<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker部署Drone</title>
    <url>/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Docker部署Drone"><a href="#Docker部署Drone" class="headerlink" title="Docker部署Drone"></a>Docker部署Drone</h1><h3 id="一、新建-GitHub-应用"><a href="#一、新建-GitHub-应用" class="headerlink" title="一、新建 GitHub 应用"></a>一、新建 GitHub 应用</h3><p>具体顺序Settings-&gt;Developer settings-&gt;OAuth Apps-&gt;New OAuth App</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155624239.png"></p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155447805.png" alt="image-20221113155447805"></p>
<p>新建完成后记住Client ID和Client secrets，后面配置需要</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155825926.png"></p>
<h3 id="二、下载drone"><a href="#二、下载drone" class="headerlink" title="二、下载drone"></a>二、下载drone</h3><pre><code class="ini">docker pull drone/drone //下载drone
</code></pre>
<h3 id="三、配置-Drone"><a href="#三、配置-Drone" class="headerlink" title="三、配置 Drone"></a>三、配置 Drone</h3><p>通过使用 <code>Docker Compose</code> 来启动 <code>Drone</code>，编写 <code>docker-compose.yml</code> 文件（这个文件直接新建就可以了）</p>
<pre><code class="ini">touch docker-compose.yml //新建文件
vim docker-compose.yml  //配置文件
</code></pre>
<pre><code class="javascript">//docker-compose.yml 文件不用修改
version: &#39;3&#39;

services:

  drone-server:
    image: drone/drone:2.3.1
    ports:
      - 443:443
      - 80:80
    volumes:
      - drone-data:/data:rw
      - ./ssl:/etc/certs
    restart: always
    environment:
      - DRONE_SERVER_HOST=$&#123;DRONE_SERVER_HOST:-https://drone.yeasy.com&#125;
      - DRONE_SERVER_PROTO=$&#123;DRONE_SERVER_PROTO:-https&#125;
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_GITHUB_SERVER=https://github.com
      - DRONE_GITHUB_CLIENT_ID=$&#123;DRONE_GITHUB_CLIENT_ID&#125;
      - DRONE_GITHUB_CLIENT_SECRET=$&#123;DRONE_GITHUB_CLIENT_SECRET&#125;

  drone-agent:
    image: drone/drone-runner-docker:1
    restart: always
    depends_on:
      - drone-server
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:rw
    environment:
      - DRONE_RPC_PROTO=http
      - DRONE_RPC_HOST=drone-server
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_RUNNER_NAME=$&#123;HOSTNAME:-demo&#125;
      - DRONE_RUNNER_CAPACITY=2
    dns: 114.114.114.114

volumes:
  drone-data:
</code></pre>
<p>新建 <code>.env</code> 文件，输入变量及其值（上面docker-compose.yml文件配置会默认读取 .env 文件变量）</p>
<pre><code class="ini">touch .env //新建文件
</code></pre>
<pre><code class="ini">//.env
# 必填 服务器地址，例如 drone.domain.com
DRONE_SERVER_HOST=
DRONE_SERVER_PROTO=https
DRONE_RPC_SECRET=secret
HOSTNAME=demo
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_ID=
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_SECRET=
</code></pre>
<pre><code class="ini">#我的配置（参考）
# 必填 服务器地址，例如 drone.domain.com
DRONE_SERVER_HOST=localhost
DRONE_SERVER_PROTO=http
DRONE_RPC_SECRET=secret
HOSTNAME=demo
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_ID=
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_SECRET=
</code></pre>
<h3 id="四、启动Drone"><a href="#四、启动Drone" class="headerlink" title="四、启动Drone"></a>四、启动Drone</h3><pre><code class="ini">docker-compose up -d
</code></pre>
<p>访问http:localhost:80（我配置的，你和我配置一样就可以打开）就成功了</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113161124001.png"></p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155240845-8325994.png"></p>
<p>等到验证完成就可以了（如果出现错误，关机重启，重新配置就可以了）</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113165243948.png"></p>
<h3 id="五、激活仓库-具体看下一篇"><a href="#五、激活仓库-具体看下一篇" class="headerlink" title="五、激活仓库(具体看下一篇)"></a>五、激活仓库(具体看下一篇)</h3><p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113171114692.png"></p>
]]></content>
      <categories>
        <category>CI/CD</category>
        <category>Docker部署Drone</category>
      </categories>
      <tags>
        <tag>drone ci</tag>
      </tags>
  </entry>
  <entry>
    <title>Apifox和Leancloud</title>
    <url>/2022/12/25/Apifox%E5%92%8CLeancloud/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Apifox和Leancloud"><a href="#Apifox和Leancloud" class="headerlink" title="Apifox和Leancloud"></a>Apifox和Leancloud</h1><blockquote>
<p>我们为什么选择Apifox和Leancloud的组合呢</p>
<p>Apifox也是一款可以模拟接口的一款工具，当然也不只可以模拟接口</p>
<p>Leancloud选择是当我们去开发一些小的应用的时候，我们降低开发成本的时候，我们就可以去选择Leancloud去当我们的平台进行数据存储，还是比较方便的。</p>
</blockquote>
<h3 id="一、Apifox下载"><a href="#一、Apifox下载" class="headerlink" title="一、Apifox下载"></a>一、Apifox下载</h3><p>访问<a href="https://www.apifox.cn/">官网</a>进行下载</p>
<p>有付费和免费的，根据需求下载</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225090853860.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225091357277.png"></p>
<p>我们可以去新建我们的项目和接口</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225092715766.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225093542358.png"></p>
<p>下面会讲如何设置和填写参数以便于和Leancloud去交互请求</p>
<h3 id="二、Leancloud注册登陆"><a href="#二、Leancloud注册登陆" class="headerlink" title="二、Leancloud注册登陆"></a>二、Leancloud注册登陆</h3><p>我们访问<a href="https://www.leancloud.cn/">官网</a>注册登陆</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225093702335.png"></p>
<p>然后来到我们的控制台创建我们的应用</p>
<p>我们可以对我们每个应用分开管理</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225093850074.png"></p>
<p>我们每个应用都有自己的信息</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094016973.png"></p>
<p>大家测试的时候可以使用自己的应用信息配置</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094046589.png"></p>
<h3 id="三、配置Apifox"><a href="#三、配置Apifox" class="headerlink" title="三、配置Apifox"></a>三、配置Apifox</h3><blockquote>
<p>当我们应用和Apifox环境准备完毕，那么我们就可以根据文档来配置了</p>
</blockquote>
<p>文档-&gt;REST API-&gt;数据存储</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094258347.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094449937.png"></p>
<h4 id="1-新建接口"><a href="#1-新建接口" class="headerlink" title="1.新建接口"></a>1.新建接口</h4><p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094537626.png"></p>
<p>在配置我们的接口的前提是要选好我们接口运行的环境</p>
<p>让我们先配置一下环境</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094638510.png"></p>
<p>我们可以将我们的服务改成我们Leancloud平台的开放服务地址（后续我们可以改成我们的域名）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094725724.png"></p>
<p>根据文档来配置</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095251514.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095213854.png"></p>
<p>Header-&gt;批量编辑-&gt;冒号模式（然后将负责的配置修改成下面这种格式就可以了）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095423023.png"></p>
<p>下一步我们来携带参数body</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095604642.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095717122.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095746960.png"></p>
<p>修改状态码并添加响应示例</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095819827.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095940926.png"></p>
<p>保存运行</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225100023787.png"></p>
<p>出error了，修复它（给body添加示例值就可以了）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225100109578.png"></p>
<h4 id="2-发起请求"><a href="#2-发起请求" class="headerlink" title="2.发起请求"></a>2.发起请求</h4><p>我们发送（响应成功）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225101014178.png"></p>
<h3 id="四、Leancloud"><a href="#四、Leancloud" class="headerlink" title="四、Leancloud"></a>四、Leancloud</h3><p>当我们查看Leancloud应用的时候，发现我们多了一张表和数据，表示我们的请求已经成功</p>
<blockquote>
<p>我们还可以根据文档来修改，查找，删除我们的数据表，代码中的配置也是一样的，这样我们就可以利用LeanCloud来搭建我们一个小应用的数据表了。</p>
</blockquote>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225101228952.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225101502303.png"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>uniapp</category>
        <category>Apifox和Leancloud</category>
      </categories>
      <tags>
        <tag>leancloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Dokcer部署Drone2</title>
    <url>/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Dokcer部署Drone2"><a href="#Dokcer部署Drone2" class="headerlink" title="Dokcer部署Drone2"></a>Dokcer部署Drone2</h1><p>这一篇延续上一篇的问题，这一篇解决仓库初始化失败（500）的问题</p>
<h3 id="一、问题原因"><a href="#一、问题原因" class="headerlink" title="一、问题原因"></a>一、问题原因</h3><p>问题在于 drone 创建 webhooks 时失败，Github 不允许创建本地 localhost 类型的 webhooks，因为这样执行时是在本地，没办法定位到具体的用户主机。可以使用 <a href="https://link.juejin.cn/?target=https://ngrok.com">ngrok</a> 这样的工具把本地服务绑定到公网。</p>
<h3 id="二、解决问题"><a href="#二、解决问题" class="headerlink" title="二、解决问题"></a>二、解决问题</h3><h4 id="1-安装ngrok"><a href="#1-安装ngrok" class="headerlink" title="1.安装ngrok"></a>1.安装ngrok</h4><p>安装ngrok的时候，mac用户默认下载的位置和终端的位置不一样，所以我们统一安装到 &#x2F;usr&#x2F;local&#x2F;bin 目录</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114110814408.png"></p>
<p>具体步骤是：</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111042057.png" alt="步骤一：解压缩文件后复制ngrok"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111257463.png" alt="步骤二：前往文件夹"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111332755.png"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111355186.png" alt="步骤三：复制ngrok，双击执行"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111451022.png" alt="进程完成"></p>
<h4 id="2-连接服务"><a href="#2-连接服务" class="headerlink" title="2.连接服务"></a>2.连接服务</h4><p>执行ngrok的密钥，连接服务</p>
<pre><code class="ini">ngrok config add-authtoken 2HW491ApRpQILMM3kwW_4T7x8zVrAXpqUEjdSGU4y
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111554074.png"></p>
<p>当出现下面的情况，就说明安装成功了，就可以使用命令了</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111712382.png"></p>
<p>如果提示没有验证邮箱，就先去验证邮箱，要不然服务会中断</p>
<h4 id="3-开启服务端口"><a href="#3-开启服务端口" class="headerlink" title="3.开启服务端口"></a>3.开启服务端口</h4><pre><code class="ini">ngrok http 80
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111950182.png"></p>
<h4 id="4-修改Drone配置（github）"><a href="#4-修改Drone配置（github）" class="headerlink" title="4.修改Drone配置（github）"></a>4.修改Drone配置（github）</h4><pre><code class="ini">#Homepage URL
https://8313-183-202-88-243.ap.ngrok.io
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114112053258.png"></p>
<p>5.修改docker-compose.yml 和 .env 文件</p>
<pre><code class="ini">vim docker-compose.yml  //配置文件
vim .env
</code></pre>
<pre><code class="javascript">//docker-compose.yml
version: &#39;3.7&#39;

services:

  drone-server:
    image: drone/drone:2.3.1
    ports:
      - 80:80
    volumes:
      - drone-data:/data:rw
      - ./ssl:/etc/certs
    restart: always
    environment:
      - DRONE_SERVER_HOST=$&#123;DRONE_SERVER_HOST:-https://drone.yeasy.com&#125;
      - DRONE_SERVER_PROTO=$&#123;DRONE_SERVER_PROTO:-https&#125;
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_GITHUB_SERVER=https://github.com
      - DRONE_GITHUB_CLIENT_ID=$&#123;DRONE_GITHUB_CLIENT_ID&#125;
      - DRONE_GITHUB_CLIENT_SECRET=$&#123;DRONE_GITHUB_CLIENT_SECRET&#125;

  drone-runner:
    image: drone/drone-runner-docker:1
    restart: always
    depends_on:
      - drone-server
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:rw
    environment:
      - DRONE_RPC_PROTO=http
      - DRONE_RPC_HOST=drone-server
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_RUNNER_NAME=$&#123;HOSTNAME:-demo&#125;
      - DRONE_RUNNER_CAPACITY=2
    dns: 114.114.114.114

volumes:
  drone-data:
</code></pre>
<pre><code class="ini">//.env
# 必填 服务器地址，例如 drone.domain.com
DRONE_SERVER_HOST=8313-183-202-88-243.ap.ngrok.io
DRONE_SERVER_PROTO=https
DRONE_RPC_SECRET=24c08d3d73e59c5d9dd5e26e3256c1f9
HOSTNAME=demo
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_ID=
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_SECRET=
</code></pre>
<h4 id="5-重启Drone"><a href="#5-重启Drone" class="headerlink" title="5.重启Drone"></a>5.重启Drone</h4><pre><code class="ini">docker-compose up -d
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114112748311.png"></p>
<p>这样我们就解决了500的问题，github上的Webhooks就启动了</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114113100300.png"></p>
]]></content>
      <categories>
        <category>CI/CD</category>
        <category>Dokcer部署Drone2</category>
      </categories>
      <tags>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title>Drone-UI挂起</title>
    <url>/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Drone-UI挂起"><a href="#Drone-UI挂起" class="headerlink" title="Drone-UI挂起"></a>Drone-UI挂起</h1><h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>当我们将.drone.yml配置文件放在项目根目录，执行</p>
<pre><code class="ini">git init //初始化仓库
git remote add origin 仓库地址 //链接远程仓库
git add . 
git commit -m &quot;xxxx&quot;
git push 仓库地址 //推送远程仓库
</code></pre>
<p>当我们将.drone.yml推送到仓库的时候，那么webhooks就会被触发，我们在drone ci页面就可以看见构建流程</p>
<p>但如果我们的.drone.yml配置失败，那么就会出现一直卡在pending上，或者构建失败</p>
<p><img src="/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/image-20221115090812831.png"></p>
<h3 id="二、修改配置文件"><a href="#二、修改配置文件" class="headerlink" title="二、修改配置文件"></a>二、修改配置文件</h3><p>1、.dron.yml文件配置和执行程序对应</p>
<p>如果没有对应配置，那么就会pending</p>
<p><img src="/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/image-20221116105118132.png"></p>
<p>举个荔枝：</p>
<pre><code class="ini">#.dron.yml
kind: pipeline
type: docker
name: deployment

platform:
  os: linux
  arch: arm64

steps:
  - name: deployment
    image: node
    commands:
      - pwd
      - ls
      - node app.js

branches: main
</code></pre>
<pre><code class="javascript">//app.js
let res = function()&#123;
    console.log(&quot;hello word&quot;)
&#125;
res()
</code></pre>
<h3 id="三、推送到远程仓库"><a href="#三、推送到远程仓库" class="headerlink" title="三、推送到远程仓库"></a>三、推送到远程仓库</h3><pre><code class="ini">git add . 
git commit -m &quot;xxxx&quot;
git push 仓库地址 //推送远程仓库
</code></pre>
<p><img src="/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/image-20221116105715577.png"></p>
<h3 id="四、查看构建结果"><a href="#四、查看构建结果" class="headerlink" title="四、查看构建结果"></a>四、查看构建结果</h3><p>构建成功</p>
<p><img src="/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/image-20221116105812556.png"></p>
<p>我们CI持续集成构建就成功了，我们可以去继续丰富我们配置文件，直到达到我们想要的结果</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Drone入门]: 	“<a href="https://0-8-0.docs.drone.io/zh/getting-started/">https://0-8-0.docs.drone.io/zh/getting-started/</a> “</p>
]]></content>
      <categories>
        <category>CI/CD</category>
        <category>Drone-UI挂起</category>
      </categories>
      <tags>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title>Vite+Vue3+Ts搭建私有组件库</title>
    <url>/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Vite-Vue3-Ts搭建私有组件库"><a href="#Vite-Vue3-Ts搭建私有组件库" class="headerlink" title="Vite+Vue3+Ts搭建私有组件库"></a>Vite+Vue3+Ts搭建私有组件库</h1><p>目前前端技术的持续发展，社区生态出现了一批比较适用的组件库，例如：ElementUI,Vant，AntDesign等，但这些组件库的组件不一定能满足我们一些项目的特定业务需求，那么我们的团队就应该建立起我们自己的组件库，方便于我们自己的业务开发，那么我们这篇文章就来了解一下我们开发组件库的大体技术架构体系。</p>
<p>搭建组件库的技术要点：</p>
<ul>
<li>如何使用pnpm搭建出一个menorepo环境</li>
<li>如何使用vite搭建一个基本的Vue3脚手架项目</li>
<li>如何开发调试一个自己的UI组件库</li>
<li>如何使用vite打包并发布自己的UI组件库</li>
</ul>
<h3 id="一、menorepo环境的搭建"><a href="#一、menorepo环境的搭建" class="headerlink" title="一、menorepo环境的搭建"></a>一、menorepo环境的搭建</h3><p>首先我们要了解什么是menorepo及它是如何搭建 (单仓库 多项目)</p>
<p>就是指在一个大的项目仓库中，管理多个模块&#x2F;包（package），这种类型的项目大都在项目根目录下有一个packages文件夹，分多个项目管理。大概结构如下：</p>
<pre><code class="ini">-- packages
  -- pkg1
    --package.json
  -- pkg2
    --package.json
--package.json
</code></pre>
<p>目前很多我们熟知的项目都是采用这种模式，如Vant，ElementUI，Vue3等。打造一个menorepo环境的工具有很多，如：lerna、pnpm、yarn等，这里我们将使用pnpm来开发我们的UI组件库</p>
<h4 id="1-使用pnpm"><a href="#1-使用pnpm" class="headerlink" title="1.使用pnpm"></a>1.使用pnpm</h4><pre><code class="ini">npm install pnpm -g //安装pnpm
pnpm init //初始化package.json
</code></pre>
<p>新建配置文件 .npmrc</p>
<pre><code class="ini">shamefully-hoist = true
</code></pre>
<p>这里简单说下为什么要配置shamefully-hoist。</p>
<p>如果某些工具仅在根目录的node_modules时才有效，可以将其设置为true来提升那些不在根目录的node_modules，就是将你安装的依赖包的依赖包的依赖包的…都放到同一级别（扁平化）。说白了就是不设置为true有些包就有可能会出问题。</p>
<p>安装对应依赖</p>
<pre><code class="ini">pnpm i vue@next typescript less -D -w //开发环境中的依赖一般全部安装在整个项目根目录下，方便下面我们每个包都可以引用,所以在安装的时候需要加个 -w
</code></pre>
<p>如果我们是在根目录下运行命令，那么就不用加 -w 了，要不然会提示</p>
<pre><code class="error">--workspace-root may only be used inside a workspace
</code></pre>
<p>配置tsconfit.json</p>
<pre><code class="ini">npx tsc --init //初始化
</code></pre>
<pre><code class="javascript">//tsconfit.json配置
&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;jsx&quot;: &quot;preserve&quot;,
    &quot;strict&quot;: true,
    &quot;target&quot;: &quot;ES2015&quot;,
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,
    &quot;esModuleInterop&quot;: true,
    &quot;moduleResolution&quot;: &quot;Node&quot;,
    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;]
  &#125;
&#125;
</code></pre>
<h4 id="2-monorepo的实现"><a href="#2-monorepo的实现" class="headerlink" title="2.monorepo的实现"></a>2.monorepo的实现</h4><p>各个项目之间能够互相引用我们要新建一个pnpm-workspace.yaml文件将我们的包关联起来</p>
<pre><code class="ini">packages:
    - &#39;packages/**&#39;
    - &#39;examples&#39;
</code></pre>
<p>这样就能将我们项目下的packages目录和examples目录关联起来了，当然如果你想关联更多目录你只需要往里面添加即可。根据上面的目录结构很显然你在根目录下新建packages和examples文件夹，packages文件夹存放我们开发的包，examples用来调试我们的组件。</p>
<p>examples文件夹就是接下来我们要使用vite搭建一个基本的Vue3脚手架项目的地方。</p>
<h4 id="3-手动搭建一个基于vite的vue3项目"><a href="#3-手动搭建一个基于vite的vue3项目" class="headerlink" title="3.手动搭建一个基于vite的vue3项目"></a>3.手动搭建一个基于vite的vue3项目</h4><p>进入examples文件夹，执行</p>
<pre><code class="ini">pnpm init //初始化仓库
pnpm install vite @vitejs/plugin-vue -D -w //安装vite和@vitejs/plugin-vue
</code></pre>
<p>配置vite.config.ts</p>
<p>新建vite.config.ts文件</p>
<pre><code class="ini">import &#123; defineConfig &#125; from &#39;vite&#39;
import vue from &#39;@vitejs/plugin-vue&#39;

export default defineConfig(&#123;
    plugins:[vue()]
&#125;)
</code></pre>
<p>新建html文件</p>
<p>@vitejs&#x2F;plugin-vue 会默认加载examples下的index.html</p>
<p>新建index.html</p>
<pre><code class="xml">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;main.ts&quot; type=&quot;module&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意：<br>vite 是基于esmodule的 所以type&#x3D;”module”</p>
<p>新建app.vue模板</p>
<pre><code class="xml">&lt;template&gt;
    &lt;div&gt;
        启动测试
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>新建main.ts</p>
<pre><code class="javascript">import &#123;createApp&#125; from &#39;vue&#39;
import App from &#39;./app.vue&#39;

const app = createApp(App)

app.mount(&#39;#app&#39;)
</code></pre>
<p>此时会发现编译器会提示个错误：找不到模块“.&#x2F;app.vue”或其相应的类型声明</p>
<p>因为直接引入.vue文件 TS会找不到对应的类型声明；所以需要新建typings（命名没有明确规定，TS会自动寻找.d.ts文件）文件夹来专门放这些声明文件。</p>
<p>typings&#x2F;vue-shim.d.ts</p>
<p>TypeScriptTS默认只认ES 模块。如果你要导入.vue文件就要declare module把他们声明出来。</p>
<pre><code class="typescript">declare module &#39;*.vue&#39; &#123;
    import type &#123; DefineComponent &#125; from &quot;vue&quot;;
    const component:DefineComponent&lt;&#123;&#125;,&#123;&#125;,any&gt;
&#125;
</code></pre>
<p>配置脚本启动项目</p>
<p>最后在package.json文件中配置scripts脚本</p>
<pre><code class="erlang">...
&quot;scripts&quot;: &#123;
    &quot;dev&quot;: &quot;vite&quot;
  &#125;,
...
</code></pre>
<p>然后终端输入我们熟悉的命令：pnpm run dev</p>
<p><img src="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/image-20221120114028908.png"></p>
<p>如果出现了cannot find module ‘node:path’这样的错误提示，那可能是node版本不兼容，升级一下node版本就可以了</p>
<p>我的node 版本是 v14.17.0 的版本，出现了不兼容的问题，于是升级到了稳定版 v16.16.0 。</p>
<p>再运行vite就没问题了</p>
<p><img src="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/image-20221120114403681.png"></p>
<h3 id="二、本地调试"><a href="#二、本地调试" class="headerlink" title="二、本地调试"></a>二、本地调试</h3><h4 id="1-新建包文件"><a href="#1-新建包文件" class="headerlink" title="1.新建包文件"></a>1.新建包文件</h4><p>往packages文件夹冲填充内容</p>
<p>一般packages要有utils包来存放我们公共方法，工具函数等</p>
<p>既然它是一个包，所以我们新建utils目录后就需要初始化它，让它变成一个包；终端进入utils文件夹执行：pnpm init 然后会生成一个package.json文件；这里需要改一下包名，我这里将name改成@alanmf&#x2F;utils表示这个utils包是属于alanmf这个组织下的。所以记住发布之前要登录npm新建一个组织；例如alanmf</p>
<p><img src="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/image-20221120152720676.png"></p>
<p>因为我们使用ts写的，所以需要将入口文件index.js改为index.ts，并新建index.ts文件:(先导出一个简单的加法函数)</p>
<p>components是我们用来存放各种UI组件的包</p>
<p>新建components文件夹并执行 pnpm init 生成package.json</p>
<ul>
<li>组件库包 这里命名为alanmf</li>
</ul>
<pre><code class="ini">&#123;
  &quot;name&quot;: &quot;@alanmf/utils&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.ts&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<p>新建index.ts入口文件并引入utils包</p>
<pre><code class="tsx">//@kitty-ui/utils
import &#123;testfun&#125; from &#39;@alanmf/utils&#39;

const result = testfun (1,1)

console.log(result)
</code></pre>
<p>由于组件库是基于ts的，所以需要安装esno来执行ts文件便于测试组件之间的引入情况</p>
<p>控制台输入esno xxx.ts即可执行ts文件</p>
<pre><code class="ini">npm i esno -g //安装esno
eson index.ts //执行index.ts文件
</code></pre>
<p><img src="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/image-20221120151321307.png"></p>
<h4 id="2-包之间本地调试"><a href="#2-包之间本地调试" class="headerlink" title="2.包之间本地调试"></a>2.包之间本地调试</h4><p>进入components文件夹执行</p>
<pre><code class="bash">pnpm install @alanmf/utils
</code></pre>
<p>你会发现pnpm会自动创建个软链接直接指向我们的utils包；此时components下的packages：</p>
<pre><code class="swift">&#123;
  &quot;name&quot;: &quot;alanmf&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.ts&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: &#123;
    &quot;@alanmf/utils&quot;: &quot;workspace:^1.0.0&quot;
  &#125;
&#125;
</code></pre>
<p>你会发现它的依赖@alanmf&#x2F;utils对应的版本为：workspace:^1.0.0；因为pnpm是由workspace管理的，所以有一个前缀workspace可以指向utils下的工作空间从而方便本地调试各个包直接的关联引用。</p>
<p>到这里基本开发方法我们已经知道啦；接下来就要进入正题了，开发一个button组件</p>
<h3 id="三、开发一个button组件"><a href="#三、开发一个button组件" class="headerlink" title="三、开发一个button组件"></a>三、开发一个button组件</h3><h4 id="1-创建一个测试组件"><a href="#1-创建一个测试组件" class="headerlink" title="1.创建一个测试组件"></a>1.创建一个测试组件</h4><p>在components文件夹下新建src,同时在src下新建button组件目录和icon组件目录(新建icon为了便于调试);此时components文件目录如下</p>
<pre><code class="lua">-- components
  -- src
    -- button
    -- icon
    -- index.ts
-- package.json
</code></pre>
<p>让我们先测试一下我们的button组件能否在我们搭建的examples下的vue3项目本引用~</p>
<p>首先在button下新建一个简单的button.vue</p>
<pre><code class="xml">&lt;template&gt;
    &lt;button&gt;测试按钮&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>然后在button&#x2F;index.ts将其导出</p>
<pre><code class="javascript">import Button from &#39;./button.vue&#39;

export default Button
</code></pre>
<p>因为我们开发组件库的时候不可能只有button，所以我们需要一个components&#x2F;index.ts将我们开发的组件一个个的集中导出</p>
<pre><code class="javascript">import Button from &#39;./button&#39;

export &#123;
    Button
&#125;
</code></pre>
<p>好了，一个组件的大体目录差不多就是这样了，接下来请进入我们的examples来看看能否引入我们的button组件</p>
<h4 id="2-测试项目引入"><a href="#2-测试项目引入" class="headerlink" title="2.测试项目引入"></a>2.测试项目引入</h4><p>上面已经说过执行在workspace执行 pnpm i xxx的时候pnpm会自动创建个软链接直接指向我们的xxx包。</p>
<p>所以这里我们直接在examples执行：pnpm i alanmf</p>
<p>此时你就会发现packages.json的依赖多了个</p>
<pre><code class="json">&quot;alanmf&quot;: &quot;workspace:^1.0.0&quot;
</code></pre>
<p>这时候我们就能直接在我们的测试项目下引入我们本地的components组件库了，启动我们的测试项目，来到我们的 examples&#x2F;app.vue 直接引入Button</p>
<pre><code class="xml">&lt;template&gt;
    &lt;div&gt;
        &lt;Button /&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script lang=&quot;ts&quot; setup&gt;
import &#123; Button &#125; from &#39;alanmf/src&#39;
&lt;/script&gt;
</code></pre>
<p>不出意外的话你的页面就会展示我们刚刚写的button组件了</p>
<p>接下来的工作就是专注于组件的开发了；让我们回到我们的button组件目录下（测试页面不用关，此时我们已经可以边开发边调试边看效果了）</p>
<h4 id="3-types-ts文件规范组件属性"><a href="#3-types-ts文件规范组件属性" class="headerlink" title="3.types.ts文件规范组件属性"></a>3.types.ts文件规范组件属性</h4><p>我们的button组件是需要接收很多属性的，如type、size等等，所以我们要新建个types.ts文件来规范这些属性</p>
<p>在button目录下新建types.ts</p>
<pre><code class="tsx">
import &#123; ExtractPropTypes &#125; from &#39;vue&#39;


export const ButtonType = [&#39;default&#39;, &#39;primary&#39;, &#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;]

export const ButtonSize = [&#39;large&#39;, &#39;normal&#39;, &#39;small&#39;, &#39;mini&#39;];


export const buttonProps = &#123;
  type: &#123;
    type: String,
    values: ButtonType
  &#125;,
  size: &#123;
    type: String,
    values: ButtonSize
  &#125;
&#125;

export type ButtonProps = ExtractPropTypes&lt;typeof buttonProps&gt;
</code></pre>
<p>import type 表示只导入类型；ExtractPropTypes是vue3中内置的类型声明,它的作用是接收一个类型，然后把对应的vue3所接收的props类型提供出来，后面有需要可以直接使用</p>
<p>很多时候我们在vue中使用一个组件会用的app.use 将组件挂载到全局。要使用app.use函数的话我们需要让我们的每个组件都提供一个install方法，app.use()的时候就会调用这个方法;</p>
<p>我们将button&#x2F;index.ts调整为</p>
<pre><code class="typescript">import button from &#39;./button.vue&#39;
import type &#123;App,Plugin&#125; from &quot;vue&quot;
type SFCWithInstall&lt;T&gt; = T&amp;Plugin
const withInstall = &lt;T&gt;(comp:T) =&gt; &#123;
    (comp as SFCWithInstall&lt;T&gt;).install = (app:App)=&gt;&#123;
        //注册组件
        app.component((comp as any).name,comp)
    &#125;
    return comp as SFCWithInstall&lt;T&gt;
&#125;
const Button = withInstall(button)
export default Button
</code></pre>
<p>此时我们就可以使用app.use来挂载我们的组件啦</p>
<p>其实withInstall方法可以做个公共方法放到工具库里，因为后续每个组件都会用到，这里等后面开发组件的时候再调整</p>
<p>到这里组件开发的基本配置已经完成，最后我们对我们的组件库以及工具库进行打包，打包之前如果要发公共包的话记得将我们的各个包的协议改为MIT开源协议</p>
<pre><code class="python-repl">...
&quot;license&quot;: &quot;MIT&quot;,
...
</code></pre>
<h3 id="四、vite打包"><a href="#四、vite打包" class="headerlink" title="四、vite打包"></a>四、vite打包</h3><h4 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h4><p>打包们这里选择vite，它有一个库模式专门为我们来打包这种库组件的。</p>
<p>前面已经安装过vite了，所以这里直接在components下直接新建vite.config.ts(配置参数文件中已经注释):</p>
<pre><code class="json">import &#123; defineConfig &#125; from &quot;vite&quot;;
import vue from &quot;@vitejs/plugin-vue&quot;
export default defineConfig(
    &#123;
        build: &#123;
            target: &#39;modules&#39;,
            //打包文件目录
            outDir: &quot;es&quot;,
            //压缩
            minify: false,
            //css分离
            //cssCodeSplit: true,
            rollupOptions: &#123;
                //忽略打包vue文件
                external: [&#39;vue&#39;],
                input: [&#39;src/index.ts&#39;],
                output: [
                    &#123;
                        format: &#39;es&#39;,
                        //不用打包成.es.js,这里我们想把它打包成.js
                        entryFileNames: &#39;[name].js&#39;,
                        //让打包目录和我们目录对应
                        preserveModules: true,
                        //配置打包根目录
                        dir: &#39;es&#39;,
                        preserveModulesRoot: &#39;src&#39;
                    &#125;,
                    &#123;
                        format: &#39;cjs&#39;,
                        entryFileNames: &#39;[name].js&#39;,
                        //让打包目录和我们目录对应
                        preserveModules: true,
                        //配置打包根目录
                        dir: &#39;lib&#39;,
                        preserveModulesRoot: &#39;src&#39;
                    &#125;
                ]
            &#125;,
            lib: &#123;
                entry: &#39;./index.ts&#39;,
                formats: [&#39;es&#39;, &#39;cjs&#39;]
            &#125;
        &#125;,
        plugins: [
            vue()
        ]
    &#125;
)
</code></pre>
<p>这里我们选择打包cjs(CommonJS)和esm(ESModule)两种形式,cjs模式主要用于服务端引用(ssr),而esm就是我们现在经常使用的方式，它本身自带treeShaking而不需要额外配置按需引入(前提是你将模块分别导出)</p>
<h4 id="2-vite打包"><a href="#2-vite打包" class="headerlink" title="2.vite打包"></a>2.vite打包</h4><p>到这里就已经可以直接打包了；components下执行： pnpm run build你就会发现打包了es和lib两个目录</p>
<p><img src="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/image-20221120165853742.png"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[私有仓库搭建源码]: 	“<a href="https://github.com/mengfeng/alanmf_ui.git">https://github.com/mengfeng/alanmf_ui.git</a> “</p>
]]></content>
      <categories>
        <category>工程技术</category>
        <category>Vite+Vue3+Ts搭建私有组件库</category>
      </categories>
      <tags>
        <tag>组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>Vite+Vue3+Ts搭建私有组件库2</title>
    <url>/2022/11/21/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%932/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Vite-Vue3-Ts搭建私有组件库2"><a href="#Vite-Vue3-Ts搭建私有组件库2" class="headerlink" title="Vite+Vue3+Ts搭建私有组件库2"></a>Vite+Vue3+Ts搭建私有组件库2</h1><p>本文章只供参考，具体实现可能会有出入（会尽快完善）</p>
<h3 id="一、vite打包"><a href="#一、vite打包" class="headerlink" title="一、vite打包"></a>一、vite打包</h3><p>上一篇末尾的打包还是有缺陷的，打包的组件库只能给js项目使用,在ts项目下运行会出现一些错误，而且使用的时候还会失去代码提示功能，这样的话我们就失去了用ts开发组件库的意义了。所以我们需要在打包的库里加入声明文件(.d.ts)。</p>
<p>那么如何向打包后的库里加入声明文件呢？ 其实很简单，只需要引入 vite-plugin-dts</p>
<pre><code class="css">pnpm i vite-plugin-dts -D -w
</code></pre>
<p>如果pnpm命令一直error，用其他命令下载安装也是一样的（下载到根目录）</p>
<p>然后修改一下我们的vite.config.ts引入这个插件</p>
<pre><code class="javascript">//components/vite.config.ts
import &#123; defineConfig &#125; from &quot;vite&quot;;
import vue from &quot;@vitejs/plugin-vue&quot;
import dts from &#39;vite-plugin-dts&#39;

export default defineConfig(
    &#123;
        build: &#123;...&#125;,
        plugins: [
            vue(),
            dts(&#123;
                //指定使用的tsconfig.json为我们整个项目根目录下掉,如果不配置,你也可以在components下新建tsconfig.json
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;),
            //因为这个插件默认打包到es下，我们想让lib目录下也生成声明文件需要再配置一个
            dts(&#123;
                outputDir:&#39;lib&#39;,
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;)

        ]
    &#125;
)
</code></pre>
<p>执行pnpm run build你就会发现你的es和lib下就有了声明文件</p>
<h3 id="二、组件样式"><a href="#二、组件样式" class="headerlink" title="二、组件样式"></a>二、组件样式</h3><p>首先我们需要做的是将less打包成css然后放到打包后对应的文件目录下,我们在components下新建build文件夹来存放我们的一些打包工具,然后新建buildLess.ts,首先我们需要先安装一些工具cpy和fast-glob</p>
<pre><code class="css">pnpm i cpy fast-glob -D -w
</code></pre>
<p>它可以直接复制我们规定的文件并将我们的文件copy到指定目录,比如buildLess.ts:</p>
<pre><code class="javascript">//build/buildLess.ts
import cpy from &#39;cpy&#39;
import &#123; resolve &#125; from &#39;path&#39;

const sourceDir = resolve(__dirname, &#39;../src&#39;)
//lib文件
const targetLib = resolve(__dirname, &#39;../lib&#39;)
//es文件
const targetEs = resolve(__dirname, &#39;../es&#39;)
console.log(sourceDir);
const buildLess = async () =&gt; &#123;
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetLib)
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetEs)
&#125;
buildLess()
</code></pre>
<p>然后在package.json中新增命令</p>
<pre><code class="erlang">...
&quot;scripts&quot;: &#123;
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;build:less&quot;: &quot;esno build/buildLess&quot;
  &#125;,
...
</code></pre>
<p>终端执行 pnpm run build:less 你就会发现lib和es文件对应目录下就出现了less文件.(如果error，切换node版本)</p>
<p>但是我们最终要的并不是less文件而是css文件,所以我们要将less打包成css,所以我们需要用的less模块.在ts中引入less因为它本身没有声明文件所以会出现类型错误,所以我们要先安装它的 @types&#x2F;less</p>
<pre><code class="css">pnpm i --save-dev @types/less -D -w
</code></pre>
<p>buildLess.ts如下(详细注释都在代码中)</p>
<pre><code class="javascript">import cpy from &#39;cpy&#39;
import &#123; resolve &#125; from &#39;path&#39;
import &#123; promises as fs &#125; from &quot;fs&quot;
import less from &quot;less&quot;
import glob from &quot;fast-glob&quot;
const sourceDir = resolve(__dirname, &#39;../src&#39;)
//lib文件目录
const targetLib = resolve(__dirname, &#39;../lib&#39;)
//es文件目录
const targetEs = resolve(__dirname, &#39;../es&#39;)



const buildLess = async () =&gt; &#123;
    //直接将less文件复制到打包后目录
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetLib)
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetEs)

    //获取打包后.less文件目录(lib和es一样)
    const lessFils = await glob(&quot;**/*.less&quot;, &#123; cwd: targetLib, onlyFiles: true &#125;)

    //遍历含有less的目录
    for (let path in lessFils) &#123;
        const lessPathLib = `$&#123;targetLib&#125;/$&#123;lessFils[path]&#125;`
        const lessPathEs = `$&#123;targetEs&#125;/$&#123;lessFils[path]&#125;`

        //获取less文件字符串
        const lessCode = await fs.readFile(lessPathLib, &#39;utf-8&#39;)
        //将less解析成css
        const code = await less.render(lessCode)

        //拿到.css后缀path
        const cssPathLib = lessPathLib.replace(&#39;.less&#39;, &#39;.css&#39;)
        const cssPathEs = lessPathEs.replace(&#39;.less&#39;, &#39;.css&#39;)

        //将css写入对应目录
        await fs.writeFile(cssPathLib, code.css)
        await fs.writeFile(cssPathEs, code.css)
    &#125;



&#125;
buildLess()
</code></pre>
<p>执行打包命令之后你会发现对应文件夹下多了.css文件</p>
<p><img src="/2022/11/21/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%932/image-20221121092003205.png"></p>
<p>现在我已经将css文件放入对应的目录下了,但是我们的相关组件并没有引入这个css文件;所以我们需要的是每个打包后组件的index.js中出现如:</p>
<pre><code class="cpp">import &quot;xxx/xxx.css&quot;
</code></pre>
<p>之类的代码我们的css才会生效;所以我们需要对vite.config.ts进行相关配置</p>
<p>首先我们先将.less文件忽略external: [‘vue’, &#x2F;.less&#x2F;],这时候打包后的文件中如button&#x2F;index.js就会出现</p>
<pre><code class="cpp">import &quot;./style/index.less&quot;;
</code></pre>
<p>然后我们再将打包后代码的.less换成.css就大功告成了</p>
<pre><code class="typescript">...
plugins: [
            ...

            &#123;
                name: &#39;style&#39;,
                generateBundle(config, bundle) &#123;
                    //这里可以获取打包后的文件目录以及代码code
                    const keys = Object.keys(bundle)

                    for (const key of keys) &#123;
                        const bundler: any = bundle[key as any]
                        //rollup内置方法,将所有输出文件code中的.less换成.css,因为我们当时没有打包less文件

                        this.emitFile(&#123;
                            type: &#39;asset&#39;,
                            fileName: key,//文件名名不变
                            source: bundler.code.replace(/\.less/g, &#39;.css&#39;)
                        &#125;)
                    &#125;
                &#125;
            &#125;
        ...
        ]
...
</code></pre>
<p>我们最终的vite.config.ts如下</p>
<pre><code class="typescript">import &#123; defineConfig &#125; from &quot;vite&quot;;
import vue from &quot;@vitejs/plugin-vue&quot;
import dts from &#39;vite-plugin-dts&#39;

export default defineConfig(
    &#123;
        build: &#123;
            target: &#39;modules&#39;,
            //打包文件目录
            outDir: &quot;es&quot;,
            //压缩
            minify: false,
            //css分离
            //cssCodeSplit: true,
            rollupOptions: &#123;
                //忽略打包vue和.less文件
                external: [&#39;vue&#39;, /\.less/],
                input: [&#39;src/index.ts&#39;],
                output: [
                    &#123;
                        format: &#39;es&#39;,
                        //不用打包成.es.js,这里我们想把它打包成.js
                        entryFileNames: &#39;[name].js&#39;,
                        //让打包目录和我们目录对应
                        preserveModules: true,
                        //配置打包根目录
                        dir: &#39;es&#39;,
                        preserveModulesRoot: &#39;src&#39;
                    &#125;,
                    &#123;
                        format: &#39;cjs&#39;,
                        //不用打包成.mjs
                        entryFileNames: &#39;[name].js&#39;,
                        //让打包目录和我们目录对应
                        preserveModules: true,
                        //配置打包根目录
                        dir: &#39;lib&#39;,
                        preserveModulesRoot: &#39;src&#39;
                    &#125;
                ]
            &#125;,
            lib: &#123;
                entry: &#39;./index.ts&#39;,
                formats: [&#39;es&#39;, &#39;cjs&#39;]
            &#125;
        &#125;,




        plugins: [
            vue(),
            dts(&#123;
                //指定使用的tsconfig.json为我们整个项目根目录下掉,如果不配置,你也可以在components下新建tsconfig.json
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;),
            //因为这个插件默认打包到es下，我们想让lib目录下也生成声明文件需要再配置一个
            dts(&#123;
                outputDir: &#39;lib&#39;,
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;),

            &#123;
                name: &#39;style&#39;,
                generateBundle(config, bundle) &#123;
                    //这里可以获取打包后的文件目录以及代码code
                    const keys = Object.keys(bundle)

                    for (const key of keys) &#123;
                        const bundler: any = bundle[key as any]
                        //rollup内置方法,将所有输出文件code中的.less换成.css,因为我们当时没有打包less文件

                        this.emitFile(&#123;
                            type: &#39;asset&#39;,
                            fileName: key,//文件名名不变
                            source: bundler.code.replace(/\.less/g, &#39;.css&#39;)
                        &#125;)
                    &#125;
                &#125;
            &#125;

        ]
    &#125;
)
</code></pre>
<p>最后我们将打包less与打包组件合成一个命令(package.json):</p>
<pre><code class="erlang">...
&quot;scripts&quot;: &#123;
     &quot;build&quot;:&quot;vite build&quot;,
    &quot;build:less&quot;: &quot;esno build/buildLess&quot;
  &#125;,
...
</code></pre>
<p>后续直接执行pnpm run build 即可完成所有打包啦</p>
<h3 id="三、引用ui包"><a href="#三、引用ui包" class="headerlink" title="三、引用ui包"></a>三、引用ui包</h3><p>做了那么多终于到发布的阶段了；其实npm发包是很容易的，就拿我们的组件alanmf举例吧</p>
<p>发布之前记得到<a href="https://www.npmjs.com/">npm</a>官网注册个账户,如果你要发布@xx&#x2F;xx这种包的话需要在npm新建个组织组织组织名就是@后面的，比如我建的组织就是kitty-ui,注册完之后你就可以发布了</p>
<p>首先要将我们代码提交到git仓库，不然pnpm发布无法通过，后面每次发版记得在对应包下执行 <strong>pnpm version patch</strong>你就会发现这个包的版本号patch(版本号第三个数) +1 了</p>
<p>如果你发布的是公共包的话，在对应包下执行</p>
<pre><code class="cpp">pnpm publish --access public
</code></pre>
<p>输入你的账户和密码（记得输入密码的时候是不显示的，不要以为卡了）正常情况下应该是发布成功了</p>
<p><strong>注意</strong></p>
<p>发布的时候要将npm的源切换到npm的官方地址(<a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>); 如果你使用了其它镜像源的话</p>
]]></content>
      <categories>
        <category>工程技术</category>
        <category>Vite+Vue3+Ts搭建私有组件库2</category>
      </categories>
      <tags>
        <tag>私有组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron-d-3.0</title>
    <url>/2022/11/26/Electron-d-3-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Electron-d-3-0"><a href="#Electron-d-3-0" class="headerlink" title="Electron-d-3.0"></a>Electron-d-3.0</h1><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><p>上一篇我们讲解了主进程的一些常用API，这一篇我们接着来讲解渲染进程的API</p>
<h3 id="1-剪切板（clipboard）"><a href="#1-剪切板（clipboard）" class="headerlink" title="1.剪切板（clipboard）"></a>1.剪切板（clipboard）</h3><blockquote>
<p>在系统剪贴板上执行复制和粘贴操作。</p>
<p>主进程和渲染进程都可以用。</p>
</blockquote>
<p>（1）<code>clipboard.readText([type])</code></p>
<ul>
<li><code>type</code> string (optional) -可以是 <code>selection</code> 或 <code>clipboard</code>; 默认为 ‘clipboard’. <code>selection</code> 仅在 Linux 中可用。</li>
</ul>
<p>返回 <code>string</code> - 剪贴板中的内容为纯文本。</p>
<pre><code class="javascript">const &#123; clipboard &#125; = require(&#39;electron&#39;)

clipboard.writeText(&#39;hello i am a bit of text!&#39;)

const text = clipboard.readText()
console.log(text)
// hello i am a bit of text!&#39;
</code></pre>
<p>（2）<code>clipboard.writeText(text[, type])</code></p>
<ul>
<li><code>text</code> string</li>
<li><code>type</code> string (optional) -可以是 <code>selection</code> 或 <code>clipboard</code>; 默认为 ‘clipboard’. <code>selection</code> 仅在 Linux 中可用。</li>
</ul>
<p>将 <code>text</code> 作为纯文本写入剪贴板。</p>
<pre><code class="javascript">const &#123; clipboard &#125; = require(&#39;electron&#39;)

const text = &#39;hello i am a bit of text!&#39;
clipboard.writeText(text)
</code></pre>
<p>我们剪切板的API就说这两个读与写。但是我在渲染进程里读不到clipboard。</p>
<p>[clipboard文档]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/clipboard">https://www.electronjs.org/zh/docs/latest/api/clipboard</a> “</p>
<h3 id="2-contextBridge"><a href="#2-contextBridge" class="headerlink" title="2.contextBridge"></a>2.contextBridge</h3><p>在隔离的上下文中创建一个安全的、双向的、同步的桥梁。</p>
<p>如下，是一个从隔离的预加载脚本将 API 暴露给渲染器的示例：（通过预加载脚本暴露API，渲染进程可以读取）</p>
<pre><code class="javascript">// Preload (Isolated World)
const &#123; contextBridge, ipcRenderer &#125; = require(&#39;electron&#39;)

contextBridge.exposeInMainWorld(
  &#39;electron&#39;,
  &#123;
    doThing: () =&gt; ipcRenderer.send(&#39;do-a-thing&#39;)
  &#125;
)
</code></pre>
<pre><code class="javascript">// Renderer (Main World)

window.electron.doThing()
</code></pre>
<p>[contextBridge文档]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/context-bridge">https://www.electronjs.org/zh/docs/latest/api/context-bridge</a> “</p>
<h3 id="3-desktopCapturer"><a href="#3-desktopCapturer" class="headerlink" title="3.desktopCapturer"></a>3.desktopCapturer</h3><p>官方文档给的案例不是特别容易理解，代码有点长。</p>
<blockquote>
<p>虽然官方文档的主进程和渲染进程都有desktopCapturer，但是渲染进程是访问不到的</p>
</blockquote>
<p>我们举一个抓取页面内容的荔枝吧！</p>
<p><img src="/2022/11/26/Electron-d-3-0/image-20221126093410069.png"></p>
<pre><code class="javascript">//main.js+
 ipcMain.handle(&#39;capture-event&#39;,async (event,args)=&gt;&#123;
      return  desktopCapturer.getSources(&#123; types: [&#39;window&#39;, &#39;screen&#39;] &#125;).then( sources =&gt; &#123;
        return sources
      &#125;)
 &#125;)
//解释一下，desktopCapturer.getSources返回的是一个Promise的对象
</code></pre>
<pre><code class="javascript">//preload.js+

  const capture = async ()=&gt;&#123;
    let res = await ipcRenderer.invoke(&#39;capture-event&#39;)
    console.log(res)
  &#125;
  
  contextBridge.exposeInMainWorld(&#39;electronAPI&#39;, &#123;
    capture
&#125;)
</code></pre>
<pre><code class="javascript">//app.js+
const btn = document.getElementById(&#39;btn&#39;)
btn.addEventListener(&#39;click&#39;,()=&gt;&#123;
    window.electronAPI.capture()
&#125;)
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
    &lt;title&gt;capture&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button id=&quot;btn&quot;&gt;capture&lt;/button&gt;
    &lt;script src=&#39;./renderer/app.js&#39;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>当我们点击页面上的按钮的时候，我们就会打印出窗口信息，由下图可以看出sources是一个数组</p>
<p><img src="/2022/11/26/Electron-d-3-0/image-20221126093927866.png"></p>
<p>我们现在就可以根据我们获取到的信息去干一些事情了。</p>
<pre><code class="javascript">//preload.js+
  const capture = async ()=&gt;&#123;
    let sources = await ipcRenderer.invoke(&#39;capture-event&#39;)
    for (const source of sources) &#123;
      if (source.name === &#39;electron&#39;) &#123;
        let str = source.thumbnail.crop(&#123;x:0,y:0,width:300,height:300&#125;)
        let imgUrl = str.toDataURL()
        return imgUrl //返回的是一个Promise
      &#125;
    &#125;
  &#125;

  contextBridge.exposeInMainWorld(&#39;electronAPI&#39;, &#123;
    handleCounter: (callback) =&gt; ipcRenderer.on(&#39;update-counter&#39;, callback),
    capture,
&#125;)
</code></pre>
<pre><code class="javascript">//app.js+
const btn = document.getElementById(&#39;btn&#39;)
btn.addEventListener(&#39;click&#39;,async ()=&gt;&#123;
   let imgUrl = await window.electronAPI.capture()
   console.log(imgUrl)
&#125;)
</code></pre>
<p><img src="/2022/11/26/Electron-d-3-0/image-20221126100006800.png"></p>
<p>我们在渲染进程这就已经拿到了我们的数据</p>
<p>接下来我们就将我们的数据填充到我们的页面之中</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;;img-src * data:&quot;&gt;
    &lt;title&gt;Menu Counter&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- Current value: &lt;strong id=&quot;counter&quot;&gt;0&lt;/strong&gt; --&gt;
    &lt;button id=&quot;btn&quot;&gt;capture&lt;/button&gt;
    &lt;img src=&quot;&quot; alt=&quot;捕获数据&quot; id=&quot;img&quot;&gt;
    &lt;script src=&#39;./renderer/app.js&#39;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="javascript">//app.js+
const btn = document.getElementById(&#39;btn&#39;)

btn.addEventListener(&#39;click&#39;,async ()=&gt;&#123;
   let imgUrl = await window.electronAPI.capture()
   document.getElementById(&#39;img&#39;).src = imgUrl
&#125;)
</code></pre>
<p><img src="/2022/11/26/Electron-d-3-0/image-20221126101223120.png"></p>
<p>恭喜你！！！成功了🥳🥳🥳</p>
<p>[desktopCapturer文档]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/desktop-capturer&quot;">https://www.electronjs.org/zh/docs/latest/api/desktop-capturer&quot;</a></p>
<h3 id="4-nativeImage"><a href="#4-nativeImage" class="headerlink" title="4.nativeImage"></a>4.nativeImage</h3><blockquote>
<p>使用 PNG 或 JPG 文件创建托盘、dock和应用程序图标。</p>
<p>主进程和渲染进程都可以用。</p>
</blockquote>
<p>在 Electron 内, 那些需要图片的 API 可以传递两种参数, 一种是文件路径, 一种是 <code>NativeImage</code> 实例对象。 空的图片对象将被 <code>null</code> 参数替代</p>
<p>例如, 创建托盘或设置窗口图标时, 你可以传递 <code>string</code> 格式的图片路径</p>
<pre><code class="javascript">const &#123; BrowserWindow, Tray &#125; = require(&#39;electron&#39;)

const appIcon = new Tray(&#39;/Users/somebody/images/icon.png&#39;)
const win = new BrowserWindow(&#123; icon: &#39;/Users/somebody/images/window.png&#39; &#125;)
console.log(appIcon, win)
</code></pre>
<p>或者从粘贴板读取图片，将返回 <code>NativeImage</code> 对象：</p>
<pre><code class="javascript">const &#123; clipboard, Tray &#125; = require(&#39;electron&#39;)
const image = clipboard.readImage()
const appIcon = new Tray(image)
console.log(appIcon)
</code></pre>
<p>我们文档里还有其他的一些关于NativeImage对象的属性和方法，我们就哪里需要哪里搬。</p>
<p>[nativeImage文档]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/native-image">https://www.electronjs.org/zh/docs/latest/api/native-image</a> “</p>
<p>到目前为止，我们对于electron的学习先到这，如果我的这几篇文章都认认真真的看完了，那么我们也对electron有了进一步认识。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Electron官网]: 	“<a href="https://www.electronjs.org/">https://www.electronjs.org/</a> “</p>
]]></content>
      <categories>
        <category>Electron</category>
        <category>Electron-d-3.0</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-eventBus</title>
    <url>/2022/12/23/Vue-eventBus/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Vue-eventBus"><a href="#Vue-eventBus" class="headerlink" title="Vue-eventBus"></a>Vue-eventBus</h1><p>父子组件通信与兄弟组件通信</p>
<p>vue组件非常常见的有父子组件通信，兄弟组件通信。</p>
<pre><code>父子组件通信：方法有很多，比如：父组件通过 props 向下传数据给子组件，子组件通过 $emit 告诉父组件。
兄弟组件通信：如果两个页面没有任何引入和被引入关系，需要额外的组件来通信，如：事件总线、Vuex。
</code></pre>
<h3 id="一、事件总线是什么"><a href="#一、事件总线是什么" class="headerlink" title="一、事件总线是什么"></a>一、事件总线是什么</h3><p>EventBus 又称为事件总线。在Vue中可以使用 EventBus 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件。</p>
<pre><code>EventBus若使用不慎，就会造成难以维护的“灾难”，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。 
</code></pre>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>解决了多层组件之间繁琐的事件传播。<br>使用原理十分简单，代码量少</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的EventBus会被移除，这样就导致业务走不下去。<br>如果业务有反复操作的页面，EventBus在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理EventBus在项目中的关系。通常在vue页面销毁时，同时移除EventBus事件监听。</p>
<p>由于是都使用一个Vue实例，所以容易出现重复触发的情景：两个页面都定义了同一个事件名，并且没有用$off销毁（常出现在路由切换时）。</p>
<h3 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h3><h4 id="1-创建事件"><a href="#1-创建事件" class="headerlink" title="1.创建事件"></a>1.创建事件</h4><p>首先需要创建事件总线并将其导出，以便其它模块可以使用或者监听它。</p>
<p>方法1、非全局事件组件</p>
<p> 新建EventBus.js</p>
<pre><code class="javascript">import Vue from &#39;vue&#39;
export const EventBus = new Vue()
</code></pre>
<p>法2、全局事件组件</p>
<p>在项目中的 main.js 初始化 EventBus。在main.js添加如下一行：</p>
<pre><code class="javascript">Vue.prototype.$EventBus = new Vue()
</code></pre>
<p>示例：</p>
<pre><code class="vue">import Vue from &#39;vue&#39;
import App from &#39;./App&#39;
import router from &#39;./router&#39;

Vue.config.productionTip = false

Vue.prototype.$EventBus = new Vue();

/* eslint-disable no-new */
new Vue(&#123;
  el: &#39;#app&#39;,
  router,
  components: &#123; App &#125;,
  template: &#39;&lt;App/&gt;&#39;
&#125;)
</code></pre>
<p>组件发送事件：this.$EventBus.$emit(…)</p>
<p>组件接收事件：this.$EventBus.$on(…)</p>
<p>移除事件</p>
<p>一般在销毁组件（也就是离开组件）时移除事件。</p>
<pre><code class="javascript">beforeDestroy()&#123;
  EventBus.$off(&quot;eventName&quot;)
&#125;
</code></pre>
<p>EventBus.$off()                           &#x2F;&#x2F;移除EventBus所有事件监听器</p>
<p>EventBus.$off(‘eventName’)       &#x2F;&#x2F;移除’eventName’事件所有监听器</p>
<p>EventBus.$off(‘eventName’, callback)    &#x2F;&#x2F;只移除这个回调的监听器。</p>
<h4 id="2-事件运用"><a href="#2-事件运用" class="headerlink" title="2.事件运用"></a>2.事件运用</h4><p>本文父组件：CompA.vue，子组件1：ChildOne.vue，子组件2：ChildTwo.vue。子组件1发送事件给父组件和子组件2。</p>
<pre><code class="javascript">router/index.js

import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import CompA from &quot;@/components/CompA&quot;;

Vue.use(Router)

export default new Router(&#123;
  routes: [
    &#123;
      path: &#39;/compA&#39;,
      name: &#39;compA&#39;,
      component: CompA,
    &#125;
  ],
&#125;)
</code></pre>
<p>1.创建EventBus</p>
<p> 新建EventBus.js</p>
<pre><code class="javascript">import Vue from &#39;vue&#39;
export const EventBus = new Vue()
</code></pre>
<p>2.发送事件</p>
<p> components&#x2F;ChildOne.vue</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;childOne&quot;&gt;
    &lt;h1&gt;childOne&lt;/h1&gt;
    &lt;button @click=&quot;sendEvent2CompA&quot;&gt;发送事件给父组件（CompA）&lt;/button&gt;
    &lt;button @click=&quot;sendEvent2ChildTwo&quot;&gt;发送事件给兄弟组件（ChildTwo）&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;EventBus&#125; from &quot;./EventBus&quot;

export default &#123;
  data() &#123;
    return &#123;
      count1: 0,
      count2: 0,
    &#125;
  &#125;,
  methods:&#123;
    sendEvent2CompA() &#123;
      this.count1++;
      EventBus.$emit(&quot;compA&quot;, &quot;compA事件触发次数：&quot; + this.count1)
    &#125;,
    sendEvent2ChildTwo() &#123;
      this.count2++;
      EventBus.$emit(&quot;childTwo&quot;, &quot;childTwo事件触发次数：&quot; + this.count2)
    &#125;
  &#125;
&#125;
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<p>3.接收事件</p>
<p>父组件：components&#x2F;CompA.vue</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;compA&quot;&gt;
    &lt;h1&gt;compA&lt;/h1&gt;
    compA收到的事件内容：&#123;&#123;msg&#125;&#125;&lt;hr&gt;
    &lt;child-one&gt;&lt;/child-one&gt;&lt;hr&gt;
    &lt;child-two&gt;&lt;/child-two&gt;

  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;EventBus&#125; from &quot;./EventBus&quot;
import ChildOne from &quot;@/components/ChildOne&quot;;
import ChildTwo from &quot;@/components/ChildTwo&quot;;

export default &#123;
  components: &#123;ChildOne, ChildTwo&#125;,
  data() &#123;
    return &#123;
      msg: &quot;&quot;,
    &#125;
  &#125;,
  mounted() &#123;
    EventBus.$on(&quot;compA&quot;, (payload1)=&gt; &#123;
      this.msg = payload1;
    &#125;)
  &#125;
&#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>子组件2：components&#x2F;ChildTwo.vue</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;childTwo&quot;&gt;
    &lt;h1&gt;childTwo&lt;/h1&gt;
    childTwo收到的事件内容：&#123;&#123;msg&#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;EventBus&#125; from &quot;./EventBus&quot;

export default &#123;
  data() &#123;
    return &#123;
      msg: &quot;&quot;,
    &#125;
  &#125;,
  mounted() &#123;
    EventBus.$on(&quot;childTwo&quot;, (payload1)=&gt; &#123;
      this.msg = payload1;
    &#125;)
  &#125;
&#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>事物都有两面性，没有好坏之分，且全在于使用者，好钢用在刀刃上，不滥用即可。有其他更好的方式则优先使用。</p>
]]></content>
      <categories>
        <category>uniapp</category>
        <category>Vue-eventBus</category>
      </categories>
      <tags>
        <tag>eventBus</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3+Ts+Vite+Pinia组合的高效开发套件</title>
    <url>/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Vue3-Ts-Vite-Pinia组合的高效开发套件"><a href="#Vue3-Ts-Vite-Pinia组合的高效开发套件" class="headerlink" title="Vue3+Ts+Vite+Pinia组合的高效开发套件"></a>Vue3+Ts+Vite+Pinia组合的高效开发套件</h1><p>2022年最受欢迎的组合</p>
<h3 id="一、Vite和Webpack区别"><a href="#一、Vite和Webpack区别" class="headerlink" title="一、Vite和Webpack区别"></a>一、Vite和Webpack区别</h3><ul>
<li>webpack是一个JavaScript应用程序的静态模块打包工具，它会对整个应用程序进行依赖关系图构建。</li>
<li>vite是构建工具的高阶封装，使用简单，快（开发的时候感觉没有编译过程），便于扩展。而他集成的esbuild(Go 编写) 预构建依赖，比node快 10-100 倍。</li>
</ul>
<p>区别：</p>
<h4 id="1-关注层级不同"><a href="#1-关注层级不同" class="headerlink" title="1.关注层级不同"></a>1.关注层级不同</h4><p>vite关注的层级更高：vite是 high level api，关注的是如何快速方便的搭建项目，相比webpack，减少了很多配置量。</p>
<p>webpack关注的层级更低：webpack是low level api，因为webpack更关注的是各种功能的实现，重点放在构建上。</p>
<h4 id="2-vite自己不包含编译能力。"><a href="#2-vite自己不包含编译能力。" class="headerlink" title="2.vite自己不包含编译能力。"></a>2.vite自己不包含编译能力。</h4><p>它本身并不参与编译，它的编译能力只是集成了rollup和ESbuild的功能.</p>
<h4 id="3-启动项目vite更快，可以说是超级快。"><a href="#3-启动项目vite更快，可以说是超级快。" class="headerlink" title="3.启动项目vite更快，可以说是超级快。"></a>3.启动项目vite更快，可以说是超级快。</h4><p>对比webpack在dev-serve的时候，会提交所有编译的文件，而vite在dev-serve的时候利用了浏览器的native ES module功能，在浏览器请求对应的url时才提供文件，实现了根据路由的懒加载，所以启动的时候是超快的。</p>
<h4 id="4-vite的热更新更快。"><a href="#4-vite的热更新更快。" class="headerlink" title="4.vite的热更新更快。"></a>4.vite的热更新更快。</h4><p>对比webpack的热更新，热更新时，把改动过模块的相关依赖模块全部编译一次。而vite热更新时，仅让浏览器重新请求改动过的模块。</p>
<p>现在公司项目从webpack过渡到vite,还在不断摸索爬坑中，虽然目前vite的生态不如webpack丰富，且实用的开发者也不及webpack。<br>但是不可否认的是，相比于webpack, vite非常适合项目的开发，webpack适合工具的开发。</p>
<ul>
<li><p>vite为构建项目而生</p>
</li>
<li><p>webpack为构建工具而生</p>
</li>
</ul>
<h3 id="二、Pinia和Vuex"><a href="#二、Pinia和Vuex" class="headerlink" title="二、Pinia和Vuex"></a>二、Pinia和Vuex</h3><p>Pinia是Vue生态里Vuex的代替者，一个全新Vue的状态管理库。在Vue3成为正式版以后，尤雨溪强势推荐的项目就是Pinia。</p>
<p>Pinia 是 Vue.js 的轻量级状态管理库，它使用 Vue 3 中的新反应系统来构建一个直观且完全类型化的状态管理库。<br>Vuex也是为Vue框架建立的一个流行的状态管理库，它也是Vue核心团队推荐的状态管理库。 Vuex高度关注应用程序的可扩展性、开发人员的工效和信心。它基于与redux相同的流量架构。Pinia 完整的符合了当时 Vuex5 提案所提到的功能点。</p>
<h4 id="Pinia-和-Vuex"><a href="#Pinia-和-Vuex" class="headerlink" title="Pinia 和 Vuex"></a>Pinia 和 Vuex</h4><p>Vuex： <code>State</code>、<code>Gettes</code>、<code>Mutations</code>(同步)、<code>Actions</code>(异步)</p>
<p>Pinia： <code>State</code>、<code>Gettes</code>、<code>Actions</code>(同步异步都支持)</p>
<h4 id="Pinia-核心特性"><a href="#Pinia-核心特性" class="headerlink" title="Pinia 核心特性"></a>Pinia 核心特性</h4><ul>
<li><p>Pinia 没有 <code>Mutations</code></p>
</li>
<li><p><code>Actions</code> 支持同步和异步</p>
</li>
<li><p>没有模块的嵌套结构</p>
</li>
<li><ul>
<li>Pinia 通过设计提供扁平结构，就是说每个 store 都是互相独立的，谁也不属于谁，也就是扁平化了，更好的代码分割且没有命名空间。当然你也可以通过在一个模块中导入另一个模块来隐式嵌套 store，甚至可以拥有 store 的循环依赖关系</li>
</ul>
</li>
<li><p>更好的 <code>TypeScript</code> 支持 </p>
</li>
<li><ul>
<li>不需要再创建自定义的复杂包装器来支持 TypeScript 所有内容都类型化，并且 API 的设计方式也尽可能的使用 TS 类型推断</li>
</ul>
</li>
<li><p>不需要注入、导入函数、调用它们，享受自动补全，让我们开发更加方便</p>
</li>
<li><p>无需手动添加 store，它的模块默认情况下创建就自动注册的</p>
</li>
<li><p>Vue2 和 Vue3 都支持 </p>
</li>
<li><ul>
<li>除了初始化安装和SSR配置之外，两者使用上的API都是相同的</li>
</ul>
</li>
<li><p>支持 <code>Vue DevTools</code></p>
</li>
<li><ul>
<li>跟踪 actions, mutations 的时间线</li>
<li>在使用了模块的组件中就可以观察到模块本身</li>
<li>支持 time-travel 更容易调试</li>
<li>在 Vue2 中 Pinia 会使用 Vuex 的所有接口，所以它俩不能一起使用</li>
<li>但是针对 Vue3 的调试工具支持还不够完美，比如还没有 time-travel 功能</li>
</ul>
</li>
<li><p>模块热更新 </p>
</li>
<li><ul>
<li>无需重新加载页面就可以修改模块</li>
<li>热更新的时候会保持任何现有状态</li>
</ul>
</li>
<li><p>支持使用插件扩展 Pinia 功能</p>
</li>
<li><p>支持服务端渲染</p>
</li>
</ul>
<h3 id="三、Vite生成Vue3脚手架"><a href="#三、Vite生成Vue3脚手架" class="headerlink" title="三、Vite生成Vue3脚手架"></a>三、Vite生成Vue3脚手架</h3><pre><code class="ini">npm create vite@latest //构建vite+vue
npm i //下载依赖
npm run dev //启动项目
</code></pre>
<p><img src="/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/image-20221119091852577.png"></p>
<p><img src="/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/image-20221119101610847.png"></p>
<h3 id="四、集成pinia"><a href="#四、集成pinia" class="headerlink" title="四、集成pinia"></a>四、集成pinia</h3><pre><code class="ini">npm install pinia //安装pinia
</code></pre>
<p>pinia简单使用</p>
<p><img src="/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/image-20221119150910678.png"></p>
<p>1.在main.ts中注册pinia</p>
<pre><code class="tsx">//main.ts
import &#123; createApp &#125; from &#39;vue&#39;
import &#39;./style.css&#39;
import App from &#39;./App.vue&#39;
import &#123;createPinia&#125; from &#39;pinia&#39; 

createApp(App).use(createPinia()).mount(&#39;#app&#39;)
</code></pre>
<p>2.创建src&#x2F;type&#x2F;user.d.ts</p>
<pre><code class="tsx">// 用户的类型声明文件
interface IUser &#123;
    name: string;
    age: number;
&#125;  
</code></pre>
<p>3.创建src&#x2F;store&#x2F;user.ts</p>
<pre><code class="tsx">//user.ts
import &#123; defineStore &#125; from &quot;pinia&quot;;
 
export default defineStore(&quot;user&quot;, &#123;
  state() &#123;
    return &#123;
      userList: [] as IUser[],
    &#125;;
  &#125;,
  actions: &#123;
    getList() &#123;
      // 模拟从后端获取数据
      let resList: IUser[] = [
        &#123; name: &quot;孟峰&quot;, age: 24 &#125;,
        &#123; name: &quot;孟一&quot;, age: 19 &#125;
      ];
      this.userList = resList;
    &#125;,
  &#125;,
&#125;);
</code></pre>
<p>4.创建src&#x2F;store&#x2F;index.ts</p>
<pre><code class="tsx">//index.ts
import useUserStore from &quot;./user&quot;;
 
export default function useStore() &#123;
  return &#123;
    user: useUserStore(),
  &#125;;
&#125;
</code></pre>
<p>5.App.vue使用</p>
<pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;
// 从状态层导出指定模块
import useStore from &quot;./store&quot;;
const &#123; user &#125; = useStore();
// 获取用户列表
user.getList();
&lt;/script&gt;
 
&lt;template&gt;
  &lt;div&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;item in user.userList&quot;&gt;
        姓名：&#123;&#123; item.name &#125;&#125; ---- 年龄：&#123;&#123; item.age &#125;&#125;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><img src="/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/image-20221119151532682.png"></p>
<h3 id="五、集成pretter和eslint"><a href="#五、集成pretter和eslint" class="headerlink" title="五、集成pretter和eslint"></a>五、集成pretter和eslint</h3><pre><code class="ini">npm i prettier -D //安装prettier
npm i eslint -D //安装eslint
npx eslint --init //初始化eslint
</code></pre>
<p>根目录创建<code>.prettierrc.js</code>文件</p>
<pre><code class="javascript">//.prettierrc.js
module.exports = &#123;
    printWidth: 140,// 超过最大值换行
    tabWidth: 4, // tab键宽度，默认为4
    useTabs: true,// 使用tab（制表符）缩进而非空格
    singleQuote: true,// 用单引号代替双引号
    semi: true,// 行末是否加分号
    trailingComma: &#39;none&#39;,// 最后一个对象元素加逗号
    bracketSpacing: true,// 对象，数组加空格
    jsxBracketSameLine: true, // jsx &gt; 是否另起一行
  
  &#125;;
</code></pre>
<pre><code class="js">//.eslintrc.cjs
module.exports = &#123;
  root: true,
  env: &#123;
    browser: true,
    node: true,
    es6: true,
    commonjs: true,
    amd: true
  &#125;,
  // ts eslint 配置
  parserOptions: &#123;
    parser:&#39;@typescript-eslint/parser&#39;,
  &#125;,
  plugins: [&#39;@typescript-eslint&#39;],
  extends: [&#39;plugin:vue/vue3-recommended&#39;,&#39;plugin:prettier/recommended&#39;,&#39;prettier/@typescript-eslint&#39;,&#39;plugin:@typescript-eslint/recommended&#39;],
  // js eslint 配置
  // parserOptions: &#123;
  //   parser: &#39;babel-eslint&#39;,
  //   sourceType: &#39;module&#39;
  // &#125;,
  // plugins: [&#39;html&#39;, &#39;vue&#39;],
  // extends: [&#39;plugin:vue/recommended&#39;, &#39;eslint:recommended&#39;],
 
  rules: &#123;
    &#39;max-len&#39;: &#39;off&#39;,
     // 统一豁免规则，原因：直接修改可能对现有功能产生影响
     &#39;eqeqeq&#39;: 1,
    //  &#39;vue/no-v-html&#39;: 1,
     // 其中代码本身有问题的规则错误有
     &#39;no-undef&#39;: 0,
     &#39;import/no-duplicates&#39;: 0,
 
     // 可能引起格式化问题但建议手动修改代码的有
     &#39;no-plusplus&#39;: 0,
     &#39;no-eval&#39;: 0,
     &#39;no-prototype-builtins&#39;: 0,
     &#39;no-multi-assign&#39;: 0,
     &#39;no-unused-vars&#39;: 0,
     &#39;no-useless-escape&#39;: 0,
     &#39;camelcase&#39;: 0,
     &#39;vue/no-unused-components&#39;: 0,
     &#39;vue/return-in-computed-property&#39;: 0,
     &#39;no-param-reassign&#39;: 0,
     &#39;prefer-const&#39;: 0,
     &#39;prefer-destructuring&#39;: 0,
     &#39;no-underscore-dangle&#39;: 0,
     &#39;no-restricted-syntax&#39;: 0,
     &#39;no-nested-ternary&#39;: 0,
     &#39;radix&#39;: 0,
     &#39;vue/no-side-effects-in-computed-properties&#39;: 0,
     &#39;vue/order-in-components&#39;: 0,
     &#39;function-paren-newline&#39;: 0,
  &#125;,
&#125;;
</code></pre>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[git仓库项目源码]: 	“<a href="https://github.com/mengfeng/vite-vue3-pinia-ts">https://github.com/mengfeng/vite-vue3-pinia-ts</a> “<br>[Vite中文官网]: 		“<a href="https://cn.vitejs.dev/">https://cn.vitejs.dev</a> “<br>[pinia中文官网]: 	“<a href="https://pinia.web3doc.top/getting-started.html#%E5%AE%89%E8%A3%85">https://pinia.web3doc.top/getting-started.html#安装</a> “</p>
]]></content>
      <categories>
        <category>工程技术</category>
        <category>Vue3+Ts+Vite+Pinia组合的高效开发套件</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>blender基本操作</title>
    <url>/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Blender基本操作"><a href="#Blender基本操作" class="headerlink" title="Blender基本操作"></a>Blender基本操作</h1><blockquote>
<p>虽然我们是程序员一枚，但是，既然学了3D那么我们就要拓展我们的技能</p>
<p>那么这篇文章就来讲讲这款免费的3维软件<a href="https://www.blender.org/">Blender</a>（英文版）</p>
<p>你要问我C4d和Blender哪个好（Blender是免费的，不要钱）要是不差钱也可以玩玩oc渲染器（比较香）</p>
<p>具体操作还得看视频，我今天就总结一些快捷键</p>
</blockquote>
<h3 id="一、安装软件"><a href="#一、安装软件" class="headerlink" title="一、安装软件"></a>一、安装软件</h3><p>下载—安装</p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205093244288.png" alt="image-20221205093244288"></p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205094355133.png"></p>
<h3 id="二、更改配置"><a href="#二、更改配置" class="headerlink" title="二、更改配置"></a>二、更改配置</h3><p>更改页面语言，如果需要更改为简体中文的话（如果找不到配置了，改为简体中文后就方便了）</p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205094539463.png"></p>
<h3 id="三、界面快捷键"><a href="#三、界面快捷键" class="headerlink" title="三、界面快捷键"></a>三、界面快捷键</h3><p>这些快捷键有点多，加油（当然，你也可以根据你的习惯去修改你的快捷键）</p>
<p>具体步骤如图所示：</p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205094948395.png"></p>
<blockquote>
<p>我建议，在你选择直接使用快捷键的时候，尽量先去了解界面，快捷键是提高工作效率的首选，但初学者还是要先熟悉软件的界面操作，再逐步的去熟悉我们大量的快捷键来提高我们的工作效率。</p>
<p>在一些情况下，快捷键却会让你行云流水的操作变得生硬</p>
</blockquote>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205094730873.png"></p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205101434727.png"></p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205104621343.png"></p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205142035840.png"></p>
<blockquote>
<p>其他快捷键我们都可以去视频练习哦</p>
<p>最后，一款双语切换插件给你们</p>
</blockquote>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[blender基础操作]: 	“<a href="https://www.youtube.com/watch?v=prQj0xVwMeo&amp;list=PL3bztmH9zKvv4sjPb6PJyLgULvQYJ8e0f&amp;index=4&quot;">https://www.youtube.com/watch?v=prQj0xVwMeo&amp;list=PL3bztmH9zKvv4sjPb6PJyLgULvQYJ8e0f&amp;index=4&quot;</a><br>[双语切换]: 	“<a href="https://github.com/Mister-Kin/ToggleLanguage/releases/tag/v1.1&quot;">https://github.com/Mister-Kin/ToggleLanguage/releases/tag/v1.1&quot;</a><br>[双语切换]: 	“<a href="https://mister-kin.github.io/manuals/toggle-language/">https://mister-kin.github.io/manuals/toggle-language/</a> “</p>
]]></content>
      <categories>
        <category>Web3D</category>
        <category>blender</category>
        <category>blender基本操作</category>
      </categories>
      <tags>
        <tag>blender</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3api变化</title>
    <url>/2022/12/16/Vue3api%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><blockquote>
<p>官网地址：<a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a><br>vue最新版分为两个版本： Vue3.0（20年9月18日） Vue 3.2 （21年8月10日）</p>
</blockquote>
<h3 id="Vue-3-2-Vite-volar"><a href="#Vue-3-2-Vite-volar" class="headerlink" title="Vue 3.2 +Vite+volar"></a><strong>Vue 3.2 +Vite+volar</strong></h3><ul>
<li>Vue3 框架做了大量的性能优化，包括虚拟 DOM，编译模板、代理的新数据监听，体积更小的打包文件等。</li>
<li>新的组合式 API （composition-api），更适合大型项目的构建，去除繁琐的 this 操作；</li>
<li>由于是基于 TypeScript 编写，对 TypeScript 原生支持更好，更强大的智能类型推导功能；</li>
<li>生命周期的一些改变，vue2 中的 beforeCreate 和 created 被一个新增的 setup 生命周期函数代替；</li>
<li>一些常见 API 如 v-model 的变化，支持对一个组件同时进行多个 v-model 的数据绑定。</li>
</ul>
<p>vscode 的插件 vetur 对vue3 的composition API语法支持度非常弱，所以开发vue3项目需要将vetur禁用 更换另一个插件</p>
<p>开发vue3安装并使用： volar 插件</p>
<h3 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h3><p>Vite 官网：<a href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a></p>
<pre><code class="json">yarn create vite my-vue-app --template vue     
</code></pre>
<h3 id="2-SFC-单文件组件"><a href="#2-SFC-单文件组件" class="headerlink" title="2.SFC 单文件组件"></a>2.SFC 单文件组件</h3><blockquote>
<p>html 部分变化不大<br>vue2的 template 中只能有一个子节点，vue3的 template 中可以写多个子节点<br>js 部分内置ts，但是vite创建的项目没有开启 ， <code>&lt;script lang=&quot;ts&quot; setup&gt;</code> 这样写即可支持ts<br>新增setup 语法糖，js代码大量简化<br>代码中不再出现 <code>this</code><br>css 代码中 可以使用v-bind 指令</p>
</blockquote>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
       let color = &#39;#f60&#39;;
&lt;/script&gt;

&lt;style scoped&gt;
.box&#123;
  width: 100px;
  height: 100px;
  background: v-bind(color);
&#125;
&lt;/style&gt;
</code></pre>
<h3 id="2-setup语法糖"><a href="#2-setup语法糖" class="headerlink" title="2. setup语法糖"></a>2. setup语法糖</h3><p>起初 Vue3.0 暴露变量必须 return 出来，template中才能使用； 这样会导致在页面上变量会出现很多次。</p>
<p>vue3.2只需在script标签中添加setup,可以帮助我们解决这个问题。</p>
<p>1.组件只需引入不用注册，属性和方法也不用返回， 也不用写setup函数，也不用写export default ， 甚至是自定义指令也可以在我们的template中自动获得。</p>
<h2 id="3-data-定义"><a href="#3-data-定义" class="headerlink" title="3.data 定义"></a>3.data 定义</h2><h3 id="3-1-直接定义-无响应式"><a href="#3-1-直接定义-无响应式" class="headerlink" title="3.1 直接定义 无响应式"></a>3.1 直接定义 无响应式</h3><pre><code class="html">&lt;template&gt;
  &lt;div&gt;
      &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;
      &lt;!-- 这里双向绑定失效，直接定义变量没有响应式特性 --&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  let name = &#39;张麻子&#39;;

&lt;/script&gt;
</code></pre>
<h3 id="3-2-ref-定义基本数据类型-有响应式"><a href="#3-2-ref-定义基本数据类型-有响应式" class="headerlink" title="3.2 ref 定义基本数据类型 有响应式"></a>3.2 ref 定义基本数据类型 有响应式</h3><pre><code class="html">&lt;template&gt;
  &lt;div&gt;
      &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;
       &lt;!-- 修改数据 有响应式 --&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;
      &lt;button @click=&quot;setData&quot;&gt;修改数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
 import &#123;ref&#125; from &#39;vue&#39;;   
    
 let name = ref(&#39;张麻子&#39;);
   //js中修改数据有响应式
 const setData = ()=&gt;&#123;
     name.value = &#39;黄四郎&#39;
 &#125;
     
&lt;/script&gt;
</code></pre>
<h3 id="3-3-reactvie-定义引用数据类型-有响应式"><a href="#3-3-reactvie-定义引用数据类型-有响应式" class="headerlink" title="3.3 reactvie 定义引用数据类型 有响应式"></a>3.3 reactvie 定义引用数据类型 有响应式</h3><pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
      &lt;h2&gt;&#123;&#123;user.name&#125;&#125;&lt;/h2&gt;
      &lt;!-- 修改数据 有响应式 --&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt;
      &lt;!-- 新增属性 --&gt;
      &lt;button @click=&quot;addItem&quot;&gt;新增属性&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import &#123;ref,reactive&#125; from &#39;vue&#39;
let user = reactive(&#123;
  name:&#39;张麻子&#39;,
  age:40
&#125;)
// js中新增对象属性-可以直接赋值和修改（有响应式），在ts环境下，vscode会提示错误，但在页面中可以正常渲染
const addItem = ()=&gt;&#123;
  user.like=&#39;打豆豆&#39;
&#125;

&lt;/script&gt;
</code></pre>
<h2 id="4-methods-方法定义"><a href="#4-methods-方法定义" class="headerlink" title="4.methods 方法定义"></a>4.methods 方法定义</h2><pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 年龄 + --&gt;
    &lt;h1&gt;&#123;&#123;user.age&#125;&#125;&lt;/h1&gt;
    &lt;!-- 调用方法 --&gt;
    &lt;button @click=&quot;addAge&quot;&gt;年龄+&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import &#123; ref, reactive &#125; from &quot;vue&quot;;

let user = reactive(&#123;
  name: &quot;张麻子&quot;,
  age: 40,
&#125;);
//方法
const addAge=()=&gt;&#123;
    user.age++;
&#125;
//方法调用方法
const getUserInfo=()=&gt;&#123;
  addAge()
  console.log(user.age)
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="5-computed-计算属性"><a href="#5-computed-计算属性" class="headerlink" title="5.computed 计算属性"></a>5.computed 计算属性</h2><pre><code class="java">&lt;script setup&gt;
import &#123; ref, reactive, computed &#125; from &quot;vue&quot;;

let user = reactive(&#123;
  name: &quot;张麻子&quot;,
  age: 40,
&#125;);
//计算属性
const getAge = computed(()=&gt;&#123;
  return &#39;我的年龄&#39;+user.age
&#125;)
&lt;/script&gt;
</code></pre>
<h2 id="6-watch-使用"><a href="#6-watch-使用" class="headerlink" title="6.watch 使用"></a>6.watch 使用</h2><pre><code class="json">watch(监听数据源,执行函数,[配置参数])    
//配置参数： 立即执行 深度监听
&#123;immediate: true, deep: true &#125;
</code></pre>
<h3 id="6-1-监听基本数据类型单一数据源"><a href="#6-1-监听基本数据类型单一数据源" class="headerlink" title="6.1 监听基本数据类型单一数据源"></a>6.1 监听基本数据类型单一数据源</h3><pre><code class="javascript">&lt;script setup&gt;
import &#123;ref, watch&#125; from &#39;vue&#39;
 let name = ref(&#39;张麻子&#39;)

 //监听器
watch(name,(newVal,oldVal)=&gt;&#123;
    console.log(&#39;变量发生了改变...&#39;,newVal);
&#125;)
&lt;/script&gt;
</code></pre>
<h3 id="6-2-监听引用数据类型单一数据源"><a href="#6-2-监听引用数据类型单一数据源" class="headerlink" title="6.2 监听引用数据类型单一数据源"></a>6.2 监听引用数据类型单一数据源</h3><pre><code class="java">&lt;script setup&gt;
import &#123;reactive, ref, watch&#125; from &#39;vue&#39;
let user = reactive(&#123;name:&#39;张三&#39;,age:14&#125;)
 //监听器
watch(()=&gt;user.name,(newVal,oldVal)=&gt;&#123;
  console.log(&#39;对象user中的name属性发生了变化..&#39;,newVal);
&#125;)
&lt;/script&gt;
</code></pre>
<h3 id="6-3-监听引用数据类型-多数据源-深度监听"><a href="#6-3-监听引用数据类型-多数据源-深度监听" class="headerlink" title="6.3 监听引用数据类型 多数据源[深度监听]"></a>6.3 监听引用数据类型 多数据源[深度监听]</h3><pre><code class="java">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;addNum()&quot;&gt; 添加随机数&lt;/button&gt;
    &lt;div v-for=&quot;item in nums&quot; :key=&quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import &#123; reactive, ref, watch &#125; from &#39;vue&#39;
let nums = reactive([]);

//添加随机数
const addNum = () =&gt; &#123;
  let num = Math.ceil(Math.random() * 100);
  nums.push(num);
&#125;
//监听数组变化-深度监听
watch(()=&gt;nums,(newVal,oldVal)=&gt;&#123;
    console.log(&#39;nums数组发生了变化..&#39;,newVal);
&#125;,&#123;deep:true&#125;)

&lt;/script&gt;
</code></pre>
<h2 id="7-生命周期"><a href="#7-生命周期" class="headerlink" title="7.生命周期"></a>7.生命周期</h2><table>
<thead>
<tr>
<th>vue2</th>
<th>vue3.0</th>
<th>vue3.2</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td></td>
<td>setup</td>
<td>组件创建之前 可以获取顶级实例对象</td>
</tr>
<tr>
<td>created</td>
<td></td>
<td>setup</td>
<td>组件创建完成，可以获取变量</td>
</tr>
<tr>
<td>beforeMount</td>
<td></td>
<td>onBeforeMount</td>
<td>挂载前，VNdom创建完成，真实dom未渲染</td>
</tr>
<tr>
<td>mounted</td>
<td></td>
<td>onMounted</td>
<td>挂载完成，真实dom创建完成，可以获取dom</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td></td>
<td>onBeforeUpdate</td>
<td>dom更新前触发</td>
</tr>
<tr>
<td>updated</td>
<td></td>
<td>onUpdated</td>
<td>dom更新完成触发</td>
</tr>
<tr>
<td>beforedestroy，destroyed</td>
<td>beforeUnmount</td>
<td>onBeforeUnmount</td>
<td>组件卸载后触发 所有的挂载的数据 子组件全部卸载后触发</td>
</tr>
<tr>
<td></td>
<td>errorCaptured</td>
<td>onErrorCaptured</td>
<td>在捕获一个来自后代组件的错误时被调用</td>
</tr>
<tr>
<td></td>
<td>renderTracked</td>
<td>onRenderTracked</td>
<td>跟踪虚拟 DOM 重新渲染时调用</td>
</tr>
<tr>
<td></td>
<td>renderTriggered</td>
<td>onRenderTriggered</td>
<td>当虚拟 DOM 重新渲染被触发时调用</td>
</tr>
<tr>
<td>activated</td>
<td>activated</td>
<td>onActivated</td>
<td>缓存组件激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>deactivated</td>
<td>onDeactivated</td>
<td>缓存组件失活时调用</td>
</tr>
</tbody></table>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
      &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import &#123; onMounted &#125; from &#39;vue&#39;;
  //生命周期钩子监听
  onMounted(()=&gt;&#123;
    console.log(document.querySelector(&#39;.box&#39;)); //可以获取dom
  &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="8-组件使用"><a href="#8-组件使用" class="headerlink" title="8.组件使用"></a>8.组件使用</h2><ul>
<li>创建 src&#x2F;components&#x2F;Son.vue</li>
<li>App.vue中导入并使用该组件</li>
</ul>
<p>vue3.2 中当我们导入子组件时，setup语法糖会自动去注册该组件，所以注册语句不用写了。</p>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
    &lt;son&gt;&lt;/son&gt;
  &lt;/div&gt;
&lt;script setup&gt;
import Son from &#39;./components/Son.vue&#39;
&lt;/script&gt;
</code></pre>
<h2 id="9-组件通信"><a href="#9-组件通信" class="headerlink" title="9.组件通信"></a>9.组件通信</h2><h3 id="9-1-父传子-defineProps"><a href="#9-1-父传子-defineProps" class="headerlink" title="9.1 父传子 defineProps"></a>9.1 父传子 defineProps</h3><ul>
<li>父组件</li>
</ul>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
      &lt;Son class=&quot;box&quot; title=&quot;我是父组件传递的标题&quot; :likes=&quot;likes&quot;&gt;&lt;/Son&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  import Son from &#39;./components/Son.vue&#39;
  let likes = [&#39;张三&#39;,&#39;李四&#39;]
&lt;/script&gt;
</code></pre>
<ul>
<li>子组件</li>
</ul>
<pre><code class="java">&lt;script setup&gt;
const props=defineProps(&#123;
    title:&#123;
        type:String,
        default:&#39;&#39;
    &#125;,
    likes:&#123;
        type:Array,
        default:()=&gt;[]
    &#125;
&#125;)
&lt;/script&gt;
</code></pre>
<h3 id="9-2-子传父-defineEmits"><a href="#9-2-子传父-defineEmits" class="headerlink" title="9.2 子传父 defineEmits"></a>9.2 子传父 defineEmits</h3><ul>
<li>子组件</li>
</ul>
<pre><code class="java">&lt;template&gt;
    &lt;div&gt;
        &lt;button @click=&quot;sendData&quot;&gt;传递数据&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
//定义自定义事件
const emit = defineEmits([&#39;send&#39;])
//自己的事件执行函数
const sendData = () =&gt; &#123;
    //执行自定义事件
    emit(&#39;send&#39;, &#39;我是儿子组件传递的数据&#39;)
&#125;
&lt;/script&gt;
</code></pre>
<ul>
<li>父组件</li>
</ul>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
      &lt;Son class=&quot;box&quot;  @send=&quot;getData&quot; &gt;&lt;/Son&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  import Son from &#39;./components/Son.vue&#39;
  //触发自定义事件-接收数据
  const getData = (data)=&gt;&#123;
    console.log(data);
  &#125;
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>Vue3</category>
        <category>Vue3api变化</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>c4d及其oc的安装和初始化设置</title>
    <url>/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="C4d-amp-amp-OC"><a href="#C4d-amp-amp-OC" class="headerlink" title="C4d &amp;&amp; OC"></a>C4d &amp;&amp; OC</h1><p>我们这篇文章是基于Mac Book Pro M1 Max芯片条件下运行的</p>
<p>（建议玩三维oc的同学还是再拥有一台windows比较好）</p>
<blockquote>
<p>今天我们来学习另一款三维软件C4d，我们上面的文章介绍了blender，也说了C4d和blender的区别。</p>
<p>C4d触及到了版权问题和付费服务，但是还是有许多人热衷于C4d和我们大名鼎鼎的oc渲染器。</p>
<p>blender（开源免费功能全）</p>
<p>下面我们就来讲讲C4d和oc的安装初始化设置</p>
</blockquote>
<p>我们先来看一下oc渲染器输出的效果</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/WechatIMG113.jpeg"></p>
<h3 id="一、软件的安装"><a href="#一、软件的安装" class="headerlink" title="一、软件的安装"></a>一、软件的安装</h3><blockquote>
<p>C4D软件下载方式二选一<br>网页不限速下载地址01：<a href="https://www.yuque.com/docs/share/42f77525-e323-4343-8b75-947b896f9b99#">https://www.yuque.com/docs/share/42f77525-e323-4343-8b75-947b896f9b99?#</a></p>
<p>百度网盘下载地址02：<a href="https://pan.baidu.com/s/14HfYqsok_VNNTpqgM2lisg">https://pan.baidu.com/s/14HfYqsok_VNNTpqgM2lisg</a><br>提取码：ocye</p>
</blockquote>
<p>不要下载到有中文目录的地方</p>
<p>下载完成之后里面有安装的教学视频，我简单的表述一下</p>
<p>1.点进链接，选择我们需要的版本下载即可</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206150700879.png"></p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206150832632.png"></p>
<p>2.安装软件</p>
<p>打开之后，双击安装Cinema 4D Installer即可（按照引导安装，安装完要打开一次）</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/wps1.jpg"></p>
<p>按Quit即可</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/wps2.jpg"></p>
<h3 id="二、软件的汉化"><a href="#二、软件的汉化" class="headerlink" title="二、软件的汉化"></a>二、软件的汉化</h3><p>将汉化补丁拖进C4的界面就可以了（记得拖动的时候需要按住shift）</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/wps3.jpg"></p>
<p>如果需要更新软件</p>
<p>将Chinese_26010_202204041.c4dupdate拖到界面更新即可</p>
<p>点击进入软件</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206151636591.png"></p>
<p>软件安装及其汉化完成</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206151746346.png"></p>
<h3 id="三、oc渲染器的下载和安装"><a href="#三、oc渲染器的下载和安装" class="headerlink" title="三、oc渲染器的下载和安装"></a>三、oc渲染器的下载和安装</h3><p>进入这一步我们首先需要科学上网（你懂的）</p>
<p>1.账户注册</p>
<p>我们先要注册一个<a href="https://home.otoy.com/render/octane-render/">oc官网</a>的账户</p>
<p>这个我们根据提示填写信息和邮箱验证就可以了</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206152135014.png"></p>
<p>2.下载oc（正版的哈，需要花钱的）</p>
<p>我们点击Downloads，进入下载界面，我们可以根据我们所使用的软件和系统来选择下载我们的软件</p>
<p>（目前好像M1可以试用一年）如果不行需要你登录，那你就交钱吧哈哈哈</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206152728362.png"></p>
<p>下载之后解压文件</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206153213703.png"></p>
<p>3.安装oc</p>
<p>mac用户使用这个建议使用一个稳定的软件版本，要不然会经常崩溃</p>
<p>这个oc是个插件，我们以后安装插件差不多都是这个流程</p>
<p>找到我们的安装目录，如果里面没有plugins就新建一个</p>
<p>将我们解压好的oc文件夹复制到我们的plugins里面</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206153420489.png"></p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206153443318.png"></p>
<p>oc的文件夹里面有适配的c4d版本</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206153650012.png"></p>
<p>重新打开我们的c4d软件，我们就可以看见oc了</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206153951543.png"></p>
<h3 id="四、oc渲染器的订阅流程"><a href="#四、oc渲染器的订阅流程" class="headerlink" title="四、oc渲染器的订阅流程"></a>四、oc渲染器的订阅流程</h3><p>登陆进我们的官网，点击导航栏的shop，我们就看到了购买界面，有按年来算的，和按月来算，如果你是要长期使用oc</p>
<p>那么年度订阅那肯定是便宜的（一个月现在涨价了，以前是150多，现在170多）可以使用支付宝支付</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206154143787.png"></p>
<p>然后购买完成，我们返回我们的软件界面，登陆账号，就可以使用oc了</p>
<p>有条件的再配个屏幕吧，这个太小了</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206155104428.png"></p>
<h3 id="五、oc渲染器的初始化设置"><a href="#五、oc渲染器的初始化设置" class="headerlink" title="五、oc渲染器的初始化设置"></a>五、oc渲染器的初始化设置</h3><p>实时渲染的设置就这些，其他的可以看<a href="https://www.bilibili.com/video/BV1944y1Q7zY/?spm_id_from=333.999.0.0&amp;vd_source=e6ad490de8a011714c955dbf8a265e32">这里</a></p>
<p>目前新版的mac下的oc没有汉化补丁，所以看起来会不习惯一些</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206160326384.png"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[新版oc设置]: 	“<a href="https://www.bilibili.com/video/BV1944y1Q7zY/?spm_id_from=333.999.0.0&amp;vd_source=e6ad490de8a011714c955dbf8a265e32&quot;">https://www.bilibili.com/video/BV1944y1Q7zY/?spm_id_from=333.999.0.0&amp;vd_source=e6ad490de8a011714c955dbf8a265e32&quot;</a><br>[oc官网]: 	“<a href="https://home.otoy.com/render/octane-render/&quot;">https://home.otoy.com/render/octane-render/&quot;</a></p>
]]></content>
      <categories>
        <category>Web3D</category>
        <category>C4d</category>
        <category>c4d及其oc的安装和初始化设置</category>
      </categories>
      <tags>
        <tag>c4d</tag>
        <tag>oc</tag>
      </tags>
  </entry>
  <entry>
    <title>chatGPT注册</title>
    <url>/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="chatGPT注册、登陆具体流程"><a href="#chatGPT注册、登陆具体流程" class="headerlink" title="chatGPT注册、登陆具体流程"></a>chatGPT注册、登陆具体流程</h1><blockquote>
<p>需要科学上网</p>
<p>由于目前推广期间，chatGPT只要注册openai就可以免费使用chatGPT</p>
</blockquote>
<h3 id="一、进入chatGPT的注册页面"><a href="#一、进入chatGPT的注册页面" class="headerlink" title="一、进入chatGPT的注册页面"></a>一、进入chatGPT的注册页面</h3><p>[chatGPT]: 	“<a href="https://chat.openai.com/auth/login">https://chat.openai.com/auth/login</a> “</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081000882.png"></p>
<h3 id="二、点击Sign-up注册"><a href="#二、点击Sign-up注册" class="headerlink" title="二、点击Sign up注册"></a>二、点击Sign up注册</h3><p>我注册的时候用的谷歌邮箱</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081235003.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081250319.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081403723.png"></p>
<h3 id="三、进入了电话号码验证环节"><a href="#三、进入了电话号码验证环节" class="headerlink" title="三、进入了电话号码验证环节"></a>三、进入了电话号码验证环节</h3><p>一个号码模拟平台 <a href="https://sms-activate.org/cn?ref=2780512">https://sms-activate.org/cn?ref=2780512</a></p>
<p>第一步去注册登陆（这一步没什么问题）</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081608840.png"></p>
<p>第二步需要存钱了哈哈哈</p>
<p>当然，充多少一般都可以，如果只用这一次的话可以充少一点，0.2-0.5美元</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081921982.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081825615.png"></p>
<p>我们可以选择支付宝来充值，很方便</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082059408.png"></p>
<p>等到充值到账（大概几分钟）</p>
<p>我们就可以购买服务了，点击购物车（这个便宜）</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082407157.png"></p>
<p>然后，可以在激活区看到待使用的临时号码，将此号码复制到 OpenAI 的验证码接收区里面。</p>
<p>先选择对应国家，再填号码，然后发送电话号码，激活区就可以看见验证码了。</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214083118069.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082913264.png"></p>
<p>电话验证完，注册完毕</p>
<h3 id="四、登陆chatGPT"><a href="#四、登陆chatGPT" class="headerlink" title="四、登陆chatGPT"></a>四、登陆chatGPT</h3><p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214083525980.png"></p>
<p>这时候我们就可以开始和它愉快的聊天了</p>
<p>我们下一篇会介绍它是什么？</p>
]]></content>
      <categories>
        <category>趣味技术</category>
        <category>chatGPT注册</category>
      </categories>
      <tags>
        <tag>chatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>chatGPT是什么</title>
    <url>/2022/12/14/chatGPT%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="chatGPT是什么"><a href="#chatGPT是什么" class="headerlink" title="chatGPT是什么"></a>chatGPT是什么</h1><blockquote>
<p>我们都知道目前火出圈的AI绘画和chatGPT</p>
<p>那么它们是什么呢？</p>
</blockquote>
<h3 id="一、chatGPT是什么"><a href="#一、chatGPT是什么" class="headerlink" title="一、chatGPT是什么"></a>一、chatGPT是什么</h3><p><strong>ChatGPT</strong>是由<a href="https://zh.m.wikipedia.org/wiki/OpenAI">OpenAI</a>开发的一个<a href="https://zh.m.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a><a href="https://zh.m.wikipedia.org/wiki/%E8%81%8A%E5%A4%A9%E6%A9%9F%E5%99%A8%E4%BA%BA">聊天机器人</a>程序，于2022年11月推出。该程序使用基于<a href="https://zh.m.wikipedia.org/wiki/GPT-3">GPT-3.5</a>架构的<a href="https://zh.m.wikipedia.org/wiki/%E8%AA%9E%E8%A8%80%E6%A8%A1%E5%9E%8B">大型语言模型</a>并通过<a href="https://zh.m.wikipedia.org/wiki/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0">强化学习</a>进行训练。它以对话方式进行交互。在推广的期间中，所有人可以免费注册，并在登入后后免费使用 ChatGPT 实现与 AI 机器人对话</p>
<p>有世界首富——电动汽车巨头特斯拉掌门人马斯克（ Elon Musk）入股的研发公司OpenAI表示，最新推出的聊天机器人ChatGPT在不到一周时间里就拥有百万用户。</p>
<p>ChatGPT是OpenAI发布的聊天机器人模型，它的交互界面简洁，只有一个输入框，AI将根据输入内容进行回复，并允许在一个语境下持续聊天。</p>
<p><img src="/2022/12/14/chatGPT%E6%98%AF%E4%BB%80%E4%B9%88/image-20221214085330016.png"></p>
<h3 id="二、如何强大"><a href="#二、如何强大" class="headerlink" title="二、如何强大"></a>二、如何强大</h3><p>据浙商和国盛证券研报，ChatGPT相比以往的主要提升点在于记忆能力，ChatGPT可以储存对话信息，延续上下文，从而实现连续对话，这在对话场景中至关重要，极大地提升了对话交互模式下的用户体验。</p>
<p>具体而言，此次新加入的训练方式被称为“从人类反馈中强化学习”（ReinforcementLearning from Human Feedback，RLHF）。这一训练方法增加了人类对模型输出结果的演示，并且对结果进行了排序。具体操作上，人工智能训练者扮演对话的双方，即用户和人工智能助手，提供对话样本。在人类扮演聊天机器人的时候，会让模型生成一些建议辅助训练师撰写回复，训练师会对回复选项打分排名，将更好的结果输回到模型中，通过以上奖励策略对模型进行微调并持续迭代。</p>
<p><strong>此外，ChatGPT的背后离不开大模型、大数据、大算力。</strong></p>
<p>ChatGPT成为AIGC里程碑的背后，是算力发展和数字时代形成的大数据所共同支持的大模型训练，才能实现目前的效果。由OpenAI研发的ChatGPT是微调后的GPT-3.5系列模型，有着多达1750亿个模型参数，并在今年年初训练完成。模型训练的背后离不开大数据的支持，OpenAI主要使用的公共爬虫数据集有着超过万亿单词的人类语言数据集。在算力方面，GPT-3.5在Azure AI超算基础设施（由V100GPU组成的高带宽集群）上进行训练，总算力消耗约3640PF-days（即每秒一千万亿次计算，运行3640个整日）。</p>
<p><strong>AIGC里程碑级应用</strong></p>
<p><a href="https://www.8btc.com/article/6787780">AIGC</a> 将是 Web3 时代的生产力工具。当我们迈入 Web3.0 时代，人工智能、关联数据和语义网络构建，形成人与网络的全新链接，内容消费需求飞速增长。UGC\PGC 这样的内容生成方式将难以匹配扩张的需求。AIGC 将是新的元宇宙内容生成解决方案。AIGC 的生成利用人工智能学习知识图谱、自动生成，在内容的创作为人类提供协助或是完全由 AI 产生内容。不仅能帮助提高内容生成的效率，还能提高内容的多样性。随着 NLP（Natural Language Processing，自然语言处理）技术和扩散模型（Diffusion Model）的发展，AI 不再仅作为内容创造的辅助工具，创造生成内容成为了可能。由此，将来文字生成、图片绘制、视频剪辑、游戏内容生成皆可由 AI 替代。</p>
<p>国盛证券表示，AIGC不仅改变创作，还将改变获取信息的主要方式。而在此之上，ChatGPT所展示了作为生产力的存在，ChatGPT在寻找答案、解决问题的效率上已经部分的超越了如今的搜索引擎，ChatGPT或许在未来会改变我们获取信息、输出内容的方式，AIGC有望成为数字经济时代驱动需求爆发的杀手级应用。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[维基百科]: 	“<a href="https://zh.m.wikipedia.org/zh-hans/ChatGPT">https://zh.m.wikipedia.org/zh-hans/ChatGPT</a> “</p>
]]></content>
      <categories>
        <category>趣味技术</category>
        <category>chatGPT是什么</category>
      </categories>
      <tags>
        <tag>chatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>electron-vue3-vite</title>
    <url>/2022/11/28/electron-vue3-vite/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Electron-Vue3-Vite"><a href="#Electron-Vue3-Vite" class="headerlink" title="Electron-Vue3-Vite"></a>Electron-Vue3-Vite</h1><blockquote>
<p>今天这一篇文章算是electron的一个短暂的结尾，以后我们再更新electron 的知识。</p>
<p>今天的内容是项目的vue3+electron项目搭建和打包部署</p>
</blockquote>
<h3 id="一、Electron-Vue3-Vite搭建"><a href="#一、Electron-Vue3-Vite搭建" class="headerlink" title="一、Electron-Vue3-Vite搭建"></a>一、Electron-Vue3-Vite搭建</h3><h4 id="1-创建模板"><a href="#1-创建模板" class="headerlink" title="1.创建模板"></a>1.创建模板</h4><blockquote>
<p>！！！兼容性注意</p>
<p>Vite 需要 Node.js版本 14.18+，16+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。</p>
</blockquote>
<pre><code class="ini">//使用npm
npm create vite@latest
//使用yarn
yarn create vite
//使用pnpm
pnpm create vite
</code></pre>
<p>使用以下命令启动：</p>
<pre><code class="ini">npm i //安装依赖
npm run dev //启动项目
</code></pre>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221127082439543.png"></p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221127082625854.png"></p>
<h4 id="2-安装electron"><a href="#2-安装electron" class="headerlink" title="2.安装electron"></a>2.安装electron</h4><pre><code class="ini">npm i electron -D 
</code></pre>
<p>目前博主遇到了一个小问题，就是下载electron会一直卡住，这里使用如下方法就可以解决了。</p>
<pre><code class="ini">npm install cnpm -g --registry=https://registry.npm.taobao.org //切换国内镜像源
cnpm isntall electron --save-dev
</code></pre>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128081646599.png"></p>
<h4 id="3-创建入口文件"><a href="#3-创建入口文件" class="headerlink" title="3.创建入口文件"></a>3.创建入口文件</h4><p>根目录下创建</p>
<p>Main.js入口文件</p>
<pre><code class="javascript">//main.js
const &#123; app,BrowserWindow &#125; = require(&#39;electron&#39;)
const path = require(&#39;path&#39;)
const WinState = require(&#39;electron-win-state&#39;).default //保存窗口状态的包（窗口可以保存缩放、位置状态）

const createWindow = () =&gt; &#123;
  const winState = new WinState(&#123; 
    defaultWidth: 1000,
    defaultHeight: 800,
    // other winState options, see below
  &#125;)
    const win = new BrowserWindow(&#123;
      ...winState.winOptions,
      // width: 800,
      // height: 600,
      webPreferences: &#123;
        preload: path.join(__dirname, &#39;preload.js&#39;)
      &#125;
    &#125;)
    win.loadURL(&#39;http://127.0.0.1:5173/&#39;) //加载本地端口，部署的时候可以换成我们的域名
    win.webContents.openDevTools() //打开控制台调试
    winState.manage(win)
  &#125;

  app.whenReady().then(() =&gt; &#123;
    createWindow()
    app.on(&#39;activate&#39;, () =&gt; &#123;
      if (BrowserWindow.getAllWindows().length === 0) createWindow()
    &#125;)
  &#125;) 

  app.on(&#39;window-all-closed&#39;, () =&gt; &#123;
    if (process.platform !== &#39;darwin&#39;) app.quit()
  &#125;)
</code></pre>
<p>Preload.js预加载文件</p>
<pre><code class="javascript">//目前先不写内容，先搭个架子
</code></pre>
<p>配置package.json</p>
<pre><code class="javascript">//package.json
&#123;
  &quot;name&quot;: &quot;vite-project&quot;,
  &quot;private&quot;: true,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;,
    &quot;start&quot;: &quot;nodemon --exec electron . --watch ./ --ext .js,.html,.vue,.css&quot;,
  &#125;,
  &quot;dependencies&quot;: &#123;
    &quot;electron-win-state&quot;: &quot;^1.1.22&quot;,
    &quot;vue&quot;: &quot;^3.2.41&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;@vitejs/plugin-vue&quot;: &quot;^3.2.0&quot;,
    &quot;electron&quot;: &quot;^21.3.1&quot;,
    &quot;electron-builder&quot;: &quot;^23.6.0&quot;,
    &quot;nodemon&quot;: &quot;^2.0.20&quot;,
    &quot;vite&quot;: &quot;^3.2.3&quot;
  &#125;
&#125;

</code></pre>
<h4 id="4-安装其他依赖"><a href="#4-安装其他依赖" class="headerlink" title="4.安装其他依赖"></a>4.安装其他依赖</h4><pre><code class="ini">cnpm install nodemon --save-dev //安装nodemon
cnpm install electron-win-state --save-dev //安装electron-win-state
</code></pre>
<h4 id="5-运行项目"><a href="#5-运行项目" class="headerlink" title="5.运行项目"></a>5.运行项目</h4><pre><code class="ini">npm run dev //启动vue项目
npm start //启动electron
</code></pre>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128085457686.png"></p>
<p>我们现在就可以去开发我们的项目了</p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128085520887.png"></p>
<h3 id="二、打包与部署"><a href="#二、打包与部署" class="headerlink" title="二、打包与部署"></a>二、打包与部署</h3><p>官网推荐我们的是<a href="https://www.electronjs.org/docs/latest/tutorial/forge-overview">Electron Forge</a>来分发我们的应用程序</p>
<blockquote>
<p>electron-forge 可以自动检测你的系统，然后打包成对应的可执行文件。<br>它可以实现 package 成最终可用的独立项目文件夹，<br>还可以 make 成能够安装的 zip 包</p>
</blockquote>
<p>目前这个方法有一些问题，我们先用另一种方法来进行打包<a href="https://www.electron.build/">electron-build</a></p>
<p>根据文档我们也可以很快的掌握这种打包方式</p>
<h4 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1.安装依赖"></a>1.安装依赖</h4><pre><code class="ini">cnpm i electron-builder -D //安装依赖
</code></pre>
<p>配置一下package.json</p>
<pre><code class="javascript">//package.json+
&quot;scripts&quot;: &#123;
  ...
  &quot;app:dir&quot;: &quot;electron-builder --dir&quot;,
  &quot;app:dist&quot;: &quot;electron-builder&quot;
  ...
&#125;
</code></pre>
<h4 id="2-打包"><a href="#2-打包" class="headerlink" title="2.打包"></a>2.打包</h4><pre><code class="ini">cnpm run app:dist  //执行打包
</code></pre>
<p>目前我遇到打包错误的问题</p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128115215328.png"></p>
<p>如果我们遇到这种问题，我们切换一下npm镜像源就可以了；</p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128115258224.png"></p>
<p>现在我们打包就成功了</p>
<h4 id="3-运行安装包"><a href="#3-运行安装包" class="headerlink" title="3.运行安装包"></a>3.运行安装包</h4><p>找到我们项目目录下的dist文件的.dmg安装包（我的是mac）</p>
<p>在运行之前，我们应该先将项目 运行 起来（因为我们是本地项目，等部署到服务器就不用了）</p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128115702655.png"></p>
<p>点击执行安装包</p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128115730129.png"></p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128115827756.png"></p>
<p>到目前为止，我们的electron的搭建-&gt;开发-&gt;打包就一气呵成了，当然，开发项目中还有许多奇奇怪怪的问题和知识点，就靠各位聪明的脑瓜了。。</p>
<p><img src="/2022/11/28/electron-vue3-vite/tl.webp"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Electron官网]: 	“<a href="https://www.electronjs.org/docs/latest/tutorial/forge-overview">https://www.electronjs.org/docs/latest/tutorial/forge-overview</a> “<br>[Vite.js官网]: 	“<a href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a> “<br>[electron-builder]: 	“<a href="https://github.com/electron-userland/electron-builder">https://github.com/electron-userland/electron-builder</a> “</p>
]]></content>
      <categories>
        <category>Electron</category>
        <category>electron-vue3-vite</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>npm命令详解</title>
    <url>/2022/11/09/npm%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="npm命令详解"><a href="#npm命令详解" class="headerlink" title="npm命令详解"></a>npm命令详解</h1><h3 id="一、npm配置命令"><a href="#一、npm配置命令" class="headerlink" title="一、npm配置命令"></a>一、npm配置命令</h3><pre><code class="css">npm install -g cnpm --registry=https://registry.npm.taobao.org  #通过cnpm使用淘宝镜像
npm config set registry https://registry.npm.taobao.org #将npm设置为淘宝镜像
npm config set registry https://registry.npmjs.org #切换回默认全局镜像
npm config get registry #查看npm镜像设置
npm config list #查看npm配置
cnpm config list #查看cnpm配置
npm -v #查看npm版本
</code></pre>
<p>方便统一和阅读，文中全部使用简写方式。</p>
<blockquote>
<p>-g： 为 –global 的缩写，表示安装到全局目录里<br>-S： 为 –save 的缩写，表示安装的包将写入package.json里面的dependencies<br>-D： 为 –save-dev 的缩写，表示将安装的包将写入packege.json里面的devDependencies<br> i： 为install的缩写，表示安装</p>
</blockquote>
<h3 id="二、npm安装命令"><a href="#二、npm安装命令" class="headerlink" title="二、npm安装命令"></a>二、npm安装命令</h3><pre><code class="css">npm init  # npm 初始化当前目录
npm i  # 安装所有依赖
npm i express  # 安装模块到默认dependencies
npm i express -g  # 会安装到配置的全局目录下
npm i express -S  # 安装包信息将加入到dependencies生产依赖
npm i express -D  # 安装包信息将加入到devDependencies开发依赖
npm i jquery@1.8.3  # 安装jquery指定的1.8.3版本
</code></pre>
<h3 id="三、npm更新命令"><a href="#三、npm更新命令" class="headerlink" title="三、npm更新命令"></a>三、npm更新命令</h3><pre><code class="css">npm update jquery  # 更新最新版本的jquery
npm update jquery@2.1.0  # 更新到指定版本号的jquery
npm install jquery@latest  # 可以直接更新到最后一个新版本
</code></pre>
<h3 id="四、npm卸载命令"><a href="#四、npm卸载命令" class="headerlink" title="四、npm卸载命令"></a>四、npm卸载命令</h3><pre><code class="css">npm uninstall express  # 卸载模块，但不卸载模块留在package.json中的对应信息
npm uninstall express -g  # 卸载全局模块
npm uninstall express --save  # 卸载模块，同时卸载留在package.json中dependencies下的信息
npm uninstall express --save-dev  # 卸载模块，同时卸载留在package.json中devDependencies下的信息
</code></pre>
<h3 id="五、npm查看命令"><a href="#五、npm查看命令" class="headerlink" title="五、npm查看命令"></a>五、npm查看命令</h3><pre><code class="css">npm root  # 查看项目中模块所在的目录
npm root -g  # 查看全局安装的模块所在目录
npm list 或者 npm ls  # 查看本地已安装模块的清单列表
npm view jquery dependencies  # 查看某个包对于各种包的依赖关系
npm view jquery version  # 查看jquery最新的版本号
npm view jquery versions  # 查看所有jquery历史版本号（很实用）
npm view jquery  # 查看最新的jquery版本的信息
npm info jquery  # 查看jquery的详细信息，等同于上面的npm view jquery
npm list jquery 或 npm ls jquery  # 查看本地已安装的jquery的详细信息
npm view jquery repository.url  # 查看jquery包的来源地址
</code></pre>
<h3 id="六、其他命令"><a href="#六、其他命令" class="headerlink" title="六、其他命令"></a>六、其他命令</h3><pre><code class="css">npm cache clean  # 清除npm的缓存
npm prune  # 清除项目中没有被使用的包
npm outdated  # 检查模块是否已经过时
npm repo jquery  # 会打开默认浏览器跳转到github中jquery的页面
npm docs jquery  # 会打开默认浏览器跳转到github中jquery的README.MD文件信息
npm home jquery  # 会打开默认浏览器跳转到github中jquery的主页
</code></pre>
<h3 id="七、package-json字段"><a href="#七、package-json字段" class="headerlink" title="七、package.json字段"></a>七、package.json字段</h3><p>[package.json字段详解]: 	“<a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json">https://docs.npmjs.com/cli/v8/configuring-npm/package-json</a> “</p>
<h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p>[npm官网]: 	“<a href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
]]></content>
      <categories>
        <category>npm&amp;yarn</category>
        <category>npm常用命令</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>pinia</title>
    <url>/2022/11/23/pinia/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h1><h3 id="一、Vuex-与-Pinia-核心思想与用法"><a href="#一、Vuex-与-Pinia-核心思想与用法" class="headerlink" title="一、Vuex 与 Pinia 核心思想与用法"></a>一、Vuex 与 Pinia 核心思想与用法</h3><h4 id="Flux-架构"><a href="#Flux-架构" class="headerlink" title="Flux 架构"></a>Flux 架构</h4><p>Flux 是 Facebook 在构建大型 Web 应用程序时为了解决数据一致性问题而设计出的一种架构，它是一种描述状态管理的设计模式。绝大多数前端领域的状态管理工具都遵循这种架构，或者以它为参考原型。</p>
<p>Flux 架构主要有四个组成部分：</p>
<ul>
<li>📦 <strong>store</strong>：状态数据的存储管理中心，可以有多个，可以接受 action 做出响应。</li>
<li>🖼 <strong>view</strong>：视图，根据 store 中的数据渲染生成页面，与 store 之间存在发布订阅关系。</li>
<li>🛠 <strong>action</strong>：一种描述动作行为的数据对象，通常会包含动作类型 type 和需要传递的参数 payload 等属性。</li>
<li>📮 <strong>dispatcher</strong>：调度器，接收 action 并分发至 store。</li>
</ul>
<p><img src="/2022/11/23/pinia/b55512a3f1be47b2.png"></p>
<p>整个数据流动关系为：</p>
<p>1、view 视图中的交互行为会创建 action，交由 dispatcher 调度器。</p>
<p>2、dispatcher 接收到 action 后会分发至对应的 store。</p>
<p>3、store 接收到 action 后做出响应动作，并触发 change 事件，通知与其关联的 view 重新渲染内容。</p>
<p>这就是 Flux 架构最核心的特点：单向数据流。</p>
<p>与传统的 MVC 架构相比，单向数据流也带来了一个好处：可预测性。</p>
<p>所有对于状态的修改都需要经过 dispatcher 派发的 action 来触发的，每一个 action 都是一个单独的数据对象实体，可序列化，操作记录可追踪，更易于调试。</p>
<p>Vuex 与 Pinia 大体上沿用 Flux 的思想，并针对 Vue 框架单独进行了一些设计上的优化。</p>
<h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p><img src="/2022/11/23/pinia/f9ae36a64955b220.png"></p>
<ul>
<li>📦 <strong>state</strong>：整个应用的状态管理单例，等效于 Vue 组件中的 data，对应了 Flux 架构中的 store。</li>
<li>🧮 <strong>getter</strong>：可以由 state 中的数据派生而成，等效于 Vue 组件中的计算属性。它会自动收集依赖，以实现计算属性的缓存。</li>
<li>🛠 <strong>mutation</strong>：类似于事件，包含一个类型名和对应的回调函数，在回调函数中可以对 state 中的数据进行同步修改。<ul>
<li>Vuex 不允许直接调用该函数，而是需要通过 <code>store.commit</code> 方法提交一个操作，并将参数传入回调函数。</li>
<li>commit 的参数也可以是一个数据对象，正如 Flux 架构中的 action 对象一样，它包含了类型名 <code>type</code> 和负载 <code>payload</code>。</li>
<li>这里要求 mutation 中回调函数的操作一定是同步的，这是因为同步的、可序列化的操作步骤能保证生成唯一的日志记录，才能使得 devtools 能够实现对状态的追踪，实现 time-travel。</li>
</ul>
</li>
<li>🔨 <strong>action</strong>：action 内部的操作不受限制，可以进行任意的异步操作。我们需要通过 <code>dispatch</code> 方法来触发 action 操作，同样的，参数包含了类型名 <code>type</code> 和负载 <code>payload</code>。<ul>
<li>action 的操作本质上已经脱离了 Vuex 本身，假如将它剥离出来，仅仅在用户（开发者）代码中调用 <code>commit</code> 来提交 mutation 也能达到一样的效果。</li>
</ul>
</li>
<li>📁 <strong>module</strong>：store 的分割，每个 module 都具有独立的 state、getter、mutation 和 action。<ul>
<li>可以使用 <code>module.registerModule</code> 动态注册模块。</li>
<li>支持模块相互嵌套，可以通过设置命名空间来进行数据和操作隔离。</li>
</ul>
</li>
</ul>
<h4 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h4><p><img src="/2022/11/23/pinia/image-20221123084525884.png"></p>
<p>保留：</p>
<ul>
<li>📦 <strong>state</strong>：store 的核心，与 Vue 中的 data 一致，可以直接对其中的数据进行读写。</li>
<li>🧮 <strong>getters</strong>：与 Vue 中的计算属性相同，支持缓存。</li>
<li>🔨 <strong>actions</strong>：操作不受限制，可以创建异步任务，可以直接被调用，不再需要 commit、dispatch 等方法。</li>
</ul>
<p>舍弃：</p>
<ul>
<li>🛠 <strong>mutation</strong>：Pinia 并非完全抛弃了 mutation，而是将对 state 中单个数据进行修改的操作封装为一个 mutation，但不对外开放接口。可以在 devtools 中观察到 mutation。</li>
<li>📁 <strong>module</strong>：Pinia 通过在创建 store 时指定 name 来区分不同的 store，不再需要 module。</li>
</ul>
<h3 id="二、使用Pinia"><a href="#二、使用Pinia" class="headerlink" title="二、使用Pinia"></a>二、使用Pinia</h3><h4 id="1-安装pinia"><a href="#1-安装pinia" class="headerlink" title="1.安装pinia"></a>1.安装pinia</h4><pre><code class="ini">npm i pinia -S //安装pinia依赖
</code></pre>
<h4 id="2-main-js组册"><a href="#2-main-js组册" class="headerlink" title="2.main.js组册"></a>2.main.js组册</h4><pre><code class="javascript">//main.js
import &#123; createApp &#125; from &#39;vue&#39;
import &#39;./style.css&#39;
import App from &#39;./App.vue&#39;
import &#123; createPinia &#125; from &#39;pinia&#39;

createApp(App)
.use(createPinia())
.mount(&#39;#app&#39;)
</code></pre>
<h4 id="3-创建store"><a href="#3-创建store" class="headerlink" title="3.创建store"></a>3.创建store</h4><p><img src="/2022/11/23/pinia/image-20221123090656211.png"></p>
<pre><code class="javascript">//countStore.js
import &#123; defineStore &#125; from &#39;pinia&#39;
const useCountStore = defineStore(&#39;countStore&#39;,&#123;
    state()&#123;
        return &#123;
            count:0
        &#125;
    &#125;
&#125; )
export default useCountStore; //导出
</code></pre>
<h4 id="4-新建组件使用state"><a href="#4-新建组件使用state" class="headerlink" title="4.新建组件使用state"></a>4.新建组件使用state</h4><pre><code class="vue">//components/Count.vue
&lt;script setup&gt;
import useCountStore from &#39;../store/countStore&#39;
const countStore = useCountStore();
console.log(countStore)
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;
    &#123;&#123;countStore.count&#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style lang=&quot;css&quot;&gt;
div&#123;
    width: 100px;
    height: 30px;
    border:1px solid black;
    border-radius: 5px;
&#125;
&lt;/style&gt;
</code></pre>
<pre><code class="vue">//App.vue
&lt;script setup&gt;
// This starter template is using Vue 3 &lt;script setup&gt; SFCs
// Check out https://vuejs.org/api/sfc-script-setup.html#script-setup
import Count from &#39;./components/Count.vue&#39;
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;
    &lt;Count/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
.logo &#123;
  height: 6em;
  padding: 1.5em;
  will-change: filter;
&#125;
.logo:hover &#123;
  filter: drop-shadow(0 0 2em #646cffaa);
&#125;
.logo.vue:hover &#123;
  filter: drop-shadow(0 0 2em #42b883aa);
&#125;
&lt;/style&gt;
</code></pre>
<p><img src="/2022/11/23/pinia/image-20221123091224524.png" alt="countStore"></p>
<p>我们可以直接使用就可以了，根据上面控制台输出可以看清楚countStore</p>
<p>到现在已经实现了创建store及使用</p>
<h4 id="5-更新store"><a href="#5-更新store" class="headerlink" title="5.更新store"></a>5.更新store</h4><p>1.我们添加一个action方法</p>
<pre><code class="javascript">//countStore.js
import &#123; defineStore &#125; from &#39;pinia&#39;

const useCountStore = defineStore(&#39;countStore&#39;,&#123;
    //定义state
    state()&#123;
        return &#123;
            count:0
        &#125;
    &#125;,
    //定义action方法
    actions:&#123;
        add()&#123;
            this.count++
        &#125;
    &#125;
&#125; )

export default useCountStore;
</code></pre>
<p>2.解构方法和state</p>
<pre><code class="vue">//Count.vue
&lt;script setup&gt;
import &#123; storeToRefs &#125; from &#39;pinia&#39;
import useCountStore from &#39;../store/countStore&#39;
const &#123;count,add&#125; = storeToRefs(useCountStore());
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;
    &#123;&#123;count&#125;&#125;
  &lt;/div&gt;
  &lt;button @click=&quot;add()&quot;&gt;Add&lt;/button&gt;
&lt;/template&gt;
&lt;style lang=&quot;css&quot;&gt;
div&#123;
    width: 100px;
    height: 30px;
    border:1px solid black;
    border-radius: 5px;
    text-align: center;
&#125;
button&#123;
    position: relative;
    bottom: -30px;
&#125;
&lt;/style&gt; 
</code></pre>
<p>如果我们不使用 storeToRefs 来转发，那么页面将不会有任何响应</p>
<p>但是我们包裹了useCountStore()并且解构了，发现控制台输出错误error</p>
<p><img src="/2022/11/23/pinia/image-20221123094109387.png"></p>
<p>经过修改发现，actions方法不可以通过解构来使用，只能通过另一种方法</p>
<p><img src="/2022/11/23/pinia/image-20221123094416363.png"> </p>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p>[Pinia中文文档]: 	“<a href="https://pinia.web3doc.top/">https://pinia.web3doc.top/</a> “<br>[Vite中文文档]: 	“<a href="https://vitejs.cn/">https://vitejs.cn/</a> “</p>
]]></content>
      <categories>
        <category>Electron</category>
        <category>Pinia</category>
      </categories>
      <tags>
        <tag>Pinia</tag>
      </tags>
  </entry>
  <entry>
    <title>playcanvas初级</title>
    <url>/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="playcanvas初级"><a href="#playcanvas初级" class="headerlink" title="playcanvas初级"></a>playcanvas初级</h1><blockquote>
<p>我们在开始本文章之前，推荐大家一个小工具，方便我们在油管上看英文视频</p>
<p>YouTube™ 双字幕</p>
<p>我们通过YouTube上<a href="https://www.youtube.com/watch?v=fXc-JjH2nNo&list=PLGmYIROty-5ZX-a88X8ztUeYSPeuBj7rG">Daniel Wood</a>博主的playcanvas视频来浅入一下（看着文章来梳理视频内容食用更佳哦！）</p>
</blockquote>
<h3 id="start：工具下载"><a href="#start：工具下载" class="headerlink" title="start：工具下载"></a>start：工具下载</h3><blockquote>
<p>YouTube™ 双字幕可以帮助我们添加双语字幕</p>
<p>安装步骤：谷歌浏览器-&gt;设置-&gt;扩展程序-&gt;打开应用商店-&gt;查找-&gt;安装</p>
</blockquote>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204161502349.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204161617072.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204161720108.png"></p>
<blockquote>
<p>下载完成之后，我们在扩展程序图标上就可以使用了，如果不起效果，请重新打开浏览器</p>
</blockquote>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204162049453.png"></p>
<h3 id="一、第一课（Getting-started-with-PlayCanvas）"><a href="#一、第一课（Getting-started-with-PlayCanvas）" class="headerlink" title="一、第一课（Getting started with PlayCanvas）"></a>一、第一课（Getting started with PlayCanvas）</h3><blockquote>
<p>我们第一课先来简单使用一下我们的可视化平台</p>
</blockquote>
<p>第一节课主要是熟悉我们的可视化面板，上一篇<a href="https://mengfeng.github.io/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/">playcanvas初识</a>有讲解，如果感兴趣，我们还是可以看看我们的第一课的视频的</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204174020956.png"></p>
<h3 id="二、第二课（Entities-and-materials）"><a href="#二、第二课（Entities-and-materials）" class="headerlink" title="二、第二课（Entities and materials）"></a>二、第二课（Entities and materials）</h3><blockquote>
<p>实体和材质是什么？</p>
<p>实体就是我们编辑器里面的方块、平面等几何体</p>
<p>材质是我们实体需要结合的属性</p>
</blockquote>
<p>1.当我们创建材质资源的时候，我们可以将其分成一个组，方便我们以后去管理我们的材质</p>
<p>2.我们的贴图，那些属性，我建议先去看看Three.js的教程吧，或者有三维软件的使用基础也是容易理解的，如果不具备这些基础概念可以看看我之前的<a href="https://mengfeng.github.io/categories/">threejs</a>的文章</p>
<p>3.简单的赋予实体材质的步骤就是如下图（还是比较容易的）</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204175100109.png"></p>
<p>4.这节课视频主要讲的是贴图和材质和我们材质的一系列属性（不是api）</p>
<p>5.点击我们的Camera（摄像机）调节角度，点击界面右上角的Launch就可以渲染我们的画面了</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204180337214.png"></p>
<h3 id="三、第三课（Lighting）"><a href="#三、第三课（Lighting）" class="headerlink" title="三、第三课（Lighting）"></a>三、第三课（Lighting）</h3><blockquote>
<p>我们的灯光也是有3种，平行光、点光源、聚光灯</p>
<p>这节课除了讲解几种灯光的属性之外，也有灯光与阴影的关系</p>
</blockquote>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204181635026.png"></p>
<p>聚光灯效果，我们在右边的属性栏也可以去修改我们聚光灯的其他属性</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204183234836.png"></p>
<p>点光源效果（可以看成一个灯泡）</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204183435845.png"></p>
<h3 id="四、第四课（Skyboxes-in-PlayCanvas）"><a href="#四、第四课（Skyboxes-in-PlayCanvas）" class="headerlink" title="四、第四课（Skyboxes in PlayCanvas）"></a>四、第四课（Skyboxes in PlayCanvas）</h3><blockquote>
<p>主要展示如何添加天空贴图</p>
<p>我们的贴图就是从这里下载的，可以去试试</p>
<p>[贴图纹理]: 	“<a href="http://www.humus.name/index.php?page=Textures">http://www.humus.name/index.php?page=Textures</a> “</p>
</blockquote>
<p>具体的步骤总结：</p>
<p>⚠️注意：还是看视频详细，这只是总结一下哈哈哈</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204184930487.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204185140511.png"></p>
<h3 id="五、第五课（Particle-systems-in-PlayCanvas）"><a href="#五、第五课（Particle-systems-in-PlayCanvas）" class="headerlink" title="五、第五课（Particle systems in PlayCanvas）"></a>五、第五课（Particle systems in PlayCanvas）</h3><blockquote>
<p>这节课的东西我比较喜欢，粒子系统（会生成粒子和粒子动画）</p>
</blockquote>
<p>具体的步骤总结：</p>
<p>这个比较简单，到了后面，这个会生成很多惊艳的动画效果</p>
<p>⚠️注意：这个属性比较多，认真看</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204185753349.png"></p>
<h3 id="六、第六课（Overview-of-scripts-in-PlayCanvas）"><a href="#六、第六课（Overview-of-scripts-in-PlayCanvas）" class="headerlink" title="六、第六课（Overview of scripts in PlayCanvas）"></a>六、第六课（Overview of scripts in PlayCanvas）</h3><blockquote>
<p>这节课没什么东西，就是讲解一下我们script资源文件的构造（给没有javaScript基础的同学讲的）</p>
<p>有基础的同学可以快速略过了</p>
</blockquote>
<p>具体的步骤总结：</p>
<p>主要是讲一下script资源的操作</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204190611547.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204190818807.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204191338719.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204191641346.png"></p>
<h3 id="七、第七课（Make-a-3D-object-move-with-code）"><a href="#七、第七课（Make-a-3D-object-move-with-code）" class="headerlink" title="七、第七课（Make a 3D object move with code）"></a>七、第七课（Make a 3D object move with code）</h3><blockquote>
<p>这节课开始就要编写js脚本文件了</p>
<p>通过我们下面的脚步编译，我们就可以渲染出方块渐行渐远的动画了</p>
<p>具体的API我们可以查询<a href="https://developer.playcanvas.com/api/pc.Entity.html">文档</a>了</p>
</blockquote>
<pre><code class="javascript">//test.js
var Test = pc.createScript(&#39;test&#39;);
var Move = function(entity)&#123;
  this.entity = entity;
&#125;
// initialize code called once per entity
Test.prototype.initialize = function() &#123;
    
&#125;;

// update code called every frame
Test.prototype.update = function(dt) &#123;
    this.entity.translateLocal(-0.01,0,0);
&#125;;

// swap method called for script hot-reloading
// inherit your script state here
// Test.prototype.swap = function(old) &#123; &#125;;

// to learn more about script anatomy, please read:
// https://developer.playcanvas.com/en/user-manual/scripting/
</code></pre>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204192521888.png"></p>
<h3 id="八、第八课（Moving-objects-with-keyboard-input）"><a href="#八、第八课（Moving-objects-with-keyboard-input）" class="headerlink" title="八、第八课（Moving objects with keyboard input）"></a>八、第八课（Moving objects with keyboard input）</h3><blockquote>
<p>利用键盘的按键来控制我们实体的移动、旋转等</p>
<p>建议不要跟着视频的写法来练习，要自己去查文档，因为视频已经有点陈旧了</p>
<p>api都有所变化</p>
</blockquote>
<p>我们的脚本实现的是利用键盘的上下左右来控制实体的上下左右</p>
<pre><code class="javascript">//test.js
var Test = pc.createScript(&#39;test&#39;);
var keyboard = new pc.Keyboard(window);
var Move = function(entity)&#123;
  this.entity = entity;
&#125;
// initialize code called once per entity
Test.prototype.initialize = function() &#123;
    
&#125;;

// update code called every frame
Test.prototype.update = function(dt) &#123;
   if(keyboard.isPressed(pc.KEY_RIGHT))&#123;
       this.entity.translate(0.01,0,0);
   &#125;
    if(keyboard.isPressed(pc.KEY_LEFT))&#123;
       this.entity.translate(-0.01,0,0);
   &#125;
    if(keyboard.isPressed(pc.KEY_UP))&#123;
       this.entity.translate(0,0,-0.01);
   &#125;
    if(keyboard.isPressed(pc.KEY_DOWN))&#123;
       this.entity.translate(0,0,0.01);
   &#125;
&#125;;

// swap method called for script hot-reloading
// inherit your script state here
// Test.prototype.swap = function(old) &#123; &#125;;

// to learn more about script anatomy, please read:
// https://developer.playcanvas.com/en/user-manual/scripting/
</code></pre>
<h3 id="九、第九课（Rotating-objects-with-keyboard-input）"><a href="#九、第九课（Rotating-objects-with-keyboard-input）" class="headerlink" title="九、第九课（Rotating objects with keyboard input）"></a>九、第九课（Rotating objects with keyboard input）</h3><blockquote>
<p>这节课和上节课的内容差不多，就是利用键盘按键去控制实体的其他属性</p>
<p>教js零基础的同学一下变量的基础写法（可以快速略过了哈哈哈，还得扫一眼哈）</p>
</blockquote>
<h3 id="十、第十课（Rigid-Bodies-and-Collision-in-PlayCanvas）"><a href="#十、第十课（Rigid-Bodies-and-Collision-in-PlayCanvas）" class="headerlink" title="十、第十课（Rigid Bodies and Collision in PlayCanvas）"></a>十、第十课（Rigid Bodies and Collision in PlayCanvas）</h3><blockquote>
<p>PlayCanvas中的刚体和碰撞这节课的知识点还是可以的</p>
<p>大体是讲物体碰撞的属性和运动</p>
</blockquote>
<p>根据步骤可以实现碰撞</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204204506027.png"></p>
<h3 id="十一、第十一课（Adding-sound-to-your-game）"><a href="#十一、第十一课（Adding-sound-to-your-game）" class="headerlink" title="十一、第十一课（Adding sound to your game）"></a>十一、第十一课（Adding sound to your game）</h3><blockquote>
<p>我们的游戏进去是不是有背景音乐呀，这节课就是将背景音乐加载进来</p>
<p>Audio Listener可以简单的说像耳朵一样，可以听见附近的声音</p>
</blockquote>
<p>大体步骤如下，具体可以看视频了（还有许多细节）</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204205445304.png"></p>
<h3 id="十二、第十二课（Controlling-audio-with-scripts）"><a href="#十二、第十二课（Controlling-audio-with-scripts）" class="headerlink" title="十二、第十二课（Controlling audio with scripts）"></a>十二、第十二课（Controlling audio with scripts）</h3><blockquote>
<p>这节课就是延续上面的，对于audio的属性讲解和脚本编写了，</p>
<p>这个任务交给你们了，写好评论，给你点大赞👍</p>
</blockquote>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[playcanvas初级教程]: 	“<a href="https://www.youtube.com/watch?v=fXc-JjH2nNo&amp;list=PLGmYIROty-5ZX-a88X8ztUeYSPeuBj7rG">https://www.youtube.com/watch?v=fXc-JjH2nNo&amp;list=PLGmYIROty-5ZX-a88X8ztUeYSPeuBj7rG</a> “<br>[playcanvas官网API]: 	“<a href="https://developer.playcanvas.com/en/api/">https://developer.playcanvas.com/en/api/</a> “<br>[playcanvas中文]: 	“<a href="https://developer.playcanvas.com/zh/">https://developer.playcanvas.com/zh/</a> “</p>
]]></content>
      <categories>
        <category>Web3D</category>
        <category>playcanvas</category>
        <category>playcanvas初级</category>
      </categories>
      <tags>
        <tag>playcanvas</tag>
      </tags>
  </entry>
  <entry>
    <title>playcanvas初识</title>
    <url>/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="playcanvas（基于WebGL的游戏引擎）"><a href="#playcanvas（基于WebGL的游戏引擎）" class="headerlink" title="playcanvas（基于WebGL的游戏引擎）"></a>playcanvas（基于WebGL的游戏引擎）</h1><p>PlayCanvas 是一款使用 HTML5 和 WebGL 技术运行游戏以及其他 3D 内容的开源游戏引擎，PlayCanvas 以其独特的性能实现了在任何手机移动端和桌面浏览器端均可以流畅运行。</p>
<p>PlayCanvas 引擎是一款可以基于浏览器的用于制作游戏以及 3D 可视化的开源引擎。除此之外，还开发了<a href="https://playcanvas.com/">PlayCanvas 开发平台</a>， 为用户提供了可视化编辑器，资源管理，代码编辑，代码托管以及发布等服务。</p>
<blockquote>
<p>目前中文的教程很少，所以英语好的同学可以去看一下国外的那些教程，但是还是有<a href="https://developer.playcanvas.com/zh/">中文文档</a>的。</p>
</blockquote>
<p>可视化平台操作上倒是没什么难度，就是和正常的建模操作大同小异，一个可视化的一个操作平台，可以进一步的提高我们工作的效率吧。</p>
<h3 id="一、注册账户"><a href="#一、注册账户" class="headerlink" title="一、注册账户"></a>一、注册账户</h3><blockquote>
<p>注册账户的方式很简单，根据提示去注册就可以了</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203152809943.png"></p>
<h3 id="二、新建项目"><a href="#二、新建项目" class="headerlink" title="二、新建项目"></a>二、新建项目</h3><blockquote>
<p>1.我们点击NEW，即可创建新项目</p>
<p>2.点击我们的项目就可以进入项目界面</p>
<p>3.点击EDITOR就可以进入可视化操作平台，去操作我们的项目</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203153658606.png"></p>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203153755107.png"></p>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203152450815.png"></p>
<h3 id="三、导出项目"><a href="#三、导出项目" class="headerlink" title="三、导出项目"></a>三、导出项目</h3><blockquote>
<p>1.导出项目前，我们得先pulish</p>
<p>2.点击下载 .zip 包</p>
<p>3.将包用vsCode打开，运行index.html</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203155914469.png"></p>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203160109159.png"></p>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203160208211.png"></p>
<h3 id="四、其他界面菜单"><a href="#四、其他界面菜单" class="headerlink" title="四、其他界面菜单"></a>四、其他界面菜单</h3><p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203160737778.png"></p>
<h4 id="1-工具栏和菜单栏"><a href="#1-工具栏和菜单栏" class="headerlink" title="1.工具栏和菜单栏"></a>1.工具栏和菜单栏</h4><blockquote>
<p>点击 PLAYCANVAS 图标会显示所有的可用功能，可以使用这些功能编辑场景。如果找不到某个按钮或者快捷键，肯定是能在菜单里找到对应功能的。</p>
<p>工具栏提供快捷访问的常用功能，其中包含最重要的运行按钮。运行按钮会在一个独立的浏览器窗口中启动游戏并且加载当前的场景，可以立即开始游戏测试。可以从属性编辑栏中看到运行中游戏的实时参数变化。</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161229021.png"></p>
<h4 id="2-层级树"><a href="#2-层级树" class="headerlink" title="2.层级树"></a>2.层级树</h4><blockquote>
<p>场景是由层级结构的实体组成，场景层级树显示了当前整个场景的树形结构。一个场景永远包含一个根节点实体，位于层级树的最顶端。所有其他的实体都是由开发者逐步加入的。</p>
<p>层级树面板包含了场景中的全部实体，可以在其中快速定位实体，而不必在场景中搜寻。点击层级树上的实体将会选中它。</p>
<h2 id="创建和删除实体"><a href="#创建和删除实体" class="headerlink" title="创建和删除实体"></a>创建和删除实体</h2><p>当在层级树中选中一个实体时，用户可以创建一个新的实体或者选出这个所选中的选项。或者使用位于层级树面板左上角的各种按钮，又或者通过点击操作打开内容目录来进行操作。</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161304494.png"></p>
<h4 id="3-检测器"><a href="#3-检测器" class="headerlink" title="3.检测器"></a>3.检测器</h4><blockquote>
<p>检查器面板会显示当前选定对象的属性值。</p>
<p>根据选择的不同，会现实不同的检查器面板。目前有</p>
<ul>
<li><strong>实体&#x2F;组件检查器</strong></li>
<li><strong>纹理检查器</strong></li>
<li><strong>材质检查器</strong></li>
<li><strong>Cubemap检查器</strong></li>
</ul>
<p>修改这些数值用以特制化实体的行为。譬如可以设置 Model 组件所渲染的模型，或灯光的颜色等灯。</p>
<p>有些参数是简单的文字或数值，通过标准的文字框和滑动条来进行修改。有些值需要特殊的编辑方式，譬如从资源面板中选取一个高亮的资源之类（选取纹理等）。有些值可以通过视口进行可视化编辑，譬如可以直接在视口中用Gizmo平移旋转缩放一个实体的变换属性.</p>
<p>在应用和编辑器同时运行的情况下，对实体属性的修改将会传递到运行中的应用中。一个绝佳的迭代方式是在应用运行起来之后，并排打开编辑器和应用窗口，实时的对想要的调整的值进行修正。</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161602442.png"></p>
<h4 id="4-视口"><a href="#4-视口" class="headerlink" title="4.视口"></a>4.视口</h4><blockquote>
<p>视口展示了当前场景的可视化状态。你可以通过移动摄影机在场景中自由漫游。</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161643712.png"></p>
<blockquote>
<h2 id="摄影机"><a href="#摄影机" class="headerlink" title="摄影机"></a>摄影机</h2><p>初始情况下，编辑器会采用 <strong>透视</strong> 摄影机。这种摄影机如同电影摄影机一般漂浮在场景之中。可以使用摄影机选择菜单选择场景中的不同摄影机。 <strong>正交</strong> 摄影机包含几个确定的机位：顶视图，底视图，前视图，后视图，左视图，右视图。通过这些机位可以无透视的观察场景，特别方便用来调整场景中的实体位置之类。</p>
<p>在摄影机菜单中选择摄影机的同时，场景中的摄影机实体会被显示为高亮状态。可以利用这个特性精确的设置摄影机位置。</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161804927.png"></p>
<h4 id="5-资源"><a href="#5-资源" class="headerlink" title="5.资源"></a>5.资源</h4><blockquote>
<p>资源面板管理了所有的项目中的可用资源。从这个面板可以创建，上传，删除，查看和编辑任何资源</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161917993.png"></p>
<h3 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h3><blockquote>
<p>three.js还是比PlayCanvas活跃的，当然，如果感兴趣并且有精力的话，还是建议都了解了解</p>
<p>毕竟知识是无穷无尽的</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203162850169.png"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[playcanvas-github]: 	“<a href="https://github.com/playcanvas/engine/blob/main/README-zh.md">https://github.com/playcanvas/engine/blob/main/README-zh.md</a> “<br>[playcanvas中文]: 	“<a href="https://developer.playcanvas.com/zh/">https://developer.playcanvas.com/zh/</a> “</p>
]]></content>
      <categories>
        <category>Web3D</category>
        <category>playcanvas</category>
        <category>playcanvas初识</category>
      </categories>
      <tags>
        <tag>playcanvas</tag>
      </tags>
  </entry>
  <entry>
    <title>threejs-d-1.0</title>
    <url>/2022/11/27/threejs-d-1-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="threejs-d-1-0"><a href="#threejs-d-1-0" class="headerlink" title="threejs-d-1.0"></a>threejs-d-1.0</h1><blockquote>
<p>d-1.0主要是准备我们开发环境和其他的一些准备，为了我们更好的去进入three的世界</p>
</blockquote>
<h3 id="一、搭建three-js本地网站"><a href="#一、搭建three-js本地网站" class="headerlink" title="一、搭建three.js本地网站"></a>一、搭建three.js本地网站</h3><blockquote>
<p>搭建本地网站的原因，是因为我们访问官网的时候，由于网速限制，导致我们的体验感下降，搭建本地服务器，快很多了。</p>
</blockquote>
<p>我们打开官网<a href="https://threejs.org/">Three.js</a>点击github就进入了threejs仓库了</p>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127171040581.png"></p>
<p>我们下载仓库的dev开发包</p>
<p>git clone 和 下载压缩包都可以！</p>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127171152583.png"></p>
<p>执行命令运行：</p>
<pre><code class="ini">npm i //安装依赖
npm start //运行项目
</code></pre>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127171346283.png"></p>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127171325067.png"></p>
<p>我们现在访问本地项目就快多了，我们想知道任何一个例子也可以查看其具体的文件了。</p>
<h3 id="二、使用parcel搭建threejs开发环境"><a href="#二、使用parcel搭建threejs开发环境" class="headerlink" title="二、使用parcel搭建threejs开发环境"></a>二、使用<a href="https://parceljs.org/">parcel</a>搭建threejs开发环境</h3><pre><code class="ini">npm init -y //初始化项目
npm install  parcel-bundler -D //安装parcel
</code></pre>
<p>设置入口文件main.js和index.html</p>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127173957450.png"></p>
<p>配置package.json</p>
<pre><code class="javascript">//package.json
&#123;
  &quot;name&quot;: &quot;threejs&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;dev&quot;: &quot;parcel ./src/index.html&quot;,
    &quot;build&quot;: &quot;parcel build ./src/index.html&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: &#123;
    &quot;parcel-bundler&quot;: &quot;^1.12.5&quot;
  &#125;
&#125;
</code></pre>
<p>下载threejs依赖</p>
<pre><code class="ini">npm install three --save //安装依赖
</code></pre>
<pre><code class="javascript">//main.js
import * as THREE from &#39;three&#39;
console.log(THREE)
</code></pre>
<p>运行项目，打包项目</p>
<pre><code class="ini">npm run dev //运行项目
npm run build //打包项目
</code></pre>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127174654769.png"></p>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127174742984.png"></p>
<p>运行成功！！！</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Three.js官网]: 	“<a href="https://threejs.org/">https://threejs.org/</a> “<br>[Three.js-github]: 	“<a href="https://github.com/mrdoob/three.js/">https://github.com/mrdoob/three.js/</a> “<br>[parcel官网]: 	“<a href="https://parceljs.org/&quot;">https://parceljs.org/&quot;</a><br>[parcel中文官网]: 	“<a href="https://www.parceljs.cn/">https://www.parceljs.cn/</a> “</p>
]]></content>
      <categories>
        <category>Web3D</category>
        <category>Three.js</category>
        <category>threejs-d-1.0</category>
      </categories>
      <tags>
        <tag>three.js</tag>
      </tags>
  </entry>
  <entry>
    <title>react-native环境搭建</title>
    <url>/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="react-native环境搭建（Mac-M1）"><a href="#react-native环境搭建（Mac-M1）" class="headerlink" title="react-native环境搭建（Mac M1）"></a>react-native环境搭建（Mac M1）</h1><h3 id="一、本机安装环境"><a href="#一、本机安装环境" class="headerlink" title="一、本机安装环境"></a>一、本机安装环境</h3><p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221207175048319.png"></p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221207175217956.png"></p>
<p>安装官方的说法，需要具备的环境条件</p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221207175323650.png"></p>
<p>node和npm的安装就不说了</p>
<p>下载yarn：</p>
<pre><code class="ini">npm install -g yarn
</code></pre>
<p>react-native：</p>
<pre><code class="ini">yarn add react-native --exact
</code></pre>
<pre><code class="ini">//Mac m1 安装 Homebrew
/bin/bash -c &quot;$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)&quot;

环境变量：
 echo &#39;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#39; &gt;&gt; /Users/mengfeng/.zprofile
   eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;
</code></pre>
<blockquote>
<p>建议同学们早上去下载（网好），当然，不可避免的还是要出现一系列的问题，我们根据错误提示去查询相应的解决方案就行（因为每个同学的问题都不太一样）</p>
</blockquote>
<p>下载watchman：</p>
<pre><code class="ini">brew install watchman
</code></pre>
<p>下载pod（cocoapods）：</p>
<pre><code class="ini">brew install cocoapods
</code></pre>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208082020782.png"></p>
<p>到目前为止，我们已经安装了 Node、Homebrew、watchman、cocoapods</p>
<p>下面我们来安装xcode</p>
<h3 id="二、xcode安装模拟器"><a href="#二、xcode安装模拟器" class="headerlink" title="二、xcode安装模拟器"></a>二、xcode安装模拟器</h3><p>我们在app store下载就可以，当然版本历史记录可以查看以前的xcode版本</p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208082606954.png"></p>
<p>当我们创建了一个项目，点击小三角，模拟器完美运行</p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208083302861.png"></p>
<h3 id="三、react-native创建项目"><a href="#三、react-native创建项目" class="headerlink" title="三、react-native创建项目"></a>三、react-native创建项目</h3><p>创建项目</p>
<pre><code class="ini">npx react-native init testapp
</code></pre>
<blockquote>
<p>出现报错</p>
</blockquote>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208084024802.png"></p>
<blockquote>
<p>解决以上问题的第一个error</p>
<p>报了一个警告，大概意思是不安全的写权限，目录是 &#x2F;opt&#x2F;homebrew&#x2F;bin<br>于是我们把这个目录的写权限去掉</p>
<pre><code class="ini">sudo chmod -R go-w /opt/homebrew/bin
sudo chmod -R go-w /opt/homebrew
</code></pre>
</blockquote>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208085035978.png"></p>
<blockquote>
<p>解决第一个问题</p>
<p>我们需要下载ruby 2.7.5并将ruby版本指向2.7.5</p>
</blockquote>
<p>如果你有条件的话请试试<a href="https://www.rubyonmac.dev/?utm_campaign=install-ruby-guide">macruby</a>109美元终身，ruby不太友好</p>
<p>下篇文章继续</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Mac下的环境搭建]: 	“<a href="https://juejin.cn/post/7119039164074426375">https://juejin.cn/post/7119039164074426375</a> “<br>[rbenv下载缓慢解决]: 	“<a href="https://blog.csdn.net/shine_a/article/details/103927374">https://blog.csdn.net/shine_a/article/details/103927374</a> “<br>[mac下载rbenv]: 	“<a href="https://juejin.cn/post/6899650892313100302">https://juejin.cn/post/6899650892313100302</a> “<br>[CocoaPods安装方法]: 	“<a href="https://blog.csdn.net/Wulitc/article/details/115682720&quot;">https://blog.csdn.net/Wulitc/article/details/115682720&quot;</a></p>
]]></content>
      <categories>
        <category>工程技术</category>
        <category>react-native环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>threejs-d-2.0</title>
    <url>/2022/11/29/threejs-d-2-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="threejs-d-2-0"><a href="#threejs-d-2-0" class="headerlink" title="threejs-d-2.0"></a>threejs-d-2.0</h1><h3 id="一、创建第一个threejs应用"><a href="#一、创建第一个threejs应用" class="headerlink" title="一、创建第一个threejs应用"></a>一、创建第一个threejs应用</h3><p>代码汇总：</p>
<pre><code class="javascript">//main.js
import * as THREE from &#39;three&#39;

const scene = new THREE.Scene();//创建场景
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );//创建透视相机（相机中的一种）
const renderer = new THREE.WebGLRenderer();//创建渲染器
renderer.setSize( window.innerWidth, window.innerHeight );//将输出canvas的大小调整为(width, height)并考虑设备像素比，且将视口从(0, 0)开始调整到适合大小
document.body.appendChild( renderer.domElement );//将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中

const geometry = new THREE.BoxGeometry( 1, 1, 1 );//创建几何体
const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );//创建基础网格材质
const cube = new THREE.Mesh( geometry, material );//使用构造器
scene.add( cube );//将几何体添加到场景
camera.position.z = 5;//调整相机位置（默认0，0，0）

//几何体循环旋转动画
function animate() &#123;
    requestAnimationFrame( animate );
  //旋转坐标变换
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;
  //重新渲染几何体
    renderer.render( scene, camera );
&#125;
animate();
</code></pre>
<h4 id="1-创建场景、相机、渲染器"><a href="#1-创建场景、相机、渲染器" class="headerlink" title="1.创建场景、相机、渲染器"></a>1.创建场景、相机、渲染器</h4><blockquote>
<p>如果我们有玩过三维软件的同学应该不会陌生这几个概念</p>
<p>我们下面以三维软件C4D来简单认识一下吧</p>
</blockquote>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129085326176.png"></p>
<p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。</p>
<pre><code class="javascript">const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
</code></pre>
<p>three.js里有几种不同的相机，在这里，我们使用的是<strong>PerspectiveCamera</strong>（透视摄像机）。</p>
<p>第一个参数是<strong>视野角度（FOV）</strong>。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。</p>
<p>第二个参数是<strong>长宽比（aspect ratio）</strong>。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>
<p>接下来的两个参数是<strong>近截面</strong>（near）和<strong>远截面</strong>（far）。 当物体某些部分比摄像机的<strong>远截面</strong>远或者比<strong>近截面</strong>近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>
<p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。</p>
<p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用<strong>setSize</strong>传入一个较小的值，例如<strong>window.innerWidth&#x2F;2</strong>和<strong>window.innerHeight&#x2F;2</strong>，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p>
<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用<strong>setSize</strong>时，将<strong>updateStyle</strong>（第三个参数）设为false。例如，假设你的<canvas> 标签现在已经具有了100%的宽和高，调用**setSize(window.innerWidth&#x2F;2, window.innerHeight&#x2F;2, false)**将使得你的应用程序以一半的分辨率来进行渲染。</p>
<pre><code class="javascript">document.body.appendChild( renderer.domElement );
</code></pre>
<p>最后一步很重要，我们将<strong>renderer</strong>（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。</p>
<h4 id="2-创建几何体、材质"><a href="#2-创建几何体、材质" class="headerlink" title="2.创建几何体、材质"></a>2.创建几何体、材质</h4><blockquote>
<p>对于材质这块，就是给一个没有任何属性的物体添加属性，玻璃、金属、玉、有颜色的立方体。</p>
</blockquote>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129090339038.png"></p>
<p>要创建一个立方体，我们需要一个<strong>BoxGeometry</strong>（立方体）对象. 这个对象包含了一个立方体中所有的顶点（<strong>vertices</strong>）和面（<strong>faces</strong>）。未来我们将在这方面进行更多的探索。</p>
<pre><code class="javascript">const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
camera.position.z = 5;
</code></pre>
<p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是<strong>MeshBasicMaterial</strong>。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为<strong>0x00ff00</strong>，也就是绿色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(<strong>hex colors</strong>)颜色格式来设置颜色的方式一致。</p>
<p>第三步，我们需要一个<strong>Mesh</strong>（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>
<p>默认情况下，当我们调用**scene.add()<strong>的时候，物体将会被添加到</strong>(0,0,0)**坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p>
<h4 id="3-创建渲染"><a href="#3-创建渲染" class="headerlink" title="3.创建渲染"></a>3.创建渲染</h4><blockquote>
<p>这个就比较好理解了，添加x，y，z方向的位置变化</p>
</blockquote>
<p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用一个被叫做“<strong>渲染循环</strong>”（render loop）或者“<strong>动画循环</strong>”（animate loop）的东西。</p>
<pre><code class="javascript">function animate() &#123; 
requestAnimationFrame( animate ); 
renderer.render( scene, camera ); 
&#125; 
animate();
</code></pre>
<p>在这里我们创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次&#x2F;秒）。如果你是一个浏览器游戏开发的新手，你或许会说<em>“为什么我们不直接用setInterval来实现刷新的功能呢？”</em>当然啦，我们的确可以用setInterval，但是，<strong>requestAnimationFrame</strong>有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。</p>
<p>在开始之前，如果你已经将上面的代码写入到了你所创建的文件中，你可以看到一个绿色的方块。让我们来做一些更加有趣的事 —— 让它旋转起来。</p>
<p>将下列代码添加到animate()函数中<strong>renderer.render</strong>调用的上方：</p>
<pre><code class="javascript">cube.rotation.x += 0.01; 
cube.rotation.y += 0.01;
</code></pre>
<p>这段代码每帧都会执行（正常情况下是60次&#x2F;秒），这就让立方体有了一个看起来很不错的旋转动画。基本上来说，当应用程序运行时，如果你想要移动或者改变任何场景中的东西，都必须要经过这个动画循环。当然，你可以在这个动画循环里调用别的函数，这样你就不会写出有上百行代码的<strong>animate</strong>函数。</p>
<h4 id="效果演示："><a href="#效果演示：" class="headerlink" title="效果演示："></a>效果演示：</h4><p><img src="/2022/11/29/threejs-d-2-0/image-20221129090831716.png"></p>
<h3 id="二、控制器（轨道控制器）"><a href="#二、控制器（轨道控制器）" class="headerlink" title="二、控制器（轨道控制器）"></a>二、控制器（轨道控制器）</h3><blockquote>
<p>控制器有许多，我们这先说这一种</p>
<p>轨道控制器是以物体为中心，对物体做环绕运动</p>
</blockquote>
<p>代码汇总：</p>
<pre><code class="javascript">//main.js
import * as THREE from &#39;three&#39;
import &#123; OrbitControls &#125; from &#39;three/examples/jsm/controls/OrbitControls&#39; //导入轨道控制器

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

const geometry = new THREE.BoxGeometry( 5, 5, 5 );
const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
const controls = new OrbitControls( camera,renderer.domElement  );
camera.position.set(0,20,100);
controls.update();//更新控制器。必须在摄像机的变换发生任何手动改变后调用
function animate() &#123;
    requestAnimationFrame( animate );
    controls.update();//循环更新轨道控制器
    renderer.render( scene, camera );
&#125;
animate();
</code></pre>
<p>OrbitControls( object : Camera, domElement : HTMLDOMElement )</p>
<p>object: （必须）将要被控制的相机。该相机不允许是其他任何对象的子级，除非该对象是场景自身。</p>
<p>domElement: 用于事件监听的HTML元素。</p>
<p>那我们现在就可以移动我们的相机来观察我们的物体了。</p>
<h3 id="三、添加辅助器"><a href="#三、添加辅助器" class="headerlink" title="三、添加辅助器"></a>三、添加辅助器</h3><blockquote>
<p>这个来自与我们help里面的东西，文档里查就可以了</p>
<p>添加辅助器的用处是为了更好的去开发</p>
</blockquote>
<h4 id="1-坐标辅助器"><a href="#1-坐标辅助器" class="headerlink" title="1.坐标辅助器"></a>1.坐标辅助器</h4><blockquote>
<p>用于简单模拟3个坐标轴的对象.<br>红色代表 X 轴. 绿色代表 Y 轴. 蓝色代表 Z 轴.</p>
</blockquote>
<pre><code class="javascript">const axesHelper = new THREE.AxesHelper( 5 );//轴的线段长度. 默认为 1.
scene.add( axesHelper );//添加到场景
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129155031932.png"></p>
<h4 id="2-相机辅助器"><a href="#2-相机辅助器" class="headerlink" title="2.相机辅助器"></a>2.相机辅助器</h4><blockquote>
<p>用于模拟相机视锥体的辅助对象.<br>它使用 LineSegments 来模拟相机视锥体.</p>
</blockquote>
<pre><code class="javascript">const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
const helper = new THREE.CameraHelper( camera );
scene.add( helper );
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129155852737.png"></p>
<p>CameraHelper( camera : Camera )</p>
<p>camera – 被模拟的相机.</p>
<p>为指定相机创建一个新的相机辅助对象 CameraHelper .</p>
<h4 id="3-平面辅助器"><a href="#3-平面辅助器" class="headerlink" title="3.平面辅助器"></a>3.平面辅助器</h4><blockquote>
<p>用于模拟平面 Plane 的辅助对象.</p>
</blockquote>
<pre><code class="javascript">const plane = new THREE.Plane( new THREE.Vector3( 1, 1, 0.2 ), 3 );
const helper = new THREE.PlaneHelper( plane, 100, 0xffff00 );
scene.add( helper );
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129160213446.png"></p>
<p>PlaneHelper( plane : Plane, size : Float, hex : Color )</p>
<p>plane – 被模拟的平面.<br>size – (可选的) 辅助对象的单边长度. 默认为 1.<br>color – (可选的) 辅助对象的颜色. 默认为 0xffff00.</p>
<p>创建一个线框辅助对象来表示指定平面.</p>
<h4 id="终结："><a href="#终结：" class="headerlink" title="终结："></a>终结：</h4><p>其他的辅助器，我们就自己按照需求去加吧，这个就是做一个参照</p>
<h3 id="四、物体的属性"><a href="#四、物体的属性" class="headerlink" title="四、物体的属性"></a>四、物体的属性</h3><blockquote>
<p>物体的属性，那我们要看一下cube是什么了</p>
<p>根据控制台打印，它是个Mesh类，下面有许多属性</p>
</blockquote>
<pre><code class="javascript">const geometry = new THREE.BoxGeometry( 5, 5, 5 );
const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129160944920.png"></p>
<h4 id="1-物体的位移"><a href="#1-物体的位移" class="headerlink" title="1.物体的位移"></a>1.物体的位移</h4><blockquote>
<p>控制物体的位置</p>
</blockquote>
<pre><code class="javascript">cube.position.set(10,0,0)//默认为x，y，z方向
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129161420179.png"></p>
<h4 id="2-物体的旋转"><a href="#2-物体的旋转" class="headerlink" title="2.物体的旋转"></a>2.物体的旋转</h4><blockquote>
<p>控制问题的旋转角度</p>
<p>这个不是单纯的三维向量了</p>
<p>是一个Euler类</p>
</blockquote>
<pre><code class="javascript">cube.rotation.set(Math.PI/4,0,0,&#39;XYZ&#39;)//默认为‘xyz’
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129162730828.png"></p>
<p>Euler( x : Float, y : Float, z : Float, order : String )</p>
<p>x - (optional) 用弧度表示x轴旋转量。 默认值是 <strong>0</strong>。<br>y - (optional) 用弧度表示y轴旋转量。 默认值是 <strong>0</strong>。<br>z - (optional) 用弧度表示z轴旋转量。 默认值是 <strong>0</strong>。<br>order - (optional) 表示旋转顺序的字符串，默认为’XYZ’（必须是大写）。</p>
<h4 id="3-物体的缩放"><a href="#3-物体的缩放" class="headerlink" title="3.物体的缩放"></a>3.物体的缩放</h4><blockquote>
<p>控制物体缩放</p>
</blockquote>
<pre><code class="javascript">cube.scale.set(3,2,1)
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129161943968.png"></p>
]]></content>
      <categories>
        <category>Web3D</category>
        <category>Three.js</category>
        <category>threejs-d-2.0</category>
      </categories>
      <tags>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title>threejs-d-3.0</title>
    <url>/2022/11/30/threejs-d-3-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="threejs-d-3-0"><a href="#threejs-d-3-0" class="headerlink" title="threejs-d-3.0"></a>threejs-d-3.0</h1><h3 id="一、通过Clock跟踪时间处理动画"><a href="#一、通过Clock跟踪时间处理动画" class="headerlink" title="一、通过Clock跟踪时间处理动画"></a>一、通过Clock跟踪时间处理动画</h3><blockquote>
<p>我们通过时间属性去控制物体动画，我们需要一个对象用于跟踪时间</p>
</blockquote>
<pre><code class="javascript">const clock = THREE.Clock();
const time = clock.getElapsedTime();//获取时钟运行的总时长
const getDelta = clock.getDelta();//获取两次渲染的间隔时长
</code></pre>
<p>Clock( autoStart : Boolean )</p>
<p>autoStart — (可选) 是否要在第一次调用 .getDelta() 时自动开启时钟。默认值是 <strong>true</strong>。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>.autoStart : Boolean</p>
<p>如果设置为 true，则在第一次调用 .getDelta() 时开启时钟。默认值是 <strong>true</strong>。</p>
<p>.startTime : Float</p>
<p>存储时钟最后一次调用 start 方法的时间。默认值是 <strong>0</strong>。</p>
<p>.oldTime : Float</p>
<p>存储时钟最后一次调用 start, .getElapsedTime() 或 .getDelta() 方法的时间。默认值是 <strong>0</strong>。</p>
<p>.elapsedTime : Float</p>
<p>保存时钟运行的总时长。默认值是 <strong>0</strong>。</p>
<p>.running : Boolean</p>
<p>判断时钟是否在运行。默认值是 <strong>false</strong>。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>.start () : undefined</p>
<p>启动时钟。同时将 startTime 和 oldTime 设置为当前时间。 设置 elapsedTime 为 <strong>0</strong>，并且设置 running 为 <strong>true</strong>.</p>
<p>.stop () : undefined</p>
<p>停止时钟。同时将 oldTime 设置为当前时间。</p>
<p>.getElapsedTime () : Float</p>
<p>获取自时钟启动后的秒数，同时将 .oldTime 设置为当前时间。<br>如果 .autoStart 设置为 <strong>true</strong> 且时钟并未运行，则该方法同时启动时钟。</p>
<p>.getDelta () : Float</p>
<p>获取自 .oldTime 设置后到当前的秒数。 同时将 .oldTime 设置为当前时间。<br>如果 .autoStart 设置为 <strong>true</strong> 且时钟并未运行，则该方法同时启动时钟。</p>
<h3 id="二、Gsap动画库的基本使用"><a href="#二、Gsap动画库的基本使用" class="headerlink" title="二、Gsap动画库的基本使用"></a>二、Gsap动画库的基本使用</h3><blockquote>
<p>这个动画库的API都有相关的动画示例，所以即使看不懂文档的同学使用也是可以明白的</p>
</blockquote>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130085026756.png"></p>
<h4 id="1-安装并使用"><a href="#1-安装并使用" class="headerlink" title="1.安装并使用"></a>1.安装并使用</h4><pre><code class="ini">npm install gsap //安装gsap
</code></pre>
<pre><code class="javascript">//main.js
import gsap from &#39;gsap&#39;
gsap.to(cube.position,&#123;x:20,duration:5&#125;)//动画属性，控制物体位置和运动时间（duration）
gsap.to(cube.rotation,&#123;x:Math.PI/4,duration:5&#125;)//动画属性，控制物体旋转和运动时间（duration）
</code></pre>
<p>当然我们的动画运动肯定不只是匀速运动，也是可以配置我们的缓冲器（和<a href="https://cubic-bezier.com/#.17,.67,.83,.67">贝赛尔曲线</a>差不多）</p>
<pre><code class="javascript">gsap.to(cube.position,&#123;x:20,duration:5,ease: &quot;elastic.out(1, 0.2)&quot;&#125;)
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130085456408.png"></p>
<h4 id="2-其他属性使用"><a href="#2-其他属性使用" class="headerlink" title="2.其他属性使用"></a>2.其他属性使用</h4><blockquote>
<p>我们也可以在动画开始、更新、结束去执行回调</p>
<p>我们<a href="https://greensock.com/docs/v3/GSAP/gsap.to()">gsap.to()</a>还有其他动画的属性，比如往返运动、定义关键帧、循环等等</p>
</blockquote>
<pre><code class="javascript">//main.js
import gsap from &#39;gsap&#39;
gsap.to(cube.position,&#123;
    x:20,
    duration:5,
    ease: &quot;elastic.out(1, 0.2)&quot;,
    onStart:()=&gt;&#123;console.log(&#39;动画开始&#39;)&#125;,
    onComplete:()=&gt;&#123;console.log(&#39;动画结束&#39;)&#125;,
    onUpdate:()=&gt;&#123;console.log(&#39;更新动画&#39;)&#125;
&#125;)
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130090823212.png"></p>
<p>我们还可以根据返回对象实现对动画的控制</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;threejs&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;nav&quot;&gt;
        &lt;button id=&quot;play&quot;&gt;play()&lt;/button&gt;
        &lt;button id=&quot;pause&quot;&gt;pause()&lt;/button&gt;
        &lt;button id=&quot;resume&quot;&gt;resume()&lt;/button&gt;
        &lt;button id=&quot;reverse&quot;&gt;reverse()&lt;/button&gt;
        &lt;button id=&quot;restart&quot;&gt;restart()&lt;/button&gt;
      &lt;/div&gt;
    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="javascript">const tween = gsap.to(cube.position,&#123;
    x:20,
    duration:5,
    ease: &quot;elastic.out(1, 0.2)&quot;,
    onStart:()=&gt;&#123;console.log(&#39;动画开始&#39;)&#125;,
    onComplete:()=&gt;&#123;console.log(&#39;动画结束&#39;)&#125;,
    onUpdate:()=&gt;&#123;console.log(&#39;更新动画&#39;)&#125;
&#125;)

document.querySelector(&quot;#play&quot;).onclick = () =&gt; tween.play();//开启动画
document.querySelector(&quot;#pause&quot;).onclick = () =&gt; tween.pause();//暂停动画
document.querySelector(&quot;#resume&quot;).onclick = () =&gt; tween.resume();//继续播放动画
document.querySelector(&quot;#reverse&quot;).onclick = () =&gt; tween.reverse();//反转动画
document.querySelector(&quot;#restart&quot;).onclick = () =&gt; tween.restart();//重新开始
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130092808802.png"></p>
<h3 id="三、自适应更改"><a href="#三、自适应更改" class="headerlink" title="三、自适应更改"></a>三、自适应更改</h3><blockquote>
<p>我们希望我们的画面能够适应我们屏幕的更改</p>
</blockquote>
<pre><code class="javascript">//main.js+
//监听屏幕变化
window.addEventListener(&#39;resize&#39;,()=&gt;&#123;
  //更新摄影机
    camera.aspect = window.innerWidth/window.innerHeight;
  //更新摄影机的投影矩阵
    camera.updateProjectionMatrix();
  //更新渲染器
    renderer.setSize(window.innerWidth,window.innerHeight);
  //更新渲染器的像素比
    renderer.setPixelRatio(window.devicePixelRatio);
&#125;)
</code></pre>
<h3 id="四、可视化调节"><a href="#四、可视化调节" class="headerlink" title="四、可视化调节"></a>四、可视化调节</h3><blockquote>
<p>我们在开发过程中，各种参数比较多，我们需要改一下看一下效果是否符合我们的需要，这样我们的效率就会降低。</p>
<p>所以我们需要一款能快速调节参数的可视化工具<a href="https://www.npmjs.com/package/dat.gui">dat.gui</a></p>
</blockquote>
<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><pre><code class="ini">npm install --save dat.gui
</code></pre>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><p>修改数值</p>
<pre><code class="javascript">import dat from &#39;dat.gui&#39;//引入
const gui = new dat.GUI();//初始化

gui.add(cube.position,&#39;x&#39;)//添加要控制的属性
.min(0)//最小值
.max(20)//最大值
.name(&#39;移动x坐标&#39;)//控制器名称
.step(0.1)//改变刻度
.onChange(value=&gt;console.log(&#39;x坐标改变了：&#39;+value))//坐标改变触发
.onFinishChange(value=&gt;console.log(&#39;x坐标停止改变了：&#39;+value))//坐标停止改变触发
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130103244105.png"></p>
<p>修改颜色</p>
<pre><code class="javascript">const parm = &#123;
    color:&#39;#ffffff&#39;
&#125;
gui.addColor(parm,&#39;color&#39;)
.name(&#39;物体颜色&#39;)
.onChange(value=&gt;&#123;
    cube.material.color.set(value)
&#125;)
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130105101668.png"></p>
<blockquote>
<p>我们的dat.gui还有许多API可以调用，具体的我们可以看<a href="https://github.com/dataarts/dat.gui/blob/master/API.md">dat.gui-api</a></p>
</blockquote>
<h3 id="五、BufferGeometry创建顶点创建矩形"><a href="#五、BufferGeometry创建顶点创建矩形" class="headerlink" title="五、BufferGeometry创建顶点创建矩形"></a>五、BufferGeometry创建顶点创建矩形</h3><blockquote>
<p>我们所见的立方体，是由顶点坐标创建的面形成的</p>
<p>也可以看<a href="https://mengfeng.github.io/2022/11/18/webgl/">webgl</a>里有一些基础的知识可以帮助我们理解点与面的关系</p>
<p>官方描述：是面片、线或点几何体的有效表述。包括顶点位置，面片索引、法相量、颜色值、UV 坐标和自定义缓存属性值。使用 BufferGeometry 可以有效减少向 GPU 传输上述数据所需的开销。</p>
</blockquote>
<pre><code class="javascript">//main.js
import * as THREE from &#39;three&#39;
import &#123; OrbitControls &#125; from &#39;three/examples/jsm/controls/OrbitControls&#39; 


const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

const axesHelper = new THREE.AxesHelper( 30 );//轴的线段长度. 默认为 1.
scene.add( axesHelper );//添加到场景

const geometry = new THREE.BufferGeometry();
// 创建一个简单的矩形. 在这里我们左上和右下顶点被复制了两次。
// 因为在两个三角面片里，这两个顶点都需要被用到。
const vertices = new Float32Array( [
    -1.0, -1.0,  1.0,
     1.0, -1.0,  1.0,
     1.0,  1.0,  1.0,

     1.0,  1.0,  1.0,
    -1.0,  1.0,  1.0,
    -1.0, -1.0,  1.0
] );
// itemSize = 3 因为每个顶点都是一个三元组。
geometry.setAttribute( &#39;position&#39;, new THREE.BufferAttribute( vertices, 3 ) );
const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );
const cube = new THREE.Mesh( geometry, material );
console.log(cube)

 
scene.add( cube );
const controls = new OrbitControls( camera,renderer.domElement  );
camera.position.set(0,20,100);
controls.update();
function animate() &#123;
   
    requestAnimationFrame( animate );
    controls.update();
    renderer.render( scene, camera );
&#125;
animate();

window.addEventListener(&#39;resize&#39;,()=&gt;&#123;
    // console.log(&#39;屏幕变化了&#39;)
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
&#125;)
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130162558717.png"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[GSAP]: 	“<a href="https://github.com/greensock/GSAP">https://github.com/greensock/GSAP</a> “<br>[gsap]: 	“<a href="https://greensock.com/gsap/">https://greensock.com/gsap/</a> “<br>[Cubic Bezier]: 	“<a href="https://cubic-bezier.com/#.17,.67,.83,.67">https://cubic-bezier.com/#.17,.67,.83,.67</a> “<br>[dat.gui]: 	“<a href="https://www.npmjs.com/package/dat.gui">https://www.npmjs.com/package/dat.gui</a> “<br>[dat.gui-api]: 	“<a href="https://github.com/dataarts/dat.gui/blob/master/API.md">https://github.com/dataarts/dat.gui/blob/master/API.md</a> “</p>
]]></content>
      <categories>
        <category>Web3D</category>
        <category>Three.js</category>
        <category>threejs-d-3.0</category>
      </categories>
      <tags>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title>umi-4.0</title>
    <url>/2023/01/02/umi-4-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="umi-4-0"><a href="#umi-4-0" class="headerlink" title="umi 4.0"></a>umi 4.0</h1><h2 id="Umi-4-有什么新功能？"><a href="#Umi-4-有什么新功能？" class="headerlink" title="Umi 4 有什么新功能？"></a>Umi 4 有什么新功能？</h2><p><img src="/2023/01/02/umi-4-0/image-20230102100825501.png"></p>
<h2 id="多构建引擎"><a href="#多构建引擎" class="headerlink" title="多构建引擎"></a>多构建引擎</h2><p> Umi 4 同时支持 Vite 和 Webpack 两种构建方式，并尽量确保他们之间功能的一致性，让开发者可以通过一行配置进行切换。可能有些同学会喜欢 dev 用 vite，build 用 webpack 这样的组合。同时我们也在探索包括 ESMi 在内的其他构建方案的探索。</p>
<pre><code class="javascript">export default &#123;
  vite: &#123;&#125;
&#125;
</code></pre>
<h2 id="默认快"><a href="#默认快" class="headerlink" title="默认快"></a>默认快</h2><p>默认快是多维度的，我们通过 MFSU V3 + Webpack 5 缓存解 Dev 时编译慢的问题；内网还有通过 Webpack 5 物理缓存和 CD 平台结合解 Build 时编译慢的问题；有使用 esbuild 做 js 和 css 的压缩器、配置和 MOCK 文件的读取、jest 的 transformer，让除构建之外的其他环节也飞快；此外还有运行时速度也有考虑。</p>
<h2 id="MFSU-V3"><a href="#MFSU-V3" class="headerlink" title="MFSU V3"></a>MFSU V3</h2><p>Umi 3 的 MFSU 大家可能多少有接触过，虽然有用，但 DX 不够好。用的时候会遇到一些坑，以至于很多同学都掌握了一项特殊技能，遇到问题时 rm -rf src&#x2F;.umi。大家可能会遇到 monorepo 不支持、热更新导致 Tab 卡死、请求多导致页面打开慢、一些语法不支持的问题。以上问题在 MFSU V3 中全解！基于此，我们非常有信心地在 Umi 4 中默认开启 MFSU 功能。当然，如果你不喜欢，会保留手动配置 mfsu: false 关闭的口子。同时，MFSU V3 还可脱离 Umi 独立使用。</p>
<p><img src="/2023/01/02/umi-4-0/42ccadf17ce44ef48af14f70a9071303.png"></p>
<h2 id="Umi-Max"><a href="#Umi-Max" class="headerlink" title="Umi Max"></a>Umi Max</h2><p>这是内部 Bigfish 框架的对外版本，解我们自己的问题，同时也给社区另一个集中化框架的选择，定位是中后台框架，包含了中后台相关的大量最佳实践的插件。如果有定制需求，大家可以参考他来实现内网框架的定制，比如快手团队就有基于 Umi 4 的框架定制，还有 Alita 也是基于 Umi 定制的面向移动端的框架。</p>
<pre><code class="ini">$ npm i @umijs/max -D
</code></pre>
<h2 id="React-Router-6"><a href="#React-Router-6" class="headerlink" title="React Router 6"></a>React Router 6</h2><p>我们升级了路由方案到 React Router 6，喜忧参半。好消息是，React Router 6 是 Remix 的基础库，面向框架层做了很多优化，路由实现层更优雅，Umi 得以删除大量路由渲染的代码；坏消息是，带来不少 Break Change，比如之前父路由渲染子路由用 children，得换成 。</p>
<pre><code class="javascript">- &#123; props.children &#125;
+ &lt;Outlet /&gt;
</code></pre>
<h2 id="支持-Vue"><a href="#支持-Vue" class="headerlink" title="支持 Vue"></a>支持 Vue</h2><p>Umi 4 中提供了 Vue 支持，记得我在 Umi 2 时画过一张架构图，其中就有 Vue 的一环，Umi 3 时也有过尝试，但那会 Vue 3 还不太成熟，接入时遇到不少坑，这个坑今天总算是补上了。此功能由社区同学操刀，只需装载一个 preset 即可切换到 Vue。</p>
<pre><code class="javascript">export default &#123;
  presets: [&#39;@umijs/preset-vue&#39;],
&#125;;
</code></pre>
<h2 id="默认最快的-CSR-请求"><a href="#默认最快的-CSR-请求" class="headerlink" title="默认最快的 CSR 请求"></a>默认最快的 CSR 请求</h2><p>项目构建快解的是 DX 问题，但同时也应该关注 UX。Client Loader 的目的是让应用加载默认快，避免 React 项目经典的 Render-Then-Fetch 的加载瀑布流问题。效果见下图，示例项目的从 9s 降到 6s，这 6s 还是之前截的图，上了 Preload 功能之后其实已更快。</p>
<pre><code class="javascript">export default function() &#123;
  // 使用请求数据
  useClientLoaderData()
&#125;
// 声明请求
export function clientLoader() &#123;&#125;
</code></pre>
<p><img src="/2023/01/02/umi-4-0/96cb23f5545845f6bcd7430b9ddd35a7.png"></p>
<h2 id="白盒文档的-Lint。"><a href="#白盒文档的-Lint。" class="headerlink" title="白盒文档的 Lint。"></a>白盒文档的 Lint。</h2><p> Umi 4 里内置了我们精挑细选的 lint 规则，只有质量类不开可能会导致项目问题的规则，不包含风格类的规则，不包含 TypeScript 中 type-aware 类的规则，这类规则需要跑整个项目，会导致性能问题；同时，我们通过 @rushstack&#x2F;eslint-pach 的方式锁定了 config 里找 plugin 的规则，确保规则是长期稳定的。</p>
<h2 id="SSR。"><a href="#SSR。" class="headerlink" title="SSR。"></a>SSR。</h2><p> Umi 4 重写了 SSR 功能，目前此功能还在 beta 阶段，请勿将其用于生产环境。Umi 4 的 SSR 有以下特点，1）server 代码的构建基于 esbuild，所以极快，2）请求的处理类似 next.js 的 getServerSideProps 和 remix 的 loader，只在服务端跑，3）基于 react 18 的 suspense 和 renderToPipeableStream。实现原因，部署层目前仅实现了 vercel 的 adapter。这里有个简单的 Todos 示例：<a href="https://link.juejin.cn/?target=https://test-vercel-chencheng.vercel.app/">test-vercel-chencheng.vercel.app&#x2F;</a></p>
<pre><code class="javascript">export default &#123;
  ssr: &#123; platform: &#39;vercel&#39; &#125;
&#125;
</code></pre>
<h2 id="API-路由"><a href="#API-路由" class="headerlink" title="API 路由"></a>API 路由</h2><p>Umi 4 约定 src&#x2F;api 目录下存放的 Serverless Function 格式的文件即为 API 路由。这部分路由会打包成不同平台支持的 Serverless Function 产物。场景比如带 token 的 API 调用、动态数据源、基于 Notion API 的 Blog、Hackernews Clone 等等。基于此，Umi 能做的事的边界就大了很多。不再只是写写中后台，实现静态页面。</p>
<pre><code class="javascript">export default &#123;
  apiRoute: &#123;&#125;,
&#125;
</code></pre>
<h2 id="微生成器"><a href="#微生成器" class="headerlink" title="微生成器"></a>微生成器</h2><p>此概念来自 Modern.js。Modern.js 引入很多新概念，其中「微生成器」还是非常贴切的。他包含两个功能，1）小型脚手架，2）功能的开启与关闭。Umi 3 虽然也有 generate 命令，但只包含功能 1。Umi 4 拓展了下 generate（alias 为 g）命令。除了支持更多类型的小型脚手架生成，还支持功能的开启与关闭，以及比如 Monorepo、react 和 antd 版本等的功能切换。</p>
<pre><code class="ini">$ npx umi g
? Pick generator type › - Use arrow-keys. Return to submit.
❯   创建页面 -- Create a umi page by page name
    创建组件 -- .
    创建 mock 代码 -- .
    创建 model 代码 -- .
    启用 Prettier -- Setup Prettier Configurations
    启用 Jest -- Setup Jest Configuration
    启用 E2E 测试 -- .
    启用 Tailwind CSS -- Setup Tailwind CSS configuration
    启用 SSR -- .
    启用 Low Import 研发模式 -- .
    启用权限方案 -- .
    启用 Monaco 编辑器 -- .
    关闭 Dva 数据流 -- Configuration, Dependencies, and Model Files for Dva
    关闭 MFSU -- .
    切换为 Monorepo 项目 -- .
    切换 React 为 18 -- .
    切换 Antd 为 5 -- .
</code></pre>
<p>除此之外，我们还有非常多小而美的 DX 改进。</p>
<h2 id="自动-https"><a href="#自动-https" class="headerlink" title="自动 https"></a>自动 https</h2><p> Umi 4 的 https dev server 的实现基于 mkcert，启动过程中会基于 hosts 自动生成对应的 key 和 cert。开发者除了安装前置的 mkcert，其他无需关心。</p>
<p><img src="/2023/01/02/umi-4-0/1dd8df4ee5a346818acba7bd6a0f3a47.png"></p>
<h2 id="浏览器里的构建进度条。"><a href="#浏览器里的构建进度条。" class="headerlink" title="浏览器里的构建进度条。"></a>浏览器里的构建进度条。</h2><p>如果首次构建没有完成就在浏览器里打开，你会看到一个构建进度条，支持 webpack 多实例，支持 MFSU，完成初始构建后会自动跳转到项目页。</p>
<p><img src="/2023/01/02/umi-4-0/ae6c76af39ae4dcbad21e186de7e1d29.png"></p>
<h2 id="Terminal-中的日志"><a href="#Terminal-中的日志" class="headerlink" title="Terminal 中的日志"></a>Terminal 中的日志</h2><p>有些开发者会更希望在命令行里看到项目里通过 console 输出的日志，比如我。因为命令行日志不会随着刷新而失效，大家可能都经历过一些一闪而过的页面，想截屏都难；同时命令行日志还可以做物理存储，导出后可以方便他人排查。此功能复刻自 <a href="https://link.juejin.cn/?target=https://github.com/patak-dev/vite-plugin-terminal%E3%80%82">github.com&#x2F;patak-dev&#x2F;v…</a></p>
<pre><code class="ini">import &#123; terminal &#125; from &#39;umi&#39;;
terminal.log(`Some info from the app`);
</code></pre>
<p>然后就可以在命令行中看到日志，</p>
<p><img src="/2023/01/02/umi-4-0/53371b8fabe340eaabc9b00abecd7623.png"></p>
<h2 id="umi-js-产物调试"><a href="#umi-js-产物调试" class="headerlink" title="umi.js 产物调试"></a>umi.js 产物调试</h2><p>不知大家是否会有这样的需求，开发项目时发现一些比较复杂的问题时，需要调整构建产物的代码。而 Umi 基于 webpack-dev-server，在 dev 阶段所有文件都存于内存中，没有物理文件的形式，并不方便直接修改后验证效果。如果大家用 Umi 4，可以把 umi.js 等产物文件保存到项目根目录，然后可以直接修改即生效。</p>
<p><img src="/2023/01/02/umi-4-0/e11af2c3f8cb4e5c84b697000c41e7c5.png"></p>
<h2 id="项目级插件：plugin-ts"><a href="#项目级插件：plugin-ts" class="headerlink" title="项目级插件：plugin.ts"></a>项目级插件：plugin.ts</h2><p> 为进一步降低项目中使用插件的门槛，Umi 4 中约定项目根目录下的 plugin.ts 为插件，开发者可在此直接调用插件 API，无需注册，支持 TypeScript。有了这个文件，我们可以在项目级做很多事。比如，</p>
<pre><code class="javascript">import &#123; IApi &#125; from &#39;umi&#39;;
export default (api: IApi) =&gt; &#123;
  // 比如修改 HTML
  api.modifyHTML($ =&gt; &#123;
    return $;
  &#125;);
  // 比如在入口的 umi.ts 中添加代码
  api.addEntryCodeAhead(() =&gt; [`console.log(&#39;entry code ahead&#39;)`]);
  api.addEntryCode(() =&gt; [`console.log(&#39;entry code&#39;)`]);
  // 比如在构建完成时做额外的事
  api.onBuildComplete((opts) =&gt; &#123;&#125;);
  // 比如在启动阶段做额外的事
  api.onStart((opts) =&gt; &#123;&#125;);
  // 比如校验每个 JavaScript/TypeScript 代码
  api.onCheckCode((args) =&gt; &#123;&#125;);
  // 比如动态修改路由
  api.modifyRoutes((routes) =&gt; &#123;&#125;);
&#125;
</code></pre>
<h2 id="deadCode-检测"><a href="#deadCode-检测" class="headerlink" title="deadCode 检测"></a>deadCode 检测</h2><p> 项目中通常会有未使用的文件或导出，Umi 4 中通过配置 deadCode: {} 即可在 build 阶段做检测。如有发现，会有类似信息抛出。</p>
<pre><code class="javascript">Warning: There are 3 unused files:
 1. /mock/a.ts
 2. /mock/b.ts
 3. /pages/index.module.less
 Please be careful if you want to remove them (¬º-°)¬.
</code></pre>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[umi仓库]: 	“<a href="https://github.com/umijs/umi">https://github.com/umijs/umi</a> “</p>
]]></content>
      <categories>
        <category>umi.js</category>
        <category>umi-4.0</category>
      </categories>
      <tags>
        <tag>umi</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp安装及调试</title>
    <url>/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="uniapp安装及调试"><a href="#uniapp安装及调试" class="headerlink" title="uniapp安装及调试"></a>uniapp安装及调试</h1><blockquote>
<p>我们本篇文章主要讲解uniapp的项目创建</p>
<p>真机调试、ios模拟器调试、微信小程序调试</p>
</blockquote>
<h3 id="一、下载HBuilder-X"><a href="#一、下载HBuilder-X" class="headerlink" title="一、下载HBuilder X"></a>一、下载HBuilder X</h3><p>[HBuilder X]: 	“<a href="https://www.dcloud.io/hbuilderx.html">https://www.dcloud.io/hbuilderx.html</a> “</p>
<p>我们可以下载我们需要的版本</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218095304650.png"></p>
<h3 id="二、安装运行并创建项目"><a href="#二、安装运行并创建项目" class="headerlink" title="二、安装运行并创建项目"></a>二、安装运行并创建项目</h3><p>第一次打开HBuilder X，我们可以去定义一下我们的配置，macos是去偏好设置，windows的在工具-&gt;设置</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218095514743.png"></p>
<p>我们可以去新建项目弹出窗口配置我们项目信息，项目名称和vue版本，这里我现在的是vue3，vue3的绑定预设是vite。</p>
<p>我们也可以去选择不一样的模板。</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218095735225.png"></p>
<h3 id="三、运行项目"><a href="#三、运行项目" class="headerlink" title="三、运行项目"></a>三、运行项目</h3><p>当我们打开项目的时候，准备运行的时候，我们可以选择将我们的项目运行到哪里，它会提示你安装相对应的插件，如果安装完插件，我们的软件没有识别到我们的插件，那我们可以选择重启我们的软件。</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218100111748.png"></p>
<p>这里先演示一下运行到内置浏览器（第一次运行我们可能要稍等一下）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218100428208.png"></p>
<h3 id="四、调试"><a href="#四、调试" class="headerlink" title="四、调试"></a>四、调试</h3><h4 id="1-ios模拟器调试"><a href="#1-ios模拟器调试" class="headerlink" title="1.ios模拟器调试"></a>1.ios模拟器调试</h4><blockquote>
<p>当然，在ios模拟器调试的前提是要是macos环境，并且下载了xcode（提前准备一下哦）因为我没有ios手机🫠</p>
</blockquote>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218100850001.png"></p>
<p>我们选择运行到ios模拟器 App基座（loading…）</p>
<p>选择我们的模拟器手机型号</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218101003209.png"></p>
<p>现在我就可以看到程序运行到了我们的iPhone 14 Pro Max（香得嘞）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218101115311.png"></p>
<p>当我们修改我们的程序代码并保存，就可以看见我们的视图更新了</p>
<h4 id="2-Android手机真机调试"><a href="#2-Android手机真机调试" class="headerlink" title="2.Android手机真机调试"></a>2.Android手机真机调试</h4><blockquote>
<p>当然，没有Android手机的也可以借其他同学的（Android模拟器配置有点麻烦，就先不配置了，想配置的同学先自行打开搜索🔍）</p>
</blockquote>
<p>手机真机调试的前提是要打开你的手机的开发者模式，不同的手机开启的方式也是不一样的，我的手机是红米K20 pro</p>
<p>具体打开流程为设置-&gt;我的设备-&gt;全部参数-&gt;点击MIUI版本3下（连击）系统提示进入开发者模式-&gt;返回到更多设置-&gt;开发者选项-&gt;打开usb调试</p>
<p>当我们选择运行到Android App基座，就会识别你的手机（记得用数据线将手机连接到电脑），点击运行</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218102154748.png"></p>
<p>第一次运行，手机会让你安装，点击安装就可以了</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/WechatIMG125.jpeg"></p>
<h4 id="3-微信小程序开发者工具调试"><a href="#3-微信小程序开发者工具调试" class="headerlink" title="3.微信小程序开发者工具调试"></a>3.微信小程序开发者工具调试</h4><blockquote>
<p>这个调试的方式的前提是要有一个开发者账号，没有的同学要先去注册一个</p>
<p>[注册]: 	“<a href="https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN">https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN</a> “</p>
<p>然后利用注册绑定的微信登陆我们的微信公众平台</p>
<p>没有下载微信开发者工具的同学也要下载一个</p>
</blockquote>
<p>然后在我们的开发-&gt;开发管理-&gt;开发设置下面有我们的开发者ID（等会要用）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218102931643.png"></p>
<p>当我们点击发行-&gt;小程序-微信的时候，会让你配置你的开发者ID，然后项目就会自动打包</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218103403063.png"></p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218103530235.png"></p>
<p>第一次编译的时候，我们可以根据编译完成的项目路径去手动导入我们的微信开发者工具去调试</p>
<p>注意：不要在微信开发者工具去修改我们的代码，因为下一次发行编译会覆盖掉我们的修改</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218103710649.png"></p>
<p>当然，我们还有另一种导入方法，那就是自动导入</p>
<p>首先我们要将微信开发者工具的安全设置的服务端口打开</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218104049483.png"></p>
<p>再到HBuilder X去配置微信开发者工具的路径（这里的路径可以查看自己的安装路径）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218104502864.png"></p>
<p>到这我们的配置就完成了</p>
<p>接下来我们再发行微信小程序</p>
<p>我们就可以看见微信开发者工具自动打开并运行我们的项目了</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218104719407.png"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>到目前为止，我们开发时候的调试就可以轻松掌握了</p>
]]></content>
      <categories>
        <category>uniapp</category>
        <category>uniapp安装及调试</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>uniapp生命周期</title>
    <url>/2022/12/20/uniapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="uniapp生命周期"><a href="#uniapp生命周期" class="headerlink" title="uniapp生命周期"></a>uniapp生命周期</h1><h3 id="一、应用生命周期"><a href="#一、应用生命周期" class="headerlink" title="一、应用生命周期"></a>一、应用生命周期</h3><p>uni-app 支持如下应用生命周期函数：</p>
<p><img src="/2022/12/20/uniapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20221220094520002.png"></p>
<p>这几个函数主要还是在App.vue这个文件进行定义，注意：</p>
<p>应用生命周期仅可在App.vue中监听，在其它页面监听无效。<br>onlaunch里进行页面跳转</p>
<p>onPageNotFound 页面实际上已经打开了（比如通过分享卡片、小程序码）且发现页面不存在，才会触发，api 跳转不存在的页面不会触发（如 uni.navigateTo）</p>
<h3 id="二、页面生命周期"><a href="#二、页面生命周期" class="headerlink" title="二、页面生命周期"></a>二、页面生命周期</h3><p><code>uni-app</code> 支持如下页面生命周期函数：</p>
<table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">说明</th>
<th align="left">平台差异说明</th>
<th align="left">最低版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onInit</td>
<td align="left">监听页面初始化，其参数同 onLoad 参数，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad</td>
<td align="left">百度小程序</td>
<td align="left">3.1.0+</td>
</tr>
<tr>
<td align="left">onLoad</td>
<td align="left">监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考<a href="https://zh.uniapp.dcloud.io/api/router#navigateto">示例</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onShow</td>
<td align="left">监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onReady</td>
<td align="left">监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onHide</td>
<td align="left">监听页面隐藏</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onUnload</td>
<td align="left">监听页面卸载</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onResize</td>
<td align="left">监听窗口尺寸变化</td>
<td align="left">App、微信小程序、快手小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onPullDownRefresh</td>
<td align="left">监听用户下拉动作，一般用于下拉刷新，参考<a href="https://zh.uniapp.dcloud.io/api/ui/pulldown">示例</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onReachBottom</td>
<td align="left">页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。具体见下方注意事项</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onTabItemTap</td>
<td align="left">点击 tab 时触发，参数为Object，具体见下方注意事项</td>
<td align="left">微信小程序、QQ小程序、支付宝小程序、百度小程序、H5、App、快手小程序、京东小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onShareAppMessage</td>
<td align="left">用户点击右上角分享</td>
<td align="left">微信小程序、QQ小程序、支付宝小程序、字节小程序、飞书小程序、快手小程序、京东小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onPageScroll</td>
<td align="left">监听页面滚动，参数为Object</td>
<td align="left">nvue暂不支持</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onNavigationBarButtonTap</td>
<td align="left">监听原生标题栏按钮点击事件，参数为Object</td>
<td align="left">App、H5</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onBackPress</td>
<td align="left">监听页面返回，返回 event &#x3D; {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：<a href="http://ask.dcloud.net.cn/article/35120">onBackPress 详解</a>。支付宝小程序只有真机能触发，只能监听非navigateBack引起的返回，不可阻止默认行为。</td>
<td align="left">app、H5、支付宝小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onNavigationBarSearchInputChanged</td>
<td align="left">监听原生标题栏搜索输入框输入内容变化事件</td>
<td align="left">App、H5</td>
<td align="left">1.6.0</td>
</tr>
<tr>
<td align="left">onNavigationBarSearchInputConfirmed</td>
<td align="left">监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。</td>
<td align="left">App、H5</td>
<td align="left">1.6.0</td>
</tr>
<tr>
<td align="left">onNavigationBarSearchInputClicked</td>
<td align="left">监听原生标题栏搜索输入框点击事件（pages.json 中的 searchInput 配置 disabled 为 true 时才会触发）</td>
<td align="left">App、H5</td>
<td align="left">1.6.0</td>
</tr>
<tr>
<td align="left">onShareTimeline</td>
<td align="left">监听用户点击右上角转发到朋友圈</td>
<td align="left">微信小程序</td>
<td align="left">2.8.1+</td>
</tr>
<tr>
<td align="left">onAddToFavorites</td>
<td align="left">监听用户点击右上角收藏</td>
<td align="left">微信小程序、QQ小程序</td>
<td align="left">2.8.1+</td>
</tr>
</tbody></table>
<p><code>onInit</code>使用注意</p>
<ul>
<li>仅百度小程序基础库 3.260 以上支持 onInit 生命周期</li>
<li>其他版本或平台可以同时使用 onLoad 生命周期进行兼容，注意避免重复执行相同逻辑</li>
<li>不依赖页面传参的逻辑可以直接使用 created 生命周期替代</li>
</ul>
<p><code>onReachBottom</code>使用注意 可在pages.json里定义具体页面底部的触发距离<a href="https://zh.uniapp.dcloud.io/collocation/pages#globalstyle">onReachBottomDistance</a>，比如设为50，那么滚动页面到距离底部50px时，就会触发onReachBottom事件。</p>
<p>如使用scroll-view导致页面没有滚动，则触底事件不会被触发。scroll-view滚动到底部的事件请参考scroll-view的文档</p>
<p><code>onPageScroll</code> （监听滚动、滚动监听、滚动事件）参数说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scrollTop</td>
<td>Number</td>
<td>页面在垂直方向已滚动的距离（单位px）</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li><code>onPageScroll</code>里不要写交互复杂的js，比如频繁修改页面。因为这个生命周期是在渲染层触发的，在非h5端，js是在逻辑层执行的，两层之间通信是有损耗的。如果在滚动过程中，频发触发两层之间的数据交换，可能会造成卡顿。</li>
<li>如果想实现滚动时标题栏透明渐变，在App和H5下，可在pages.json中配置titleNView下的type为transparent，<a href="https://uniapp.dcloud.io/collocation/pages?id=app-titlenview">参考</a>。</li>
<li>如果需要滚动吸顶固定某些元素，推荐使用css的粘性布局，参考<a href="https://ext.dcloud.net.cn/plugin?id=715">插件市场</a>。插件市场也有其他js实现的吸顶插件，但性能不佳，需要时可自行搜索。</li>
<li>在App、微信小程序、H5中，也可以使用wxs监听滚动，<a href="https://uniapp.dcloud.io/tutorial/miniprogram-subject#wxs">参考</a>；在app-nvue中，可以使用bindingx监听滚动，<a href="https://uniapp.dcloud.io/tutorial/nvue-api#nvue-%E9%87%8C%E4%BD%BF%E7%94%A8-bindingx">参考</a>。</li>
<li><code>onBackPress</code>上不可使用<code>async</code>，会导致无法阻止默认返回</li>
</ul>
<pre><code class="js">onPageScroll : function(e) &#123; //nvue暂不支持滚动监听，可用bindingx代替
    console.log(&quot;滚动距离为：&quot; + e.scrollTop);
&#125;,
</code></pre>
<p><code>onTabItemTap</code> 返回的json对象说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>Number</td>
<td>被点击tabItem的序号，从0开始</td>
</tr>
<tr>
<td>pagePath</td>
<td>String</td>
<td>被点击tabItem的页面路径</td>
</tr>
<tr>
<td>text</td>
<td>String</td>
<td>被点击tabItem的按钮文字</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li>onTabItemTap常用于点击当前tabitem，滚动或刷新当前页面。如果是点击不同的tabitem，一定会触发页面切换。</li>
<li>如果想在App端实现点击某个tabitem不跳转页面，不能使用onTabItemTap，可以使用<a href="http://www.html5plus.org/doc/zh_cn/nativeobj.html">plus.nativeObj.view</a>放一个区块盖住原先的tabitem，并拦截点击事件。</li>
<li>支付宝小程序平台onTabItemTap表现为点击非当前tabitem后触发，因此不能用于实现点击返回顶部这种操作</li>
</ul>
<pre><code class="js">onTabItemTap : function(e) &#123;
    console.log(e);
    // e的返回格式为json对象： &#123;&quot;index&quot;:0,&quot;text&quot;:&quot;首页&quot;,&quot;pagePath&quot;:&quot;pages/index/index&quot;&#125;
&#125;,
</code></pre>
<p><code>onNavigationBarButtonTap</code> 参数说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>Number</td>
<td>原生标题栏按钮数组的下标</td>
</tr>
</tbody></table>
<pre><code class="js">onNavigationBarButtonTap : function (e) &#123;
    console.log(e);
    // e的返回格式为json对象：&#123;&quot;text&quot;:&quot;测试&quot;,&quot;index&quot;:0&#125;
&#125;
</code></pre>
<p><code>onBackPress</code> 回调参数对象说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>from</td>
<td>String</td>
<td>触发返回行为的来源：’backbutton’——左上角导航栏按钮及安卓返回键；’navigateBack’——uni.navigateBack() 方法。<strong>支付宝小程序端不支持返回此字段</strong></td>
</tr>
</tbody></table>
<pre><code class="javascript">export default &#123;
    data() &#123;
        return &#123;&#125;;
    &#125;,
    onBackPress(options) &#123;
        console.log(&#39;from:&#39; + options.from)
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong></p>
<ul>
<li>nvue 页面weex编译模式支持的生命周期同weex，具体参考：<a href="https://uniapp.dcloud.io/tutorial/nvue-outline?id=%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F">weex生命周期介绍</a>。</li>
<li>支付宝小程序真机可以监听到非<code>navigateBack</code>引发的返回事件（使用小程序开发工具时不会触发<code>onBackPress</code>），不可以阻止默认返回行为</li>
</ul>
<h3 id="三、组件生命周期"><a href="#三、组件生命周期" class="headerlink" title="三、组件生命周期"></a>三、组件生命周期</h3><p><code>uni-app</code> 组件支持的生命周期，与vue标准组件的生命周期相同。这里没有页面级的onLoad等生命周期：</p>
<table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">说明</th>
<th align="left">平台差异说明</th>
<th align="left">最低版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">在实例初始化之前被调用。<a href="https://v2.cn.vuejs.org/v2/api/#beforeCreate">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">在实例创建完成后被立即调用。<a href="https://v2.cn.vuejs.org/v2/api/#created">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">在挂载开始之前被调用。<a href="https://v2.cn.vuejs.org/v2/api/#beforeMount">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">挂载到实例上去之后调用。<a href="https://v2.cn.vuejs.org/v2/api/#mounted">详见</a> 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用<code>$nextTick</code><a href="https://v2.cn.vuejs.org/v2/api/#vm-nextTick">Vue官方文档</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">数据更新时调用，发生在虚拟 DOM 打补丁之前。<a href="https://v2.cn.vuejs.org/v2/api/#beforeUpdate">详见</a></td>
<td align="left">仅H5平台支持</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">updated</td>
<td align="left">由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<a href="https://v2.cn.vuejs.org/v2/api/#updated">详见</a></td>
<td align="left">仅H5平台支持</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td align="left">实例销毁之前调用。在这一步，实例仍然完全可用。<a href="https://v2.cn.vuejs.org/v2/api/#beforeDestroy">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">destroyed</td>
<td align="left">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<a href="https://v2.cn.vuejs.org/v2/api/#destroyed">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[uniapp]: 	“<a href="https://zh.uniapp.dcloud.io/tutorial/page.html#lifecycle">https://zh.uniapp.dcloud.io/tutorial/page.html#lifecycle</a> “</p>
]]></content>
      <categories>
        <category>uniapp</category>
        <category>uniapp生命周期</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
      </tags>
  </entry>
  <entry>
    <title>vite配置</title>
    <url>/2022/11/22/vite%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="vite配置"><a href="#vite配置" class="headerlink" title="vite配置"></a>vite配置</h1><p>最直观的体验是“快速”、“清爽”，开发效率也得到明显提升（解决掉了webpack开发服务器存在的痛点）。</p>
<p>初始化完成后，工程目录如下：</p>
<p><img src="/2022/11/22/vite%E9%85%8D%E7%BD%AE/image-20221122094453903.png"></p>
<p>VS Code插件：Vite</p>
<p>配置详情：</p>
<p>vite.config.ts</p>
<pre><code class="javascript">import &#123; defineConfig, loadEnv &#125; from &#39;vite&#39;;
import vue from &#39;@vitejs/plugin-vue&#39;;
import vueJSX from &#39;@vitejs/plugin-vue-jsx&#39;;
import Components from &#39;unplugin-vue-components/vite&#39;;
import &#123; AntDesignVueResolver &#125; from &#39;unplugin-vue-components/resolvers&#39;;
import &#123; resolve &#125; from &#39;path&#39;;
import &#123; initDevProxy &#125; from &#39;./http-proxy&#39;;

// https://vitejs.dev/config/
export default defineConfig((&#123; mode &#125;) =&gt; &#123;
  const env = loadEnv(mode, process.cwd(), &#39;&#39;);
  return &#123;
    // 自定义公共基础路径（取自 .env(.*) 文件）
    base: env.VITE_BASE_PATH,
    // 定义全局常量替换方式
    define: &#123;
      // 取消启用Vue.2x中选项式api（这部分不会被打包）
      &#39;__VUE_OPTIONS_API__&#39;: false,
    &#125;,
    // 配置vite插件
    plugins: [
      vue(),
      vueJSX(),
      // 自动化的组件按需引入配置
      Components(&#123;
        extensions: [&#39;vue&#39;, &#39;tsx&#39;],
        resolvers: [
          AntDesignVueResolver(&#123; resolveIcons: true &#125;),
        ],
        include: [/\.vue$/, /\.vue\?vue/, /\.tsx$/],
      &#125;),
    ],
    // 配置解析项
    resolve: &#123;
      // 路径别名
      alias: &#123;
        &#39;@/&#39;: resolve(__dirname, &#39;src&#39;) + &#39;/&#39;,
      &#125;,
    &#125;,
    // 样式处理配置项
    css: &#123;
      // CSS module
      modules: &#123;
        generateScopedName: `_[name]_[local]_[hash:base64:6]_`,
      &#125;,
      // 传递给特定css样式预处理器的配置
      preprocessorOptions: &#123;
        less: &#123;
          javascriptEnabled: true,
        &#125;,
      &#125;,
    &#125;,
    // 配置开发服务器
    server: &#123;
      open: true,
      proxy: initDevProxy(),
    &#125;,
    // 自定义打包项配置
    build: &#123;
      // 大文件告警阈值(kb)
      chunkSizeWarningLimit: 400,
    &#125;,
  &#125;;
&#125;);
</code></pre>
<p>http-proxy.ts</p>
<pre><code class="javascript">import type &#123; ProxyOptions &#125; from &#39;vite&#39;;

/**
 * 初始化开发服务器代理
 */
export const initDevProxy = (): Record&lt;string, string | ProxyOptions&gt; =&gt; &#123;
  return &#123;
    // 临时示例
    &#39;/api&#39;: &#123;
      target: &#39;&#39;,
      changeOrigin: true,
    &#125;,
  &#125;;
&#125;;
</code></pre>
<p>以上的配置是项目配置的一部分，其他所需要的配置按照自己的需要去官网查询就可以，官网基于没个配置都有详细讲解。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Vite中文官网]: 	“<a href="https://cn.vitejs.dev/guide/">https://cn.vitejs.dev/guide/</a> “</p>
]]></content>
      <categories>
        <category>工程技术</category>
        <category>vite配置</category>
      </categories>
      <tags>
        <tag>vite</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn命令详解</title>
    <url>/2022/11/09/yarn%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="yarn命令详解"><a href="#yarn命令详解" class="headerlink" title="yarn命令详解"></a>yarn命令详解</h1><h3 id="一、yarn安装初始化"><a href="#一、yarn安装初始化" class="headerlink" title="一、yarn安装初始化"></a>一、yarn安装初始化</h3><pre><code class="css">npm i yarn -g #yarn安装
yarn -v #查看版本
yarn init ｜ yarn #初始化，创建package.json文件
yarn init --yes #简写 -y 跳过会话，直接通过默认值生成 package.json
</code></pre>
<h3 id="二、yarn安装依赖"><a href="#二、yarn安装依赖" class="headerlink" title="二、yarn安装依赖"></a>二、yarn安装依赖</h3><pre><code class="css">yarn add webpack@2.3.3 # yarn --save 是 yarn 默认的，默认记录在 package.json dependencies 中
</code></pre>
<pre><code class="css">yarn add webpack --dev # yarn 简写 -D  devDependencies 中
</code></pre>
<pre><code class="css">yarn global add webpack # yarn 安装全局依赖
</code></pre>
<h3 id="三、yarn更新依赖"><a href="#三、yarn更新依赖" class="headerlink" title="三、yarn更新依赖"></a>三、yarn更新依赖</h3><pre><code class="css">yarn upgrade # 升级所有依赖项，不记录在 package.json 中
yarn upgrade webpack # 升级指定包
yarn upgrade --latest # 忽略版本规则，升级到最新版本，并且更新 package.json
</code></pre>
<h3 id="四、yarn移除依赖"><a href="#四、yarn移除依赖" class="headerlink" title="四、yarn移除依赖"></a>四、yarn移除依赖</h3><pre><code class="css">yarn remove webpack # yarn
</code></pre>
<h3 id="五、其他命令"><a href="#五、其他命令" class="headerlink" title="五、其他命令"></a>五、其他命令</h3><pre><code class="css">yarn install # 或者 yarn 在 node_modules 目录安装 package.json 中列出的所有依赖
yarn install --force # 强制下载安装
yarn start # yarn  执行 scripts 下 start 对应的脚本

###用来查看某个模块的最新版本信息
yarn info webpack # yarn
yarn info webpack --json # 输出 json 格式
yarn info webpack readme # 输出 README 部分

yarn list # 列出当前项目的依赖
yarn list --depth=0 # 限制依赖的深度
sudo yarn global list # 列出全局安装的模块

###yarn配置文件
yarn config set key value # 设置
yarn config get key # 读取值
yarn config delete key # 删除
yarn config list # 显示当前配置
yarn config set registry [https://registry.npm.taobao.org](https://links.jianshu.com/go?to=https%3A%2F%2Fregistry.npm.taobao.org) # 设置淘宝镜像

###缓存
sudo yarn cache list # 列出已缓存的每个包
sudo yarn cache dir # 返回 全局缓存位置
sudo yarn cache clean # 清除缓存
</code></pre>
]]></content>
      <categories>
        <category>npm&amp;yarn</category>
        <category>yarn常用命令</category>
      </categories>
      <tags>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是CI/CD</title>
    <url>/2022/11/12/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CI-x2F-CD是什么？如何理解持续集成、持续交付和持续部署"><a href="#CI-x2F-CD是什么？如何理解持续集成、持续交付和持续部署" class="headerlink" title="CI&#x2F;CD是什么？如何理解持续集成、持续交付和持续部署"></a>CI&#x2F;CD是什么？如何理解持续集成、持续交付和持续部署</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>CI&#x2F;CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI&#x2F;CD 的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI&#x2F;CD 主要针对在集成新代码时所引发的问题（亦称：”集成地狱”）。</p>
<p>具体而言，CI&#x2F;CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为”CI&#x2F;CD 管道”，由开发和运维团队以敏捷方式协同支持。</p>
<h3 id="CI-是什么？CI-和-CD-有什么区别？"><a href="#CI-是什么？CI-和-CD-有什么区别？" class="headerlink" title="CI 是什么？CI 和 CD 有什么区别？"></a>CI 是什么？CI 和 CD 有什么区别？</h3><p>缩略词 CI &#x2F; CD 具有几个不同的含义。CI&#x2F;CD 中的”CI”始终指持续集成，它属于开发人员的自动化流程。成功的 CI 意味着应用代码的新更改会定期构建、测试并合并到共享存储库中。该解决方案可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题。</p>
<p>CI&#x2F;CD 中的”CD”指的是持续交付和&#x2F;或持续部署，这些相关概念有时会交叉使用。两者都事关管道后续阶段的自动化，但它们有时也会单独使用，用于说明自动化程度。</p>
<p>持续<em>交付</em>通常是指开发人员对应用的更改会自动进行错误测试并上传到存储库（如 GitHub或容器注册表），然后由运维团队将其部署到实时生产环境中。这旨在解决开发和运维团队之间可见性及沟通较差的问题。因此，持续交付的目的就是确保尽可能减少部署新代码时所需的工作量。</p>
<p>持续<em>部署</em>（另一种”CD”）指的是自动将开发人员的更改从存储库发布到生产环境，以供客户使用。它主要为了解决因手动流程降低应用交付速度，从而使运维团队超负荷的问题。持续部署以持续交付的优势为根基，实现了管道后续阶段的自动化。</p>
<p><img src="/2022/11/12/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/ci-cd-flow-desktop_edited_0.png" alt="CI/CD flow"></p>
<p>CI&#x2F;CD 既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这三项构成的关联环节。更为复杂的是，有时”持续交付”也包含了持续部署流程。</p>
<p>归根结底，我们没必要纠结于这些语义，您只需记得 CI&#x2F;CD 其实就是一个流程（通常形象地表述为管道），用于实现应用开发中的高度持续自动化和持续监控。因案例而异，该术语的具体含义取决于 CI&#x2F;CD 管道的自动化程度。许多企业最开始先添加 CI，然后逐步实现交付和部署的自动化（例如作为云原生应用的一部分）。</p>
<h3 id="CI-持续集成（Continuous-Integration）"><a href="#CI-持续集成（Continuous-Integration）" class="headerlink" title="CI 持续集成（Continuous Integration）"></a>CI 持续集成（Continuous Integration）</h3><p>现代应用开发的目标是让多位开发人员同时处理同一应用的不同功能。但是，如果企业安排在一天内将所有分支源代码合并在一起（称为”合并日”），最终可能造成工作繁琐、耗时，而且需要手动完成。这是因为当一位独立工作的开发人员对应用进行更改时，有可能会与其他开发人员同时进行的更改发生冲突。如果每个开发人员都自定义自己的本地集成开发环境（IDE），而不是让团队就一个基于云的 IDE 达成一致，那么就会让问题更加雪上加霜。</p>
<p>持续集成（CI）可以帮助开发人员更加频繁地（有时甚至每天）将代码更改合并到共享分支或”主干”中。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。这意味着测试内容涵盖了从类和函数到构成整个应用的不同模块。如果自动化测试发现新代码和现有代码之间存在冲突，CI 可以更加轻松地快速修复这些错误。</p>
<h3 id="CD-持续交付（Continuous-Delivery）"><a href="#CD-持续交付（Continuous-Delivery）" class="headerlink" title="CD 持续交付（Continuous Delivery）"></a>CD 持续交付（Continuous Delivery）</h3><p>完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。</p>
<p>在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。</p>
<h3 id="CD-持续部署（Continuous-Deployment）"><a href="#CD-持续部署（Continuous-Deployment）" class="headerlink" title="CD 持续部署（Continuous Deployment）"></a>CD 持续部署（Continuous Deployment）</h3><p>对于一个成熟的 CI&#x2F;CD 管道来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的测试自动化。</p>
<p>实际上，持续部署意味着开发人员对应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI&#x2F;CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。不过，由于还需要编写自动化测试以适应 CI&#x2F;CD 管道中的各种测试和发布阶段，因此前期投资还是会很大。</p>
]]></content>
      <categories>
        <category>CI/CD</category>
        <category>什么是CI/CD</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>webgl</title>
    <url>/2022/11/18/webgl/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="webgl"><a href="#webgl" class="headerlink" title="webgl"></a>webgl</h1><h2 id="第一章-webgl绘图流程"><a href="#第一章-webgl绘图流程" class="headerlink" title="第一章  webgl绘图流程"></a>第一章  webgl绘图流程</h2><hr>
<h3 id="一、创建canvas画布"><a href="#一、创建canvas画布" class="headerlink" title="一、创建canvas画布"></a>一、创建canvas画布</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body&#123;
            margin: 0;
            overflow: hidden;
        &#125;
        #canvas&#123;
            background-color: pink;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="二、js获取canvas画布"><a href="#二、js获取canvas画布" class="headerlink" title="二、js获取canvas画布"></a>二、js获取canvas画布</h3><pre><code class="javascript">const canvas = document.querySelector(&#39;#canvas&#39;)
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
</code></pre>
<h3 id="三、使用canvas获取webgl绘图上下文"><a href="#三、使用canvas获取webgl绘图上下文" class="headerlink" title="三、使用canvas获取webgl绘图上下文"></a>三、使用canvas获取webgl绘图上下文</h3><pre><code class="javascript"> const gl = canvas.getContext(&quot;webgl&quot;)
        gl.clearColor(1,0,0,1)
        gl.clear(gl.COLOR_BUFFER_BIT)
</code></pre>
<h3 id="四、在script中建立顶点着色器和顶点着色器-glsl-es语言"><a href="#四、在script中建立顶点着色器和顶点着色器-glsl-es语言" class="headerlink" title="四、在script中建立顶点着色器和顶点着色器(glsl es语言)"></a>四、在script中建立顶点着色器和顶点着色器(glsl es语言)</h3><pre><code class="javascript">&lt;!-- 顶点着色器 --&gt;
&lt;script id=&quot;vertexShader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
        void main()&#123;
            gl_Position = vec4(0,0,0,1);
            gl_PointSize = 50.0;
        &#125;
&lt;/script&gt;
    &lt;!-- 片元着色器 --&gt;
&lt;script id=&quot;fragmentShader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
        void main()&#123;
            gl_FragColor = vec4(1,1,1,1);
        &#125;
&lt;/script&gt;
</code></pre>
<h3 id="五、在js中获取顶点着色器和片元着色器"><a href="#五、在js中获取顶点着色器和片元着色器" class="headerlink" title="五、在js中获取顶点着色器和片元着色器"></a>五、在js中获取顶点着色器和片元着色器</h3><pre><code class="javascript">//顶点着色器文本
const vsSource = document.getElementById(&#39;vertexShader&#39;).innerText;
//片元舍色器文本
const fsSourse = document.getElementById(&#39;fragmentShader&#39;).innerText;
</code></pre>
<h3 id="六、初始化节点"><a href="#六、初始化节点" class="headerlink" title="六、初始化节点"></a>六、初始化节点</h3><pre><code class="javascript"> //初始化着色器
 initShaders(gl,vsSource,fsSourse);
</code></pre>
<h3 id="七、指定将来用来清空绘图区的颜色"><a href="#七、指定将来用来清空绘图区的颜色" class="headerlink" title="七、指定将来用来清空绘图区的颜色"></a>七、指定将来用来清空绘图区的颜色</h3><pre><code class="javascript">//指定将要用来清理绘图区的颜色
gl.clearColor(0,0,0,1);
</code></pre>
<h3 id="八、使用指定颜色清空绘图区"><a href="#八、使用指定颜色清空绘图区" class="headerlink" title="八、使用指定颜色清空绘图区"></a>八、使用指定颜色清空绘图区</h3><pre><code class="javascript">//清理绘图区
gl.clear(gl.COLOR_BUFFER_BIT);
</code></pre>
<h3 id="九、绘制顶点"><a href="#九、绘制顶点" class="headerlink" title="九、绘制顶点"></a>九、绘制顶点</h3><pre><code class="javascript">//绘制顶点(点模式)
gl.drawArrays(gl.POINTS,0,1);
</code></pre>
<h3 id="十、初始化节点具体代码实现"><a href="#十、初始化节点具体代码实现" class="headerlink" title="十、初始化节点具体代码实现"></a>十、初始化节点具体代码实现</h3><pre><code class="javascript">function initShaders(gl,vsSource,fsSourse)&#123;
//创建程序对象
const program = gl.createProgram();
//建立着色对象
const vertexShader = loadShader(gl,gl.VERTEX_SHADER,vsSource);
const fragmentShader = loadShader(gl,gl.FRAGMENT_SHADER,fsSourse);
//将顶点着色对象装进程序对象中
gl.attachShader(program, vertexShader);
//将片元着色对象装进程序对象中
         gl.attachShader(program,fragmentShader);
//连接webgl上下文对象和程序对象
gl.linkProgram(program);
//启动程序对象
gl.useProgram(program);
//将程序对象挂到上下文对象
gl.program = program;
return true;
&#125;

function loadShader(gl,type,source)&#123;
//根据着色器的类型，建立着色器对象
const shader = gl.createShader(type);
//将着色器源文件传入着色器对象中
gl.shaderSource(shader, source);
//编译着色器对象
gl.compileShader(shader);
//返回着色器对象
return shader;
&#125;
</code></pre>
<h2 id="第二章-用js控制点位"><a href="#第二章-用js控制点位" class="headerlink" title="第二章  用js控制点位"></a>第二章  用js控制点位</h2><h3 id="一、js中声明attribute变量"><a href="#一、js中声明attribute变量" class="headerlink" title="一、js中声明attribute变量"></a>一、js中声明attribute变量</h3><pre><code class="javascript">&lt;script id=&quot;vertexShader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
//声明变量类型vec4，导出变量a_Position
        attribute vec4 a_Position;
//修改顶点尺寸和修改顶点位置是一样的原理，只是类型为float
        void main()&#123;
            gl_Position = a_Position;
            gl_PointSize = 50.0;
        &#125;
    &lt;/script&gt;
</code></pre>
<h3 id="二、js获取attribute变量"><a href="#二、js获取attribute变量" class="headerlink" title="二、js获取attribute变量"></a>二、js获取attribute变量</h3><pre><code class="javascript">//设置attribute变量
const a_Position = gl.getAttribLocation(gl.program, &#39;a_Position&#39;);
</code></pre>
<h3 id="三、在js中修改attribute变量"><a href="#三、在js中修改attribute变量" class="headerlink" title="三、在js中修改attribute变量"></a>三、在js中修改attribute变量</h3><pre><code class="javascript">//修改attribute变量值
gl.vertexAttrib3f(a_Position,0,0,0)
//参数（变量名,x,y,z）
//也有许多同族函数
gl.vertexAttrib1f(a_Position,0)
gl.vertexAttrib2f(a_Position,0,0)
gl.vertexAttrib3f(a_Position,0,0,0)
gl.vertexAttrib4f(a_Position,0,0,0,0)
</code></pre>
<h3 id="案例小节（鼠标控制点位）"><a href="#案例小节（鼠标控制点位）" class="headerlink" title="案例小节（鼠标控制点位）"></a>案例小节（鼠标控制点位）</h3><h4 id="1-获取鼠标在canvas中的位置"><a href="#1-获取鼠标在canvas中的位置" class="headerlink" title="1.获取鼠标在canvas中的位置"></a>1.获取鼠标在canvas中的位置</h4><pre><code class="javascript">//获取鼠标点在canvas中的位置
canvas.addEventListener(&#39;click&#39;,(event)=&gt;&#123;
const &#123;clientX,clientY&#125; = event;
const &#123;left,top&#125; = canvas.getBoundingClientRect();
const [cssX,cssY]=[clientX - left,clientY - top];
        &#125;)
</code></pre>
<p><img src="/2022/11/18/webgl/image-20220922115516857.png"></p>
<pre><code class="javascript">//解决canvas和webgl差异
//1.解决原点差异
const [halfWidth,halfHeight] = [width/2,height/2];
const [xBaseCenter,yBaseCenter] = [cssX - halfWidth,cssY - halfHeight];
//2.解决y轴轴向差异
const yBaseCenterTop = -yBaseCenter;
//3.解决基底差异
const [x,y] = [xBaseCenter/halfWidth,yBaseCenterTop/halfHeight];
</code></pre>
<h4 id="2-绘制图层"><a href="#2-绘制图层" class="headerlink" title="2.绘制图层"></a>2.绘制图层</h4><pre><code class="javascript">gl.vertexAttrib2f(a_Position,x,y);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.drawArrays(gl.POINTS,0,1);
</code></pre>
<h3 id="四、webgl同步绘图原理"><a href="#四、webgl同步绘图原理" class="headerlink" title="四、webgl同步绘图原理"></a>四、webgl同步绘图原理</h3><p>​       webgl 的同步绘图的现象,其实是由于 webgl 底层内置颜色缓冲区导致的.它在电脑中会占用一块内存,在我们使用 webgl 绘图的时候,是在颜色缓冲区中画出来,但是图片暂时还未渲染出来.只有 webgl 自己知道.如果我们想要将图像的时候,那就照着缓冲区的图像去画,这个步骤是 webgl 内部自己完成的,我们只需要执行绘图命令就行了,颜色缓冲区存储的图像,只有当前线程有效,比如我们先在 js 主线程绘图的时候,主线程结束后,会在执行信息队列的异步线程,子啊执行异步线程时,颜色缓冲区会被 webgl 重置,导致颜色缓冲器绘制的图形被清除,导致以前绘制的图像也会消失.</p>
<h2 id="第三章-用js控制顶点颜色"><a href="#第三章-用js控制顶点颜色" class="headerlink" title="第三章  用js控制顶点颜色"></a>第三章  用js控制顶点颜色</h2><h3 id="一、js中声明uniform变量"><a href="#一、js中声明uniform变量" class="headerlink" title="一、js中声明uniform变量"></a>一、js中声明uniform变量</h3><pre><code class="javascript">&lt;script id=&quot;fragmentShader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
 //将float精度设置为中等
 precision mediump float;
 uniform vec4 u_FragColor;
 void main()&#123;
    gl_FragColor = u_FragColor;
 &#125;
&lt;/script&gt;
</code></pre>
<h3 id="二、js获取uniform变量"><a href="#二、js获取uniform变量" class="headerlink" title="二、js获取uniform变量"></a>二、js获取uniform变量</h3><pre><code class="javascript">const u_FragColor = gl.getUniformLocation(gl.program, &#39;u_FragColor&#39;);
</code></pre>
<h3 id="三、在js中修改uniform变量值"><a href="#三、在js中修改uniform变量值" class="headerlink" title="三、在js中修改uniform变量值"></a>三、在js中修改uniform变量值</h3><pre><code class="javascript">//一个一个传递参数
gl.uniform4f(u_FragColor, 0.0, 1.0, 0.0, 1.0);
//可以以数组的形式传递参数
//Float32Array为一种32位浮点型数组，在浏览器中的运行效率比Array要高的多
const color = new Float32Array([1.0,1.0,0.0,1.0]);
gl.uniform4v(u_FragColor,color);
</code></pre>
<h3 id="四、片元着色器的绘图原理"><a href="#四、片元着色器的绘图原理" class="headerlink" title="四、片元着色器的绘图原理"></a>四、片元着色器的绘图原理</h3><p>​     我们所看到的图形都是由多个片元组成的，那么想要绘制相应图形，只需要渲染范围内的片元就可以了</p>
<p><img src="/2022/11/18/webgl/image-20220922162314987.png"></p>
<p>具体代码实现：</p>
<pre><code class="javascript">&lt;script id=&quot;fragmentShader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;
uniform vec4 u_FragColor;
void main()&#123;
  //distance为计算两个点的距离 distance(p1,p2)
  //gl_PointCoord片元在一个点中的位置是统一化的
  //discard丢弃，不会进行渲染
float dist = distance(gl_PointCoord,vec2(0.5,0.5));
if(dist &lt; 0.5)&#123;
  //进入范围就渲染
    gl_FragColor = u_FragColor;
&#125;else&#123;
    discard;
&#125;
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="五、片元着色器合成功能"><a href="#五、片元着色器合成功能" class="headerlink" title="五、片元着色器合成功能"></a>五、片元着色器合成功能</h3><p>开启着色器合成功能和声明合成方式才可以生效</p>
<pre><code class="javascript">//开启片元着色器合成功能
gl.enable(gl.BLEND);
//设置片元着色器合成方式
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
</code></pre>
<h2 id="第四章-架构补间动画"><a href="#第四章-架构补间动画" class="headerlink" title="第四章 架构补间动画"></a>第四章 架构补间动画</h2><p>完成透明度动画</p>
<h3 id="一、建立合成对象"><a href="#一、建立合成对象" class="headerlink" title="一、建立合成对象"></a>一、建立合成对象</h3><pre><code class="javascript">export default class Compose &#123;
    constructor()&#123;
//parent 父对象，合成对象可以嵌套
        this.parent = null;
//children 子对象集合，其集合可以是时间轨，也可以是合成对象
        this.children = [];
    &#125;
//添加子对象方法
    add(obj)&#123;
        obj.parent = this;
        this.children.push(obj);
    &#125;
//基于当前时间更新子对象状态的方法
    update(t) &#123;
        this.children.forEach((ele)=&gt;&#123;
            ele.update(t);
        &#125;)
    &#125;
&#125;
</code></pre>
<h3 id="二、建立时间轨"><a href="#二、建立时间轨" class="headerlink" title="二、建立时间轨"></a>二、建立时间轨</h3><pre><code class="javascript">export default class Track&#123;
    constructor(target)&#123;
        this.target = target;
        this.parent = null;
        this.start = 0;
        this.timeLen = 5;
        this.loop = false;
        this.keyMap = new Map();
    &#125;
    update(t) &#123;
        const &#123;target,start,timeLen,loop,keyMap&#125; = this;
        //本地时间
        let time = t - start;
        if(loop)&#123;
            time = time % timeLen;
        &#125;
        //遍历关键帧集合，判断在两个关键帧之前还是之后
        for(const [key,fms] of keyMap)&#123;
            const last = fms.length - 1;
            if(time &lt; fms[0][0])&#123;
                target[key] = fms[0][1]; 
            &#125;else if(time &gt; fms[0][1])&#123;
                target[key] = fms[last][0];
            &#125;else&#123;
                target[key] = getValBetweenFms(time,fms,last);
            &#125;
        &#125;
    &#125;
&#125;

//获取两个关键帧之间的补间状态的方法
function getValBetweenFms(time,fms,last)&#123;
    for(let i = 0;i &lt; last;i++)&#123;
        //两个关键帧fm1和fm2
        const fm1 = fms[i];
        const fm2 = fms[i + 1];
        //如果在两个关键帧之间，基于两个关键帧的时间和状态求点斜式
        if(time &gt;= fm1[0] &amp;&amp; time &lt;= fm2[0])&#123;
            const delta = &#123;
                x: fm2[0] - fm1[0],
                y: fm2[1] - fm1[1],
            &#125;;
            //获取斜率k和截距b
            const k = delta.y / delta.x;
            const b = fm1[1] - fm1[0] * k;
            //根据点斜式求当前时间对应的状态
            return k * time + b;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="/2022/11/18/webgl/image-20220922181506452.png"></p>
<h3 id="三、使用合成对象和轨道对象制作补间动画"><a href="#三、使用合成对象和轨道对象制作补间动画" class="headerlink" title="三、使用合成对象和轨道对象制作补间动画"></a>三、使用合成对象和轨道对象制作补间动画</h3><pre><code class="javascript">//引入合成对象Compose和轨道对象Track
import Compose from &#39;./utils/Compose.js&#39;
import Track from &#39;./utils/ComposeOne.js&#39;
</code></pre>
<pre><code class="javascript">const compose = new Compose();
</code></pre>
<pre><code class="javascript">const obj = &#123;x,y,size&#125;;
starts.push(obj);
//建立轨道对象
const track = new Track(obj);
track.start = new Date();
track.timeLen = 2000;
track.loop = true;
track.keyMap = new Map([
            [
                &#39;size&#39;,
                [
                    [500,size],
                    [1000,0],
                    [1500,size]
                ]
            ]
           ])
compose.add(track);
</code></pre>
<pre><code class="javascript">//连续渲染
!(function ani()&#123;
            compose.update(new Date());
            render();
            requestAnimationFrame(ani);
 &#125;)()
 //渲染方法
 function render()&#123;
gl.clear(gl.COLOR_BUFFER_BIT);
starts.forEach((&#123;x,y,size&#125;)=&gt;&#123;
   gl.vertexAttrib2f(a_Position,x,y);
   gl.vertexAttrib1f(a_PointSize,size);
   gl.uniform4f(u_FragColor, 1.0, 1.0,1.0, Math.random()*1);
   
  gl.drawArrays(gl.POINTS,0,1);
            &#125;)
        &#125;
</code></pre>
<h2 id="第五章-绘制多点图形"><a href="#第五章-绘制多点图形" class="headerlink" title="第五章 绘制多点图形"></a>第五章 绘制多点图形</h2><h3 id="一、绘制多点步骤"><a href="#一、绘制多点步骤" class="headerlink" title="一、绘制多点步骤"></a>一、绘制多点步骤</h3><p>和之前的webgl绘图流程是一样的只是赋值attribute不一样</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;webgl多点绘制&lt;/title&gt;
    &lt;style&gt;
        body&#123;
            margin: 0;
            overflow: hidden;
        &#125;
        #canvas&#123;
            background-color: antiquewhite;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
    &lt;!-- 顶点着色器 --&gt;
    &lt;script id=&quot;vertexShader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
        attribute vec4 a_Position;
        void main()&#123;
            gl_Position = a_Position;
            gl_PointSize = 50.0;
        &#125;
    &lt;/script&gt;
    &lt;!-- 片元着色器 --&gt;
    &lt;script id=&quot;fragmentShader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
        void main()&#123;
            gl_FragColor = vec4(1,1,1,1);
        &#125;
    &lt;/script&gt;
    &lt;script type=&quot;module&quot;&gt;
        import &#123;initShaders&#125; from &#39;./utils/index.js&#39;
        //canvas画布，获取上下文对象
        const canvas = document.querySelector(&#39;#canvas&#39;);
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        //webgl画笔
        const gl = canvas.getContext(&quot;webgl&quot;);
        //顶点着色器文本
        const vsSource = document.getElementById(&#39;vertexShader&#39;).innerText;
        //片元舍色器文本
        const fsSourse = document.getElementById(&#39;fragmentShader&#39;).innerText;
        //初始化着色器
        initShaders(gl,vsSource,fsSourse);
      //设置attribute变量
        const a_Position =                        gl.getAttribLocation(gl.program, &#39;a_Position&#39;);
        //在这开始修改

        //指定将要用来清理绘图区的颜色
        gl.clearColor(0,0,0,1);
        //清理绘图区
        gl.clear(gl.COLOR_BUFFER_BIT);
        //绘制顶点
        gl.drawArrays(gl.POINTS,0,1);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="二、绘制多点"><a href="#二、绘制多点" class="headerlink" title="二、绘制多点"></a>二、绘制多点</h3><p><img src="/2022/11/18/webgl/image-20220923105127932.png"></p>
<pre><code class="javascript">//如何向attribute变量中写入多点，并绘制多点
//创建顶点数据
const vertices =new Float32Array([0.0,0.1,-0.1,-0.1,0.1,-0.1])
//建立缓存对象，独立缓存区
const vertexBuffer = gl.createBuffer();
//绑定缓存对象
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
//写入数据
gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);
//获取attribute变量
gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
//开启批处理功能
gl.enableVertexAttribArray(a_Position);
</code></pre>
<pre><code class="javascript">//添加顶点的时候，也要修改绘制顶点的数量 
//绘制顶点
 gl.drawArrays(gl.POINTS,0,3);
</code></pre>
<h3 id="三、绘制三角面"><a href="#三、绘制三角面" class="headerlink" title="三、绘制三角面"></a>三、绘制三角面</h3><pre><code class="javascript">//不需要顶点大小了
//修改绘图方式就可以了
gl.drawArrays(gl.TRIANGLES,0,3);
</code></pre>
<h3 id="四、绘制线"><a href="#四、绘制线" class="headerlink" title="四、绘制线"></a>四、绘制线</h3><p>绘制线的方式主要是修改顶点个数和绘图方式gl.drawArrays(mode,first,count);</p>
<ul>
<li>POINTS 可视的点</li>
<li>LINES 单独线段</li>
<li>LINE_STRIP 线条</li>
<li>LINE_LOOP闭合线条</li>
<li>TRIANGLES 单独三角形</li>
<li>TRIANGLE_STRIP 三角带</li>
<li>TRIANGLE_FAN 三角扇</li>
</ul>
<h3 id="五、三角带和三角扇的规则"><a href="#五、三角带和三角扇的规则" class="headerlink" title="五、三角带和三角扇的规则"></a>五、三角带和三角扇的规则</h3><p><img src="/2022/11/18/webgl/image-20220923120827422.png"></p>
<p><img src="/2022/11/18/webgl/image-20220923122032402.png"></p>
]]></content>
      <categories>
        <category>WebGl</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>webgl</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是性能优化</title>
    <url>/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="什么是性能优化"><a href="#什么是性能优化" class="headerlink" title="什么是性能优化"></a>什么是性能优化</h1><h3 id="1-性能的起因"><a href="#1-性能的起因" class="headerlink" title="1.性能的起因"></a>1.性能的起因</h3><p>​		市场上的某个功能还没有能满足其需求的可选方案的时候，如果出来一个应用即使很难用，用户都要忍着用。如果这个功能确实能解决用户的某些痛点需求，且有其存在的价值，那么让用户忍受糟糕体验的背后，就存在 对产品优化和改进的空间。</p>
<h3 id="2-性能的影响"><a href="#2-性能的影响" class="headerlink" title="2.性能的影响"></a>2.性能的影响</h3><p>​		大部分网站体现的价值都无外乎信息的载体、交互的工具或商品流通的渠道，这就要求它们需要与更多的用户建立联系，同时还要保持所建立的联系拥有绵延不绝的用户黏性，所以网站就不能只关注自我表达，而不顾及用户是否喜欢。</p>
<h4 id="2-1用户的留存"><a href="#2-1用户的留存" class="headerlink" title="2.1用户的留存"></a>2.1用户的留存</h4><p>​		我们都希望用户访问网站所进行的交互，对网站构建的内容来讲是有意义的，比如，电商网站希望用户浏览并购买商品，社交网站希望用户之间进行互动，视频网站希望用户观看视频，而这些希望都是建立在网站用户留存的基础上的。网站用户的留存情况，一般指的是用户自登录注册之日起，经过一段时间后， 仍然还在使用该网站的用户数。统计出注册用户数与留存用户数后，就可以计算出用户留存率，这个指标对网站的运营有重要的指导意义。</p>
<p>​		根据Google营销平台提供的调研发现，如果网站页面的加载时间超过3s,就会有53%的移动网站的访问遭到用户抛弃。同时他们还针对加载时间分别在4s内和20s内的网站进行比较，发现加载时间在5s内的网站，用户的停留时间相比会长70%，用户在一定时间内从该网站离开的跳出率会低35%，而网站上展示广告的可见率也会高25%。</p>
<p>​		虽然影响用户留存的因素不止性能这一方面， 但从上述数据可知，通过优化性能来保证留存事是必要的措施。	</p>
<h4 id="2-2网站的转化率"><a href="#2-2网站的转化率" class="headerlink" title="2.2网站的转化率"></a>2.2网站的转化率</h4><p>​		从运营角度来看，网站转化率是一个非常 重要的考量指标，网站转化率指的是用户进行了某项目标行为的访问次数与总访问次数的比率。某项目标行为可以是用户注册、资源下载、商品购买等一 系列用户行为，简言之，比如在电商网站上浏览了某个商品的用户中，有多少位用户最终购买了该商品，其所占的比例就可以看作访客到消费者的转化率。</p>
<p>​		根据Mobify (一家著 名的电子商务优化平台)的调研，发现商品的结账页面加载时间每减少100ms,基于该商品购买访问的转化率就会增加1.55%， 这个比率对大型电商网站来讲，其所带来的年均收入增长将会是上千万元。Google 营销平台的调研也指出，加载时间在5s以内的网站会比在20s以内的网站的广告收入多一倍。</p>
<p>​		目前大部分互联网广告营销都渐趋精准化，即广告商的广告费会根据经广告导流，产生确定的用户交易后再收取。如此看来网站性能不仅影响用户体验，对于广告主和广告商的经济利益也会带来实实在在的影响。</p>
<h4 id="2-3体验与传播"><a href="#2-3体验与传播" class="headerlink" title="2.3体验与传播"></a>2.3体验与传播</h4><p>​		当用户通过手机、平板电脑等移动设备经运营商网络浏览网站时，所产生的流量数据通常是根据字节数进行收费的。虽然从2G、 3G 到4G,甚至5G,运营商所收取的流量费用单价一直在下滑，但与此同时，页面所承载的内容却在不断增大，并且这一趋势似乎将持续下去。 那么用户必将为过多的流量数据支付相应的费用，若所访问网站包含的资源文件过大、组织冗余，用户便会浪费过多的网络资费，同时过大的资源传输量也会延长请求响应的时间，最终降低用户的体验度。</p>
<p>​		性能问题引起的所谓用户体验差，造成的影响并非单纯是用户觉得不喜欢就放弃了使用。用户还会拒绝向自己的周边网络推荐该网站或应用，更坏的情况是用户会对低性能进行差评。口碑是互联网时代t分可靠的通行证，如果我们不重视性能问题，经过网络口碑的放大效应，网站的发展不仅会遇到瓶颈，甚至还可能会日薄西山。</p>
<h3 id="3-性能评估模型"><a href="#3-性能评估模型" class="headerlink" title="3.性能评估模型"></a>3.性能评估模型</h3><p>​		我们先来约定一个原则，以用户为中心，然后根据该原则引出指导后文涉及的各种优化策略，所参照的性能模型为RAIL性能模型。这个名字的由来是四个英文单词的首字母:响应( Response)、动画(Animation)、 空闲(Idle)、加载(Load)，这四个单词代表与网站或应用的生命周期相关的四个方面，这些方面会以不同的方式影响整个网站的性能。</p>
<p><img src="/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20230106102130579.png"></p>
<p>我们将用户作为之后性能优化的中心，首先需要了解用户对于延迟的反应。用户感知延迟的时间窗口。</p>
<table>
<thead>
<tr>
<th align="center">延迟</th>
<th align="center">用户反应</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0～16ms</td>
<td align="center">人眼可以感知每秒60帧的动画转场，即每帧16ms，除了浏览器将每一帧画面绘制到屏幕上的时间，网站应用大约需要10ms来生成一帧</td>
</tr>
<tr>
<td align="center">0～100ms</td>
<td align="center">在该时间窗口内来响应用户的操作，才会是流畅的体验</td>
</tr>
<tr>
<td align="center">100～300ms</td>
<td align="center">用户能感知轻微的延迟</td>
</tr>
<tr>
<td align="center">300～1000ms</td>
<td align="center">所感知的延迟会被用户当作网站页面加载或更改视图过程的一部分</td>
</tr>
<tr>
<td align="center">&gt;1s</td>
<td align="center">用户的注意力将离开之前执行的任务</td>
</tr>
<tr>
<td align="center">&gt;10s</td>
<td align="center">用户感觉失望，可能会放弃任务</td>
</tr>
</tbody></table>
<h4 id="3-1响应"><a href="#3-1响应" class="headerlink" title="3.1响应"></a>3.1响应</h4><p>​		网站性能对于响应方面的要求是，在用户感知延迟之前接收到操作的反馈。比如用户进行了文本输入，按钮单击、表单切换及启动动画等操作后，必须在100m内收到反馈，如果超过100ms的时间窗口，用户就会感知延迟。</p>
<p>​		看似很基本的用户操作背后，可能会隐藏着复杂的业务逻辑处理及网络请求与数据计算。对此我们应当谨慎，将较大开销的工作放在后台异步执行，而即便后白处理要数百毫秒才能完成的操作，也应当给用户提供及时的阶段性反馈。</p>
<p>​		比如在单击按钮向后台发起某项业务处理请求时，首先反馈给用户开始处理的提示，然后在处理完成的回调后反馈完成的提示。</p>
<h4 id="3-2动画"><a href="#3-2动画" class="headerlink" title="3.2动画"></a>3.2动画</h4><p>​		前端所涉及的动画不仅有炫酷的UI特效，还包括滚动和触摸拖动等交互效果，而这一方面的性能要求就是流畅。 众所周知，人眼具有视觉暂留特性，就是当光对视网膜所产生的视觉在光停止作用后，仍能保留一段时间。</p>
<p>​		研究表明这是由于视神经存在反应速度造成的， 其值是1&#x2F;24s，即当我们所见的物体移除后，该物体在我们眼中并不会立即消失，而会延续存在1&#x2F;24s 的时间。对动画来说，无论动画帧率有多高，最后我们仅能分辨其中的30帧，但越高的帧率会带来更好的流畅体验，因此动画要尽力达到60fps的帧率，每一帧画面的生成都需要经过若干步骤，根据60fps 帧率的计算，帧图像的生成预算为16ms ( 1000ms&#x2F;60 约等于 16.6ms)，除去浏览器绘制新帧的时间，留给执行代码的时间仅10ms 左右。关于这个维度的具体优化策略，会在后面优化谊染过程的相关章节中详细介绍。</p>
<h4 id="3-3空闲"><a href="#3-3空闲" class="headerlink" title="3.3空闲"></a>3.3空闲</h4><p>​		要使网站响应迅速、动画流畅，通常都需要较长的处理时间，但以用户为中心来看待性能问题，就会发现并非所有工作都需要在响应和加载阶段完成，我们完全可以利用浏览器的空闲时间处理可延迟的任务，只要让用户感受不到延迟即可。利用空闲时间处理延迟，可减少预加载的数据大小，以保证网站或应用快速完成加载。</p>
<p>​		为了更加合理地利用浏览器的空闲时间，最好将处理任务按50ms为单位分组。这么做就是保证用户在发生操作后的100ms 内给出响应。</p>
<h4 id="3-4-加载"><a href="#3-4-加载" class="headerlink" title="3.4 加载"></a>3.4 加载</h4><p>​		用户感知要求我们尽量在1s内完成页面加载，如果没有完成，用户的注意力就会分散到其他事情上，并对当前处理的任务产生中断感。需要注意的是，这里在1s内完成加载井谊染出页面的要求，并非要完成所有页面资源的加载，从用户感如体验的角度来说，只要关键谊染路径完成，用户就会认为全部加载已完成。</p>
<p>​		对于其他非关键资源的加载，延迟到浏览器空闲时段再进行，是比较常见的渐进式优化策略。</p>
<h3 id="4-性能优化的步骤"><a href="#4-性能优化的步骤" class="headerlink" title="4.性能优化的步骤"></a>4.性能优化的步骤</h3><p>​		RAIL性能模型指出了用户对不同延迟时间的感知度，以用户为中心的原则，就是要让用户满意网站或应用的性能体验。</p>
<p>​		不同类型的操作，需要在规定的时间窗口内完成，所以进行性能优化的步骤般是:首先可量化地评估出网站或应用的性能表现,然后立足于网站页面响应的生命周期，分析出造成较差性能表现的原因,最后进行技术改造、可行性分析等具体的优化实施。</p>
<h4 id="4-1-性能测量"><a href="#4-1-性能测量" class="headerlink" title="4.1 性能测量"></a>4.1 性能测量</h4><p>​		如果把对网站的性能优化比作一场旅程， 它无疑会是漫长且可能还略带泥泞的，那么在开始之前我们有必要对网站进行性能测量，以知道优化的方向在何处。通常我们会借助.些工具来完成性能测量.</p>
<p>1.Chrome浏览器的Performance功能</p>
<p>​		通过Chrome浏览器访问我们要进行性能测量的网站，打开开发者工具的Performance选项卡。单击左上角的“开始评估”按钮后刷新网站，该工具便开始分析页面资源加载、渲染、请求响应等各环节耗费的时间线，据此便可分析定程度的性能问题， 比如JavaScript 的执行是否会触发大量视觉变化的计算，重绘和重排(或回流)是否会被多次触发等。</p>
<p>2.灯塔(Lighthouse)</p>
<p>​		Lighthouse是一个开源的自动化审查网站页面性能的工具，可根据所提供的网站URL从性能、可访问性、渐进式Web应用、SEO (搜索引擎优化)等多个方面进行自动化分析，最终给出一份具有指导意义的报告。它既可以当作Chrome的扩展插件来使用，又可以在开发者工具中直接使用。</p>
<p><img src="/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20230106110717868.png"></p>
<p><img src="/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20230106110753427.png"></p>
<p>除此之外，还会经常用到的性能测试工具有PageSpeed Insights、WEBPAGETEST、Pingdom等。</p>
<h4 id="4-2生命周期"><a href="#4-2生命周期" class="headerlink" title="4.2生命周期"></a>4.2生命周期</h4><pre><code>     网站页面的生命周期，通俗地讲就是从我们在浏览器的地址栏中输入一个URL后，到整个页面渲染出来的过程。整个过程包括域名解析，建立TCP连接，前后端通过HTTP进行会话，压缩与解压缩，以及前端的关键渲染路径等，把这些阶段拆解开来看，不仅能容易地获得优化性能的启发，而且也能为今后的前端工程师之路构建完整的知识框架。
</code></pre>
<p><img src="/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20230106113810661.png"></p>
<h4 id="4-3优化方案"><a href="#4-3优化方案" class="headerlink" title="4.3优化方案"></a>4.3优化方案</h4><p>​		经过对网站页面性能的测量及渲染过程的了解，相信你对于糟糕性能体验的原因已经比较清楚了，那么接下来便是优化性能。</p>
<p>(1)传输资源的优化，比如图像资源， 不同的格式类型会有不同的使用场景，在使用的过程中是否恰当。</p>
<p>(2)加载过程的优化，比如延迟加载，是否有不需要在首屏展示的非关键信息，占用了页面加载的时间。</p>
<p>(3) JavaScript 是现代大型网站中相当“昂贵”的资源，是否进行了压缩，书写是否规范，有无考虑内存泄漏等。</p>
<p>(4)关键渲染路径优化，比如是否存在不必要的重绘和回流。</p>
<p>(5)本地存储和浏览器缓存。</p>
<h3 id="参考：Web前端性能优化"><a href="#参考：Web前端性能优化" class="headerlink" title="参考：Web前端性能优化"></a>参考：Web前端性能优化</h3>]]></content>
      <categories>
        <category>前端性能优化</category>
        <category>什么是性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>从0到1搭建自己的脚手架vue3</title>
    <url>/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="搭建vue项目脚手架"><a href="#搭建vue项目脚手架" class="headerlink" title="搭建vue项目脚手架"></a>搭建vue项目脚手架</h1><h3 id="1-所以的网站都需要一个页面，所以创建第一个-html文件（index-html）"><a href="#1-所以的网站都需要一个页面，所以创建第一个-html文件（index-html）" class="headerlink" title="1.所以的网站都需要一个页面，所以创建第一个.html文件（index.html）"></a>1.所以的网站都需要一个页面，所以创建第一个.html文件（index.html）</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;vue-cli-start&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
   &lt;!-- 引入打包后的js文件 --&gt;
    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="2-创建src和dist文件夹"><a href="#2-创建src和dist文件夹" class="headerlink" title="2.创建src和dist文件夹"></a>2.创建src和dist文件夹</h3><p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107081630590.png"></p>
<p>因为index.html需要引入打包后的bundle.js文件，所以将index.js放到了dist目录下</p>
<h3 id="3-创建入口文件main-js"><a href="#3-创建入口文件main-js" class="headerlink" title="3.创建入口文件main.js"></a>3.创建入口文件main.js</h3><p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107082550022.png"></p>
<p>我们需要引入vue实例，但是现在我们没有vue包，所以要先下载vue</p>
<p>我们也可以一次性下载vue所需要的依赖</p>
<pre><code class="ini">npm i vue element-ui axios
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107083055837.png"></p>
<h3 id="4-安装开发依赖"><a href="#4-安装开发依赖" class="headerlink" title="4.安装开发依赖"></a>4.安装开发依赖</h3><pre><code class="ini">npm i -D webpack webpack-cli vue-loader vue-template-compiler sass sass-loader css-loader style-loader babel-loader @babel/core @babel/preset-env
</code></pre>
<p>如果项目文件没有package.json,那么</p>
<pre><code class="ini">npm init -y
</code></pre>
<h3 id="5-创建webpack-config-js并配置-根目录下和package-json同一目录创建"><a href="#5-创建webpack-config-js并配置-根目录下和package-json同一目录创建" class="headerlink" title="5.创建webpack.config.js并配置(根目录下和package.json同一目录创建)"></a>5.创建webpack.config.js并配置(根目录下和package.json同一目录创建)</h3><pre><code class="javascript">//webpack.config.js基本配置模板
module.exports = &#123;
    //入口，表示从那个文件开始解析
    entry:&#39;&#39;,
    //出口，表示输出文件位置和信息
    output:&#123;
        path:&#39;&#39;,
        filename:&#39;&#39;
    &#125;,
    //模块，定义匹配规则和转换loader
    module:&#123;
        rules:[
            &#123;test:/\.vue$/,use:&#39;vue-loader&#39;&#125;,
            &#123;&#125;
        ]
    &#125;,
    //插件,给予webpack更丰富的功能
    plugins:[
        //实例化
        new PluginA()
    ]

&#125;
</code></pre>
<p>基本配置完成的webpack.config.js</p>
<pre><code class="javascript">const path = require(&#39;path&#39;)
const &#123;VueLoaderPlugin&#125; = require(&#39;vue-loader&#39;)
module.exports = &#123;
    entry:&#39;./src/main.js&#39;,
    output:&#123;
        path:path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    module:&#123;
        rules:[
            &#123;test:/\.vue$/,use:&#39;vue-loader&#39;&#125;,
            &#123;test:/\.s[ca]ss$/,use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;sass-loader&#39;]&#125;,
            &#123;
                test:/\.m?js$/,
                use:&#123;
                    loader:&#39;babel-loader&#39;,
                    options:&#123;
                        presets:[&#39;@babel/preset-env&#39;],
                    &#125;
                &#125;
            &#125;,
            //老语法
            // &#123;test:/\.(png|jpe?g|svg|gif|webp)$/,use:&#123;loader:&#39;file-loader&#39;,options:&#123;esModule:&#39;false&#39;&#125;&#125;&#125;
            &#123;test:/\.(png|jpe?g|svg|gif|webp)$/,type:&#39;asset/resource&#39;&#125;,
        ]
    &#125;,
    plugins:[
        new VueLoaderPlugin()
    ]
&#125;
</code></pre>
<h3 id="6-编辑书写main-js文件和App-vue"><a href="#6-编辑书写main-js文件和App-vue" class="headerlink" title="6.编辑书写main.js文件和App.vue"></a>6.编辑书写main.js文件和App.vue</h3><pre><code class="javascript">//main.js
import &#123; createApp &#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;
createApp(App).mount(&#39;#app&#39;)
</code></pre>
<pre><code class="vue">//App.vue
&lt;template&gt;
    &lt;div&gt;
        艺术码畜博客‘https://mengfeng.github.io/’
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;&#125;
&lt;/script&gt;
&lt;style lang=&quot;scss&quot; scoped&gt;
&lt;/style&gt;
</code></pre>
<h3 id="7-那么我们现在应该可以运行所配置的代码了"><a href="#7-那么我们现在应该可以运行所配置的代码了" class="headerlink" title="7.那么我们现在应该可以运行所配置的代码了"></a>7.那么我们现在应该可以运行所配置的代码了</h3><p>现在出现一个问题，直接执行webpack命令会找不到webpack命令，虽然我们下载了webpack-cli，但是只是存在于.&#x2F;node_modules&#x2F;.bin里面</p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107100606449.png"></p>
<p>那我们执行.&#x2F;node_modules&#x2F;.bin&#x2F;webpack也是可以打包的，但是我们每次执行这么长的命令不是很方便，所以通过配置package.json文件来简化命令</p>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;vue-cli-start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;:&#123;
    //--mode=development为开发环境，速度较快，上线可以配置为生产环境，会压缩，优化代码
    //--watch为监听代码变化，只要代码变化，会重新编译
    //build是生产环境的打包
    &quot;serve&quot;:&quot;webpack --mode=development --watch&quot;,
    &quot;build&quot;:&quot;webpack --mode=production&quot;
  &#125;,
 &quot;dependencies&quot;: &#123;
    &quot;axios&quot;: &quot;^1.1.3&quot;,
    &quot;element-ui&quot;: &quot;^2.15.10&quot;,
    &quot;vue&quot;: &quot;^3.2.41&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;@babel/core&quot;: &quot;^7.20.2&quot;,
    &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;,
    &quot;babel-loader&quot;: &quot;^9.1.0&quot;,
    &quot;css-loader&quot;: &quot;^6.7.1&quot;,
    &quot;sass&quot;: &quot;^1.56.0&quot;,
    &quot;sass-loader&quot;: &quot;^13.1.0&quot;,
    &quot;style-loader&quot;: &quot;^3.3.1&quot;,
    &quot;vue-loader&quot;: &quot;^17.0.1&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.7.13&quot;,
    &quot;webpack&quot;: &quot;^5.74.0&quot;,
    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<p>当我们执行npm run serve</p>
<pre><code class="ini">npm run serve
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107110605226.png"></p>
<p>表示我们编译成功了，我们现在可以试着运行一下index.html</p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107110725484.png"></p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107110748068.png"></p>
<p>恭喜，目前为止已经没有什么问题了！！！基础的vue脚手架就完成了（目前只是一个页面）</p>
<h3 id="8-我们需要多个页面的时候，就需要其他依赖了"><a href="#8-我们需要多个页面的时候，就需要其他依赖了" class="headerlink" title="8.我们需要多个页面的时候，就需要其他依赖了"></a>8.我们需要多个页面的时候，就需要其他依赖了</h3><p>根据下面的配置来修改自己的代码，可能下面的代码于上面的不同，但效果是一样的</p>
<pre><code class="ini">npm i vue-router
</code></pre>
<h3 id="9-创建route文件夹和pages文件夹"><a href="#9-创建route文件夹和pages文件夹" class="headerlink" title="9.创建route文件夹和pages文件夹"></a>9.创建route文件夹和pages文件夹</h3><p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107143307837.png"></p>
<h3 id="10-编辑App-vue和route下的index-js文件"><a href="#10-编辑App-vue和route下的index-js文件" class="headerlink" title="10.编辑App.vue和route下的index.js文件"></a>10.编辑App.vue和route下的index.js文件</h3><pre><code class="vue">//App.vue
&lt;template&gt;
    &lt;div id=&quot;nav&quot;&gt;
        &lt;router-link to=&quot;/&quot;&gt; home &lt;/router-link&gt; |
        &lt;router-link to=&quot;/food&quot;&gt; food &lt;/router-link&gt; |
        &lt;router-link to=&quot;/banner&quot;&gt; banner &lt;/router-link&gt;
    &lt;/div&gt;
    &lt;router-view /&gt;
&lt;/template&gt;
</code></pre>
<p>这里我们使用的是history，也可以用hash</p>
<pre><code class="javascript">//route/index.js
import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;
//注册
import home from &#39;../pages/Home.vue&#39;
import food from &#39;../pages/Food.vue&#39;
import banner from &#39;../pages/Banner.vue&#39;

const routes = [
  &#123; path: &quot;/&quot;, redirect: &quot;/home&quot; &#125;,
  &#123;
    path: &quot;/home&quot;,
    name: &quot;home&quot;,
    component: home
  &#125;,
  &#123;
    path: &quot;/food&quot;,
    name: &quot;food&quot;,
    component: food
  &#125;,
  &#123;
    path: &quot;/banner&quot;,
    name: &quot;banner&quot;,
    component: banner
  &#125;
]
//导出
const router = createRouter(&#123;
    history: createWebHashHistory(),
    routes: routes
  &#125;)

  export default router;
</code></pre>
<h3 id="11-需要在main-js里面去注册"><a href="#11-需要在main-js里面去注册" class="headerlink" title="11.需要在main.js里面去注册"></a>11.需要在main.js里面去注册</h3><pre><code class="javascript">import &#123; createApp &#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import router from &#39;./route&#39;

const app = createApp(App)
app.use(router)
app.mount(&#39;#app&#39;)
</code></pre>
<h3 id="12-这个时候再去跑我们的代码就可以了"><a href="#12-这个时候再去跑我们的代码就可以了" class="headerlink" title="12.这个时候再去跑我们的代码就可以了"></a>12.这个时候再去跑我们的代码就可以了</h3><pre><code class="ini">npm run serve
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107143925345.png"></p>
<h3 id="13-页面之间的route跳转"><a href="#13-页面之间的route跳转" class="headerlink" title="13.页面之间的route跳转"></a>13.页面之间的route跳转</h3><pre><code class="vue">//Food.vue
&lt;template&gt;
    &lt;p&gt;food&lt;/p&gt;
    &lt;button @click=&quot;toHome&quot;&gt;toHome&lt;/button&gt;
     &lt;!-- router-link组件跳转 --&gt;
    &lt;router-link to=&quot;/home&quot;&gt;toHome&lt;/router-link&gt;
  &lt;/template&gt;
  &lt;script&gt;
  import &#123; useRouter &#125; from &#39;vue-router&#39;
  export default &#123;
    setup () &#123;
      //编程式跳转
      const router = useRouter()
      const toHome = (() =&gt; &#123;
        router.push(&#123;
          name: &#39;home&#39;
        &#125;)
      &#125;)
      return &#123;
        toHome
      &#125;
    &#125;,
  &#125;
  &lt;/script&gt;
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107145442966.png"></p>
<p>当我们点击toHome按钮就可以跳转到home页了,两种方式都可以跳转</p>
<h3 id="14-配置ESLint和Prettier"><a href="#14-配置ESLint和Prettier" class="headerlink" title="14.配置ESLint和Prettier"></a>14.配置ESLint和Prettier</h3><p>安装ESLint</p>
<pre><code class="ini">//本地安装
npm install eslint --save-dev
//全局安装
npm install -g eslint
</code></pre>
<p>运行eslint –init，选择工程使用了vue，自动生成.eslintrc.js文件</p>
<pre><code class="ini">eslint --init
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107151858584.png"></p>
<p>我们按照需求去选择就可以了</p>
<p>安装prettier</p>
<pre><code class="ini">//本地
npm i -D --save-exact prettier
//全局
npm i --global prettier
</code></pre>
<p>安装eslint-config-prettier插件（禁用 eslint 风格校验)</p>
<pre><code class="ini">npm i -D eslint-config-prettier
</code></pre>
<p>安装eslint-plugin-prettier插件（使eslint采用prettier的风格校验）</p>
<pre><code class="ini">npm i -D eslint-plugin-prettier
</code></pre>
<p>配置eslintrc.js文件</p>
<pre><code class="javascript">module.exports = &#123;
    &quot;env&quot;: &#123;
        &quot;browser&quot;: true,
        &quot;es2021&quot;: true,
        &quot;node&quot;:true,
    &#125;,
    &quot;extends&quot;: [
        &quot;eslint:recommended&quot;,
        &quot;plugin:vue/vue3-essential&quot;
    ],
    &quot;overrides&quot;: [
    ],
    &quot;parserOptions&quot;: &#123;
        &quot;ecmaVersion&quot;: &quot;latest&quot;
    &#125;,
    &quot;plugins&quot;: [
        &quot;vue&quot;
    ],
    &quot;rules&quot;: &#123;
      &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;warn&#39; : &#39;off&#39;,
      &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;warn&#39; : &#39;off&#39;,
       //在rules中添加自定义规则
       //关闭组件命名规则
       &quot;vue/multi-word-component-names&quot;:&quot;off&quot;,
    &#125;
&#125;
</code></pre>
<p>在根目录下创建.prettierrc 或 prettier.config.js文件</p>
<pre><code class="javascript">module.exports = &#123;
    endOfLine: &#39;auto&#39;, // 不检测检测文件每行结束的格式
    semi: true, // 使用分号, 默认true
    singleQuote: true // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)
  &#125;
</code></pre>
<p>安装vscode插件：Prettier ESLint</p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107154026317.png"></p>
<p>该插件会根据工程根目录下的eslintrc.js和prettier.config.js文件格式化代码。可以进一步设置为vscode默认formater和自动格式化。</p>
<p>Prettier配置常用的参数可以根据团队需求制定</p>
<h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p>[ESLint中文文档]: 	“<a href="https://eslint.bootcss.com/">https://eslint.bootcss.com</a> “<br>[Prettier中文网]: 	“<a href="https://www.prettier.cn/">https://www.prettier.cn</a> “</p>
<h3 id="源码仓库地址："><a href="#源码仓库地址：" class="headerlink" title="源码仓库地址："></a>源码仓库地址：</h3><p><a href="https://github.com/mengfeng/vue-cli-start">https://github.com/mengfeng/vue-cli-start</a></p>
]]></content>
      <categories>
        <category>工程技术</category>
        <category>从0到1搭建自己的脚手架vue3</category>
      </categories>
      <tags>
        <tag>工程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>前端异常捕获问题</title>
    <url>/2022/11/05/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（异常捕获）"><a href="#前端面试题大全（异常捕获）" class="headerlink" title="前端面试题大全（异常捕获）"></a>前端面试题大全（异常捕获）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><h4 id="什么是异常数据？"><a href="#什么是异常数据？" class="headerlink" title="什么是异常数据？"></a>什么是异常数据？</h4><p>异常数据，是指前端在操作页面的过程中，触发的执行异常或加载异常，此时浏览器会抛出来报错信息。</p>
<p>比如说你的前端代码用了个未声明的变量，此时控制台会打印出红色错误，告诉你报错原因。或者是接口请求出错了，在网络面板内也能查到异常情况，是请求发送的异常，还是接口响应的异常。</p>
<p>在我们实际的开发场景中，前端捕获的异常主要是分两个大类，接口异常 和 前端异常，我们分别看下这两大类异常怎么捕获。</p>
<h4 id="接口异常"><a href="#接口异常" class="headerlink" title="接口异常"></a>接口异常</h4><p>接口异常一定是在请求的时候触发。前端目前大部分的请求是用 axios 发起的，所以只要获取 axios 可能发生的异常即可。</p>
<p>如果你用 Promise 的写法，则用 .catch 捕获：</p>
<pre><code class="javascript">axios
  .post(&#39;/test&#39;)
  .then((res) =&gt; &#123;
    console.log(res);
  &#125;)
  .catch((err) =&gt; &#123;
    // err 就是捕获到的错误对象
    handleError(err);
  &#125;);
</code></pre>
<p>如果你用 async&#x2F;await 的写法，则用 try..catch.. 捕获：</p>
<pre><code class="javascript">async () =&gt; &#123;
  try &#123;
    let res = await axios.post(&#39;/test&#39;);
    console.log(res);
  &#125; catch (err) &#123;
    // err 就是捕获到的错误对象
    handleError(err);
  &#125;
&#125;;
</code></pre>
<p>当捕获到异常之后，统一交给 handleError 函数处理，这个函数会将接收到的异常进行处理，并调用 上报接口 将异常数据传到服务器，从而完成采集。</p>
<p>上面我们写的异常捕获，逻辑上是没问题的，实操起来就会发现第一道坎：页面这么多，难道每个请求都要包一层 catch 吗？</p>
<p>是啊，如果我们是新开发一个项目，在开始的时候就规定每个请求要包一层 catch 也无可厚非，但是如果是在一个已有的规模还不小的项目中接入前端监控，这时候在每个页面或每个请求 catch 显然是不现实的。</p>
<p>所以，为了最大程度地降低接入成本，减少侵入性，我们是用第二种方案：在 axios 拦截器中捕获异常。</p>
<p>前端项目，为了统一处理请求，比如 401 的跳转，或者全局错误提示，都会在全局写一个 axios 实例，为这个实例添加拦截器，然后在其他页面中直接导入这个实例使用，比如：</p>
<pre><code class="javascript">// 全局请求：src/request/axios.js
const instance = axios.create(&#123;
  baseURL: &#39;https://api.test.com&#39;
  timeout: 15000,
  headers: &#123;
    &#39;Content-Type&#39;: &#39;application/json&#39;,
  &#125;,
&#125;)
export default instance1
</code></pre>
<p>然后在具体的页面中这样发起请求：</p>
<pre><code class="javascript">// a 页面：src/page/a.jsx
import http from &#39;@/src/request/axios.js&#39;;
async () =&gt; &#123;
  let res = await http.post(&#39;/test&#39;);
  console.log(res);
&#125;;
</code></pre>
<p>这样的话，我们发现每个页面的请求都会走全局 axios 实例，所以我们只需要在全局请求的位置捕获异常即可，就不需要在每个页面捕获了，这样接入成本会大大降低。</p>
<p>按照这个方案，接下来我们在 src&#x2F;request&#x2F;axios.js 这个文件中动手实施。</p>
<h4 id="拦截器中捕获异常"><a href="#拦截器中捕获异常" class="headerlink" title="拦截器中捕获异常"></a>拦截器中捕获异常</h4><p>首先我们为 axios 添加响应拦截器：</p>
<pre><code class="javascript">// 响应拦截器
instance.interceptors.response.use(
  (response) =&gt; &#123;
    return response.data;
  &#125;,
  (error) =&gt; &#123;
    // 发生异常会走到这里
    if (error.response) &#123;
      let response = error.response;
      if (response.status &gt;= 400) &#123;
        handleError(response);
      &#125;
    &#125; else &#123;
      handleError(null);
    &#125;
    return Promise.reject(error);
  &#125;,
);
</code></pre>
<p>响应拦截器的第二个参数是在发生错误时执行的函数，参数就是异常。我们首先要判断是否存在 error.response，存在就说明接口有响应，也就是接口通了，但是返回错误；不存在则说明接口没通，请求一直挂起，多数是接口崩溃了。</p>
<p>如果有响应，首先获取状态码，根据状态码来判断什么时候需要收集异常。上面的判断方式简单粗暴，只要状态码大于 400 就视为一个异常，拿到响应数据，并执行上报逻辑。</p>
<p>如果没有响应，可以看作是接口超时异常，调用异常处理函数时传一个 null 即可。</p>
<h3 id="前端异常"><a href="#前端异常" class="headerlink" title="前端异常"></a>前端异常</h3><p>上面我们介绍了在 axios 拦截器中如何捕获接口异常，这部分我们再介绍如何捕获前端异常。</p>
<p>前端代码捕获异常，最常用的方式就是用 try..catch.. 了，任意同步代码块都可以放到 try 块中，只要发生异常就会执行 catch：</p>
<pre><code class="javascript">try &#123;
  // 任意同步代码
&#125; catch (err) &#123;
  console.log(err);
&#125;
</code></pre>
<p>上面说“任意同步代码”而不是“任意代码”，主要是普通的 Promise 写法 try..catch.. 是捕获不到的，只能用 .catch() 捕获，如：</p>
<pre><code class="javascript">try &#123;
  Promise.reject(new Error(&#39;出错了&#39;)).catch((err) =&gt; console.log(&#39;1：&#39;, err));
&#125; catch (err) &#123;
  console.log(&#39;2：&#39;, err);
&#125;
</code></pre>
<p>把这段代码丢进浏览器，打印结果是：</p>
<pre><code class="javascript">1： Error: 出错了1.
</code></pre>
<p>很明显只是 .catch 捕获到了异常。不过与上面接口异常的逻辑一样，这种方式处理当前页面异常没什么问题，但从整个应用来看，这样捕获异常侵入性强，接入成本高，所以我们的思路依然是全局捕获。</p>
<p>全局捕获 js 的异常也比较简单，用 window.addEventLinstener(‘error’) 即可：</p>
<pre><code class="javascript">// js 错误捕获
window.addEventListener(&#39;error&#39;, (error) =&gt; &#123;
  // error 就是js的异常
&#125;);
</code></pre>
<h4 id="为啥不用-window-onerror-？"><a href="#为啥不用-window-onerror-？" class="headerlink" title="为啥不用 window.onerror ？"></a>为啥不用 window.onerror ？</h4><p>这里很多小伙伴有疑问，为什么不用 window.onerror 全局监听呢？window.addEventLinstener(‘error’) 和 window.onerror 有什么区别呢？</p>
<p>首先这两个函数功能基本一致，都可以全局捕获 js 异常。但是有一类异常叫做 资源加载异常，就是在代码中引用了不存在的图片，js，css 等静态资源导致的异常，比如:</p>
<pre><code class="javascript">const loadCss = ()=&gt; &#123;
  let link = document.createElement(&#39;link&#39;)
  link.type = &#39;text/css&#39;
  link.rel = &#39;stylesheet&#39;
  link.href = &#39;https://baidu.com/15.css&#39;
  document.getElementsByTagName(&#39;head&#39;)[10].append(link)
&#125;
render() &#123;
  return &lt;div&gt;
    &lt;img src=&#39;./bbb.png&#39;/&gt;
    &lt;button onClick=&#123;loadCss&#125;&gt;加载样式&lt;button/&gt;
  &lt;/div&gt;
&#125;
</code></pre>
<p>上述代码中的 baidu.com&#x2F;15.css 和 bbb.png 是不存在的，JS 执行到这里肯定会报一个资源找不到的错误。但是默认情况下，上面两种 window 对象上的全局监听函数都监听不到这类异常。</p>
<p>因为资源加载的异常只会在当前元素触发，异常不会冒泡到 window，因此监听 window 上的异常是捕捉不到的。那怎么办呢？</p>
<p>如果你熟悉 DOM 事件你就会明白，既然冒泡阶段监听不到，那么在捕获阶段一定能监听到。</p>
<p>方法就是给 window.addEventListene 函数指定第三个参数，很简单就是 true，表示该监听函数会在捕获阶段执行，这样就能监听到资源加载异常了。</p>
<pre><code class="javascript">// 捕获阶段全局监听
window.addEventListene(
  &#39;error&#39;,
  (error) =&gt; &#123;
    if (error.target != window) &#123;
      console.log(error.target.tagName, error.target.src);
    &#125;
    handleError(error);
  &#125;,
  true,
);
</code></pre>
<p>上述方式可以很轻松的监听到图片加载异常，这就是为什么更推荐 window.addEventListene 的原因。不过要记得，第三个参数设为 true，监听事件捕获，就可以全局捕获到 JS 异常和资源加载异常。</p>
<p>需要特别注意，window.addEventListene 同样不能捕获 Promise 异常。不管是 Promise.then() 写法还是 async&#x2F;await 写法，发生异常时都不能捕获。</p>
<p>因此，我们还需要全局监听一个 unhandledrejection 函数来捕获未处理的 Promise 异常。</p>
<pre><code class="javascript">// promise 错误捕获
window.addEventListener(&#39;unhandledrejection&#39;, (error) =&gt; &#123;
  // 打印异常原因
  console.log(error.reason);
  handleError(error);
  // 阻止控制台打印
  error.preventDefault();
&#125;);
</code></pre>
<p>unhandledrejection 事件会在 Promise 发生异常并且没有指定 catch 的时候触发，相当于一个全局的 Promise 异常兜底方案。这个函数会捕捉到运行时意外发生的 Promise 异常，这对我们排错非常有用。</p>
<p>默认情况下，Promise 发生异常且未被 catch 时，会在控制台打印异常。如果我们想阻止异常打印，可以用上面的 error.preventDefault() 方法。</p>
<h4 id="异常处理函数"><a href="#异常处理函数" class="headerlink" title="异常处理函数"></a>异常处理函数</h4><p>前面我们在捕获到异常时调用了一个异常处理函数 handleError，所有的异常和上报逻辑统一在这个函数内处理，接下来我们实现这个函数。</p>
<pre><code class="javascript">const handleError = (error: any, type: 1 | 2) &#123;
  if(type == 1) &#123;
    // 处理接口异常
  &#125;
  if(type == 2) &#123;
    // 处理前端异常
  &#125;
&#125;
</code></pre>
<p>为了区分异常类型，函数新加了第二个参数 type 表示当前异常属于前端还是接口。在不同的场景中使用如下：</p>
<ul>
<li>处理前端异常：handleError(error, 1)。</li>
<li>处理接口异常：handleError(error, 2)。</li>
</ul>
<h3 id="处理接口异常"><a href="#处理接口异常" class="headerlink" title="处理接口异常"></a>处理接口异常</h3><p>处理接口异常，我们需要将拿到的 error 参数解析，然后取到需要的数据。接口异常一般需要的数据字段如下：</p>
<ul>
<li>code：http 状态码。</li>
<li>url：接口请求地址。</li>
<li>method：接口请求方法。</li>
<li>params：接口请求参数。</li>
<li>error：接口报错信息。</li>
</ul>
<p>这些字段都可以在 error 参数中获取，方法如下：</p>
<pre><code class="javascript">const handleError = (error: any, type: 1 | 2) &#123;
  if(type == 1) &#123;
    // 此时的 error 响应，它的 config 字段中包含请求信息
    let &#123; url, method, params, data &#125; = error.config
    let err_data = &#123;
       url, method,
       params: &#123; query: params, body: data &#125;,
       error: error.data?.message || JSON.stringify(error.data),
    &#125;)
  &#125;
&#125;
</code></pre>
<p>config 对象中的 params 表示 GET 请求的 query 参数，data 表示 POST 请求的 body 参数，所以我在处理参数的时候，将这两个参数合并为一个，用一个属性 params 来表示。</p>
<pre><code class="javascript">params: &#123; query: params, body: data &#125;
</code></pre>
<p>还有一个 error 属性表示错误信息，这个获取方式要根据你的接口返回格式来拿。要避免获取到接口可能返回的超长错误信息，多半是接口没处理，这样可能会导致写入数据失败，要提前与后台规定好。</p>
<h3 id="处理前端异常"><a href="#处理前端异常" class="headerlink" title="处理前端异常"></a>处理前端异常</h3><p>前端异常异常大多数就是 js 异常，异常对应到 js 的 Error 对象，在处理之前，我们先看 Error 有哪几种类型：</p>
<ul>
<li>ReferenceError：引用错误。</li>
<li>RangeError：超出有效范围。</li>
<li>TypeError：类型错误。</li>
<li>URIError：URI 解析错误。</li>
</ul>
<p>这几类异常的引用对象都是 Error，因此可以这样获取：</p>
<pre><code class="javascript">const handleError = (error: any, type: 1 | 2) &#123;
  if(type == 2) &#123;
    let err_data = null
    // 监测 error 是否是标准类型
    if(error instanceof Error) &#123;
      let &#123; name, message &#125; = error
      err_data = &#123;
        type: name,
        error: message
      &#125;
    &#125; else &#123;
      err_data = &#123;
        type: &#39;other&#39;,
        error: JSON.strigify(error)
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>上述判断中，首先判断异常是否是 Error 的实例。事实上绝大部分的代码异常都是标准的 JS Error，但我们这里还是判断一下，如果是的话直接获取异常类型和异常信息，不是的话将异常类型设置为 other 即可。</p>
<p>我们随便写一个异常代码，看一下捕获的结果：</p>
<pre><code class="javascript">function test() &#123;
  console.aaa(&#39;ccc&#39;);
&#125;
test();
</code></pre>
<p>然后捕获到的异常是这样的：</p>
<pre><code class="javascript">const handleError = (error: any) =&gt; &#123;
  if (error instanceof Error) &#123;
    let &#123; name, message &#125; = error;
    console.log(name, message);
    // 打印结果：TypeError console.aaa is not a function
  &#125;
&#125;;
</code></pre>
<h4 id="获取环境数据"><a href="#获取环境数据" class="headerlink" title="获取环境数据"></a>获取环境数据</h4><p>获取环境数据的意思是，不管是接口异常还是前端异常，除了异常本身的数据之外，我们还需要一些其他信息来帮助我们更快更准的定位到哪里出错了。</p>
<p>这类数据我们称之为 “环境数据”，就是触发异常时所在的环境。比如是谁在哪个页面的哪个地方触发的错误，有了这些，我们就能马上找到错误来源，再根据异常信息解决错误。</p>
<p>环境数据至少包括下面这些：</p>
<ul>
<li>app：应用的名称&#x2F;标识。</li>
<li>env：应用环境，一般是开发，测试，生产。</li>
<li>version：应用的版本号。</li>
<li>user_id：触发异常的用户 ID。</li>
<li>user_name：触发异常的用户名。</li>
<li>page_route：异常的页面路由。</li>
<li>page_title：异常的页面名称。</li>
</ul>
<p>app 和 version 都是应用配置，可以判断异常出现在哪个应用的哪个版本。这两个字段我建议直接获取 package.json 下的 name 和 version 属性，在应用升级的时候，及时修改 version 版本号即可。</p>
<h3 id="Vue和React异常处理"><a href="#Vue和React异常处理" class="headerlink" title="Vue和React异常处理"></a>Vue和React异常处理</h3><blockquote>
<p>现在越来越多的项目开始使用前端框架，在MVVM框架中如果你一如既往的想使用window.onerror来捕获异常，那么很可能会竹篮打水一场空，或许根本捕获不到，因为你的异常信息被框架自身的异常机制捕获了。</p>
</blockquote>
<p>比如Vue 2.x中我们应该这样捕获全局异常：</p>
<pre><code class="js">Vue.config.errorHandler = function (err, vm, info) &#123;
    let &#123; 
        message, // 异常信息
        name, // 异常名称
        script,  // 异常脚本url
        line,  // 异常行号
        column,  // 异常列号
        stack  // 异常堆栈信息
    &#125; = err;

    // vm为抛出异常的 Vue 实例
    // info为 Vue 特定的错误信息，比如错误所在的生命周期钩子
&#125;
</code></pre>
<blockquote>
<p>目前script、line、column这3个信息打印出来是undefined，不过这些信息在stack中都可以找到，可以通过正则匹配去进行获取，然后进行上报。</p>
<p>同样的在react也提供了异常处理的方式，在 React 16.x 版本中引入了 Error Boundary：</p>
</blockquote>
<pre><code class="js">class ErrorBoundary extends React.Component &#123;
    constructor(props) &#123;
        super(props);
        this.state = &#123; hasError: false &#125;;
    &#125;

    componentDidCatch(error, info) &#123;
        this.setState(&#123; hasError: true &#125;);

        // 将异常信息上报给服务器
        logErrorToMyService(error, info); 
    &#125;

    render() &#123;
        if (this.state.hasError) &#123;
            return &#39;出错了&#39;;
        &#125;

        return this.props.children;
    &#125;
&#125;
</code></pre>
<p>然后我们就可以这样使用该组件：</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a href="https://www.51cto.com/article/711309.html">https://www.51cto.com/article/711309.html</a></p>
<p><a href="https://juejin.cn/post/7072179884247744526">https://juejin.cn/post/7072179884247744526</a></p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>前端异常捕获</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全之手写代码一</title>
    <url>/2022/11/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试大全之手写代码（一）"><a href="#前端面试大全之手写代码（一）" class="headerlink" title="前端面试大全之手写代码（一）"></a>前端面试大全之手写代码（一）</h1><p>每日12题（高频基础）</p>
<h3 id="1-构造函数继承"><a href="#1-构造函数继承" class="headerlink" title="1.构造函数继承"></a>1.构造函数继承</h3><pre><code class="javascript">function Super(name,age)&#123;
    this.name = name;
    this.age = age;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;];
    this.sayHi = function()&#123;
        console.log(&#39;hi&#39;)
    &#125;
    console.log(this)
&#125;
function Sub()&#123;
    Super.apply(this,arguments)
    this.height = 180;
&#125;

var instance1 = new Sub(&#39;mengfeng&#39;,25);
var instance2 = new Sub(&#39;mengfeng123&#39;,24);
instance1.sayHi();
</code></pre>
<h3 id="2-计时器"><a href="#2-计时器" class="headerlink" title="2.计时器"></a>2.计时器</h3><pre><code class="javascript">var i = 10;
let fn = () =&gt; &#123;
    console.log(i--);
&#125;
function mySetInterval(fn, delay, times) &#123;
    let timer = setTimeout(function a() &#123;
        fn()
        times--
        timer = setTimeout(a, delay)
        if (times &lt;= 0) &#123;
            clearTimeout(timer)
        &#125;
    &#125;, delay)
&#125;
mySetInterval(fn, 1000, 10)
</code></pre>
<h3 id="3-寄生组合继承"><a href="#3-寄生组合继承" class="headerlink" title="3.寄生组合继承"></a>3.寄生组合继承</h3><pre><code class="javascript"> function inheritPrototype(Sub,Super)&#123;
    var subPrototype=Object.create(Super.prototype)
    subPrototype.constructor=Sub
    Sub.prototype=subPrototype
    
  &#125;
  function Super(name)&#123;
    this.name=name
  &#125;
  Super.prototype.sayHi=function()&#123;
    console.log(this.name)//ccdida
  &#125;
  function Sub(name)&#123;
    Super.call(this,name)
  &#125;
  inheritPrototype(Sub,Super)

  Sub.prototype.sayHello=function()&#123;
    console.log(&#39;sayHello&#39;)
  &#125;

  var instance1=new Sub(&#39;ccdida&#39;)
  console.log(instance1.__proto__)
  console.log(instance1.__proto__.__proto__)
</code></pre>
<h3 id="4-柯里化函数"><a href="#4-柯里化函数" class="headerlink" title="4.柯里化函数"></a>4.柯里化函数</h3><pre><code class="javascript">function add() &#123;
    const _args = [...arguments];
    function fn() &#123;
      _args.push(...arguments);
      return fn; //一直重复收集参数
    &#125;
    fn.toString = function() &#123;
      return _args.reduce((sum, cur) =&gt; sum + cur);
    &#125;
    return fn;
  &#125;
console.log(add(1)(2)(3)(4).toString())
console.log(add(1,2)(1, 2, 3)(2).toString())
</code></pre>
<h3 id="5-千位符"><a href="#5-千位符" class="headerlink" title="5.千位符"></a>5.千位符</h3><pre><code class="javascript">// 将金额类型转为数字类型
function toNum(str) &#123;
    return str.replace(/\,|\￥/g, &quot;&quot;);
&#125;

// 保留两位小数（四舍五入）
function toPrice(num) &#123;
    num = parseFloat(toNum(num)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);
&#125;

// 保留两位小数（不四舍五入）
function toPrice1(num) &#123;
    num = parseFloat(toNum(num).replace(/(\.\d&#123;2&#125;)\d+$/,&quot;$1&quot;)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);;
&#125;

// 不处理小数部分
function toPrice2(num) &#123;
    var source = toNum(num).split(&quot;.&quot;);
    source[0] = source[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + source.join(&quot;.&quot;)
&#125;

console.log(toPrice(&#39;12312.236&#39;)) //￥12,312.24
console.log(toPrice1(&#39;12312.234&#39;)) //￥12,312.23
console.log(toPrice2(&#39;1232342312.234&#39;)) //￥1,232,342,312.234
</code></pre>
<h3 id="6-深拷贝"><a href="#6-深拷贝" class="headerlink" title="6.深拷贝"></a>6.深拷贝</h3><pre><code class="javascript">function deepClone(obj,hash = new WeakMap())&#123;
    if(obj == null) return obj;
    if(obj instanceof Date) return new Date(obj);
    if(obj instanceof RegExp) return new RegExp(obj);
    if(typeof obj !== &#39;object&#39;) return obj;
    if(hash.get(obj)) return hash.get(obj);
    let cloneObj = new obj.constructor;
    hash.set(obj,cloneObj);
    for(let key in obj)&#123;
        if(obj.hasOwnProperty(key))&#123;
            cloneObj[key] = deepClone(obj[key],hash);
        &#125;
    &#125;
    return cloneObj;
&#125;

let obj = &#123;name:1,address:&#123;x:1000&#125;&#125;;
let d = deepClone(obj);
obj.address.x = 200;
console.log(d); //&#123;name:1,address:&#123;x:1000&#125;&#125;
</code></pre>
<h3 id="7-数组扁平化"><a href="#7-数组扁平化" class="headerlink" title="7.数组扁平化"></a>7.数组扁平化</h3><pre><code class="javascript">//递归实现
var arr = [1,2,[3,4,[5,6]]]
function flatten(arr)&#123;
    let result = []
    arr.forEach(item =&gt; &#123;
        if(Array.isArray(item))&#123;
            result = result.concat(flatten(item))
        &#125;else&#123;
            result.push(item)
        &#125;
    &#125;);
    return result
&#125;
console.log(flatten(arr)) //[ 1, 2, 3, 4, 5, 6 ]

//利用reduce函数迭代
var arr1 = [1,2,[3,4,[5,6]]]
function flatten1(arr)&#123;
    return arr.reduce((res,next) =&gt; &#123;
        return res.concat(Array.isArray(next) ? flatten1(next) : next)
    &#125;,[])
&#125;
console.log(flatten1(arr1)) //[ 1, 2, 3, 4, 5, 6 ]
</code></pre>
<h3 id="8-原型链继承"><a href="#8-原型链继承" class="headerlink" title="8.原型链继承"></a>8.原型链继承</h3><pre><code class="javascript">//1.原型链继承
function Super()&#123;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;black&#39;]
&#125;
function Sub()&#123;
&#125;

Sub.prototype = new Super();
const instance1 = new Sub();
const instance2 = new Sub();
console.log(instance1.__proto__.color === instance2.__proto__.color)//true
</code></pre>
<h3 id="9-组合继承"><a href="#9-组合继承" class="headerlink" title="9.组合继承"></a>9.组合继承</h3><pre><code class="javascript">function Super(name,age)&#123;
    this.name = name;
    this.age = age;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;]
&#125;

Super.prototype.sayHi = function()&#123;
    console.log(&#39;hi&#39;)
&#125;

function Sub(name,age,height)&#123;
    Super.apply(this,arguments)
    this.height = height;
&#125;

Sub.prototype = new Super(&#39;w&#39;,22);
Sub.prototype.constructor = Sub;
console.log(Sub.prototype)
Sub.prototype.sayHello = function()&#123;
    console.log(&#39;hello&#39;)
&#125;

var instance1 = new Sub(&#39;mengfeng&#39;,23,180);
var instance2 = new Sub(&#39;mengfeng123&#39;,24,181);
console.log(instance1)
</code></pre>
<h3 id="10-instanceof"><a href="#10-instanceof" class="headerlink" title="10.instanceof"></a>10.instanceof</h3><pre><code class="javascript">function new_instance_of(leftValue,rightValue)&#123;
    let rightProto = rightValue.prototype;//取右边表达式的 prototype 值
    leftValue = leftValue.__proto__;//取左表达式的 __proto__ 值
    while(true)&#123;
        if(leftValue == null)&#123;
            return false;
        &#125;
        if(leftValue === rightProto)&#123;
            return true;
        &#125;
        leftValue = leftValue.__proto__;
    &#125;
&#125;
function Foo()&#123;&#125;
console.log(new_instance_of(Foo,Object))//true
</code></pre>
<h3 id="11-promise-all"><a href="#11-promise-all" class="headerlink" title="11.promise.all"></a>11.promise.all</h3><pre><code class="javascript">Promise.prototype.all = function(promises)&#123;
    let results = [];
    let promiseCount = 0;
    let promisesLength = promises.length;
    return new Promise(function(resolve,reject)&#123;
        for(let val of promises)&#123;
            Promise.resolve(val).then(function(res)&#123;
                promiseCount++;
                results[i] = res;
                if(promiseCount === promisesLength)&#123;
                    return resolve(results);
                &#125;
            &#125;,function(err)&#123;
                return reject(err);
            &#125;)
        &#125;
    &#125;)
&#125;

let promise1 = new Promise(function(resolve) &#123;
    resolve(1);
  &#125;);
  let promise2 = new Promise(function(resolve) &#123;
    resolve(2);
  &#125;);
  let promise3 = new Promise(function(resolve) &#123;
    resolve(3);
  &#125;);
  
  let promiseAll = Promise.all([promise1, promise2, promise3]);
  promiseAll.then(function(res) &#123;
    console.log(res);
  &#125;);
</code></pre>
<h3 id="12-promise-race"><a href="#12-promise-race" class="headerlink" title="12.promise.race"></a>12.promise.race</h3><pre><code class="javascript">Promise.race = function(promises)&#123;
    //将可迭代对象转换为数组
    promises = Array.from(promises);
    return new Promise((resolve,reject)=&gt;&#123;
        if(promises.length === 0)&#123;
            //空的可迭代对象，用于pending状态
        &#125;else&#123;
            for(let i = 0;i &lt; promises.length;i++)&#123;
                Promise.resolve(promises[i]).then((data)=&gt;&#123;
                    resolve(data);
                &#125;).catch((reason)=&gt;&#123;
                    reject(reason)
                &#125;)
            &#125;
        &#125;
    &#125;)
&#125;

let p1 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;success&#39;)
    &#125;,1000)
&#125;)

let p2 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;faild&#39;)
    &#125;,500)
&#125;)

Promise.race([p1,p2]).then(result=&gt;&#123;
console.log(result)             //  faild    faild耗时短
&#125;)
</code></pre>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>前端面试大全之手写代码一</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全网络攻防</title>
    <url>/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（网络攻防）"><a href="#前端面试题大全（网络攻防）" class="headerlink" title="前端面试题大全（网络攻防）"></a>前端面试题大全（网络攻防）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="网络攻防"><a href="#网络攻防" class="headerlink" title="网络攻防"></a>网络攻防</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-XSS攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-XSS攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ XSS攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ XSS攻击</h3><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html">美团技术谈XSS攻防</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-CSRF攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-CSRF攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ CSRF攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ CSRF攻击</h3><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">美团技术谈CSRF攻击</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-中间人攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-中间人攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 中间人攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 中间人攻击</h3><p><a href="https://cloud.tencent.com/developer/article/1900287">中间人攻击</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-SQL注入"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-SQL注入" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ SQL注入"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ SQL注入</h3><p><a href="https://blog.csdn.net/github_36032947/article/details/78442189">理解SQL注入</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-DDoS攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-DDoS攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DDoS攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DDoS攻击</h3><p>DDoS攻击——常见的具有破坏性的安全性问题(如果是分布式攻击的话就是DDos攻击)</p>
<p>攻击方式：Ping Flood攻击即利用ping命令不停的发送的数据包到服务器。</p>
<p><a href="https://www.cloudflare.com/zh-cn/learning/ddos/what-is-a-ddos-attack/">DDoS攻击 </a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-DNS缓存污染"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-DNS缓存污染" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DNS缓存污染"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DNS缓存污染</h3><p>DNS缓存污染——常见的网站不可访问的问题</p>
<p>攻击方式：第三方可信赖的域名服务器缓存了一些DNS解析，但被别人制造一些假域名服务器封包污染了，指向错误网址。</p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>网络攻击</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>加载优化（视频加载）</title>
    <url>/2023/02/16/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%A7%86%E9%A2%91%E5%8A%A0%E8%BD%BD%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="视频加载"><a href="#视频加载" class="headerlink" title="视频加载"></a>视频加载</h2><blockquote>
<p>与延迟加载图像资源类似，通过视频标签引入的视频资源也可进行延迟加载，但通常都会根据需求场景进行具体的处理，下面就来探讨一 些关于 视频加载的优化内容。</p>
</blockquote>
<h3 id="一、不需要自动播放"><a href="#一、不需要自动播放" class="headerlink" title="一、不需要自动播放"></a>一、不需要自动播放</h3><p>​		由于Chrome等一些浏览器会对视频资源进行预加载，即在HTML完成加载和解析时触发DOMContentLoaded 事件开始请求视频资源，当请求完成后触发window. onload事件开始页面渲染，过程如图所示。</p>
<p><img src="/2023/02/16/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%A7%86%E9%A2%91%E5%8A%A0%E8%BD%BD%EF%BC%89/image-20230216103841965.png" alt="视频资源的加载"></p>
<p>为了使页面更快地加载并渲染出来，可以阻止不需要自动播放的视频的预加载:其方法是通过视频标签的preload进行控制:</p>
<pre><code class="html">&lt;video controls preload-&quot;none&quot; poster=&quot;default.1po9&quot;&gt;
        &lt;source src=&quot;simply.webm&quot; type-&quot;video/webm&quot;&gt;
        &lt;source src=&quot;simply.mp4&quot; tye-&quot;video/mp4&quot;&gt;
&lt;/video&gt;
</code></pre>
<p>标签的preload属性通常的默认值为auto，表示无论用户是否希望，所有视频文件都会被自动下载，这里将其设置为none，来阻止视频的自动加载。同时这里还通过poster属性为视频提供占位符图片，它的作用是当视频未加载出来时，不至于在页面中呈现一块让用户未知的空白。考虑类似边缘异常场最是必要的，因为浏览器对视烦的加载行为可能存在较大差别。</p>
<ul>
<li>Chrome之前的版本中，preload的默认值是auto,从64版本以后其默人值改为了metadata, 表示仅加载视频的元数据，Firefox、 IE11和Edge等浏览器的行为类似。</li>
<li>Safari 11.0的Mac版会默认进行部分视频资源预加载，11.2的Mac版后仅可预加载元数据，但ios的Safari不会对视频预加载。</li>
<li>若浏览器开启了流量节省模式后，preload 将默认设置为none.</li>
</ul>
<p>​		当浏览器支持preload的metadata属性值后，这将会是一种兼顾了 性能与体验后更优的方式，因为从体验上讲，对于不自动播放的视频场景，在单击播放之前，若能提前告知视频的播放时长、播放列表等元数据，便能带给用户更好的可控感，同时又不至于提前加载了过多资源而阻塞页面渲染。</p>
<p>另外， 如果你的站点中包含了同一域名下的多个视频资源，那么推荐最好将preload属性设置为metadata,或者定义poster属性值时将preload设置为none,这样能很好地避免HTTP的最大连接数，因为通常HTTP 1.1协议规定同一城名下的最大连接数为6,如果同时有超过此数量的资源请求连接，那么多余的连接便会被挂起，这无疑也会对性能造成负面影响。</p>
<h3 id="二、视频代替GIF动画"><a href="#二、视频代替GIF动画" class="headerlink" title="二、视频代替GIF动画"></a>二、视频代替GIF动画</h3><p>​		另一种视频的使用场最是在前面章节讲到的:应当尽量用视频代替尺寸过大的GIF动画，虽然GIF动画的应用历史和范围都很广泛，但其在输出文件大小、图像色彩质量等许多方面的表现均不如视频。GIF动画相对于视频具有三个附加的特性:没有音轨、连续循环播放、加载完自动播放，替换成视频后类似于:</p>
<pre><code class="html">&lt;video autoplay muted loop playsinline&gt;
        &lt;source src-&quot;video.webm&quot; type-&quot;video/webm&quot;&gt;
        &lt;source srC-&quot;video .mp4&quot;type-&quot;video/mp4&quot;&gt;
&lt;/video&gt;
</code></pre>
<p>​		其中在视频标签中附加的属性含义分别为:autoplay自动播放、muted 静音播放及loop循环播放，而playsinline属性则是用于在ios中指定自动播放的。虽然有了GIF图像的替代方案，但并非所有浏览器都像Chrome一样， 能自动进行延迟加载。接下来就需要进行一些配置开发， 使该场最的视频也能延迟加载。首先修改HTML标签如下:</p>
<pre><code class="html">&lt;video autoplay muted loop playsinline width=&quot;610&quot; height=&quot;254&quot; poster=&quot;video-poster.jpg&quot;&gt;
        &lt;source data-src=&quot;video. webm&quot; type=&quot;video/webm&quot;&gt;
        &lt;source data-src=&quot;video .mp4&quot; type=&quot;video/mp4&quot;&gt;
&lt;/video&gt;
</code></pre>
<p>​		这里进行了两处修改:首先是为视频标签添加了poster 属性，意为使用poster中指定的图片作为视频延迟加载出现前的占位;其次是使用了类似应对图像延迟加载的方式，将真实视频资源的URL放在data-src属性中，然后基于Intersection Observer用JavaScript实现对延迟加载的控制:</p>
<pre><code class="js">Document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123;
  const lazyVideos = [].slice.call(document.querySelectorAll(&quot;video.lazy&quot;));
  if (&quot;IntersectionObserver&quot; in window) &#123;
    const lazyVideoObserver = new IntersectionObserver((entries, observer) =&gt; &#123;
      entries.forEach((video) =&gt; &#123;
        if (video.isIntersecting) &#123;
          for (const source in video.target.children) &#123;
            const videoSrc = video.target.children[source];
            if (
              typeof videoSrc.tagName === &quot;string&quot; &amp;&amp;
              videoSrc.tagName === &quot;source&quot;
            ) &#123;
              videoSrc.src = videoSrc.dataset.src;
            &#125;
          &#125;
          video.target.load();
          video.target.classList.remove(&quot;lazy&quot;);
          lazyVideoObserver.unobserve(video.target);
        &#125;
      &#125;);
    &#125;);

    lazyVideos.forEach((lazyVideo) =&gt; &#123;
      lazyVideoObserver.observe(lazyVideo);
    &#125;);
  &#125;
&#125;);
</code></pre>
<p>​		对视频标签的延迟加载有点类似<picture>,需要对所有<source> 子元素进行选代解析，将data-src上的属性值迁移到src属性上。不同的是，需要额外显示调用元素的load方法来触发加载，然后视频才会根据autoplay属性开始进行自动播放。如此便可使用低于GIF动画的流量消耗，进行资源的延迟加载。</p>
]]></content>
      <categories>
        <category>前端性能优化</category>
        <category>加载优化（视频加载）</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>视频加载</tag>
      </tags>
  </entry>
  <entry>
    <title>如何上传npm包</title>
    <url>/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="如何上传自己的npm包"><a href="#如何上传自己的npm包" class="headerlink" title="如何上传自己的npm包"></a>如何上传自己的npm包</h1><h3 id="一、创建自己的npm账号"><a href="#一、创建自己的npm账号" class="headerlink" title="一、创建自己的npm账号"></a>一、创建自己的npm账号</h3><p>[npm官网]: 	“<a href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
<h3 id="二、创建npm包目录"><a href="#二、创建npm包目录" class="headerlink" title="二、创建npm包目录"></a>二、创建npm包目录</h3><pre><code class="ini">mkdir npm-me // 在终端输入以下命令，npm-me为包的目录，可以自己任意取名
cd npm-me // 进入包目录
</code></pre>
<h3 id="三、-编写模块"><a href="#三、-编写模块" class="headerlink" title="三、 编写模块"></a>三、 编写模块</h3><p>在npm-me目录下创建 ifYes.js文件</p>
<pre><code class="javascript">//ifYes.js
exports.ifYes = function() &#123;
    return &quot;If you&#39;re late, your wages will be docked&quot;
&#125;
</code></pre>
<h3 id="四、-初始化包描述文件"><a href="#四、-初始化包描述文件" class="headerlink" title="四、 初始化包描述文件"></a>四、 初始化包描述文件</h3><pre><code class="ini">npm init //初始化会生成package.json文件
</code></pre>
<p>初始化的过程会出现一系列的问题，根据我们自己的情况去选择就可以，如果没有其他要求，回车就可哟</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110143318339.png"></p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110143450471.png"></p>
<h3 id="五、注册包仓库账号"><a href="#五、注册包仓库账号" class="headerlink" title="五、注册包仓库账号"></a>五、注册包仓库账号</h3><pre><code class="ini">npm adduser
</code></pre>
<p>当你没有创建npm账户或者输入错误的账户和密码，都会出现下面的error</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110143800873.png"></p>
<p>这是处理正确的结果（确认的时候需要接收验证码：例30466554）</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110144117450.png"></p>
<h3 id="六、上传包"><a href="#六、上传包" class="headerlink" title="六、上传包"></a>六、上传包</h3><pre><code class="ini">npm publish 包文件夹名字 //上传npm命令格式
</code></pre>
<p>1.为了不出现npm命名冲突，第一个方法是在npm官网查一下，如果重复就需要重新修改一下（现在我的npm包就冲突了）</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110144658634.png"></p>
<p>2.当你上传npm包的时候可能才会发现npm命名冲突</p>
<pre><code class="ini">npm publish . //上传npm包
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110145002168.png"></p>
<p>修改后上传</p>
<pre><code class="javascript">//package.json
&#123;
  &quot;name&quot;: &quot;alan-npm-me&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;If you&#39;re late, your wages will be docked&quot;,
  &quot;main&quot;: &quot;ifYes.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [
    &quot;ifYes&quot;
  ],
  &quot;author&quot;: &quot;alan_mf&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110145126857.png"></p>
<p>上传成功啦啦啦</p>
<p>npm账户上可以看到我们上传的包</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110151414170.png"></p>
<h3 id="七、-更新npm包"><a href="#七、-更新npm包" class="headerlink" title="七、 更新npm包"></a>七、 更新npm包</h3><p>npm包修改后，手动把package.json里的version版本号修改了，或者使用以下命令自动更新版本号，再执行npm publish . 命令就可以了。</p>
<ul>
<li>升级补丁版本号(修改bug)：npm version patch</li>
<li>升级小版本号(新增功能)：npm version minor</li>
<li>升级大版本号(较大改版)：npm version major</li>
</ul>
<pre><code class="ini">npm version patch //补丁
npm publish . //更新npm包
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110151715232.png"></p>
<p>更新成功版本1.0.1</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110151928908.png"></p>
<h3 id="八、-对上传的npm进行测试"><a href="#八、-对上传的npm进行测试" class="headerlink" title="八、 对上传的npm进行测试"></a>八、 对上传的npm进行测试</h3><pre><code class="ini">mkdir npm-me-test //新建目录
cd  npm-me-test //进入目录
</code></pre>
<p>下载我们上传的npm包</p>
<pre><code class="ini">npm init -y //初始化生成package.json文件
npm install alan-npm-me -D
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110153117681.png"></p>
<p>创建test.js文件并编写代码</p>
<pre><code class="javascript">//test.js
const demo = require(&#39;alan-npm-me&#39;);
const res = demo.ifYes();
console.log(res);
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110153427301.png"></p>
<p>目前我们所开发的都是共享的npm包，具有一定的安全性风险，如果用于企业，就会具有一定的风险。企业的限制在于，一方面需要享受模块开发带来的低耦合和项目组织上的好处，另一方面却要考虑到模块保密性的问题。所以，通过NPM共享和发布存在潜在的风险。</p>
<p>为了同时能够享受到NPM上众多的包，同时对自己的包进行保密和限制，现有的解决方案就是企业搭建自己的NPM仓库。局域NPM仓库的搭建方法与搭建镜像站的方式几乎一样，与镜像仓库不同的地方在于，企业局域NPM可以选择不同步官方源仓库中的包，即企业可混合使用官方仓库和局域仓库。</p>
<p>对于企业内部而言，私有的可重用模块可以打包到局域NPM仓库中，这样可以保持更新的中心化，不至于让各个小项目各自维护相同功能的模块，杜绝通过复制粘贴实现代码共享的行为。</p>
<p>链接：</p>
<p>[npm官网]: 	“<a href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
]]></content>
      <categories>
        <category>npm&amp;yarn</category>
        <category>上传自己的npm包</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个自己的博客平台（github+hexo）</title>
    <url>/2022/08/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="如何搭建一个自己的博客平台（github-hexo）"><a href="#如何搭建一个自己的博客平台（github-hexo）" class="headerlink" title="如何搭建一个自己的博客平台（github+hexo）"></a>如何搭建一个自己的博客平台（github+hexo）</h1><h2 id="一、下载node-js"><a href="#一、下载node-js" class="headerlink" title="一、下载node.js"></a>一、下载node.js</h2><p>直接到<a href="https://nodejs.org/zh-cn/">node.js官网</a>下载就可以了</p>
<h2 id="二、下载cnpm"><a href="#二、下载cnpm" class="headerlink" title="二、下载cnpm"></a>二、下载cnpm</h2><pre><code class="linux">//得进入到管理员权限中，要不然权限不够
sudo su
//输入自己的密码就可以了
//然后查看自己node是否安装成功
node -v
npm -v
//利用npm下载cnpm
npm install -g cnpm 
//查看cnpm是否安装成功
cnpm -v
</code></pre>
<h2 id="三、下载hexo博客框架"><a href="#三、下载hexo博客框架" class="headerlink" title="三、下载hexo博客框架"></a>三、下载hexo博客框架</h2><pre><code class="linux">//利用cnpm来下载hexo框架
cnpm install -g hexo-cli
//验证hexo框架是否下载
hexo -v
</code></pre>
<h2 id="四、搭建hexo博客"><a href="#四、搭建hexo博客" class="headerlink" title="四、搭建hexo博客"></a>四、搭建hexo博客</h2><h3 id="1-创建一个文件夹blog"><a href="#1-创建一个文件夹blog" class="headerlink" title="1.创建一个文件夹blog"></a>1.创建一个文件夹blog</h3><pre><code class="linux">mkdir blog
</code></pre>
<h3 id="2-进入blog文件夹并且初始化一hexo博客"><a href="#2-进入blog文件夹并且初始化一hexo博客" class="headerlink" title="2.进入blog文件夹并且初始化一hexo博客"></a>2.进入blog文件夹并且初始化一hexo博客</h3><pre><code class="linux">//1.进入blog
cd blog
//2.初始化hexo博客
sudo hexo init
</code></pre>
<h3 id="3-初始化完成之后，那么就可以启动hexo博客进行预览了"><a href="#3-初始化完成之后，那么就可以启动hexo博客进行预览了" class="headerlink" title="3.初始化完成之后，那么就可以启动hexo博客进行预览了"></a>3.初始化完成之后，那么就可以启动hexo博客进行预览了</h3><pre><code class="linux">//启动hexo博客
hexo s
//浏览器打开 http://localhost:4000/ 端口号就可以了
</code></pre>
<p><img src="/2022/08/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/image-20220826092046998.png"></p>
<h3 id="4-新建一篇博客"><a href="#4-新建一篇博客" class="headerlink" title="4.新建一篇博客"></a>4.新建一篇博客</h3><pre><code class="linux">//1.新建一篇博客
hexo n &quot;我的第一篇hexo博客&quot;
//2.检测博客是否被创建
//查看当前路径
pwd 
//进入博客目录文件夹
cd source/_posts
//查看文件
ls -l
</code></pre>
<p><img src="/2022/08/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/image-20220826092538004.png"></p>
<h3 id="5-编辑空白博客"><a href="#5-编辑空白博客" class="headerlink" title="5.编辑空白博客"></a>5.编辑空白博客</h3><pre><code class="linux">//如果大家熟悉md语法，就可以在终端直接编写博客
vim +博客的名字
//例如 vim 我的第一篇hexo博客
//如果大家不熟悉md语法，也可以使用其他可编辑md文件的快捷编辑器。例如：Typora等
</code></pre>
<h3 id="6-生成hexo博客"><a href="#6-生成hexo博客" class="headerlink" title="6.生成hexo博客"></a>6.生成hexo博客</h3><pre><code class="linux//返回blog目录，当前目录为source/_posts">cd ../..
//清理一下缓存
hexo clean
//然后生成hexo博客
hexo g
</code></pre>
<p><img src="/2022/08/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/image-20220826094128755.png"></p>
<h3 id="7-查看hexo博客内容是否更新"><a href="#7-查看hexo博客内容是否更新" class="headerlink" title="7.查看hexo博客内容是否更新"></a>7.查看hexo博客内容是否更新</h3><pre><code class="linux">//启动博客
hexo s 
//浏览器输入端口号
//博客更新成功
//到目前为止，hexo博客本地部署就完成了，后期我们可以通过本地来测试和修改我们即将发布远端的博客
</code></pre>
<h2 id="五、将本地的博客部署到远端github上面"><a href="#五、将本地的博客部署到远端github上面" class="headerlink" title="五、将本地的博客部署到远端github上面"></a>五、将本地的博客部署到远端github上面</h2><h3 id="1-创建自己的github仓库"><a href="#1-创建自己的github仓库" class="headerlink" title="1.创建自己的github仓库"></a>1.创建自己的github仓库</h3><p>仓库地址必须是xxxx.github.io,而且xxxx必须是和你的用户名一样的，否则访问不了。以后我们只需要访问这个地址就可以访问我们的博客了</p>
<p><img src="/2022/08/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/image-20220826100648264.png"></p>
<h3 id="2-安装一个hexo的git插件"><a href="#2-安装一个hexo的git插件" class="headerlink" title="2.安装一个hexo的git插件"></a>2.安装一个hexo的git插件</h3><pre><code class="linux">cnpm install --save hexo-deployer-git
</code></pre>
<h3 id="3-重点，配置-config-yml"><a href="#3-重点，配置-config-yml" class="headerlink" title="3.!!!!重点，配置_config.yml"></a>3.!!!!重点，配置_config.yml</h3><pre><code class="linux">//查看当前目录下的文件
ls
//配置_config.yml文件
vim _config.yml
</code></pre>
<p><img src="/2022/08/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/image-20220826101717108.png"></p>
<pre><code class="yml">//在配置文件的最底部deploy配置
//repo:替换成你自己的git仓库地址
deploy:
type: git
repo:https://github.com/mengfeng/mengfeng.github.io.git
branch:master
</code></pre>
<h3 id="4-配置完成之后就可以部署了"><a href="#4-配置完成之后就可以部署了" class="headerlink" title="4.配置完成之后就可以部署了"></a>4.配置完成之后就可以部署了</h3><pre><code class="linux">hexo d
</code></pre>
<h3 id="5-这时候可能会出现下面的问题（没问题可以省略）"><a href="#5-这时候可能会出现下面的问题（没问题可以省略）" class="headerlink" title="5.这时候可能会出现下面的问题（没问题可以省略）"></a>5.这时候可能会出现下面的问题（没问题可以省略）</h3><p><img src="/2022/08/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/image-20220827093736440.png"></p>
<p>出现这个问题的原因应该是你使用了github密码去部署了，应该使用密钥去部署，具体请看下面的博主介绍</p>
<p><a href="https://zhuanlan.zhihu.com/p/401978754">创建自己的密钥部署</a></p>
<p><img src="/2022/08/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/image-20220827094139470.png"></p>
<p>出现上图的结果，那么说明你的hexo博客已经部署到了github上面去了,访问 xxxx.github.io 就可以了。</p>
<h2 id="六、替换博客主题"><a href="#六、替换博客主题" class="headerlink" title="六、替换博客主题"></a>六、替换博客主题</h2><p>因为默认的主题可能没有长在博主的审美上，所以我们换一个好看一点的，自己喜欢的博客主题也是可以滴。</p>
<h3 id="1-你可以在HEXO官网选择你喜欢的博客主题"><a href="#1-你可以在HEXO官网选择你喜欢的博客主题" class="headerlink" title="1.你可以在HEXO官网选择你喜欢的博客主题"></a>1.你可以在<a href="https://hexo.io/zh-cn/">HEXO官网</a>选择你喜欢的博客主题</h3><h3 id="2-替换博客主题"><a href="#2-替换博客主题" class="headerlink" title="2.替换博客主题"></a>2.替换博客主题</h3><p>所有的博客主题都可以在blog&#x2F;themes里面替换</p>
<pre><code>//下载博客源码到themes文件中，用我用的博客主题举例吧
git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer
//修改_config.yml配置 ayer为博客主题的名字
theme：ayer
//想要更新博客的话只需要
cd themes/ayer
git pull
//最后重新部署就可以了
hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
</code></pre>
<p>后期修改博客配置请看git仓库的配置介绍</p>
]]></content>
      <categories>
        <category>工程技术</category>
        <category>搭建自己的hexo博客</category>
      </categories>
      <tags>
        <tag>开始</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔Linux部署</title>
    <url>/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="宝塔Linux部署"><a href="#宝塔Linux部署" class="headerlink" title="宝塔Linux部署"></a>宝塔Linux部署</h1><h3 id="一、购买云服务器"><a href="#一、购买云服务器" class="headerlink" title="一、购买云服务器"></a>一、购买云服务器</h3><p>[阿里云官网]: 	“<a href="https://cn.aliyun.com/?from_alibabacloud=&amp;utm_content=se_1013083955">https://cn.aliyun.com/?from_alibabacloud=&amp;utm_content=se_1013083955</a> “</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100233843.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100305806.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100353042.png"></p>
<p>当我购买了云服务器，那我们就可以登陆我们的服务器去下载mac的宝塔面板（通过外网地址访问浏览器）</p>
<h3 id="二、登陆云服务器"><a href="#二、登陆云服务器" class="headerlink" title="二、登陆云服务器"></a>二、登陆云服务器</h3><p>初始化（重置）实例密码</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101533088.png"></p>
<p>输入Password密码和实例密码</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100757824.png"></p>
<h3 id="三、安装宝塔"><a href="#三、安装宝塔" class="headerlink" title="三、安装宝塔"></a>三、安装宝塔</h3><p>然后可以看到已经进了服务器，那么我们就可以开始安装了</p>
<pre><code class="php">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh fa1f2600
</code></pre>
<p>稍等片刻后，输入“y”继续</p>
<p>下载成功之后，就会出现账户和密码和访问地址</p>
<p>我们通过外网面板地址访问</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101323474.png"></p>
<p>如果现在无法访问的话，就去阿里云服务器实例安全组添加提示端口</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101750883.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101826756.png"></p>
<p>现在应该可以访问了，如果还不行就添加8888端口</p>
<h3 id="四、配置宝塔"><a href="#四、配置宝塔" class="headerlink" title="四、配置宝塔"></a>四、配置宝塔</h3><p>当我们访问成功，根据提示安装宝塔面板所需要的创建就可以了</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102042938.png"></p>
<p>如果我们下载插件时间过长，重启宝塔面板</p>
<h3 id="五、创建站点"><a href="#五、创建站点" class="headerlink" title="五、创建站点"></a>五、创建站点</h3><p>我们来创建我们第一个站点</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102605290.png"></p>
<p>提交的时候我们可能遇见下面的提示，配置错误</p>
<pre><code class="ini">nginx: [emerg] open() &quot;/www/server/nginx/conf/enable-php.conf&quot; failed (2: No such file or directory) in /www/server/nginx/conf/nginx.conf:79 nginx: configuration file /www/server/nginx/conf/nginx.conf test failed
</code></pre>
<p>有一个最简单的方案就是，替换nginx 的版本，换一个更低一点的版本</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102833852.png"></p>
<p>重启宝塔面板就可以了</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102931757.png"></p>
<h3 id="六、上传站点部署文件"><a href="#六、上传站点部署文件" class="headerlink" title="六、上传站点部署文件"></a>六、上传站点部署文件</h3><p>选择要上传文件的站点</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115103700868.png"></p>
<p>选择要上传的文件，可以拖拽</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115103850298.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115104445278.png"></p>
<p>那么我们现在访问网站就可以了</p>
<p>如果还是访问不到的话（阿里云购买的域名），建议先进行备案，然后再部署网站</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115132138765.png"></p>
]]></content>
      <categories>
        <category>CI/CD</category>
        <category>宝塔Linux部署</category>
      </categories>
      <tags>
        <tag>CD</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计一个组件</title>
    <url>/2022/12/09/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="如何设计一个组件"><a href="#如何设计一个组件" class="headerlink" title="如何设计一个组件"></a>如何设计一个组件</h1><blockquote>
<p>在开发过程中，我们经常会遇到现有组件库无法满足需求，需要自己设计和实现组件的情况。那么，如何才能设计一个既满足产品需求，又易于开发人员使用的组件呢？本文就以一个级联组件的设计为例，探讨一下如何设计一个优质组件。</p>
</blockquote>
<h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>开发这个组件的原因是来自工作中遇到的一个需求。</p>
<p>产品提出的业务需求是实现一个地区的级联选择，并且应设计师要求，不能使用 Ant Design 的Cascader 级联选择，因此需要自己实现一个级联选择。</p>
<p>通常需要从 4 个角度对需求进行分析：</p>
<ol>
<li>业务需求角度</li>
<li>UI 设计角度</li>
<li>开发人员角度</li>
<li>与其他组件配合角度</li>
</ol>
<h4 id="业务需求角度"><a href="#业务需求角度" class="headerlink" title="业务需求角度"></a>业务需求角度</h4><p>在拿到一个需求之后，我们不应当直接考虑如何实现，而要先思考一下，这个需求是不是真正的需求。或者说，这个需求背后，是否还有更加基础和核心的需求。</p>
<p>现在，我们拿到了一个<strong>地区级联选择</strong>的需求，那么我们应该<strong>仅仅实现</strong>地区级联选择吗？我认为不是的，今天我们拿到的是地区选择的需求，明天就可能变成职业选择。</p>
<p>因此，我们实际需要实现的，应该是一个支持<strong>N 级</strong>的级联选择框。</p>
<h4 id="UI-设计角度"><a href="#UI-设计角度" class="headerlink" title="UI 设计角度"></a>UI 设计角度</h4><p>既然已经确定了要实现 N 级级联选择框，就需要考虑其在各个屏幕尺寸的兼容情况，于是我在组件中引入了 Grid 栅格 。并默认设置了 3 级级联的样式，同时为使用者提供了相应的配置选项，如下：</p>
<pre><code class="yaml">&lt;Cascade
  rowProps=&#123;&#123;
    gutter: 10,
  &#125;&#125;
  colProps=&#123;&#123;
    xs: 24,
    sm: 24,
    md: 8,
    lg: 8,
    xl: 8,
  &#125;&#125;
/&gt;
</code></pre>
<h4 id="开发人员角度"><a href="#开发人员角度" class="headerlink" title="开发人员角度"></a>开发人员角度</h4><p>我们开发的组件，不止会被我们的团队成员使用，甚至会开源给其他开发者使用。那么，提供给开发者更好的体验就尤为重要。</p>
<p>为了节省开发人员的学习成本，我们可以按照以下思路考虑：</p>
<ol>
<li>在满足基本需求的前提下，提供尽量少的 API。</li>
<li>为 API 选项提供尽量少的配置项。</li>
<li>为代码，特别是 API 提供尽量好的文档或注释。</li>
</ol>
<p>定义的 <code>Cascade</code> 组件 <code>Props</code> 示例如下：</p>
<pre><code class="less">interface Props&lt;T&gt; &#123;
  cascadeKeys?: CascadeKeys; // 自定义 dataSource 中 value label children 的字段
  value?: T[]; // 指定当前选中的条目
  onChange?: (value: T[], level: number) =&gt; void; // 选中选项时，调用此函数
  rowProps?: RowProps; // 行排列方式，可参考https://ant.design/components/grid-cn/
  colProps?: ColProps; // 列排列方式
  loading?: boolean[]; // 选择框loading装填
  dataSource?: T[] | CascadeData&lt;T&gt; | T[][]; // 可选项数据源
&#125;
</code></pre>
<p>可以看到， <code>Props</code> 中只有 <code>dataSource</code> 是必须的。也就是说，如果你对配置项并不了解，组件也只需要最简单的配置，就可以正常工作了，例如：</p>
<pre><code class="ini">&lt;Cascade
  dataSource=&#123;pcaCascadeData&#125;
/&gt;
</code></pre>
<ol>
<li><p>在使用 TypeScript 时，还需要特别考虑类型匹配的问题。例如可以在使用组件时，传入一个类型，并且在 <code>onChange</code> 事件中如果使用了其他类型， TypeScript 检查就会提示错误，如下面例子中的 <code>PCAItem</code> 。</p>
<pre><code class="ini">&lt;Cascade&lt;PCAItem&gt;
  dataSource=&#123;pcaCascadeData&#125;
  cascadeKeys=&#123;pcaCascadeKeys&#125;
  onChange=&#123;async (value: PCAItem[], level: number) =&gt; &#123;
    setPCAData(value);
    setPCAIndex(level);
  &#125;&#125;
/&gt;
</code></pre>
</li>
<li><p>对于级联组件，我们还需要考虑 dataSource 的数据来源可能有两种。</p>
<ul>
<li>组件初始化时，就传入了所有的级联数据，例如 省&#x2F;地&#x2F;县&#x2F;乡层级数据 。对应 Demo 中的“同步级联数据”，以及 <code>Props</code> 中 <code>dataSource</code> 类型定义的 <code>CascadeData&lt;T&gt; | T[][]</code> 。<ul>
<li>在某些场景下，虽然没有级联选择框存在，但也需要处理树形数据，包括数据的查询和校验等功能，因此将该方法封装到 <code>CascadeData</code> 类中。</li>
<li>考虑到树的数据量可能非常庞大，如果在每次选择时都在树中搜索效率较低。因此设计成在组件创建时，直接遍历树中的所有节点，然后将每个层级所有节点的数据都存储在相应的 <code>Map</code> 中，之后就能很方便地查询数据。</li>
<li>虽然在组件初始化时遍历所有节点比较耗时，但考虑到用户从进入页面到操作组件有一定时间差，因此我认为这个问题可以忽略。</li>
<li>基于以上考虑，你在 <code>Props</code> 中 <code>dataSource</code> 类型中看到的 <code>CascadeData&lt;T&gt;</code> ，就表示直接传入了一个 <code>new CascadeData(treeData)</code> 。而<code>T[][]</code>就表示直接传入树形数据，由组件内部进行 <code>new CascadeData(treeData) </code> 。</li>
</ul>
</li>
<li>组件初始化时，只传入了第一级的选项，之后每级的选项通过前一级所选择的参数，从服务端获取。对应 Demo 中的“异步级联数据”，对应 <code>dataSource</code> 类型中的 <code>T[]</code> 。<ul>
<li>组件初始化时，只传入第一级的数据，其他级别传入空数组，如：<code>[[&#123;&quot;code&quot;:110000,&quot;name&quot;:&quot;北京市&quot;&#125;],[],[]]</code>，组件会渲染出 3 层级联选项。</li>
<li>当进行选择时，需要使用者通过 <code>onChange</code> 事件自行更新下一级的数据。也就是说，组件完全放弃了对数据的控制。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="与其他组件配合角度"><a href="#与其他组件配合角度" class="headerlink" title="与其他组件配合角度"></a>与其他组件配合角度</h4><p>由于该组件需要与 Ant Design 其他组件配合使用，如前面讨论过的 UI 部分，该组件就结合了 Grid 栅格 组件。既保证了该组件在各屏幕宽度下正常显示，又保证了与其他组件的显示一致。</p>
<p>除此之外，还需要考虑与 Form 表单 组件的配合，特别是兼容表单校验功能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过一个级联组件的设计案例，探讨了如何从四个角度分析，进而设计一个优秀的组件。这 4 个角度分别是：</p>
<ol>
<li>业务需求角度</li>
<li>UI 设计角度</li>
<li>开发人员角度</li>
<li>与其他组件配合角度</li>
</ol>
<p>我认为很多时候组件的设计并没有最优解，总是需要根据需求在各种方案中取舍。但只要按照本文提到的 4 个角度进行分析，就能设计出优秀的组件。</p>
]]></content>
      <categories>
        <category>工程技术</category>
        <category>如何设计一个组件</category>
      </categories>
      <tags>
        <tag>组件设计</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建私有的npm仓库</title>
    <url>/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="使用docker和verdaccio搭建npm私有库"><a href="#使用docker和verdaccio搭建npm私有库" class="headerlink" title="使用docker和verdaccio搭建npm私有库"></a>使用docker和verdaccio搭建npm私有库</h1><p>本文章docker环境为macos</p>
<h3 id="1-使用-docker-镜像安装verdaccio"><a href="#1-使用-docker-镜像安装verdaccio" class="headerlink" title="1.使用 docker 镜像安装verdaccio"></a>1.使用 docker 镜像安装verdaccio</h3><pre><code class="ini">docker pull verdaccio/verdaccio //安装verdaccio镜像
</code></pre>
<h3 id="2-启动端口映射verdaccio容器"><a href="#2-启动端口映射verdaccio容器" class="headerlink" title="2.启动端口映射verdaccio容器"></a>2.启动端口映射verdaccio容器</h3><pre><code class="ini">docker run -it --name verdaccio -p 4873:4873 verdaccio/verdaccio //运行 verdaccio，使用 docker 命令运行镜像，创建 verdaccio 容器 ，端口4873
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095140709.png"></p>
<h3 id="3-私有部署npm仓库成功"><a href="#3-私有部署npm仓库成功" class="headerlink" title="3.私有部署npm仓库成功"></a>3.私有部署npm仓库成功</h3><p>访问<a href="http://localhost:4873/">http://localhost:4873/</a></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095258155.png"></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095230480.png"></p>
<h3 id="4-添加权限用户"><a href="#4-添加权限用户" class="headerlink" title="4.添加权限用户"></a>4.添加权限用户</h3><pre><code class="ini">npm adduser --registry http://localhost:4873/ //根据提示添加用户
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095338495.png"></p>
<h3 id="5-登陆"><a href="#5-登陆" class="headerlink" title="5.登陆"></a>5.登陆</h3><p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095621194.png"></p>
<h3 id="6-发布npm包"><a href="#6-发布npm包" class="headerlink" title="6.发布npm包"></a>6.发布npm包</h3><p>当我们的私有仓库搭建好之后，那么我们就可以向仓库发布npm包了，到我们npm包目录下上传就可以了</p>
<pre><code class="css">1.创建npm-me包目录
2.npm init 初始化目录
3.编写功能文件
4.如果是改版发布，更新版本号
5.登陆私有仓库
6.向私有仓库发布npm包
</code></pre>
<pre><code class="javascript">//ifYes.js
exports.ifYes = function() &#123;
    return &quot;If you&#39;re late, your wages will be docked version new（registry）&quot;
&#125;
</code></pre>
<pre><code class="json">//package.json
&#123;
  &quot;name&quot;: &quot;alan-npm-me&quot;,
  &quot;version&quot;: &quot;1.0.3&quot;,
  &quot;description&quot;: &quot;If you&#39;re late, your wages will be docked&quot;,
  &quot;main&quot;: &quot;ifYes.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [
    &quot;ifYes&quot;
  ],
  &quot;author&quot;: &quot;alan_mf&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<pre><code class="ini">npm version patch  //补丁版本更新
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112101529827.png"></p>
<pre><code class="ini">npm-me % npm publish --registry http://localhost:4873/ //发布
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112102102928.png"></p>
<p>这时候刷新我们的私有仓库页面就可以看到了<a href="http://localhost:4873/">http://localhost:4873/</a></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112102228314.png"></p>
<h3 id="7-下载私有仓库的包"><a href="#7-下载私有仓库的包" class="headerlink" title="7.下载私有仓库的包"></a>7.下载私有仓库的包</h3><pre><code class="css">1.创建一个文件目录
2.初始化 npm init -y
3.编辑测试代码
4. npm install --registry http://localhost:4873 alan-npm-me //下载私有仓库npm包
5.执行测试代码
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112105324344.png"></p>
<h3 id="8-修改verdaccio权限"><a href="#8-修改verdaccio权限" class="headerlink" title="8.修改verdaccio权限"></a>8.修改verdaccio权限</h3><p>因为我是docker安装的verdaccio，所以查找配置文件路径是这样的</p>
<pre><code class="ini">1. docker exec --user root -it verdaccio sh
2. cd /verdaccio
3. cd conf
4. vi config.yaml
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112125337815.png"></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112125352787.png"></p>
<p>里面就可以配置你们的文件了，重启容器就生效了</p>
]]></content>
      <categories>
        <category>npm&amp;yarn</category>
        <category>搭建私有的npm仓库</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>秋天的第一个烤红薯</title>
    <url>/2022/10/31/%E7%A7%8B%E5%A4%A9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%83%A4%E7%BA%A2%E8%96%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="秋天的第一个烤红薯"><a href="#秋天的第一个烤红薯" class="headerlink" title="秋天的第一个烤红薯"></a>秋天的第一个烤红薯</h1><h2 id="美丽的不只是风景"><a href="#美丽的不只是风景" class="headerlink" title="美丽的不只是风景"></a>美丽的不只是风景</h2><p><img src="/2022/10/31/%E7%A7%8B%E5%A4%A9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%83%A4%E7%BA%A2%E8%96%AF/IMG_20220923_174805.jpg"></p>
]]></content>
      <categories>
        <category>旅行</category>
        <category>秋天</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>秋天</tag>
        <tag>季节</tag>
      </tags>
  </entry>
  <entry>
    <title>数据埋点监控系统设计</title>
    <url>/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="数据监控和数据埋点"><a href="#数据监控和数据埋点" class="headerlink" title="数据监控和数据埋点"></a>数据监控和数据埋点</h1><h3 id="一、数据监控分类"><a href="#一、数据监控分类" class="headerlink" title="一、数据监控分类"></a>一、数据监控分类</h3><h4 id="1-数据监控"><a href="#1-数据监控" class="headerlink" title="(1)数据监控"></a>(1)数据监控</h4><p>数据监控，顾名思义就是监听用户的行为。常见的数据监控包括：</p>
<ul>
<li>PV&#x2F;UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数</li>
<li>用户在每一个页面的停留时间</li>
<li>用户通过什么入口来访问该网页</li>
<li>用户在相应的页面中触发的行为</li>
</ul>
<p>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</p>
<h4 id="2-性能监控"><a href="#2-性能监控" class="headerlink" title="(2)性能监控"></a>(2)性能监控</h4><p>性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：</p>
<ul>
<li>不同用户，不同机型和不同系统下的首屏加载时间</li>
<li>白屏时间</li>
<li>http等请求的响应时间</li>
<li>静态资源整体下载时间</li>
<li>页面渲染时间</li>
<li>页面交互动画完成时间</li>
</ul>
<p>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。</p>
<h4 id="3-异常监控"><a href="#3-异常监控" class="headerlink" title="(3)异常监控"></a>(3)异常监控</h4><p>此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>
<ul>
<li>Javascript的异常监控</li>
<li>样式丢失的异常监控</li>
</ul>
<h3 id="二、常见的埋点方案"><a href="#二、常见的埋点方案" class="headerlink" title="二、常见的埋点方案"></a>二、常见的埋点方案</h3><h4 id="1-代码埋点"><a href="#1-代码埋点" class="headerlink" title="1. 代码埋点"></a>1. 代码埋点</h4><p>代码埋点是最早的埋点方式，根据业务的分析需求，将埋点的采集代码加入到应用端。按照埋点实施方，又分为前端(客户端)埋点和后端(服务端)埋点两种类型。</p>
<h5 id="1）客户端埋点"><a href="#1）客户端埋点" class="headerlink" title="1）客户端埋点"></a>1）客户端埋点</h5><p>由前端开发手动定义数据采集时机、内容等将数据采集的代码代码段加入到前端业务代码中，当用户在前端产生对应行为时，触发数据采集代码。</p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>按需埋点，采集数据更全面，几乎可覆盖所有数据采集场景</li>
<li>行为数据和业务数据可充分联合分析</li>
</ul>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>延迟上报，数据丢失率高(5%-10%)</li>
<li>需要客户端发版，用户端更新App</li>
<li>埋点开发工作量大</li>
<li>埋点流程需要多方协作，容易漏埋、错埋</li>
</ul>
<h6 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h6><p>全面分析用户在客户端的操作行为，对于一些电商交易类的产品，需要把行为和业务数据充分结合分析</p>
<h5 id="2）服务端埋点"><a href="#2）服务端埋点" class="headerlink" title="2）服务端埋点"></a>2）服务端埋点</h5><p>由服务端开发将埋点采集代码加入到后端服务请求中，当用户前端操作请求服务端数据时，按照约定规则触发埋点代码</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>按需埋点，采集数据更全面，几乎可覆盖所有数据采集场景</li>
<li>行为数据和业务数据可充分联合分析</li>
<li>数据采集实时上报，准确性高，丢失率低</li>
<li>服务端更新，不需要客户端发版或用户更新版本</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>纯前端操作不触发服务请求的按钮点击无法采集数据</li>
<li>埋点开发工作量大</li>
<li>埋点流程需要多方协作，容易漏埋、错埋</li>
</ul>
<h6 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h6><p>对于一些非点击、不可见的行为，或者要获取用户身份信息、更多的业务相关的属性信息。如果前后端都可以采集到，优先后端埋点</p>
<h4 id="2-全埋点"><a href="#2-全埋点" class="headerlink" title="2. 全埋点"></a>2. 全埋点</h4><p>全埋点也有称之为无埋点或无痕埋点的，主要是将埋点采集代码封装成标准的SDK，应用端接入后，按照SDK的采集规则自动化地进行数据采集和上报</p>
<h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>接入SDK后，可自动采集数据，无需按需开发，节省开发成本</li>
<li>页面可见元素均可自动采集，数据更全面</li>
<li>埋点流程简单，业务使用埋点系统自助定义事件，新增埋点需求无需业务开发参与</li>
</ul>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>动态页面或页面不可见行为数据无法采集</li>
<li>和业务强相关的属性信息采集困难</li>
<li>数据全部采集，数据存储压力大</li>
</ul>
<h6 id="适用场景：-2"><a href="#适用场景：-2" class="headerlink" title="适用场景："></a>适用场景：</h6><p>业务场景简单，如工具、应用类的产品，或者业务发展初期，产品快速迭代需求比精细化分析优先级更高，只需要分析简单的PV、UV</p>
<h4 id="3-可视化埋点"><a href="#3-可视化埋点" class="headerlink" title="3. 可视化埋点"></a>3. 可视化埋点</h4><p>默认不采集数据，当数据分析人员通过设备连接用户行为分析工具的数据接入管理界面，在页面可视化定义需要采集的位点后下发采集请求，采集代码生效</p>
<h6 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>默认不上报数据，可视化圈选才按需触发埋点，节约存储和传输成本</li>
<li>业务可视化圈选，埋点操作简单方便</li>
</ul>
<h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>数据只在埋点圈选定义之后才有，历史数据无法回溯</li>
<li>只能覆盖基本的点击、展示等用户行为，和业务强相关的属性信息采集困难</li>
</ul>
<h6 id="适用场景：-3"><a href="#适用场景：-3" class="headerlink" title="适用场景："></a>适用场景：</h6><p>业务场景简单，如工具、应用类的产品，或者业务发展初期，产品快速迭代需求比精细化分析优先级更高，只需要分析简单的PV、UV</p>
<h3 id="三、sdk设计"><a href="#三、sdk设计" class="headerlink" title="三、sdk设计"></a>三、sdk设计</h3><h4 id="SDK的设计"><a href="#SDK的设计" class="headerlink" title="SDK的设计"></a>SDK的设计</h4><p>在开始设计之前，先看一下SDK怎么使用。</p>
<pre><code class="javascript">import StatisticSDK from &#39;StatisticSDK&#39;;
// 全局初始化一次
window.insSDK = new StatisticSDK(&#39;uuid-12345&#39;);
&lt;button onClick=&#123;()=&gt;&#123;
  window.insSDK.event(&#39;click&#39;,&#39;confirm&#39;);
  ...// 其他业务代码
&#125;&#125;&gt;确认&lt;/button&gt;
</code></pre>
<p>首先把SDK实例挂载到全局，之后在业务代码中调用，这里的新建实例时需要传入一个id，因为这个埋点监控系统往往是给多个业务去使用的，通过id去区分不同的数据来源。</p>
<p>首先实现实例化部分：</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
  &#125;
&#125;
</code></pre>
<h4 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h4><p>数据发送是一个最基础的api，后面的功能都要基于此进行。通常这种前后端分离的场景会使用AJAX的方式发送数据，但是这里使用图片的src属性。原因有两点：</p>
<ol>
<li>没有跨域的限制，像srcipt标签、img标签都可以直接发送跨域的GET请求，不用做特殊处理。</li>
<li>兼容性好，一些静态页面可能禁用了脚本，这时script标签就不能使用了。</li>
</ol>
<p>但要注意，这个图片不是用来展示的，我们的目的是去「传递数据」，只是借助img标签的的src属性，在其url后面拼接上参数，服务端收到再去解析。</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
  &#125;
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
    let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
    let img = new Image();
    img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
&#125;
</code></pre>
<p>img标签的优点是不需要将其append到文档，只需设置src属性便能成功发起请求。</p>
<p>通常请求的这个url会是一张1X1px的GIF图片，网上的文章对于这里为什么返回图片的是一张GIF都是含糊带过，这里查阅了一些资料并测试了：</p>
<p>1.同样大小，不同格式的的图片中GIF大小是最小的，所以选择返回一张GIF，这样对性能的损耗更小。</p>
<p>2.如果返回204，会走到img的onerror事件，并抛出一个全局错误;如果返回200和一个空对象会有一个CORB的告警。</p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/346cd16826c82e6bd7a2246d22d56fc478dfc3.png"></p>
<p>3.当然如果不在意这个报错可以采取返回空对象，事实上也有一些工具是这样做的。</p>
<p>有一些埋点需要真实的加到页面上，比如垃圾邮件的发送者会添加这样一个隐藏标志来验证邮件是否被打开，如果返回204或者是200空对象会导致一个明显图片占位符。</p>
<pre><code>&lt;img src=&quot;http://www.example.com/logger?event_id=1234&quot;&gt;1.
</code></pre>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/77236ef50e0237529c0080434f48bd20be8ce5.png"></p>
<h4 id="更优雅的web-beacon"><a href="#更优雅的web-beacon" class="headerlink" title="更优雅的web beacon"></a>更优雅的web beacon</h4><p>这种打点标记的方式被称web beacon(网络信标)。除了gif图片，从2014年开始，浏览器逐渐实现专门的API，来更优雅的完成这件事：Navigator.sendBeacon。</p>
<p>使用很简单。</p>
<pre><code class="javascript">Navigator.sendBeacon(url,data)
</code></pre>
<p>相较于图片的src，这种方式的更有优势：</p>
<ul>
<li>不会和主要业务代码抢占资源，而是在浏览器空闲时去做发送。</li>
<li>并且在页面卸载时也能保证请求成功发送，不阻塞页面刷新和跳转。</li>
</ul>
<p>现在的埋点监控工具通常会优先使用sendBeacon，但由于浏览器兼容性，还是需要用图片的src兜底。</p>
<h4 id="用户行为监控"><a href="#用户行为监控" class="headerlink" title="用户行为监控"></a>用户行为监控</h4><p>上面实现了数据发送的api，现在可以基于它去实现用户行为监控的api。</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
  &#125;
  // 数据发送
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
      let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
      let img = new Image();
      img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
  // 自定义事件
  event(key, val=&#123;&#125;) &#123;
    let eventURL = &#39;http://demo/&#39;
    this.send(eventURL,&#123;event:key,...val&#125;)
  &#125;
  // pv曝光
  pv() &#123;
    this.event(&#39;pv&#39;)
  &#125;
&#125;
</code></pre>
<p>用户行为包括自定义事件和pv曝光，也可以把pv曝光看作是一种特殊的自定义行为事件。</p>
<h4 id="页面性能监控"><a href="#页面性能监控" class="headerlink" title="页面性能监控"></a>页面性能监控</h4><p>页面的性能数据可以通过performance.timing这个API获取到，获取的数据是单位为毫秒的时间戳。</p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/272519802405fa2531a97471630d64ab493783.png"></p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/95d45e432d6684cc4ab527d2ac28bddad1a98e.png" alt="img">上面的不需要全部了解，但比较关键的数据有下面几个，根据它们可以计算出FP&#x2F;DCL&#x2F;Load等关键事件的时间点：</p>
<ol>
<li>页面首次渲染时间：FP(firstPaint)&#x3D;domLoading-navigationStart。</li>
<li>DOM加载完成：DCL(DOMContentEventLoad)&#x3D;domContentLoadedEventEnd-navigationStart。</li>
<li>图片、样式等外链资源加载完成：L(Load)&#x3D;loadEventEnd-navigationStart。</li>
</ol>
<p>上面的数值可以跟performance面板里的结果对应。</p>
<p>回到SDK，我们只用实现一个上传所有性能数据的api就可以了：</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
    // 初始化自动调用性能上报
    this.initPerformance()
  &#125;
  // 数据发送
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
      let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
      let img = new Image();
      img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
  // 性能上报
  initPerformance()&#123;
    let performanceURL = &#39;http://performance/&#39;
    this.send(performanceURL,performance.timing)
  &#125;
&#125;
</code></pre>
<p>并且，在构造函数里自动调用，因为性能数据是必须要上传的，就不需要用户每次都手动调用了。</p>
<h4 id="错误告警监控"><a href="#错误告警监控" class="headerlink" title="错误告警监控"></a>错误告警监控</h4><p>错误报警监控分为JS原生错误和React&#x2F;Vue的组件错误的处理。</p>
<h5 id="JS原生错误"><a href="#JS原生错误" class="headerlink" title="JS原生错误"></a>JS原生错误</h5><p>除了try catch中捕获住的错误，我们还需要上报没有被捕获住的错误——通过error事件和unhandledrejection事件去监听。</p>
<h5 id="error"><a href="#error" class="headerlink" title="error"></a>error</h5><p>error事件是用来监听DOM操作错误DOMException和JS错误告警的，具体来说，JS错误分为下面8类：</p>
<ol>
<li>InternalError: 内部错误，比如如递归爆栈。</li>
<li>RangeError: 范围错误，比如new Array(-1)。</li>
<li>EvalError: 使用eval()时错误。</li>
<li>ReferenceError: 引用错误，比如使用未定义变量。</li>
<li>SyntaxError: 语法错误，比如var a &#x3D; 。</li>
<li>TypeError: 类型错误，比如[1,2].split(‘.’)。</li>
<li>URIError: 给 encodeURI或 decodeURl()传递的参数无效，比如decodeURI(‘%2’)。</li>
<li>Error: 上面7种错误的基类，通常是开发者抛出。</li>
</ol>
<p>也就是说，代码运行时发生的上述8类错误，都可以被检测到。</p>
<h5 id="unhandledrejection"><a href="#unhandledrejection" class="headerlink" title="unhandledrejection"></a>unhandledrejection</h5><p>Promise内部抛出的错误是无法被error捕获到的，这时需要用unhandledrejection事件。</p>
<p>回到SDK的实现，处理错误报警的代码如下：</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
    // 初始化错误监控
    this.initError()
  &#125;
  // 数据发送
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
      let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
      let img = new Image();
      img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
  // 自定义错误上报
  error(err, etraInfo=&#123;&#125;) &#123;
    const errorURL = &#39;http://error/&#39;
    const &#123; message, stack &#125; = err;
    this.send(errorURL, &#123; message, stack, ...etraInfo&#125;)
  &#125;
  // 初始化错误监控
  initError()&#123;
    window.addEventListener(&#39;error&#39;, event=&gt;&#123;
      this.error(error);
    &#125;)
    window.addEventListener(&#39;unhandledrejection&#39;, event=&gt;&#123;
      this.error(new Error(event.reason), &#123; type: &#39;unhandledrejection&#39;&#125;)
    &#125;)
  &#125;
&#125;
</code></pre>
<p>和初始化性能监控一样，初始化错误监控也是一定要做的，所以需要在构造函数中调用。后续开发人员只用在业务代码的try catch中调用error方法即可。</p>
<h3 id="React-x2F-Vue组件错误"><a href="#React-x2F-Vue组件错误" class="headerlink" title="React&#x2F;Vue组件错误"></a>React&#x2F;Vue组件错误</h3><p>成熟的框架库都会有错误处理机制，React和Vue也不例外。</p>
<h5 id="React的错误边界"><a href="#React的错误边界" class="headerlink" title="React的错误边界"></a>React的错误边界</h5><p>错误边界是希望当应用内部发生渲染错误时，不会整个页面崩溃。我们提前给它设置一个兜底组件，并且可以细化粒度，只有发生错误的部分被替换成这个「兜底组件」，不至于整个页面都不能正常工作。</p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/562c10735609456ff5d155aa6880f7ca2598a4.png"></p>
<p>它的使用很简单，就是一个带有特殊生命周期的类组件，用它把业务组件包裹起来。</p>
<p>这两个生命周期是getDerivedStateFromError和componentDidCatch。</p>
<p>代码如下：</p>
<pre><code class="javascript">// 定义错误边界
class ErrorBoundary extends React.Component &#123;
  state = &#123; error: null &#125;
  static getDerivedStateFromError(error) &#123;
    return &#123; error &#125;
  &#125;
  componentDidCatch(error, errorInfo) &#123;
    // 调用我们实现的SDK实例
    insSDK.error(error, errorInfo)
  &#125;
  render() &#123;
    if (this.state.error) &#123;
      return &lt;h2&gt;Something went wrong.&lt;/h2&gt;
    &#125;
    return this.props.children
  &#125;
&#125;
...
&lt;ErrorBoundary&gt;
  &lt;BuggyCounter /&gt;
&lt;/ErrorBoundary&gt;1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.
</code></pre>
<p>回到SDK的整合上，在生产环境下，被错误边界包裹的组件，如果内部抛出错误，全局的error事件是无法监听到的，因为这个错误边界本身就相当于一个try catch。所以需要在错误边界这个组件内部去做上报处理。也就是上面代码中的componentDidCatch生命周期。</p>
<h3 id="Vue的错误边界"><a href="#Vue的错误边界" class="headerlink" title="Vue的错误边界"></a>Vue的错误边界</h3><p>vue也有一个类似的生命周期来做这件事，不再赘述：errorCaptured。</p>
<pre><code class="javascript">Vue.component(&#39;ErrorBoundary&#39;, &#123;
  data: () =&gt; (&#123; error: null &#125;),
  errorCaptured (err, vm, info) &#123;
    this.error = `$&#123;err.stack&#125;\n\nfound in $&#123;info&#125; of component`
    // 调用我们的SDK，上报错误信息
    insSDK.error(err,info)
    return false
  &#125;,
  render (h) &#123;
    if (this.error) &#123;
      return h(&#39;pre&#39;, &#123; style: &#123; color: &#39;red&#39; &#125;&#125;, this.error)
    &#125;
    return this.$slots.default[0]
  &#125;
&#125;)
...
&lt;error-boundary&gt;
  &lt;buggy-counter /&gt;
&lt;/error-boundary&gt;
</code></pre>
<p>现在我们已经实现了一个完整的SDK的骨架，并且处理了在实际开发时，react&#x2F;vue项目应该怎么接入。</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a href="https://www.51cto.com/article/706364.html">https://www.51cto.com/article/706364.html</a></p>
]]></content>
      <categories>
        <category>工程技术</category>
        <category>数据埋点监控系统设计</category>
      </categories>
      <tags>
        <tag>工程技术</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众测试号浪漫早安</title>
    <url>/2022/10/10/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E6%B5%8B%E8%AF%95%E5%8F%B7%E6%B5%AA%E6%BC%AB%E6%97%A9%E5%AE%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="微信公众测试号浪漫早安（公众号）"><a href="#微信公众测试号浪漫早安（公众号）" class="headerlink" title="微信公众测试号浪漫早安（公众号）"></a>微信公众测试号浪漫早安（公众号）</h2><p>去公众号查看吧，嘿嘿<br>浪漫与你同在<br>勇敢的少年</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg4OTg0NDY0Ng==&amp;mid=2247483683&amp;idx=1&amp;sn=06dc7ea6b771925d6fe70d67b21d67a9&amp;chksm=cfe4e7eaf8936efcb39dfdfce911f6b530a665040a98c4c740bc0099f70caa1c25a549fe0678#rd">https://mp.weixin.qq.com/s?__biz=Mzg4OTg0NDY0Ng==&amp;mid=2247483683&amp;idx=1&amp;sn=06dc7ea6b771925d6fe70d67b21d67a9&amp;chksm=cfe4e7eaf8936efcb39dfdfce911f6b530a665040a98c4c740bc0099f70caa1c25a549fe0678#rd</a></p>
]]></content>
      <categories>
        <category>趣味技术</category>
        <category>浪漫早安</category>
      </categories>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title>表白爱心biu</title>
    <url>/2022/11/11/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="爱心代码（canvas）"><a href="#爱心代码（canvas）" class="headerlink" title="爱心代码（canvas）"></a>爱心代码（canvas）</h1><p>每天浪漫一点点</p>
<p>发给你女朋友，有奖励🥳</p>
<p><img src="/2022/11/11/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/image-20221111095138378.png"></p>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;玥小公主爱心&lt;/title&gt;

    &lt;style&gt;
      html,
      body &#123;
        height: 100%;
        padding: 0;
        margin: 0;
        background: #000;
      &#125;
      canvas &#123;
        width: 100%;
        height: 100%;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;pinkboard&quot;&gt;&lt;/canvas&gt;
    &lt;script&gt;
      /*
       * 参数配置
       */
      var settings = &#123;
        particles: &#123;
          length: 500, // 最大颗粒量
          duration: 2, // 粒子持续时间（秒）
          velocity: 110, // 粒子范围（像素/秒）
          effect: -1.0, // 内轮廓
          size: 35, // 颗粒大小（像素）
        &#125;,
      &#125;;

      /*
       * Point class
       */
      var Point = (function () &#123;
        function Point(x, y) &#123;
          this.x = typeof x !== &quot;undefined&quot; ? x : 0;
          this.y = typeof y !== &quot;undefined&quot; ? y : 0;
        &#125;
        Point.prototype.clone = function () &#123;
          return new Point(this.x, this.y);
        &#125;;
        Point.prototype.length = function (length) &#123;
          if (typeof length == &quot;undefined&quot;)
            return Math.sqrt(this.x * this.x + this.y * this.y);
          this.normalize();
          this.x *= length;
          this.y *= length;
          return this;
        &#125;;
        Point.prototype.normalize = function () &#123;
          var length = this.length();
          this.x /= length;
          this.y /= length;
          return this;
        &#125;;
        return Point;
      &#125;)();

      /*
       * Particle class
       */
      var Particle = (function () &#123;
        function Particle() &#123;
          this.position = new Point();
          this.velocity = new Point();
          this.acceleration = new Point();
          this.age = 0;
        &#125;
        Particle.prototype.initialize = function (x, y, dx, dy) &#123;
          this.position.x = x;
          this.position.y = y;
          this.velocity.x = dx;
          this.velocity.y = dy;
          this.acceleration.x = dx * settings.particles.effect;
          this.acceleration.y = dy * settings.particles.effect;
          this.age = 0;
        &#125;;
        Particle.prototype.update = function (deltaTime) &#123;
          this.position.x += this.velocity.x * deltaTime;
          this.position.y += this.velocity.y * deltaTime;
          this.velocity.x += this.acceleration.x * deltaTime;
          this.velocity.y += this.acceleration.y * deltaTime;
          this.age += deltaTime;
        &#125;;
        Particle.prototype.draw = function (context, image) &#123;
          function ease(t) &#123;
            return --t * t * t + 1;
          &#125;
          var size = image.width * ease(this.age / settings.particles.duration);
          context.globalAlpha = 1 - this.age / settings.particles.duration;
          context.drawImage(
            image,
            this.position.x - size / 2,
            this.position.y - size / 2,
            size,
            size
          );
        &#125;;
        return Particle;
      &#125;)();

      /*
       * ParticlePool class
       */
      var ParticlePool = (function () &#123;
        var particles,
          firstActive = 0,
          firstFree = 0,
          duration = settings.particles.duration;

        function ParticlePool(length) &#123;
          // create and populate particle pool
          particles = new Array(length);
          for (var i = 0; i &lt; particles.length; i++)
            particles[i] = new Particle();
        &#125;
        ParticlePool.prototype.add = function (x, y, dx, dy) &#123;
          particles[firstFree].initialize(x, y, dx, dy);

          // handle circular queue
          firstFree++;
          if (firstFree == particles.length) firstFree = 0;
          if (firstActive == firstFree) firstActive++;
          if (firstActive == particles.length) firstActive = 0;
        &#125;;
        ParticlePool.prototype.update = function (deltaTime) &#123;
          var i;

          // update active particles
          if (firstActive &lt; firstFree) &#123;
            for (i = firstActive; i &lt; firstFree; i++)
              particles[i].update(deltaTime);
          &#125;
          if (firstFree &lt; firstActive) &#123;
            for (i = firstActive; i &lt; particles.length; i++)
              particles[i].update(deltaTime);
            for (i = 0; i &lt; firstFree; i++) particles[i].update(deltaTime);
          &#125;

          // remove inactive particles
          while (
            particles[firstActive].age &gt;= duration &amp;&amp;
            firstActive != firstFree
          ) &#123;
            firstActive++;
            if (firstActive == particles.length) firstActive = 0;
          &#125;
        &#125;;
        ParticlePool.prototype.draw = function (context, image) &#123;
          // draw active particles
          if (firstActive &lt; firstFree) &#123;
            for (i = firstActive; i &lt; firstFree; i++)
              particles[i].draw(context, image);
          &#125;
          if (firstFree &lt; firstActive) &#123;
            for (i = firstActive; i &lt; particles.length; i++)
              particles[i].draw(context, image);
            for (i = 0; i &lt; firstFree; i++) particles[i].draw(context, image);
          &#125;
        &#125;;
        return ParticlePool;
      &#125;)();

      /*
       * Putting it all together
       */
      (function (canvas) &#123;
        var context = canvas.getContext(&quot;2d&quot;),
          particles = new ParticlePool(settings.particles.length),
          particleRate =
            settings.particles.length / settings.particles.duration, // particles/sec
          time;

        // get point on heart with -PI &lt;= t &lt;= PI
        function pointOnHeart(t) &#123;
          return new Point(
            160 * Math.pow(Math.sin(t), 3),
            130 * Math.cos(t) -
              50 * Math.cos(2 * t) -
              20 * Math.cos(3 * t) -
              10 * Math.cos(4 * t) +
              25
          );
        &#125;

        // 使用虚拟画布创建粒子图像
        var image = (function () &#123;
          var canvas = document.createElement(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;);
          canvas.width = settings.particles.size;
          canvas.height = settings.particles.size;
          // helper function to create the path
          function to(t) &#123;
            var point = pointOnHeart(t);
            point.x =
              settings.particles.size / 2 +
              (point.x * settings.particles.size) / 450;
            point.y =
              settings.particles.size / 2 -
              (point.y * settings.particles.size) / 450;
            return point;
          &#125;
          // create the path
          context.beginPath();
          var t = -Math.PI;
          var point = to(t);
          context.moveTo(point.x, point.y);
          while (t &lt; Math.PI) &#123;
            t += 0.03; // baby steps!
            point = to(t);
            context.lineTo(point.x, point.y);
          &#125;
          context.closePath();
          // create the fill （更换爱心颜色）
          context.fillStyle = &quot;#ea80b0&quot;;
          context.fill();
          // create the image
          var image = new Image();
          image.src = canvas.toDataURL();
          return image;
        &#125;)();

        // render that thing!
        function render() &#123;
          // next animation frame
          requestAnimationFrame(render);

          // update time（粒子速度）
          var newTime = new Date().getTime() / 1000,
            deltaTime = newTime - (time || newTime);
          time = newTime;

          // clear canvas
          context.clearRect(0, 0, canvas.width, canvas.height);

          // create new particles
          var amount = particleRate * deltaTime;
          for (var i = 0; i &lt; amount; i++) &#123;
            var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
            var dir = pos.clone().length(settings.particles.velocity);
            particles.add(
              canvas.width / 2 + pos.x,
              canvas.height / 2 - pos.y,
              dir.x,
              -dir.y
            );
          &#125;

          // update and draw particles
          particles.update(deltaTime);
          particles.draw(context, image);
        &#125;

        // handle (re-)sizing of the canvas
        function onResize() &#123;
          canvas.width = canvas.clientWidth;
          canvas.height = canvas.clientHeight;
        &#125;
        window.onresize = onResize;

        // delay rendering bootstrap
        setTimeout(function () &#123;
          onResize();
          render();
        &#125;, 10);
      &#125;)(document.getElementById(&quot;pinkboard&quot;));
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>趣味技术</category>
        <category>表白爱心biu</category>
      </categories>
      <tags>
        <tag>浪漫代码</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron-d-1.0</title>
    <url>/2022/11/24/Electron-d-1-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h1><h3 id="一、构建第一个electron应用"><a href="#一、构建第一个electron应用" class="headerlink" title="一、构建第一个electron应用"></a>一、构建第一个electron应用</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><pre><code class="ini">npm init -y //初始化项目
npm install --save-dev electron //下载electron到开发依赖
</code></pre>
<h4 id="2-创建入口index-html"><a href="#2-创建入口index-html" class="headerlink" title="2.创建入口index.html"></a>2.创建入口index.html</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World!&lt;/h1&gt;
    We are using Node.js &lt;span id=&quot;node-version&quot;&gt;&lt;/span&gt;,
    Chromium &lt;span id=&quot;chrome-version&quot;&gt;&lt;/span&gt;,
    and Electron &lt;span id=&quot;electron-version&quot;&gt;&lt;/span&gt;.
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="3-创建入口文件"><a href="#3-创建入口文件" class="headerlink" title="3.创建入口文件"></a>3.创建入口文件</h4><pre><code class="javascript">//main.js
const &#123; app,BrowserWindow &#125; = require(&#39;electron&#39;)

const createWindow = () =&gt; &#123;
    const win = new BrowserWindow(&#123;
      width: 800,
      height: 600
    &#125;)
  
    win.loadFile(&#39;index.html&#39;)
  &#125;

app.whenReady().then(() =&gt; &#123;
    createWindow()
  &#125;)
</code></pre>
<h4 id="4-创建窗口应用"><a href="#4-创建窗口应用" class="headerlink" title="4.创建窗口应用"></a>4.创建窗口应用</h4><p>Package.json配置</p>
<pre><code class="javascript">//Package.json
&#123;
  &quot;name&quot;: &quot;electron-app&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;一个处于实验阶段的app&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;start&quot;: &quot;electron .&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;alanmf&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;devDependencies&quot;: &#123;
    &quot;electron&quot;: &quot;^21.3.0&quot;
  &#125;
&#125;
</code></pre>
<pre><code class="ini">npm start //执行 electron .
</code></pre>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221123155226283.png"></p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221123155133707.png"></p>
<p>为了更方便页面更新我们使用nodemon</p>
<p>nodemon是一个自动重启node应用的工具，当监听的文件或监听目录下的文件发生修改时，自动重启应用</p>
<pre><code class="ini">npm i nodemon -D
</code></pre>
<p>更改package.json</p>
<pre><code class="javascript">//Package.json
&#123;
  &quot;name&quot;: &quot;electron-app&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;一个处于实验阶段的app&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;start&quot;: &quot;nodemon --exec electron .&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;alanmf&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;devDependencies&quot;: &#123;
    &quot;electron&quot;: &quot;^21.3.0&quot;
  &#125;
&#125;
</code></pre>
<h3 id="二、electron核心"><a href="#二、electron核心" class="headerlink" title="二、electron核心"></a>二、electron核心</h3><h4 id="1-electron核心概念"><a href="#1-electron核心概念" class="headerlink" title="1.electron核心概念"></a>1.electron核心概念</h4><p><strong>主进程</strong>；启动项目时运行的main.js脚本就是我们说的主进程，在主进程运行的脚步可以创建web页面的形式展示GUI，主进程只有一个。</p>
<p><strong>渲染进程</strong>：每个Electron的页面都在运行着自己的进程，这样的进程称之为渲染进程（基于Chromium的多进程结构）。</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221123160858462.png"></p>
<p>主进程使用BrowserWindow创建实例，主进程销毁后，对应的渲染进程会被终止。主进程与渲染进程通过 IPC 的方式（事件驱动）进行通信。</p>
<h4 id="2-electron窗口控制台"><a href="#2-electron窗口控制台" class="headerlink" title="2.electron窗口控制台"></a>2.electron窗口控制台</h4><pre><code class="javascript">//打开开发者工具
win.webContents.openDevTools();
//暂时关闭安全警告（不推荐）
process.env[&#39;ELECTRON_DISABLE_SECURITY_WARNINGS&#39;] = &#39;true&#39;
</code></pre>
<pre><code class="javascript">//配置CSP（阻挡一部分安全警告）
&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
</code></pre>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221123162757926.png"></p>
<h4 id="3-主进程事件生命周期"><a href="#3-主进程事件生命周期" class="headerlink" title="3.主进程事件生命周期"></a>3.主进程事件生命周期</h4><p>关闭所有窗口时退出应用 <strong>Windows &amp; Linux</strong></p>
<p>在Windows和Linux上，关闭所有窗口通常会完全退出一个应用程序。</p>
<p>为了实现这一点，你需要监听 <code>app</code> 模块的 <code>&#39;window-all-closed&#39;事件。如果用户不是在 macOS(</code>darwin<code>) 上运行程序，则调用 </code>app.quit()&#96;。</p>
<pre><code class="javascript">app.on(&#39;window-all-closed&#39;, () =&gt; &#123;
  //macOS用户在关闭窗口时不会关闭应用
  if (process.platform !== &#39;darwin&#39;) app.quit()
&#125;)
</code></pre>
<p>当 Linux 和 Windows 应用在没有窗口打开时退出了，macOS 应用通常即使在没有打开任何窗口的情况下也继续运行，并且在没有窗口可用的情况下激活应用时会打开新的窗口。</p>
<p>为了实现这一特性，监听 <code>app</code> 模块的 <code>activate</code> 事件。如果没有任何浏览器窗口是打开的，则调用 <code>createWindow()</code> 方法。</p>
<p>因为窗口无法在 <code>ready</code> 事件前创建，你应当在你的应用初始化后仅监听 <code>activate</code> 事件。 通过在您现有的 <code>whenReady()</code> 回调中附上您的事件监听器来完成这个操作。</p>
<pre><code class="javascript">app.whenReady().then(() =&gt; &#123;
  createWindow()
  app.on(&#39;activate&#39;, () =&gt; &#123;
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  &#125;)
&#125;)
</code></pre>
<p>这样，我们的窗口的控件就完整了（实现macOS用户-没有窗口打开时创建新窗口-关闭窗口不关闭应用，点击程序坞应用打开新窗口）</p>
<h4 id="4-通过预加载脚本从渲染器访问Node-js"><a href="#4-通过预加载脚本从渲染器访问Node-js" class="headerlink" title="4.通过预加载脚本从渲染器访问Node.js"></a>4.通过预加载脚本从渲染器访问Node.js</h4><p>现在，最后要做的是输出Electron的版本号和它的依赖项到你的web页面上。</p>
<p>在主进程通过Node的全局 <code>process</code> 对象访问这个信息是微不足道的。 然而，你不能直接在主进程中编辑DOM，因为它无法访问渲染器 <code>文档</code> 上下文。 它们存在于完全不同的进程！</p>
<p>这是将 <strong>预加载</strong> 脚本连接到渲染器时派上用场的地方。 预加载脚本在渲染器进程加载之前加载，并有权访问两个 渲染器全局 (例如 <code>window</code> 和 <code>document</code>) 和 Node.js 环境。</p>
<p>创建一个名为 <code>preload.js</code> 的新脚本:</p>
<pre><code class="javascript">//preload.js
window.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; &#123;
  const replaceText = (selector, text) =&gt; &#123;
    const element = document.getElementById(selector)
    if (element) element.innerText = text
  &#125;

  for (const dependency of [&#39;chrome&#39;, &#39;node&#39;, &#39;electron&#39;]) &#123;
    replaceText(`$&#123;dependency&#125;-version`, process.versions[dependency])
  &#125;
&#125;)
</code></pre>
<p>上面的代码访问 Node.js <code>process.versions</code> 对象，并运行一个基本的 <code>replaceText</code> 辅助函数将版本号插入到 HTML 文档中。</p>
<p>要将此脚本附加到渲染器流程，请在你现有的 <code>BrowserWindow</code> 构造器中将路径中的预加载脚本传入 <code>webPreferences.preload</code> 选项。</p>
<pre><code class="javascript">// include the Node.js &#39;path&#39; module at the top of your file
const path = require(&#39;path&#39;)

// modify your existing createWindow() function
const createWindow = () =&gt; &#123;
  const win = new BrowserWindow(&#123;
    width: 800,
    height: 600,
    webPreferences: &#123;
      preload: path.join(__dirname, &#39;preload.js&#39;)
    &#125;
  &#125;)

  win.loadFile(&#39;index.html&#39;)
&#125;
// ...
</code></pre>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124081539904.png"></p>
<p>这里使用了两个Node.js概念：</p>
<ul>
<li><code>__dirname</code>字符串指向当前正在执行脚本的路径 (在本例中，它指向你的项目的根文件夹)。</li>
<li><code>path.join</code> API 将多个路径联结在一起，创建一个跨平台的路径字符串。</li>
</ul>
<p>我们使用一个相对当前正在执行JavaScript文件的路径，这样相对路径将在开发模式和打包模式中都将有效。</p>
<h4 id="5-contextBridge"><a href="#5-contextBridge" class="headerlink" title="5.contextBridge"></a>5.contextBridge</h4><p><code>contextBridge</code>模块有以下方法:</p>
<p><code>contextBridge.exposeInMainWorld(apiKey, api)</code></p>
<ul>
<li><code>apiKey</code> string - 将 API 注入到 <code>窗口</code> 的键。 API 将可通过 <code>window[apiKey]</code> 访问。</li>
<li><code>api</code> any - 你的 API可以是什么样的以及它是如何工作的相关信息如下。</li>
</ul>
<p>应用开发接口（API）</p>
<p>提供给 <code>exposeInMainWorld</code> 的 <code>api</code> 必须是一个 <code>Function</code>， <code>string</code>， <code>number</code>， <code>Array</code>， <code>boolean</code>；或一个键为字符串，值为一个 <code>Function</code>， <code>string</code>， <code>number</code>， <code>Array</code>， <code>boolean</code>的对象；或其他符合相同条件的嵌套对象。</p>
<p><code>Function</code> 类型的值被代理到其他上下文中，所有其他类型的值都会被 <strong>复制</strong> 并 <strong>冻结</strong>。 在 API 中发送的任何数据 &#x2F;原始数据将不可改变，在桥接器其中一侧的更新不会导致另一侧的更新。</p>
<p>代码应用：</p>
<pre><code class="javascript">//preload.js+
const &#123; contextBridge &#125; = require(&#39;electron&#39;)

contextBridge.exposeInMainWorld(&#39;myApi&#39;,&#123;
    platform:process.platform
  &#125;)
</code></pre>
<p>那我们就可以在页面上去访问window上的方法了</p>
<pre><code class="javascript">//app.js
console.log(window.myApi.platform) //darwin
</code></pre>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124093018081.png"></p>
<h3 id="三、主进程与渲染进程通信"><a href="#三、主进程与渲染进程通信" class="headerlink" title="三、主进程与渲染进程通信"></a>三、主进程与渲染进程通信</h3><p>进程间通信 (IPC) 是在 Electron 中构建功能丰富的桌面应用程序的关键部分之一。 由于主进程和渲染器进程在 Electron 的进程模型具有不同的职责，因此 IPC 是执行许多常见任务的唯一方法，例如从 UI 调用原生 API 或从原生菜单触发 Web 内容的更改。</p>
<p>在 Electron 中，进程使用 <code>ipcMain</code> 和 <code>ipcRenderer</code>模块，通过开发人员定义的“通道”传递消息来进行通信。 这些通道是 <strong>任意</strong> （您可以随意命名它们）和 <strong>双向</strong> （您可以在两个模块中使用相同的通道名称）的。</p>
<h4 id="1-渲染器进程到主进程（单向"><a href="#1-渲染器进程到主进程（单向" class="headerlink" title="1.渲染器进程到主进程（单向 )"></a>1.渲染器进程到主进程（单向 )</h4><p>要将单向 IPC 消息从渲染器进程发送到主进程，您可以使用 <code>ipcRenderer.send</code>API 发送消息，然后使用 <code>ipcMain.on</code>API 接收。</p>
<p>我们下边就按照官网的例子来说吧！</p>
<h5 id="1-使用-ipcMain-on-监听事件"><a href="#1-使用-ipcMain-on-监听事件" class="headerlink" title="(1) 使用 ipcMain.on 监听事件"></a>(1) 使用 <code>ipcMain.on</code> 监听事件</h5><p>在主进程（main.js）中，使用 <code>ipcMain.on</code> API 在 <code>set-title</code> 通道上设置一个 IPC 监听器:</p>
<pre><code class="javascript">//main.js+
const &#123; ipcMain &#125; = require(&#39;electron&#39;)
 ipcMain.on(&#39;set-title&#39;, (event, title) =&gt; &#123;
      const webContents = event.sender
      const win = BrowserWindow.fromWebContents(webContents)
      win.setTitle(title)
    &#125;)
</code></pre>
<h5 id="2-通过预加载脚本暴露-ipcRenderer-send"><a href="#2-通过预加载脚本暴露-ipcRenderer-send" class="headerlink" title="(2) 通过预加载脚本暴露 ipcRenderer.send"></a>(2) 通过预加载脚本暴露 <code>ipcRenderer.send</code></h5><p>要将消息发送到上面创建的 IPC 监听器，可以使用 <code>ipcRenderer.send</code> API。 默认情况下，渲染器进程没有权限访问 Node.js 和 Electron 模块。 作为应用开发者，需要使用 <code>contextBridge</code> API 来选择要从预加载脚本中暴露哪些 API。</p>
<p>在您的预加载脚本中添加以下代码，向渲染器进程暴露一个全局的 <code>window.electronAPI</code> 变量。</p>
<pre><code class="javascript">//preload.js+
const &#123; contextBridge,ipcRenderer &#125; = require(&#39;electron&#39;)
contextBridge.exposeInMainWorld(&#39;electronAPI&#39;, &#123;
    setTitle: (title) =&gt; ipcRenderer.send(&#39;set-title&#39;, title)
&#125;)
</code></pre>
<p>此时，将能够在渲染器进程中使用 <code>window.electronAPI.setTitle()</code> 函数。</p>
<h5 id="3-构建渲染器进程-UI"><a href="#3-构建渲染器进程-UI" class="headerlink" title="(3) 构建渲染器进程 UI"></a>(3) 构建渲染器进程 UI</h5><p>在 BrowserWindow 加载的我们的 HTML 文件中，添加一个由文本输入框和按钮组成的基本用户界面：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Title: &lt;input id=&quot;title&quot;/&gt;
    &lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;Set&lt;/button&gt;
    &lt;script src=&quot;./renderer/app.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>将在导入的 <code>renderer.js</code> 文件中添加几行代码，以利用从预加载脚本中暴露的 <code>window.electronAPI</code> 功能：</p>
<pre><code class="javascript">//app.js
const setButton = document.getElementById(&#39;btn&#39;)
const titleInput = document.getElementById(&#39;title&#39;)
setButton.addEventListener(&#39;click&#39;, () =&gt; &#123;
    const title = titleInput.value
    window.electronAPI.setTitle(title)
&#125;);
</code></pre>
<p>到目前的代码为止，我们的一个渲染进程到主进程的进程通信就已经实现了，我们可以试一试我们的UI界面功能</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124100800847.png"></p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>！！！我们上面有一些地方不理解的方法和API，我们现在讲一下</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124101054114.png"></p>
<p>上面的 回调函数有两个参数：一个 IpcMainEvent 结构和一个 <code>title</code> 字符串。 每当消息通过 <code>set-title</code> 通道传入时，此函数找到附加到消息发送方的 BrowserWindow 实例，并在该实例上使用 <code>win.setTitle</code> API。</p>
<p>我们只是为了更简单的理解进程通信，具体 API 见官方文档吧！</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124101339509.png"></p>
<h4 id="2-渲染器进程到主进程（双向）"><a href="#2-渲染器进程到主进程（双向）" class="headerlink" title="2.渲染器进程到主进程（双向）"></a>2.渲染器进程到主进程（双向）</h4><p>双向 IPC 的一个常见应用是从渲染器进程代码调用主进程模块并等待结果。 这可以通过将 <code>ipcRenderer.invoke</code> 与 <code>ipcMain.handle</code> 搭配使用来完成。</p>
<h5 id="1-使用-ipcMain-handle-监听事件"><a href="#1-使用-ipcMain-handle-监听事件" class="headerlink" title="(1)使用 ipcMain.handle 监听事件"></a>(1)使用 <code>ipcMain.handle</code> 监听事件</h5><p>在主进程(main.js)中，我们将创建一个 <code>handleFileOpen()</code> 函数，它调用 <code>dialog.showOpenDialog</code> 并返回用户选择的文件路径值。 每当渲染器进程通过 <code>dialog:openFile</code> 通道发送 <code>ipcRender.invoke</code> 消息时，此函数被用作一个回调。 然后，返回值将作为一个 Promise 返回到最初的 <code>invoke</code> 调用。</p>
<pre><code class="javascript">//main.js
const &#123; app,BrowserWindow,ipcMain,dialog &#125; = require(&#39;electron&#39;)
const path = require(&#39;path&#39;)

//回调函数
async function handleFileOpen() &#123;
  const &#123; canceled, filePaths &#125; = await dialog.showOpenDialog()
  if (canceled) &#123;
    return
  &#125; else &#123;
    return filePaths[0]
  &#125;
&#125;

const createWindow = () =&gt; &#123;
    const win = new BrowserWindow(&#123;
      width: 800,
      height: 600,
      webPreferences: &#123;
        preload: path.join(__dirname, &#39;preload.js&#39;)
      &#125;
    &#125;)
    win.loadFile(&#39;index.html&#39;) 
    win.webContents.openDevTools()
    
  &#125;

  app.whenReady().then(() =&gt; &#123;
    //监听，执行回调
    ipcMain.handle(&#39;dialog:openFile&#39;, handleFileOpen)
    createWindow()
    app.on(&#39;activate&#39;, () =&gt; &#123;
      if (BrowserWindow.getAllWindows().length === 0) createWindow()
    &#125;)
  &#125;)
  app.on(&#39;window-all-closed&#39;, () =&gt; &#123;
    if (process.platform !== &#39;darwin&#39;) app.quit()
  &#125;)
</code></pre>
<h5 id="2-通过预加载脚本暴露-ipcRenderer-invoke"><a href="#2-通过预加载脚本暴露-ipcRenderer-invoke" class="headerlink" title="(2)通过预加载脚本暴露 ipcRenderer.invoke"></a>(2)通过预加载脚本暴露 <code>ipcRenderer.invoke</code></h5><p>在预加载脚本中，我们暴露了一个单行的 <code>openFile</code> 函数，它调用并返回 <code>ipcRenderer.invoke(&#39;dialog:openFile&#39;)</code> 的值。 我们将在下一步中使用此 API 从渲染器的用户界面调用原生对话框。</p>
<pre><code class="javascript">//preload.js
const &#123; contextBridge,ipcRenderer &#125; = require(&#39;electron&#39;)
 contextBridge.exposeInMainWorld(&#39;electronAPI&#39;, &#123;
    openFile: () =&gt; ipcRenderer.invoke(&#39;dialog:openFile&#39;)
&#125;)
</code></pre>
<h5 id="3-构建渲染器进程-UI-1"><a href="#3-构建渲染器进程-UI-1" class="headerlink" title="(3)构建渲染器进程 UI"></a>(3)构建渲染器进程 UI</h5><p>最后，让我们构建加载到 BrowserWindow 中的 HTML 文件。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
    &lt;title&gt;Dialog&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button type=&quot;button&quot; id=&quot;btn&quot;&gt;Open a File&lt;/button&gt;
    File path: &lt;strong id=&quot;filePath&quot;&gt;&lt;/strong&gt;
    &lt;script src=&#39;./renderer/app.js&#39;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>用户界面包含一个 <code>#btn</code> 按钮元素，将用于触发我们的预加载 API，以及一个 <code>#filePath</code> 元素，将用于显示所选文件的路径。需要在渲染器进程脚本中编写几行代码</p>
<pre><code class="javascript">//app.js
const btn = document.getElementById(&#39;btn&#39;)
const filePathElement = document.getElementById(&#39;filePath&#39;)

btn.addEventListener(&#39;click&#39;, async () =&gt; &#123;
  const filePath = await window.electronAPI.openFile()
  filePathElement.innerText = filePath
&#125;)
</code></pre>
<p>到目前的代码为止，我们的一个渲染进程到主进程的双向进程通信就已经实现了，我们可以试一试我们的UI界面功能</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124103530122.png"></p>
<h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><p><code>ipcRenderer.invoke</code> API （老方法了，但依然好用）是在 Electron 7 中添加的，作为处理渲染器进程中双向 IPC 的一种开发人员友好的方式。 但这种 IPC 模式存在几种替代方法。</p>
<p>使用 <code>ipcRenderer.send</code>我们用于单向通信的 <code>ipcRenderer.send</code> API 也可用于双向通信。 这是在 Electron 7 之前通过 IPC 进行异步双向通信的推荐方式。</p>
<pre><code class="javascript">//preload.js
// 您也可以使用 `contextBridge` API
// 将这段代码暴露给渲染器进程
const &#123; ipcRenderer &#125; = require(&#39;electron&#39;)

ipcRenderer.on(&#39;asynchronous-reply&#39;, (_event, arg) =&gt; &#123;
  console.log(arg) // 在 DevTools 控制台中打印“pong”
&#125;)
ipcRenderer.send(&#39;asynchronous-message&#39;, &#39;ping&#39;)
</code></pre>
<pre><code class="javascript">//main.js
ipcMain.on(&#39;asynchronous-message&#39;, (event, arg) =&gt; &#123;
  console.log(arg) // 在 Node 控制台中打印“ping”
  // 作用如同 `send`，但返回一个消息
  // 到发送原始消息的渲染器
  event.reply(&#39;asynchronous-reply&#39;, &#39;pong&#39;)
&#125;)
</code></pre>
<p>这种方法有几个缺点：</p>
<ul>
<li>您需要设置第二个 <code>ipcRenderer.on</code> 监听器来处理渲染器进程中的响应。 使用 <code>invoke</code>，您将获得作为 Promise 返回到原始 API 调用的响应值。</li>
<li>没有显而易见的方法可以将 <code>asynchronous-reply</code> 消息与原始的 <code>asynchronous-message</code>消息配对。 如果您通过这些通道非常频繁地来回传递消息，则需要添加其他应用代码来单独跟踪每个调用和响应。</li>
</ul>
<p>使用 <code>ipcRenderer.sendSync</code>API也是可以替代的，但不推荐</p>
<p><code>ipcRenderer.sendSync</code> API 向主进程发送消息，并 <em>同步</em> 等待响应。</p>
<pre><code class="javascript">//main.js
const &#123; ipcMain &#125; = require(&#39;electron&#39;)
ipcMain.on(&#39;synchronous-message&#39;, (event, arg) =&gt; &#123;
  console.log(arg) // 在 Node 控制台中打印“ping”
  event.returnValue = &#39;pong&#39;
&#125;)
</code></pre>
<pre><code class="javascript">//perload.js
// 您也可以使用 `contextBridge` API
// 将这段代码暴露给渲染器进程
const &#123; ipcRenderer &#125; = require(&#39;electron&#39;)

const result = ipcRenderer.sendSync(&#39;synchronous-message&#39;, &#39;ping&#39;)
console.log(result) // 在 DevTools 控制台中打印“pong”
</code></pre>
<p>这份代码的结构与 <code>invoke</code> 模型非常相似，但出于性能原因，我们建议<strong>避免使用此 API</strong>。 它的同步特性意味着它将阻塞渲染器进程，直到收到回复为止。(容易阻塞渲染器进程)</p>
<h4 id="3-主进程到渲染器进程"><a href="#3-主进程到渲染器进程" class="headerlink" title="3.主进程到渲染器进程"></a>3.主进程到渲染器进程</h4><p>将消息从主进程发送到渲染器进程时，需要指定是哪一个渲染器接收消息。 消息需要通过其 <code>WebContents</code>实例发送到渲染器进程。 此 WebContents 实例包含一个 <code>send</code> 方法，其使用方式与 <code>ipcRenderer.send</code> 相同。</p>
<h5 id="1-使用-webContents-模块发送消息"><a href="#1-使用-webContents-模块发送消息" class="headerlink" title="(1)使用 webContents 模块发送消息"></a>(1)使用 <code>webContents</code> 模块发送消息</h5><p>我们需要首先使用 Electron 的 <code>Menu</code> 模块在主进程中构建一个自定义菜单，该模块使用 <code>webContents.send</code> API 将 IPC 消息从主进程发送到目标渲染器。</p>
<pre><code class="javascript">//main.js
const &#123; app,BrowserWindow,ipcMain,Menu &#125; = require(&#39;electron&#39;)
const path = require(&#39;path&#39;)

const createWindow = () =&gt; &#123;
    const win = new BrowserWindow(&#123;
      width: 800,
      height: 600,
      webPreferences: &#123;
        preload: path.join(__dirname, &#39;preload.js&#39;)
      &#125;
    &#125;)

    const menu = Menu.buildFromTemplate([
      &#123;
        label: app.name,
        submenu: [
        &#123;
          click: () =&gt; win.webContents.send(&#39;update-counter&#39;, 1),
          label: &#39;Increment&#39;,
        &#125;,
        &#123;
          click: () =&gt; win.webContents.send(&#39;update-counter&#39;, -1),
          label: &#39;Decrement&#39;,
        &#125;
        ]
      &#125;
  
    ])

    Menu.setApplicationMenu(menu)
    win.loadFile(&#39;index.html&#39;) 
    win.webContents.openDevTools()
    
  &#125;

  app.whenReady().then(() =&gt; &#123;
    ipcMain.on(&#39;counter-value&#39;, (_event, value) =&gt; &#123;
      console.log(value) // will print value to Node console
    &#125;)
    createWindow()
    app.on(&#39;activate&#39;, () =&gt; &#123;
      if (BrowserWindow.getAllWindows().length === 0) createWindow()
    &#125;)
  &#125;)

  app.on(&#39;window-all-closed&#39;, () =&gt; &#123;
    if (process.platform !== &#39;darwin&#39;) app.quit()
  &#125;)
</code></pre>
<h5 id="2-通过预加载脚本暴露-ipcRenderer-on"><a href="#2-通过预加载脚本暴露-ipcRenderer-on" class="headerlink" title="(2)通过预加载脚本暴露 ipcRenderer.on"></a>(2)通过预加载脚本暴露 <code>ipcRenderer.on</code></h5><p>与前面的渲染器到主进程的示例一样，我们使用预加载脚本中的 <code>contextBridge</code> 和 <code>ipcRenderer</code> 模块向渲染器进程暴露 IPC 功能：</p>
<pre><code class="javascript">//preload.js
const &#123; contextBridge,ipcRenderer &#125; = require(&#39;electron&#39;)
contextBridge.exposeInMainWorld(&#39;electronAPI&#39;, &#123;
    handleCounter: (callback) =&gt; ipcRenderer.on(&#39;update-counter&#39;, callback)
&#125;)
</code></pre>
<p>加载预加载脚本后，渲染器进程应有权访问 <code>window.electronAPI.handleCounter()</code> 监听器函数。</p>
<h5 id="3-构建渲染器进程-UI-2"><a href="#3-构建渲染器进程-UI-2" class="headerlink" title="(3)构建渲染器进程 UI"></a>(3)构建渲染器进程 UI</h5><p>我们将在加载的 HTML 文件中创建一个接口，其中包含一个 <code>#counter</code>元素，我们将使用该元素来显示值：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
    &lt;title&gt;Menu Counter&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Current value: &lt;strong id=&quot;counter&quot;&gt;0&lt;/strong&gt;
    &lt;script src=&#39;./renderer/app.js&#39;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>为了更新 HTML 文档中的值，我们将添加几行 DOM 操作的代码，以便在每次触发 <code>update-counter</code> 事件时更新 <code>#counter</code> 元素的值。</p>
<pre><code class="javascript">//app.js
const counter = document.getElementById(&#39;counter&#39;)
window.electronAPI.handleCounter((event, value) =&gt; &#123;
    const oldValue = Number(counter.innerText)
    const newValue = oldValue + value
    counter.innerText = newValue
    event.sender.send(&#39;counter-value&#39;, newValue)
&#125;)
</code></pre>
<p>在上面的代码中，我们将回调传递给从预加载脚本中暴露的 <code>window.electronAPI.onUpdateCounter</code> 函数。 第二个 <code>value</code> 参数对应于我们传入 <code>webContents.send</code> 函数的 <code>1</code> 或 <code>-1</code>，该函数是从原生菜单调用的。</p>
<p>到目前的代码为止，我们的一个主进程到渲染器进程的进程通信就已经实现了，我们可以试一试我们的UI界面功能</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124161644112.png"></p>
<h5 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h5><p>对于从主进程到渲染器进程的 IPC，没有与 <code>ipcRenderer.invoke</code> 等效的 API。 不过，可以从 <code>ipcRenderer.on</code> 回调中将回复发送回主进程。</p>
<p>我们可以对前面例子的代码进行略微修改来演示这一点。 在渲染器进程中，使用 <code>event</code> 参数，通过 <code>counter-value</code> 通道将回复发送回主进程。</p>
<pre><code class="javascript">//app.js
const counter = document.getElementById(&#39;counter&#39;)
window.electronAPI.handleCounter((event, value) =&gt; &#123;
    const oldValue = Number(counter.innerText)
    const newValue = oldValue + value
    counter.innerText = newValue
    event.sender.send(&#39;counter-value&#39;, newValue)
&#125;)
</code></pre>
<p>在主进程中，监听 <code>counter-value</code> 事件并适当地处理它们。</p>
<pre><code class="javascript">//main.js
ipcMain.on(&#39;counter-value&#39;, (_event, value) =&gt; &#123;
      console.log(value) // will print value to Node console
  &#125;)
</code></pre>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124162116311.png"></p>
<h4 id="4-渲染器进程到渲染器进程"><a href="#4-渲染器进程到渲染器进程" class="headerlink" title="4.渲染器进程到渲染器进程"></a>4.渲染器进程到渲染器进程</h4><p>没有直接的方法可以使用 <code>ipcMain</code> 和 <code>ipcRenderer</code> 模块在 Electron 中的渲染器进程之间发送消息。 为此，有两种选择：</p>
<ul>
<li>将主进程作为渲染器之间的消息代理。 这需要将消息从一个渲染器发送到主进程，然后主进程将消息转发到另一个渲染器。</li>
<li>从主进程将一个 MessagePort 传递到两个渲染器。 这将允许在初始设置后渲染器之间直接进行通信。</li>
</ul>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Electron官网]: 	“<a href="https://www.electronjs.org/zh/docs/latest/tutorial/quick-start">https://www.electronjs.org/zh/docs/latest/tutorial/quick-start</a> “</p>
]]></content>
      <categories>
        <category>Electron</category>
        <category>Electron-d-1.0</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron-d-2.0</title>
    <url>/2022/11/25/Electron-d-2-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h1><p>本篇文章接上一篇文章，详细讲解主进程和渲染进程一些常用的API</p>
<h3 id="主进程API"><a href="#主进程API" class="headerlink" title="主进程API"></a>主进程API</h3><h4 id="1-App-BrowserWindow"><a href="#1-App-BrowserWindow" class="headerlink" title="1.App+BrowserWindow"></a>1.App+BrowserWindow</h4><h5 id="App事件："><a href="#App事件：" class="headerlink" title="App事件："></a>App事件：</h5><h6 id="（1）Before-quit"><a href="#（1）Before-quit" class="headerlink" title="（1）Before-quit"></a>（1）Before-quit</h6><ul>
<li><code>event</code> Event #返回</li>
</ul>
<p> 在程序关闭窗口前触发（macOS不是关闭窗口触发，而是关闭程序）</p>
<p>**注:**在 Windows 系统中，如果应用程序因系统关机&#x2F;重启或用户注销而关闭，那么这个事件不会被触发。</p>
<p>代码以及程序演示：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125085755781.png"></p>
<h6 id="（2）browser-window-blur"><a href="#（2）browser-window-blur" class="headerlink" title="（2）browser-window-blur"></a>（2）browser-window-blur</h6><ul>
<li><code>event</code> Event #返回</li>
<li><code>window</code> BrowserWindow #返回</li>
</ul>
<p>当一个 browserWindow （窗口）失去焦点时触发。当我们鼠标点击窗口以外的地方就会失焦。</p>
<p>代码以及程序演示：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125090204480.png"></p>
<h6 id="（3）browser-window-focus"><a href="#（3）browser-window-focus" class="headerlink" title="（3）browser-window-focus"></a>（3）browser-window-focus</h6><ul>
<li><code>event</code> Event #返回</li>
<li><code>window</code> BrowserWindow #返回</li>
</ul>
<p>当一个 browserWindow 获得焦点时触发。</p>
<p>代码以及程序演示：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125090450485.png"></p>
<h6 id="（4）quit"><a href="#（4）quit" class="headerlink" title="（4）quit"></a>（4）quit</h6><ul>
<li><code>event</code> Event #返回</li>
<li><code>exitCode</code> Integer #返回</li>
</ul>
<p>在应用程序退出时发出。</p>
<p>**注:**在 Windows 系统中，如果应用程序因系统关机&#x2F;重启或用户注销而关闭，那么这个事件不会被触发。</p>
<p>代码以及程序演示：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125090654139.png"></p>
<h6 id="（5）window-all-closed"><a href="#（5）window-all-closed" class="headerlink" title="（5）window-all-closed"></a>（5）window-all-closed</h6><p>当所有的窗口都被关闭时触发。</p>
<p>如果你没有监听此事件并且所有窗口都关闭了，默认的行为是控制退出程序；但如果你监听了此事件，你可以控制是否退出程序。 如果用户按下了 <code>Cmd + Q</code>，或者开发者调用了 <code>app.quit()</code>，Electron 会首先关闭所有的窗口然后触发 <code>will-quit</code> 事件，在这种情况下 <code>window-all-closed</code>事件不会被触发。</p>
<p>代码以及程序演示：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125090909458.png"></p>
<h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><p>由于各种app.方法使用频率都差不多，那么我们根据需要看官方文档吧（也比较容易看懂）</p>
<p>[App.方法 文档]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/app#%E6%96%B9%E6%B3%95">https://www.electronjs.org/zh/docs/latest/api/app#方法</a> “</p>
<h5 id="BrowserWindow："><a href="#BrowserWindow：" class="headerlink" title="BrowserWindow："></a>BrowserWindow：</h5><p><code>BrowserWindow</code> 类暴露了各种方法来修改应用窗口的外观和行为</p>
<h6 id="（1）优雅的打开窗口"><a href="#（1）优雅的打开窗口" class="headerlink" title="（1）优雅的打开窗口"></a>（1）优雅的打开窗口</h6><p><code>ready-to-show</code> 事件</p>
<p>在加载页面时，渲染进程第一次完成绘制时，如果窗口还没有被显示，渲染进程会发出 <code>ready-to-show</code> 事件 。 在此事件后显示窗口将没有视觉闪烁：（不会有白屏出现，但如果绘制没有完成，窗口出现的时间也会延长，根据业务需求来选择是否要选择这种优雅的打开窗口方式）</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125093133167.png"></p>
<p>这个事件通常在 <code>did-finish-load</code> 事件之后发出，但是页面有许多远程资源时，它可能会在 <code>did-finish-load</code>之前发出事件。</p>
<p><code>backgroundColor</code>属性</p>
<p>对于一个复杂的应用，<code>ready-to-show</code> 可能发出的太晚，会让应用感觉缓慢。 在这种情况下，建议立刻显示窗口，并使用接近应用程序背景的 <code>backgroundColor</code></p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125093813389.png"></p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125093827541.png"></p>
<p>建议 设置 <code>backgroundColor</code>和 <code>ready-to-show</code> 事件一起用，以使应用感觉更接近原生。</p>
<pre><code class="javascript">//backgroundColor有效值
const win = new BrowserWindow()
win.setBackgroundColor(&#39;hsl(230, 100%, 50%)&#39;)
win.setBackgroundColor(&#39;rgb(255, 145, 145)&#39;)
win.setBackgroundColor(&#39;#ff00a3&#39;)
win.setBackgroundColor(&#39;blueviolet&#39;)
</code></pre>
<h6 id="（2）父子窗口-amp-amp-模态窗口"><a href="#（2）父子窗口-amp-amp-模态窗口" class="headerlink" title="（2）父子窗口&amp;&amp;模态窗口"></a>（2）父子窗口&amp;&amp;模态窗口</h6><p>父子窗口：</p>
<p>通过使用 <code>parent</code> 选项，你可以创建子窗口：</p>
<pre><code class="javascript">const &#123; BrowserWindow &#125; = require(&#39;electron&#39;)

const top = new BrowserWindow()
const child = new BrowserWindow(&#123; parent: top &#125;)
child.show()
top.show()
</code></pre>
<p><code>child</code> 窗口将总是显示在 <code>top</code> 窗口的顶部.</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125094829288.png"></p>
<p>模态窗口</p>
<p>模态窗口是禁用父窗口的子窗口，创建模态窗口必须设置 <code>parent</code> 和 <code>modal</code> 选项：</p>
<pre><code class="javascript">const &#123; BrowserWindow &#125; = require(&#39;electron&#39;)

const child = new BrowserWindow(&#123; parent: top, modal: true, show: false &#125;)
child.loadURL(&#39;https://github.com&#39;)
child.once(&#39;ready-to-show&#39;, () =&gt; &#123;
  child.show()
&#125;)
</code></pre>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125095057232.png"></p>
<h6 id="（3）BrowserWindow属性"><a href="#（3）BrowserWindow属性" class="headerlink" title="（3）BrowserWindow属性"></a>（3）BrowserWindow属性</h6><p>这个BrowserWindow属性 比较多，而且都是设置窗口的一些属性，也是不难理解，我们就对照我们的官方文档来学习吧！</p>
<p>[BrowserWindow属性]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/browser-window#new-browserwindowoptions">https://www.electronjs.org/zh/docs/latest/api/browser-window#new-browserwindowoptions</a> “</p>
<h6 id="（4）webContents"><a href="#（4）webContents" class="headerlink" title="（4）webContents"></a>（4）webContents</h6><p><code>did-finish-load</code> 事件</p>
<p>导航完成时触发，即选项卡的旋转器将停止旋转，并指派<code>onload</code>事件后。</p>
<p>[webContents类实例事件]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/web-contents#%E7%B1%BB-webcontents">https://www.electronjs.org/zh/docs/latest/api/web-contents#类-webcontents</a> “</p>
<h6 id="（5）保存窗口状态"><a href="#（5）保存窗口状态" class="headerlink" title="（5）保存窗口状态"></a>（5）保存窗口状态</h6><p>当我们使用桌面程序的时候，那么我们有时候希望我们关闭程序再次打开程序的时候，程序的界面和状态能够是我们关闭前的样子，不希望再去重新设置。那我们就需要一个包<code>electron-win-state</code> </p>
<p>安装这个包</p>
<pre><code class="ini">npm i electron-win-state -S
</code></pre>
<p>我们可以在npmjs官网上找到这个包，去看它的说明文档</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125101014250.png"></p>
<p>根据使用说明，我们代码如下：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125101245297.png"></p>
<p>我们发现报错了，WinState is not a constructor</p>
<p>当我们打印一下WinState看看什么情况</p>
<pre><code class="javascript">const WinState = require(&#39;electron-win-state&#39;)
console.log(WinState)
</code></pre>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125101446532.png"></p>
<p>发现没有直接引入WinState，我们修改一下</p>
<pre><code class="javascript">const WinState = require(&#39;electron-win-state&#39;).default 
</code></pre>
<p>现在就没报错了。</p>
<p>但是我们发现，虽然安装了这个包，但是我们程序的状态还是没有改变，这就很奇怪了，其实，是我们自己已经给窗口设置了自定义宽高，覆盖了。我们也缺了一句代码；</p>
<pre><code class="javascript"> winState.manage(win)
</code></pre>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125102737449.png"></p>
<p>现在我们的状态保存就没问题了。当我们关闭窗口再次打开的时候就是关闭之前的样子了。</p>
<h4 id="2-dialog"><a href="#2-dialog" class="headerlink" title="2.dialog"></a>2.dialog</h4><p>这些具体参数请看官方文档，下面几个方法返回一个promise对象</p>
<h6 id="（1）dialog-showOpenDialog-browserWindow-options"><a href="#（1）dialog-showOpenDialog-browserWindow-options" class="headerlink" title="（1）dialog.showOpenDialog([browserWindow, ]options)"></a>（1）<code>dialog.showOpenDialog([browserWindow, ]options)</code></h6><h6 id="（2）dialog-showSaveDialog-browserWindow-options"><a href="#（2）dialog-showSaveDialog-browserWindow-options" class="headerlink" title="（2）dialog.showSaveDialog([browserWindow, ]options)"></a>（2）<code>dialog.showSaveDialog([browserWindow, ]options)</code></h6><h6 id="（3）dialog-showMessageBox-browserWindow-options"><a href="#（3）dialog-showMessageBox-browserWindow-options" class="headerlink" title="（3）dialog.showMessageBox([browserWindow, ]options)"></a>（3）<code>dialog.showMessageBox([browserWindow, ]options)</code></h6><p>[dialog文档]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/dialog#dialogshowopendialogsyncbrowserwindow-options">https://www.electronjs.org/zh/docs/latest/api/dialog#dialogshowopendialogsyncbrowserwindow-options</a> “</p>
<h4 id="3-快捷键（globalShortcut）"><a href="#3-快捷键（globalShortcut）" class="headerlink" title="3.快捷键（globalShortcut）"></a>3.快捷键（globalShortcut）</h4><blockquote>
<p>在应用程序没有键盘焦点时，监听键盘事件。</p>
</blockquote>
<p><code>globalShortcut</code> 模块可以在操作系统中注册&#x2F;注销全局快捷键, 以便可以为操作定制各种快捷键。</p>
<p><strong>注意:</strong> 快捷方式是全局的; 即使应用程序没有键盘焦点, 它也仍然在持续监听键盘事件。 在 app 模块的 <code>ready</code> 事件就绪之前，这个模块不能使用。</p>
<pre><code class="javascript">const &#123; app, globalShortcut &#125; = require(&#39;electron&#39;)

app.whenReady().then(() =&gt; &#123;
  // 注册一个&#39;CommandOrControl+X&#39; 快捷键监听器
  const ret = globalShortcut.register(&#39;CommandOrControl+X&#39;, () =&gt; &#123;
    console.log(&#39;CommandOrControl+X is pressed&#39;)
  &#125;)

  if (!ret) &#123;
    console.log(&#39;registration failed&#39;)
  &#125;

  // 检查快捷键是否注册成功
  console.log(globalShortcut.isRegistered(&#39;CommandOrControl+X&#39;))
&#125;)

app.on(&#39;will-quit&#39;, () =&gt; &#123;
  // 注销快捷键
  globalShortcut.unregister(&#39;CommandOrControl+X&#39;)

  // 注销所有快捷键
  globalShortcut.unregisterAll()
&#125;)
</code></pre>
<p>方法</p>
<p><code>globalShortcut</code> 模块具有以下方法:</p>
<h6 id="（1）globalShortcut-register-accelerator-callback"><a href="#（1）globalShortcut-register-accelerator-callback" class="headerlink" title="（1）globalShortcut.register(accelerator, callback)"></a>（1）<code>globalShortcut.register(accelerator, callback)</code></h6><ul>
<li><code>accelerator</code> Accelerator</li>
<li><code>callback</code> Function</li>
</ul>
<p>返回<code>boolean</code> - 快捷键注册是否成功</p>
<p>注册 <code>accelerator</code> 的全局快捷键。 当用户按下注册快捷键时， <code>callback</code> 会被调用。</p>
<p>如果指定的快捷键已经被其他应用程序注册掉, 调用会默默失败。 该特性由操作系统定义，因为操作系统不希望多个程序的全局快捷键互相冲突。</p>
<p>在 macOS 10.14 Mojave 下面，如果 app 没有被授权为可信任使用的客户端，那么下列快捷键会注册失败：</p>
<ul>
<li>“Media Play&#x2F;Pause”</li>
<li>“Media Next Track”</li>
<li>“Media Previous Track”</li>
<li>“Media Stop”</li>
</ul>
<h6 id="（2）globalShortcut-registerAll-accelerators-callback"><a href="#（2）globalShortcut-registerAll-accelerators-callback" class="headerlink" title="（2）globalShortcut.registerAll(accelerators, callback)"></a>（2）<code>globalShortcut.registerAll(accelerators, callback)</code></h6><ul>
<li><code>accelerators</code> string[] - an array of Accelerators.</li>
<li><code>callback</code> Function</li>
</ul>
<p>注册多个全局快捷键。 当用户按下注册快捷键时， <code>callback</code> 会被调用。</p>
<p>如果定义的快捷键已经被其他应用占用，这个调用会失效。 该特性由操作系统定义，因为操作系统不希望多个程序的全局快捷键互相冲突。</p>
<p>在 macOS 10.14 Mojave 下面，如果 app 没有被授权为可信任使用的客户端，那么下列快捷键会注册失败：</p>
<ul>
<li>“Media Play&#x2F;Pause”</li>
<li>“Media Next Track”</li>
<li>“Media Previous Track”</li>
<li>“Media Stop”</li>
</ul>
<h6 id="（3）globalShortcut-isRegistered-accelerator"><a href="#（3）globalShortcut-isRegistered-accelerator" class="headerlink" title="（3）globalShortcut.isRegistered(accelerator)"></a>（3）<code>globalShortcut.isRegistered(accelerator)</code></h6><ul>
<li><code>accelerator</code> Accelerator</li>
</ul>
<p>Returns <code>boolean</code> - 表示 <code>accelerator</code> 全局快捷键是否注册成功</p>
<p>当快捷键已经被其他应用程序注册时, 此调用依然将返回 <code>false</code>。 该特性由操作系统定义，因为操作系统不希望多个程序的全局快捷键互相冲突。</p>
<h6 id="（4）globalShortcut-unregister-accelerator"><a href="#（4）globalShortcut-unregister-accelerator" class="headerlink" title="（4）globalShortcut.unregister(accelerator)"></a>（4）<code>globalShortcut.unregister(accelerator)</code></h6><ul>
<li><code>accelerator</code> Accelerator</li>
</ul>
<p>注销 <code>accelerator</code> 的全局快捷键。</p>
<h6 id="（5）globalShortcut-unregisterAll"><a href="#（5）globalShortcut-unregisterAll" class="headerlink" title="（5）globalShortcut.unregisterAll()"></a>（5）<code>globalShortcut.unregisterAll()</code></h6><p>注销所有的全局快捷键（清空该应用程序的所有全局快捷键）。</p>
<h4 id="4-菜单（Menu）"><a href="#4-菜单（Menu）" class="headerlink" title="4.菜单（Menu）"></a>4.菜单（Menu）</h4><p>我们这举个例子：</p>
<pre><code class="javascript">//一个简单的菜单模板
const &#123; app, Menu &#125; = require(&#39;electron&#39;)

const isMac = process.platform === &#39;darwin&#39;//判断是不是macOS
//role：菜单选项
const template = [
  // &#123; role: &#39;appMenu&#39; &#125;
  ...(isMac ? [&#123;
    label: app.name,//我们程序名称
    submenu: [
      &#123; role: &#39;about&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;services&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;hide&#39; &#125;,
      &#123; role: &#39;hideOthers&#39; &#125;,
      &#123; role: &#39;unhide&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;quit&#39; &#125;
    ]
  &#125;] : []),
  // &#123; role: &#39;fileMenu&#39; &#125;
  &#123;
    label: &#39;File&#39;,
    submenu: [
      isMac ? &#123; role: &#39;close&#39; &#125; : &#123; role: &#39;quit&#39; &#125;
    ]
  &#125;,
  // &#123; role: &#39;editMenu&#39; &#125;
  &#123;
    label: &#39;Edit&#39;,
    submenu: [
      &#123; role: &#39;undo&#39; &#125;,
      &#123; role: &#39;redo&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;cut&#39; &#125;,
      &#123; role: &#39;copy&#39; &#125;,
      &#123; role: &#39;paste&#39; &#125;,
      ...(isMac ? [
        &#123; role: &#39;pasteAndMatchStyle&#39; &#125;,
        &#123; role: &#39;delete&#39; &#125;,
        &#123; role: &#39;selectAll&#39; &#125;,
        &#123; type: &#39;separator&#39; &#125;,//分割线
        &#123;
          label: &#39;Speech&#39;,
          submenu: [
            &#123; role: &#39;startSpeaking&#39; &#125;,
            &#123; role: &#39;stopSpeaking&#39; &#125;
          ]
        &#125;
      ] : [
        &#123; role: &#39;delete&#39; &#125;,
        &#123; type: &#39;separator&#39; &#125;,//分割线
        &#123; role: &#39;selectAll&#39; &#125;
      ])
    ]
  &#125;,
  // &#123; role: &#39;viewMenu&#39; &#125;
  &#123;
    label: &#39;View&#39;,
    submenu: [
      &#123; role: &#39;reload&#39; &#125;,
      &#123; role: &#39;forceReload&#39; &#125;,
      &#123; role: &#39;toggleDevTools&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;resetZoom&#39; &#125;,
      &#123; role: &#39;zoomIn&#39; &#125;,
      &#123; role: &#39;zoomOut&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;togglefullscreen&#39; &#125;
    ]
  &#125;,
  // &#123; role: &#39;windowMenu&#39; &#125;
  &#123;
    label: &#39;Window&#39;,
    submenu: [
      &#123; role: &#39;minimize&#39; &#125;,
      &#123; role: &#39;zoom&#39; &#125;,
      ...(isMac ? [
        &#123; type: &#39;separator&#39; &#125;,//分割线
        &#123; role: &#39;front&#39; &#125;,
        &#123; type: &#39;separator&#39; &#125;,//分割线
        &#123; role: &#39;window&#39; &#125;
      ] : [
        &#123; role: &#39;close&#39; &#125;
      ])
    ]
  &#125;,
  &#123;
    role: &#39;help&#39;,
    submenu: [
      &#123;
        label: &#39;Learn More&#39;,
        click: async () =&gt; &#123;
          //定义自己的菜单方法
          const &#123; shell &#125; = require(&#39;electron&#39;)
          await shell.openExternal(&#39;https://electronjs.org&#39;)
        &#125;
      &#125;,
      &#123;
        label:&#39;alanmf&#39;,
          click:()=&gt;&#123;console.log(&#39;shift+G&#39;)&#125;,
          accelerator:&#39;shift+G&#39;//定义快捷键
      &#125;
    ]
  &#125;
]

const menu = Menu.buildFromTemplate(template)//一般来说， template是一个options类型的数组，用于构建MenuItem。 使用方法可参考前文。还可以将其他字段附加到template，它们将成为菜单项的属性。
Menu.setApplicationMenu(menu)//在macOS上将 menu设置成应用内菜单 在windows和Linux上，menu 将会被设置成窗口顶部菜单在Windows和Linux中
</code></pre>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125155603331.png"></p>
<p>[Menu菜单文档]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/menu">https://www.electronjs.org/zh/docs/latest/api/menu</a> “<br>[role的属性值]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/menu-item#%E8%A7%92%E8%89%B2">https://www.electronjs.org/zh/docs/latest/api/menu-item#角色</a> “</p>
<h4 id="5-系统托盘（Tray）"><a href="#5-系统托盘（Tray）" class="headerlink" title="5.系统托盘（Tray）"></a>5.系统托盘（Tray）</h4><blockquote>
<p>添加图标和上下文菜单到系统通知区</p>
</blockquote>
<pre><code class="javascript">const &#123; app, Menu, Tray &#125; = require(&#39;electron&#39;)

let tray = null
app.whenReady().then(() =&gt; &#123;
  tray = new Tray(&#39;/path/to/my/icon&#39;) //定义icon的路径
  const contextMenu = Menu.buildFromTemplate([
    &#123; label: &#39;Item1&#39;, type: &#39;radio&#39; &#125;,
    &#123; label: &#39;Item2&#39;, type: &#39;radio&#39; &#125;,
    &#123; label: &#39;Item3&#39;, type: &#39;radio&#39;, checked: true &#125;,
    &#123; label: &#39;Item4&#39;, type: &#39;radio&#39; &#125;
  ])
  tray.setToolTip(&#39;This is my application.&#39;)//设置鼠标指针在托盘图标上悬停时显示的文本
  tray.setContextMenu(contextMenu)//设置上下文菜单到托盘
&#125;)
</code></pre>
<p>其实这个Tray跟Menu是布局差不太多的，所以学习起来也不是很难理解了。具体事件和方法也不是特别多，我们就直接看官方API文档吧！</p>
<p>[Tray文档]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/tray">https://www.electronjs.org/zh/docs/latest/api/tray</a> “</p>
<h4 id="6-触控板（TouchBar）"><a href="#6-触控板（TouchBar）" class="headerlink" title="6.触控板（TouchBar）"></a>6.触控板（TouchBar）</h4><p><strong>注意:</strong> TouchBar API目前为实验性质，可能会更改或删除。</p>
<p>如果官网推荐的TouchBar模拟器下载失败，自己搜索一下即可。（如果下载的打不开，那就在应用程序-&gt;右键显示包内容-&gt;如下）执行就可以了</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125172856290.png"></p>
<pre><code class="javascript">//touchbar.js
const &#123; app, BrowserWindow, TouchBar &#125; = require(&#39;electron&#39;)

const &#123; TouchBarLabel, TouchBarButton, TouchBarSpacer &#125; = TouchBar

let spinning = false

// 类似老虎机的滚轴标签
const reel1 = new TouchBarLabel()
const reel2 = new TouchBarLabel()
const reel3 = new TouchBarLabel()

// 旋转结果标签
const result = new TouchBarLabel()

// 旋转按钮
const spin = new TouchBarButton(&#123;
  label: &#39;🎰 Spin&#39;,
  backgroundColor: &#39;#7851A9&#39;,
  click: () =&gt; &#123;
    // Ignore clicks if already spinning
    if (spinning) &#123;
      return
    &#125;

    spinning = true
    result.label = &#39;&#39;

    let timeout = 10
    const spinLength = 4 * 1000 // 4 seconds
    const startTime = Date.now()

    const spinReels = () =&gt; &#123;
      updateReels()

      if ((Date.now() - startTime) &gt;= spinLength) &#123;
        finishSpin()
      &#125; else &#123;
        // Slow down a bit on each spin
        timeout *= 1.1
        setTimeout(spinReels, timeout)
      &#125;
    &#125;

    spinReels()
  &#125;
&#125;)

const getRandomValue = () =&gt; &#123;
  const values = [&#39;🍒&#39;, &#39;💎&#39;, &#39;7️⃣&#39;, &#39;🍊&#39;, &#39;🔔&#39;, &#39;⭐&#39;, &#39;🍇&#39;, &#39;🍀&#39;]
  return values[Math.floor(Math.random() * values.length)]
&#125;

const updateReels = () =&gt; &#123;
  reel1.label = getRandomValue()
  reel2.label = getRandomValue()
  reel3.label = getRandomValue()
&#125;

const finishSpin = () =&gt; &#123;
  const uniqueValues = new Set([reel1.label, reel2.label, reel3.label]).size
  if (uniqueValues === 1) &#123;
    // All 3 values are the same
    result.label = &#39;💰 Jackpot!&#39;
    result.textColor = &#39;#FDFF00&#39;
  &#125; else if (uniqueValues === 2) &#123;
    // 2个值相同
    result.label = &#39;😍 Winner!&#39;
    result.textColor = &#39;#FDFF00&#39;
  &#125; else &#123;
    // 没有值相同
    result.label = &#39;🙁 Spin Again&#39;
    result.textColor = null
  &#125;
  spinning = false
&#125;

const touchBar = new TouchBar(&#123;
  items: [
    spin,
    new TouchBarSpacer(&#123; size: &#39;large&#39; &#125;),
    reel1,
    new TouchBarSpacer(&#123; size: &#39;small&#39; &#125;),
    reel2,
    new TouchBarSpacer(&#123; size: &#39;small&#39; &#125;),
    reel3,
    new TouchBarSpacer(&#123; size: &#39;large&#39; &#125;),
    result
  ]
&#125;)

let window

app.whenReady().then(() =&gt; &#123;
  window = new BrowserWindow(&#123;
    frame: false,
    titleBarStyle: &#39;hiddenInset&#39;,
    width: 200,
    height: 200,
    backgroundColor: &#39;#000&#39;
  &#125;)
  window.loadURL(&#39;about:blank&#39;)
  window.setTouchBar(touchBar)
&#125;)
</code></pre>
<p>运行命令：</p>
<pre><code class="ini">./node_modules/.bin/electron touchbar.js
</code></pre>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125172447369.png"></p>
<p>[TouchBar文档]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/touch-bar&quot;">https://www.electronjs.org/zh/docs/latest/api/touch-bar&quot;</a></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Electron官方文档]: 	“<a href="https://www.electronjs.org/zh/docs/latest/api/app">https://www.electronjs.org/zh/docs/latest/api/app</a> “<br>[npmjs]: 	“<a href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
]]></content>
      <categories>
        <category>Electron</category>
        <category>Electron-d-2.0</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>docker入门</title>
    <url>/2022/11/11/docker%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="docker入门"><a href="#docker入门" class="headerlink" title="docker入门"></a>docker入门</h1><h3 id="一、docker安装"><a href="#一、docker安装" class="headerlink" title="一、docker安装"></a>一、docker安装</h3><p>目前我们只是基于macos环境下的安装和学习</p>
<p>（很多平台都是windows的）</p>
<h4 id="1-docker下载"><a href="#1-docker下载" class="headerlink" title="1.docker下载"></a>1.docker下载</h4><p>直接去Docker官网去下载对应的版本就可以了（官网地址：<a href="https://dockerdocs.cn/%EF%BC%89">https://dockerdocs.cn/）</a></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109091347433.png"></p>
<p>选择对应inter芯片或者m1和m2芯片的docker版本就可以</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109091446299.png"></p>
<h4 id="2-设置国内镜像源"><a href="#2-设置国内镜像源" class="headerlink" title="2.设置国内镜像源"></a>2.设置国内镜像源</h4><p>在国内使用docker拉取镜像会非常的慢，所以一定得设置国内镜像源。</p>
<p>设置镜像源在设置里的Docker Engine</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109094123087.png"></p>
<p><a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器：点击管理控制台-&gt;登陆账号（淘宝账号）-&gt;右侧镜像工具-&gt;镜像加速器-&gt;拷贝镜像链接</a></p>
<p>网易云加速器：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></p>
<p>百度云加速器：<a href="https://mirror.baidubce.com/">https://mirror.baidubce.com</a></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109095852276.png"></p>
<p>配置完成后，查看是否配置成功</p>
<pre><code class="ini">docker info 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109100105080.png"></p>
<p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 Nginx 服务器</p>
<pre><code class="ini">docker run -d -p 80:80 --name webserver nginx
</code></pre>
<p>服务运行后，可以访问 <a href="http://localhost,如果看到了/">http://localhost，如果看到了</a> “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109101903810.png"></p>
<pre><code class="ini">docker ps -a //查看所有的容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102114729.png"></p>
<pre><code class="ini">docker stop webserver //停止容器服务
docker rm webserver //删除容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102355610.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102417586.png"></p>
<h3 id="二、docker镜像"><a href="#二、docker镜像" class="headerlink" title="二、docker镜像"></a>二、docker镜像</h3><h4 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1.获取镜像"></a>1.获取镜像</h4><p><a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p>
<pre><code class="ini">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] //获取镜像命令格式
docker pull ubuntu:18.04 //具体一点
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103151217.png"></p>
<p>查看下载镜像</p>
<pre><code class="ini">docker images -a //查看所有镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103328637.png"></p>
<p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p>
<pre><code class="ini">docker run -it --rm ubuntu:18.04 bash
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103803885.png"></p>
<p><code>docker run</code> 就是运行容器的命令，具体格式我们会在容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p>
<p>最后我们通过 <code>exit</code> 退出了这个容器。</p>
<h4 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2.列出镜像"></a>2.列出镜像</h4><pre><code class="ini">docker image ls //列出所有下载的镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109104611497.png"></p>
<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<p><code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<pre><code class="ini">docker system df //便捷的查看镜像、容器、数据卷所占用的空间
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109104851278.png" alt="image-20221109104851278"></p>
<pre><code class="ini">docker image ls ubuntu //列出部分镜像
docker image ls ubuntu:18.04 //列出特定的某个镜像，也就是说指定仓库名和标签
</code></pre>
<p>docker image ls<code>还支持强大的过滤器参数</code>–filter<code>，或者简写 </code>-f，之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>nginx</code> 之后建立的镜像，可以用下面的命令：</p>
<pre><code class="ini">docker image ls -f since=nginx
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105424883.png"></p>
<p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可</p>
<pre><code class="ini">docker image ls -q //以特定格式显示
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105634317.png"></p>
<pre><code class="ini">docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot; //直接列出镜像结果，并且只包含镜像ID和仓库名
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105755189.png"></p>
<pre><code class="ini">docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot; //以表格等距显示，并且有标题行，和默认一样，不过自己定义列
</code></pre>
<h4 id="3-删除镜像"><a href="#3-删除镜像" class="headerlink" title="3.删除镜像"></a>3.删除镜像</h4><pre><code class="ini">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] //删除镜像命令格式
</code></pre>
<p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code></p>
<p>我们先列出我们下载的所有镜像</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109110129824.png"></p>
<pre><code class="ini">docker image rm afb //删除redis镜像
docker image ls //查看所有镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109110407331.png"></p>
<p>发现已经删除了指定镜像</p>
<pre><code class="ini">docker image rm $(docker image ls -q redis) //组合命令使用
</code></pre>
<p>充分利用你的想象力和 Linux 命令行的强大</p>
<h3 id="三、docker容器"><a href="#三、docker容器" class="headerlink" title="三、docker容器"></a>三、docker容器</h3><h4 id="1-启动容器"><a href="#1-启动容器" class="headerlink" title="1.启动容器"></a>1.启动容器</h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<pre><code class="ini">docker run ubuntu:18.04 /bin/echo &#39;Hello world&#39; //执行后命令后终止容器
</code></pre>
<pre><code class="ini">docker run -t -i ubuntu:18.04 /bin/bash //保持交互
</code></pre>
<p><code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110081411097.png"></p>
<p>Docker run创建容器时，docker的标准操作</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 registry下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<pre><code class="ini">docker start 9a115164bf87//启动一个终止（exited）的容器
</code></pre>
<pre><code class="ini">docker ps -a//查看所有容器信息
docker logs 9a115164bf87//获取容器输出信息
</code></pre>
<h4 id="2-终止容器"><a href="#2-终止容器" class="headerlink" title="2.终止容器"></a>2.终止容器</h4><pre><code class="ini">docker stop (ID) //终止容器
docker ps //查看启动容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110083759963.png"></p>
<h4 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3.进入容器"></a>3.进入容器</h4><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台</p>
<p><code>docker attach</code> 命令或 <code>docker exec</code> 命令都可以进入容器，推荐大家使用 <code>docker exec</code> 命令</p>
<pre><code class="ini">docker attach (ID) //会导致容器的终止
</code></pre>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符</p>
<pre><code class="ini">docker exec -i 4e56f70383c9 /bin/bash 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110084917152.png"></p>
<pre><code class="ini">docker exec -it 4e56f70383c9 /bin/bash //不会导致容器的终止
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110085014483.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110085250397.png"></p>
<pre><code class="ini">docker exec --help //查看更多参数
</code></pre>
<h4 id="4-导入和导出"><a href="#4-导入和导出" class="headerlink" title="4.导入和导出"></a>4.导入和导出</h4><pre><code class="ini">docker export 4e56f70383c9 &gt; ubuntu.tar //导出容器快照到本地文件
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110090757653.png"></p>
<pre><code class="ini">cat nginx.tar | docker import - test/nginx //从容器快照文件中再导入为镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110092840790.png"></p>
<p>用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<h4 id="5-删除容器"><a href="#5-删除容器" class="headerlink" title="5.删除容器"></a>5.删除容器</h4><pre><code class="ini">docker rm (ID or Name) //删除一个处于终止状态的容器
</code></pre>
<p>删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器</p>
<pre><code class="ini">sudo docker rm $(sudo docker ps -a -q) //删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了）
</code></pre>
<h3 id="四、访问仓库"><a href="#四、访问仓库" class="headerlink" title="四、访问仓库"></a>四、访问仓库</h3><h4 id="1-Docker-Hub"><a href="#1-Docker-Hub" class="headerlink" title="1.Docker Hub"></a>1.Docker Hub</h4><p>Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<p>注册一个docker账号</p>
<blockquote>
<p>在 <a href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号</p>
</blockquote>
<p>登陆</p>
<blockquote>
<p>1.可以在docker App上登陆dockr账号（会跳转到 <a href="https://hub.docker.com/">https://hub.docker.com</a> ）</p>
<p>2.通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <code>docker logout</code> 退出登录。</p>
</blockquote>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110094750263.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110094815601.png"></p>
<p>拉取镜像</p>
<blockquote>
<p>可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地</p>
</blockquote>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110095756575.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110095822481.png"></p>
<p>推送镜像</p>
<blockquote>
<p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub</p>
</blockquote>
<pre><code class="ini">docker tag ubuntu:18.04 username/ubuntu:18.04 //username 请替换为你的 Docker 账号用户名
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110100404351.png"></p>
<p>自动化构建</p>
<p>自动构建（<code>Automated Builds</code>）可以自动触发构建镜像，方便升级镜像。</p>
<p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p>
<p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a href="https://github.com/">GitHub</a> 或 <a href="https://bitbucket.org/">BitBucket</a>）上的项目，一旦项目发生新的提交 （<code>commit</code>）或者创建了新的标签（<code>tag</code>），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动构建，包括如下的步骤：</p>
<p>- </p>
<p>  登录 Docker Hub；</p>
<p>- </p>
<p>  在 Docker Hub 点击右上角头像，在账号设置（<code>Account Settings</code>）中关联（<code>Linked Accounts</code>）目标网站；</p>
<p>- </p>
<p>  在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</p>
<p>- </p>
<p>  选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</p>
<p>- </p>
<p>  指定 <code>Dockerfile</code> 的位置，并保存。</p>
<p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p>
<p>（‼️这个需要付钱）</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110101243394.png"></p>
<h4 id="2-私有仓库"><a href="#2-私有仓库" class="headerlink" title="2.私有仓库"></a>2.私有仓库</h4><p>安装运行 docker-registry</p>
<pre><code class="ini">docker run -d -p 5000:5000 --restart=always --name registry registry //使用官方 registry 镜像来运行
</code></pre>
<p>如果报错端口不可用</p>
<pre><code class="ini">docker run -d -p 8080:8080 --restart=always --name registry registry //删除原来容器，重新创建
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110104412354.png"></p>
<p>在私有仓库上传、搜索、下载镜像</p>
<pre><code class="ini">docker tag ubuntu:latest alan0924/ubuntu:latest //将 ubuntu:latest 这个镜像标记为 alan0924/ubuntu:latest
docker image ls //查看所有镜像
docker push alan0924/ubuntu:latest //上传私有仓库
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110105039054.png"></p>
<p>删除已有镜像，再尝试从私有仓库中下载这个镜像</p>
<pre><code class="ini">docker image rm alan0924/ubuntu:latest
docker image ls
docker pull  alan0924/ubuntu:latest
docker image ls 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110110006213.png"></p>
<p>这是我们docker的私有仓库</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110111655879.png"></p>
<h3 id="五、数据管理"><a href="#五、数据管理" class="headerlink" title="五、数据管理"></a>五、数据管理</h3><h4 id="1-数据卷"><a href="#1-数据卷" class="headerlink" title="1.数据卷"></a>1.数据卷</h4><pre><code class="ini">docker volume create my-vol //创建一个数据卷
docker volume ls //查看所有的数据卷
docker volume inspect my-vol //主机里使用以下命令可以查看指定 数据卷 的信息
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110163653187.png"></p>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<pre><code class="ini">//启动一个挂载数据卷的容器
docker run -d -P \
    --name web \
    --mount source=my-vol,target=/usr/share/nginx/html \
    nginx:alpine
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164146345.png"></p>
<pre><code class="ini">docker inspect web //查看数据卷的具体信息
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164302235.png"></p>
<pre><code class="ini">docker volume rm my-vol //删除数据卷
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164601907.png"></p>
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令</p>
<p>无主的数据卷可能会占据很多空间,要清理请使用以下命令</p>
<pre><code class="ini">docker volume prune
</code></pre>
<h3 id="六、访问网络"><a href="#六、访问网络" class="headerlink" title="六、访问网络"></a>六、访问网络</h3><h4 id="1-外部访问容器"><a href="#1-外部访问容器" class="headerlink" title="1.外部访问容器"></a>1.外部访问容器</h4><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker ps</code> 可以看到，本地主机的 55000 被映射到了容器的 80 端口。此时访问本机的 55000 端口即可访问容器内 NGINX 默认页面。</p>
<pre><code class="ini">docker run -d -P nginx:alpine // 
docker logs 75bbd0b01745 //查看日志
</code></pre>
<p>-p<code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。</code> </p>
<p> <code>支持的格式有 </code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111102609943.png"></p>
<p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p>
<pre><code class="ini">docker run -d -p 80:80 nginx:alpine //映射所有接口地址,此时默认会绑定本地所有接口上的所有地址。
</code></pre>
<p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<pre><code class="ini">docker run -d -p 127.0.0.1:80:80 nginx:alpine //映射到指定地址的指定端口,
</code></pre>
<p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<pre><code class="ini">docker run -d -p 127.0.0.1::80 nginx:alpine //映射到指定地址的任意端口
</code></pre>
<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<pre><code class="ini">docker run -d -p 127.0.0.1:80:80/udp nginx:alpine 
</code></pre>
<p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<pre><code class="ini">docker port 75b 80 //查看映射端口配置
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111103203892.png"></p>
<ul>
<li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li>
<li><code>-p</code> 标记可以多次使用来绑定多个端口</li>
</ul>
<pre><code class="ini">docker run -d \
    -p 80:80 \
    -p 443:443 \
    nginx:alpine
</code></pre>
<h4 id="2-容器互联"><a href="#2-容器互联" class="headerlink" title="2.容器互联"></a>2.容器互联</h4><p>新建网络</p>
<pre><code class="ini">docker network create -d bridge my-net //创建一个新的 Docker 网络
</code></pre>
<p>连接容器</p>
<pre><code class="ini">docker run -it --rm --name busybox1 --network my-net busybox sh //运行一个容器并连接到新建的 my-net 网络
</code></pre>
<pre><code class="ini">docker run -it --rm --name busybox2 --network my-net busybox sh //打开新的终端，再运行一个容器并加入到 my-net 网络
</code></pre>
<pre><code class="ini">docker ps //再打开一个新的终端查看容器信息
</code></pre>
<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<pre><code class="ini">/ # ping busybox2
PING busybox2 (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms
64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms
</code></pre>
<p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code></p>
<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到</p>
<pre><code class="ini">/ # ping busybox1
PING busybox1 (172.19.0.2): 56 data bytes
64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms
64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111104242497.png"></p>
<p><code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<h3 id="七、Docker-Compose"><a href="#七、Docker-Compose" class="headerlink" title="七、Docker Compose"></a>七、Docker Compose</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p><code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用</p>
<pre><code class="ini">docker-compose --version
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111110532499.png"></p>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><ul>
<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</li>
</ul>
<p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>
<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p>
<pre><code class="python">//app.py
from flask import Flask
from redis import Redis

app = Flask(__name__)
redis = Redis(host=&#39;redis&#39;, port=6379)

@app.route(&#39;/&#39;)
def hello():
    count = redis.incr(&#39;hits&#39;)
    return &#39;Hello World! 该页面已被访问 &#123;&#125; 次。\n&#39;.format(count)

if __name__ == &quot;__main__&quot;:
    app.run(host=&quot;0.0.0.0&quot;, debug=True)
</code></pre>
<pre><code class="javascript">//docker-compose.yml
version: &#39;3&#39;
services:

  web:
    build: .
    ports:
     - &quot;5500:5500&quot;

  redis:
    image: &quot;redis:alpine&quot;
</code></pre>
<pre><code class="javascript">//Dockerfile
FROM python:3.6-alpine
ADD . /code
WORKDIR /code
RUN pip install redis flask
CMD [&quot;python&quot;, &quot;app.py&quot;]
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111112418983.png"></p>
<pre><code class="ini">docker-compose up //运行 compose 项目
</code></pre>
<p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>
<h4 id="3-命令说明"><a href="#3-命令说明" class="headerlink" title="3.命令说明"></a>3.命令说明</h4><p>命令对象与格式</p>
<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<p>docker-compose [-f&#x3D;<arg>…] [options] [COMMAND] [ARGS…]</p>
<p>命令选项</p>
<p>- </p>
<p>  <code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</p>
<p>- </p>
<p>  <code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</p>
<p>- </p>
<p>  <code>--verbose</code> 输出更多调试信息。</p>
<p>- </p>
<p>  <code>-v, --version</code> 打印版本并退出。</p>
<p>命令使用说明</p>
<p><code>build</code></p>
<p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>
<p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p>
<p>选项包括：</p>
<ul>
<li><code>--force-rm</code> 删除构建过程中的临时容器。</li>
<li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li>
<li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li>
</ul>
<p><code>config</code></p>
<p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<p><code>down</code></p>
<p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<p><code>exec</code></p>
<p>进入指定的容器。</p>
<p><code>help</code></p>
<p>获得一个命令的帮助。</p>
<p><code>images</code></p>
<p>列出 Compose 文件中包含的镜像。</p>
<p><code>kill</code></p>
<p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p>
<p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p>
<pre><code class="ini">docker-compose kill -s SIGINT
</code></pre>
<p><code>logs</code></p>
<p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p>
<p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p>
<p>该命令在调试问题的时候十分有用。</p>
<p><code>pause</code></p>
<p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p>
<p>暂停一个服务容器。</p>
<p><code>port</code></p>
<p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p>
<p>打印某个容器端口所映射的公共端口。</p>
<p>选项：</p>
<ul>
<li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li>
<li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li>
</ul>
<p><code>ps</code></p>
<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<p><code>pull</code></p>
<p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p>
<p>拉取服务依赖的镜像。</p>
<p>选项：</p>
<ul>
<li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li>
</ul>
<p><code>push</code></p>
<p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<p><code>restart</code></p>
<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<p><code>rm</code></p>
<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<p><code>run</code></p>
<p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p>
<p>在指定服务上执行一个命令。</p>
<p>例如：</p>
<pre><code class="ini">docker-compose run ubuntu ping docker.com
</code></pre>
<p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<ul>
<li>给定命令将会覆盖原有的自动运行命令；</li>
<li>不会自动创建端口，以避免冲突。</li>
</ul>
<p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p>
<pre><code class="ini">docker-compose run --no-deps web python manage.py shell
</code></pre>
<p>将不会启动 web 容器所关联的其它容器。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 后台运行容器。</li>
<li><code>--name NAME</code> 为容器指定一个名字。</li>
<li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li>
<li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li>
<li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li>
<li><code>--no-deps</code> 不自动启动关联的服务容器。</li>
<li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li>
<li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li>
<li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li>
<li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li>
</ul>
<p><code>scale</code></p>
<p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p>
<p>设置指定服务运行的容器个数。</p>
<p>通过 <code>service=num</code> 的参数来设置数量。例如：</p>
<pre><code class="ini">docker-compose scale web=3 db=2
</code></pre>
<p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p>
<p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>start</code></p>
<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<p><code>stop</code></p>
<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>top</code></p>
<p>查看各个服务容器内运行的进程。</p>
<p><code>unpause</code></p>
<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<p><code>up</code></p>
<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 在后台运行服务容器。</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像。</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>version</code></p>
<p>格式为 <code>docker-compose version</code>。</p>
<p>打印版本信息。</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>docker入门</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>threejs-d-4.0</title>
    <url>/2022/12/01/threejs-d-4-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="threejs-d-4-0"><a href="#threejs-d-4-0" class="headerlink" title="threejs-d-4.0"></a>threejs-d-4.0</h1><h3 id="一、基础网格材质"><a href="#一、基础网格材质" class="headerlink" title="一、基础网格材质"></a>一、基础网格材质</h3><blockquote>
<p>一个以简单着色（平面或线框）方式来绘制几何体的材质。</p>
<p>这种材质不受光照的影响。</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();//初始化一个加载器
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) //加载一张纹理贴图

const geometry = new THREE.BoxGeometry( 1, 1, 1 );//创建一个立方体
const material = new THREE.MeshBasicMaterial( &#123; 
    color: &#39;#ffffff&#39;,//给立方体添加颜色
    map:mbColortexture//加载贴图
 &#125; );
const cube = new THREE.Mesh( geometry, material );
console.log(cube)
</code></pre>
<pre><code class="css">.alphaMap : Texture 
#alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。

仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道， 因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 Luminance-only以及luminance/alpha纹理也仍然有效。

.aoMap : Texture
该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。

.aoMapIntensity : Float
环境遮挡效果的强度。默认值为1。零是不遮挡效果。

.color : Color
材质的颜色(Color)，默认值为白色 (0xffffff)。

.combine : Integer
如何将表面颜色的结果与环境贴图（如果有）结合起来。

选项为THREE.MultiplyOperation（默认值），THREE.MixOperation， THREE.AddOperation。如果选择多个，则使用.reflectivity在两种颜色之间进行混合。

.envMap : Texture
环境贴图。默认值为null。

.fog : Boolean
材质是否受雾影响。默认为true。

.lightMap : Texture
光照贴图。默认值为null。lightMap需要第二组UV。

.lightMapIntensity : Float
烘焙光的强度。默认值为1。

.map : Texture
颜色贴图。可以选择包括一个alpha通道，通常与.transparent 或.alphaTest。默认为null。

.reflectivity : Float
环境贴图对表面的影响程度; 见.combine。默认值为1，有效范围介于0（无反射）和1（完全反射）之间。

.refractionRatio : Float
空气的折射率（IOR）（约为1）除以材质的折射率。它与环境映射模式THREE.CubeRefractionMapping 和THREE.EquirectangularRefractionMapping一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过1。默认值为0.98。

.specularMap : Texture
材质使用的高光贴图。默认值为null。

.wireframe : Boolean
将几何体渲染为线框。默认值为false（即渲染为平面多边形）。

.wireframeLinecap : String
定义线两端的外观。可选值为 &#39;butt&#39;，&#39;round&#39; 和 &#39;square&#39;。默认为&#39;round&#39;。

该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。

.wireframeLinejoin : String
定义线连接节点的样式。可选值为 &#39;round&#39;, &#39;bevel&#39; 和 &#39;miter&#39;。默认值为 &#39;round&#39;。

该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。

.wireframeLinewidth : Float
控制线框宽度。默认值为1。
</code></pre>
<p>效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201090956497.png"></p>
<h3 id="二、纹理常用属性"><a href="#二、纹理常用属性" class="headerlink" title="二、纹理常用属性"></a>二、纹理常用属性</h3><pre><code class="javascript">const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) 
console.log(mbColortexture)
</code></pre>
<blockquote>
<p>我们可以看到mbColortexture的属性</p>
</blockquote>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201091841323.png"></p>
<h4 id="1-纹理偏移"><a href="#1-纹理偏移" class="headerlink" title="1.纹理偏移"></a>1.纹理偏移</h4><pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) 
mbColortexture.offset.set(0.2,0.2)//默认是x,y,范围是0.0 to 1.0
</code></pre>
<p>效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201092855963.png"></p>
<h4 id="2-纹理旋转"><a href="#2-纹理旋转" class="headerlink" title="2.纹理旋转"></a>2.纹理旋转</h4><pre><code class="javascript">const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) 
mbColortexture.center.set(0.5,0.5)//设置中心点，(0.5, 0.5)对应纹理的正中心。默认值为(0,0)，即左下角
mbColortexture.rotation = Math.PI / 4 //纹理将围绕中心点旋转多少度，单位为弧度（rad）。正值为逆时针方向旋转，默认值为0。
</code></pre>
<p>效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201093713067.png"></p>
<h4 id="3-纹理重复"><a href="#3-纹理重复" class="headerlink" title="3.纹理重复"></a>3.纹理重复</h4><blockquote>
<p>当我们旋转或者改变了uv属性，那么可能就出现了上面那种情况，是因为</p>
<p>.wrapS : number</p>
<p>这个值定义了纹理贴图在水平方向上将如何包裹，在UV映射中对应于<strong>U</strong>。<br>默认值是THREE.ClampToEdgeWrapping，即纹理边缘将被推到外部边缘的纹素。</p>
</blockquote>
<p>我们需要修改属性，使其达到合适的uv</p>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping//使用RepeatWrapping，纹理将简单地重复到无穷大。
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
mbColortexture.rotation = Math.PI / 4

//使用MirroredRepeatWrapping， 纹理将重复到无穷大，在每次重复时将进行镜像。
</code></pre>
<p>wrapS和wrapT可以设置相同的属性</p>
<p>.wrapS : number</p>
<p>这个值定义了纹理贴图在水平方向上将如何包裹，在UV映射中对应于<strong>U</strong>。<br>默认值是THREE.ClampToEdgeWrapping，即纹理边缘将被推到外部边缘的纹素。 其它的两个选项分别是THREE.RepeatWrapping和THREE.MirroredRepeatWrapping。 请参阅texture constants来了解详细信息。</p>
<p>.wrapT : number</p>
<p>这个值定义了纹理贴图在垂直方向上将如何包裹，在UV映射中对应于<strong>V</strong>。<br>可以使用与 .wrapS : number相同的选项。</p>
<p>请注意：纹理中图像的平铺，仅有当图像大小（以像素为单位）为2的幂（2、4、8、16、32、64、128、256、512、1024、2048、……）时才起作用。 宽度、高度无需相等，但每个维度的长度必须都是2的幂。 这是WebGL中的限制，不是由three.js所限制的。</p>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.repeat.set(1,1)//设置重复的次数
mbColortexture.center.set(0.5,0.5)
</code></pre>
<h3 id="三、纹理算法显示"><a href="#三、纹理算法显示" class="headerlink" title="三、纹理算法显示"></a>三、纹理算法显示</h3><blockquote>
<p>这里主要是两个属性.magFilter和.minFilter</p>
</blockquote>
<h4 id="magFilter-number"><a href="#magFilter-number" class="headerlink" title=".magFilter : number"></a>.magFilter : number</h4><p>当一个纹素覆盖大于一个像素时，贴图将如何采样。默认值为THREE.LinearFilter， 它将获取四个最接近的纹素，并在他们之间进行双线性插值。 另一个选项是THREE.NearestFilter，它将使用最接近的纹素的值。<br>请参阅texture constants页面来了解详细信息。</p>
<h4 id="minFilter-number"><a href="#minFilter-number" class="headerlink" title=".minFilter : number"></a>.minFilter : number</h4><p>当一个纹素覆盖小于一个像素时，贴图将如何采样。默认值为THREE.LinearMipmapLinearFilter， 它将使用mipmapping以及三次线性滤镜。</p>
<p>magFilter为THREE.NearestFilter效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201100523546.png"></p>
<p>magFilter为THREE.LinearFilter时效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201100924472.png"></p>
<p>.minFilter 的一些属性值</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201102245156.png"></p>
<h3 id="四、透明材质和纹理"><a href="#四、透明材质和纹理" class="headerlink" title="四、透明材质和纹理"></a>四、透明材质和纹理</h3><blockquote>
<p>alphaMap和opacity</p>
</blockquote>
<pre><code class="javascript">//main.js
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/AHS_AlphaPack_V3_ (1).png&#39;) //加载颜色贴图
const mbAlphatexture = textureLoader.load(&#39;./texture/AHS_AlphaPack_V3_ (1).jpg&#39;) //加载Alpha贴图
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    alphaMap:mbAlphatexture,//alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。
    transparent:true //定义此材质是否透明。这对渲染有影响，因为透明对象需要特殊处 理，并在非透明对象之后渲染。设置为true时，通过设置材质的opacity属性来控制材质透明的程度。默认值为false。
    opacity:0.5 //设置材质的opacity属性来控制材质透明的程度
 &#125; );
const cube = new THREE.Mesh( geometry, material ); 
scene.add( cube );
</code></pre>
<p>透明纹理效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201105806475.png"></p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201110104958.png"></p>
<h3 id="五、环境遮挡贴图与强度"><a href="#五、环境遮挡贴图与强度" class="headerlink" title="五、环境遮挡贴图与强度"></a>五、环境遮挡贴图与强度</h3><blockquote>
<h3 id="aoMap-Texture"><a href="#aoMap-Texture" class="headerlink" title=".aoMap : Texture"></a>.aoMap : Texture</h3><p>该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。</p>
<h3 id="aoMapIntensity-Float"><a href="#aoMapIntensity-Float" class="headerlink" title=".aoMapIntensity : Float"></a>.aoMapIntensity : Float</h3><p> 环境遮挡效果的强度。默认值为1。零是不遮挡效果。</p>
</blockquote>
<pre><code class="javascript">const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_height.jpg&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    aoMap:mbHeighttexture,
    aoMapIntensity:1//范围 0-1
 &#125; );
const cube = new THREE.Mesh( geometry, material );
console.log(cube)
</code></pre>
<p>添加环境遮挡贴图前：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201111821273.png"></p>
<p>添加环境遮挡贴图后：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201111921492.png"></p>
<h3 id="六、PBR"><a href="#六、PBR" class="headerlink" title="六、PBR"></a>六、PBR</h3><p>PBR是Physically-Based Rendering（基于物理的渲染)的简称，这个词的字面意思并不容易弄懂，到底什么是PBR呢？</p>
<p>让PBR材质流区别与其他手法的重要一点是光对表面造成的细腻效果，它有着更为准确的模拟，而且同时不失一定的艺术感。让我们从最基础的概念说起：</p>
<h4 id="1-漫射与反射"><a href="#1-漫射与反射" class="headerlink" title="1.漫射与反射"></a>1.漫射与反射</h4><p>这是两个材质制作里最基本的概念，是光与表面最基础的相互作用，很多人都知道这一点，但不一定知道在物理层面上到底是什么。</p>
<p>当一束光照射到一个表面，有些光会被反射，即从物体表面沿着法线反方向弹射回去。这一过程和一个球打在了墙上或地上反弹回去差不多。在一个光滑的表面上，这会产生一种镜面效果。</p>
<p>也不是所有的光都被物体表面反弹回去，有些会被物体表面吸收，或者散射进了物体内部，有些散射进去的光又会从后面再次穿出去，再次被眼睛或相机捕捉到。</p>
<p><img src="/2022/12/01/threejs-d-4-0/efab4-6369032157239337638822742.png"></p>
<p>- </p>
<p>光的这种被物体表面吸收和散射因光的不同波长而不同，也即颜色的不同而不同。由于这种散射极为不规则，所以看起来给人感觉是来自各个方向。这和镜面效果很不同！要在材质里模拟这种效果，可以通过定义一个漫射颜色来做到。</p>
<h4 id="2-半透与透明"><a href="#2-半透与透明" class="headerlink" title="2.半透与透明"></a>2.半透与透明</h4><p>但有些漫射很复杂，比如皮肤和蜡烛的表面，简单的定义一个漫射颜色是不够的，还需要考虑材质的厚度和形状。如果物体本身很薄，那么就应该能看到透明效果。这时就需要特殊材质才能模拟了。</p>
<p>能量守恒（一）<br>通过以上对反射和漫射的描述，我们不难得出一个结论：漫射和反射是互斥的。为了能看到漫射颜色，光必须先穿过表面，或者说没能被表面反射回去。那么根据能量守恒法则，就出现这样的情况：越是反射强烈的表面，其漫射越是弱（暗），因为没有那么多的光穿过去，大部分都被反射回去了。一个表面很明亮的物体它不可能有很强的反射。</p>
<p><img src="/2022/12/01/threejs-d-4-0/bf8d3-6369032158373459631393348.png"></p>
<p>- </p>
<p>能量守恒是PBR材质流的基础，要做出自然逼真的材质来，不可以无视这个规则。</p>
<h4 id="3-金属"><a href="#3-金属" class="headerlink" title="3.金属"></a>3.金属</h4><p>导电体，比如金属材质要特别单独拿出来讲一下。因为：<br>首先，它们比绝缘体的表面更加具有反射效果，它们的反射率高达60-90%，而绝缘体只有0-20%。高反射率让光无法穿过表面进入物体内部，从而产生了闪光的质感。</p>
<p>其次，金属的反射效果还会随着光谱而不同，这就是说，金属的反射是带有颜色的，而且很不均匀，比如金，铜等。而绝缘体的反射是无色的。</p>
<p>最后，穿过导电体表面的光最后大部分也会被吸收而不是被散射出去，这既是说，理论上导电体是没有漫射颜色的。</p>
<h4 id="4-菲涅尔"><a href="#4-菲涅尔" class="headerlink" title="4.菲涅尔"></a>4.菲涅尔</h4><p>奥古斯汀-让·菲涅尔，这个人的名字是绝对不可能被遗忘的，因为他的名字和反射现象结合到了一起去，不说他的名字谈反射几乎不可能。</p>
<p>在CG里，菲涅尔代表了反射效果因观察角度的不同而不同，也即是物体边缘的反射效果会更加明亮。PBR材质流在这个效果上有几个特色：</p>
<p>首先，对于所有的材质来说，反射效果在接近0度角时最明显，就像镜面反射一样，不管是什么材质都是如此。只要足够光滑能产生反射，那么一定能在某一个角度观察时，看到完美的镜面反射效果！这听起来有点玄乎，但这就是物理。</p>
<p>其次，这种反射效果的变化随着材质的不同而有所不同，如下图：</p>
<p><img src="/2022/12/01/threejs-d-4-0/27de3-6369032159485741581962421.png"></p>
<p>- </p>
<p>- </p>
<p>- </p>
<p>这个图的意思是在说：在模拟真实材质时，反射效果必须要稍微有些收敛，至少要在需要弱的地方弱下来。这并不难做到，而且现在的材质系统都能自带这种菲尼尔效果了。PBR材质流是可以带出些艺术处理的，在做出基础反射效果后，你可以再添加一些完全反射的小局部做点缀。</p>
<h4 id="5-微表面"><a href="#5-微表面" class="headerlink" title="5.微表面"></a>5.微表面</h4><p>上面都是基于物体表面说的东西，或者说是物体能被渲染出来的效果。但物体表面并非完美无瑕，小凹痕，裂纹，凹凸，这些无法被眼睛看到，也无法在法线贴图里被体现出来的微小细节，确实左右漫射和反射效果的真正因素。</p>
<p><img src="/2022/12/01/threejs-d-4-0/923ff-6369032160821103922455437.png"></p>
<p>- </p>
<p>- </p>
<p>- </p>
<p>上图中，平行照射到物体表面的三道光线被反射到不同的方向上去了，因为它们所照到的物体表面具有不同的方向，使得这种反射的角度变得不可预测，这就产生了模糊反射效果。</p>
<p>但要从物理级别上模拟出这种无规则的反射需要大量的内存和计算量，在CG里只能大概模拟一个整体效果，我们一般叫反射光泽度或反射模糊度。</p>
<p>这是材质制作里一个重要的部分，因为真实世界里到处充满了这种模糊反射效果。</p>
<p>能量守恒（二）<br>现在渲染器都有了这种虚拟的模糊反射的模拟，正确的参数能让效果更加逼真，比如粗糙的表面会产生更大更柔和的高光区，请看下图：</p>
<p><img src="/2022/12/01/threejs-d-4-0/70f54-6369032161855385747450216.png" alt="05.png"></p>
<p>- </p>
<p>- </p>
<p>- </p>
<p>图中的小球具有相同的反射强度，但因为不同的反射模糊度而表现出不同的质感，高光随着光滑度越来越清晰明亮。这又是能量守恒的法则体现之一。</p>
<p>微表面反射也同样遵守菲涅尔效果</p>
<p><img src="/2022/12/01/threejs-d-4-0/4232b-6369032162994187744034914.png"></p>
<p>- </p>
<p>- </p>
<p>- </p>
<p>PBR材质似乎在一夜之间改变了人们对于引擎实时渲染画面的理解。在游戏中我们也能够体验到锈蚀的金属，厚重的皮革，精细的纹理，更加真实的世界从此展现在眼前。从此，PBR材质成为了“次时代”游戏必备的标准。</p>
<h3 id="七、标准网格材质"><a href="#七、标准网格材质" class="headerlink" title="七、标准网格材质"></a>七、标准网格材质</h3><blockquote>
<p>一种基于物理的标准材质</p>
<p>基于物理的渲染（PBR）这种方法与旧方法的不同之处在于，不使用近似值来表示光与表面的相互作用，而是使用物理上正确的模型。 我们的想法是，不是在特定照明下调整材质以使其看起来很好，而是可以创建一种材质，能够“正确”地应对所有光照场景。</p>
</blockquote>
<p>我们PBR材质是和光相辅相成的</p>
<h4 id="1-PointLight-color-Integer-intensity-Float-distance-Number-decay-Float"><a href="#1-PointLight-color-Integer-intensity-Float-distance-Number-decay-Float" class="headerlink" title="1.PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )"></a>1.PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )</h4><p>color - (可选参数)) 十六进制光照颜色。 缺省值 0xffffff (白色)。<br>intensity - (可选参数) 光照强度。 缺省值 1。<br>distance - 这个距离表示从光源到光照强度为0的位置。 当设置为0时，光永远不会消失(距离无穷大)。缺省值 0.<br>decay - 沿着光照距离的衰退量。缺省值 2</p>
<h4 id="2-AmbientLight-color-Integer-intensity-Float"><a href="#2-AmbientLight-color-Integer-intensity-Float" class="headerlink" title="2.AmbientLight( color : Integer, intensity : Float )"></a>2.AmbientLight( color : Integer, intensity : Float )</h4><p>color - (参数可选）颜色的rgb数值。缺省值为 0xffffff。<br>intensity - (参数可选)光照的强度。缺省值为 1。</p>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_height.jpg&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
//和基础网格材质一样具备相同属性
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    aoMap:mbHeighttexture,
    aoMapIntensity:1
 &#125; );
const cube = new THREE.Mesh( geometry, material );
console.log(cube)
scene.add( cube );

// const light = new THREE.AmbientLight( 0xffffff); // 环境光，相当于各个方向射过来的光（没有投影）
// scene.add( light );

const light = new THREE.PointLight( 0xffffff, 5, 100 );//点光源，相当于灯泡，相对灯光的物体背面是没光的
light.position.set( 10, 10, 10 );
scene.add( light );
</code></pre>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201154732277.png"></p>
<p>参考链接：</p>
<p>[什么是PBR]: 	“<a href="https://tao0.date/2021/06/shenmeshipbrcaizhi/">https://tao0.date/2021/06/shenmeshipbrcaizhi/</a> “</p>
]]></content>
      <categories>
        <category>Web3D</category>
        <category>Three.js</category>
        <category>threejs-d-4.0</category>
      </categories>
      <tags>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title>threejs-d-5.0</title>
    <url>/2022/12/02/threejs-d-5-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="threejs-d-5-0"><a href="#threejs-d-5-0" class="headerlink" title="threejs-d-5.0"></a>threejs-d-5.0</h1><h3 id="一、置换与置换贴图"><a href="#一、置换与置换贴图" class="headerlink" title="一、置换与置换贴图"></a>一、置换与置换贴图</h3><blockquote>
<h3 id="displacementMap-Texture"><a href="#displacementMap-Texture" class="headerlink" title=".displacementMap : Texture"></a>.displacementMap : Texture</h3><p>位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象， 以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。</p>
<h3 id="displacementScale-Float"><a href="#displacementScale-Float" class="headerlink" title=".displacementScale : Float"></a>.displacementScale : Float</h3><p>位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为1。</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_height.jpg&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.BoxGeometry( 1, 1, 1,100,100,100 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p>置换效果图：</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202081128766.png"></p>
<h3 id="二、粗糙度与粗糙度贴图"><a href="#二、粗糙度与粗糙度贴图" class="headerlink" title="二、粗糙度与粗糙度贴图"></a>二、粗糙度与粗糙度贴图</h3><blockquote>
<h3 id="roughness-Float"><a href="#roughness-Float" class="headerlink" title=".roughness : Float"></a>.roughness : Float</h3><p>材质的粗糙程度。0.0表示平滑的镜面反射，1.0表示完全漫反射。默认值为1.0。如果还提供roughnessMap，则两个值相乘。</p>
<h3 id="roughnessMap-Texture"><a href="#roughnessMap-Texture" class="headerlink" title=".roughnessMap : Texture"></a>.roughnessMap : Texture</h3><p>该纹理的绿色通道用于改变材质的粗糙度。</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_height.jpg&#39;) 
const mbRoughnesstexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_roughness.jpg&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.BoxGeometry( 1, 1, 1,50,50,50 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05,
    // roughness:0,
    roughnessMap:mbRoughnesstexture

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p>粗糙度为0效果：</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202082244999.png"></p>
<p>加载粗糙度纹理：</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202082433121.png"></p>
<h3 id="三、金属度与金属贴图"><a href="#三、金属度与金属贴图" class="headerlink" title="三、金属度与金属贴图"></a>三、金属度与金属贴图</h3><blockquote>
<h3 id="metalness-Float"><a href="#metalness-Float" class="headerlink" title=".metalness : Float"></a>.metalness : Float</h3><p>材质与金属的相似度。非金属材质，如木材或石材，使用0.0，金属使用1.0，通常没有中间值。 默认值为0.0。0.0到1.0之间的值可用于生锈金属的外观。如果还提供了metalnessMap，则两个值相乘。</p>
<h3 id="metalnessMap-Texture"><a href="#metalnessMap-Texture" class="headerlink" title=".metalnessMap : Texture"></a>.metalnessMap : Texture</h3><p>该纹理的蓝色通道用于改变材质的金属度。</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_height.jpg&#39;) 
const mbRoughnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_roughness.jpg&#39;) 
const mbMetalnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_metalness.jpg&#39;) 

mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.PlaneGeometry( 1, 1,100,100 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05,
    roughness:0.2,
    roughnessMap:mbRoughnesstexture,
    metalnessMap:mbMetalnesstexture,
    metalness:0.3

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p>添加金属和金属贴图前：</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202091721564.png"></p>
<p>添加金属和金属贴图后： </p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202091744042.png"></p>
<h3 id="四、法线和法线贴图"><a href="#四、法线和法线贴图" class="headerlink" title="四、法线和法线贴图"></a>四、法线和法线贴图</h3><blockquote>
<h3 id="normalMap-Texture"><a href="#normalMap-Texture" class="headerlink" title=".normalMap : Texture"></a>.normalMap : Texture</h3><p>用于创建法线贴图的纹理。RGB值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。 In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness.</p>
<h3 id="normalMapType-Integer"><a href="#normalMapType-Integer" class="headerlink" title=".normalMapType : Integer"></a>.normalMapType : Integer</h3><p>法线贴图的类型。</p>
<p>选项为THREE.TangentSpaceNormalMap（默认）和THREE.ObjectSpaceNormalMap。</p>
<h3 id="normalScale-Vector2"><a href="#normalScale-Vector2" class="headerlink" title=".normalScale : Vector2"></a>.normalScale : Vector2</h3><p>法线贴图对材质的影响程度。典型范围是0-1。默认值是Vector2设置为（1,1）</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_height.jpg&#39;) 
const mbRoughnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_roughness.jpg&#39;) 
const mbMetalnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_metalness.jpg&#39;) 
const mbNormaltexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_normal.jpg&#39;) 

mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.PlaneGeometry( 1, 1,100,100 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05,
    roughness:0.2,
    roughnessMap:mbRoughnesstexture,
    metalnessMap:mbMetalnesstexture,
    metalness:0.3,
    normalMap:mbNormaltexture

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p>添加法线贴图后：</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202092454739.png"></p>
<p>贴图到这里就已经很逼真了，当然，不同的材质所使用的贴图也有一定的区别。</p>
<h3 id="五、纹理加载回调"><a href="#五、纹理加载回调" class="headerlink" title="五、纹理加载回调"></a>五、纹理加载回调</h3><h4 id="1-纹理回调"><a href="#1-纹理回调" class="headerlink" title="1.纹理回调"></a>1.纹理回调</h4><blockquote>
<h3 id="load-url-String-onLoad-Function-onProgress-Function-onError-Function-Texture"><a href="#load-url-String-onLoad-Function-onProgress-Function-onError-Function-Texture" class="headerlink" title=".load ( url : String, onLoad : Function, onProgress : Function, onError : Function ) : Texture"></a>.load ( url : String, onLoad : Function, onProgress : Function, onError : Function ) : Texture</h3><p>url — 文件的URL或者路径，也可以为 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">Data URI</a>.<br>onLoad — 加载完成时将调用。回调参数为将要加载的texture.<br>onProgress — 将在加载过程中进行调用。参数为XMLHttpRequest实例，实例包含total和loaded字节。<br>onError — 在加载错误时被调用。</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_height.jpg&#39;) 
const mbRoughnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_roughness.jpg&#39;) 
const mbMetalnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_metalness.jpg&#39;) 
const event = &#123;&#125;;
event.onLoad = function(e)&#123;
    console.log(&#39;加载完成了&#39;)
&#125;
event.onProgress = function(e)&#123;
    console.log(e)
    console.log(&#39;正在加载&#39;)
&#125;
event.onError = function(e)&#123;
    console.log(&#39;加载错误了&#39;)
    console.log(e)
&#125;
const mbNormaltexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_normal.jpg&#39;,
event.onLoad,//加载完成调用
event.onProgress,//加载过程中调用
event.onError//加载错误调用
) 

mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.PlaneGeometry( 1, 1,100,100 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05,
    roughness:0.2,
    roughnessMap:mbRoughnesstexture,
    metalnessMap:mbMetalnesstexture,
    metalness:0.3,
    normalMap:mbNormaltexture

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p>加载中</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202101019627.png" alt="onProgress"></p>
<p>加载完成</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202101056269.png" alt="onLoad"></p>
<p>加载错误</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202101123771.png" alt="onError"></p>
<h4 id="2-纹理加载器"><a href="#2-纹理加载器" class="headerlink" title="2.纹理加载器"></a>2.纹理加载器</h4><blockquote>
<p>其功能是处理并跟踪已加载和待处理的数据，管理我们加载的纹理</p>
</blockquote>
<pre><code class="javascript">//main.js+
const event = &#123;&#125;;
event.onLoad = function(e)&#123;
    console.log(&#39;加载完成了&#39;)
&#125;
event.onProgress = function( url,itemsLoaded,itemsTotal)&#123;
    console.log(&#39;url:&#39;+ url)//当前加载纹理路径
    console.log(&#39;itemsLoaded:&#39; + itemsLoaded )//加载当前纹理位置
    console.log(&#39;itemsTotal:&#39; + itemsTotal)//纹理总数
    console.log(&#39;加载角度:&#39; + ((itemsLoaded / itemsTotal) * 100).toFixed(2) + &#39;%&#39;)//纹理加载进度
&#125;
event.onError = function(e)&#123;
    console.log(&#39;加载错误了&#39;)
    console.log(e)
&#125;
const manager = new THREE.LoadingManager(
    event.onLoad,
    event.onProgress,
    event.onError
    );

const textureLoader = new THREE.TextureLoader(manager);//装载加载器
const mbColortexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_height.jpg&#39;) 
const mbRoughnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_roughness.jpg&#39;) 
const mbMetalnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_metalness.jpg&#39;) 
const mbNormaltexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_normal.jpg&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.PlaneGeometry( 1, 1,100,100 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05,
    roughness:0.2,
    roughnessMap:mbRoughnesstexture,
    metalnessMap:mbMetalnesstexture,
    metalness:0.3,
    normalMap:mbNormaltexture

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202102251981.png"></p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202104213221.png"></p>
<h3 id="六、环境纹理"><a href="#六、环境纹理" class="headerlink" title="六、环境纹理"></a>六、环境纹理</h3><blockquote>
<p>创建一个由6张图片所组成的纹理对象。</p>
<p>（前后，上下，左右）也可以是 <a href="https://zh.m.wikipedia.org/zh/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%88%90%E5%83%8F">hdr</a>（一张图）</p>
</blockquote>
<pre><code class="javascript">const loader = new THREE.CubeTextureLoader();
loader.setPath( &#39;textures/cube/pisa/&#39; );

const textureCube = loader.load( [
    &#39;px.png&#39;, &#39;nx.png&#39;,
    &#39;py.png&#39;, &#39;ny.png&#39;,
    &#39;pz.png&#39;, &#39;nz.png&#39;
] );
const material = new THREE.MeshBasicMaterial( &#123; color: 0xffffff, envMap: textureCube &#125; );
scene.background = textureCube;
scene.environment = textureCube;//若该值不为null，则该纹理贴图将会被设为场景中所有物理材质的环境贴图。 然而，该属性不能够覆盖已存在的、已分配给 MeshStandardMaterial.envMap 的贴图
</code></pre>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202133340321.png"></p>
<h3 id="七、HDR"><a href="#七、HDR" class="headerlink" title="七、HDR"></a>七、HDR</h3><blockquote>
<p><a href="https://zh.m.wikipedia.org/zh/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%88%90%E5%83%8F">HDR</a></p>
<p>那么我们也是要知道如何加载hdr</p>
</blockquote>
<p><strong>高动态范围成像</strong>（英語：<strong>H</strong>igh <strong>D</strong>ynamic <strong>R</strong>ange Imaging，简称<strong>HDRI</strong>或<strong>HDR</strong>），在计算机图形学与电影摄影术中，是用来实现比普通数位图像技术更大曝光动态范围（即更大的明暗差别）的一组技术。高动态范围成像的目的就是要正确地表示真实世界中从太阳光直射到最暗的阴影这样大的范围亮度。</p>
<blockquote>
<h3 id="mapping-number"><a href="#mapping-number" class="headerlink" title=".mapping : number"></a>.mapping : number</h3><p>图像将如何应用到物体（对象）上。默认值是THREE.UVMapping对象类型， 即UV坐标将被用于纹理映射。</p>
<p>EquirectangularReflectionMapping 和 EquirectangularRefractionMapping 用于等距圆柱投影的环境贴图，也被叫做经纬线映射贴图。等距圆柱投影贴图表示沿着其水平中线360°的视角，以及沿着其垂直轴向180°的视角。贴图顶部和底部的边缘分别对应于它所映射的球体的北极和南极。</p>
</blockquote>
<pre><code class="javascript">//main.js+
import &#123; RGBELoader &#125; from &#39;three/examples/jsm/loaders/RGBELoader&#39;
const rgbeLoader = new RGBELoader();
rgbeLoader.loadAsync(&#39;./texture/ruin1.hdr&#39;).then((texture)=&gt;&#123;
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.background = texture;
    scene.environment = texture;
&#125;)
const geometry = new THREE.SphereGeometry( 15, 100, 50 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    metalness:0.5,
    roughness:0.05
 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202141946012.png"></p>
<h3 id="八、灯光与阴影"><a href="#八、灯光与阴影" class="headerlink" title="八、灯光与阴影"></a>八、灯光与阴影</h3><blockquote>
<p>阴影需要满足的条件</p>
<p>1.材质应满足对灯光有反应（环境光由于是四面八方的光，所以不具备阴影的条件）</p>
<p>2.渲染器开启阴影计算：renderer.shadowMap.enabled &#x3D; true</p>
<p>3.光照投射阴影：light.castShadow &#x3D; true</p>
<p>4.物体投射阴影：cube.castShadow &#x3D; true（投影主体）</p>
<p>5.物体接收投射阴影：plane.receiveShadow &#x3D; true（接收主体）</p>
</blockquote>
<pre><code class="javascript">//main.js
import * as THREE from &#39;three&#39;
import &#123; OrbitControls &#125; from &#39;three/examples/jsm/controls/OrbitControls&#39; 
import dat from &#39;dat.gui&#39;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;//渲染器开启阴影计算
document.body.appendChild( renderer.domElement );

const axesHelper = new THREE.AxesHelper( 30 );//轴的线段长度. 默认为 1.
scene.add( axesHelper );//添加到场景


const geometry = new THREE.SphereGeometry( 15, 100, 50 );
const material = new THREE.MeshStandardMaterial();
const cube = new THREE.Mesh( geometry, material );
cube.castShadow = true;//物体投射阴影
scene.add( cube );

const geometryP = new THREE.PlaneGeometry( 100,100 );
const materialP = new THREE.MeshStandardMaterial();
const plane = new THREE.Mesh( geometryP, materialP );
plane.rotation.x = -Math.PI / 2
plane.position.set(0,-15,0)
plane.receiveShadow = true//物体接收投射阴影
scene.add( plane );

const light = new THREE.PointLight( 0xffffff, 1, 100 );
light.position.set( 10, 50, 10 );
light.castShadow = true;//光照投射阴影
scene.add( light ); 

const gui = new dat.GUI();
gui.add(light.position,&#39;x&#39;)
.min(0)
.max(30)
.name(&#39;移动x坐标&#39;)
.step(0.1)
gui.add(light.position,&#39;y&#39;)
.min(0)
.max(30)
.name(&#39;移动y坐标&#39;)
.step(0.1)
gui.add(light.position,&#39;z&#39;)
.min(0)
.max(30)
.name(&#39;移动z坐标&#39;)
.step(0.1)
const controls = new OrbitControls( camera,renderer.domElement  );
camera.position.set(0,20,100);
controls.update();
function animate() &#123;
    requestAnimationFrame( animate );
    controls.update();
    renderer.render( scene, camera );
&#125;
animate();

window.addEventListener(&#39;resize&#39;,()=&gt;&#123;
    // console.log(&#39;屏幕变化了&#39;)
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
&#125;)
</code></pre>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202151934429.png"></p>
<p>总结：</p>
<p>我们还有一些灯光，例如点光源和聚光灯，它们的属性我们就不一一来讲了，相信我们到了这，文档已经可以比较熟悉的查阅了。加油！！！</p>
<p>参考文档：</p>
<p>[HDR讲解]: 	“<a href="https://zh.m.wikipedia.org/zh/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%88%90%E5%83%8F&quot;">https://zh.m.wikipedia.org/zh/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%88%90%E5%83%8F&quot;</a></p>
]]></content>
      <categories>
        <category>Web3D</category>
        <category>Three.js</category>
        <category>threejs-d-5.0</category>
      </categories>
      <tags>
        <tag>threejs</tag>
      </tags>
  </entry>
  <entry>
    <title>从0到1搭建自己的脚手架react</title>
    <url>/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="从0到1搭建自己的脚手架react"><a href="#从0到1搭建自己的脚手架react" class="headerlink" title="从0到1搭建自己的脚手架react"></a>从0到1搭建自己的脚手架react</h1><h3 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1.初始化项目"></a>1.初始化项目</h3><pre><code class="ini">npm init -y
</code></pre>
<p>执行初始化命令之后，会出现package.json文件</p>
<h3 id="2-建立项目目录（基础项目目录）"><a href="#2-建立项目目录（基础项目目录）" class="headerlink" title="2.建立项目目录（基础项目目录）"></a>2.建立项目目录（基础项目目录）</h3><p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108085707668.png"></p>
<h3 id="3-下载依赖"><a href="#3-下载依赖" class="headerlink" title="3.下载依赖"></a>3.下载依赖</h3><p>react</p>
<pre><code class="ini">npm i react react-dom 
</code></pre>
<p>下载babel。babel是javascript编辑器，作用如下：</p>
<ol>
<li>负责把ES6、ES7等高版本js编译成低版本js，供浏览器运行。</li>
<li>负责把react语法（jsx）编译成js。</li>
</ol>
<pre><code class="ini"> npm i @babel/core @babel/cli @babel/preset-env @babel/preset-react --save-dev
</code></pre>
<p>集成webpack。webpack是一个现代JavaScript应用程序的静态模块打包器，现代前端应用很多都是用webpack打包。webpack-dev-server用来搭建一个本地服务，可以热加载前端项目</p>
<pre><code class="ini">npm i webpack webpack-dev-server webpack-cli --save-dev
</code></pre>
<p>webpack集成babel还需要babel-loader，加载html文件还需要插件html-webpack-plugin：</p>
<pre><code class="ini">npm i babel-loader html-webpack-plugin --save-dev
</code></pre>
<h3 id="4-编辑index-html、App-js、index-js"><a href="#4-编辑index-html、App-js、index-js" class="headerlink" title="4.编辑index.html、App.js、index.js"></a>4.编辑index.html、App.js、index.js</h3><pre><code class="html">//index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;root&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="javascript">//App.js
import React from &quot;react&quot;;
class App extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                App
            &lt;/div&gt;
          );
    &#125;
&#125;

export default App
</code></pre>
<pre><code class="javascript">//index.js
import React from &#39;react&#39;;
import &#123; createRoot &#125; from &#39;react-dom/client&#39;;
import App from &#39;./App&#39;;

const root = createRoot(document.getElementById(&#39;root&#39;))
root.render(&lt;App /&gt;)
</code></pre>
<h3 id="5-在根目录下添加-babelrc文件、webpack-config-js文件"><a href="#5-在根目录下添加-babelrc文件、webpack-config-js文件" class="headerlink" title="5.在根目录下添加.babelrc文件、webpack.config.js文件"></a>5.在根目录下添加.babelrc文件、webpack.config.js文件</h3><p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108093539451.png"></p>
<h3 id="6-配置-babelrc、webpack-config-js"><a href="#6-配置-babelrc、webpack-config-js" class="headerlink" title="6.配置.babelrc、webpack.config.js"></a>6.配置.babelrc、webpack.config.js</h3><pre><code class="javascript">//.babelrc
&#123;
    &quot;presets&quot;: [&quot;@babel/preset-env&quot;,&quot;@babel/preset-react&quot;]
&#125;
</code></pre>
<pre><code class="javascript">//webpack.config.js
const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.js&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.m?js/,
                use:&#39;babel-loader&#39;,
                exclude:/node_modules/
            &#125;
        ]
    &#125;,
    //webpack加载html文件需要html-webpack-plugin插件处理。
    //启动webpack-dev-server的时候，会把打包好的js文件，css文件，html文件放在内存里
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;

&#125;
</code></pre>
<h3 id="7-当我们配置好上面的项目了，现在我们就可以运行了"><a href="#7-当我们配置好上面的项目了，现在我们就可以运行了" class="headerlink" title="7.当我们配置好上面的项目了，现在我们就可以运行了"></a>7.当我们配置好上面的项目了，现在我们就可以运行了</h3><p>现在我们还得配置一个小细节package,json</p>
<pre><code class="javascript">&#123;
  &quot;name&quot;: &quot;react-app-start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: &#123;
    //--mode=development为开发环境，速度较快，上线可以配置为生产环境，会压缩，优化代码
    //--watch为监听代码变化，只要代码变化，会重新编译
    //build是生产环境的打包
    &quot;serve&quot;: &quot;webpack --mode=development --watch&quot;,
    &quot;build&quot;: &quot;webpack --mode=production&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: &#123;
    &quot;react&quot;: &quot;^18.2.0&quot;,
    &quot;react-dom&quot;: &quot;^18.2.0&quot;,
    &quot;webpack&quot;: &quot;^5.74.0&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;@babel/cli&quot;: &quot;^7.19.3&quot;,
    &quot;@babel/core&quot;: &quot;^7.20.2&quot;,
    &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;,
    &quot;@babel/preset-react&quot;: &quot;^7.18.6&quot;,
    &quot;babel-loader&quot;: &quot;^9.1.0&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,
    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;
  &#125;
&#125;
</code></pre>
<p>这时候就可以执行命令了</p>
<pre><code class="ini">npm run serve
</code></pre>
<p>打包执行命令</p>
<pre><code class="ini">npm run build
</code></pre>
<h3 id="8-如果没有报错的话，你就会看见下面的页面"><a href="#8-如果没有报错的话，你就会看见下面的页面" class="headerlink" title="8.如果没有报错的话，你就会看见下面的页面"></a>8.如果没有报错的话，你就会看见下面的页面</h3><p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108100300240.png"></p>
<h3 id="9-至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server："><a href="#9-至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server：" class="headerlink" title="9.至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server："></a>9.至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server：</h3><pre><code class="ini">npm i webpack-dev-server --save-dev
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108100733217.png"></p>
<p>执行命令：</p>
<pre><code class="ini">npm run start
</code></pre>
<p>项目在3000端口启动，启动后会自动打开浏览器窗口。热加载配置完成，文件修改保存后浏览器直接展示出来。</p>
<p>到此react项目简化版搭建完成。后续继续集成其他工具库即可。</p>
<h3 id="10-react使用ts"><a href="#10-react使用ts" class="headerlink" title="10.react使用ts"></a>10.react使用ts</h3><p>ts对比js最大的特点就是多了类型检查。推荐前端语言使用ts。接下来介绍在webpack中配置ts。</p>
<p>安装typescript、ts-loader。typescript是ts编辑器，把ts代码编译成js，ts-loader是让webpack识别.ts&#x2F;.tsx文件，调用编译器编译，</p>
<pre><code class="ini">npm i typescript ts-loader --save-dev
</code></pre>
<p>添加ts配置文件,在根目录下添加tsconfig.json：</p>
<pre><code class="ini">//tsconfig.json
&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;es5&quot;,
        &quot;lib&quot;:[&quot;es6&quot;,&quot;dom&quot;],
        &quot;module&quot;: &quot;esnext&quot;,
        &quot;moduleResolution&quot;: &quot;node&quot;,
        &quot;jsx&quot;:&quot;react&quot;,
        &quot;sourceMap&quot;: true,
        &quot;strict&quot;: true,
        &quot;importHelpers&quot;: true,
        &quot;skipLibCheck&quot;: true,
        &quot;allowJs&quot;: true,
        &quot;allowSyntheticDefaultImports&quot;: true
    &#125;
&#125;
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108101701100.png"></p>
<p>修改webpack配置</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.tsx&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.m?js|tsx$/,
                use:&#39;ts-loader&#39;,
                exclude:/node_modules/
            &#125;
        ]
    &#125;,
    //增加扩展选项，让webpack可以识别.ts/tsx文件
    resolve:&#123;
        extensions:[&#39;.ts&#39;,&#39;.tsx&#39;,&#39;.js&#39;]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;

&#125;
</code></pre>
<p>目前可能会报错</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108110219148.png"></p>
<p>根据提示，我们缺一些依赖</p>
<pre><code class="ini">npm i --save-dev @types/react
npm i --save-dev @types/react-dom
</code></pre>
<p>这个时候我们还会遇到一个问题</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108111925911.png"></p>
<p>那么这个问题的原因是缺null类型检测</p>
<p>其他人回答说应该添加null检查，但Typescript也有一个非null断言，当您通过添加！运算符添加到语句末尾：</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108112118833.png"></p>
<p>这个时候我们react使用ts的问题就解决了</p>
<p>启动项目，运行成功，ts集成成功了</p>
<h3 id="11-react集成路由"><a href="#11-react集成路由" class="headerlink" title="11.react集成路由"></a>11.react集成路由</h3><p>安装路由库</p>
<pre><code class="ini">npm install react-router-dom@6
</code></pre>
<p>创建项目目录</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108143446498.png"></p>
<p>编辑About.tsx、Home.tsx、index.tsx、App.tsx</p>
<pre><code class="tsx">//About.tsx
import React from &quot;react&quot;;
import &#123; Link &#125; from &quot;react-router-dom&quot;;

class About extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                this is about&lt;br/&gt;
                &lt;Link to=&#123;&#39;/home&#39;&#125;&gt;to home&lt;/Link&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default About;
</code></pre>
<pre><code class="tsx">//Home.tsx
import React from &quot;react&quot;;
import &#123; Link &#125; from &quot;react-router-dom&quot;;

class Home extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                this is home&lt;br/&gt;
                &lt;Link to=&#123;&#39;/about&#39;&#125;&gt;to about&lt;/Link&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default Home;
</code></pre>
<pre><code class="tsx">//App.tsx
import React from &quot;react&quot;;
import &#123; Routes,Route &#125; from &quot;react-router-dom&quot;;
import About from &quot;./compents/About&quot;;
import Home from &quot;./compents/Home&quot;;

class App extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                &lt;Routes&gt;
                    &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;
                &lt;/Routes&gt;
            &lt;/div&gt;
          );
    &#125;
&#125;

export default App
</code></pre>
<pre><code class="tsx">//index.tsx
import React from &#39;react&#39;;
import &#123; createRoot &#125; from &#39;react-dom/client&#39;;
import App from &#39;./App&#39;;
import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;;

const root = createRoot(document.getElementById(&#39;root&#39;)!)
root.render(
    &lt;BrowserRouter&gt;
        &lt;App /&gt;
    &lt;/BrowserRouter&gt;
)
</code></pre>
<p>react路由搭建成功</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108143901241.png"></p>
<h3 id="12-react使用redux"><a href="#12-react使用redux" class="headerlink" title="12.react使用redux"></a>12.react使用redux</h3><p>对于大型项目来说，数据管理工具也是必不可少的。我们简单介绍redux、react-redux的使用。这里使用的是@reduxjs&#x2F;toolkit库，相比redux库使用方法有很大区别，想用redux库的请自行查看redux文档。</p>
<p>下载依赖</p>
<pre><code class="ini">npm i @reduxjs/toolkit react-redux
</code></pre>
<p>创建项目目录</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108151822086.png"></p>
<p>编辑store.ts、countSlice.ts、counter.tsx、index.tsx、App.tsx</p>
<pre><code class="tsx">//store.ts
import &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;;
import counterReducer from &#39;./countSlice&#39;;

export default configureStore(&#123;
    reducer:&#123;
        counter:counterReducer
    &#125;
&#125;)
</code></pre>
<pre><code class="tsx">//countSlice.ts
import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;

export const counterSlice = createSlice(&#123;
    name:&#39;counter&#39;,
    initialState:&#123;
        value:0
    &#125;,
    reducers:&#123;
        increment:(state) =&gt; &#123;
            state.value += 1
        &#125;,
        decrement:(state) =&gt;&#123;
            state.value -= 1
        &#125;,
        incrementByAmount:(state,action) =&gt; &#123;
            state.value += action.payload
        &#125;
    &#125;
&#125;)

export const &#123; increment,decrement,incrementByAmount &#125; = counterSlice.actions
export default counterSlice.reducer
</code></pre>
<pre><code class="tsx">//index.tsx
import React from &#39;react&#39;;
import &#123; createRoot &#125; from &#39;react-dom/client&#39;;
import App from &#39;./App&#39;;
import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;;
import store  from &#39;./store/store&#39;;
import &#123; Provider &#125; from &#39;react-redux&#39;;

const root = createRoot(document.getElementById(&#39;root&#39;)!)
root.render(
    &lt;BrowserRouter&gt;
    &lt;Provider store=&#123;store&#125;&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;  
    &lt;/BrowserRouter&gt;
)
</code></pre>
<pre><code class="tsx">//counter.tsx
import React from &quot;react&quot;;
import &#123; useSelector,useDispatch &#125; from &quot;react-redux&quot;;
import &#123; decrement,increment &#125; from &quot;../store/countSlice&quot;;

function Counter()&#123;
    const count = useSelector((state:any) =&gt; state.counter.value)
    const dispatch = useDispatch()
    
    return (
        &lt;div&gt;
            &lt;div&gt;
                &lt;button 
                aria-label=&quot;Increment value&quot;
                onClick=&#123;() =&gt; dispatch(increment())&#125;
                &gt;
                    increment
                &lt;/button&gt;
                &lt;span&gt;&#123;count&#125;&lt;/span&gt;
                &lt;button
                aria-label=&quot;Decrement value&quot;
                onClick=&#123;() =&gt; dispatch(decrement())&#125;
                &gt;
                    Decrement
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
&#125;

export default Counter;
</code></pre>
<pre><code class="tsx">//App.tsx
import React from &quot;react&quot;;
import &#123; Routes,Route &#125; from &quot;react-router-dom&quot;;
import About from &quot;./compents/About&quot;;
import Home from &quot;./compents/Home&quot;;
import Counter from &quot;./compents/Counter&quot;;

class App extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                &lt;Routes&gt;
                    &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/counter&quot; element=&#123;&lt;Counter /&gt;&#125;&gt;&lt;/Route&gt;
                &lt;/Routes&gt;
            &lt;/div&gt;
          );
    &#125;
&#125;

export default App
</code></pre>
<p>当我执行命令进入counter组件点击功能按钮就发现redux使用成功了</p>
<pre><code class="ini">npm run start
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108152335825.png"></p>
<h3 id="13-集成UI库"><a href="#13-集成UI库" class="headerlink" title="13.集成UI库"></a>13.集成UI库</h3><p>这里使用的是antd第三方库</p>
<p>安装ui库</p>
<pre><code class="ini">npm i antd
</code></pre>
<p>使用antd还需要引用其样式文件，因此还需要下载css-loader、style-loader。</p>
<pre><code class="ini">npm i style-loader css-loader -D
</code></pre>
<p>修改webpack配置</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.tsx&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.j|tsx$/,
                use:&#39;ts-loader&#39;,
                exclude:/node_modules/
            &#125;,
            &#123;
                test:/.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;
        ]
    &#125;,
    //增加扩展选项，让webpack可以识别.ts/tsx文件
    resolve:&#123;
        extensions:[&#39;.ts&#39;,&#39;.tsx&#39;,&#39;.js&#39;]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;
&#125;
</code></pre>
<p>使用antd的话直接引入使用就可以了</p>
<pre><code class="tsx">//Home.tsx
import React from &quot;react&quot;;
import &#123; Link &#125; from &quot;react-router-dom&quot;;
import &#123; Button &#125; from &quot;antd&quot;;

class Home extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                this is home&lt;br/&gt;
                &lt;Link to=&#123;&#39;/about&#39;&#125;&gt;
                    &lt;Button type=&#123;&#39;primary&#39;&#125;&gt;to about&lt;/Button&gt;
                &lt;/Link&gt;
                &lt;Link to=&#123;&#39;/counter&#39;&#125;&gt;
                    &lt;Button type=&#123;&#39;primary&#39;&#125;&gt;to counter&lt;/Button&gt; 
                &lt;/Link&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default Home;
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108153155300.png"></p>
<h3 id="14-跨域问题"><a href="#14-跨域问题" class="headerlink" title="14.跨域问题"></a>14.跨域问题</h3><p>修改webpack.config.js使用proxy</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.tsx&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.j|tsx$/,
                use:&#39;ts-loader&#39;,
                exclude:/node_modules/
            &#125;,
            &#123;
                test:/.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;
        ]
    &#125;,
    //增加扩展选项，让webpack可以识别.ts/tsx文件
    resolve:&#123;
        extensions:[&#39;.ts&#39;,&#39;.tsx&#39;,&#39;.js&#39;]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;,
    devServer:&#123;
        proxy:&#123;
            &#39;/api&#39;:&#39;http://localhost:8080&#39;,
        &#125;,
        client:&#123;
            progress:true
        &#125;
    &#125;

&#125;
</code></pre>
<p>配置后，前端请求就会被代理到8080端口，解决跨域问题</p>
<p>15.集成ESLint和prettier</p>
<p>安装ESLint</p>
<pre><code class="ini">//本地安装
npm install eslint --save-dev
//全局安装
npm install -g eslint
</code></pre>
<p>运行eslint –init，选择工程使用了react，自动生成.eslintrc.js文件</p>
<pre><code class="ini">eslint --init
</code></pre>
<p>安装prettier</p>
<pre><code class="ini">//本地
npm i -D --save-exact prettier
//全局
npm i --global prettier
</code></pre>
<p>安装eslint-config-prettier插件（禁用 eslint 风格校验)</p>
<pre><code class="ini">npm i -D eslint-config-prettier
</code></pre>
<p>安装eslint-plugin-prettier插件（使eslint采用prettier的风格校验）</p>
<pre><code class="ini">npm i -D eslint-plugin-prettier
</code></pre>
<p>配置eslintrc.js文件</p>
<pre><code class="javascript">// eslint-disable-next-line no-undef
module.exports = &#123;
    &quot;env&quot;: &#123;
        &quot;browser&quot;: true,
        &quot;es2021&quot;: true,
        &quot;jest&quot;:true
    &#125;,
    &quot;extends&quot;: [
        &quot;eslint:recommended&quot;,
        &quot;plugin:react/recommended&quot;,
        &quot;plugin:@typescript-eslint/recommended&quot;
    ],
    &quot;overrides&quot;: [
    ],
    &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,
    &quot;parserOptions&quot;: &#123;
        &quot;ecmaVersion&quot;: &quot;latest&quot;
    &#125;,
    &quot;plugins&quot;: [
        &quot;react&quot;,
        &quot;@typescript-eslint&quot;
    ],
    &quot;rules&quot;: &#123;
    &quot;no-cond-assign&quot;: 2,
    &quot;no-console&quot;: [
      &quot;error&quot;, &#123;
        &quot;allow&quot;: [&quot;log&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;info&quot;]
      &#125;
    ],
    // 禁止 function 定义中出现重名参数
    &quot;no-dupe-args&quot;: 2,
    // 禁止对象字面量中出现重复的 key
    &quot;no-dupe-keys&quot;: 2,
    // 禁止重复的 case 标签
    &quot;no-duplicate-case&quot;: 2,
    // 禁止对 catch 子句的参数重新赋值
    &quot;no-ex-assign&quot;: 2,
    // 禁止不必要的布尔转换
    &quot;no-extra-boolean-cast&quot;: 2,
    // 禁止不必要的括号 //(a * b) + c;//报错
    &quot;no-extra-parens&quot;: 0,
    // 禁止 catch 子句的参数与外层作用域中的变量同名
    &quot;no-catch-shadow&quot;: 0,
    // 不允许标签与变量同名
    &quot;no-label-var&quot;: 2,
    // 禁用特定的全局变量
    &quot;no-restricted-globals&quot;: 2,
    // 禁止覆盖受限制的标识符
    &quot;no-shadow-restricted-names&quot;: 2,
    // 禁止将变量初始化为 undefined
    
    // 强制使用一致的换行风格
    &quot;linebreak-style&quot;: [2, &quot;unix&quot;],
    //在JSX中强制布尔属性符号
    &quot;react/jsx-boolean-value&quot;: 2,
    //在JSX中验证右括号位置
    // &quot;react/jsx-closing-bracket-location&quot;: 1,
    //在JSX属性和表达式中加强或禁止大括号内的空格。
    &quot;react/jsx-curly-spacing&quot;: [2, &#123;
      &quot;when&quot;: &quot;never&quot;,
      &quot;children&quot;: true
    &#125;],
    //在数组或迭代器中验证JSX具有key属性
    &quot;react/jsx-key&quot;: 2,
    // 限制JSX中单行上的props的最大数量
    &quot;react/jsx-max-props-per-line&quot;: [1, &#123;
      &quot;maximum&quot;: 5
    &#125;],
    //防止在JSX中重复的props
    &quot;react/jsx-no-duplicate-props&quot;: 2,
    //  //防止使用未包装的JSX字符串
    // &quot;react/jsx-no-literals&quot;: 0,
    //在JSX中禁止未声明的变量
    &quot;react/jsx-no-undef&quot;: 2,
    //为用户定义的JSX组件强制使用PascalCase
    &quot;react/jsx-pascal-case&quot;: 0,
    //防止反应被错误地标记为未使用
    &quot;react/jsx-uses-react&quot;: 2,
    //防止在JSX中使用的变量被错误地标记为未使用
    &quot;react/jsx-uses-vars&quot;: 2,
    //防止在componentDidMount中使用setState
    &quot;react/no-did-mount-set-state&quot;: 2,
    //防止在componentDidUpdate中使用setState
    &quot;react/no-did-update-set-state&quot;: 2,
    //防止使用未知的DOM属性
    &quot;react/no-unknown-property&quot;: 2,
    //为React组件强制执行ES5或ES6类
    &quot;react/prefer-es6-class&quot;: 2,
    //防止在React组件定义中丢失props验证
    // &quot;react/prop-types&quot;: 1,
    //使用JSX时防止丢失React
    &quot;react/react-in-jsx-scope&quot;: 2,
    //防止没有children的组件的额外结束标签
    &quot;react/self-closing-comp&quot;: 0,
    //禁止不必要的bool转换
    // &quot;no-extra-boolean-cast&quot;: 0,
    //防止在数组中遍历中使用数组key做索引
    // &quot;react/no-array-index-key&quot;: 0,
    //不使用弃用的方法
    &quot;react/no-deprecated&quot;: 2,
    //在JSX属性中强制或禁止等号周围的空格
    &quot;react/jsx-equals-spacing&quot;: 2,
    &quot;react/jsx-filename-extension&quot;: [2, &#123;
      &quot;extensions&quot;: [&quot;.js&quot;, &quot;.jsx&quot;]
    &#125;],
    // 禁止未使用的变量
    &quot;no-unused-vars&quot;: 0,
    &#125;
&#125;
</code></pre>
<p>当我们代码被eslint检测到不符合规则的代码就会提示，根据eslint指示修改就可以</p>
<p>在根目录下创建.prettierrc 或 prettier.config.js文件</p>
<pre><code class="javascript">module.exports = &#123;
    endOfLine: &#39;auto&#39;, // 不检测检测文件每行结束的格式
    semi: true, // 使用分号, 默认true
    singleQuote: true // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)
 &#125;
</code></pre>
<p>安装vscode插件：Prettier ESLint</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221107154026317.png"></p>
<p>该插件会根据工程根目录下的eslintrc.js和prettier.config.js文件格式化代码。可以进一步设置为vscode默认formater和自动格式化。</p>
<p>Prettier配置常用的参数可以根据团队需求制定</p>
<p>该文章只是配置简单的react脚手架，核心流程和方法是如此，其他具体需求可以根据团队客制化定制</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[antd官网]: 	“<a href="https://ant.design/docs/react/introduce-cn">https://ant.design/docs/react/introduce-cn</a> “<br>[ESLint中文文档]: 	“<a href="https://eslint.bootcss.com/">https://eslint.bootcss.com</a> “<br>[Prettier中文网]: 	“<a href="https://www.prettier.cn/">https://www.prettier.cn</a> “</p>
<h3 id="源码仓库地址："><a href="#源码仓库地址：" class="headerlink" title="源码仓库地址："></a>源码仓库地址：</h3><p><a href="https://github.com/mengfeng/react-app-start.git">https://github.com/mengfeng/react-app-start.git</a></p>
]]></content>
      <categories>
        <category>工程技术</category>
        <category>从0到1搭建自己的脚手架react</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端页面的生命周期</title>
    <url>/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端页面的生命周期"><a href="#前端页面的生命周期" class="headerlink" title="前端页面的生命周期"></a>前端页面的生命周期</h1><blockquote>
<p>性能问题呈现给用户的感受往往是简单而直接的:加载资源缓慢、运行过程卡杨或响应交互迟缓等，当把这些问题呈现到前端工程师面前时，却是另种系统级别复杂的图景。</p>
<p>从域名解析、TCP建立连接到HTTP的请求与响应，以及从资源请求、文件解析到关键渲染路径等，每一 个环节都有可能因为设计不当、考虑不周、运行出错而产生性能不佳的体验。作为前端工程师，为了能在遇到性能问题时快速而准确地定位问题所在，并设计可行的优化方案，熟悉前端页面的生命周期是一堂必修课。本章就从一道常见的前端面试题开始，通过对此问题的解答，来分析前端页面生命周期的各个环节，并着重分析其中关键渲染路径的具体过程和优化实践，希望以此为基础帮读者建构一套完整知识框架的图谱，而后续章节的专题性优化，也都是对此生命周期中某个局部过程的优化分析。</p>
</blockquote>
<h3 id="一、一道前端面试题"><a href="#一、一道前端面试题" class="headerlink" title="一、一道前端面试题"></a>一、一道前端面试题</h3><p>​		我们在进行前端面试时，经常问这样一个问题: 从浏览器地址栏输入URL后，到页面渲染出来，整个过程都发生了什么?这个问题不仅能很好地分辨出面试候选人对前端知识的掌握程度，能够考查其知识体系的完整性，更重要的是，能够考查面试者在前端性能优化方面理解和掌握此过程的深入程度，与快速定位性能瓶颈及高效权衡出恰当的性能优化解决方案是正相关的。</p>
<p>​		根据面试和工作的经验，将工程师的能力由低到高划分了若干等级:不堪一击、初窥门径、略有小成、驾轻就熟、融会贯通…..如果面试者的回答是:首先浏览器发起请求，然后服务器返回数据，最后脚本执行和页面渲染，那么这种程度大概在不堪- 击与初窥门径之间，属于刚入门前端，对性能优化还没什么概念。</p>
<p>​		如果知道在浏览器输入URL后会建立TCP连接，并在此之上有HTTP的请求与响应，在浏览器接收到数据后，了解HTML与CSS文件如何构成渲染树，以及JS(JavaScript的简称)引擎解析和执行的基本流程，这种程度基本算是初窥门径，在面对网站较差的性能表现时，能够尝试从网络连接、关键渲染路径及JS执行过程等角度去分析和找寻可能存在的问题。</p>
<p>​		其实这个问题的回答可以非常细致，能从信号与系统、计算机原理、操作系统聊到网络通信、浏览器内核，再到DNS解析、负载均衡、页面渲染等，主要关注前端方面的相关内容，为了后文表述更清楚，这里首先将整个过程划分为以下几个阶段。</p>
<pre><code class="css">(1)浏览器接收到URL,到网络请求线程的开启。
(2)一个完整的HTTP请求并的发出。
(3)服务器接收到请求并转到具体的处理后台。
(4)前后台之间的HTTP交互和涉及的缓存机制。
(5)浏览器接收到数据包后的关键渲染路径。
(6) JS引擎的解析过程。
</code></pre>
<p>​		本章接下来的部分将对以上各阶段进行介绍，由于其中涉及一些知识点，认为这些知识点对理解性能问题和实施优化十分重要，需要更多的篇幅才能表述清楚，所以本章仅对其讲明原理，而后续章节将会单独详述，比如发起完整HTTP请求阶段的DNS域名解析，前后台HTTP交互阶段的数据压缩与缓存等。</p>
<h3 id="二、网络请求线程开启"><a href="#二、网络请求线程开启" class="headerlink" title="二、网络请求线程开启"></a>二、网络请求线程开启</h3><p>​		浏览器接收到我们输入的URL到开启网络请求线程，这个阶段是在浏览器内部完成的，需要先来了解这里面涉及的一些概念。</p>
<p>首先是对URL的解析，它的各部分的含义如下所示。</p>
<pre><code class="css">URL结构: Protocol://Host:Port/Path?Query#Fragment
</code></pre>
<table>
<thead>
<tr>
<th align="left">标识</th>
<th align="left">名称</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Protocol</td>
<td align="left">协议头</td>
<td align="left">说明浏览器如何处理要打开的文件，常见的有HTTP、FTP、Telnet等</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">主机域名&#x2F;IP地址</td>
<td align="left">所访问资源在互联网上的地址，主机域名或经过DNS解析为IP地址</td>
</tr>
<tr>
<td align="left">Port</td>
<td align="left">端口号</td>
<td align="left">请求程序和响应程序之间连接用的标识</td>
</tr>
<tr>
<td align="left">Path</td>
<td align="left">目录路径</td>
<td align="left">请求的目录或者文件名</td>
</tr>
<tr>
<td align="left">Query</td>
<td align="left">查询参数</td>
<td align="left">请求所传递的参数</td>
</tr>
<tr>
<td align="left">Fragment</td>
<td align="left">片段</td>
<td align="left">次级资源信息，通常可作为前端路由或锚点</td>
</tr>
</tbody></table>
<p>​		解析URL后，如果是HTTP协议，则浏览器会新建一个网络请求线程去下载所需的资源，要明白这个过程需要先了解进程和线程之间的区别，以及目前主流的多进程浏览器结构。</p>
<h4 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h4><p>​	简单来说，进程就是一个程序运行的实例，操作系统会为进程创建独立的内存，用来存放运行所需的代码和数据;而线程是进程的组成部分，每个进程至少有一个主线程及可能的若干子线程，这些线程由所属的进程进行启动和管理。由于多个线程可以共享操作系统为其所属的同一个进程所分配的资源，所以多线程的并行处理能有效提高程序的运行效率。</p>
<p>下面形象地展示了进程、线程和所执行任务之间的关系。从中可以总结出进程与线程之间关系的四个特点。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230107112002226.png"></p>
<p>（1）只要某个线程执行出错，将会导致整个进程崩溃。</p>
<p>（2）进程与进程之间相互隔离。这保证了当一个进程挂起或崩溃的情况发生时，并不会影响其他进程的正常运行，虽然每个进程只能访问系统分配给自己的资源，但可以通过IPC机制进行进程间通信。</p>
<p>（3）进程所占用的资源会在其关闭后由操作系统回收。即使进程中存在某个线程产生的内存泄漏，当进程退出时，相关的内存资源也会被回收。</p>
<p>（4）线程之间可以共享所属进程的数据。</p>
<h4 id="2-单进程浏览器"><a href="#2-单进程浏览器" class="headerlink" title="2.单进程浏览器"></a>2.单进程浏览器</h4><p>​		在熟悉了进程和线程之间的区别后， 我们在此基础上通过了解浏览器架构模型的演变，来看网络请求线程的开启处在怎样的位置。</p>
<p>​		说到底浏览器也只是一个运行在操作系统上的程序，那么它的运行单位就是进程，而早在2008年谷歌发布Chrome多进程浏览器之前，市面上几乎所有浏览器都是单进程的，它们将所有功能模块都运行在同一一个进程中。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230107112844646.png"></p>
<p>单进程浏览器在以下方面有着较为明显的隐患。</p>
<ul>
<li>流畅性: 首先是页面内存泄漏，浏览器内核通常非常复杂，单进程浏览器打开再关闭一个页面的操作，通常会有一些内存不能完全回收，这样随着使用时间延长，占用的内存会越来越多，从而引起浏览器运行变慢:其次由于很多模块运行在同一个线程中，如JS引擎、页面渲染及插件等，那么执行某个循环任务的模块就会阻塞其他模块的任务执行，这样难免会有卡顿的现象发生。</li>
<li>安全性: 由于插件的存在，不免其中有些恶意脚本会利用浏览器漏洞来获取系统权限，进行引发安全问题的行为。</li>
<li>稳定性: 由于所有模块都运行在同一个进程中，对于稍复杂的JS代码，如果页面渲染引擎崩溃，就会导致整个浏览器崩溃。同样，各种不稳定的第三方插件，也是导致浏览器崩溃的隐患。</li>
</ul>
<h4 id="3-多进程浏览器"><a href="#3-多进程浏览器" class="headerlink" title="3.多进程浏览器"></a>3.多进程浏览器</h4><p>​		出于对单进程浏览器存在问题的优化，Chrome 推出了多进程浏览器架构。</p>
<p>​		浏览器把原先单进程内功能相对独立的模块抽离为单个进程处理对应的任务，主要分为以下几种进程。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230107114445249.png"></p>
<p>（1）浏览器主进程: 一个浏览器只有一个主进程，负责如菜单栏、标题栏等界面显示，文件访问，前进后退，以及子进程管理等。</p>
<p>（2）GPU进程: GPU (图形处理单元)最初是为了实现3D的CSS效果而引入的，后来随着网页及浏览器在界面中的使用需求越来越普遍，Chrome 便在架构中加入了GPU进程。</p>
<p>（3）插件进程:主进程会为每个加入浏览器的插件开辟独立的子进程，由于进程间所分配的运行资源相对独立，所以即便某个插件进程意外崩溃，也不至于对浏览器和页面造成影响。另外，出于对安全因素的考虑，这里采用了沙箱模式(即图中虚线所标出的进程)，在沙箱中运行的程序受到一些限制: 不能读取敏感位置的数据，也不能在硬盘上写入数据。这样即使插件运行了恶意脚本，也无法获取系统权限。</p>
<p>（4）网络进程:负责页面的网络资源加载，之前属于浏览器主进程中的一个模块，最近才独立出来。</p>
<p>（5）渲染进程:也称为浏览器内核，其默认会为每个标签窗口页开辟一个独立的进程，负责将HTML、CSS和JavaScript等资源转为可交互的页面，其中包含多个子线程，即JS引擎线程、GUI渲染线程、事件触发线程、定时触发器线程、异步HTTP请求线程等。当打开个标签页输入 URL后，所发起的网络请求就是从这个进程开始的。另外，出于对安全性的考虑，渲染进程也被放入沙箱中。</p>
<p>打开Chrome任务管理器，可以从中查看到当前浏览器都启动了哪些进程，如图所示。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230107113416449.png"></p>
<p>此时仅打开了一个标签页， 除了浏览器添加插件所开辟的进程，还可以看到浏览器进程、GPU进程、网络进程，以及最近新抽离出来的一个音频服务进程。</p>
<h3 id="三、建立HTTP请求"><a href="#三、建立HTTP请求" class="headerlink" title="三、建立HTTP请求"></a>三、建立HTTP请求</h3><p>​		这个阶段的主要工作分为两部分: DNS解析和通信链路的建立，简单说就是，首先发起请求的客户端浏览器要明确知道所要访问的服务器地址，然后建立通往该服务器地址的路径。</p>
<h4 id="1-DNS-解析"><a href="#1-DNS-解析" class="headerlink" title="1.DNS 解析"></a>1.DNS 解析</h4><p>​		在前面章节讲到的URL解析，其实仅将URL拆分为代表具体含义的字段，然后以参数的形式传入网络请求线程进行进一步处理 ，首先第一步便是这 里讲到的DNS解析。其主要目的便是通过查询将URL中的Host字段转化为网络中具体的IP地址，因为域名只是为了方便帮助记忆的，IP 地址才是所访问服务器在网络中的“门牌号”。如图所示为DNS解析过程。</p>
<p>​		首先查询浏览器自身的DNS缓存，如果查到IP地址就结束解析，由于缓存时间限制比较大，一般只有1分钟，同时缓存容量也有限制，所以在浏览器缓存中没找到IP地址时，就会搜索系统自身的DNS缓存:如果还未找到，接着就会尝试从系统的hosts 文件中查找。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230108084422437.png"></p>
<p>​		在本地主机进行的查询若都没获取到，接下来便会在本地城名服务器上查询，如果本地城名服务器没有直接的目标IP地址可供返回，则本地域名服务器便会采取选代的方式去依次查询根域名服务器、COM顶级域名服务器和权限域名服务器等，最终将所要访问的目标服务器IP地址返回本地主机，若查询不到，则返回报错信息。</p>
<p>​		由此可以看出DNS解析是个很耗时的过程，若解析的域名过多，势必会延缓首屏的加载时间。本节仅对DNS解析过程进行简要的概述，而关于原理及优化方式等更为详细的介绍会在后续章节中单独展开介绍。</p>
<h4 id="2-网络模型"><a href="#2-网络模型" class="headerlink" title="2.网络模型"></a>2.网络模型</h4><p>​		在通过DNS解析获取到目标服务器IP地址后，就可以建立网络连接进行资源的请求与响应了。但在此之前，我们需要对网络架构模型有一些基本的认识，在互联网发展初期，为了使网络通信能够更加灵活、稳定及可互操作，国际标准化组织提出了些网络架构极型，0SI模型、TCP&#x2F;IP模型，二者的网络模型图如图。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230108085159377.png"></p>
<p>​		OSI (开放系统互连)模型将网络从底层的物理层到顶层浏览器的应用层一共划分了7层，OSI各层的具体作用如表所示。</p>
<table>
<thead>
<tr>
<th>OSI模型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>负责给应用程序提供接口，使其可以使用网络服务，HTTP 协议就位于该层</td>
</tr>
<tr>
<td>表示层</td>
<td>负责数据的编码与解码，加密和解密，压缩和解压缩</td>
</tr>
<tr>
<td>会话层</td>
<td>负责协调系统之间的通信过程</td>
</tr>
<tr>
<td>传输层</td>
<td>负责端到端连接的建立，使报文能在端到端之间进行传输。TCP&#x2F;UDP 协议位于该层</td>
</tr>
<tr>
<td>网络层</td>
<td>为网络设备提供逻辑地址，使位于不同地理位置的主机之间拥有可访问的连接和路径</td>
</tr>
<tr>
<td>数据链路层</td>
<td>在不可靠的物理链路上，提供可靠的数据传输服务。包括组帧、物理编址、流量控制、差错控制、接入控制等</td>
</tr>
<tr>
<td>物理层</td>
<td>主要功能包括:定义网络的物理拓扑，定义物理设备的标准(如介质传输速率、网线或光纤的接口模型等)，定义比特的表示和信号的传输模式</td>
</tr>
</tbody></table>
<p>​		OSI是一种理论下的模型，它先规划了模型再填入协议，先制定了标准再推行实践，TCP&#x2F;IP充分借鉴了OSI 引入的服务、接口、协议及分层等概念，建立了TCP&#x2F;IP模型并广泛使用，成为目前互联网事实上的标准。</p>
<h4 id="3-TCP-连接"><a href="#3-TCP-连接" class="headerlink" title="3.TCP 连接"></a>3.TCP 连接</h4><p>​		根据对网络模型的介绍，当使用本地主机连上网线接入互联网后，数据链路层和网络层就已经打通了，而要向目标主机发起HTTP请求，就需要通过传输层建立端到端的连接。</p>
<p>​		传输层常见的协议有TCP协议和UDP协议，由于本章关注的重点是前端页面的资源请求，这需要面向连接、丢包重发及对数据传输的各种控制，所以接下来仅详细介绍TCP协议的“三次握手”和“四次挥手”。</p>
<p>​		由于TCP是面向有连接的通信协议，所以在数据传输之前需要建立好客户端与服务器端之间的连接，即通常所说的“三次握手”，具体过程分为如下步骤。</p>
<p>（1）客户端生成 一个随机数seq，假设其值为t， 并将标志位SYN设为1,将这些数据打包发给服务器端后，客户端进入等待服务器端确认的状态。</p>
<p>（2）服务器端收到客户端发来的SYN&#x3D;1的数据包后，知道这是在请求建立连接，于是服务器端将SYN与ACK均置为1,并将请求包中客户端发来的随机数t加1后赋值给ack,然后生成一个服务器端的随机数seq&#x3D;k,完成这些操作后，服务器端将这些数据打包再发回给客户端，作为对客户端建立连接请求的确认应答。</p>
<p>（3）客户端收到服务器端的确认应答后，检查数据包中ack的字段值是否为t+1,ACK是否等于1,若都正确就将服务器端发来的随机数加1 (ack&#x3D;k+1),将ACK&#x3D;1的数据包再发送给服务器端以确认服务器端的应答，服务器端收到应答包后通过检查ack是否等于k+1来确认连接是否建立成功。连接建立的关系图如图所示。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230108091919913.png"></p>
<p>当用户关闭标签页或请求完成后，TCP连接会进行“四次挥手”，具体过程如下。</p>
<p>（1）由客户端先向服务器发送FIN&#x3D;M的指令，随后进入完成等待状态FIN_WAIT_1,表明客户端已经没有再向服务器端发送服务器端发送的数据，但若服务器端此时还有未完成的数据传递，可继续传递数据。</p>
<p>（2）当服务器端收到客户端的FIN报文后，会先发送ack&#x3D;M+1的确认，告知客户端关闭请求已收到，但可能由于服务器端还有未完成的数据传递，所以请客户端维续等待。</p>
<p>（3）当服务器端确认已完成所有数据传递后， 便发送带有FIN&#x3D;N的报文给客户端，准备关闭连接。</p>
<p>（4）客户端收到FIN&#x3D;N的报文后可进行关闭操作，但为保证数据正确性，会回传给服务器端一个确认报文ack&#x3D;N+1,同时服务器端也在等待客户端的最终确认，如果服务器端没有收到报文则会进行重传，只有收到报文后才会真正断开连接。而客户端在发送了确认报文一段时间后， 没有收到服务器端任何信息则认为服务器端连接已关闭，也可关闭客户端信息。连接关闭的关系图如图所示。</p>
<p>​		只有连接建立成功后才可开始进行数据的传递，由于浏览器对同一域名下并发的TCP连接有限制，以及在1.0版本的HTTP协议中，一个资源的下载需对应一个TCP的请求，这样的并发限制又会涉及许多优化方案，我们将在后续章节中进行进一步介绍。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230108092747425.png"></p>
<p>​		这里较为详细地介绍了TCP连接建立和断开的过程，首先让读者有一个网络架构分层的概念，虽然前端工作基本围绕在应用层，但有一个全局的网络视角后，能帮助我们在定位性能瓶颈时更加准确:其次也为了说明影响前端性能体验的因素，不仅是日常编写的代码和使用的资源，网络通信中每个环节的优劣缓急都值得关注。</p>
<h3 id="四、前后端的交互"><a href="#四、前后端的交互" class="headerlink" title="四、前后端的交互"></a>四、前后端的交互</h3><p>​		当TCP连接建立好之后，便可通过HTTP等协议进行前后端的通信，但在实际的网络访问中，并非浏览器与确定IP地址的服务器之间直接通信，往往会在中间加入反向代理服务器。</p>
<h4 id="1-反向代理服务器"><a href="#1-反向代理服务器" class="headerlink" title="1.反向代理服务器"></a>1.反向代理服务器</h4><p>​		对需要提供复杂功能的网站来说，通常单一的服务器资源是很难满足期望的。一般采用的方式是将多个应用服务器组成的集群由反向代理服务器提供给客户端用户使用，这些功能服务器可能具有不同类型，比如文件服务器、邮件服务器及Web应用服务器，同时也可能是相同的Web 服务部署到多个服务器上，以实现负载均衡的效果，反向代理服务器的作用如图所示。</p>
<p>​		反向代理服务器根据客户的请求，从后端服务器上获取资源后提供给客户端。反向代理服务器通常的作用如下:</p>
<ul>
<li>负载均衡。</li>
<li>安全防火墙。</li>
<li>加密及SSL加速。</li>
<li>数据压缩。</li>
<li>解决跨域。</li>
<li>对静态资源缓存。</li>
</ul>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230108094750198.png"></p>
<p>​		常用作反向代理服务器的有Nginx、IIS、Apache，后面会针对Nginx深入介绍一些可用于性能优化的配置。</p>
<h4 id="2-后端处理流程"><a href="#2-后端处理流程" class="headerlink" title="2.后端处理流程"></a>2.后端处理流程</h4><p>​	经反向代理收到请求后，具体的服务器后台处理流程大致如下。</p>
<p>（1）首先会有一层统一的验证环节，如跨城验证、安全校验拦截等。如果发现是不符合规则的请求，则直接返回相应的拒绝报文。</p>
<p>（2）通过验证后才会进入具体的后台程序代码执行阶段，如具体的计算、 数据库查询等。</p>
<p>（3）完成计算后，后台会以一个HTTP响应数据包的形式发送回请求的前端，结束本次请求。</p>
<p>​		只要网站涉及数据交互，这个请求和响应的过程就会频繁发生，而后端处理程序的执行需要花费时间，HTTP协议保证数据交互的同时也对传输细节有所限制。这其中就存在很大的性能优化空间，比如HTTP协议版本的升级、缓存机等。</p>
<h4 id="3-HTTP-相关协议特性"><a href="#3-HTTP-相关协议特性" class="headerlink" title="3.HTTP 相关协议特性"></a>3.HTTP 相关协议特性</h4><p>​		HTTP是建立在传输层TCP协议之上的应用层协议，在TCP层面上存在长连接和短连接的区别。所谓长连接，就是在客户端与服务器端建立的TCP连接上，可以连续发送多个数据包，但需要双方发送心跳检查包来维持这个连接。</p>
<p>​		短连接就是当客户端需要向服务器端发送请求时，会在网络层IP协议之上建立一个TCP连接，当请求发送并收到响应后，则断开此连接。根据前面关于TCP连接建立过程的描述，我们知道如果这个过程频繁发生，就是个很大的性能耗费，所以从HTTP的1.0版本开始对于连接的优化一直在进行。</p>
<p>​		在HTTP 1.0时，默认使用短连接，浏览器的每一次 HTTP操作就会建立一个连接，任务结束则断开连接。</p>
<p>​		在HTTP1.1时，默认使用长连接，在此情况下，当一个网页的打开操作完成时，其中所建立用于传输HTTP的TCP连接并不会断开关闭，客户端后续的请求操作便会继续使用这个已经建立的连接。如果我们对浏览器的开发者工具留心，在查看请求头时会发现一行Connection: keep-alive长连接并非永久保持，它有一个持续时间，可在服务器中进行配置。</p>
<p>​		而在HTTP2.0到来之前，每一个资源的请求都需要开启一个 TCP连接，由于TCP本身有并发数的限制，这样的结果就是，当请求的资源变多时， 速度性能就会明显下降。为此，经常会采用的优化策略包括，将静态资源的请求进行多城名拆分，对于小图标或图片使用雪碧图等。</p>
<p>​		在HTTP2.0之后，便可以在一个TCP连接上请求多个资源，分割成更小的帧请求，其速度性能便会明显上升，所以之前针对HTTP 1.1限制的优化方案也就不再需要了。</p>
<p>​		HTTP2.0除了一个连接可请求多个资源这种多路复用的特性，还有如下一些新特性。</p>
<p>(1)二进制分帧:在应用层和传输层之间，新加入了一个二进制分帧层，以实现低延迟和高吞吐量。</p>
<p>(2)服务器端推送:以往是一个请求带来一 个响应，现在服务器可以向客户端的一个请求发出多个响应，这样便可以实现服务器端主动向客户端推送的功能。</p>
<p>(3)设置请求优先级:服务器会根据请求所设置的优先级，来决定需要多少资源处理该请求。</p>
<p>(4) HTTP头部压缩:减少报文传输体积。</p>
<h4 id="4-浏览器缓存"><a href="#4-浏览器缓存" class="headerlink" title="4.浏览器缓存"></a>4.浏览器缓存</h4><p>​		在基于HTTP的前后端交互过程中，使用缓存可以使性能得到显著提升。具体的缓存策略分为两种:强缓存和协商缓存。</p>
<p>​	 强缓存就是当浏览器判断出本地缓存未过期时，直接读取本地缓存，无须发起HTTP请求，此时状态为: 200 from cache。在HTTP 1.1版本后通过头部的cache-control字段的 max-age 属性值规定的过期时长来判断缓存是否过期失效，这比之前使用expires标识的服务器过期时间更准确而且安全。</p>
<p>​		协商缓存则需要浏览器向服务器发起HTTP请求，来判断浏览器本地缓存的文件是否仍未修改，若未修改则从缓存中读取，此时的状态码为: 304。具体过程是判断浏览器头部if-none-match与服务器短的 e-tag 是否匹配，来判断所访问的数据是否发生更改。这相比HTTP 1.0版本通过last- modified判断上次文件修改时间来说也更加准确。具体的浏览器缓存触发逻辑如图所示。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230108102744303.png"></p>
<p>​		在浏览器缓存中，强缓存优于协商缓存，若强缓存生效则直接使用强缓存，若不生效则再进行协商缓存的请求，由服务器来判断是否使用缓存，如果都失效则重新向服务器发起请求获取资源。本节仅简要说明浏览器缓存的触发过程，由于这部分对性能优化来说比较重要，所以在后续章节也会详细介绍。</p>
<h3 id="五、关键渲染路径"><a href="#五、关键渲染路径" class="headerlink" title="五、关键渲染路径"></a>五、关键渲染路径</h3><p>​		当我们经历了网络请求过程，从服务器获取到了所访问的页面文件后，浏览器如何将这些HTML、CSS及JS文件组织在一起渲染出来呢?</p>
<h4 id="1-构建对象模型"><a href="#1-构建对象模型" class="headerlink" title="1.构建对象模型"></a>1.构建对象模型</h4><p>​		首先浏览器会通过解析HTML和CSS文件，来构建DOM (文档对象模型)和CSSOM (层叠样式表对象模型)，为便于理解，我们以如下HTML内容文件为例，来观察文档对象模型的构建过程。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;title&gt;关键渲染路径&lt;/title&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;你好&lt;span&gt;性能优化&lt;/span&gt;&lt;/p&gt;
        &lt;div&gt;
            &lt;img src=&quot;photo.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​		浏览器接收读取到的HTML文件，其实是文件根据指定编码(UTF-8) 的原始字节，开形如3C 62 6F 79 3E 65 6C 6F 2C 20 73 7…首先需要将字节转换成字符，即原本的代码字符串，接者再将字符串转化为W3C标准规定的令牌结构，所谓令牌就是HTML中不同标签代表不同含义的组规则结构。 然后经过词法分析将令牌转化成定义了属性和规则值的对象，最后将这些标签节点根据HTML表示的父子关系，连接成树形结构，如图所示。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230108103514781.png"></p>
<p>​		DOM树表示文档标记的属性和关系，但未包含其中各元素经过渲染后的外观呈现，这便是接下来CSSOM的职责了，与将HTML文件解析为文档对象模型的过程类似，CSS文件也会首先经历从字节到字符串，然后令牌化及词法分析后构建为层叠样式对象模型。假设CSS文件内容如下：</p>
<pre><code class="css">body&#123; font-size: 16px; &#125;
p&#123; font-weight: bold; &#125;
span&#123; color: red; &#125;
p span&#123; display: none; &#125;
img&#123; float: right; &#125;
</code></pre>
<p>最后构建的CSSOM树如图所示。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230108105702149.png"></p>
<p>​	这两个对象模型的构建过程是会花费时间的，可以通过打开Chrome 浏览器的开发者工具的性能选项卡，查看到对应过程的耗时情况，如图所示。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230108104355600.png" alt="构建过程耗时监控"></p>
<h4 id="2-渲染绘制"><a href="#2-渲染绘制" class="headerlink" title="2.渲染绘制"></a>2.渲染绘制</h4><p>​		当完成文档对象模型和层叠样式表对象模型的构建后，所得到的其实是描述最终渲染页面两个不同方而信息的对象:一个是展示的文档内容， 另一个是文档对象对应的样式规则，接下来就需要将两个对象模型合并为渲染树，渲染树中只包含渲染可见的节点，该HTML文档最终生成的渲染树如图所示。</p>
<p><img src="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20230108110128235.png" alt="渲染树"></p>
<p>渲染绘制的步骤大致如下。</p>
<p>(1)从所生成DOM树的根节点开始向下遍历每个子节点，忽略所有不可见的节点(脚本标记不可见、CSS隐藏不可见)， 因为不可见的节点不会出现在渲染树中。</p>
<p>(2)在CSSOM中为每个可见的子节点找到对应的规则并应用。</p>
<p>(3)布局阶段，根据所得到的渲染树，计算它们在设备视图中的具体位置和大小，这一步输出的是一个“盒模型”。</p>
<p>(4)绘制阶段，将每个节点的具体绘制方式转化为屏幕上的实际像素。</p>
<p>​		此处所举的例子较为简单，读者要明白执行构建渲染树、布局及绘制过程所需要的时间取决于实际文档的大小。文档越大，浏览器需要处理的任务就越多，样式也复杂，绘制需要的时间就越长，所以关键渲染路径执行快慢，将直接影响首屏加载时间的性能指标。</p>
<p>​		当首屏渲染完成后，用户在和网站的交互过程中，有可能通过JavaSeript 代码提供的用户操作接口更改渲染树的结构，一且DOM结构发生改变，这个渲染过程就会重新执行遍。 可见对于关键渲染路径的优化影响的不仅是首屏性能，还有交互性能。本节仅对首屏渲染过程进行了简要描述，其中细节性的优化方案，将会在后续章节中展开介绍。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​		本章通过一 道前端工程师常见的面试题，较为详细地描述了当用户从浏览器的地址栏输入URL后，到页面渲染出来的整个过程。其实不难理解当某个较差的性能体验发生时，很有可能是这个过程中的某个环节出现了过多的性能损耗，后续我们会介绍一些辅 助的性能分析工具来帮助定位具体的性能瓶颈，其实它们也是以页面加载生命周期为“纲”进行逐步分析的，所以我们理解并掌握了这个过程，对具体的优化手段可以做到心中有数。</p>
<p>​		后续的章节安排，就是选取本章介绍的页面生命周期的某个局部环节进行优化以及某些具体的优化技巧和实用工具。如果说这些是前端性能优化的“术”，那么理解页面生命周期就是“道”。</p>
<h3 id="参考文章：web前端性能优化"><a href="#参考文章：web前端性能优化" class="headerlink" title="参考文章：web前端性能优化"></a>参考文章：web前端性能优化</h3>]]></content>
      <categories>
        <category>前端性能优化</category>
        <category>前端页面的生命周期</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>加载优化（图像延迟加载）</title>
    <url>/2023/02/09/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%BE%E5%83%8F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="图像延迟加载"><a href="#图像延迟加载" class="headerlink" title="图像延迟加载"></a>图像延迟加载</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​		相要得到更好的性能体验，只靠资源压缩与恰当的文件格式选型，是很难满足期望的。我们还需要针对资源加载过程进行优化，该环节所要做的内容可概括为分清资源加载的优先级顺序，仅加载当前所必需的资源，并利用系统空闲提前加载可能会用利的资源。这便是本章将要探讨的内容:资源的优先级、延迟加载和预加载。</p>
<p>​		什么是图像的延迟加载，如何高效地实现延迟加载。随着近些年视频资源越来越多的使用，也会捎带介绍视频资源的延迟加载。然后谈谈浏览器对于资源优先级的划分和控制，既然可以通过将非关键资源延迟加载来提升性能，那么是否可以利用系统使用的空闲，预先去加载可能会使用到的资源。</p>
<p>​		本节介绍什么是延迟加载，以及这种优化策略产生的逻辑和实现原理。笔者认为只有先理解了一种原理或方法的缘起流变，才能知道怎样的实现方式是更高效的、更贴近业务场景的。</p>
<h3 id="一、什么是延迟加载"><a href="#一、什么是延迟加载" class="headerlink" title="一、什么是延迟加载"></a>一、什么是延迟加载</h3><p>​		首先来想象一个场景，当浏览一个内容丰富的网站时，比如电商的商品列表页、主流视频网站的节目列表等，由于屏幕尺寸的限制，每次只能查看到视窗中的那部分内容，而要浏览完页面所包含的全部信息，就需要滚动页面，让屏幕视窗依次展示出个页面的所有局部内容。</p>
<p>​		显而易见，对于首屏之外的内容，特别是图片和视频，一方面 由于资源文件很大，若是全部加载完，既费时又费力，还容易阻塞渲染引起卡顿:另一方面，就算加载完成，用户也不一定会滚动屏幕浏览到全部页面内容，如果首屏内容没能吸引住用户，那么很可能整个页面就将遭到关闭。</p>
<p>​		既然如此，本着节约不浪费的原则，在首次打开网站时，应尽量只加载首屏内容所包含的资源，而首屏之外涉及的图片或视频，可以等到用户滚动视窗浏览时再去加载。</p>
<p>​		以上就是延迟加载优化策略的产生逻辑，通过延迟加载“非关键”的图片及视频资源，使得页面内容更快地呈现在用户面前。这里的“非关键”资源指的就是首屏之外的图片或视频资源，相较于文本、脚本等其他资源来说，图片的资源大小不容小觑。这个优化策略在业界已经被广泛使用，接下来笔者就以天猫购物网站的商品列表页为例，具体看看延迟加载是如何实现的，如图所示。</p>
<p><img src="/2023/02/09/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%BE%E5%83%8F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89/image-20230209161519677.png"></p>
<p>​		图左侧是手机端常见的电商购物平台的商品列表页，右侧是其对应的DOM树结构。其中在区域上方，整齐如排比句般的<div>结构，所对应的正是列表页中一行行的商品项。以其中一件商品为例， 展开它的DOM树，直到找到展示该商品图片的<img>标签。为了方便说明，笔者将这个<img>标签的相关细节摘录如下:</p>
<pre><code class="html">&lt;img class=&quot;boom-item-item&quot; autowebp=&quot;false&quot; autopixelratio=&quot;true&quot; forceupdate=&quot;true&quot; data-bindkey=&quot;pic&quot; data-itemid=&quot;700023719087&quot; data-size=&quot;348x348&quot; data-rewrite=&quot;&#123;size:&#39;348x348&#39;&#125;&quot; data-lazy-type=&quot;img&quot; data-lazy-id=&quot;lazyId-11&quot; data-lazy-manager-id=&quot;gLazyM-1&quot; data-in-view-range=&quot;1&quot; src=&quot;//gw.alicdn.com/bao/uploaded/i3/3058655500/O1CN01CyNBBW1qV3AjEusqC_!!0-item_pic.jpg_360x360q75.jpg_.webp&quot;&gt;
</code></pre>
<p>​		这里主要关注其中的src属性，src 属性代表了一个CDN上的图片资源。要知道当<img>标签的src属性被赋予了一一个URL后，它就会立刻向该URL发起资源请求。所以这个商品的<img>标签代表的就是一个商品图片的占位符。</p>
<p>​		接下来我们找到一个位于屏幕视窗外，还未加载的商品图片和已加载的图片，相比较看看二者标签上的属性值有何不同。首先保持左侧页面显示窗口不发生滚动，在DevTools工具的Elements页签下，寻找还未呈现在左侧视窗中的商品项，容易找到它的DOM结构。</p>
<p>​		首先，我们依然关注<img>标签的src属性，这里并不是图片资源的外链URL,取而代之的是一个在图像优化章节中介绍过的Base64图片，与外链URL不同的是，Base64图片已经包含了图片的完全编码，可以直接拿来渲染，而无须发起任何网络请求。</p>
<p>​		这意味着该Base64图片仅仅是在真实图片显示出来前用以占位的，同时注意到所有未展示在页面视窗中的商品，其图片占位src属性值均使用了相同的Base64的值.当页面发生滚动时，之前未出现在视窗中的商品出现在视窗中后，其商品图片的真实URL会被替换到<img>标签的src属性上，进而发起资源请求。</p>
<p>​		我们知道了什么是延迟加载。以及为什么要使用延迟加载，并通过观察一个商品列表页的案例，基本清楚了延迟加载的处理过程，接下来将通过三种方法来具体实现延迟加载。</p>
<h3 id="二、实现图片的延迟加载：传统方式"><a href="#二、实现图片的延迟加载：传统方式" class="headerlink" title="二、实现图片的延迟加载：传统方式"></a>二、实现图片的延迟加载：传统方式</h3><p>​		就是事件监听的方式，通过监听scroll事件与resize 事件，并在事件的回调函费中去判断，需要进行延迟加载的图片是否进入视窗区域。</p>
<p>​		首先根据前面的例子，定义出将要实现延迟加载的<img>标签结构:</p>
<p>我们只需要关注三个属性。</p>
<ul>
<li>class 属性，稍后会在JavaScript中使用类选择器选取需要延迟加载处理的<img>标签。</li>
<li>src属性，加载前的占位符图片，可用Base64图片或低分辨率的图片。</li>
<li>data-src属性，通过该自定义属性保存图片真实的URL外链。</li>
</ul>
<p>假设以三张图片为例进行延迟加载的<img>标签列表如下:</p>
<pre><code class="html">&lt;img class=&quot;lazy&quot; src-&quot;data: image/gif;base64, iVBORwOKGg.. .BJRUErkJgqs-.data-src=&quot;https://res.cloudinary.com/ .../tacos-2x.jpg&quot;width=&quot;385&quot; height=&quot;108&quot; alt=&quot;Some tacos. &quot;&gt;

&lt;img class=&quot;lazy&quot; src=&quot;data:image/gif;base64, iVBORw0KGg. . . BJRU5ErkJggg==&quot; data-src=&quot;https:// res.cloudinary.com/d. . ./modem-2x . png&quot; width=&quot;320&quot; height=&quot;176&quot; alt=&quot;A 56k modem. &quot;&gt;

&lt;img class=&quot;lazy&quot; src=&quot;data:image/gif;base64, iVBORw0KGg.. . BJRU5ErkJggg==&quot; data-src=&quot;https ://res. cloudinary. com/ ../st-paul-2x. jpg&quot; width=&quot;400&quot; height=&quot;267&quot; alt=&quot;A city skyline. &quot;&gt;
</code></pre>
<p>​		具体的JvsSerpr实现逻辑如下，在文档的DOMContentLoaded事件中，添加延迟加载处理逻辑，首先获取class属性名为lazy的所有<img>标签，将这些标签看存在一个名为lazylmages 的数组中，表示需要进行延迟加载但还未加载的图片集合。当一个图片被加载后，便将其从lazylmages数组中移除，直到lazyImages数组为空时，表示所有待延迟加载的图片均已经加载完成，此时便可将页面滚动事件移除。</p>
<p>​		接下来的关键就是判断图片是否出现在视窗中，这里使用了getBoundingClientRect()函数获取元素的相对位置，如图所示。它会返回图片元素的宽width和高height,及其与视窗的相对位置:元素上边缘与屏幕视窗顶部之间的距离top,元素左边缘和屏幕视窗左侧之间的距离left,元素下边缘和屏幕视窗顶部之间的距离bottom 以及元素右边缘和屏幕视窗左侧之间的距离right, 其具体含义可参考示意图，window.innerHeight 表示整个视窗的高度。</p>
<p><img src="/2023/02/09/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%BE%E5%83%8F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89/image-20230209164625464.png" alt="getBoundingClientRect()函数获取元素的相对位置"></p>
<p>​		对于只可上下滚动的页面，判断一个图片 元素是否出现在屏幕视窗中的方法其实显而易见，即当元素上边缘距屏幕视窗顶部的top 值小于整个视窗的高度window.innerHeight时，预加载的事件处理代码如下:</p>
<pre><code class="js">document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;
  //获取所有需要延迟加载的图片
  let lazyImages = [].sllce.call(document.querySelectorAll(&quot;img.1azy&quot;));
  //限制函数频繁被调用
  let active = false;
  const lazyLoad = function () &#123;
    if (active === false) &#123;
      active = true;
      setTimeout(function () &#123;
        lazyImages.forEach(function (lazyImage) &#123;
          //判断图片是否出现在视窗中
          if (
            lazyImage.getBoundingClientRect().top &lt;= window.innerHeight &amp;&amp;
            lazyImage.getBoundingClientRect().bottom &gt;= 0 &amp;&amp;
            getComputedstyle(lazyImage).display !== &quot;none&quot;
          ) &#123;
            // 将真实的图片URL赋值给src属性，发起请求加载资源

            lazyImage.src = lazyImage.dataset.src;

            //图片加载完成后，取消监控以防止重复加载

            lazyImage.classList.remove(&quot;1azy&quot;);

            lazyImages = lazyImages.filter(function (image) &#123;
              return image !== lazyImage;
            &#125;);

            //所有延迟加载图片加载完成后，移除事件触发处理函数

            if (lazyImages.length === 0) &#123;
              document.removeEventListener(&quot;scroll&quot;, lazyLoad);
              window.removeEventListener(&quot;resize&quot;, lazyload);
              window.removeEventListener(&quot;orientationchange&quot;, lazyLoad);
            &#125;
          &#125;
        &#125;);

        active = false;
      &#125;, 200);
    &#125;
  &#125;;

  document.addEventListener(&quot;scroll&quot;, lazyLoad);
  window.addEventListener(&quot;resize&quot;, lazyLoad);
  window.addEventListener(&quot;orientationchange&quot;, lazyLoad);
&#125;);
</code></pre>
<p>​	由于无法控制用户随心所欲地滑动鼠标滚轮，从而造成scroll 事件被触发地过于频繁，导致过多的冗余计算影响性能。所以此处笔者将延迟加载的处理过程置于一个200ms的异步定时器中，并在每次处理完成后，通过修改标志位active 的方式来对方法的执行进行限流。</p>
<p>​		即便如此也有潜在的性能问题，因为重复的setTimeout调用是浪费的，虽然进行了触发限制，但当文档滚动或窗口大小调整时，不论图片是否出现在视窗中，每200ms都会运行一次检查，并且跟踪尚未加载的图片数量，以及完全加载完后，取消绑定滚动事件的处理函数等操作都需要开发者来考虑。</p>
<p>​		如此来看，虽然传统的延迟加载实现方式具有更好的浏览器兼容性，但也存在如上所述不可逾越的性能问题与编码的烦琐性，这便有了下面一种新的实现方式。</p>
<h3 id="三、实现图片的延迟加载-Intersection-Observer方式"><a href="#三、实现图片的延迟加载-Intersection-Observer方式" class="headerlink" title="三、实现图片的延迟加载: Intersection Observer方式"></a>三、实现图片的延迟加载: Intersection Observer方式</h3><p>​		现代浏览器已大多支持了Intersection Observer API,可以通过它来检查目标元素的可见性，这种方式的性能和效率都比较好。</p>
<p>​		关于Intersection Observer的概念和用法，可以参考阅读相关文档，这里用一句话简述:每当因页面滚动或窗口尺寸发生变化，使得目标元素(target) 与设备视窗或其他指定元素产生交集时，便会触发通过Intersection Observer API配置的回调函数，在该回调函数中进行延迟加载的逻辑处理，会比传统方式显得更加简洁而高效。</p>
<p>​		以下便是Intersection Observer 方式的具体实现，此方式仅需创建一个新的Observer,并在类名为lazy的<img>标签进入视窗后触发回调。</p>
<pre><code class="js">document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;
  var lazyImages = [].slice.call(document.querySelectorAll(&quot;img.lazy&quot;));
  //判断浏览器兼容性
  if (
    &quot;Intersectionobserver&quot; in window &amp;&amp;
    &quot;IntersectionObserverEntry&quot; in window &amp;&amp;
    &quot;intersectionRatio&quot; in window.Intersection0bserverEntry.prototype
  ) &#123;
    //新建Intersectionobserver对象，并在其回调函数中实现关键加载逻辑
    let lazyImageObserver = new IntersectionObserver(function (
      entries,observer
    ) &#123;
      entries.forEach(function (entry) &#123;
        //判断图片是否出现在视窗中
        if (entry.isIntersecting) &#123;
          let lazyImage = entry.target;

          lazyImage.src = lazyImage.dataset.src;
          //图片加载完成后，取消监控防止重复加载
          lazyImage.classList.remove(&quot;lazy&quot;);
          lazyImageObserver.unobserve(lazyImage);
        &#125;
      &#125;);
    &#125;);
    lazyImages.forEach(function (lazyImage) &#123;
      lazyImageObserver.observe(lazyImage);
    &#125;);
  &#125;
&#125;);
</code></pre>
<p>​		这种方式判断元素是否出现在视窗中更为简单直观，应在实际开发中尽量使用，但其问题是并非所有浏览器都能兼容。具其体的浏览器兼容情况可在站点上进行查看，根据网站用户的硬件分布情况来权衡是否使用，以及使用后是否需要进行兼容处理。在将这种方式引入项目之前，应当确保已做到以下两点。</p>
<p>（1）做好尽量完备浏览器兼容性检查，对于兼容Intersection Observer API的浏览器，采用这种方式进行处理，而对于不兼容的浏览器，则切换回传统的实现方式进行处理。</p>
<p>（2）使用相应兼容的polyfill插件，在W3C官方Git账号下就有提供。除此之外，还有第三种通过Css属性的实现方案。</p>
<h3 id="四、实现图片的延迟加载：CSS类名方式"><a href="#四、实现图片的延迟加载：CSS类名方式" class="headerlink" title="四、实现图片的延迟加载：CSS类名方式"></a>四、实现图片的延迟加载：CSS类名方式</h3><p>​		这种实现方式通过css的 backgound-image 属性来加载图片，与判断<img>标签src属性是否有要请求图片的URL不同，Css中图片加载的行为建立在浏览器对文档分析基础之上。</p>
<p>​		具体来说，当DOM树、CSSOM树及渲染树生成后，浏览器会去检查CSS以何种方式应用于文档，再决定是否请求外部资源。如果浏览器确定涉及外部资源请求的CSS规则在当前文档中不存在时，便不会去请求该资源。图片列表如下所示:</p>
<pre><code class="html">&lt;div class=&quot;wrapper&quot;&gt;
&lt;div class=&quot;lazy-background one&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;lazy-background two&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;lazy-background three&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>​		具体的实现方式是通过javascript来判断元素是否出现在视窗中的，当在视窗中出现的时候，为其class属性添加visible类名，而在css文件中，为同一类名元素定义出带 .visible和不带.visible的两种包含 background-image规则。</p>
<p>​		不带 .visible的图片规则中的background-image属性可以是低分辨辨率的图片或Base64图片，而带.visible的图片规则中的background-image属性为为希望展示的真实图片URL.</p>
<p>​		具体JavaScript的实现过程如下所示，判断图片元素是否出现在视窗内的逻辑，与上面的Intersection Observer 方式相同。同样为了确保浏览器的兼容性，在实际应用中应确保提供回退方案或polyfill。</p>
<h3 id="五、原生的延迟加载支持"><a href="#五、原生的延迟加载支持" class="headerlink" title="五、原生的延迟加载支持"></a>五、原生的延迟加载支持</h3><p>​		除了上述通过开发者手动实现延迟加载逻辑的方式，从Chrome 75版本开始，已经可以通过 img 和 ifram e标签的loading属性原生支持延迟加载了，loading 属性包含以下三种取值。</p>
<ul>
<li>lazy: 进行延迟加载。</li>
<li>eager: 立即加载。</li>
<li>auto:浏览器自行决定是否进行延迟加载。</li>
</ul>
<p>若不指定任何属性值，loading 默认取值auto。</p>
<p>​		之前讲到延迟加载的独发触发机，都是当目标图像文件经页面滚动出现在屏幕视窗中时，能发对图像资源的请求。但从体验上考虑，这样处理并不完美，因为当图像标签出现在屏幕视窗中时，还只是占位符图像。</p>
<p>​		如果网络存在延迟或图像资源过大，那么它的请求加载过程是可以被用户感知的。更好的做法是在图像即将滚动出现在屏幕视窗之前一段距离， 就开始请求加载图像或iframe中的内容，这样能很好地缩短用户的等待加载时长。</p>
<p>​		兼容性处理:通过使用新技术优化了延迟加载的实现方式，同时也应当注意新技本在不同览器之间的兼容性，在使用前需要对浏览器特性进行检查，如下所示:</p>
<pre><code class="js">&lt;script&gt;
if (&#39;loading&#39; in HTMLImageElement . prototype)&#123;
//浏览器支持loading=&quot;lazy&quot;的延迟加载方式
&#125; else &#123;
//获取其他JavaScript库来实现延迟加载
&#125;
&lt;/script&gt;
</code></pre>
<p>​	当判断浏览器支持通过属性loading&#x3D;”lazy”来进行延迟加载时，我们就在JavaScript处理程序中，将真实图像资源的URL赋值在其src属性上。而对于不支持该属性配置的延迟加载方式，就需要默认将真实图像资源的URL挂在data-src 属性上，仅当延迟加载的滚动事件触发时，才将data-src属性上的值换到src属性上。</p>
<p>​		这也正是我们在传统方式中实现的加载策略，其原因是如果浏览器不支持<img>标签的loading属性，便会立刻发起对src 属性上URL资源的网络请求。当然我们也可以使用CSS类名的方式触发对资源的加载。</p>
<p>&lt; img data-src&#x3D; “photo.jpg” loading&#x3D;”lazy” class&#x3D;”lazyload” alt&#x3D;”photo” &#x2F;&gt;不过对于这种方式，笔者建议等到loading属性在浏览器的稳定版本中被引入后，再在项目的生产环境中使用。</p>
<h3 id="参考书籍：前端性能优化"><a href="#参考书籍：前端性能优化" class="headerlink" title="参考书籍：前端性能优化"></a>参考书籍：前端性能优化</h3>]]></content>
      <categories>
        <category>前端性能优化</category>
        <category>加载优化（图像延迟加载)</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>加载优化</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式设计</title>
    <url>/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h1><blockquote>
<p>自适应、响应式、弹性布局、屏幕适配，这是四个独立不同的概念。</p>
</blockquote>
<h3 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h3><p>自适应：多端请求时返回不同的页面，服务端需要准备多套程序或者多套模板。</p>
<p>响应式：主要是利用css媒体查询使得在不同屏幕大小下，页面有不同表现，主要是元素布局等变化。</p>
<p>弹性布局：主要是利用百分比设置元素宽度，浮动还有flex设置元素布局等等。</p>
<p>屏幕适配：主要是应用于对完美还原设计稿尺寸有要求的页面，主要是利用 rem、vm等技术。（类似于750px的设计稿是一张图片，这张图片无论怎么缩放，都能显示很好的效果，现在我们的网页也需要图片这种等比缩放的效果，这么说你应该能体会到了。当然了，这里还需要顺便解决高清屏显示的问题。）</p>
<h3 id="二、技术方案怎么选"><a href="#二、技术方案怎么选" class="headerlink" title="二、技术方案怎么选"></a>二、技术方案怎么选</h3><ol>
<li>简单 &amp; 对速度不敏感和对代码精简没要求 &amp; 预算紧张</li>
</ol>
<p>​      响应式，一套代码解决多端</p>
<p>​     展示阅读类 交互逻辑简单且少，且移动端与pc端内容差异不大，如新闻站，企业官网</p>
<ol start="2">
<li>复杂 &amp; 对精简代码和速度有要求 预算充足</li>
</ol>
<p>​      做两套 根据请求头自适应返回 web端 手机端 （后端可共用，也可不共用，如不同模块或者部署不同应用）</p>
<p>​     功能类，交互逻辑复杂且多，如电商，社交类</p>
<ol start="3">
<li>复杂 &amp; 有多终端适配要求 &amp; 对细节有一定要求 追求用户体验 &amp; 预算豪华</li>
</ol>
<p>​       做两套 移动端用适配做以满足不同移动终端</p>
<ol start="4">
<li>复杂 &amp; 细节要求和技术追求极高 &amp; 追求极致完美的用户体验 &amp; 不差钱 （艺术家、哲学家）</li>
</ol>
<p>​      多端 多套 响应式 适配 多技术相结合</p>
<h3 id="三、各种方案的详细讲解"><a href="#三、各种方案的详细讲解" class="headerlink" title="三、各种方案的详细讲解"></a>三、各种方案的详细讲解</h3><h4 id="1-媒体查询"><a href="#1-媒体查询" class="headerlink" title="1.媒体查询"></a>1.媒体查询</h4><p>要想实现css屏幕大小自适应，首先得引入 CSS3 @media 媒体查询器：</p>
<p>media的使用和规则：</p>
<p>　　①被链接文档将显示在什么设备上。</p>
<p>　　②用于为不同的媒介类型规定不同的样式。</p>
<p>语法： </p>
<pre><code class="css">@media 设备名 only （选取条件） not （选取条件） and（设备选取条件），设备二&#123;sRules&#125;
</code></pre>
<p>实例：</p>
<pre><code class="css">/* 这是匹配横屏的状态，横屏时的css代码 */

@media all and (orientation :landscape)&#123;&#125;

/* 这是匹配竖屏的状态，竖屏时的css代码 */

@media all and (orientation :portrait)&#123;&#125;

@media X and (min-width:200px)&#123;&#125;
/*X为媒体类型---&gt;比如print/screen/TV等等*/

/* 宽度大于600px小于960之间时，隐藏footer结构 */

@media all and (min-height:640px) and (max-height:960px)&#123;
   　　　footer&#123;display:none;&#125;
&#125;
</code></pre>
<p>在实际应用的时候，首先得在HTML的头文件<head>里上加入以下代码：</p>
<pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;
</code></pre>
<p>解释：　　　</p>
<p>width &#x3D; device-width：宽度等于当前设备的宽度</p>
<p>initial-scale：初始的缩放比例（默认设置为1.0） </p>
<p>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）  </p>
<p>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） </p>
<p>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）</p>
<p>因为media的类型很多，这里就发MDN的对应链接了：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media</a></p>
<p>下面是media类型的screen（用于电脑屏幕，平板电脑，智能手机等）：</p>
<p><strong>css自适应屏幕大小大方法：</strong></p>
<pre><code class="css">@media screen and (min-width: 320px) and (max-width: 1156px)&#123;

              .site-bg-dl &#123;
              position: fixed;
              height: 100%;
              width: 100%;
              z-index: 0;
              background-image: url(bjxzfwzx/images/bj1.png);
              background-size: cover;
              background-repeat: no-repeat;
              background-attachment: fixed;
              background-size:100% 100%;
              -moz-background-size:100% 100%;
            &#125;
&#125;
</code></pre>
<p>解释：</p>
<p>告诉浏览器当屏幕大于320px，并小于1156px下执行此代码；</p>
<p>在css中添加如下内容 可以分别定制不同屏幕的显示样式：</p>
<pre><code class="css">/* 大屏幕 ：大于等于1200px*/
@media (min-width: 1200px) &#123; ... &#125;

/*默认*/
@media (min-width: 980px)&#123;...&#125;

/* 平板电脑和小屏电脑之间的分辨率 */
@media (min-width: 768px) and (max-width: 979px) &#123; ... &#125;

/* 横向放置的手机和竖向放置的平板之间的分辨率 */
@media (max-width: 767px) &#123; ... &#125;

/* 横向放置的手机及分辨率更小的设备 */
@media (max-width: 480px) &#123; ... &#125;
</code></pre>
<p>Media Queries Level 4 引入了一种新的范围语法，在测试接受范围的任何特性时允许更简洁的媒体查询，如下面的示例所示：</p>
<pre><code class="css">@media (height &gt; 600px) &#123;
  body &#123;
    line-height: 1.4;
  &#125;
&#125;

@media (400px &lt;= width &lt;= 700px) &#123;
  body &#123;
    line-height: 1.4;
  &#125;
&#125;
</code></pre>
<h4 id="2-如何选择屏幕大小分割点"><a href="#2-如何选择屏幕大小分割点" class="headerlink" title="2.如何选择屏幕大小分割点"></a>2.如何选择屏幕大小分割点</h4><p>如何确定媒体查询的分割点也是一个开发中会遇到的问题，下面是市场上的移动设备和电脑屏幕分辨率的分布情况，可以发现不同品牌和型号的设备屏幕分辨率一般都不一样</p>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213140505623.png"></p>
<p>如果我们选择<code>600px</code>,<code>900px</code>,<code>1200px</code>,<code>1800px</code>作为分割点，可以适配到常见的14个机型：</p>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213140556282.png"></p>
<p>而作为曾经典型的响应式布局框架，<code>Bootstrap</code>是怎么进行断点的呢？</p>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213140637166.png"></p>
<p>上面的分割方案不一定满足项目中的实际需求，我们可以先用跨度大的分割点进行分割，如果出现不适配的情况可以再根据实际情况增加新的分割点。</p>
<h4 id="3-移动优先-or-PC优先"><a href="#3-移动优先-or-PC优先" class="headerlink" title="3.移动优先 or PC优先"></a>3.移动优先 or PC优先</h4><p>不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是<code>min-width</code>，PC端优先使用的<code>max-width</code>。</p>
<p>移动优先：</p>
<pre><code class="css">/* iphone6 7 8 */
body &#123;
    background-color: yellow;
&#125;
/* iphone 5 */
@media screen and (max-width: 320px) &#123;
    body &#123;
      background-color: red;
    &#125;
&#125;
/* iphoneX */
@media screen and (min-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    body &#123;
      background-color: #0FF000;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (min-width: 414px) &#123;
    body &#123;
      background-color: blue;
    &#125;
&#125;
/* ipad */
@media screen and (min-width: 768px) &#123;
    body &#123;
      background-color: green;
    &#125;
&#125;
/* ipad pro */
@media screen and (min-width: 1024px) &#123;
    body &#123;
      background-color: #FF00FF;
    &#125;
&#125;
/* pc */
@media screen and (min-width: 1100px) &#123;
    body &#123;
      background-color: black;
    &#125;
&#125;
</code></pre>
<p>pc优先：</p>
<pre><code class="css">/* pc width &gt; 1024px */
    body &#123;
        background-color: yellow;
    &#125;
/* ipad pro */
@media screen and (max-width: 1024px) &#123;
    body &#123;
        background-color: #FF00FF;
    &#125;
&#125;
/* ipad */
@media screen and (max-width: 768px) &#123;
    body &#123;
        background-color: green;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (max-width: 414px) &#123;
    body &#123;
        background-color: blue;
    &#125;
&#125;
/* iphoneX */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    body &#123;
        background-color: #0FF000;
    &#125;
&#125;
/* iphone6 7 8 */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123;
    body &#123;
        background-color: #0FF000;
    &#125;
&#125;
/* iphone5 */
@media screen and (max-width: 320px) &#123;
    body &#123;
        background-color: #0FF000;
    &#125;
&#125;
</code></pre>
<h4 id="4-百分比布局"><a href="#4-百分比布局" class="headerlink" title="4.百分比布局"></a>4.百分比布局</h4><p>通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap里面的栅格系统就是利用百分比来定义元素的宽高，<code>CSS3</code>支持最大最小高，可以将百分比和<code>max(min)</code>一起结合使用来定义元素在不同设备下的宽高。</p>
<pre><code class="css">/* pc width &gt; 1100px */
html, body &#123; margin: 0;padding: 0;width: 100%;height: 100%;&#125;
aside &#123;
    width: 10%;
    height: 100%;
    background-color: red;
    float: left;
&#125;
main &#123;
    height: 100%;
    background-color: blue;
    overflow: hidden;
&#125;
/* ipad pro */
@media screen and (max-width: 1024px) &#123;
    aside &#123;
      width: 8%;
      background-color: yellow;
    &#125;
&#125;
/* ipad */
@media screen and (max-width: 768px) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 10%;
      background-color: green;
    &#125;
    main &#123;
      height: calc(100vh - 10%);
      background-color: red;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (max-width: 414px) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 5%;
      background-color: yellow;
    &#125;
    main &#123;
      height: calc(100vh - 5%);
      background-color: red;
    &#125;
&#125;
/* iphoneX */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 10%;
      background-color: blue;
    &#125;
    main &#123;
      height: calc(100vh - 10%);
      background-color: red;
    &#125;
&#125;
/* iphone6 7 8 */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 3%;
      background-color: black;
    &#125;
    main &#123;
      height: calc(100vh - 3%);
      background-color: red;
    &#125;
&#125;
/* iphone5 */
@media screen and (max-width: 320px) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 7%;
      background-color: green;
    &#125;
    main &#123;
      height: calc(100vh - 7%);
      background-color: red;
    &#125;
&#125;
</code></pre>
<p>但是我们必须要弄清楚css中子元素的百分比到底是相对谁的百分比。</p>
<p>子元素的<code>height</code>或<code>width</code>中使用百分比，是相对于子元素的直接父元素，<code>width</code>相对于父元素的<code>width</code>，<code>height</code>相对于父元素的<code>height</code>；子元素的<code>top</code>和<code>bottom</code>如果设置百分比，则相对于直接非<code>static</code>定位(默认定位)的父元素的高度，同样子元素的<code>left</code>和<code>right</code>如果设置百分比，则相对于直接非<code>static</code>定位(默认定位的)父元素的宽度；子元素的<code>padding</code>如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的<code>width</code>，而与父元素的<code>height</code>无关。跟<code>padding</code>一样，<code>margin</code>也是如此，子元素的<code>margin</code>如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的<code>width</code>；<code>border-radius</code>不一样，如果设置<code>border-radius</code>为百分比，则是相对于自身的宽度，除了<code>border-radius</code>外，还有比如<code>translate</code>、<code>background-size</code>等都是相对于自身的；</p>
<p>从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：</p>
<ul>
<li>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。</li>
<li>可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如<code>width</code>和<code>height</code>相对于父元素的<code>width</code>和<code>height</code>，而<code>margin</code>、<code>padding</code>不管垂直还是水平方向都相对比父元素的宽度、<code>border-radius</code>则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。</li>
</ul>
<h4 id="5-rem布局"><a href="#5-rem布局" class="headerlink" title="5.rem布局"></a>5.rem布局</h4><p><code>REM</code>是<code>CSS3</code>新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。<code>rem</code>单位都是相对于根元素html的<code>font-size</code>来决定大小的,根元素的<code>font-size</code>相当于提供了一个基准，当页面的size发生变化时，只需要改变<code>font-size</code>的值，那么以<code>rem</code>为固定单位的元素的大小也会发生响应的变化。 因此，如果通过<code>rem</code>来实现响应式的布局，只需要根据视图容器的大小，动态的改变<code>font-size</code>即可（而<code>em</code>是相对于父元素的）。</p>
<p><strong>rem响应式的布局思想：</strong></p>
<ul>
<li>一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值</li>
<li>高度值可以设置固定值，设计稿有多大，我们就严格有多大</li>
<li>所有设置的固定值都用<code>rem</code>做单位（首先在HTML总设置一个基准值：<code>px</code>和<code>rem</code>的对应比例，然后在效果图上获取<code>px</code>值，布局的时候转化为<code>rem</code>值)</li>
<li>js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了。</li>
</ul>
<p><strong>rem布局的缺点：</strong></p>
<p>在响应式布局中，必须通过js来动态控制根元素<code>font-size</code>的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变<code>font-size</code>的代码放在<code>css</code>样式之前</p>
<pre><code class="javascript">/*上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/
function refreshRem() &#123;
    var docEl = doc.documentElement;
    var width = docEl.getBoundingClientRect().width;
    var rem = width / 10;
    docEl.style.fontSize = rem + &#39;px&#39;;
    flexible.rem = win.rem = rem;
&#125;
win.addEventListener(&#39;resize&#39;, refreshRem);
</code></pre>
<p><code>REM</code>布局也是目前多屏幕适配的最佳方式。默认情况下我们html标签的<code>font-size</code>为16px,我们利用媒体查询，设置在不同设备下的字体大小。</p>
<pre><code class="css">/* pc width &gt; 1100px */
html&#123; font-size: 100%;&#125;
body &#123;
    background-color: yellow;
    font-size: 1.5rem;
&#125;
/* ipad pro */
@media screen and (max-width: 1024px) &#123;
    body &#123;
      background-color: #FF00FF;
      font-size: 1.4rem;
    &#125;
&#125;
/* ipad */
@media screen and (max-width: 768px) &#123;
    body &#123;
      background-color: green;
      font-size: 1.3rem;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (max-width: 414px) &#123;
    body &#123;
      background-color: blue;
      font-size: 1.25rem;
    &#125;
&#125;
/* iphoneX */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    body &#123;
      background-color: #0FF000;
      font-size: 1.125rem;
    &#125;
&#125;
/* iphone6 7 8 */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123;
    body &#123;
      background-color: #0FF000;
      font-size: 1rem;
    &#125;
&#125;
/* iphone5 */
@media screen and (max-width: 320px) &#123;
    body &#123;
      background-color: #0FF000;
      font-size: 0.75rem;
    &#125;
&#125;
</code></pre>
<h4 id="6-视口单位"><a href="#6-视口单位" class="headerlink" title="6.视口单位"></a>6.视口单位</h4><p><code>css3</code>中引入了一个新的单位<code>vw/vh</code>，与视图窗口有关，<code>vw</code>表示相对于视图窗口的宽度，<code>vh</code>表示相对于视图窗口高度，除了<code>vw</code>和<code>vh</code>外，还有<code>vmin</code>和<code>vmax</code>两个相关的单位。各个单位具体的含义如下：</p>
<table>
<thead>
<tr>
<th align="center">单位</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vw</td>
<td align="center">相对于视窗的宽度，1vw 等于视口宽度的1%，即视窗宽度是100vw</td>
</tr>
<tr>
<td align="center">vh</td>
<td align="center">相对于视窗的高度，1vh 等于视口高度的1%，即视窗高度是100vh</td>
</tr>
<tr>
<td align="center">vmin</td>
<td align="center">vw和vh中的较小值</td>
</tr>
<tr>
<td align="center">vmax</td>
<td align="center">vw和vh中的较大值</td>
</tr>
</tbody></table>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213142123454.png"></p>
<p>用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况）。例如，在桌面端浏览器视口尺寸为650px，那么 1vw &#x3D; 650 * 1% &#x3D; 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。</p>
<p>那么vw或者vh很类似百分比单位。vw和%的区别为：</p>
<table>
<thead>
<tr>
<th align="center">单位</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%</td>
<td align="center">大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</td>
</tr>
<tr>
<td align="center">vw&#x2F;vh</td>
<td align="center">相对于视窗的尺寸</td>
</tr>
</tbody></table>
<p>从对比中我们可以发现，<code>vw</code>单位与百分比类似，单确有区别，前面我们介绍了百分比单位的换算困难，这里的<code>vw</code>更像”理想的百分比单位”。任意层级元素，在使用<code>vw</code>单位的情况下，1vw都等于视图宽度的百分之一。</p>
<p>使用视口单位来实现响应式有两种做法：</p>
<h5 id="1-仅使用vw作为CSS单位"><a href="#1-仅使用vw作为CSS单位" class="headerlink" title="1.仅使用vw作为CSS单位"></a>1.仅使用vw作为CSS单位</h5><ul>
<li><p>对于设计稿的尺寸转换为为单位，我们使用<code>Sass</code>函数编译</p>
<pre><code class="css">//iPhone 6尺寸作为设计稿基准
$vm_base: 375; 
@function vw($px) &#123;
    @return ($px / 375) * 100vw;
&#125;
</code></pre>
</li>
<li><p>无论是文本还是布局宽度、间距等都使用<code>vw</code>作为单位</p>
<pre><code class="css">.mod_nav &#123;
    background-color: #fff;
    &amp;_list &#123;
        display: flex;
        padding: vm(15) vm(10) vm(10); // 内间距
        &amp;_item &#123;
            flex: 1;
            text-align: center;
            font-size: vm(10); // 字体大小
            &amp;_logo &#123;
                display: block;
                margin: 0 auto;
                width: vm(40); // 宽度
                height: vm(40); // 高度
                img &#123;
                    display: block;
                    margin: 0 auto;
                    max-width: 100%;
                &#125;
            &#125;
            &amp;_name &#123;
                margin-top: vm(2);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>1物理像素线（也就是普通屏幕下1px,高清屏幕下0.5px的情况）采用<code>transform</code>属性<code>scale</code>实现</p>
<pre><code class="css">.mod_grid &#123;
    position: relative;
    &amp;::after &#123;
        // 实现1物理像素的下边框线
        content: &#39;&#39;;
        position: absolute;
        z-index: 1;
        pointer-events: none;
        background-color: #ddd;
        height: 1px;
        left: 0;
        right: 0;
        top: 0;
        @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123;
            -webkit-transform: scaleY(0.5);
            -webkit-transform-origin: 50% 0%;
        &#125;
    &#125;
    ...
&#125;
</code></pre>
</li>
<li><p>对于需要保持宽高比的图，应该用<code>padding-top</code>实现</p>
<pre><code class="css">.mod_banner &#123;
    position: relative;
    padding-top: percentage(100/700); // 使用padding-top
    height: 0;
    overflow: hidden;
    img &#123;
        width: 100%;
        height: auto;
        position: absolute;
        left: 0;
        top: 0; 
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h5 id="2-搭配vw和rem"><a href="#2-搭配vw和rem" class="headerlink" title="2.搭配vw和rem"></a>2.搭配vw和rem</h5><p>虽然采用<code>vw</code>适配后的页面效果很好，但是它是利用视口单位实现的布局，依赖视口大小而自动缩放，无论视口过大还是过小，它也随着时候过大或者过小，失去了最大最小宽度的限制，此时我们可以结合<code>rem</code>来实现布局</p>
<ul>
<li><p>给根元素大小设置随着视口变化而变化的<code>vw</code>单位，这样就可以实现动态改变其大小</p>
</li>
<li><p>限制根元素字体大小的最大最小值，配合<code>body</code>加上最大宽度和最小宽度</p>
<pre><code class="scss">// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推
$vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值
@function rem($px) &#123;
     @return ($px / $vm_fontsize ) * 1rem;
&#125;
// 根元素大小使用 vw 单位
$vm_design: 750;
html &#123;
    font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; 
    // 同时，通过Media Queries 限制根元素最大最小值
    @media screen and (max-width: 320px) &#123;
        font-size: 64px;
    &#125;
    @media screen and (min-width: 540px) &#123;
        font-size: 108px;
    &#125;
&#125;
// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小
body &#123;
    max-width: 540px;
    min-width: 320px;
&#125;
</code></pre>
</li>
</ul>
<h4 id="7-图片响应式"><a href="#7-图片响应式" class="headerlink" title="7.图片响应式"></a>7.图片响应式</h4><p>这里的图片响应式包括两个方面，一个就是大小自适应，这样能够保证图片在不同的屏幕分辨率下出现压缩、拉伸的情况；一个就是根据不同的屏幕分辨率和设备像素比来尽可能选择高分辨率的图片，也就是当在小屏幕上不需要高清图或大图，这样我们用小图代替，就可以减少网络带宽了。</p>
<h5 id="1-使用max-width（图片自适应）"><a href="#1-使用max-width（图片自适应）" class="headerlink" title="1.使用max-width（图片自适应）:"></a>1.使用max-width（图片自适应）:</h5><p>图片自适应意思就是图片能随着容器的大小进行缩放，可以采用如下代码：</p>
<pre><code class="css">img &#123;
    display: inline-block;
    max-width: 100%;
    height: auto;
&#125;
</code></pre>
<p><code>inline-block</code> 元素相对于它周围的内容以内联形式呈现，但与内联不同的是，这种情况下我们可以设置宽度和高度。 <code>max-width</code>保证了图片能够随着容器的进行等宽扩充（即保证所有图片最大显示为其自身的 100%。此时，如果包含图片的元素比图片固有宽度小，图片会缩放占满最大可用空间），而<code>height</code>为<code>auto</code>可以保证图片进行等比缩放而不至于失真。如果是背景图片的话要灵活运用<code>background-size</code>属性。</p>
<p>那么为什么不能用<code>width：100%</code>呢？因为这条规则会导致它显示得跟它的容器一样宽。在容器比图片宽得多的情况下，图片会被无谓地拉伸。</p>
<h5 id="2-使用srcset"><a href="#2-使用srcset" class="headerlink" title="2.使用srcset"></a>2.使用srcset</h5><pre><code class="ini">&lt;img srcset=&quot;photo_w350.jpg 1x, photo_w640.jpg 2x&quot; src=&quot;photo_w350.jpg&quot; alt=&quot;&quot;&gt;
</code></pre>
<p>如果屏幕的dpi &#x3D; 1的话则加载1倍图，而dpi &#x3D; 2则加载2倍图，手机和mac基本上dpi都达到了2以上，这样子对于普通屏幕来说不会浪费流量，而对于视网膜屏来说又有高清的体验。</p>
<p>如果浏览器不支持<code>srcset</code>，则默认加载src里面的图片。</p>
<p>但是你会发现实际情况并不是如此，在Mac上的Chrome它会同时加载<code>srcset</code>里面的那张2x的，还会再去加载src里面的那张，加载两张图片。顺序是先把所有<code>srcset</code>里面的加载完了，再去加载src的。这个策略比较奇怪，它居然会加载两张图片，如果不写src，则不会加载两张，但是兼容性就没那么好。这个可能是因为浏览器认为，既然有<code>srcset</code>就不用写src了，如果写了src，用户可能是有用的。而使用<code>picture</code>就不会加载两张</p>
<h5 id="3-使用background-image"><a href="#3-使用background-image" class="headerlink" title="3.使用background-image"></a>3.使用background-image</h5><pre><code class="css">.banner&#123;
  background-image: url(/static/large.jpg);
&#125;

@media screen and (max-width: 767px)&#123;
  background-image: url(/static/small.jpg);
&#125;
</code></pre>
<h5 id="4-使用picture标签"><a href="#4-使用picture标签" class="headerlink" title="4.使用picture标签"></a>4.使用picture标签</h5><p><a href="https://link.juejin.im/?target=https://scottjehl.github.io/picturefill/">picturefill.min.js</a> ：解决IE等浏览器不支持 的问题</p>
<pre><code class="xml">&lt;picture&gt;
    &lt;source srcset=&quot;banner_w1000.jpg&quot; media=&quot;(min-width: 801px)&quot;&gt;
    &lt;source srcset=&quot;banner_w800.jpg&quot; media=&quot;(max-width: 800px)&quot;&gt;
    &lt;img src=&quot;banner_w800.jpg&quot; alt=&quot;&quot;&gt;
&lt;/picture&gt;

&lt;!-- picturefill.min.js 解决IE等浏览器不支持 &lt;picture&gt; 的问题 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/vendor/picturefill.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><code>picture</code>必须要写img标签，否则无法显示，对<code>pictur</code>e的操作最后都是在img上面，例如onload事件是在img标签触发的，<code>picture</code>和<code>source</code>是不会进行layout的，它们的宽和高都是0。</p>
<p>另外使用<code>source</code>，还可以对图片格式做一些兼容处理：</p>
<pre><code class="ini">&lt;picture&gt;
    &lt;source type=&quot;image/webp&quot; srcset=&quot;banner.webp&quot;&gt;
    &lt;img src=&quot;banner.jpg&quot; alt=&quot;&quot;&gt;
&lt;/picture&gt;
</code></pre>
<p><strong>总结</strong>：响应式布局的实现可以通过媒体查询+<code>px</code>,媒体查询+百分比，媒体查询+<code>rem</code>+<code>js</code>,<code>vm/vh</code>,<code>vm/vh</code> +<code>rem</code>这几种方式来实现。但每一种方式都是有缺点的，媒体查询需要选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配，另外用户体验也不友好，布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。通过百分比来适配首先是计算麻烦，第二各个属性中如果使用百分比，其相对的元素的属性并不是唯一的，这样就造成我们使用百分比单位容易使布局问题变得复杂。通过采用<code>rem</code>单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得<code>CSS</code>与<code>JS</code> 耦合了在一起。通过利用纯<code>css</code>视口单位实现适配的页面，是既能解决响应式断层问题，又能解决脚本依赖的问题的，但是兼容性还没有完全能结构接受。</p>
<h3 id="四、响应式布局的成型方案"><a href="#四、响应式布局的成型方案" class="headerlink" title="四、响应式布局的成型方案"></a>四、响应式布局的成型方案</h3><p>现在的css，UI框架等都已经考虑到了适配不同屏幕分辨率的问题，实际项目中我们可以直接使用这些新特性和框架来实现响应式布局。可以有以下选择方案：</p>
<ul>
<li>利用上面的方法自己来实现，比如CSS3 Media Query,rem，vw等</li>
<li>Flex弹性布局，兼容性较差</li>
<li>Grid网格布局，兼容性较差</li>
<li>Columns栅格系统，往往需要依赖某个UI库，如Bootstrap</li>
</ul>
<h3 id="五、响应式布局的要点"><a href="#五、响应式布局的要点" class="headerlink" title="五、响应式布局的要点"></a>五、响应式布局的要点</h3><p>在实际项目中，我们可能需要综合上面的方案，比如用<code>rem</code>来做字体的适配，用<code>srcset</code>来做图片的响应式，宽度可以用<code>rem</code>，<code>flex</code>，栅格系统等来实现响应式，然后可能还需要利用媒体查询来作为响应式布局的基础，因此综合上面的实现方案，项目中实现响应式布局需要注意下面几点：</p>
<ul>
<li>设置viewport</li>
<li>媒体查询</li>
<li>字体的适配（字体单位）</li>
<li>百分比布局</li>
<li>图片的适配（图片的响应式）</li>
<li>结合flex，grid，BFC，栅格系统等已经成型的方案</li>
</ul>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[响应式设计]: 	“<a href="https://juejin.cn/post/6844903814332432397">https://juejin.cn/post/6844903814332432397</a> “</p>
]]></content>
      <categories>
        <category>响应式设计</category>
        <category>响应式设计</category>
      </categories>
      <tags>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全git</title>
    <url>/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（git命令）"><a href="#前端面试题大全（git命令）" class="headerlink" title="前端面试题大全（git命令）"></a>前端面试题大全（git命令）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git是什么？"><a href="#git是什么？" class="headerlink" title="git是什么？"></a>git是什么？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>git，是一个分布式版本控制软件，最初目的是为更好地管理<code>Linux</code>内核开发而设计</p>
<p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32393234306634302d663739632d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>项目开始，只有一个原始版仓库，别的机器可以<code>clone</code>这个原始版本库，那么所有<code>clone</code>的机器，它们的版本库其实都是一样的，并没有主次之分</p>
<p>所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库<code>clone</code>一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交</p>
<p><code>github</code>实际就可以充当这个服务器角色，其是一个开源协作社区，提供<code>Git</code>仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目</p>
<h4 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h4><p>当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的</p>
<p><code>Git</code> 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，<code>git</code>能够知道</p>
<p><code>Git </code>用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来，如下：</p>
<pre><code class="ini">24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre>
<p>当我们修改文件的时候，<code>git</code>就会修改文件的状态，可以通过<code>git status</code>进行查询，状态情况如下：</p>
<ul>
<li>已修改（modified）：表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交（committed）：表示数据已经安全的保存在本地数据库中。</li>
</ul>
<p>文件状态对应的，不同状态的文件在<code>Git</code>中处于不同的工作区域，主要分成了四部分：</p>
<ul>
<li>工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本</li>
<li>暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中</li>
<li>本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库</li>
<li>远程仓库：远程的仓库，如 github</li>
</ul>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33323733633961302d663739632d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="三、命令"><a href="#三、命令" class="headerlink" title="三、命令"></a>三、命令</h4><p>从上图可以看到，<code>git</code>日常简单的使用就只有上图6个命令：</p>
<ul>
<li>add</li>
<li>commit</li>
<li>push</li>
<li>pull</li>
<li>clone</li>
<li>checkout</li>
</ul>
<p>但实际上还有很多命令，如果想要熟练使用，还有60个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力</p>
<h3 id="Git中-fork-clone-branch这三个概念，有什么区别"><a href="#Git中-fork-clone-branch这三个概念，有什么区别" class="headerlink" title="Git中 fork, clone,branch这三个概念，有什么区别?"></a>Git中 fork, clone,branch这三个概念，有什么区别?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p><code>fork</code>，英语翻译过来就是叉子，动词形式则是分叉，如下图，从左到右，一条直线变成多条直线</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61643034616465302d663761642d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>转到<code>git</code>仓库中，<code>fork</code>则可以代表分叉、克隆 出一个（仓库的）新拷贝</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62346233313435302d663761642d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>包含了原来的仓库（即upstream repository，上游仓库）所有内容，如分支、Tag、提交</p>
<p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p>
<h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p>
<p>执行<code>clone</code>命令后，会在当前目录下创建一个名为<code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p>
<p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p>
<h5 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h5><p><code>branch</code>，译为分支，其作用简单而言就是开启另一个分支， 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线</p>
<p><code>Git</code> 处理分支的方式十分轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷</p>
<p>在我们开发中，默认只有一条<code>master</code>分支，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37666138653963302d663932332d313165622d393931642d3333346664333166303230312e706e67.png">]</p>
<p>通过<code>git branch </code>可以创建一个分支，但并不会自动切换到新分支中去</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38396566643536302d663932332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>通过<code>git checkout</code>可以切换到另一个<code>testing</code>分支</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39316431636566302d663932332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h4><h5 id="fork-1"><a href="#fork-1" class="headerlink" title="fork"></a>fork</h5><p>当你在<code>github</code>发现感兴趣开源项目的时候，可以通过点击<code>github</code>仓库中右上角<code>fork</code>标识的按钮，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095419097.png"></p>
<p>点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的<code>github</code>仓库中，而你本地仓库是不会存在任何更改</p>
<p>然后你就可以通过<code>git clone</code>对你这个复制的远程仓库进行克隆</p>
<p>后续更改任何东西都可以在本地完成，如<code>git add</code>、<code>git commit</code>一系列的操作，然后通过<code>push</code>命令推到自己的远程仓库</p>
<p>如果希望对方接受你的修改，可以通过发送<code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095452040.png"></p>
<p>整体流程如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63656438636531302d663761642d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="clone-1"><a href="#clone-1" class="headerlink" title="clone"></a>clone</h5><p>在<code>github</code>中，开源项目右侧存在<code>code</code>按钮，点击后则会显示开源项目<code>url</code>信息，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095540516.png"></p>
<p>通过<code>git clone xxx</code>则能完成远程项目的下载</p>
<h5 id="branch-1"><a href="#branch-1" class="headerlink" title="branch"></a>branch</h5><p>可通过<code>git branch</code>进行查看当前的分支状态，</p>
<p>如果给了<code>--list</code>，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号</p>
<p>以及通过<code>git branch</code>创建一个新的分支出来</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>其三者区别如下：</p>
<ul>
<li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li>
<li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li>
<li>branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支</li>
</ul>
<h3 id="Git常用的命令有哪些？"><a href="#Git常用的命令有哪些？" class="headerlink" title="Git常用的命令有哪些？"></a>Git常用的命令有哪些？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p><code>git </code>的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66653135303532302d663761662d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的<code>git </code>命令</p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p><code>Git </code>自带一个 <code>git config</code> 的工具来帮助设置控制 <code>Git </code>外观和行为的配置变量，在我们安装完<code>git</code>之后，第一件事就是设置你的用户名和邮件地址</p>
<p>后续每一个提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改</p>
<p>设置提交代码时的用户信息命令如下：</p>
<ul>
<li>git config [–global] user.name “[name]”</li>
<li>git config [–global] user.email “[email address]”</li>
</ul>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>一个<code>git</code>项目的初始有两个途径，分别是：</p>
<ul>
<li>git init [project-name]：创建或在当前目录初始化一个git代码库</li>
<li>git clone url：下载一个项目和它的整个代码历史</li>
</ul>
<h5 id="日常基本操作"><a href="#日常基本操作" class="headerlink" title="日常基本操作"></a>日常基本操作</h5><p>在日常工作中，代码常用的基本操作如下：</p>
<ul>
<li>git init 初始化仓库，默认为 master 分支</li>
<li>git add . 提交全部文件修改到缓存区</li>
<li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li>
<li>git diff 查看当前代码 add后，会 add 哪些内容</li>
<li>git diff –staged查看现在 commit 提交后，会提交哪些内容</li>
<li>git status 查看当前分支状态</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li>
<li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li>
<li>git commit -v 提交时显示所有diff信息</li>
<li>git commit –amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</li>
</ul>
<p>关于提交信息的格式，可以遵循以下的规则：</p>
<ul>
<li>feat: 新特性，添加功能</li>
<li>fix: 修改 bug</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>style: 代码格式修改, 注意不是 css 修改</li>
<li>test: 测试用例修改</li>
<li>chore: 其他修改, 比如构建流程, 依赖管理</li>
</ul>
<h5 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h5><ul>
<li>git branch 查看本地所有分支</li>
<li>git branch -r 查看远程所有分支</li>
<li>git branch -a 查看本地和远程所有分支</li>
<li>git merge &lt;分支名&gt; 合并分支</li>
<li>git merge –abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li>
<li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li>
<li>git checkout –orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li>
<li>git branch -D &lt;分支名&gt; 删除本地某个分支</li>
<li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li>
<li>git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</li>
<li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li>
<li>git checkout &lt;分支名&gt; 切换到本地某个分支</li>
<li>git checkout &lt;远程库名&gt;&#x2F;&lt;分支名&gt; 切换到线上某个分支</li>
<li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li>
</ul>
<h5 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h5><p>远程操作常见的命令：</p>
<ul>
<li>git fetch [remote] 下载远程仓库的所有变动</li>
<li>git remote -v 显示所有远程仓库</li>
<li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li>
<li>git fetch 获取线上最新版信息记录，不合并</li>
<li>git push [remote] [branch] 上传本地指定分支到远程仓库</li>
<li>git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突</li>
<li>git push [remote] –all 推送所有分支到远程仓库</li>
</ul>
<h5 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h5><ul>
<li>git checkout [file] 恢复暂存区的指定文件到工作区</li>
<li>git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</li>
<li>git checkout . 恢复暂存区的所有文件到工作区</li>
<li>git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</li>
<li>git reset –hard 重置暂存区与工作区，与上一次commit保持一致</li>
<li>git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</li>
<li>git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</li>
</ul>
<blockquote>
<p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p>
<p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p>
</blockquote>
<h5 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h5><p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p>
<ul>
<li>git stash 暂时将未提交的变化移除</li>
<li>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</li>
<li>git stash list 查看所有储藏中的工作</li>
<li>git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</li>
<li>git stash clear 清空所有储藏中的工作</li>
<li>git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</li>
</ul>
<h5 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h5><p><code>git</code>常用命令速查表如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613130663363302d663762302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<h3 id="对git-pull-和-git-fetch-的理解？有什么区别？"><a href="#对git-pull-和-git-fetch-的理解？有什么区别？" class="headerlink" title="对git pull 和 git fetch 的理解？有什么区别？"></a>对git pull 和 git fetch 的理解？有什么区别？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>先回顾两个命令的定义</p>
<ul>
<li>git fetch 命令用于从另一个存储库下载对象和引用</li>
<li>git pull 命令用于从另一个存储库或本地分支获取并集成(整合)</li>
</ul>
<p>再来看一次<code>git</code>的工作流程图，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64353233626136302d666163322d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>可以看到，<code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p>
<p>而<code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p>
<p>在我们本地的<code>git</code>文件中对应也存储了<code>git</code>本地仓库分支的<code>commit ID </code>和 跟踪的远程分支的<code>commit ID</code>，对应文件如下：</p>
<ul>
<li>.git&#x2F;refs&#x2F;head&#x2F;[本地分支]</li>
<li>.git&#x2F;refs&#x2F;remotes&#x2F;[正在跟踪的分支]</li>
</ul>
<p>使用 <code>git fetch</code>更新代码，本地的库中<code>master</code>的<code>commitID</code>不变</p>
<p>但是与<code>git</code>上面关联的那个<code>orign/master</code>的<code>commit ID</code>发生改变</p>
<p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过<code>merge</code>去合并这两个不同的代码版本</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66643233666637302d666231322d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>也就是<code>fetch</code>的时候本地的<code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地<code>merge</code>合并这两个版本号的代码</p>
<p>相比之下，使用<code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30393162383134302d666231332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h4><p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到<code>git pull</code>或者<code>git fetch</code>命令</p>
<h5 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h5><p>用法如下：</p>
<pre><code class="ini">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>例如从远程的<code>origin</code>仓库的<code>master</code>分支下载代码到本地并新建一个<code>temp</code>分支</p>
<pre><code class="ini">git fetch origin master:temp
</code></pre>
<p>如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来到本地当前分支</p>
<p>这里<code>git fetch</code>不会进行合并，执行后需要手动执行<code>git merge</code>合并，如下：</p>
<pre><code class="ini">git merge temp
</code></pre>
<h5 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h5><p>两者的用法十分相似，<code>pull</code>用法如下：</p>
<pre><code class="ini">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>例如将远程主机<code>origin</code>的<code>master</code>分支拉取过来，与本地的<code>branchtest</code>分支合并，命令如下：</p>
<pre><code class="ini">git pull origin master:branchtest
</code></pre>
<p>同样如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来与本地当前分支合并</p>
<h4 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h4><p>相同点：</p>
<ul>
<li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li>
</ul>
<p>不同点：</p>
<ul>
<li>git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull &#x3D; git fetch + git merge</li>
<li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li>
</ul>
<h3 id="Git-中-HEAD、工作树和索引之间的区别？"><a href="#Git-中-HEAD、工作树和索引之间的区别？" class="headerlink" title="Git 中 HEAD、工作树和索引之间的区别？"></a>Git 中 HEAD、工作树和索引之间的区别？</h3><h4 id="一、HEAD"><a href="#一、HEAD" class="headerlink" title="一、HEAD"></a>一、HEAD</h4><p>在<code>git</code>中，可以存在很多分支，其本质上是一个指向<code>commit</code>对象的可变指针，而<code>Head</code>是一个特别的指针，是一个指向你正在工作中的本地分支的指针</p>
<p>简单来讲，就是你现在在哪儿，HEAD 就指向哪儿</p>
<p>例如当前我们处于<code>master</code>分支，所以<code>HEAD</code>这个指针指向了<code>master</code>分支指针</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33366362306461302d666134302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>然后通过调用<code>git checkout test</code>切换到<code>test</code>分支，那么<code>HEAD</code>则指向<code>test</code>分支，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33653836626138302d666134302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>但我们在<code>test</code>分支再一次<code>commit</code>信息的时候，<code>HEAD</code>指针仍然指向了<code>test</code>分支指针，而<code>test</code>分支指针已经指向了最新创建的提交，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34333938333962302d666136362d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这个<code>HEAD</code>存储的位置就在<code>.git/HEAD</code>目录中，查看信息可以看到<code>HEAD</code>指向了另一个文件</p>
<pre><code class="ini">$ cat .git/HEAD
ref: refs/heads/master

$ cat .git/refs/heads/master
7406a10efcc169bbab17827aeda189aa20376f7f
</code></pre>
<p>这个文件的内容是一串哈希码，而这个哈希码正是<code>master</code>分支上最新的提交所对应的哈希码</p>
<p>所以，当我们切换分支的时候，<code>HEAD</code>指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p>
<p>所以，HEAD指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p>
<h4 id="二、工作树和索引"><a href="#二、工作树和索引" class="headerlink" title="二、工作树和索引"></a>二、工作树和索引</h4><p>在<code>Git</code>管理下，大家实际操作的目录被称为工作树，也就是工作区域</p>
<p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34366535616334302d666134302d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>Git</code>在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库</p>
<p>因此，要提交文件，首先需要把文件加入到索引区域中。</p>
<p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交</p>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><p>从所在的位置来看：</p>
<ul>
<li>HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</li>
<li>工作树是查看和编辑的（源）文件的实际内容</li>
<li>索引是放置你想要提交给 git仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过git commit 则将索引区域的文件提交到 git 仓库中</li>
</ul>
<h3 id="对git-stash-的理解？应用场景？"><a href="#对git-stash-的理解？应用场景？" class="headerlink" title="对git stash 的理解？应用场景？"></a>对git stash 的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上</p>
<p>后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码</p>
<p>默认情况下，<code>git stash</code>会缓存下列状态的文件：</p>
<ul>
<li>添加到暂存区的修改（staged changes）</li>
<li>Git跟踪的但并未添加到暂存区的修改（unstaged changes）</li>
</ul>
<p>但以下状态的文件不会缓存：</p>
<ul>
<li>在工作目录中新的文件（untracked files）</li>
<li>被忽略的文件（ignored files）</li>
</ul>
<p>如果想要上述的文件都被缓存，可以使用<code>-u</code>或者<code>--include-untracked</code>可以工作目录新的文件，使用<code>-a</code>或者<code>--all</code>命令可以当前目录下的所有修改</p>
<h4 id="二、如何使用-1"><a href="#二、如何使用-1" class="headerlink" title="二、如何使用"></a>二、如何使用</h4><p>关于<code>git stash</code>常见的命令如下：</p>
<ul>
<li>git stash</li>
<li>git stash save</li>
<li>git stash list</li>
<li>git stash pop</li>
<li>git stash apply</li>
<li>git stash show</li>
<li>git stash drop</li>
<li>git stash clear</li>
</ul>
<h5 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h5><p>保存当前工作进度，会把暂存区和工作区的改动保存起来</p>
<h5 id="git-stash-save"><a href="#git-stash-save" class="headerlink" title="git stash save"></a>git stash save</h5><p><code>git stash save</code>可以用于存储修改.并且将<code>git</code>的工作状态切回到<code>HEAD</code>也就是上一次合法提交上</p>
<p>如果给定具体的文件路径,<code>git stash</code>只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：</p>
<ul>
<li>–keep-index 或者 -k 只会存储为加入 git 管理的文件</li>
<li>–include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态</li>
<li>-a 或者 –all 命令可以当前目录下的所有修改，包括被 git 忽略的文件</li>
</ul>
<h5 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h5><p>显示保存进度的列表。也就意味着，<code>git stash</code>命令可以多次执行，当多次使用<code>git stash</code>命令后，栈里会充满未提交的代码，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35303231366464302d666363662d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>其中，<code>stash@&#123;0&#125;</code>、<code>stash@&#123;1&#125;</code>就是当前<code>stash</code>的名称</p>
<h5 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h5><p><code>git stash pop</code> 从栈中读取最近一次保存的内容，也就是栈顶的<code>stash</code>会恢复到工作区</p>
<p>也可以通过 <code>git stash pop</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>
<p>如果从<code>stash</code>中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突</p>
<h5 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h5><p>将堆栈中的内容应用到当前目录，不同于<code>git stash pop</code>，该命令不会将内容从堆栈中删除</p>
<p>也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况</p>
<p>同样，可以通过<code>git stash apply</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>
<h5 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h5><p>查看堆栈中最新保存的<code>stash</code>和当前目录的差异</p>
<p>通过使用<code>git stash show -p</code>查看详细的不同</p>
<p>通过使用<code>git stash show stash@&#123;1&#125;</code>查看指定的<code>stash</code>和当前目录差异</p>
<p><a href="https://camo.githubusercontent.com/bfc073fa538b45c4d6de871da070f364638cdd751a8c08426794c5dba2230514/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34353836323061302d666363662d313165622d626336662d3366303665313439313636342e706e67"><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34353836323061302d666363662d313165622d626336662d3366303665313439313636342e706e67.png" alt="img"></a></p>
<h5 id="git-stash-drop"><a href="#git-stash-drop" class="headerlink" title="git stash drop"></a>git stash drop</h5><p><code>git stash drop</code> + <code>stash</code>名称表示从堆栈中移除某个指定的stash</p>
<h5 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h5><p>删除所有存储的进度</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情</p>
<p>但是你创建一次未完成的代码的<code>commit</code>提交，这时候就可以使用<code>git stash</code></p>
<p>例如以下场景：</p>
<p>当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过<code>git pull</code>解决</p>
<p>但是如果可能发生冲突怎么办.直接<code>git pull</code>会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：</p>
<ul>
<li>git stash</li>
<li>git pull</li>
<li>git stash pop</li>
</ul>
<p>或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用<code>git stash</code>缓存当前区域的代码</p>
<ul>
<li>git stash：保存开发到一半的代码</li>
<li>git commit -m ‘修改问题’</li>
<li>git stash pop：将代码追加到最新的提交之后</li>
</ul>
<h3 id="对git-rebase-和-git-merge的理解？区别？"><a href="#对git-rebase-和-git-merge的理解？区别？" class="headerlink" title="对git rebase 和 git merge的理解？区别？"></a>对git rebase 和 git merge的理解？区别？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p>
<ul>
<li>git merge</li>
<li>git rebase</li>
</ul>
<p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p>
<p>用法上两者也十分的简单：</p>
<h5 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h5><p>将当前分支合并到指定分支，命令用法如下：</p>
<pre><code class="ini">git merge xxx
</code></pre>
<h5 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h5><p>将当前分支移植到指定分支或指定<code>commit</code>之上，用法如下：</p>
<pre><code class="ini">git rebase -i &lt;commit&gt;
</code></pre>
<p>常见的参数有<code>--continue</code>，用于解决冲突之后，继续执行<code>rebase</code></p>
<pre><code class="ini">git rebase --continue
</code></pre>
<h4 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h4><h5 id="git-merge-1"><a href="#git-merge-1" class="headerlink" title="git merge"></a>git merge</h5><p>通过<code>git merge</code>将当前分支与<code>xxx</code>分支合并，产生的新的<code>commit</code>对象有两个父节点</p>
<p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p>
<p>举个例子，<code>bugfix</code>分支是从<code>maste</code>r分支分叉出来的，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38383431306133302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>合并<code> bugfix</code>分支到<code>master</code>分支时，如果<code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含<code>master</code>分支所有的历史记录</p>
<p>所以通过把<code>master</code>分支的位置移动到<code>bugfix</code>的最新分支上，就完成合并</p>
<p>如果<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39323965623232302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这时候使用<code>git merge</code>的时候，会生成一个新的提交，并且<code>master</code>分支的<code>HEAD</code>会移动到新的分支上，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39666466613365302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p>
<h5 id="git-rebase-1"><a href="#git-rebase-1" class="headerlink" title="git rebase"></a>git rebase</h5><p>同样，<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61623264353132302d666464342d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>通过<code>git rebase</code>，会变成如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62373261656437302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63396261306538302d666464342d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>rebase</code>之后，<code>master</code>的<code>HEAD</code>位置不变。因此，要合并<code>master</code>分支和<code>bugfix</code>分支</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64633636303636302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的<code>B</code></p>
<p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交<code>X</code>和<code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p>
<p>然后将当前分支指向目标最新位置<code>D</code>, 然后将之前另存为临时文件的修改依序应用</p>
<h4 id="三、区别-3"><a href="#三、区别-3" class="headerlink" title="三、区别"></a>三、区别</h4><p>从上面可以看到，<code>merge</code>和<code>rebasea</code>都是合并历史记录，但是各自特性不同：</p>
<h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>通过<code>merge</code>合并分支会新增一个<code>merge commit</code>，然后将两个分支的历史联系起来</p>
<p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p>
<h5 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h5><p><code>rebase </code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p>
<p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p>
<h3 id="git-发生冲突的场景？如何解决？"><a href="#git-发生冲突的场景？如何解决？" class="headerlink" title="git 发生冲突的场景？如何解决？"></a>git 发生冲突的场景？如何解决？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>一般情况下，出现分支的场景有如下：</p>
<ul>
<li>多个分支代码合并到一个分支时</li>
<li>多个分支向同一个远端分支推送</li>
</ul>
<p>具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称</p>
<p>如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可</p>
<p>应用在命令中，就是<code>push</code>、<code>pull</code>、<code>stash</code>、<code>rebase</code>等命令下都有可能产生冲突情况，从本质上来讲，都是<code>merge</code>和<code>patch</code>（应用补丁）时产生冲突</p>
<h4 id="二、分析-1"><a href="#二、分析-1" class="headerlink" title="二、分析"></a>二、分析</h4><p>在本地主分值<code>master</code>创建一个<code>a.txt</code>文件，文件起始位置写上<code>master commit</code>，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39353961646532302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>然后提交到仓库：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m ‘master first commit’</li>
</ul>
<p>创建一个新的分支<code>featurel1</code>分支，并进行切换，如下：</p>
<pre><code class="ini">git checkout -b featurel1
</code></pre>
<p>然后修改<code>a.txt</code>文件首行文字为 <code>featurel commit</code>，然后添加到暂存区，并开始进行提交到仓库：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m ‘featurel first change’</li>
</ul>
<p>然后通过<code>git checkout master</code>切换到主分支，通过<code>git merge</code>进行合并，发现不会冲突</p>
<p>此时<code>a.txt</code>文件的内容变成<code>featurel commit</code>，没有出现冲突情况，这是因为<code>git</code>在内部发生了快速合并</p>
<blockquote>
<p>如果当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作</p>
<p>git 不创建任何新的提交(commit)，只是将当前分支指向合并进来的分支</p>
</blockquote>
<p>如果此时切换到<code>featurel</code>分支，将文件的内容修改成<code>featrue second commit</code>，然后提交到本地仓库</p>
<p>然后切换到主分支，如果此时在<code>a.txt</code>文件再次修改，修改成<code>mastet second commit</code>，然后再次提交到本地仓库</p>
<p>此时，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61303534383863302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这种情况下，无法执行快速合并，只能试图把各自的修改合并起来，但这种合并就可能会有冲突</p>
<p>现在通过<code>git merge featurel</code>进行分支合并，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62303939316439302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>从冲突信息可以看到，<code>a.txt</code>发生冲突，必须手动解决冲突之后再提交</p>
<p>而<code>git status</code>同样可以告知我们冲突的文件：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63353832333433302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>打开<code>a.txt</code>文件，可以看到如下内容：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63653761306139302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容：</p>
<ul>
<li>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 和 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 之间的区域就是当前更改的内容</li>
<li>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 之间的区域就是传入进来更改的内容</li>
</ul>
<p>现在要做的事情就是将冲突的内容进行更改，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，<code>Git </code>就会将它们标记为冲突已解决然后再提交：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m “conflict fixed”</li>
</ul>
<p>此时<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64373432316536302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>使用<code>git log</code>命令可以看到合并的信息：</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65306466643162302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></h4><h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>当<code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p>
<p>解决冲突就是把<code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p>
<h3 id="对git-reset-和-git-revert-的理解？区别？"><a href="#对git-reset-和-git-revert-的理解？区别？" class="headerlink" title="对git reset 和 git revert 的理解？区别？"></a>对git reset 和 git revert 的理解？区别？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><h5 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h5><p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p>
<p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61623464306330302d666637322d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h5><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p>
<p><a href="https://camo.githubusercontent.com/e14636346aeadfa4f5766d89196355a3ff8fd0edadd8b74bd5803cdab3312e60/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643132633239302d666637322d313165622d393931642d3333346664333166303230312e706e67"><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643132633239302d666637322d313165622d393931642d3333346664333166303230312e706e67.png" alt="img"></a></p>
<h4 id="二、如何用"><a href="#二、如何用" class="headerlink" title="二、如何用"></a>二、如何用</h4><h5 id="git-reset-1"><a href="#git-reset-1" class="headerlink" title="git reset"></a>git reset</h5><p>当没有指定<code>ID</code>的时候，默认使用<code>HEAD</code>，如果指定<code>ID</code>，那么就是基于指向<code>ID</code>去变动暂存区或工作区的内容</p>
<pre><code class="ini">// 没有指定ID, 暂存区的内容会被当前ID版本号的内容覆盖，工作区不变
git reset

// 指定ID，暂存区的内容会被指定ID版本号的内容覆盖，工作区不变
git reset &lt;ID&gt; 
</code></pre>
<p>日志<code>ID</code>可以通过查询，可以<code>git log</code>进行查询，如下：</p>
<pre><code class="ini">commit a7700083ace1204ccdff9f71631fb34c9913f7c5 (HEAD -&gt; master)
Author: linguanghui &lt;linguanghui@baidu.com&gt;
Date:   Tue Aug 17 22:34:40 2021 +0800

    second commit

commit e31118663ce66717edd8a179688a7f3dde5a9393
Author: linguanghui &lt;linguanghui@baidu.com&gt;
Date:   Tue Aug 17 22:20:01 2021 +0800

    first commit
</code></pre>
<p>常见命令如下：</p>
<ul>
<li>–mixed（默认）：默认的时候，只有暂存区变化</li>
<li>–hard参数：如果使用 –hard 参数，那么工作区也会变化</li>
<li>–soft：如果使用 –soft 参数，那么暂存区和工作区都不会变化</li>
</ul>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32323562343165302d666637332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="git-revert-1"><a href="#git-revert-1" class="headerlink" title="git revert"></a>git revert</h5><p>跟<code>git reset</code>用法基本一致，<code>git revert</code> 撤销某次操作，此次操作之前和之后的 <code>commit</code>和<code>history</code>都会保留，并且把这次撤销，作为一次最新的提交，如下：</p>
<pre><code class="ini">git revert &lt;commit_id&gt; 
</code></pre>
<p>如果撤销前一个版本，可以通过如下命令：</p>
<pre><code class="ini">git revert HEAD
</code></pre>
<p>撤销前前一次，如下：</p>
<pre><code class="ini">git revert HEAD^
</code></pre>
<h4 id="三、区别-4"><a href="#三、区别-4" class="headerlink" title="三、区别"></a>三、区别</h4><p>撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，<code>git reset</code>被设计为重设本地更改</p>
<p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p>
<p>两者主要区别如下：</p>
<ul>
<li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li>
<li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容</li>
<li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li>
</ul>
<blockquote>
<p>git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并</p>
<p>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</p>
</blockquote>
<ul>
<li>如果回退分支的代码以后还需要的情况则使用<code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用<code>git reset</code></li>
</ul>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>git操作</category>
      </categories>
      <tags>
        <tag>mians</tag>
        <tag>代码版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全设计模式</title>
    <url>/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（设计模式）"><a href="#前端面试题大全（设计模式）" class="headerlink" title="前端面试题大全（设计模式）"></a>前端面试题大全（设计模式）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ul>
<li>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</li>
</ul>
<h3 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h3><ul>
<li>看懂源代码：如果你不懂设计模式去看Jdk、Spring、SpringMVC、IO等等等等的源码，你会很迷茫，你会寸步难行</li>
<li>看看前辈的代码：你去个公司难道都是新项目让你接手？很有可能是接盘的，前辈的开发难道不用设计模式？</li>
<li>编写自己的理想中的好代码：我个人反正是这样的，对于我自己开发的项目我会很认真，我对他比对我女朋友还好，把项目当成自己的儿子一样</li>
</ul>
<h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17172acfe20b2d2d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png"></p>
<ul>
<li>创建型模式，共五种：工厂方法模式、抽象工厂模式<strong>、</strong>单例模式、建造者模式、原型模式。</li>
<li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17172acff10be430~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.jpeg"></p>
<h4 id="开放封闭原则（Open-Close-Principle）"><a href="#开放封闭原则（Open-Close-Principle）" class="headerlink" title="开放封闭原则（Open Close Principle）"></a>开放封闭原则（Open Close Principle）</h4><ul>
<li>原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</li>
<li>描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li>
<li>优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。</li>
</ul>
<h4 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h4><ul>
<li>原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。</li>
<li>大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。</li>
<li>优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。</li>
</ul>
<h4 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h4><ul>
<li>依赖倒置原则的核心思想是面向接口编程.</li>
<li>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，</li>
<li>这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。</li>
</ul>
<h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h4><ul>
<li>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</li>
<li>例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口</li>
</ul>
<h4 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h4><ul>
<li>原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦</li>
<li>大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</li>
<li>优点：低耦合，高内聚。</li>
</ul>
<h4 id="单一职责原则（Principle-of-single-responsibility）"><a href="#单一职责原则（Principle-of-single-responsibility）" class="headerlink" title="单一职责原则（Principle of single responsibility）"></a>单一职责原则（Principle of single responsibility）</h4><ul>
<li>原则思想：一个方法只负责一件事情。</li>
<li>描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。</li>
<li>优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>单例模式（Singleton Pattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建</p>
<p>在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66613738393864302d336232632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>从定义上来看，全局变量好像就是单例模式，但是一般情况我们不认为全局变量是一个单例模式，原因是：</p>
<ul>
<li>全局命名污染</li>
<li>不易维护，容易被重写覆盖</li>
</ul>
<h4 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h4><p>在<code>javascript</code>中，实现一个单例模式可以用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可，如下：</p>
<pre><code class="javascript">// 定义一个类
function Singleton(name) &#123;
  this.name = name;
  this.instance = null;
&#125;
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 获取类的实例
Singleton.getInstance = function(name) &#123;
  if(!this.instance) &#123;
      this.instance = new Singleton(name);
  &#125;
  return this.instance
&#125;;

// 获取对象1
const a = Singleton.getInstance(&#39;a&#39;);
// 获取对象2
const b = Singleton.getInstance(&#39;b&#39;);
// 进行比较
console.log(a === b);
</code></pre>
<p>使用闭包也能够实现，如下：</p>
<pre><code class="javascript">function Singleton(name) &#123;
  this.name = name;
&#125;
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 获取类的实例
Singleton.getInstance = (function() &#123;
  var instance = null;
  return function(name) &#123;
      if(!this.instance) &#123;
          this.instance = new Singleton(name);
      &#125;
      return this.instance
  &#125;        
&#125;)();

// 获取对象1
const a = Singleton.getInstance(&#39;a&#39;);
// 获取对象2
const b = Singleton.getInstance(&#39;b&#39;);
// 进行比较
console.log(a === b);
</code></pre>
<p>也可以将上述的方法稍作修改，变成构造函数的形式，如下：</p>
<pre><code class="javascript">// 单例构造函数
function CreateSingleton (name) &#123;
  this.name = name;
  this.getName();
&#125;;

// 获取实例的名字
CreateSingleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 单例对象
const Singleton = (function()&#123;
  var instance;
  return function (name) &#123;
      if(!instance) &#123;
          instance = new CreateSingleton(name);
      &#125;
      return instance;
  &#125;
&#125;)();

// 创建实例对象1
const a = new Singleton(&#39;a&#39;);
// 创建实例对象2
const b = new Singleton(&#39;b&#39;);

console.log(a===b); // true
</code></pre>
<h4 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>在前端中，很多情况都是用到单例模式，例如页面存在一个模态框的时候，只有用户点击的时候才会创建，而不是加载完成之后再创建弹窗和隐藏，并且保证弹窗全局只有一个</p>
<p>可以先创建一个通常的获取对象的方法，如下：</p>
<pre><code class="javascript">const getSingle = function( fn )&#123;
let result;
return function()&#123;
  return result || ( result = fn .apply(this, arguments ) );
&#125;
&#125;; 
</code></pre>
<p>创建弹窗的代码如下：</p>
<pre><code class="javascript">const createLoginLayer = function()&#123;
var div = document.createElement( &#39;div&#39; );
div.innerHTML = &#39;我是浮窗&#39;;
div.style.display = &#39;none&#39;;
document.body.appendChild( div );
return div;
&#125;; 

const createSingleLoginLayer = getSingle( createLoginLayer ); 

document.getElementById( &#39;loginBtn&#39; ).onclick = function()&#123;
var loginLayer = createSingleLoginLayer();
loginLayer.style.display = &#39;block&#39;;
&#125;;
</code></pre>
<p>上述这种实现称为惰性单例，意图解决需要时才创建类实例对象</p>
<p>并且<code>Vuex</code>、<code>redux</code>全局态管理库也应用单例模式的思想，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38626535306638302d336232622d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>现在很多第三方库都是单例模式，多次引用只会使用同一个对象，如<code>jquery</code>、<code>lodash</code>、<code>moment</code>…</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂</p>
<p>其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品</p>
<p>举个例子：</p>
<ul>
<li>编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联（耦合）</li>
<li>后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事；</li>
<li>这种情况下，就需要将创建实例的工作从调用方（A类）中分离，与调用方解耦，也就是使用工厂方法创建实例的工作封装起来（减少代码重复），由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，而降低调用者因为创建逻辑导致的错误；</li>
</ul>
<h4 id="二、实现-1"><a href="#二、实现-1" class="headerlink" title="二、实现"></a>二、实现</h4><p>工厂模式根据抽象程度的不同可以分为：</p>
<ul>
<li>简单工厂模式（Simple Factory）</li>
<li>工厂方法模式（Factory Method）</li>
<li>抽象工厂模式（Abstract Factory）</li>
</ul>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例</p>
<p>假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致</p>
<p>代码如下：</p>
<pre><code class="javascript">function Factory(career) &#123;
    function User(career, work) &#123;
        this.career = career 
        this.work = work
    &#125;
    let work
    switch(career) &#123;
        case &#39;coder&#39;:
            work =  [&#39;写代码&#39;, &#39;修Bug&#39;] 
            return new User(career, work)
            break
        case &#39;hr&#39;:
            work = [&#39;招聘&#39;, &#39;员工信息管理&#39;]
            return new User(career, work)
            break
        case &#39;driver&#39;:
            work = [&#39;开车&#39;]
            return new User(career, work)
            break
        case &#39;boss&#39;:
            work = [&#39;喝茶&#39;, &#39;开会&#39;, &#39;审批文件&#39;]
            return new User(career, work)
            break
    &#125;
&#125;
let coder = new Factory(&#39;coder&#39;)
console.log(coder)
let boss = new Factory(&#39;boss&#39;)
console.log(boss)
</code></pre>
<p><code>Factory</code>就是一个简单工厂。当我们调用工厂函数时，只需要传递name、age、career就可以获取到包含用户工作内容的实例对象</p>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂方法模式跟简单工厂模式差不多，但是把具体的产品放到了工厂函数的<code>prototype</code>中</p>
<p>这样一来，扩展产品种类就不必修改工厂函数了，核心类就变成抽象类，也可以随时重写某种具体的产品</p>
<p>也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产；但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产</p>
<p>如下代码：</p>
<pre><code class="javascript">// 工厂方法
function Factory(career)&#123;
    if(this instanceof Factory)&#123;
        var a = new this[career]();
        return a;
    &#125;else&#123;
        return new Factory(career);
    &#125;
&#125;
// 工厂方法函数的原型中设置所有对象的构造函数
Factory.prototype=&#123;
    &#39;coder&#39;: function()&#123;
        this.careerName = &#39;程序员&#39;
        this.work = [&#39;写代码&#39;, &#39;修Bug&#39;] 
    &#125;,
    &#39;hr&#39;: function()&#123;
        this.careerName = &#39;HR&#39;
        this.work = [&#39;招聘&#39;, &#39;员工信息管理&#39;]
    &#125;,
    &#39;driver&#39;: function () &#123;
        this.careerName = &#39;司机&#39;
        this.work = [&#39;开车&#39;]
    &#125;,
    &#39;boss&#39;: function()&#123;
        this.careerName = &#39;老板&#39;
        this.work = [&#39;喝茶&#39;, &#39;开会&#39;, &#39;审批文件&#39;]
    &#125;
&#125;
let coder = new Factory(&#39;coder&#39;)
console.log(coder)
let hr = new Factory(&#39;hr&#39;)
console.log(hr)
</code></pre>
<p>工厂方法关键核心代码是工厂里面的判断this是否属于工厂，也就是做了分支判断，这个工厂只做我能做的产品</p>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>上述简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建</p>
<p>通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的</p>
<p>由于<code>JavaScript</code>中并没有抽象类的概念，只能模拟，可以分成四部分：</p>
<ul>
<li>用于创建抽象类的函数</li>
<li>抽象类</li>
<li>具体类</li>
<li>实例化具体类</li>
</ul>
<p>上面的例子中有<code>coder</code>、<code>hr</code>、<code>boss</code>、<code>driver</code>四种岗位，其中<code>coder</code>可能使用不同的开发语言进行开发，比如<code>JavaScript</code>、<code>Java</code>等等。那么这两种语言就是对应的类簇</p>
<p>示例代码如下：</p>
<pre><code class="javascript">let CareerAbstractFactory = function(subType, superType) &#123;
  // 判断抽象工厂中是否有该抽象类
  if (typeof CareerAbstractFactory[superType] === &#39;function&#39;) &#123;
    // 缓存类
    function F() &#123;&#125;
    // 继承父类属性和方法
    F.prototype = new CareerAbstractFactory[superType]()
    // 将子类的constructor指向父类
    subType.constructor = subType;
    // 子类原型继承父类
    subType.prototype = new F()
  &#125; else &#123;
    throw new Error(&#39;抽象类不存在&#39;)
  &#125;
&#125;
</code></pre>
<p>上面代码中<code>CareerAbstractFactory</code>就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>从上面可看到，简单简单工厂的优点就是我们只要传递正确的参数，就能获得所需的对象，而不需要关心其创建的具体细节</p>
<p>应用场景也容易识别，有构造函数的地方，就应该考虑简单工厂，但是如果函数构建函数太多与复杂，会导致工厂函数变得复杂，所以不适合复杂的情况</p>
<p>抽象工厂模式一般用于严格要求以面向对象思想进行开发的超大型项目中，我们一般常规的开发的话一般就是简单工厂和工厂方法模式会用的比较多一些</p>
<p>综上，工厂模式适用场景如下：</p>
<ul>
<li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li>
<li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li>
<li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来</p>
<p>一个基于策略模式的程序至少由两部分组成：</p>
<ul>
<li>策略类，策略类封装了具体的算法，并负责具体的计算过程</li>
<li>环境类Context，Context 接受客户的请求，随后 把请求委托给某一个策略类</li>
</ul>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>举个例子，公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍</p>
<p>若使用<code>if</code>来实现，代码则如下：</p>
<pre><code class="javascript">var calculateBouns = function(salary,level) &#123;
    if(level === &#39;A&#39;) &#123;
        return salary * 4;
    &#125;
    if(level === &#39;B&#39;) &#123;
        return salary * 3;
    &#125;
    if(level === &#39;C&#39;) &#123;
        return salary * 2;
    &#125;
&#125;;
// 调用如下：
console.log(calculateBouns(4000,&#39;A&#39;)); // 16000
console.log(calculateBouns(2500,&#39;B&#39;)); // 7500
</code></pre>
<p>从上述可有看到，函数内部包含过多<code>if...else</code>，并且后续改正的时候，需要在函数内部添加逻辑，违反了开放封闭原则</p>
<p>而如果使用策略模式，就是先定义一系列算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，如下：</p>
<pre><code class="javascript">var obj = &#123;
        &quot;A&quot;: function(salary) &#123;
            return salary * 4;
        &#125;,
        &quot;B&quot; : function(salary) &#123;
            return salary * 3;
        &#125;,
        &quot;C&quot; : function(salary) &#123;
            return salary * 2;
        &#125; 
&#125;;
var calculateBouns =function(level,salary) &#123;
    return obj[level](salary);
&#125;;
console.log(calculateBouns(&#39;A&#39;,10000)); // 40000
</code></pre>
<p>上述代码中，<code>obj</code>对应的是策略类，而<code>calculateBouns</code>对应上下通信类</p>
<p>又比如实现一个表单校验的代码，常常会像如下写法：</p>
<pre><code class="javascript">var registerForm = document.getElementById(&quot;registerForm&quot;);
registerForm.onsubmit = function()&#123;
    if(registerForm.userName.value === &#39;&#39;) &#123;
        alert(&#39;用户名不能为空&#39;);
        return;
    &#125;
    if(registerForm.password.value.length &lt; 6) &#123;
        alert(&quot;密码的长度不能小于6位&quot;);
        return;
    &#125;
    if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123;
        alert(&quot;手机号码格式不正确&quot;);
        return;
    &#125;
&#125;
</code></pre>
<p>上述代码包含多处<code>if</code>语句，并且违反了开放封闭原则，如果应用中还有其他的表单，需要重复编写代码</p>
<p>此处也可以使用策略模式进行重构校验，第一步确定不变的内容，即策略规则对象，如下：</p>
<pre><code class="javascript">var strategy = &#123;
    isNotEmpty: function(value,errorMsg) &#123;
        if(value === &#39;&#39;) &#123;
            return errorMsg;
        &#125;
    &#125;,
    // 限制最小长度
    minLength: function(value,length,errorMsg) &#123;
        if(value.length &lt; length) &#123;
            return errorMsg;
        &#125;
    &#125;,
    // 手机号码格式
    mobileFormat: function(value,errorMsg) &#123;
        if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123;
            return errorMsg;
        &#125;
    &#125; 
&#125;;
</code></pre>
<p>然后找出变的地方，作为环境类<code>context</code>，负责接收用户的要求并委托给策略规则对象，如下<code>Validator</code>类：</p>
<pre><code class="javascript">var Validator = function()&#123;
        this.cache = [];  // 保存效验规则
&#125;;
Validator.prototype.add = function(dom,rule,errorMsg) &#123;
    var str = rule.split(&quot;:&quot;);
    this.cache.push(function()&#123;
        // str 返回的是 minLength:6 
        var strategy = str.shift();
        str.unshift(dom.value); // 把input的value添加进参数列表
        str.push(errorMsg);  // 把errorMsg添加进参数列表
        return strategys[strategy].apply(dom,str);
    &#125;);
&#125;;
Validator.prototype.start = function()&#123;
    for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123;
        var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息
        if(msg) &#123;
            return msg;
        &#125;
    &#125;
&#125;;
</code></pre>
<p>通过<code>validator.add</code>方法添加校验规则和错误信息提示，使用如下：</p>
<pre><code class="javascript">var validateFunc = function()&#123;
    var validator = new Validator(); // 创建一个Validator对象
    /* 添加一些效验规则 */
    validator.add(registerForm.userName,&#39;isNotEmpty&#39;,&#39;用户名不能为空&#39;);
    validator.add(registerForm.password,&#39;minLength:6&#39;,&#39;密码长度不能小于6位&#39;);
    validator.add(registerForm.userName,&#39;mobileFormat&#39;,&#39;手机号码格式不正确&#39;);

    var errorMsg = validator.start(); // 获得效验结果
    return errorMsg; // 返回效验结果
&#125;;
var registerForm = document.getElementById(&quot;registerForm&quot;);
registerForm.onsubmit = function()&#123;
    var errorMsg = validateFunc();
    if(errorMsg)&#123;
        alert(errorMsg);
        return false;
    &#125;
&#125;
</code></pre>
<p>上述通过策略模式完成表单的验证，并且可以随时调用，在修改表单验证规则的时候，也非常方便，通过传递参数即可调用</p>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>从上面可以看到，使用策略模式的优点有如下：</p>
<ul>
<li>策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句</li>
<li>策略模式提供了开放-封闭原则，使代码更容易理解和扩展</li>
<li>策略模式中的代码可以复用</li>
</ul>
<p>策略模式不仅仅用来封装算法，在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装 一系列的“业务规则”</p>
<p>只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>代理模式（Proxy Pattern）是为一个对象提供一个代用品或占位符，以便控制对它的访问</p>
<p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39353163393962302d336436612d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>在生活中，代理模式的场景是十分常见的，例如我们现在如果有租房、买房的需求，更多的是去找链家等房屋中介机构，而不是直接寻找想卖房或出租房的人谈。此时，链家起到的作用就是代理的作用</p>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p>在<code>ES6</code>中，存在<code>proxy</code>构建函数能够让我们轻松使用代理模式：</p>
<pre><code class="javascript">const proxy = new Proxy(target, handler);
</code></pre>
<p>关于<code>Proxy</code>的使用可以翻看以前的文章</p>
<p>而按照功能来划分，<code>javascript</code>代理模式常用的有：</p>
<ul>
<li>缓存代理</li>
<li>虚拟代理</li>
</ul>
<h5 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h5><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</p>
<p>如实现一个求积乘的函数，如下：</p>
<pre><code class="javascript">var muti = function () &#123;
  console.log(&quot;开始计算乘积&quot;);
  var a = 1;
  for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;
    a = a * arguments[i];
  &#125;
  return a;
&#125;;
</code></pre>
<p>现在加入缓存代理，如下：</p>
<pre><code class="javascript">var proxyMult = (function () &#123;
  var cache = &#123;&#125;;
  return function () &#123;
    var args = Array.prototype.join.call(arguments, &quot;,&quot;);
    if (args in cache) &#123;
      return cache[args];
    &#125;
    return (cache[args] = mult.apply(this, arguments));
  &#125;;
&#125;)();

proxyMult(1, 2, 3, 4); // 输出:24
proxyMult(1, 2, 3, 4); // 输出:24
</code></pre>
<p>当第二次调用 <code>proxyMult(1, 2, 3, 4)</code> 时，本体 <code>mult</code> 函数并没有被计算，<code>proxyMult</code> 直接返回了之前缓存好的计算结果</p>
<h5 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h5><p>虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建</p>
<p>常见的就是图片预加载功能：</p>
<p>未使用代理模式如下：</p>
<pre><code class="javascript">let MyImage = (function()&#123;
    let imgNode = document.createElement( &#39;img&#39; );
    document.body.appendChild( imgNode );
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;

    img.onload = function()&#123;
        // 监听到图片加载完成后，设置src为加载完成后的图片
        imgNode.src = img.src;
    &#125;;

    return &#123;
        setSrc: function( src )&#123;
            // 设置图片的时候，设置为默认的loading图
            imgNode.src = &#39;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#39;;
            // 把真正需要设置的图片传给Image对象的src属性
            img.src = src;
        &#125;
    &#125;
&#125;)();

MyImage.setSrc( &#39;https://xxx.jpg&#39; );
</code></pre>
<p><code>MyImage</code>对象除了负责给<code>img</code>节点设置<code>src</code>外，还要负责预加载图片，违反了面向对象设计的原则——单一职责原则</p>
<p>上述过程<code>loding</code>则是耦合进<code>MyImage</code>对象里的，如果以后某个时候，我们不需要预加载显示loading这个功能了，就只能在<code>MyImage</code>对象里面改动代码</p>
<p>使用代理模式，代码则如下：</p>
<pre><code class="javascript">// 图片本地对象，负责往页面中创建一个img标签，并且提供一个对外的setSrc接口
let myImage = (function()&#123;
    let imgNode = document.createElement( &#39;img&#39; );
    document.body.appendChild( imgNode );

    return &#123;
        //setSrc接口，外界调用这个接口，便可以给该img标签设置src属性
        setSrc: function( src )&#123;
            imgNode.src = src;
        &#125;
    &#125;
&#125;)();
// 代理对象，负责图片预加载功能
let proxyImage = (function()&#123;
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;
    img.onload = function()&#123;
        // 监听到图片加载完成后，给被代理的图片本地对象设置src为加载完成后的图片
        myImage.setSrc( this.src );
    &#125;
    return &#123;
        setSrc: function( src )&#123;
            // 设置图片时，在图片未被真正加载好时，以这张图作为loading，提示用户图片正在加载
            myImage.setSrc( &#39;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#39; );
            img.src = src;
        &#125;
    &#125;
&#125;)();

proxyImage.setSrc( &#39;https://xxx.jpg&#39; );
</code></pre>
<p>使用代理模式后，图片本地对象负责往页面中创建一个<code>img</code>标签，并且提供一个对外的<code>setSrc</code>接口；</p>
<p>代理对象负责在图片未加载完成之前，引入预加载的<code>loading</code>图，负责了图片预加载的功能</p>
<p>上述并没有改变或者增加<code>MyImage</code>的接口，但是通过代理对象，实际上给系统添加了新的行为</p>
<p>并且上述代理模式可以发现，代理和本体接口的一致性，如果有一天不需要预加载，那么就不需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了 <code>setSrc</code> 方法</p>
<p>‘</p>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>现在的很多前端框架或者状态管理框架都使用代理模式，用与监听变量的变化</p>
<p>使用代理模式代理对象的访问的方式，一般又被称为拦截器，比如我们在项目中经常使用 <code>Axios</code> 的实例来进行 HTTP 的请求，使用拦截器 <code>interceptor</code> 可以提前对 请求前的数据 服务器返回的数据进行一些预处理</p>
<p>以及上述应用到的缓存代理和虚拟代理</p>
<h3 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h3><h4 id="一、观察者模式"><a href="#一、观察者模式" class="headerlink" title="一、观察者模式"></a>一、观察者模式</h4><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p>
<p>观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64336138303032302d336637632d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸</p>
<p>报社和订报纸的客户就形成了一对多的依赖关系</p>
<p>实现代码如下：</p>
<p>被观察者模式</p>
<pre><code class="javascript">class Subject &#123;

  constructor() &#123;
    this.observerList = [];
  &#125;

  addObserver(observer) &#123;
    this.observerList.push(observer);
  &#125;

  removeObserver(observer) &#123;
    const index = this.observerList.findIndex(o =&gt; o.name === observer.name);
    this.observerList.splice(index, 1);
  &#125;

  notifyObservers(message) &#123;
    const observers = this.observeList;
    observers.forEach(observer =&gt; observer.notified(message));
  &#125;

&#125;
</code></pre>
<p>观察者：</p>
<pre><code class="javascript">class Observer &#123;

  constructor(name, subject) &#123;
    this.name = name;
    if (subject) &#123;
      subject.addObserver(this);
    &#125;
  &#125;

  notified(message) &#123;
    console.log(this.name, &#39;got message&#39;, message);
  &#125;
&#125;
</code></pre>
<p>使用代码如下：</p>
<pre><code class="javascript">const subject = new Subject();
const observerA = new Observer(&#39;observerA&#39;, subject);
const observerB = new Observer(&#39;observerB&#39;);
subject.addObserver(observerB);
subject.notifyObservers(&#39;Hello from subject&#39;);
subject.removeObserver(observerA);
subject.notifyObservers(&#39;Hello again&#39;);
</code></pre>
<p>上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表</p>
<h4 id="二、发布订阅模式"><a href="#二、发布订阅模式" class="headerlink" title="二、发布订阅模式"></a>二、发布订阅模式</h4><p>发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在</p>
<p>同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65323464336364302d336637632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>实现代码如下：</p>
<pre><code class="javascript">class PubSub &#123;
  constructor() &#123;
    this.messages = &#123;&#125;;
    this.listeners = &#123;&#125;;
  &#125;
  // 添加发布者
  publish(type, content) &#123;
    const existContent = this.messages[type];
    if (!existContent) &#123;
      this.messages[type] = [];
    &#125;
    this.messages[type].push(content);
  &#125;
  // 添加订阅者
  subscribe(type, cb) &#123;
    const existListener = this.listeners[type];
    if (!existListener) &#123;
      this.listeners[type] = [];
    &#125;
    this.listeners[type].push(cb);
  &#125;
  // 通知
  notify(type) &#123;
    const messages = this.messages[type];
    const subscribers = this.listeners[type] || [];
    subscribers.forEach((cb, index) =&gt; cb(messages[index]));
  &#125;
&#125;
</code></pre>
<p>发布者代码如下：</p>
<pre><code class="javascript">class Publisher &#123;
  constructor(name, context) &#123;
    this.name = name;
    this.context = context;
  &#125;
  publish(type, content) &#123;
    this.context.publish(type, content);
  &#125;
&#125;
</code></pre>
<p>订阅者代码如下：</p>
<pre><code class="javascript">class Subscriber &#123;
  constructor(name, context) &#123;
    this.name = name;
    this.context = context;
  &#125;
  subscribe(type, cb) &#123;
    this.context.subscribe(type, cb);
  &#125;
&#125;
</code></pre>
<p>使用代码如下：</p>
<pre><code class="javascript">const TYPE_A = &#39;music&#39;;
const TYPE_B = &#39;movie&#39;;
const TYPE_C = &#39;novel&#39;;

const pubsub = new PubSub();

const publisherA = new Publisher(&#39;publisherA&#39;, pubsub);
publisherA.publish(TYPE_A, &#39;we are young&#39;);
publisherA.publish(TYPE_B, &#39;the silicon valley&#39;);
const publisherB = new Publisher(&#39;publisherB&#39;, pubsub);
publisherB.publish(TYPE_A, &#39;stronger&#39;);
const publisherC = new Publisher(&#39;publisherC&#39;, pubsub);
publisherC.publish(TYPE_C, &#39;a brief history of time&#39;);

const subscriberA = new Subscriber(&#39;subscriberA&#39;, pubsub);
subscriberA.subscribe(TYPE_A, res =&gt; &#123;
  console.log(&#39;subscriberA received&#39;, res)
&#125;);
const subscriberB = new Subscriber(&#39;subscriberB&#39;, pubsub);
subscriberB.subscribe(TYPE_C, res =&gt; &#123;
  console.log(&#39;subscriberB received&#39;, res)
&#125;);
const subscriberC = new Subscriber(&#39;subscriberC&#39;, pubsub);
subscriberC.subscribe(TYPE_B, res =&gt; &#123;
  console.log(&#39;subscriberC received&#39;, res)
&#125;);

pubsub.notify(TYPE_A);
pubsub.notify(TYPE_B);
pubsub.notify(TYPE_C);
</code></pre>
<p>上述代码，发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>两种设计模式思路是一样的，举个生活例子：</p>
<ul>
<li>观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体</li>
<li>发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决</li>
</ul>
<p>上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的</p>
<p>两者区别如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f3135352f39313431363832632d373338362d346631322d383431322d6662313761316364346266362e706e67.png"></p>
<ul>
<li>在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</li>
<li>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</li>
<li>观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</li>
</ul>
<h3 id="其他完整的设计模式（感兴趣可以看看）"><a href="#其他完整的设计模式（感兴趣可以看看）" class="headerlink" title="其他完整的设计模式（感兴趣可以看看）"></a>其他完整的设计模式（感兴趣可以看看）</h3><p><a href="https://juejin.cn/post/6844904032826294286">23种设计模式</a></p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>常用设计模式</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>图像优化</title>
    <url>/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="图像优化"><a href="#图像优化" class="headerlink" title="图像优化"></a>图像优化</h1><blockquote>
<p>前端大部分的工作都围绕在JavaScript和CSS上，考虑如何更快地下载文件，如何提供给用户复杂而优雅的交互，如何高效合理地应用有限的处理和传输资源等，这些是用户感知的全部吗?</p>
<p>当然，他们在前端开发和性能优化中的地位举足轻重，但JavaScript和CSS对用户感知而言，并不是最重要的部分，图像才是。我们在公众号发布文章或用PPT进行演讲时，都知道一条高效传递信息的原则:字不如表，表不如图。</p>
<p>网站作为一种信息传递的媒介，且如今各类Web项目中，图像资源的使用占比也越来越大，更应当注重图像资源的使用方式。如果网站中的图像资源未进行恰当的优化，那么势必会导致许多问题，诸如巨量的访问请求引发传输带宽的挑战，请求大尺寸图片需要过久的等待时间等。</p>
<p>图像优化问题主要可以分为两方面:图像的选取和使用，图像的加载和显示。对于加载方面的策略将放在 加载优化 中深入讨论,本章将聚焦图像的选取和使用。本章内容包括:什么是图像文件，都有哪些格式的图像文件，不同格式的图像文件适用于怎样的业务场景，以及通过怎样的优化方法能够有效提升用户对图像的体验感知等。</p>
</blockquote>
<h3 id="一、图像基础"><a href="#一、图像基础" class="headerlink" title="一、图像基础"></a>一、图像基础</h3><p>​	HTTP Archive上的数据显示，网站传输的数据中，60%的资源都是由各种图像文件组成的，当然这个数据是将各种类型网站平均之后的结果，要是单独看电商类面向消费者端页面的数据，这个比例可能会更大。如此之大的资源占比，也同样意味着存在很大的优化空间。</p>
<h4 id="1-图像是否必需"><a href="#1-图像是否必需" class="headerlink" title="1.图像是否必需"></a>1.图像是否必需</h4><p>​		图像资源优化的根本思想，可以归结为两个字: 压缩。无论是选取何种图像的文件格式，还是针对同一种格式压缩至更小的尺寸，其本质都是用更小的资源开销来完成图像的传输和展示。</p>
<p>​		在深入探讨之前，我们首先思考一下要达到期望的信息传递效果，是否真的需要图像?这不仅是因为图像资源与网页上的其他资源(HTML&#x2F;CSS&#x2F;JavaScript等)相比有更大的字节开销，出于对节省资源的考虑，对用户注意力的珍惜也很重要，如果一个页面打开后有很多图像，那么用户其实很难快速梳理出有效的信息，即便获取到了也会让用户觉得很累。</p>
<p>​		一个低感官体验的网站，它的价值转化率不会很高。当然这个问题的答案不是通过自己简单想想就能得到的，我们可能需要在日常的开发中与产品经理及体验设计师不断沟通，不断思考，来趋近更优的方案。</p>
<p>​		当确定了图像的展示效果必须存在时，在前端实现上也并非一定就要用图像文件，还存在一些场景可以使用更高效的方式来实现所需的效果。</p>
<ul>
<li>网站中一个图像在不同的页面或不同的交互状态下，需要呈现出不同的效果(边角的裁切、阴影或渐变)，其实没有必要为不同场景准备不同效果的多份图像文件，只需用CSS将一-张图像处理为所需的不同效果即可。相对于一个图像文件的大小来讲，修改其所增加的CSS代码量可以忽略不计。</li>
<li>如果一个图像上面需要显示文字，建议使用网页字体的形式通过前端代码进行添加，而不是使用带文字的图像，其原因一方面是包含了更多信息的图像文件一般会更大， 另一方面是图像中的文本信息带来的用户体验一般较差 (不可选择、搜索及缩放)，并且在高分辨率设备上的显示效果也会打折扣。</li>
</ul>
<p>这里列举的两个例子，为了说明当我们在选择使用某种资源之前，如果期望达到更优的性能效果，则需要先去思考这种选择是否必需。</p>
<h4 id="2-矢量图和位图"><a href="#2-矢量图和位图" class="headerlink" title="2.矢量图和位图"></a>2.矢量图和位图</h4><p>​		当确定了图像是实现展示效果的最佳方式时，接下来就是选择合适的图像格式。图像文件可以分为两类:矢量图和位图。每种类型都有其各自的优缺点和适用场景。</p>
<p>1.矢量图</p>
<p>​		矢量图中的图形元素被定义为一个对象，包括颜色、大小、形状及屏幕位置等属性。它适合如文本、品牌logo、控件图标及二维码等构图形状较简单的几何图形。矢量图的 优点 是能够在任何缩放比例下呈现出细节同样清晰的展示效果。其缺点是对细节的展示效果不够丰富，对足够复杂的图像来说，比如要达到照片的效果，若通过SVG进行矢量图绘制，则所得文件会大得离谱，但即便如此也很难达到照片的真实效果。</p>
<p>​		SVG也是一种基于XML的图像格式，其全称是Scalable Vector Graphics (可缩放的矢量图形)，目前几乎所有浏览器都支持SVG.我们可以在Iconfont.上找到许多矢量图，或者上传自己绘制的矢量图，在上面构建自己的矢量图标库并引入项目进行使用，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230108155047156.png" alt="矢量图标"></p>
<p>标识照片的矢量图标的SVG标签格式，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230108155303100.png"></p>
<p>​		SVG标签所包括的部分就是该矢量图的全部内容，除了必要的绘制信息，可能还包括一些元数据，比如XML命名空间、图层及注释信息。但这些信息对浏览器绘制一个 SVG来说并不是必要的，所以在使用前可通过工县去除这些元数据来达到压缩的目的。</p>
<p>2.位图</p>
<p>​		位图是通过对一个矩阵中的栅格进行编码来表示图像的，每个栅格只能编码表示一个特定的颜色，如果组成图像的栅格像素点越多且每个像素点所能表示的颜色范围越广，则位图图像整体的显示效果就会越逼真。虽然位图没有像矢量图那种不受分辨率影响的优秀特性，但对于复杂的照片却能提供较为真实的细节体验，如图中一幅海边的位图对于云朵及波浪的细节表现，如果用矢量图来实现是不可想象的。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230108160504567.png" alt="海边的位图"></p>
<p>​		当把图像不断放大后，就会看到许多栅格像素色块，如图所示。每个像素存储的是图像局部的RGBA信息，即红绿蓝三色通道及透明度。通常浏览器会为每个颜色通道分配一个字节的存储空间，即2^8&#x3D;256个色阶值。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230108160613742.png" alt="放大后的位图局部"></p>
<p>​		一个像素点4个通道就是4字节，一张图像整体的大小与其包含的像素数成正比，图像包含的像素越多，所能展示的细节就越丰富，同时图像就越大。</p>
<p>​		如表所示，当图像尺寸为100像素 x 100像素时，文件大小为39KB.随着图像尺寸在长和宽两个维度上同时增大，所产生像素数量的增加就不是简单的线性关系了，而是平方的抛物线增加，也就是说文件大小会迅速增加，在网络带宽一 定的前提下，下载完张图像会更慢。</p>
<table>
<thead>
<tr>
<th>图像尺寸</th>
<th>像素数量</th>
<th>文件大小</th>
</tr>
</thead>
<tbody><tr>
<td>100像素 x 100像素</td>
<td>10,000</td>
<td>39KB</td>
</tr>
<tr>
<td>200像素 x 200像素</td>
<td>40,000</td>
<td>156KB</td>
</tr>
<tr>
<td>500像素 x 500像素</td>
<td>250,000</td>
<td>977KB</td>
</tr>
<tr>
<td>800像素 x 800像素</td>
<td>640,000</td>
<td>2.5MB</td>
</tr>
</tbody></table>
<p>​		出于对性能的考虑，在使用图像时必须考虑对图像进行压缩，采用什么样的图像格式，使用什么样的压缩算法及压缩到何种程度，这将是本章接下来详细讨论的内容，但在此之前先说明关于分辨率的两个容易混淆的概念。</p>
<h4 id="3-分辨率"><a href="#3-分辨率" class="headerlink" title="3.分辨率"></a>3.分辨率</h4><p>​		在前端开发过程中书写CSS时，经常会为图像设置显示所需的长宽像素值，但在不同的设备屏幕上，有时候相同的图像及相同的设置，其渲染出来的图像会让人明显察觉出清晰度有差别。产生这个现象的原因涉及两种不同的分辨率:屏幕分辨率和图像分辨率。</p>
<p>​		图像分辨率表示的就是该图像文件所包含的真实像素值信息，比如一个 200像素X200像素的分辨率的图像文件，它就定义了长宽各200个像素点的信息。设备分辨率则是显示器屏幕所能显示的最大像素值，比如一台13英寸的Mac Pro 笔记本电脑的显示器分辨率为2560像素 x 1600像素。这两种分辨率都用到了像素，那么它们有什么区别呢?</p>
<p>​		更高的设备分辨率有助于显示更绚丽多彩的图像，这其实很话合矢量图的发挥，因为它不会因放大而失真。而对位图来说，只有图像文件包含更多的像素信息时，才能更充分地利用屏幕分辨率。为了能在不同的分辨率下使项目中所包含的图像都能得到恰当的展示效果，可以利用picture标签和srcset 属性提供图像的多个变体。</p>
<p>​		用于插入图像的ing标签，有一个 srcset属性可以用来针对不同设备，提供不同分辨率的图像文件:</p>
<pre><code class="html">&lt; img src=&quot;photo.jpg&quot; srcset=&quot;photo@2x.jpg 2x,photo@3x.jpg 3x, photo@4x.jpg 4x&quot; alt=&quot;photo&quot;&gt;
</code></pre>
<p>​		除了IE和其他较低版本的浏览器不支持，目前主流的大部分浏览器都已支持img标签的srcset 属性。在srcset属性中设置多种分辨率的图像文件及使用条件，浏览器在请求之前便会先对此进行解析，只选择最合适的图像文件进行下载，如果浏览器不支持，请务必在src属性中包含必要的默认图片。</p>
<p>​		使用picture标签则会在多图像文件选择时，获得更多的控制维度，比如屏幕方向、设备大小、屏幕分辨率等。</p>
<pre><code class="html">&lt;picture&gt;
  &lt;source media=&quot; (min-width:800px)&quot; srcset=&quot;photo.ipg, photo-2x.jpg 2x&quot;&gt;
  &lt;source media=&quot; (min-width:450px)&quot; srcset=&quot;photo-s.jpg photo-s-2x.jpg 2x&quot;&gt;
  &lt; img src=&quot;photo.jpg&quot;&gt;
&lt;/picture&gt;
</code></pre>
<p>​		由于picture标签也是加入标准不久的元素标签，所以在使用过程中，同样应当考虑兼容性问题。</p>
<h4 id="4-压缩的有损和无损"><a href="#4-压缩的有损和无损" class="headerlink" title="4.压缩的有损和无损"></a>4.压缩的有损和无损</h4><p>​		压缩是降低源文件大小的有效方式，对JavaScript代码或网页的一些脚本文件而言，压缩掉的内容是一些多余的空格及不影响执行的注释，其目的是在不损坏正常执行的情况下，尽量缩小源文件的大小。对图像文件而言，由于人眼对不同颜色的敏感度存在差异，所以便可通过减少对某种颜色的编码位数来减小文件大小，甚至还可以损失部分源文件信息，以达到近似的效果，使得压缩后的文件尺寸更小。</p>
<p>​		对于图像压缩，应该采用有损压缩还是无损压缩?如果都采用又该如何搭配设置呢?当结合了具体的业务需求再考虑后，关于压缩的技术选型就可以简单分成两步进行。</p>
<p>（1）首先确定业务所要展示图像的颜色阶数、图像显示的分率及清晰程度，当锚定了这几个参数的基准后，如果获取的图像源文件的相应参数指标过高，便可适当进行有损压缩，通过降低源文件图像质量的方法来降低图像文件大小。</p>
<p>​		如果业务所要求的图像质量较高，便可跳过有损压缩，直接进入第二步无损压缩。所以是否要进行有损压缩，其实是在理解了业务需求后的一个可选选项，而非必要的。</p>
<p>（2）当确定了展示图像的质量后，便可利用无损压缩技术尽可能降低图像大小。和第(1)步要通过业务决策来判断是否需要所不同的是，无损压缩是应当完成的工作环节。那么最好能通过一套完善的工程方案，自动化执行来避免烦琐的人工重复工作。</p>
<h3 id="二、图像格式"><a href="#二、图像格式" class="headerlink" title="二、图像格式"></a>二、图像格式</h3><p>​		实际上，不同的图像文件格式(JPG、PNG、GIF 等)之间的区别，在于它们进行有损压缩和无损压缩过程中采用了不同的算法组合，接下来我们将从不同的图像文件格式入手，看看它们的特点和使用场景，以及在具体业务中应该如何选取。</p>
<h4 id="1-JPEG"><a href="#1-JPEG" class="headerlink" title="1.JPEG"></a>1.JPEG</h4><p>​		JPEG可能是目前所有图像格式中出现最早，同时也是使用范围最广的一种格式。它也是一种有损压缩算法，它通过去除相关冗余图像和色彩数据等方式来获得较高的压缩率，同时还能展现出相当丰富的图像内容。</p>
<p>​		JPEG在网站开发中经常被用作背景图、轮播图或者一些商品的banner图，以呈现色彩丰富的内容。但由于是有损压缩，当处理Logo或图标时，需要较强线条感和强烈颜色对比，JPEG图像可能会出现一些边 界模糊的不佳体验，另外JPEG图像并不支持透明度。</p>
<p>​		接下来介绍有关JPEG常用的压缩编码方式，以及在工程实践中如何自动批量处理。</p>
<p>1.压缩模式</p>
<p>​		JPEG包含了多种压缩模式，其中常见的有基于基线的、渐进式的。简单来说基线模式的JPEG加载顺序是自上而下的，当网络连接缓慢或不稳定时，其是从上往下逐渐加载完成的，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230108163309301.png" alt="基线JPEG"></p>
<pre><code>     渐进式模式是将图像文件分为多次扫描，首先展示一个低质量模糊的图像，随着扫描到的图像信息不断增多，每次扫描过后所展示的图像清晰度也会不断提升，如图所示。
</code></pre>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109080817397.png" alt="渐进式JPEG"></p>
<p>2.渐进式JPEG的优缺点</p>
<p>​		渐进式JPEG的优点是显而易见的，在网络连接缓慢的情况下，首先能快速加载出一个图像质量比较模糊的预览版本。这样用户便可据此了解图像的大致内容，来决定是否继续花费时间等待完整图像的加载。这样做可以很好地提高对用户的感知性能，用户不仅知道所访问图像的大致内容，还会感知完整的图像就快加载好了。如果读者平时留心观察，应该能注意到渐进式JPEG已经在渐渐取代基线JPEG了。</p>
<p>​		通过了解两种压缩的原理不难发现，渐进式JPEG的解码速度会比基线的要慢一些，因为它增加了重复的检索开销。另外，通过渐进式JPEG压缩模式得到的图像文件也不一定是最小的，比如特别小的图像。所以是否要采用渐进式JPEG,需要综合考虑文件大小、大部分用户的设备类型与网络延迟。</p>
<p>3.创建渐进式JPEG</p>
<p>​		如果所得到的图像不是渐进式JPEG,那么我们可以通过许多第三方工具来进行处理，例如imagemin、libjpeg、 imageMagick 等。值得注意的是，这个步骤应当尽量交给构建工具来自动化完成，通过如下代码可以将该工作加入gulp处理管道:</p>
<pre><code class="javascript">const gulp = require(&#39;gulp&#39;);
const imagemin = require(&#39;gulp-imagemin&#39;);
gulp.task(&#39;images&#39;,()=&gt; 
    gulp.src(&#39;images/*.jpg&#39;)
    .pipe(imagemin(&#123;
        progressive:true
    &#125;))
    .pipe(gulp.dest(&#39;dist&#39;))
);
</code></pre>
<p>在执行构建流程后，gulp 会调用imagemin的方法把images 文件夹下的所有jpg后缀图像全部进行渐进式编码处理。</p>
<p>4.其他JPEG编码方式</p>
<p>​		除了常见的基线与渐进式压缩编码方式，最近还出现了几种现代的JPEG编码器，它们尝试以更高的保真度及压缩后更小的文件大小为目标，同时还兼容当前主流的浏览器。其中比较出色的有Mozilla基金会推出的MozJPEG和Google提出的Guetzli。</p>
<p>​		MozJPEG和Guetzli也都已经有了可靠的imagemin插件支持，其使用方式与渐进式JPEG处理方式类似，这里仅列出示例代码，具体工程化构建请读者结合项目实践进行改写。</p>
<pre><code class="javascript"> const gulp = require(&#39;gulp&#39;);
const imagemin = require (&#39;gulp-imagemin&#39;);
const imageminMozJPEG = require (&#39;imagemin-mozjpeg&#39;); //引入MozJPEG依赖包
const imageminGuetzli = require (&#39;imagemin-guetzli&#39;); //引入Guetzli依赖包
//MozJPEG压缩编码
gulp. task(&#39;mozjpeg&#39;, () =&gt;
    gulp.src(&#39;image/*. jpg&#39;)
    .pipe (imagemin([
        imageminMozJPEG(&#123;quality: 85 &#125;)
    ]))
    .pipe(gulp.dest(&#39;dist&#39;))
)
//Guetzli压缩编码
gulp.task(&#39;guetzli&#39;, () =&gt;
    gulp.src(&#39;image/* . jpg&#39;)
    .pipe (imagemin([
        imageminGuetzli (&#123;quality: 85 &#125;)
    ]))
    .pipe (gulp.dest(&#39;dist&#39;))
)
</code></pre>
<p>​		MozJPEG引入了对逐行扫描的优化及一些栅 格量化的功能，最多能将图像文件压缩10%，而Guetzli则是找到人眼感知上无法区分的最小体积的JPEG,那么两者的优化效果具体如何，又如何评价呢?</p>
<p>​		这里需要借助两个指标来进行衡量，首先是用来计算两个图像相似度的结构相似性分数(Structural Similarity index),简称SSIM,具体的计算过程可以借助第三方工具jpeg-compress 来进行，这个指标分数以原图为标准来判断测试图片与原图的相似度，数值越接近1表示和原图越相似。</p>
<p>​		Butteraugli则是一种基 于人类感知测量图像的差异模型，它能在人眼几乎看不出明显差异的地方，给出可靠的差别分数。如果SSIM是对图像差别的汇总，那么Butteraugli则可以帮助找出非常糟糕的部分。表列出了MozJPEG编码压缩后的数据比较。</p>
<table>
<thead>
<tr>
<th>原图大小 982 KB</th>
<th>Q&#x3D;90 &#x2F; 841KB</th>
<th>Q&#x3D;85 &#x2F; 562KB</th>
<th>Q&#x3D;75 &#x2F;324KB</th>
</tr>
</thead>
<tbody><tr>
<td>SSIM</td>
<td>0.999936</td>
<td>0.999698</td>
<td>0.999478</td>
</tr>
<tr>
<td>Butteraugli</td>
<td>1.576957</td>
<td>2.483837</td>
<td>3.66127</td>
</tr>
</tbody></table>
<p>​																	MozJPEG编码压缩后的数据比较</p>
<table>
<thead>
<tr>
<th>原图大小 982 KB</th>
<th>Q&#x3D;100 &#x2F; 945KB</th>
<th>Q&#x3D;90 &#x2F; 687KB</th>
<th>Q&#x3D;85 &#x2F; 542KB</th>
</tr>
</thead>
<tbody><tr>
<td>SSIM</td>
<td>0.999998</td>
<td>0.99971</td>
<td>0.999508</td>
</tr>
<tr>
<td>Butteraugli</td>
<td>0.40884</td>
<td>1.580555</td>
<td>2.0996</td>
</tr>
</tbody></table>
<p>​																	Guetzli编码压缩后的数据比较</p>
<p>不仅要考虑图像压缩的质量和保真度，还要关注压缩后的大小，没有哪种压缩编码方式在各种条件下都是最优的，需要结合实际业务进行选择。这里可以给读者一些使用建议:</p>
<ul>
<li>使用一些外部工具找到图像的最佳表现质量后，再用MozJPEG进行编码压缩。</li>
<li>Guetzli会获得更高质量的图像，压缩速度相对较慢。</li>
</ul>
<p>​		虽然本节介绍了关于JPEG的若干编码器，也对它们之间的差别进行了比较，但需要明确的一点是，最终压缩后的图像文件大小差异更多地取决于设置的压缩质量，而非所选择的编码器。所以在对JPEG进行编码优化时，应主要关注业务可接受的最低图像质量。</p>
<h4 id="2-GIF"><a href="#2-GIF" class="headerlink" title="2.GIF"></a>2.GIF</h4><p>​		GIF是Graphics Interchange Format的缩写，也是一种比较早的图像文件格式。 由于对支持颜色数量的限制，256色远小于展示照片所需颜色的数量级，所以GIF并不适合用来呈现照片，可能用来呈现图标或Logo会更适合些， 但后来推出的PNG格式对于图形的展示效果更佳，所以当下只有在需要使用到动画时才会使用GIF。</p>
<p>接下来探讨一些关于GIF的优化点。</p>
<ol>
<li>单帧的GIF转化为PNG</li>
</ol>
<p>​		首先可以使用npm引入ImageMagick工具来检查GIF图像文件，看其中是否包含多帧动画。如果GIF图像文件中不包含多帧动画，则会返回一个GIF字符串，如果GIF图像文件中包含动画内容，则会返回多帧信息。</p>
<p>​		对于单帧图像的情况，同样可使用ImageMagick工具将其转化为更适合展示图形的PNG文件格式。对于动画的处理稍后会进一步介绍， 这里先列出代码示例:</p>
<pre><code class="javascript">const im = require(&#39;imagemagick&#39;);
//检查是否为动画
im.identify([&#39;-format&#39;,&#39;%m&#39;,&#39;my.gif&#39;],(err,output)=&gt;&#123;
    if (err) throw err;
    //通过output处理判断流程
&#125;)
//将gif转化为png
im.convert([&#39;my.gif&#39;,&#39;my.png&#39;],(err,stdout)=&gt;&#123;
    if (err) throw err;
    console.log(&#39;转化完成&#39;,stdout)
&#125;)
</code></pre>
<ol start="2">
<li>GIF 动画优化</li>
</ol>
<p>​		由于动画包含了许多静态帧，并且每个静态帧图像上的内容在相邻的不同帧上通常不会有太多的差异，所以可通过工具来移除动画里连续帧中重复的像素信息。这里可借助gifsicle来实现:</p>
<pre><code class="javascript">const &#123; execFile &#125; = require(&#39;child_process&#39;);
const gifsicle = require(&#39;gifsicle&#39;);
execFile(gifsicle,[&#39;-o&#39;,&#39;output.gif&#39;,&#39;input.gif&#39;],err =&gt; &#123;
    console.log(&#39;动画压缩完成&#39;)
&#125;)
</code></pre>
<ol start="3">
<li>用视频替换动画</li>
</ol>
<p>​		当了解过GIF的相关特性后，不难发现如果单纯以展示动面这个目的来看，那么GIF可能并不是最好的呈现方式，因为动画的内容将会受到诸如图像质量、播放帧率及播放长度等因素的限制。</p>
<p>​		GIF展示的动画没有声音，最高支持256色的图像质量，如果动画长度较长， 即便压缩过后文件也会较大。综合考虑，建议将内容较长的GIF动画转化为视频后进行插入，因为动画也是视频的一种， 成熟的视频编码格式可以让传输的动画内容节省网络带宽开销。</p>
<p>​		可以利用ffmpeg将原本的GIF文件转化为MPEG-4或WebM的视频文件格式，将一个14MB的GIF动画通过转化后得到的视频文件格式大小分别是: MPEG-4格式下867KB, WebM 格式下611KB.另外，要知道通过压缩后的动画或视频文件，在播放前都需要进行解码，可以通过Chrome的跟踪工具(chrome:&#x2F;&#x2F;tracing)查看不同格式的文件，在解码阶段的CPU占用时，文件格式与CPU耗时如表所示。</p>
<table>
<thead>
<tr>
<th>文件格式</th>
<th>CPU耗时（ms）</th>
</tr>
</thead>
<tbody><tr>
<td>GIF</td>
<td>2,668</td>
</tr>
<tr>
<td>MPEG-4</td>
<td>1,995</td>
</tr>
<tr>
<td>WebM</td>
<td>2,354</td>
</tr>
</tbody></table>
<p>​		从表中可以看出，相比视频文件，GIF 在解码阶段也是十分耗时的，所以出于对性能的考虑，在使用GIF前应尽量谨慎选择。</p>
<h4 id="3-PNG"><a href="#3-PNG" class="headerlink" title="3.PNG"></a>3.PNG</h4><p>​		PNG是一种无损压缩的高保真图片格式，它的出现弥补了GIF图像格式的一些缺点，同时规避了当时GIF中还处在专利保护期的压缩算法，所以也有人将PNG文件后缀的缩写表示成“PNG is Not GIF”。</p>
<p>​		相比于JPEG, PNG支持透明度，对线条的处理更加细腻，并增强了色彩的表现力，不过唯一的不足就是文件体积太大。如果说GIF是专门为图标图形设计的图像文件格式，JPEG是专门为照片设计的图像文件格式，那么PNG对这两种类型的图像都能支持。通常在使用中会碰到PNG的几种子类型，有PNG-8、PNG-24、 PNG-32等。</p>
<p>1.对比GIF</p>
<p>​		其中PNG-8也称为调色板PNG,除了不支持动画，其他所有GIF拥有的功能它都拥有，同时还支持完全的alpha通道透明。只要不是颜色数特别少的图像，PNG-8的压缩比表现都会更高一筹。</p>
<p>​		对于颜色数少的单帧图形图像来说，更好的做法也并不是将其存为一个GIF文件，相比雪碧图都会更好一些，因为能够大大降低HTTP请求的开销，这一点后面章节会接着介绍，此处给出个优化建议: 在使用单帧图形图像时，应当尽量用 PNG-8格式来替换GIF格式。</p>
<p>2.对比JPEG</p>
<p>​		当所处理图像中的颜色超过256种时，就需要用到JPEG或者真彩PNG,真彩PNG包括PNG-24和PNG-32二者的区别是真彩PNG-24不包括alpha透明通道，而加上8位的alpha透明通道就是真彩PNG-32。</p>
<p>​		JPEG是有损的。它拥有更高的压缩比，也是照片存储的实际标准，如果还是要用PNG,那么很可能是在清晰的颜色过度周围出现了不可接受的“大色块”。</p>
<p>3.优化PNG</p>
<p>​		PNG图像格式还有一个优点，就是便于扩展，它将图像的信息保存在“块”中，开发者便可以通过添加一些自定义的“块”来实现额外的功能，但所添加的自定义功能并非所有软件都能读取识别，大部分可能只是特定的作图软件在读取时使用而已。对Web显示而言，浏览器可能直接将这些多余的块自动忽略掉了，如果对显示没有作用，那么又何必要存储和传输这些信息呢?因此我们可以使用pngcrush对这些多余的块进行删除压缩，通过npm引入imagemin-pngcrush,代码如下:</p>
<pre><code class="javascript">const imagemin = require(&#39;imagemin&#39;);
const imageminPngcrush = require(&#39;imagemin-pngcrush&#39;);
imagemin([&#39;images/*.png&#39;],&#39;build/images&#39;,&#123;
    plugins:[imageminPngcrush()]
&#125;)
.then(()=&gt; console.log(&#39;完成图像优化&#39;))
</code></pre>
<p>其中，imageminPngcrush()中可以带入如下一些 参数进行压缩控制。</p>
<ul>
<li>-rem alla: 删除所有块，保留控制alpha透明通道的块。</li>
<li>-brute: 采用多种方法进行压缩会得到较好的压缩效果，由于执行的方法较多，所以执行压缩的速度会变慢，建议在离线操作下可以添加，但有时改进效果并不明显，如果对构建流程有要求可不加。</li>
<li>-reduce: 会尝试减少调色板使用的颜色数量。</li>
</ul>
<h4 id="4-WebP"><a href="#4-WebP" class="headerlink" title="4.WebP"></a>4.WebP</h4><p>​		前面介绍的三种图像文件格式，在呈现位图方面各有优劣势: GIF虽然包含的颜色阶数少，但能呈现动画: JPEG虽然不支持透明度，但图像文件的压缩比高:PNG虽然文件尺寸较大，但支持透明且色彩表现力强。</p>
<p>​		开发者在使用位图时对于这样的现状就需要先考虑选型。假如有一个统的图像文件格式，具有之前格式的所有优点，WebP 就在这样的期待中诞生了。</p>
<ol>
<li>WebP的优缺点</li>
</ol>
<p>​		WebP是Google在2010年推出的一种图像文件格式， 它的目标是以较高的视觉体验为前提的，尽可能地降低有损压缩和无损压缩后的文件尺寸，同时还要支持透明度与动画。根据WebP官方给出的实验数据，当使用WebP有损文件时，文件尺寸会比JPEG小25%~ 34%，而使用WebP无损文件时，文件尺寸会比PNG小26%。就像所有新技术一样， 具有如此多优异特性的WebP, 同样也不可避免兼容性的问题，CanlUse. com网站数据统计情况，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109091411793.png"></p>
<p>​	从图中可以发现，除了IE不支持，其他主流浏览器的最新版本都已支持WebP, 考虑到浏览器的市场占有率，这样的兼容性程度可以说是非常乐观的了。虽然还需要做一 些兼容性处理，但我们也有足够的理由在项目中积极地使用WebP.此外，由于有损压缩WebP使用了VP8视频关键帧编码,可能对较高质量(80~ 99)的图像编码来说，会比JPEG占用更多的计算资源，但在较低质量(0~50)时，依然有很大的优势。</p>
<p>2.如何使用WebP</p>
<p>​		可以使用图像编辑软件直接导出WebP格式的图像文件，或者将原有的JPEG或PNG图像转化为WebP格式。这样的转化最好使用构建工具辅助完成，比如通过npm安装webp-loader后，在webpack中进行如下配置:</p>
<pre><code class="javascript">loader:[&#123;
    test:/\.(jpe?g|png)$/I,
    loaders:[
        &#39;file-loader&#39;,
        &#39;webp-loader?&#123;quality:13&#125;&#39;
    ],
&#125;]
</code></pre>
<p>​		这里值得注意的是，尽量不要使用低质量的JPEG格式进行WebP转化，因为低质量的JPEG中可能包含压缩的伪像，这样WebP不仅要保存图像信息，还要保存JPEG添加的失真，从而影响最终的转化效果。所以在选择转化的源图像文件时，建议使用质量最佳的。</p>
<p>3.兼容性处理</p>
<p>​		目前WebP格式的图像并不适用于所有浏览器，所以在使用时，应当注意兼容处理好不支持的浏览器场景。</p>
<p>​		通常的处理思路分为两种:一种是在前端处理浏览器兼容性的判断，可以通过浏览器的全局属性window.navigator. userAgent获取版本信息，再根据兼容支持情况，选择是否请求WebP图像格式的资源;也可以使用<picture>标签来选择显示的图像格式，在<picture> 标签中添加多个<source>标签元素，以及一个包含旧图像格式的<img>标签，当浏览器在解析DOM时便会对<picture>标签中包含的多个图片源依次进行检测。</p>
<p>​		倘若浏览器不支持WebP格式而未能检测获取到，最后也能够通过<img>标记兼容显示出旧图像格式，例如:</p>
<pre><code class="html">&lt;picture&gt;
   &lt;source srcset=&quot;/path/image.webp&quot; type=&quot;image/webp&quot;&gt;
   &lt;img src=&quot;/path/image.jpg&quot; alt=&quot;&quot;&gt;
&lt;/picture&gt;
</code></pre>
<p>这见需要注意的<source>标签的顺序位置，应当将包含image&#x2F;webp的图像源写在旧图像格式的前面。</p>
<p>​		另一种是将判断浏览器是否支持的工作放在后端处理，让服务器根据HTTP请求头的Accept字段来决定返回图像的文件格式。如果Accept 字段中包含image&#x2F;webp，就返回WebP图像格式，否则就使用旧图像格式(JPEG、PNG等)返回。这样做的好处是让系统的维护性更强，无论浏览器对WebP图像格式的兼容支持发生怎样的改变，只需要服务器检查Accept字段即可，无须前端跟进相应的修改。</p>
<h4 id="5-SVG"><a href="#5-SVG" class="headerlink" title="5.SVG"></a>5.SVG</h4><p>​		前面介绍的几种图像文件格式呈现的都是位图，而SVG呈现的是矢量图。正如我们在介绍位图和矢量图时讲到的，SVG对图像的处理不是基于像素栅格的，而是通过图像的形状轮廓、屏幕位置等信息进行描述的。</p>
<p>1.优缺点</p>
<p>​		SVG这种基于XML语法描述图像形状的文件格式，就适合用来表示Logo等图标图像，它可以无限放大并且不会失真，无论分辨率多高的屏幕，个文件就可以统一适配:另外，作为文本文件，除了可以将SVG标签像写代码样写在HTML中，还可以把对图标图像的描述信息写在以.svg为后缀的文件中进行存储和引用。</p>
<p>​		由于文本文件的高压缩比，最后得到的图像文件体积也会更小。要说缺点与不足，除了仅能表示矢量图，还有就是使用的学习成本和渲染成本比较高。</p>
<p>2.优化建议</p>
<p>即便SVG图像文件拥有诸多优点，但依然有可优化的空间。下面介绍一些优化建议。</p>
<p>（1）应保持SVG尽量精简，去除编辑器创建SVG时可能携带的一些冗余信息，比如注释、隐藏图层及元数据等。</p>
<p>（2）由于显示器的本质依然是元素点构成位图，所以在渲染绘制矢量图时，就会比位图的显示多一步光栅化的过程。为了使浏览器解析渲染的过程更快，建议使用预定义的SVG形状来代替自定义路径，这样会减少最终生成图像所包含标记的数量，预定义形状有<circle>、<recD>、 <line>、 <polygon>等。</p>
<p>（3）如果必须使用自定义路径，那么也尽量少用曲线。</p>
<p>（4）不要在SVG中嵌入位图。</p>
<p>（5）使用工具优化SVG,这里介绍一款基于node.js 的优化工具svgo;它可以通过降低定义中的数字精度来缩小文件的尺寸。通过npm install -g svgo 可直接安装命令方式使用，若想用webpack进行工程化集成，可加入svgo-loader的相关配置:</p>
<pre><code class="javascript">module.exports = &#123;
    rules:[
        test: /\.svg$/,
        use: [
            &#123;loader:&#39;file-loader&#39;&#125;,
            &#123;loader:&#39;svgo-loader&#39;,options:&#123;externalConfig:&#39;svgo-config.yml&#39;&#125;,
        &#125;]
    ]
&#125;
</code></pre>
<p>其中，可在 svgo-config.yml 的配置文件中定义相关优化选项：</p>
<pre><code class="java">plugins:
 - removeTitle: true
 - convertPathData: false
 - convertColors:
    shorthex: false
</code></pre>
<p>（6）优化过后，使用gzip压缩和（或）brotli压缩。</p>
<h4 id="6-Base64"><a href="#6-Base64" class="headerlink" title="6.Base64"></a>6.Base64</h4><p>​		准确地说，Base64 并不是一种图像文件格式， 而是种用于传输 8位字节码的编码方式，它通过将代表图像的编码直接写入HTML或CSS中来实现图像的展示，一般展示图像的方法都是通过将图像文件的URL值传给img标签的src属性，当HTML解析到img标签时，便会发起对该图像URL的网络请求:</p>
<p>&lt; img src&#x3D;”<a href="https://xx.cdn.com/photo.jpg&quot;&gt;">https://xx.cdn.com/photo.jpg&quot;&gt;</a></p>
<p>​		当采用Base64编码图像时，写入src的属性值不是URL值，而是类似下面的编码:data: image&#x2F;png;base64, iVBORwOKGgOAAAANSUhEUgAABYAAAWCAYAADEtGw7AA.</p>
<p>​		浏览器会自动解析该编码并展示出图像，而无须发起任何关于该图像的URL，这是Base64的优点，同时也隐含了对于使用的限制。由于Base64编码原理的特点，一般经过Base64编码后的图像大小，会膨胀四分之三。</p>
<p>​		这对想尝试通过Base64方式尽可能减少HTTP请求次数来说是得不偿失的，较复杂的大图经过编码后，所节省的几次HTTP请求，与图像文件大小增加所带来的带宽消耗相比简直是杯水车薪。所以也只有对小图而言，Base64 才能体现出真正的性能优势。</p>
<p>​		作为使用指导建议，笔者希望在考虑是否使用Base64编码时，比对如下几个条件:</p>
<ul>
<li>图像文件的实际尺寸是否很小。</li>
<li>图像文件是否真的无法以雪碧图的形式进行引入。</li>
<li>图像文件的更新频率是否很低，以避免在使用Base64时，增加不心必要的维护成本。</li>
</ul>
<h4 id="7-格式选择建议"><a href="#7-格式选择建议" class="headerlink" title="7.格式选择建议"></a>7.格式选择建议</h4><p>​		在了解了不同图像文件格式的特性后，显而易见的是不存在适用于任何场景且性能最优的图像使用方式。所以作为开发者，想要网站性能在图像方面达到最优，如何根据业务场景选择合适的文件格式也至关重要，图像文件使用策略如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109101114259.png" alt="图像文件使用策略"></p>
<p>​		这里根据使用场景的不同，以及图像文件的特性给出了一个可参考的选择策略:考虑到矢量图具有缩放不失真且表示图标时较小的文件尺寸，凡用到图标的场景应尽量使用矢量图:而对于位图的使用场景，由于在相同图像质量下其具有更高的压缩比且支持动画，所以WebP格式应该是我们的首选。</p>
<p>​		考虑到新技术的兼容性问题，也需要采用传统的方式进行适配;包含动画时使用GIF,对图像要求有更高分辨率来展示细节且需要透明度时，建议使用PNG;而在其他场景下追求更高的图像压缩比时，可使用JPEG.除此之外，位图对于不同缩放比的响应式场景，建议提供多张不同尺寸的图像，让浏览器根据具体场景进行请求调用。</p>
<h3 id="三、使用建议"><a href="#三、使用建议" class="headerlink" title="三、使用建议"></a>三、使用建议</h3><p>​		本节额外给出些使用建议来优化图像 资源的体验性能， 包括合并多张小图资源请求次数的雪碧图方案，使用Web字体的方式来替代图标文件及display:none使用的注意事项。</p>
<h4 id="1-CSS-Sprite"><a href="#1-CSS-Sprite" class="headerlink" title="1.CSS Sprite"></a>1.CSS Sprite</h4><p>​		CSS Sprite技术就是我们常说的雪碧图，通过将多张小图标拼接成一张大图， 有效地减少HTTP请求数量以达到加速显示内容的技术。</p>
<p>​		通常对于雪碧图的使用场景应当满足以下条件:首先这些图标不会随用户信息的变化而变化，它们属于网站通用的静态图标;同时单张图标体积要尽量小，这样经过拼接后其性能的提升才会比较乐观;若加载量比较大则效果会更好。</p>
<p>​		不建议将较大的图片拼接成雪碧图，因为大图拼接后的单个文件体积会非常大，这样占用网络带宽的增加与请求完成所耗费时间的延长，会完全淹没通过减少HTTP请求次数所带来的性能提升。下面来看一个雪碧图实际案例，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109102349521.png"></p>
<p>​		图中截取了淘宝网一处图标导航栏及请求的相应资源，通过案例还可以看出所拼接的雪碧图是一张PNG格式的图像文件，其中的图标不只含有一种颜色， 同时也可支持颜色渐变，这通常是单色Web字体很难具备的表现力。</p>
<p>雪碧图的使用方式也很简单，通过CSS 的background-image 属性引入雪碧图的UrL后，再使用background-position定位所需要的单个图标在雪碧图上的起始位置，配合width和height属性来锁定具体图标的尺寸，示例代码如下:</p>
<pre><code class="css">.sprite-sheet&#123;
    background-image: url(https://img.xxxx.com/xxx/sprite-sheet.png);
    background-size: 24px 600px;
&#125;
.icon-1 .sprite-sheet&#123;
    background-position: 0 0;
    height: 24px;
    width: 24px;
&#125;
.icon-2 .sprite-sheet&#123;
    background-position: 0 -24px;
    height: 24px;
    width: 24px;
&#125;
</code></pre>
<p>​		其中，background-position属性关于横纵偏移的设置规则指的是如何通过设置背景图的偏移，将雪碧图上所需图标的左上角起始位置移至坐标(0,0)位置。与通常数学上的直角坐标系不同，浏览器中的坐标系Y轴正方向是垂直向下的。当引入雪碧图后，整个图片的左上角起始位置在(0,0)，所以要得到其中的某个图标，我们就需要将雪碧图向负轴方向进行偏移，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109105436897.png" alt="雪碧图与坐标系"></p>
<p>​		如果使用第一行左边第一 个图标，则可通过设置background-position: 0 0来让雪碧图不偏移(两个0之间有空格，分别表示在X轴、Y轴的位置)，倘若要使用第二行中间的图标，就需要将雪碧图向左上方偏移，将属性backgound-position的值设置为-24px -24px，注意是负值，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109105529239.png" alt="偏移后的雪碧图"></p>
<p>​		使用雪碧图来提升小图标加载性能的历史由来已久。在HTTP 1.x环境下，它确实能够减少相应的HTTP请求，但需要注意当部分图标变更时，会导致已经加载的雪碧图缓存失效。同时在HTTP2中，最好的方式应该是加载单张图像文件，因为可以在一个HTTP连接上发起多次请求，所以对于是否使用此方法，需要考虑具体的使用环境和网络设置。</p>
<h4 id="2-Web-字体"><a href="#2-Web-字体" class="headerlink" title="2.Web 字体"></a>2.Web 字体</h4><p>​		使用Web字体有多种优点:增强网站的设计感、可读性，同时还能搜索和选取所表示的文本内容，且不受屏幕尺寸与分辨率的影响，能提供一致的视觉体验。 除此之外，由于每个字型都是特定的矢量图标，所以可以将项目中用到的矢量图标打包到一个Web字体文件中使用，以节省对图标资源的HTTP请求次数，这样做类似雪碧图优化目的。</p>
<p>1.字体的使用</p>
<p>​		目前网络上常用的字体格式有: EOT、TTF、WOFF与WOFF2,由于存在兼容性的问题，并没有哪一种字体能够适用所有浏览器，所以在实际使用中，网站开发者会声明提供字体的多种文件格式，来达到一致性的体验效果。</p>
<p>在Web项目中，一般 会先通过@font-face声明使用的字体系列:</p>
<pre><code class="css">@font-face &#123;
font-family: &#39;tianfont&#39;;
src: url(&#39;//at.alicdn.com/t/font_ 1307911 xxxx.eot&#39;);
src: url(&#39;//at.alicdn.com/t/fot 1307911 xxx.eot?#iefix&#39;) format(&#39;enmbederopentype&#39;),
url(&#39;//at.alicdn.com/t/font_ 1307911 xxxx.woff2&#39;) format(&#39;woff2&#39;),
url(&#39;//at.alicdn.com/t/font_ 1307911 xxxx.woff&#39;) format(&#39;woff&#39;),
url(&#39;//at.alicdn.com/t/font_ 1307911_ xxxx.ttf&#39;) format (&#39;truetype&#39;),
url(&#39;//at.alicdn.com/t/font_ 1307911 xxxx.svg#tianfont&#39;) format(&#39;svg&#39;),
&#125;
</code></pre>
<p>​		在上述代码中通过src字段的属性值，可以指定字体资源的位置，并且该属性值还可以提供一个用逗 号分隔的列表，列表中不同字体文件格式的资源顺序同样重要，浏览器将选取其所支持的第一个格式资源。 如果希望较新的WOFF2格式被使用，则应当将WOFF2声明在WOFF之上。</p>
<p>2.子集内嵌</p>
<p>​		对于同一个字符，Web字体可以根据样式、粗细及拉伸等属性的不同，拥有多种变种的字型展示。如果将所有字型都打包成一个文件来请求使用， 不免就会存在许多根本用不到的字型信息浪费带宽。相较于拉丁文字体而言，包含中文字符的字体文件的大小会格外突出。字体文件是否能够按需加载，就成为一个显而易见的优化项，这便是子集内嵌。</p>
<p>​		通过@font- face和unicode-range属性就可以定义所使用的字体子集，属性unicode-range用来指定所需字体在@font-face声明字体集中的子集范围，它支持三种形式:单一取值(如U+233)、范围取值(如U+233-2ff)、通配符范围( 如U+2??),取值的含义是字体集文件中的代码索引点，具体使用示例如下:</p>
<pre><code class="css">@font-face &#123;
font-family: &#39;Awesome Font&#39; ;
font-style: normal;
font-weight: 500;
src: 
  url(&#39;/fonts/awesome.woff2&#39;) format(&#39;woff2&#39;),
  url(&#39;/fonts/awesome.woff&#39;) format(&#39;woff&#39;),
  url(&#39;/fonts/awesome.ttf&#39;) format(&#39;ttf&#39;),
  url(&#39;/fonts/awesome.eot&#39;) format(&#39;eot&#39;),
  unicode-range: U+100-3ff, U+f??
&#125;
</code></pre>
<p>​		通过使用子集内嵌，以及为字体的不同样式变体采用单独的文件，用户可以仅根据需要下载字体的子集，而不必强制他们下载可能永远都不会用到的字体子集，这样对字体下载优化来说会更快速高效。不过属性unicode-range也存在兼容性的问题，对于不支持的浏览器，若想提供必要的子集字体支持，则可能需要手动处理字体文件。</p>
<p>3.字体文件预加载</p>
<p>在默认情况下，构建谊染树之前会阻塞字体文件的请求，这将可能导致部分文本谊染延迟，对此我们可使用-link re-reloao”&gt;对字体资源进行预加载。关于预加载的详细内容，会在加载优化章节进一步 介绍。</p>
<pre><code class="html">&lt;head&gt;
&lt;link rel=&quot;preload&quot; href=&quot;/ fonts/ awesome .woff2&quot; as=&quot; font&quot;&gt;
&lt;/head&gt;
</code></pre>
<link rel="preload">需要和@font-face对字体的定义一同使用，它只负责提示浏览器需要预加载给定的资源，而不指明如何使用。但同时需要注意的是，这样做将会无条件向网络发出字体请求，如果项目迭代将原本使用的字体文件修改或删除，也需同步删除对字体预加载的设置。

<h4 id="3-注意display-none的使用"><a href="#3-注意display-none的使用" class="headerlink" title="3.注意display:none的使用"></a>3.注意display:none的使用</h4><p>​	在使用位图时，经常会根据屏幕尺寸、权限控制等不同条件，响应式地处理资源的展示与隐藏。出于对性能的考虑，希望对于不展示的图像:尽量避免在首展时进行资源请求加载。但根据一些直觉性的编程习惯， 读者们真的确定所控制隐藏的图像，是否有发起资源请求吗?来看下面两个例子。</p>
<p>下面img1.jpg的图像文件是否有被浏览器发起请求?即使父级的div 设置为不显示。</p>
<pre><code class="html">&lt;div style=&quot;display:none&quot;&gt;
  &lt; img src=&quot;img1.jpg&quot;&gt;
&lt;/div&gt;
</code></pre>
<p>根据HTML的解析顺序，答案是肯定的，img1.jpg 的图像文件会被请求。那么下面img2.jpg的图像文件会发起请求吗?</p>
<pre><code class="html">&lt;div style=&quot;display:none&quot;&gt;
  &lt;div style=&quot;background: url(img2. jpg) &quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>CSS解析后发现父级使用了display:none, 再去计算子级的样式就没有多大意义了，所以就不会去下载子级div的背景图像。</p>
<p>如果不清楚不同浏览器对display:none 关于图像加载的控制，则可以通过开发者工具进行验证。这里推荐的做法是使用<picture>或&lt; img srcset&gt;的方式进行响应式显示。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​		本章首先从图像基础开始，在普及了包括图像的构成表示、分类压缩等知识之后对前端项目中常用的图像文件格式GIF、JPEG、PNG、 SVG、 WebP 及Base64进行了细致的分析介绍，包括它们之间优缺点的比较，具体场景下的技术选型，以及优化使用建议和工程实践。给出了三点与图像相关的优化技术与建议，希望同学能够明白Web项目中的图像优化是一项技术也是一门艺术， 技术指的是对于每一种图像文件的压缩和使用都有一套工程化的手段，艺术指的是当面对具体的项目实践时，如何技术选型与压缩以达到对用户最佳的体验效果，则需要在多个维度上进行权衡与取舍，并不存在明确的最佳方案。</p>
<p>本章最后给出一些希望同学能够记住的方法与技巧:</p>
<ul>
<li>适合用矢量图的地方首选矢量图。</li>
<li>使用位图时首选WebP,对不支持的浏览器场景进行兼容处理。</li>
<li>尽量为位图图像格式找到最佳质量设置。</li>
<li>删除图像文件中多余的元数据。</li>
<li>对图像文件进行必要的压缩。</li>
<li>为图像提供多种缩放尺寸的响应式资源。</li>
<li>对工程化通用图像处理流程尽量自动化。</li>
</ul>
<h3 id="参考书籍：web前端性能优化"><a href="#参考书籍：web前端性能优化" class="headerlink" title="参考书籍：web前端性能优化"></a>参考书籍：web前端性能优化</h3>]]></content>
      <categories>
        <category>前端性能优化</category>
        <category>图像优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全服务端</title>
    <url>/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（服务端）"><a href="#前端面试题大全（服务端）" class="headerlink" title="前端面试题大全（服务端）"></a>前端面试题大全（服务端）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="♥︎-♥︎-♥︎-http状态码有哪些"><a href="#♥︎-♥︎-♥︎-http状态码有哪些" class="headerlink" title="♥︎ ♥︎ ♥︎ http状态码有哪些"></a>♥︎ ♥︎ ♥︎ http状态码有哪些</h3><p><code>http</code>状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态</p>
<p>状态码第一位数字决定了不同的响应状态，有如下：</p>
<ul>
<li>1 表示消息</li>
<li>2 表示成功</li>
<li>3 表示重定向</li>
<li>4 表示请求错误</li>
<li>5 表示服务器错误</li>
</ul>
<h4 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h4><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</p>
<p>常见的有：</p>
<ul>
<li>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li>
<li>101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级</li>
</ul>
<h4 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h4><p>代表请求已成功被服务器接收、理解、并接受</p>
<p>常见的有：</p>
<ul>
<li>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</li>
<li>201（已创建）：请求成功并且服务器创建了新的资源</li>
<li>202（已创建）：服务器已经接收请求，但尚未处理</li>
<li>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</li>
<li>204（无内容）：服务器成功处理请求，但没有返回任何内容</li>
<li>205（重置内容）：服务器成功处理请求，但没有返回任何内容</li>
<li>206（部分内容）：服务器成功处理了部分请求</li>
</ul>
<h4 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h4><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</p>
<p>常见的有：</p>
<ul>
<li>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</li>
<li>301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li>
<li>302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li>
<li>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li>
<li>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</li>
<li>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li>
</ul>
<h4 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h4><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</p>
<p>常见的有：</p>
<ul>
<li>400（错误请求）： 服务器不理解请求的语法</li>
<li>401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li>
<li>403（禁止）： 服务器拒绝请求</li>
<li>404（未找到）： 服务器找不到请求的网页</li>
<li>405（方法禁用）： 禁用请求中指定的方法</li>
<li>406（不接受）： 无法使用请求的内容特性响应请求的网页</li>
<li>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</li>
<li>408（请求超时）： 服务器等候请求时发生超时</li>
</ul>
<h4 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h4><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p>
<p>常见的有：</p>
<ul>
<li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li>
<li>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</li>
<li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li>
<li>503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）</li>
<li>504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li>
<li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li>
</ul>
<p>下面给出一些状态码的适用场景：</p>
<ul>
<li>100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输</li>
<li>206：一般用来做断点续传，或者是视频文件等大文件的加载</li>
<li>301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名</li>
<li>302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</li>
<li>304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</li>
<li>400：参数有误，请求无法被服务器识别</li>
<li>403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回</li>
<li>404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时</li>
<li>503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503</li>
<li>504：网关超时</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-你知道哪些http首部字段？"><a href="#♥︎-♥︎-♥︎-你知道哪些http首部字段？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你知道哪些http首部字段？"></a>♥︎ ♥︎ ♥︎ 你知道哪些http首部字段？</h3><p>HTTP头字段（HTTP header fields）,是指在超文本传输协议（HTTP）的请求和响应消息中的消息头部分</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>能够接受的回应内容类型（Content-Types）</td>
<td>Accept: text&#x2F;plain</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>能够接受的字符集</td>
<td>Accept-Charset: utf-8</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>能够接受的编码方式列表</td>
<td>Accept-Encoding: gzip, deflate</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>能够接受的回应内容的自然语言列表</td>
<td>Accept-Language: en-US</td>
</tr>
<tr>
<td>Authorization</td>
<td>用于超文本传输协议的认证的认证信息</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>用来指定在这次的请求&#x2F;响应链中的所有缓存机制 都必须 遵守的指令</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>该浏览器想要优先使用的连接类型</td>
<td>Connection: keep-alive Connection: Upgrade</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie</td>
<td>Cookie: $Version&#x3D;1; Skin&#x3D;new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>以 八位字节数组 （8位的字节）表示的请求体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的 多媒体类型</td>
<td>Content-Type: application&#x2F;x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>发送该消息的日期和时间</td>
<td>Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>表明客户端要求服务器做出特定的行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>Host</td>
<td>服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号</td>
<td>Host: en.wikipedia.org:80 Host: en.wikipedia.org</td>
</tr>
<tr>
<td>If-Match</td>
<td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>允许在对应的内容未被修改的情况下返回304未修改</td>
<td>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>允许在对应的内容未被修改的情况下返回304未修改</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Range</td>
<td>仅请求某个实体的一部分</td>
<td>Range: bytes&#x3D;500-999</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器的浏览器身份标识字符串</td>
<td>User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:12.0) Gecko&#x2F;20100101 Firefox&#x2F;21.0</td>
</tr>
<tr>
<td>Origin</td>
<td>发起一个针对 跨来源资源共享 的请求</td>
<td>Origin: <a href="http://www.example-social-network.com/">http://www.example-social-network.com</a></td>
</tr>
</tbody></table>
<h3 id="♥︎-♥︎-♥︎-为什么浏览器要限制TCP的最大个数"><a href="#♥︎-♥︎-♥︎-为什么浏览器要限制TCP的最大个数" class="headerlink" title="♥︎ ♥︎ ♥︎ 为什么浏览器要限制TCP的最大个数"></a>♥︎ ♥︎ ♥︎ 为什么浏览器要限制TCP的最大个数</h3><p>建立一个tcp连接需要：1，socket文件描述符；2，IP地址；3，端口；4，内存</p>
<p>1、内存资源： 一个tcp连接最小占用内存为4096+4096 &#x3D; 8k， 那么对于一个8G内存的机器，在不考虑其他限制下， 最多支持的并发量为：810241024&#x2F;8 约等于100万， 在实际中，由于linux kernel对一些资源的限制， 加上程序的业务处理，所以，8G内存是很难达到100万连接的</p>
<p>2、CPU资源</p>
<h3 id="♥︎-♥︎-♥︎-说说-HTTP1-0-x2F-1-1-x2F-2-0-的区别"><a href="#♥︎-♥︎-♥︎-说说-HTTP1-0-x2F-1-1-x2F-2-0-的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?"></a>♥︎ ♥︎ ♥︎ 说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?</h3><h4 id="一、HTTP1-0"><a href="#一、HTTP1-0" class="headerlink" title="一、HTTP1.0"></a>一、HTTP1.0</h4><p><code>HTTP</code>协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本</p>
<p><code>HTTP 1.0</code> 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个<code>TCP</code>连接</p>
<p>服务器完成请求处理后立即断开<code>TCP</code>连接，服务器不跟踪每个客户也不记录过去的请求</p>
<p>简单来讲，每次与服务器交互，都需要新开一个连接</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65666666346461302d623933612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>例如，解析<code>html</code>文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接</p>
<p>最终导致，一个<code>html</code>文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接</p>
<p>这种形式明显造成了性能上的缺陷</p>
<p>如果需要建立长连接，需要设置一个非标准的Connection字段 <code>Connection: keep-alive</code></p>
<h4 id="二、HTTP1-1"><a href="#二、HTTP1-1" class="headerlink" title="二、HTTP1.1"></a>二、HTTP1.1</h4><p>在<code>HTTP1.1</code>中，默认支持长连接（<code>Connection: keep-alive</code>），即在一个TCP连接上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟</p>
<p>建立一次连接，多次请求均由这个连接完成</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32326462326239302d623933622d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>这样，在加载<code>html</code>文件的时候，文件中多个请求和响应就可以在一个连接中传输</p>
<p>同时，<code>HTTP 1.1</code>还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间</p>
<p>同时，<code>HTTP1.1</code>在<code>HTTP1.0</code>的基础上，增加更多的请求头和响应头来完善的功能，如下：</p>
<ul>
<li>引入了更多的缓存控制策略，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略</li>
<li>引入range，允许值请求资源某个部分</li>
<li>引入host，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点</li>
</ul>
<p>并且还添加了其他的请求方法：<code>put</code>、<code>delete</code>、<code>options</code>…</p>
<h4 id="三、HTTP2-0"><a href="#三、HTTP2-0" class="headerlink" title="三、HTTP2.0"></a>三、HTTP2.0</h4><p>而<code>HTTP2.0</code>在相比之前版本，性能上有很大的提升，如添加了一个特性：</p>
<ul>
<li>多路复用</li>
<li>二进制分帧</li>
<li>首部压缩</li>
<li>服务器推送</li>
</ul>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p><code>HTTP/2</code> 复用<code>TCP</code>连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33313366313938302d623933622d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>上图中，可以看到第四步中<code>css</code>、<code>js</code>资源是同时发送到服务端</p>
<h5 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h5><p>帧是<code>HTTP2</code>通信中最小单位信息</p>
<p><code>HTTP/2</code> 采用二进制格式传输数据，而非 <code>HTTP 1.x </code>的文本格式，解析起来更高效</p>
<p>将请求和响应数据分割为更小的帧，并且它们采用二进制编码</p>
<p><code>HTTP2 </code>中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流</p>
<p>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件</p>
<h5 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h5><p><code>HTTP/2</code>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送</p>
<p>首部表在<code>HTTP/2</code>的连接存续期内始终存在，由客户端和服务器共同渐进地更新</p>
<p>例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33633533363734302d623933622d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><p><code>HTTP2</code>引入服务器推送，允许服务端推送资源给客户端</p>
<p>服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源</p>
<p>免得客户端再次创建连接发送请求到服务器端获取</p>
<p>这种方式非常合适加载静态资源</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34373133303535302d623933622d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>HTTP1.0：</p>
<ul>
<li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接</li>
</ul>
<p>HTTP1.1：</p>
<ul>
<li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用</li>
<li>在同一个TCP连接里面，客户端可以同时发送多个请求</li>
<li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li>
<li>新增了一些请求方法</li>
<li>新增了一些请求头和响应头</li>
</ul>
<p>HTTP2.0：</p>
<ul>
<li>采用二进制格式而非文本格式</li>
<li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li>
<li>使用报头压缩，降低开销</li>
<li>服务器推送</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-HTTP2-0的特点"><a href="#♥︎-♥︎-♥︎-HTTP2-0的特点" class="headerlink" title="♥︎ ♥︎ ♥︎  HTTP2.0的特点"></a>♥︎ ♥︎ ♥︎  HTTP2.0的特点</h3><p>HTTP2.0大幅度的提高了web性能，在HTTP1.1完全语意兼容的基础上，进一步减少了网络的延迟。</p>
<ol>
<li>二进制分帧</li>
<li>多路复用</li>
<li>首部压缩</li>
<li>流量控制</li>
<li>请求优先级</li>
<li>服务器推送</li>
</ol>
<h3 id="♥︎-♥︎-♥︎-简述https原理，以及与http的区别"><a href="#♥︎-♥︎-♥︎-简述https原理，以及与http的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ 简述https原理，以及与http的区别"></a>♥︎ ♥︎ ♥︎ 简述https原理，以及与http的区别</h3><ol>
<li>HTTP协议工作在80端口，HTTPS协议工作在443端口</li>
<li>HTTPS需要申请证书（用于验证服务器身份）</li>
<li>HTTP在TCP三次握手建立连接之后即可开始传输数据；HTTPS协议则需要在建立TCP连接之后客户端与服务器在进行SSL加密，确定对话密钥，完成加密后才开始传输数据。</li>
<li>HTTPS协议传输是密文，HTTP协议传输是明文</li>
</ol>
<h3 id="♥︎-♥︎-♥︎-CDN-是什么？描述下-CDN-原理？为什么要用-CDN"><a href="#♥︎-♥︎-♥︎-CDN-是什么？描述下-CDN-原理？为什么要用-CDN" class="headerlink" title="♥︎ ♥︎ ♥︎ CDN 是什么？描述下 CDN 原理？为什么要用 CDN?"></a>♥︎ ♥︎ ♥︎ CDN 是什么？描述下 CDN 原理？为什么要用 CDN?</h3><p>CDN的全称是Content Delivery Network，即内容分发网络 共有云厂商在全世界各地都遍布不计其数都数据中心和服务器， CDN服务简单来讲就是这些厂商将你的服务器上面的文档分发到他们不同地区的服务器的当中， 每个地区可以称为一个节点，这样用户在访问你的网址时， 浏览器发送的请求就会优先绕去离客户最近的节点来获取数据， 这样方便客户更快的速度访问网站。 CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器， 通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容， 降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
<h3 id="♥︎-♥︎-♥︎-DNS-查询的过程，分为哪两种，是怎么一个过程"><a href="#♥︎-♥︎-♥︎-DNS-查询的过程，分为哪两种，是怎么一个过程" class="headerlink" title="♥︎ ♥︎ ♥︎ DNS 查询的过程，分为哪两种，是怎么一个过程"></a>♥︎ ♥︎ ♥︎ DNS 查询的过程，分为哪两种，是怎么一个过程</h3><p>1、分布域名解析：是指分在客户端上维护一个静态的文本文件，其中包含主机名和IP地址的映射。 随着网络规模的扩大，分布式分辨率的有效性越来越低。</p>
<p>2、集中式域名解析：要求网络中有多台DNS服务器，负责维护域名&#x2F;IP地址映射数据库。 客户端从指定的服务器获取域名的地址信息。一旦客户端指定的DNS服务器不包含相应的数据， DNS服务器就会在网络中进行递归查询，并获取其他服务器上的地址信息。</p>
<h3 id="♥︎-♥︎-♥︎-强缓存和协商缓存的区别"><a href="#♥︎-♥︎-♥︎-强缓存和协商缓存的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ 强缓存和协商缓存的区别"></a>♥︎ ♥︎ ♥︎ 强缓存和协商缓存的区别</h3><p>强缓存（本地缓存）:直接使用本地的缓存，不用跟服务器进行通信</p>
<p>相关header字段</p>
<p>expires：一个未来时间，代表请求有效期，没有过期之前都使用当前请求。</p>
<p>cache-control</p>
<p>no-cache：不使用本地缓存。向浏览器发送新鲜度校验请求</p>
<p>pubilc：任何情况下都缓存（即使是HTTP认证的资源）</p>
<p>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存</p>
<p>no-store：禁止浏览器缓存数据，也禁止保存至临时文件中，每次都重新请求，多次设置 cache-control，优先级最高</p>
<p>协商缓存:将资源一些相关信息返回服务器，让服务器判断浏览器是否能直接使用本地缓存，整个过程至少与服务器通信一次</p>
<p>相关header字段</p>
<p>Last-Modified&#x2F;If-Modified-Since（两个都是时间格式字符串）</p>
<p>浏览器第一次发请求，服务器在返回的 respone 的 header 加上 Last-Modified，表示资源的最后修改时间再次请求资源，在 requset 的 header 加上 If-Modified-Since ，值就是上一次请求返回的 Last-Modified 值</p>
<p>服务器根据请求传过来的值判断资源是否有变化，没有则返回 304，有变化就正常返回资源内容，更新 LastModified 的值</p>
<p>304 从缓存加载资源，否则直接从服务器加载资源</p>
<p>Etag&#x2F;If-None-Match与 Last-Modified&#x2F;If-Modified-Since 不同的是，返回 304 时，ETag 还是会重新生成返回至浏览器。</p>
<h3 id="♥︎-♥︎-♥︎-为什么from表单提交没有跨域问题，但ajax有跨域问题"><a href="#♥︎-♥︎-♥︎-为什么from表单提交没有跨域问题，但ajax有跨域问题" class="headerlink" title="♥︎ ♥︎ ♥︎ 为什么from表单提交没有跨域问题，但ajax有跨域问题"></a>♥︎ ♥︎ ♥︎ 为什么from表单提交没有跨域问题，但ajax有跨域问题</h3><p>浏览器的策略本质是：一个域名下面的JS，没有经过允许是不能读取另一个域名的内容，但是浏览器不阻止你向另外一个域名发送请求。 所以form表单提交没有跨域问题，提交form表单到另外一个域名，原来页面是无法获取新页面的内容，或者说form提交后不需要返回，但是ajax是需要返回的。 而ajax是想要读取响应内容，浏览器是不允许你这么做的。 浏览器的安全策略限制的是js脚本，并不限制src，form表单提交之类的请求， 就是说form表单提交不存在安全问题，ajax提交跨域存在安全问题。</p>
<hr>
<h3 id="♥︎-♥︎-♥︎-♥︎-url从输入到渲染页面的全过程"><a href="#♥︎-♥︎-♥︎-♥︎-url从输入到渲染页面的全过程" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ url从输入到渲染页面的全过程"></a>♥︎ ♥︎ ♥︎ ♥︎ url从输入到渲染页面的全过程</h3><p>浏览器构建HTTP Request请求， DNS解析URL地址、生成HTTP请求报文、构建TCP连接、使用IP协议选择传输路线</p>
<p>将请求通过网络传输到服务端 </p>
<p>从客户机到服务器需要通过许多网络设备，一般包括集线器、交换器、路由器等</p>
<p>服务器构建HTTP Response响应，响应客户端的请求</p>
<p>将响应体的数据通过网络传输返回给客户端</p>
<p>浏览器渲染页面 解析HTML、CSS、JS，生成RenderTree渲染页面</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-TCP为什么需要三次握手和四次挥手？"><a href="#♥︎-♥︎-♥︎-♥︎-TCP为什么需要三次握手和四次挥手？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ TCP为什么需要三次握手和四次挥手？"></a>♥︎ ♥︎ ♥︎ ♥︎ TCP为什么需要三次握手和四次挥手？</h3><h4 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h4><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包</p>
<p>主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</p>
<p>过程如下：</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接</li>
</ul>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66623438396663302d626562392d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>上述每一次握手的作用如下：</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了<br>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了<br>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常</li>
<li>第三次握手：客户端发包，服务端收到了。<br>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</li>
</ul>
<p>通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了</p>
<h4 id="为什么不是两次握手"><a href="#为什么不是两次握手" class="headerlink" title="为什么不是两次握手?"></a>为什么不是两次握手?</h4><p>如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到</p>
<p>并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源</p>
<h4 id="二、四次挥手"><a href="#二、四次挥手" class="headerlink" title="二、四次挥手"></a>二、四次挥手</h4><p><code>tcp</code>终止一个连接，需要经过四次挥手</p>
<p>过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li>
</ul>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613365626239302d626562612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="四次挥手原因"><a href="#四次挥手原因" class="headerlink" title="四次挥手原因"></a>四次挥手原因</h4><p>服务端在收到客户端断开连接<code>Fin</code>报文后，并不会立即关闭连接，而是先发送一个<code>ACK</code>包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送<code>FIN</code>报文断开连接，因此需要四次挥手</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>一个完整的三次握手四次挥手如下图所示：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36353934313439302d626562612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-说一下http缓存策略，有什么区别，分别解决了什么问题？"><a href="#♥︎-♥︎-♥︎-♥︎-说一下http缓存策略，有什么区别，分别解决了什么问题？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说一下http缓存策略，有什么区别，分别解决了什么问题？"></a>♥︎ ♥︎ ♥︎ ♥︎ 说一下http缓存策略，有什么区别，分别解决了什么问题？</h3><p>浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存, 如果缓存有效，则使用本地缓存。</p>
<p>向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求， 将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。</p>
<p>强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</p>
<p>协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率， 将缓存信息中的Etag和Last-Modified,通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p>
<p>解决问题</p>
<ol>
<li>减少了冗余的数据传输</li>
<li>减少了服务器的负担，大大提升了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<h3 id="♥︎-♥︎-♥︎-♥︎-为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？"><a href="#♥︎-♥︎-♥︎-♥︎-为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？"></a>♥︎ ♥︎ ♥︎ ♥︎ 为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？</h3><h4 id="一、安全特性"><a href="#一、安全特性" class="headerlink" title="一、安全特性"></a>一、安全特性</h4><p>在上篇文章中，我们了解到<code>HTTP</code>在通信过程中，存在以下问题：</p>
<ul>
<li>通信使用明文（不加密），内容可能被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
</ul>
<p>而<code>HTTPS</code>的出现正是解决这些问题，<code>HTTPS</code>是建立在<code>SSL</code>之上，其安全性由<code>SSL</code>来保证</p>
<p>在采用<code>SSL</code>后，<code>HTTP</code>就拥有了<code>HTTPS</code>的加密、证书和完整性保护这些功能</p>
<blockquote>
<p>SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议</p>
</blockquote>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63623535393430302d623266662d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h4><p><code>SSL </code>的实现这些功能主要依赖于三种手段：</p>
<ul>
<li>对称加密：采用协商的密钥对数据加密</li>
<li>非对称加密：实现身份认证和密钥协商</li>
<li>摘要算法：验证信息的完整性</li>
<li>数字签名：身份验证</li>
</ul>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65336630343066302d623266662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密</p>
<p>公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64393630336536302d623266662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>在<code>HTTPS</code>通信过程中，采用的是对称加密+非对称加密，也就是混合加密</p>
<p>在对称加密中讲到，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性</p>
<p>而<code>HTTPS</code>采用非对称加密解决秘钥交换的问题</p>
<p>具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66333735663239302d623266662d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</p>
<h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文</p>
<p>上述的方法解决了数据加密，在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客解决</p>
<p>因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是摘要算法</p>
<h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数</p>
<p>可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31323739386461302d623330302d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性</p>
<p>比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改</p>
<p><a href="https://camo.githubusercontent.com/16ceb478a4cdc255009ba6912fff85ef91ddf5711b279527344a12bef47619e1/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30323337393065302d623330302d313165622d616239302d6439616538313462323430642e706e67"><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30323337393065302d623330302d313165622d616239302d6439616538313462323430642e706e67.png" alt="img"></a></p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名</p>
<p>原理其实很简单，就是用私钥加密，公钥解密</p>
<p>签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32316161363838302d623330302d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥</p>
<p>这时候就需要一个第三方，就是证书验证机构</p>
<h4 id="CA验证机构"><a href="#CA验证机构" class="headerlink" title="CA验证机构"></a>CA验证机构</h4><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场</p>
<p>CA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”</p>
<p>流程如下图：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33393536343861302d623330302d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<ul>
<li><p>服务器的运营人员向数字证书认证机构提出公开密钥的申请</p>
</li>
<li><p>数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名</p>
</li>
<li><p>然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起</p>
</li>
<li><p>服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明：认证服务器的公开密钥的是真实有效的数字证书认证机构</p>
</li>
<li><p>服务器的公开密钥是值得信赖的</p>
</li>
</ul>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，<code>HTTPS</code>与<code>HTTP</code>虽然只差一个<code>SSL</code>，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：</p>
<ul>
<li>机密性：混合算法</li>
<li>完整性：摘要算法</li>
<li>身份认证：数字签名</li>
<li>不可否定：数字签名</li>
</ul>
<p>同时引入第三方证书机构，确保公开秘钥的安全性</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-如何理解UDP-和-TCP-区别-应用场景"><a href="#♥︎-♥︎-♥︎-♥︎-如何理解UDP-和-TCP-区别-应用场景" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 如何理解UDP 和 TCP? 区别? 应用场景?"></a>♥︎ ♥︎ ♥︎ ♥︎ 如何理解UDP 和 TCP? 区别? 应用场景?</h3><h4 id="一、UDP"><a href="#一、UDP" class="headerlink" title="一、UDP"></a>一、UDP</h4><p>UDP（User Datagram Protocol），用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层</p>
<p>也就是说无论应用层交给<code>UDP</code>多长的报文，它统统发送，一次发送一个报文</p>
<p>而对接收方，接到后直接去除首部，交给上面的应用层就完成任务</p>
<p><code>UDP</code>报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39323865356432302d623339332d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>特点如下：</p>
<ul>
<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务</li>
<li>传输途中出现丢包，UDP 也不负责重发</li>
<li>当包的到达顺序出现乱序时，UDP没有纠正的功能。</li>
<li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为</li>
</ul>
<h4 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h4><p>TCP（Transmission Control Protocol），传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送</p>
<p>可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小</p>
<p><code>TCP</code>报文首部有20个字节，额外开销大</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61303031306434302d623339332d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>特点如下：</p>
<ul>
<li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li>
<li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li>
<li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）</li>
</ul>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p><code>UDP</code>与<code>TCP</code>两者的都位于传输层，如下图所示：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61393262646138302d623339332d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>两者区别如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>可靠性</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>连接性</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>报文</td>
<td>面向字节流</td>
<td>面向报文</td>
</tr>
<tr>
<td>效率</td>
<td>传输效率低</td>
<td>传输效率高</td>
</tr>
<tr>
<td>双共性</td>
<td>全双工</td>
<td>一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td>流量控制</td>
<td>滑动窗口</td>
<td>无</td>
</tr>
<tr>
<td>拥塞控制</td>
<td>慢开始、拥塞避免、快重传、快恢复</td>
<td>无</td>
</tr>
<tr>
<td>传输效率</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
<ul>
<li>TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取</li>
<li>TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方</li>
<li>TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</li>
<li>TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</li>
</ul>
<p>两者应用场景如下图：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62366364643830302d623339332d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>可以看到，TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-如何理解OSI七层模型"><a href="#♥︎-♥︎-♥︎-♥︎-如何理解OSI七层模型" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 如何理解OSI七层模型?"></a>♥︎ ♥︎ ♥︎ ♥︎ 如何理解OSI七层模型?</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架</p>
<p><code>OSI </code>将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰</p>
<h4 id="二、划分"><a href="#二、划分" class="headerlink" title="二、划分"></a>二、划分</h4><p><code>OSI</code>主要划分了七层，如下图所示：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65623162323137302d623631652d313165622d616239302d6439616538313462323430642e706e67.png" alt="68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65623162323137302d623631652d313165622d616239302d6439616538313462323430642e706e67"></p>
<h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用</p>
<p>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 <code>DNS</code>，支持万维网应用的 <code>HTTP</code> 协议，电子邮件系统采用的 <code>SMTP </code>协议等</p>
<p>在应用层交互的数据单元我们称之为报文</p>
<h5 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h5><p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 <code>OSI </code>参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务</p>
<p>该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异</p>
<h5 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h5><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话</p>
<p>该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法</p>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题</p>
<p>传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层</p>
<p>其中，主要的传输层协议是<code>TCP</code>和<code>UDP</code></p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网</p>
<p>网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送</p>
<p>在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层</p>
<p>在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层</p>
<h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 <code>IP </code>数据报组装成帧，在两个相邻节点间的链路上传送帧</p>
<p>每一帧的数据可以分成：报头<code>head</code>和数据<code>data</code>两部分:</p>
<ul>
<li>head 标明数据发送者、接受者、数据类型，如 MAC地址</li>
<li>data 存储了计算机之间交互的数据</li>
</ul>
<p>通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源</p>
<h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>作为<code> OSI</code> 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送</p>
<p>该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）</p>
<p>该层主要是和硬件有关，与软件关系不大</p>
<h4 id="三、传输过程"><a href="#三、传输过程" class="headerlink" title="三、传输过程"></a>三、传输过程</h4><p>数据在各层之间的传输如下图所示：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66336138396434302d623631652d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<ul>
<li>应用层报文被传送到运输层</li>
<li>在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用</li>
<li>应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变</li>
<li>运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报</li>
<li>网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧</li>
<li>在物理层数据帧被封装成比特流，之后通过传输介质传送到对端</li>
<li>对端再一步步解开封装，获取到传送的数据</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-如何理解TCP-x2F-IP协议"><a href="#♥︎-♥︎-♥︎-♥︎-如何理解TCP-x2F-IP协议" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 如何理解TCP&#x2F;IP协议?"></a>♥︎ ♥︎ ♥︎ ♥︎ 如何理解TCP&#x2F;IP协议?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>TCP&#x2F;IP，传输控制协议**&#x2F;**网际协议，是指能够在多个不同网络间实现信息传输的协议簇</p>
<ul>
<li>TCP（传输控制协议）</li>
</ul>
<p>一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<ul>
<li>IP（网际协议）</li>
</ul>
<p>用于封包交换数据网络的协议</p>
<p>TCP&#x2F;IP协议不仅仅指的是<code>TCP </code>和<code>IP</code>两个协议，而是指一个由<code>FTP</code>、<code>SMTP</code>、<code>TCP</code>、<code>UDP</code>、<code>IP</code>等协议构成的协议簇，</p>
<p>只是因为在<code>TCP/IP</code>协议中<code>TCP</code>协议和<code>IP</code>协议最具代表性，所以通称为TCP&#x2F;IP协议族（英语：TCP&#x2F;IP Protocol Suite，或TCP&#x2F;IP Protocols）</p>
<h4 id="二、划分-1"><a href="#二、划分-1" class="headerlink" title="二、划分"></a>二、划分</h4><p>TCP&#x2F;IP协议族按层次分别了五层体系或者四层体系</p>
<p>五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层</p>
<p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层</p>
<p>如下图所示：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35626239333631302d623634372d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="五层体系"><a href="#五层体系" class="headerlink" title="五层体系"></a>五层体系</h4><h5 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h5><p><code>TCP/IP</code> 模型将 <code>OSI </code>参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务</p>
<p>如：<code>FTP</code>、<code>Telnet</code>、<code>DNS</code>、<code>SMTP</code> 等</p>
<h5 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h5><p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能</p>
<p>传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）</p>
<p>其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输</p>
<h5 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h5><p>负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机</p>
<p>在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送</p>
<h5 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧</p>
<h5 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h5><p>保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境</p>
<h4 id="四层体系"><a href="#四层体系" class="headerlink" title="四层体系"></a>四层体系</h4><p>TCP&#x2F;IP 的四层结构则如下表所示：</p>
<table>
<thead>
<tr>
<th>层次名称</th>
<th>单位</th>
<th>功 能</th>
<th>协 议</th>
</tr>
</thead>
<tbody><tr>
<td>网络接口层</td>
<td>帧</td>
<td>负责实际数据的传输，对应OSI参考模型的下两层</td>
<td>HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）</td>
</tr>
<tr>
<td>网络层</td>
<td>数据报</td>
<td>负责网络间的寻址数据传输，对应OSI参考模型的第三层</td>
<td>IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）</td>
</tr>
<tr>
<td>传输层</td>
<td>报文段</td>
<td>负责提供可靠的传输服务，对应OSI参考模型的第四层</td>
<td>TCP（控制传输协议） UDP（用户数据报协议）</td>
</tr>
<tr>
<td>应用层</td>
<td></td>
<td>负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层</td>
<td>FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）</td>
</tr>
</tbody></table>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>OSI 参考模型与 TCP&#x2F;IP 参考模型区别如下：</p>
<p>相同点：</p>
<ul>
<li>OSI 参考模型与 TCP&#x2F;IP 参考模型都采用了层次结构</li>
<li>都能够提供面向连接和无连接两种通信服务机制</li>
</ul>
<p>不同点：</p>
<ul>
<li>OSI 采用的七层模型； TCP&#x2F;IP 是四层或五层结构</li>
<li>TCP&#x2F;IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分</li>
<li>OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP&#x2F;IP 参考模型作为一种简化的分层结构是可以的</li>
<li>TCP&#x2F;IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 <code>OSI</code> 设想中的应用程序维度的分层是无法实现的</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-说一下-GET-和-POST-的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-说一下-GET-和-POST-的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说一下 GET 和 POST 的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ 说一下 GET 和 POST 的区别？</h3><p><code>GET</code>和<code>POST</code>，两者是<code>HTTP</code>协议中发送请求的方法</p>
<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p><code>GET</code>方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据</p>
<h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p><code>POST</code>方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用</p>
<p>本质上都是<code>TCP</code>链接，并无差别</p>
<p>但是由于<code>HTTP</code>的规定和浏览器&#x2F;服务器的限制，导致他们在应用过程中会体现出一些区别</p>
<h4 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h4><p>从<code>w3schools</code>得到的标准答案的区别如下：</p>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中</li>
</ul>
<h4 id="参数位置"><a href="#参数位置" class="headerlink" title="参数位置"></a>参数位置</h4><p>貌似从上面看到<code>GET</code>与<code>POST</code>请求区别非常大，但两者实质并没有区别</p>
<p>无论 <code>GET </code>还是 <code>POST</code>，用的都是同一个传输层协议，所以在传输上没有区别</p>
<p>当不携带参数的时候，两者最大的区别为第一行方法名不同</p>
<blockquote>
<p>POST &#x2F;uri HTTP&#x2F;1.1 \r\n</p>
<p>GET &#x2F;uri HTTP&#x2F;1.1 \r\n</p>
</blockquote>
<p>当携带参数的时候，我们都知道<code>GET</code>请求是放在<code>url</code>中，<code>POST</code>则放在<code>body</code>中</p>
<p><code>GET</code> 方法简约版报文是这样的</p>
<pre><code class="http">GET /index.html?name=qiming.c&amp;age=22 HTTP/1.1
Host: localhost
</code></pre>
<p><code>POST </code>方法简约版报文是这样的</p>
<pre><code class="http">POST /index.html HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded

name=qiming.c&amp;age=22
</code></pre>
<p>注意：这里只是约定，并不属于<code>HTTP</code>规范，相反的，我们可以在<code>POST</code>请求中<code>url</code>中写入参数，或者<code>GET</code>请求中的<code>body</code>携带参数</p>
<h4 id="参数长度"><a href="#参数长度" class="headerlink" title="参数长度"></a>参数长度</h4><p><code>HTTP </code>协议没有<code>Body</code>和 <code>URL</code> 的长度限制，对 <code>URL </code>限制的大多是浏览器和服务器的原因</p>
<p><code>IE</code>对<code>URL</code>长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持</p>
<p>这里限制的是整个<code>URL</code>长度，而不仅仅是参数值的长度</p>
<p>服务器处理长<code> URL</code> 要消耗比较多的资源，为了性能和安全考虑，会给 <code>URL</code> 长度加限制</p>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p><code>POST </code>比<code> GET</code> 安全，因为数据在地址栏上不可见</p>
<p>然而，从传输的角度来说，他们都是不安全的，因为<code> HTTP</code> 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文</p>
<p>只有使用<code>HTTPS</code>才能加密安全</p>
<h4 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h4><p>对于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应200（返回数据）</p>
<p>对于<code>POST</code>，浏览器先发送<code>header</code>，服务器响应100 <code>continue</code>，浏览器再发送<code>data</code>，服务器响应200 ok</p>
<p>并不是所有浏览器都会在<code>POST</code>中发送两次包，<code>Firefox</code>就只发送一次</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-对WebSocket的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-对WebSocket的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 对WebSocket的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ 对WebSocket的理解？应用场景？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>WebSocket，是一种网络传输协议，位于<code>OSI</code>模型的应用层。可在单个<code>TCP</code>连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅</p>
<p>客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61643338366532302d633066312d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>从上图可见，<code>websocket</code>服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接受数据</p>
<p>而在<code>websocket</code>出现之前，开发实时<code>web</code>应用的方式为轮询</p>
<p>不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果</p>
<p>轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 <code>CPU </code>资源</p>
<h4 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h4><h5 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h5><p>通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合</p>
<p>例如指 A→B 的同时 B→A ，是瞬时同步的</p>
<h5 id="二进制帧"><a href="#二进制帧" class="headerlink" title="二进制帧"></a>二进制帧</h5><p>采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比<code>http/2</code>，<code>WebSocket </code>更侧重于“实时通信”，而<code>HTTP/2</code> 更侧重于提高传输效率，所以两者的帧结构也有很大的区别</p>
<p>不像 <code>HTTP/2</code> 那样定义流，也就不存在多路复用、优先级等特性</p>
<p>自身就是全双工，也不需要服务器推送</p>
<h5 id="协议名"><a href="#协议名" class="headerlink" title="协议名"></a>协议名</h5><p>引入<code>ws</code>和<code>wss</code>分别代表明文和密文的<code>websocket</code>协议，且默认端口使用80或443，几乎与<code>http</code>一致</p>
<pre><code class="http">ws://www.chrono.com
ws://www.chrono.com:8080/srv
wss://www.chrono.com:445/im?user_id=xxx
</code></pre>
<h5 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h5><p><code>WebSocket </code>也要有一个握手过程，然后才能正式收发数据</p>
<p>客户端发送数据格式如下：</p>
<pre><code class="http">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</code></pre>
<ul>
<li>Connection：必须设置Upgrade，表示客户端希望连接升级</li>
<li>Upgrade：必须设置Websocket，表示希望升级到Websocket协议</li>
<li>Sec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept应答，否则客户端会抛出错误，并关闭连接</li>
<li>Sec-WebSocket-Version ：表示支持的Websocket版本</li>
</ul>
<p>服务端返回的数据格式：</p>
<pre><code class="http">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat
</code></pre>
<ul>
<li>HTTP&#x2F;1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接</li>
<li>Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部</li>
<li>更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li>
<li>保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证</li>
<li>更好的二进制支持：定义了二进制帧，更好处理二进制内容</li>
<li>支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议</li>
<li>更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li>
</ul>
<h4 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h4><p>基于<code>websocket</code>的事实通信的特点，其存在的应用场景大概有：</p>
<ul>
<li>弹幕</li>
<li>媒体聊天</li>
<li>协同编辑</li>
<li>基于位置的应用</li>
<li>体育实况更新</li>
<li>股票基金报价实时更新</li>
</ul>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试手撕代码合集</title>
    <url>/2023/01/05/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="面试手撕代码合集"><a href="#面试手撕代码合集" class="headerlink" title="面试手撕代码合集"></a>面试手撕代码合集</h1><h2 id="1-柯里化函数"><a href="#1-柯里化函数" class="headerlink" title="1.柯里化函数"></a>1.柯里化函数</h2><pre><code class="javascript">function add() &#123;
    const _args = [...arguments];
    function fn() &#123;
      _args.push(...arguments);
      return fn; //一直重复收集参数
    &#125;
    fn.toString = function() &#123;
      return _args.reduce((sum, cur) =&gt; sum + cur);
    &#125;
    return fn;
  &#125;
console.log(add(1)(2)(3)(4).toString()) //10
console.log(add(1,2)(1, 2, 3)(2).toString()) //11
</code></pre>
<h2 id="2-千位符转换"><a href="#2-千位符转换" class="headerlink" title="2.千位符转换"></a>2.千位符转换</h2><pre><code class="javascript">// 将金额类型转为数字类型
function toNum(str) &#123;
    return str.replace(/\,|\￥/g, &quot;&quot;);
&#125;

// 保留两位小数（四舍五入）
function toPrice(num) &#123;
    num = parseFloat(toNum(num)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);
&#125;

// 保留两位小数（不四舍五入）
function toPrice1(num) &#123;
    num = parseFloat(toNum(num).replace(/(\.\d&#123;2&#125;)\d+$/,&quot;$1&quot;)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);;
&#125;

// 不处理小数部分
function toPrice2(num) &#123;
    var source = toNum(num).split(&quot;.&quot;);
    source[0] = source[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + source.join(&quot;.&quot;)
&#125;

console.log(toPrice(&#39;12312.236&#39;)) //￥12,312.24
console.log(toPrice1(&#39;12312.234&#39;)) //￥12,312.23
console.log(toPrice2(&#39;1232342312.234&#39;)) //￥1,232,342,312.234
</code></pre>
<h2 id="3-用setTimeout实现setInterval-计数器"><a href="#3-用setTimeout实现setInterval-计数器" class="headerlink" title="3.用setTimeout实现setInterval(计数器)"></a>3.用setTimeout实现setInterval(计数器)</h2><pre><code class="javascript">var i = 10;
let fn = () =&gt; &#123;
    console.log(i--);
&#125;
function mySetInterval(fn, delay, times) &#123;
    let timer = setTimeout(function a() &#123;
        fn()
        times--
        timer = setTimeout(a, delay)
        if (times &lt;= 0) &#123;
            clearTimeout(timer)
        &#125;
    &#125;, delay)
&#125;
mySetInterval(fn, 1000, 10)
</code></pre>
<h2 id="4-数组扁平化"><a href="#4-数组扁平化" class="headerlink" title="4.数组扁平化"></a>4.数组扁平化</h2><pre><code class="javascript">//递归实现
var arr = [1,2,[3,4,[5,6]]]
function flatten(arr)&#123;
    let result = []
    arr.forEach(item =&gt; &#123;
        if(Array.isArray(item))&#123;
            result = result.concat(flatten(item))
        &#125;else&#123;
            result.push(item)
        &#125;
    &#125;);
    return result
&#125;
console.log(flatten(arr)) //[ 1, 2, 3, 4, 5, 6 ]

//利用reduce函数迭代
var arr1 = [1,2,[3,4,[5,6]]]
function flatten1(arr)&#123;
    return arr.reduce((res,next) =&gt; &#123;
        return res.concat(Array.isArray(next) ? flatten1(next) : next)
    &#125;,[])
&#125;
console.log(flatten1(arr1)) //[ 1, 2, 3, 4, 5, 6 ]
</code></pre>
<h2 id="5-深拷贝"><a href="#5-深拷贝" class="headerlink" title="5.深拷贝"></a>5.深拷贝</h2><pre><code class="javascript">function deepClone(obj,hash = new WeakMap())&#123;
    if(obj == null) return obj;
    if(obj instanceof Date) return new Date(obj);
    if(obj instanceof RegExp) return new RegExp(obj);
    if(typeof obj !== &#39;object&#39;) return obj;
    if(hash.get(obj)) return hash.get(obj);
    let cloneObj = new obj.constructor;
    hash.set(obj,cloneObj);
    for(let key in obj)&#123;
        if(obj.hasOwnProperty(key))&#123;
            cloneObj[key] = deepClone(obj[key],hash);
        &#125;
    &#125;
    return cloneObj;
&#125;

let obj = &#123;name:1,address:&#123;x:1000&#125;&#125;;
let d = deepClone(obj);
obj.address.x = 200;
console.log(d); //&#123;name:1,address:&#123;x:1000&#125;&#125;
</code></pre>
<h2 id="6-Promise-all"><a href="#6-Promise-all" class="headerlink" title="6.Promise.all"></a>6.Promise.all</h2><pre><code class="javascript">Promise.prototype.all = function(promises)&#123;
    let results = [];
    let promiseCount = 0;
    let promisesLength = promises.length;
    return new Promise(function(resolve,reject)&#123;
        for(let val of promises)&#123;
            Promise.resolve(val).then(function(res)&#123;
                promiseCount++;
                //results.push(res)
                results[i] = res;
                //当所有函数都正确执行了，resolve输出所有返回结果
                if(promiseCount === promisesLength)&#123;
                    return resolve(results);
                &#125;
            &#125;,function(err)&#123;
                return reject(err);
            &#125;)
        &#125;
    &#125;)
&#125;

//测试
let promise1 = new Promise(function(resolve) &#123;
    resolve(1);
  &#125;);
  let promise2 = new Promise(function(resolve) &#123;
    resolve(2);
  &#125;);
  let promise3 = new Promise(function(resolve) &#123;
    resolve(3);
  &#125;);
  
  let promiseAll = Promise.all([promise1, promise2, promise3]);
  promiseAll.then(function(res) &#123;
    console.log(res);
  &#125;);//[1,2,3]
</code></pre>
<h2 id="7-Promise-race"><a href="#7-Promise-race" class="headerlink" title="7.Promise.race"></a>7.Promise.race</h2><pre><code class="javascript">Promise.race = function(promises)&#123;
    //将可迭代对象转换为数组
    promises = Array.from(promises);
    return new Promise((resolve,reject)=&gt;&#123;
        if(promises.length === 0)&#123;
            //空的可迭代对象，用于pending状态
        &#125;else&#123;
            for(let i = 0;i &lt; promises.length;i++)&#123;
                Promise.resolve(promises[i]).then((data)=&gt;&#123;
                    resolve(data);
                &#125;).catch((reason)=&gt;&#123;
                    reject(reason)
                &#125;)
            &#125;
        &#125;
    &#125;)
&#125;

//测试
let p1 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;success&#39;)
    &#125;,1000)
&#125;)
let p2 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;faild&#39;)
    &#125;,500)
&#125;)

Promise.race([p1,p2]).then(result=&gt;&#123;
console.log(result)  //  faild    faild耗时短
&#125;)
</code></pre>
<h2 id="8-instanceof"><a href="#8-instanceof" class="headerlink" title="8.instanceof"></a>8.instanceof</h2><pre><code class="javascript">function new_instance_of(leftValue,rightValue)&#123;
    let rightProto = rightValue.prototype;//取右边表达式的 prototype 值
    leftValue = leftValue.__proto__;//取左表达式的 __proto__ 值
    while(true)&#123;
        if(leftValue == null)&#123;
            return false;
        &#125;
        if(leftValue === rightProto)&#123;
            return true;
        &#125;
        leftValue = leftValue.__proto__;
    &#125;
&#125;
function Foo()&#123;&#125;
console.log(new_instance_of(Foo,Object))//true
</code></pre>
<h2 id="9-js继承"><a href="#9-js继承" class="headerlink" title="9.js继承"></a>9.js继承</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h3><pre><code class="javascript"> // 原型链继承
  function Super()&#123;
    this.color=[&#39;red&#39;,&#39;yellow&#39;,&#39;black&#39;]
  &#125;

  function Sub()&#123;
  &#125;
  //继承了color属性 Sub.prototype.color=[&#39;red&#39;,&#39;yellow&#39;,&#39;black&#39;]
  Sub.prototype=new Super()

  //创建实例 instance1.__proto__.color
  const instance1=new Sub()
  const instance2=new Sub()
  console.log(instance1.__proto__.color===instance2.__proto__.color) //true
</code></pre>
<h3 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2.构造函数继承"></a>2.构造函数继承</h3><pre><code class="javascript">function Super(name,age)&#123;
    this.name = name;
    this.age = age;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;];
    this.sayHi = function()&#123;
        console.log(&#39;hi&#39;)
    &#125;
    console.log(this)
&#125;
function Sub()&#123;
    //改变this指向
    Super.apply(this,arguments)
    this.height = 180;
&#125;

var instance1 = new Sub(&#39;mengfeng&#39;,25);
var instance2 = new Sub(&#39;mengfeng123&#39;,24);
instance1.sayHi();//hi
</code></pre>
<h3 id="3-实例继承"><a href="#3-实例继承" class="headerlink" title="3.实例继承"></a>3.实例继承</h3><pre><code class="javascript">new
</code></pre>
<h3 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4.拷贝继承"></a>4.拷贝继承</h3><pre><code class="javascript">//深拷贝
</code></pre>
<h3 id="5-组合继承"><a href="#5-组合继承" class="headerlink" title="5.组合继承"></a>5.组合继承</h3><pre><code class="javascript">function Super(name,age)&#123;
    this.name = name;
    this.age = age;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;]
&#125;

Super.prototype.sayHi = function()&#123;
    console.log(&#39;hi&#39;)
&#125;

function Sub(name,age,height)&#123;
    Super.apply(this,arguments)
    this.height = height;
&#125;

Sub.prototype = new Super(&#39;w&#39;,22);
Sub.prototype.constructor = Sub;
console.log(Sub.prototype)
Sub.prototype.sayHello = function()&#123;
    console.log(&#39;hello&#39;)
&#125;

var instance1 = new Sub(&#39;mengfeng&#39;,23,180);
var instance2 = new Sub(&#39;mengfeng123&#39;,24,181);
console.log(instance1)
</code></pre>
<h3 id="6-寄生组合继承"><a href="#6-寄生组合继承" class="headerlink" title="6.寄生组合继承"></a>6.寄生组合继承</h3><pre><code class="javascript">function inheritPrototype(Sub,Super)&#123;
    var subPrototype=Object.create(Super.prototype)
    subPrototype.constructor=Sub
    Sub.prototype=subPrototype
    
  &#125;
  function Super(name)&#123;
    this.name=name
  &#125;
  Super.prototype.sayHi=function()&#123;
    console.log(this.name)//ccdida
  &#125;
  function Sub(name)&#123;
    Super.call(this,name)
  &#125;
  inheritPrototype(Sub,Super)

  Sub.prototype.sayHello=function()&#123;
    console.log(&#39;sayHello&#39;)
  &#125;

  var instance1=new Sub(&#39;ccdida&#39;)
  console.log(instance1.__proto__)
  console.log(instance1.__proto__.__proto__)
</code></pre>
<h2 id="10-对象扁平化"><a href="#10-对象扁平化" class="headerlink" title="10.对象扁平化"></a>10.对象扁平化</h2><pre><code class="javascript">//对象扁平化
function flat(obj, key = &quot;&quot;, res = &#123;&#125;, isArray = false) &#123; 
    for (let [k, v] of Object.entries(obj)) &#123; 
      if (Array.isArray(v)) &#123; 
        let tmp = isArray ? key + &quot;[&quot; + k + &quot;]&quot; : key + k 
        flat(v, tmp, res, true) 
      &#125; else if (typeof v === &quot;object&quot;) &#123; 
        let tmp = isArray ? key + &quot;[&quot; + k + &quot;].&quot; : key + k + &quot;.&quot; 
        flat(v, tmp, res) 
      &#125; else &#123; 
        let tmp = isArray ? key + &quot;[&quot; + k + &quot;]&quot; : key + k 
        res[tmp] = v 
      &#125; 
    &#125; 
    return res 
  &#125;
  
  var entryObj = &#123;
    a: &#123;
        b: &#123;
            c: &#123;
                dd: &#39;abcdd&#39;
            &#125;
        &#125;,
        d: &#123;
            xx: &#39;adxx&#39;
        &#125;,
        e: &#39;ae&#39;
    &#125;
&#125;

console.log(flat(entryObj))
</code></pre>
<h2 id="11-发布订阅"><a href="#11-发布订阅" class="headerlink" title="11.发布订阅"></a>11.发布订阅</h2><pre><code class="javascript">class EventEmitter&#123;
    constructor()&#123;
        this._events = &#123;&#125;;
    &#125;

    on(eventName, callback)&#123;
        if(this._events[eventName])&#123;
            if(this.eventName !== &quot;newListener&quot;)&#123;
                this.emit(&quot;newListener&quot;, eventName)
            &#125;
        &#125;
        const callbacks = this._events[eventName] || [];
        callbacks.push(callback);
        this._events[eventName] = callbacks
    &#125;

    emit(eventName, ...args)&#123;
        const callbacks = this._events[eventName] || [];
        callbacks.forEach(cb =&gt; cb(...args))
    &#125;

    once(eventName, callback)&#123;
        const one = (...args)=&gt;&#123;
            callback(...args)
            this.off(eventName, one)
        &#125;
        one.initialCallback = callback;
        this.on(eventName, one)
    &#125;

     off(eventName, callback)&#123;
        const callbacks = this._events[eventName] || []
        const newCallbacks = callbacks.filter(fn =&gt; fn != callback &amp;&amp; fn.initialCallback != callback /* 用于once的取消订阅 */)
        this._events[eventName] = newCallbacks;
    &#125;
&#125;



const events = new EventEmitter()

events.on(&quot;newListener&quot;, function(eventName)&#123;
    console.log(`eventName`, eventName)
&#125;)

events.on(&quot;hello&quot;, function()&#123;
    console.log(&quot;hello&quot;);
&#125;)

let cb = function()&#123;
    console.log(&#39;cb&#39;);
&#125;
events.on(&quot;hello&quot;, cb)

events.off(&quot;hello&quot;, cb)

function once()&#123;
    console.log(&quot;once&quot;);
&#125;
events.once(&quot;hello&quot;, once)

events.off(&quot;hello&quot;, once)
events.emit(&quot;hello&quot;)
events.emit(&quot;hello&quot;)
</code></pre>
<h2 id="12-反柯里化函数"><a href="#12-反柯里化函数" class="headerlink" title="12.反柯里化函数"></a>12.反柯里化函数</h2><pre><code class="javascript">Function.prototype.uncurrying = function() &#123;
    var self = this;   //self为Array.prototype.push
    return function() &#123;
        //obj = &#123;0:1, length: 1&#125;, arguments = [2, callee: ƒ, Symbol(Symbol.iterator): ƒ]
        var obj = Array.prototype.shift.call(arguments); 
        
        //Array.ptototype.push(obj, 2)
        return self.apply(obj, arguments);
    &#125;
&#125;
var testObj = &#123;
    length: 1,
    0: 1
&#125;
var push = Array.prototype.push.uncurrying();
push(testObj, 2);
console.log(testObj);   //&#123;0: 1, 1: 2, length: 2&#125;
</code></pre>
<h2 id="13-防抖"><a href="#13-防抖" class="headerlink" title="13.防抖"></a>13.防抖</h2><pre><code class="javascript">//scroll方法中的do somthing至少间隔500毫秒执行一次
window.addEventListener(&#39;scroll&#39;,function()&#123;
    var timer;//使用闭包，缓存变量
    return function()&#123;
    if(timer) clearTimeout(timer);
    timer = setTimeout(function()&#123;
    console.log(&#39;do somthing&#39;)
&#125;,500)
&#125;
&#125;());//此处()作用 - 立即调用return后面函数，形成闭包
</code></pre>
<h2 id="14-监测数组变化"><a href="#14-监测数组变化" class="headerlink" title="14.监测数组变化"></a>14.监测数组变化</h2><pre><code class="javascript">// 获取Array的原型，并创建一个新的对象指向这个原型
const arrayMethods = Object.create(Array.prototype)
// 创建一个新的原型，这就是改造之后的数组原型
const ArrayProto = []
// 重新构建Array原型里面的虽有方法
Object.getOwnPropertyNames(Array.prototype).forEach(method =&gt; &#123;
    if(typeof arrayMethods[method] === &quot;function&quot;)&#123;
        ArrayProto[method] = function()&#123;
            console.log(&quot;我已经监听到数组触发了&quot;+method+&quot;事件&quot;)
            return arrayMethods[method].apply(this, arguments)
        &#125;
    &#125;else&#123;
        ArrayProto[method] = arrayMethods[method]
    &#125;
&#125;)


let list = [1, 2, 3]
// 将数组的原型链指向新构造的原型
list.__proto__ = ArrayProto
// 执行push事件
list.push(2)
// 输出：
我已经监听到数组触发了push事件 // 这个说明监听成功了
</code></pre>
<h2 id="15-节流"><a href="#15-节流" class="headerlink" title="15.节流"></a>15.节流</h2><pre><code class="javascript">//scroll方法中当间隔时间大于2s，do somthing执行一次
window.addEventListener(&#39;scroll&#39;,function()&#123;
    var timer ;//使用闭包，缓存变量
    var startTime = new Date();
    return function()&#123;
    var curTime = new Date();
    if(curTime - startTime &gt;= 2000)&#123;
    timer = setTimeout(function()&#123;
    console.log(&#39;do somthing&#39;)
    &#125;,500);
    startTime = curTime;
    &#125;
      &#125; &#125;());//此处()作用 - 立即调用return后面函数，形成闭包
</code></pre>
<h2 id="16-拦截全局Promise-reject"><a href="#16-拦截全局Promise-reject" class="headerlink" title="16.拦截全局Promise-reject"></a>16.拦截全局Promise-reject</h2><pre><code class="javascript">// 使用Try catch 只能拦截try语句块里面的
try &#123;
    new Promise((resolve, reject) =&gt; &#123;
      reject(&quot;WTF 123&quot;);
    &#125;);
  &#125; catch (e) &#123;
    console.log(&quot;e&quot;, e);
    throw e;
  &#125;
  
  // 使用 unhandledrejection 来拦截全局错误  （这个是对的）
  window.addEventListener(&quot;unhandledrejection&quot;, (event) =&gt; &#123;
    event &amp;&amp; event.preventDefault();
    console.log(&quot;event&quot;, event);
  &#125;);
</code></pre>
<h2 id="17-千位符"><a href="#17-千位符" class="headerlink" title="17.千位符"></a>17.千位符</h2><pre><code class="javascript">// 将金额类型转为数字类型
function toNum(str) &#123;
    return str.replace(/\,|\￥/g, &quot;&quot;);
&#125;

// 保留两位小数（四舍五入）
function toPrice(num) &#123;
    num = parseFloat(toNum(num)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);
&#125;

// 保留两位小数（不四舍五入）
function toPrice1(num) &#123;
    num = parseFloat(toNum(num).replace(/(\.\d&#123;2&#125;)\d+$/,&quot;$1&quot;)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);;
&#125;

// 不处理小数部分
function toPrice2(num) &#123;
    var source = toNum(num).split(&quot;.&quot;);
    source[0] = source[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + source.join(&quot;.&quot;)
&#125;

console.log(toPrice(&#39;12312.236&#39;)) //￥12,312.24
console.log(toPrice1(&#39;12312.234&#39;)) //￥12,312.23
console.log(toPrice2(&#39;1232342312.234&#39;)) //￥1,232,342,312.234
</code></pre>
<h2 id="18-浅拷贝"><a href="#18-浅拷贝" class="headerlink" title="18.浅拷贝"></a>18.浅拷贝</h2><pre><code class="javascript">let Sclone =(obj)=&gt;&#123;        
    // 方法一        
    // let obj1 = &#123;&#125;        
    // obj1 = Object.assign(&#123;&#125;,obj)        
    // 方法二 
    let obj1 =&#123;...obj&#125;       
    return obj1    
&#125;
</code></pre>
<h2 id="19-数组去重"><a href="#19-数组去重" class="headerlink" title="19.数组去重"></a>19.数组去重</h2><pre><code class="javascript">let arr =  [1,2,2,4,null,null,&#39;3&#39;,&#39;abc&#39;,3,5,4,1,2,2,4,null,null,&#39;3&#39;,&#39;abc&#39;,3,5,4] 

//利用key的唯一
let obj = &#123;&#125;;
for (let i = 0; i &lt; arr.length; i++) &#123;
  let item = arr[i]
  if (obj[item] !== undefined) &#123;
    arr.splice(i, 1);
    i--; // 解决删除元素后，数组塌陷问题
    continue;
  &#125;
  obj[item] = item
&#125;

console.log(arr)
// arr: [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]


// 交换元素位置从而替换调 splice方法
let obj1 = &#123;&#125;;
for (let i = 0; i &lt; arr.length; i++) &#123;
  let item = arr[i]
  if (obj1[item] !== undefined) &#123;
    arr[i] = arr[arr.length-1]
    arr.length--;
    i--; 
    continue;
  &#125;
  obj1[item] = item
&#125;
// arr: [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]


// Array.filter + Array.indexO
let newArr = arr.filter((item, index) =&gt; arr.indexOf(item) === index);  
// [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5


// Array.filter + Object.hasOwnProperty
let obj2 = &#123;&#125;
arr.filter(item =&gt; obj2.hasOwnProperty(typeof item + item) ? false : (obj2[typeof item + item] = true))


// Array.reduce + Array.includes
let newArr1 = arr.reduce((accu, cur) =&gt; &#123;
    return accu.includes(cur) ? accu : accu.concat(cur);  // 1. 拼接方法
    // return accu.includes(cur) ? accu : [...accu, cur]; // 2. 扩展运算
&#125;, [])


// Array.indexOf
let newArr2 = []
for (var i = 0; i &lt; arr.length; i++) &#123;
    if (newArr2.indexOf(arr[i]) === -1) newArr2.push(arr[i])  
&#125;
//等同于 forEach 写法
arr.forEach( item =&gt; newArr2.indexOf(item) === -1 ? newArr2.push(item) : &#39;&#39;)

//Array.includes
let newArr3 = []
for (var i = 0; i &lt; arr.length; i++) &#123;
    if (!newArr3.includes(arr[i]))  newArr3.push(arr[i])
&#125;
//等同于 forEach 写法
arr.forEach( item =&gt; !newArr3.includes(item) ? newArr3.push(item) : &#39;&#39;)


// new Set + 扩展运算符 || Array.from
let newArr5 = [...new Set(arr)];      // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]
let newArr4 = Array.from(new Set(arr));      // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]
let newStr = [...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)  //  &#39;abc&#39;


// new Map
let map = new Map();
let newStr6 = [];

for (let i = 0; i &lt; arr.length; i++) &#123;
    if (!map.has(arr[i])) &#123;
        map.set(arr[i], true);
        newStr6.push(arr[i]);
    &#125;
&#125;
console.log(newArr6)  // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]
</code></pre>
<h2 id="20-数组转为tree"><a href="#20-数组转为tree" class="headerlink" title="20.数组转为tree"></a>20.数组转为tree</h2><pre><code class="javascript">let arr= [
    &#123; id: 1, name: &#39;部门A&#39;, parentId: 0 &#125;,
    &#123; id: 3, name: &#39;部门C&#39;, parentId: 1 &#125;,
    &#123; id: 4, name: &#39;部门D&#39;, parentId: 1 &#125;,
    &#123; id: 5, name: &#39;部门E&#39;, parentId: 2 &#125;,
    &#123; id: 6, name: &#39;部门F&#39;, parentId: 3 &#125;,
    &#123; id: 7, name: &#39;部门G&#39;, parentId: 2 &#125;,
    &#123; id: 8, name: &#39;部门H&#39;, parentId: 4 &#125;,
    &#123; id: 18, name: &#39;部门K&#39;, parentId: 4 &#125;,
    &#123; id: 22, name: &#39;部门zz&#39;, parentId: 21 &#125;
]


function arrToTree(arr) &#123;
  arr=JSON.parse(JSON.stringify(arr))
  const newArr = []
  // 1. 构建一个字典：能够快速根据id找到对象。
  const map = &#123;&#125;
  arr.forEach(item =&gt; &#123;
    // 为了计算方便，统一添加children
    item.children = []
    // 构建一个字典
    map[item.id] = item
  &#125;)
 
  // 2. 对于arr中的每一项
  arr.forEach(item =&gt; &#123;
    const parent = map[item.parentId]
    if (parent) &#123;
      //    如果它有父级，把当前对象添加父级元素的children中
      parent.children.push(item)
    &#125; else &#123;
      //    如果它没有父级（pid:&#39;&#39;）,直接添加到newArr
      newArr.push(item)
    &#125;
  &#125;)
  return newArr
&#125;

console.log(arrToTree(arr))
</code></pre>
<h2 id="21-ajax"><a href="#21-ajax" class="headerlink" title="21.ajax"></a>21.ajax</h2><pre><code class="javascript">function ajax(option) &#123;//type,url,obj,timeout,success,error将所有参数换成一个对象&#123;&#125;
    //  0.将对象转换成字符串
    var str = objToString(option.data);
    //  1.创建一个异步对象xmlhttp；
    var xmlhttp, timer;
    if (window.XMLHttpRequest) &#123;
        xmlhttp = new XMLHttpRequest();
    &#125; else &#123;// code for IE6, IE5 
        xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
    &#125;
    //  2.设置请求方式和请求地址； 
    // 判断请求的类型是POST还是GET
    if (option.type.toLowerCase() === &#39;get&#39;) &#123;
        xmlhttp.open(option.type, option.url + &quot;?t=&quot; + str, true);
        //  3.发送请求；
        xmlhttp.send();
    &#125; else &#123;
        xmlhttp.open(option.type, option.url, true);
        // 注意：在post请求中，必须在open和send之间添加HTTP请求头：setRequestHeader(header,value);
        xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
        //  3.发送请求；
        xmlhttp.send(str);
    &#125;
    //  4.监听状态的变化；
    xmlhttp.onreadystatechange = function () &#123;
        clearInterval(timer);
        if (xmlhttp.readyState === 4) &#123;
            if (xmlhttp.status &gt;= 200 &amp;&amp; xmlhttp.status &lt; 300 || xmlhttp.status == 304) &#123;
                //  5.处理返回的结果；
                option.success(xmlhttp);//成功后回调；
            &#125; else &#123;
                option.error(xmlhttp);//失败后回调；
            &#125;
        &#125;
    &#125;
    //处理obj 
    function objToString(data) &#123;
        data.t = new Date().getTime();
        var res = [];
        for (var key in data) &#123;
            //需要将key和value转成非中文的形式，因为url不能有中文。使用encodeURIComponent();
            res.push(encodeURIComponent(key) + &quot; = &quot; + encodeURIComponent(data[key]));
        &#125;
        return res.join(&quot;&amp;&quot;);
    &#125;
    //判断外界是否传入了超时时间
    if (option.timeout) &#123;
        timer = setInterval(function () &#123;
            xmlhttp.abort();//中断请求
            clearInterval(timer);
        &#125;, timeout);
    &#125;
&#125;
</code></pre>
<h2 id="22-apply"><a href="#22-apply" class="headerlink" title="22.apply"></a>22.apply</h2><pre><code class="javascript">Function.prototype.apply2 = function(obj,arr)&#123;
    obj = obj?Object(obj):window;
    let _fn = &quot;fn&quot;,result;
    while (obj.hasOwnProperty(_fn)) &#123;
      _fn = &quot;fn&quot; + Math.random(); // 循环判断并重新赋值
    &#125;
    obj[_fn] = this;
    if(arr)&#123;
      result = obj[_fn](...arr);
    &#125;else&#123;
      result = obj[_fn]();
    &#125;
    delete obj[_fn];
    return result;
  &#125;
</code></pre>
<h2 id="23-async和await"><a href="#23-async和await" class="headerlink" title="23.async和await"></a>23.async和await</h2><pre><code class="javascript">function asyncToGen(genFunction) &#123;
    return function (...args) &#123;
      const gen = genFunction.apply(this, args);
      return new Promise((resolve, reject) =&gt; &#123;
        function step(key, arg) &#123;
          let genResult;
          try &#123;
            genResult = gen[key](arg);
          &#125; catch (err) &#123;
            return reject(err);
          &#125;
          const &#123; value, done &#125; = genResult;
          if (done) &#123;
            return resolve(value);
          &#125;
          return Promise.resolve(value).then(
            (val) =&gt; &#123;
              step(&#39;next&#39;, val);
            &#125;,
            (err) =&gt; &#123;
              step(&#39;throw&#39;, err);
            &#125;,
          );
        &#125;
        step(&#39;next&#39;);
      &#125;);
    &#125;;
  &#125;
  const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(&#39;data&#39;), 1000));
  function* testG() &#123;
    const data = yield getData();
    console.log(&#39;data: &#39;, data);
    const data2 = yield getData();
    console.log(&#39;data2: &#39;, data2);
    return &#39;success&#39;;
  &#125;
  
  const gen = asyncToGen(testG);
  gen().then(res =&gt; console.log(res));
</code></pre>
<h2 id="24-bind"><a href="#24-bind" class="headerlink" title="24.bind"></a>24.bind</h2><pre><code class="javascript">Function.prototype.bind2 = function (obj) &#123;
    obj = obj ? Object(obj) : window
    let myArguments = arguments
    let self = this
    if (arguments.length &gt; 1) &#123;
      return function () &#123;
        self.apply(obj, [...[...myArguments].slice(1), ...arguments])
      &#125;
    &#125;
    return function () &#123;
      self.apply(obj, [...arguments])
    &#125;
  &#125;
</code></pre>
<h2 id="25-call"><a href="#25-call" class="headerlink" title="25.call"></a>25.call</h2><pre><code class="javascript">Function.prototype.call2 = function(obj)&#123;
    obj = obj?Object(obj):window;
    let _fn = &quot;fn&quot;,result;
    while (obj.hasOwnProperty(_fn)) &#123;
      _fn = &quot;fn&quot; + Math.random(); // 循环判断并重新赋值
    &#125;
    obj[_fn] = this;
    if(arguments.length&gt;1)&#123;
      result = obj[_fn](...([...arguments].slice(1)));
    &#125;else&#123;
      result = obj[_fn]();
    &#125;
    delete obj[_fn];
    return result;
  &#125;
</code></pre>
<h2 id="26-filter"><a href="#26-filter" class="headerlink" title="26.filter"></a>26.filter</h2><pre><code class="javascript">Array.prototype.myFilter = function(callback, thisArg) &#123;
    // 确认调用者必须是个数组
    if (Object.prototype.toString.call(this) !== &#39;[object Array]&#39;) &#123;
      throw new TypeError(&#39;this must be a array&#39;);
    &#125;
    if (typeof callback !== &#39;function&#39;) &#123;
      throw new TypeError(callback + &#39;is not a function&#39;);
    &#125;
    // 返回结果的数组
    const res = [];
    // 让O成为回调函数的对象传递（强制转换对象）
    const O = Object(this);
    console.log(O)
    // &gt;&gt;&gt;0 保证len为number，且为正整数
    // 无符号位移计算符
    const len = O.length &gt;&gt;&gt; 0;
    // 对整个数组进行遍历
    for (let i = 0; i &lt; len; i++) &#123;
        // 遍历回调函数调用传参
        // call是传入（新this指向，参数）
        // thisArg新设置的this，这里无设置就是undefined
        // O[i] 是原数组的当前元素
        // i是当前index
        // O是原数组
        if (callback.call(thisArg, O[i], i, O)) &#123;
          res.push(O[i]);
        &#125;
    &#125;
    // 返回结果
    return res;
  &#125;
  console.log([30,20,16,10].myFilter((num) =&gt; &#123; return num &gt;= 12&#125;));
</code></pre>
<h2 id="27-forEach"><a href="#27-forEach" class="headerlink" title="27.forEach"></a>27.forEach</h2><pre><code class="javascript">Array.prototype.myForEach = function(callback, thisArg) &#123;
    // 判断是否是数组调用，并且传入的是回调函数
    if (this == null) &#123;
      throw new TypeError(&#39;this is null or not defined&#39;);
    &#125;
    if (typeof callback !== &quot;function&quot;) &#123;
      throw new TypeError(callback + &#39; is not a function&#39;);
    &#125;
    const O = Object(this);
    const len = O.length &gt;&gt;&gt; 0;
    let k = 0;
   // 循环所有数据  
   for(let i = 0; i &lt; len; i++) &#123;
    callback.call(thisArg, O[k], k, O);
   &#125;
  &#125;
</code></pre>
<h2 id="28-instanceof"><a href="#28-instanceof" class="headerlink" title="28.instanceof"></a>28.instanceof</h2><pre><code class="javascript">function new_instance_of(leftValue,rightValue)&#123;
    let rightProto = rightValue.prototype;//取右边表达式的 prototype 值
    leftValue = leftValue.__proto__;//取左表达式的 __proto__ 值
    while(true)&#123;
        if(leftValue == null)&#123;
            return false;
        &#125;
        if(leftValue === rightProto)&#123;
            return true;
        &#125;
        leftValue = leftValue.__proto__;
    &#125;
&#125;
function Foo()&#123;&#125;
console.log(new_instance_of(Foo,Object))//true
</code></pre>
<h2 id="29-jsonp"><a href="#29-jsonp" class="headerlink" title="29.jsonp"></a>29.jsonp</h2><pre><code class="javascript">let jsonp=(url,data=&#123;&#125;,callback=&#39;callback&#39;)=&gt;&#123;
    //准备好带有padding的请求url
let dataStr=url.indexOf(&#39;?&#39;)=== -1?&#39;?&#39;:&#39;&amp;&#39;
// console.log(dataStr);
for(let key in data)&#123;
    dataStr +=`$&#123;key&#125;=$&#123;data[key]&#125;&amp;`
&#125;
dataStr +=`callback=`+callback

//构造 script
let oScript=document.createElement(&#39;script&#39;)
oScript.src=url+dataStr
//appendChild () 方法可向节点的子节点列表的末尾添加新的子节点
document.body.appendChild(oScript)

// window[callback]=(data)=&gt;&#123;
//     console.log(data);
// &#125;
return new Promise((resolve,reject)=&gt;&#123;
    window[callback]=(data)=&gt;&#123;
        try&#123;
            resolve(data)
        &#125;catch(e)&#123;
            reject(e)
        &#125;finally&#123;
            oScript.parentNode.removeChild(oScript)// 注意这句代码，OScript移除,细节
        &#125;
    &#125;
&#125;)
&#125;

jsonp(&#39;https://photo.sina.cn/aj/index?a=1&#39;,&#123;
    page:1,
    cate:&#39;recommend&#39;
&#125;).then(response=&gt;&#123;
    console.log(response,&#39;-------then&#39;);
&#125;) 
</code></pre>
<h2 id="30-map"><a href="#30-map" class="headerlink" title="30.map"></a>30.map</h2><pre><code class="javascript">Array.prototype.myMap = function(callback, thisArg) &#123;
    if (this == undefined) &#123;
      throw new TypeError(&#39;this is null or not defined&#39;);
    &#125;
    if (typeof callback !== &#39;function&#39;) &#123;
      throw new TypeError(callback + &#39; is not a function&#39;);
    &#125;
    const res = [];
    const O = Object(this);
    const len = O.length &gt;&gt;&gt; 0;
    for (let i = 0; i &lt; len; i++) &#123;
       // 调用回调函数并传入新数组
       res[i] = callback.call(thisArg, O[i], i, O);
    &#125;
    return res;
  &#125;
</code></pre>
<h2 id="31-new"><a href="#31-new" class="headerlink" title="31.new"></a>31.new</h2><pre><code class="javascript">/**
 * new 使用Js原生实现
 */
function Parent(name, age) &#123;
    this.name = name;
    this.age = age;
    this.sayName = function () &#123;
        console.log(this.name);
    &#125;
&#125;
const _new = function (Parent, ...rest) &#123;
    //1.以构造器Parent的prototype为原型创建新对象
    const child = Object.create(Parent.prototype);
    //2. 将this和调用参数传给构造器执行
    const result = Parent.apply(child, rest);
    return typeof result === &#39;object&#39; ? result : child;
&#125;
const p1 = _new(Parent,&#39;www&#39;,&#39;23&#39;);
console.log(p1);
p1.sayName(); 
</code></pre>
<h2 id="32-object-create"><a href="#32-object-create" class="headerlink" title="32.object-create"></a>32.object-create</h2><pre><code class="javascript">Object.myCreate = function (proto, propertyObject = undefined) &#123;
    if (propertyObject === null) &#123;
      // 这里没有判断propertyObject是否是原始包装对象
      throw &#39;TypeError&#39;
    &#125; else &#123;
      function Fn () &#123;&#125;
      Fn.prototype = proto
      const obj = new Fn()
      if (propertyObject !== undefined) &#123;
        Object.defineProperties(obj, propertyObject)
      &#125;
      if (proto === null) &#123;
        // 创建一个没有原型对象的对象，Object.create(null)
        obj.__proto__ = null
      &#125;
      return obj
    &#125;
  &#125;
  
  // 示例
  // 第二个参数为null时，抛出TypeError
  // const throwErr = Object.myCreate(&#123;a: &#39;aa&#39;&#125;, null)  // Uncaught TypeError
  // 构建一个以
  const obj1 = Object.myCreate(&#123;a: &#39;aa&#39;&#125;)
  console.log(obj1)  // &#123;&#125;, obj1的构造函数的原型对象是&#123;a: &#39;aa&#39;&#125;
  const obj2 = Object.myCreate(&#123;a: &#39;aa&#39;&#125;, &#123;
    b: &#123;
      value: &#39;bb&#39;,
      enumerable: true
    &#125;
  &#125;)
  console.log(obj2)  // &#123;b: &#39;bb&#39;&#125;, obj2的构造函数的原型对象是&#123;a: &#39;aa&#39;&#125;
</code></pre>
<h2 id="33-object-is"><a href="#33-object-is" class="headerlink" title="33.object-is"></a>33.object-is</h2><pre><code class="javascript">Object.is = function(x, y) &#123;
    if (x === y) &#123;
        // 当前情况下，只有一种情况是特殊的，即 +0 -0
        // 如果 x !== 0，则返回true
        // 如果 x === 0，则需要判断+0和-0，则可以直接使用 1/+0 === Infinity 和 1/-0 === -Infinity来进行判断
        return x !== 0 || 1 / x === 1 / y;
    &#125;
    
    // x !== y 的情况下，只需要判断是否为NaN，如果x!==x，则说明x是NaN，同理y也一样
    // x和y同时为NaN时，返回true
    return x !== x &amp;&amp; y !== y;
&#125;
</code></pre>
<h2 id="34-promise-all"><a href="#34-promise-all" class="headerlink" title="34.promise.all"></a>34.promise.all</h2><pre><code class="javascript">Promise.prototype.all = function(promises)&#123;
    let results = [];
    let promiseCount = 0;
    let promisesLength = promises.length;
    return new Promise(function(resolve,reject)&#123;
        for(let val of promises)&#123;
            Promise.resolve(val).then(function(res)&#123;
                promiseCount++;
                results[i] = res;
                if(promiseCount === promisesLength)&#123;
                    return resolve(results);
                &#125;
            &#125;,function(err)&#123;
                return reject(err);
            &#125;)
        &#125;
    &#125;)
&#125;

let promise1 = new Promise(function(resolve) &#123;
    resolve(1);
  &#125;);
  let promise2 = new Promise(function(resolve) &#123;
    resolve(2);
  &#125;);
  let promise3 = new Promise(function(resolve) &#123;
    resolve(3);
  &#125;);
  
  let promiseAll = Promise.all([promise1, promise2, promise3]);
  promiseAll.then(function(res) &#123;
    console.log(res);
  &#125;);
</code></pre>
<h2 id="35-promise"><a href="#35-promise" class="headerlink" title="35.promise"></a>35.promise</h2><pre><code class="javascript">const PENDING = &#39;PENDING&#39;;
const FULFILLED = &#39;FULFILLED&#39;;
const REJECTED = &#39;REJECTED&#39;;

const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;
  // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1
  if (promise2 === x) &#123; 
    return reject(new TypeError(&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;))
  &#125;
  // Promise/A+ 2.3.3.3.3 只能调用一次
  let called;
  // 后续的条件要严格判断 保证代码能和别的库一起使用
  if ((typeof x === &#39;object&#39; &amp;&amp; x != null) || typeof x === &#39;function&#39;) &#123; 
    try &#123;
      // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1
      let then = x.then;
      if (typeof then === &#39;function&#39;) &#123; 
        // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3
        then.call(x, y =&gt; &#123; // 根据 promise 的状态决定是成功还是失败
          if (called) return;
          called = true;
          // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1
          resolvePromise(promise2, y, resolve, reject); 
        &#125;, r =&gt; &#123;
          // 只要失败就失败 Promise/A+ 2.3.3.3.2
          if (called) return;
          called = true;
          reject(r);
        &#125;);
      &#125; else &#123;
        // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4
        resolve(x);
      &#125;
    &#125; catch (e) &#123;
      // Promise/A+ 2.3.3.2
      if (called) return;
      called = true;
      reject(e)
    &#125;
  &#125; else &#123;
    // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4  
    resolve(x)
  &#125;
&#125;

class Promise &#123;
  constructor(executor) &#123;
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks= [];

    let resolve = (value) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125; 

    let reject = (reason) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125;

    try &#123;
      executor(resolve,reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

  then(onFulfilled, onRejected) &#123;
    //解决 onFufilled，onRejected 没有传值的问题
    //Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4
    onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : v =&gt; v;
    //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获
    onRejected = typeof onRejected === &#39;function&#39; ? onRejected : err =&gt; &#123; throw err &#125;;
    // 每次调用 then 都返回一个新的 promise  Promise/A+ 2.2.7
    let promise2 = new Promise((resolve, reject) =&gt; &#123;
      if (this.status === FULFILLED) &#123;
        //Promise/A+ 2.2.2
        //Promise/A+ 2.2.4 --- setTimeout
        setTimeout(() =&gt; &#123;
          try &#123;
            //Promise/A+ 2.2.7.1
            let x = onFulfilled(this.value);
            // x可能是一个proimise
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            //Promise/A+ 2.2.7.2
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === REJECTED) &#123;
        //Promise/A+ 2.2.3
        setTimeout(() =&gt; &#123;
          try &#123;
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === PENDING) &#123;
        this.onResolvedCallbacks.push(() =&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);

        this.onRejectedCallbacks.push(()=&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject)
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);
      &#125;
    &#125;);
  
    return promise2;
  &#125;
&#125;
</code></pre>
<h2 id="36-promise-race"><a href="#36-promise-race" class="headerlink" title="36.promise.race"></a>36.promise.race</h2><pre><code class="javascript">Promise.race = function(promises)&#123;
    //将可迭代对象转换为数组
    promises = Array.from(promises);
    return new Promise((resolve,reject)=&gt;&#123;
        if(promises.length === 0)&#123;
            //空的可迭代对象，用于pending状态
        &#125;else&#123;
            for(let i = 0;i &lt; promises.length;i++)&#123;
                Promise.resolve(promises[i]).then((data)=&gt;&#123;
                    resolve(data);
                &#125;).catch((reason)=&gt;&#123;
                    reject(reason)
                &#125;)
            &#125;
        &#125;
    &#125;)
&#125;

let p1 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;success&#39;)
    &#125;,1000)
&#125;)

let p2 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;faild&#39;)
    &#125;,500)
&#125;)

Promise.race([p1,p2]).then(result=&gt;&#123;
console.log(result)             //  faild    faild耗时短
&#125;)
</code></pre>
<h2 id="37-reduce"><a href="#37-reduce" class="headerlink" title="37.reduce"></a>37.reduce</h2><pre><code class="javascript">Array.prototype.myReduce = function(callback, initialValue) &#123;
    // 判断调用的是否是数组，以及传入的callback是否是函数
    if (this == undefined) &#123;
      throw new TypeError(&#39;this is null or not defined&#39;);
    &#125;
    if (typeof callback !== &#39;function&#39;) &#123;
      throw new TypeError(callbackfn + &#39; is not a function&#39;);
    &#125;
    // 空数组也是不允许的
    if (this.length == 0) &#123;
     throw new TypeError(&#39;Reduce of empty array with no initial value&#39;);
    &#125;
    // 让O成为回调函数的对象传递（强制转换对象）
    const O = Object(this);
    // &gt;&gt;&gt;0 保证len为number，且为正整数
    const len = this.length &gt;&gt;&gt; 0;
    // 保存初始值，初始值不传的时候为undefined
    let accumulator = initialValue;
    // 标志位
    let k = 0;
    // 如果第二个参数为undefined的情况，则数组的第一个有效值作为累加器的初始值
    if (accumulator === undefined) &#123;
      // 这里是k++，就是赋值完成之后k再加1
      accumulator = O[k++];
    &#125;
    // 此时如果有初始值，k是0，如果无初始值k是1
    for(k;k&lt;len;k++) &#123;
     accumulator = callback.call(this, accumulator, O[k], k, O);
    &#125;
    return accumulator;
  &#125;
  console.log([2,4,6].myReduce((t,n)=&gt;&#123;return t+n&#125;));
  console.log([2,4,6].myReduce((t,n)=&gt;&#123;return t+n&#125;,10));
</code></pre>
<h2 id="38-sleep"><a href="#38-sleep" class="headerlink" title="38.sleep"></a>38.sleep</h2><pre><code class="javascript">//Promise
const sleep = time =&gt; &#123;
    return new Promise(resolve =&gt; setTimeout(resolve,time))
  &#125;
  sleep(1000).then(()=&gt;&#123;
    console.log(1)
  &#125;)
  
  //Generator
  function* sleepGenerator(time) &#123;
    yield new Promise(function(resolve,reject)&#123;
      setTimeout(resolve,time);
    &#125;)
  &#125;
  sleepGenerator(1000).next().value.then(()=&gt;&#123;console.log(1)&#125;)
  
  //async
  function sleep(time) &#123;
    return new Promise(resolve =&gt; setTimeout(resolve,time))
  &#125;
  async function output() &#123;
    let out = await sleep(1000);
    console.log(1);
    return out;
  &#125;
  output();
  
  //ES5
  function sleep(callback,time) &#123;
    if(typeof callback === &#39;function&#39;)
      setTimeout(callback,time)
  &#125;
  
  function output()&#123;
    console.log(1);
  &#125;
  sleep(output,1000);
</code></pre>
<h2 id="39-vue-Reactive"><a href="#39-vue-Reactive" class="headerlink" title="39.vue-Reactive"></a>39.vue-Reactive</h2><pre><code class="javascript">const targetMap = new WeakMap();
let activeEffect = null; // 引入 activeEffect 变量

const effect = eff =&gt; &#123;
    activeEffect = eff; // 1. 将副作用赋值给 activeEffect
  activeEffect();     // 2. 执行 activeEffect
  activeEffect = null;// 3. 重置 activeEffect
&#125;

const track = (target, key) =&gt; &#123;
    if (activeEffect) &#123;  // 1. 判断当前是否有 activeEffect
        let depsMap = targetMap.get(target);
        if (!depsMap) &#123;
            targetMap.set(target, (depsMap = new Map()));
        &#125;
        let dep = depsMap.get(key);
        if (!dep) &#123;
            depsMap.set(key, (dep = new Set()));
        &#125;
        dep.add(activeEffect);  // 2. 添加 activeEffect 依赖
    &#125;
&#125;

const trigger = (target, key) =&gt; &#123;
    const depsMap = targetMap.get(target);
    if (!depsMap) return;
    let dep = depsMap.get(key);
    if (dep) &#123;
        dep.forEach(effect =&gt; effect());
    &#125;
&#125;;

const reactive = (target) =&gt; &#123;
    const handler = &#123;
        get(target, key, receiver) &#123;
            const result = Reflect.get(target, key, receiver);
            track(target, key);
            return result;
        &#125;,
        set(target, key, value, receiver) &#123;
            const oldValue = target[key];
            const result = Reflect.set(target, key, value, receiver);
            if (oldValue != result) &#123;
                trigger(target, key);
            &#125;
            return result;
        &#125;
    &#125;

    return new Proxy(target, handler);
&#125;

let product = reactive(&#123; price: 10, quantity: 2 &#125;);
let total = 0, salePrice = 0;
// 修改 effect 使用方式，将副作用作为参数传给 effect 方法
effect(() =&gt; &#123;
    total = product.price * product.quantity
&#125;);
effect(() =&gt; &#123;
    salePrice = product.price * 0.9
&#125;);
console.log(total, salePrice);  // 20 9
product.quantity = 5;
console.log(total, salePrice);  // 50 9
product.price = 20;
console.log(total, salePrice);  // 100 18
</code></pre>
<h2 id="40-算法笔试"><a href="#40-算法笔试" class="headerlink" title="40.算法笔试"></a>40.算法笔试</h2><h3 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h3><pre><code class="javascript">function insertionSort(arr) &#123;
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) &#123;
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        &#125;
        arr[preIndex+1] = current;
    &#125;
    return arr;
&#125;
const arr1 = [2,6,8,2,3,5,0,1,6,8]
let res = insertionSort(arr1)
console.log(arr1)//[ 0, 1, 2, 2, 3, 5, 6, 6, 8, 8]
</code></pre>
<h3 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2.堆排序"></a>2.堆排序</h3><pre><code class="javascript">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) &#123;   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;
        heapify(arr, i);
    &#125;
&#125;

function heapify(arr, i) &#123;     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;
        largest = left;
    &#125;

    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;
        largest = right;
    &#125;

    if (largest != i) &#123;
        swap(arr, i, largest);
        heapify(arr, largest);
    &#125;
&#125;

function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;

function heapSort(arr) &#123;
    buildMaxHeap(arr);

    for (var i = arr.length-1; i &gt; 0; i--) &#123;
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    &#125;
    return arr;
&#125;

const arr1 = [12,4,6,9,11,0,4,3,7,9]
let res = heapSort(arr1)
console.log(res)//[0, 3, 4,  4,  6, 7, 9, 9, 11, 12]
</code></pre>
<h3 id="3-斐波那契数列"><a href="#3-斐波那契数列" class="headerlink" title="3.斐波那契数列"></a>3.斐波那契数列</h3><pre><code class="javascript">//方法一：使用递归
function fibonacci(n) &#123;
    if (n == 1 || n == 2) &#123;
        return 1
    &#125;;
    return fibonacci(n - 2) + fibonacci(n - 1);
&#125;
console.log(fibonacci(3))//2

//方法二：改进递归-把前两位数字做成参数避免重复计算
function fibonacci(n) &#123;
    function fib(n, v1, v2) &#123;
        if (n == 1)
            return v1;
        if (n == 2)
            return v2;
        else
            return fib(n - 1, v2, v1 + v2)
    &#125;
    return fib(n, 1, 1)
&#125;
fibonacci(30)

//方法三：改进递归-利用闭包特性把运算结果存储在数组里，避免重复计算
var fibonacci = function () &#123;
    let memo = [0, 1];
    let fib = function (n) &#123;
        if (memo[n] == undefined) &#123;
            memo[n] = fib(n - 2) + fib(n - 1)
        &#125;
        return memo[n]
    &#125;
    return fib;
&#125;()
fibonacci(30)


//方法四：改进递归-摘出存储计算结果的功能函数
var memoizer = function (func) &#123;
    let memo = [];
    return function (n) &#123;
        if (memo[n] == undefined) &#123;
            memo[n] = func(n)
        &#125;
        return memo[n]
    &#125;
&#125;;
var fibonacci=memoizer(function(n)&#123;
    if (n == 1 || n == 2) &#123;
        return 1
    &#125;;
    return fibonacci(n - 2) + fibonacci(n - 1);
&#125;)
fibonacci(30)


//方法五：普通for循环
function fibonacci(n) &#123;
    var n1 = 1, n2 = 1, sum;
    for (let i = 2; i &lt; n; i++) &#123;
        sum = n1 + n2
        n1 = n2
        n2 = sum
    &#125;
    return sum
&#125;
fibonacci(30)

//方法六：for循环+解构赋值
var fibonacci = function (n) &#123;
    let n1 = 1; n2 = 1;
    for (let i = 2; i &lt; n; i++) &#123;
        [n1, n2] = [n2, n1 + n2]
    &#125;
    return n2
&#125;
fibonacci(30)
</code></pre>
<h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h3><pre><code class="javascript">function mergeSort(arr) &#123;  // 采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    var result = [];

    while (left.length &amp;&amp; right.length) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
&#125;


const arr1 = [1,4,6,1,0,3,4,2,7,3,1]
let res = mergeSort(arr1)
console.log(res)//[0, 1, 1, 1, 2,3, 3, 4, 4, 6,7]
</code></pre>
<h3 id="5-汉诺塔问题"><a href="#5-汉诺塔问题" class="headerlink" title="5.汉诺塔问题"></a>5.汉诺塔问题</h3><pre><code class="javascript">/** 
 * @param &#123;圆盘数：number&#125; plates 
 * @param &#123;起始柱子 a：string&#125; source 
 * @param &#123;辅助柱子 b：string&#125; helper 
 * @param &#123;目标柱子 c：string&#125; dest 
 * @param &#123;移动步骤集：Array，数组的长度就是移动的次数&#125; moves 
 */
function hanoi(plates, source, helper, dest, moves = []) &#123;
    if (plates &lt;= 0) &#123;
        return moves;
    &#125;
    if (plates === 1) &#123;
        moves.push([source, dest]);
    &#125; else &#123;
        hanoi(plates - 1, source, dest, helper, moves);
        moves.push([source, dest]);
        hanoi(plates - 1, helper, source, dest, moves);
    &#125;
    return moves;
&#125;

// test
console.log(hanoi(4, &#39;source&#39;, &#39;helper&#39;, &#39;dest&#39;)); // 输出结果如下图展示
</code></pre>
<h3 id="6-合并两个有序数组"><a href="#6-合并两个有序数组" class="headerlink" title="6.合并两个有序数组"></a>6.合并两个有序数组</h3><pre><code class="javascript">var merge = function (nums1, m, nums2, n) &#123;
    var p = m + n - 1;//0
    var p1 = m - 1;//-1
    var p2 = n - 1;//0
      // 理论上来说，nums2应该全部填充进去，所以这里以p2作为条件
    while (p2 &gt;= 0) &#123;
        // nums1里面全是0的情况，比如[0], 0, [1], 1
        if (p1 &lt; 0) &#123;
            // 直接用nums2去填补nums1就好了
            nums1[p--] = nums2[p2--]
        // 只有nums2比nums1大才用nus2填补
        &#125; else if (nums2[p2] &gt; nums1[p1]) &#123;
            nums1[p] = nums2[p2];
            p--;
            p2--;
        // 反之用nums1填补
        &#125; else &#123;
            nums1[p] = nums1[p1];
            p--;
            p1--;
        &#125;
    &#125;;
    return nums1;
&#125;;

let nums1 = [1,2,3,0,0,0], m = 3,nums2 = [2,5,6],n = 3
console.log(merge(nums1, m, nums2, n))//[ 1, 2, 2, 3, 5, 6 ]
</code></pre>
<h3 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h3><pre><code class="javascript">function quickSort(arr, left, right) &#123;
    var len = arr.length,
        partitionIndex,
        left = typeof left != &#39;number&#39; ? 0 : left,
        right = typeof right != &#39;number&#39; ? len - 1 : right;

    if (left &lt; right) &#123;
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    &#125;
    return arr;
&#125;

function partition(arr, left ,right) &#123;     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) &#123;
        if (arr[i] &lt; arr[pivot]) &#123;
            swap(arr, i, index);
            index++;
        &#125;        
    &#125;
    swap(arr, pivot, index - 1);
    return index-1;
&#125;

function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;
function partition2(arr, low, high) &#123;
  let pivot = arr[low];
  while (low &lt; high) &#123;
    while (low &lt; high &amp;&amp; arr[high] &gt; pivot) &#123;
      --high;
    &#125;
    arr[low] = arr[high];
    while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;
      ++low;
    &#125;
    arr[high] = arr[low];
  &#125;
  arr[low] = pivot;
  return low;
&#125;

function quickSort2(arr, low, high) &#123;
  if (low &lt; high) &#123;
    let pivot = partition2(arr, low, high);
    quickSort2(arr, low, pivot - 1);
    quickSort2(arr, pivot + 1, high);
  &#125;
  return arr;
&#125;

const arr1 = [1,4,6,1,0,3,4,2,7,3,1]
let res = quickSort(arr1,0,11)
console.log(res)//[ 0, 1, 1, 1, 2, 3, 3, 4, 4, 6,7]
</code></pre>
<h3 id="8-两数之和"><a href="#8-两数之和" class="headerlink" title="8.两数之和"></a>8.两数之和</h3><pre><code class="javascript">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number[]&#125;
 */
const twoSum = (nums, target) =&gt; &#123;
    const prevNums = &#123;&#125;;                    // 存储出现过的数字，和对应的索引               
  
    for (let i = 0; i &lt; nums.length; i++) &#123;       // 遍历元素   
      const curNum = nums[i];                     // 当前元素   
      const targetNum = target - curNum;          // 满足要求的目标元素   
      const targetNumIndex = prevNums[targetNum]; // 在prevNums中获取目标元素的索引
      if (targetNumIndex !== undefined) &#123;         // 如果存在，直接返回 [目标元素的索引,当前索引]
        return [targetNumIndex, i];
      &#125; else &#123;                                    // 如果不存在，说明之前没出现过目标元素
        prevNums[curNum] = i;                     // 存入当前的元素和对应的索引
      &#125;
    &#125;
  &#125;

  let nums = [2,7,11,15], target = 17
  console.log(twoSum(nums,target))//[ 0, 3 ]
</code></pre>
<h3 id="9-冒泡排序"><a href="#9-冒泡排序" class="headerlink" title="9.冒泡排序"></a>9.冒泡排序</h3><pre><code class="javascript"> //双向冒泡排序
 function bubbleSort_twoway(arr) &#123;
    var len = arr.length;    //依次将最大的数放置到数组末尾，将第二大的数放到倒数第二位...
    var flag = false;
    for(var i = 0; i &lt; len/2; i++) &#123;
        flag = false;
        for(var j = i; j &lt; len - 1 - i; j++) &#123;   //从前往后,比较相邻两个数,把大的放在后边.之前已放置成功的可以不再参与比较
            if(arr[j] &gt; arr[j + 1]) &#123;
                var middle = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = middle;
                flag =true;
            &#125;
        &#125;
        if(!flag)&#123;
            break;
        &#125;

        for(var j = len - 1 - i; j &gt; i; j--)&#123;
            if(arr[j] &lt; arr[j - 1]) &#123;
                var middle = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = middle;
                flag = true;
            &#125;
        &#125;
        if(!flag)&#123;
            break;
        &#125;
    &#125;
    return arr;
&#125;

var defaultArr = [3, 5, 32, 15, 7, 26, 10, 55, 45, 12, 28, 88, 18];
var resultArr = bubbleSort_twoway(defaultArr);
console.table(resultArr);
</code></pre>
<h3 id="10-爬台阶"><a href="#10-爬台阶" class="headerlink" title="10.爬台阶"></a>10.爬台阶</h3><pre><code class="javascript">/**
 * @param &#123;number&#125; n
 * @return &#123;number&#125;
 */
var climbStairs = function(n) &#123;
    const sqrt_5 = Math.sqrt(5);
    const fib_n = Math.pow((1 + sqrt_5) / 2, n + 1) - Math.pow((1 - sqrt_5) / 2,n + 1);
    return Math.round(fib_n / sqrt_5);
&#125;;


/**
 * @param &#123;number&#125; n
 * @return &#123;number&#125;
 */
var climbStairs = function(n) &#123;
    const dp = [];
    dp[0] = 1;
    dp[1] = 1;
    for(let i = 2; i &lt;= n; i++) &#123;
        dp[i] = dp[i - 1] + dp[i - 2];
    &#125;
    return dp[n];
&#125;;
</code></pre>
<h3 id="11-数组交集"><a href="#11-数组交集" class="headerlink" title="11.数组交集"></a>11.数组交集</h3><pre><code class="javascript">//数组功能扩展
//数组迭代函数
Array.prototype.each = function(fn)&#123;
    fn = fn || Function.K;
    var a = [];
    var args = Array.prototype.slice.call(arguments, 1);
    for(var i = 0; i &lt; this.length; i++)&#123;
    var res = fn.apply(this,[this[i],i].concat(args));
    if(res != null) a.push(res);
    &#125;
    return a;
   &#125;;
   //数组是否包含指定元素
   Array.prototype.contains = function(suArr)&#123;
    for(var i = 0; i &lt; this.length; i ++)&#123;
    if(this[i] == suArr)&#123;
    return true;
    &#125;
    &#125;
    return false;
   &#125;
   //不重复元素构成的数组
   Array.prototype.uniquelize = function()&#123;
    var ra = new Array();
    for(var i = 0; i &lt; this.length; i ++)&#123;
    if(!ra.contains(this[i]))&#123;
    ra.push(this[i]);
    &#125;
    &#125;
    return ra;
   &#125;;
   //两个数组的交集
   Array.intersect = function(a, b)&#123;
    return a.uniquelize().each(function(o)&#123;return b.contains(o) ? o : null&#125;);
   &#125;;
   //两个数组的差集
   Array.minus = function(a, b)&#123;
    return a.uniquelize().each(function(o)&#123;return b.contains(o) ? null : o&#125;);
   &#125;;
   //两个数组的补集
   Array.complement = function(a, b)&#123;
    return Array.minus(Array.union(a, b),Array.intersect(a, b));
   &#125;;
   //两个数组并集
   Array.union = function(a, b)&#123;
    return a.concat(b).uniquelize();
   &#125;;


var a = [1,2,3,4,5]
var b = [2,4,6,8,10]
console.log(&quot;数组a：&quot;, a);
console.log(&quot;数组b：&quot;, b);
var sa = new Set(a);
var sb = new Set(b);
// 交集
let intersect = a.filter(x =&gt; sb.has(x));
// 差集
let minus = a.filter(x =&gt; !sb.has(x));
// 补集
let complement = [...a.filter(x =&gt; !sb.has(x)), ...b.filter(x =&gt; !sa.has(x))];
// 并集
let unionSet = Array.from(new Set([...a, ...b]));
console.log(&quot;a与b的交集：&quot;, intersect);
console.log(&quot;a与b的差集：&quot;, minus);
console.log(&quot;a与b的补集：&quot;, complement);
console.log(&quot;a与b的并集：&quot;, unionSet);
</code></pre>
<h3 id="12-希尔排序"><a href="#12-希尔排序" class="headerlink" title="12.希尔排序"></a>12.希尔排序</h3><pre><code class="javascript">function shellSort(arr) &#123;
    var len = arr.length,
        temp,
        gap = 1;
    while(gap &lt; len/3) &#123;          //动态定义间隔序列
        gap =gap*3+1;
    &#125;
    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123;
        for (var i = gap; i &lt; len; i++) &#123;
            temp = arr[i];
            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;
                arr[j+gap] = arr[j];
            &#125;
            arr[j+gap] = temp;
        &#125;
    &#125;
    return arr;
&#125;

var defaultArr = [3, 5, 32, 15, 7, 26, 10, 55, 45, 12, 28, 88, 18];
var resultArr = shellSort(defaultArr);
console.table(resultArr);
</code></pre>
<h3 id="13-旋转数组"><a href="#13-旋转数组" class="headerlink" title="13.旋转数组"></a>13.旋转数组</h3><pre><code class="javascript">/**
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
 */

let reverse = function(nums, start, end)&#123;
    while(start &lt; end)&#123;
        [nums[start++], nums[end--]] = [nums[end], nums[start]];
    &#125;
&#125;
let rotate = function(nums, k) &#123;
    k %= nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
    return nums;
&#125;;
</code></pre>
<h3 id="14-选择排序"><a href="#14-选择排序" class="headerlink" title="14.选择排序"></a>14.选择排序</h3><pre><code class="javascript">function selectionSort(arr) &#123;
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) &#123;
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) &#123;
            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    return arr;
&#125;
var defaultArr = [3, 5, 32, 15, 7, 26, 10, 55, 45, 12, 28, 88, 18];
var resultArr = selectionSort(defaultArr);
console.table(resultArr);
</code></pre>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>面试手撕代码合集</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全ES6</title>
    <url>/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（ES6）"><a href="#前端面试题大全（ES6）" class="headerlink" title="前端面试题大全（ES6）"></a>前端面试题大全（ES6）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-var、let、const之间的区别"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-var、let、const之间的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ var、let、const之间的区别"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ var、let、const之间的区别</h3><h4 id="一、var"><a href="#一、var" class="headerlink" title="一、var"></a>一、var</h4><p>在ES5中，顶层对象的属性和全局变量是等价的，用<code>var</code>声明的变量既是全局变量，也是顶层变量</p>
<p>注意：顶层对象，在浏览器环境指的是<code>window</code>对象，在 <code>Node</code> 指的是<code>global</code>对象</p>
<pre><code class="javascript">var a = 10;
console.log(window.a) // 10
</code></pre>
<p>使用<code>var</code>声明的变量存在变量提升的情况</p>
<pre><code class="javascript">console.log(a) // undefined
var a = 20
</code></pre>
<p>在编译阶段，编译器会将其变成以下执行</p>
<pre><code class="javascript">var a
console.log(a)
a = 20
</code></pre>
<p>使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明</p>
<pre><code class="javascript">var a = 20 
var a = 30
console.log(a) // 30
</code></pre>
<p>在函数中使用使用<code>var</code>声明变量时候，该变量是局部的</p>
<pre><code class="javascript">var a = 20
function change()&#123;
    var a = 30
&#125;
change()
console.log(a) // 20 
</code></pre>
<p>而如果在函数内不使用<code>var</code>，该变量是全局的</p>
<pre><code class="javascript">var a = 20
function change()&#123;
   a = 30
&#125;
change()
console.log(a) // 30 
</code></pre>
<h4 id="二、let"><a href="#二、let" class="headerlink" title="二、let"></a>二、let</h4><p><code>let</code>是<code>ES6</code>新增的命令，用来声明变量</p>
<p>用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效</p>
<pre><code class="javascript">&#123;
    let a = 20
&#125;
console.log(a) // ReferenceError: a is not defined.
</code></pre>
<p>不存在变量提升</p>
<pre><code class="javascript">console.log(a) // 报错ReferenceError
let a = 2
</code></pre>
<p>这表示在声明它之前，变量<code>a</code>是不存在的，这时如果用到它，就会抛出一个错误</p>
<p>只要块级作用域内存在<code>let</code>命令，这个区域就不再受外部影响</p>
<pre><code class="javascript">var a = 123
if (true) &#123;
    a = &#39;abc&#39; // ReferenceError
    let a;
&#125;
</code></pre>
<p>使用<code>let</code>声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”</p>
<p>最后，<code>let</code>不允许在相同作用域中重复声明</p>
<pre><code class="javascript">let a = 20
let a = 30
// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared
</code></pre>
<p>注意的是相同作用域，下面这种情况是不会报错的</p>
<pre><code class="javascript">let a = 20
&#123;
    let a = 30
&#125;
</code></pre>
<p>因此，我们不能在函数内部重新声明参数</p>
<pre><code class="javascript">function func(arg) &#123;
  let arg;
&#125;
func()
// Uncaught SyntaxError: Identifier &#39;arg&#39; has already been declared
</code></pre>
<h4 id="三、const"><a href="#三、const" class="headerlink" title="三、const"></a>三、const</h4><p><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变</p>
<pre><code class="javascript">const a = 1
a = 3
// TypeError: Assignment to constant variable.
</code></pre>
<p>这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值</p>
<pre><code class="javascript">const a;
// SyntaxError: Missing initializer in const declaration
</code></pre>
<p>如果之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错</p>
<pre><code class="javascript">var a = 20
let b = 20
const a = 30
const b = 30
// 都会报错
</code></pre>
<p><code>const</code>实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</p>
<p>对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量</p>
<p>对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的，并不能确保改变量的结构不变</p>
<pre><code class="javascript">const foo = &#123;&#125;;

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only
</code></pre>
<p>其它情况，<code>const</code>与<code>let</code>一致</p>
<h4 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h4><p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p>
<ul>
<li>变量提升</li>
<li>暂时性死区</li>
<li>块级作用域</li>
<li>重复声明</li>
<li>修改声明的变量</li>
<li>使用</li>
</ul>
<h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><pre><code class="css">var `声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined
</code></pre>
<p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p>
<pre><code class="javascript">// var
console.log(a)  // undefined
var a = 10

// let 
console.log(b)  // Cannot access &#39;b&#39; before initialization
let b = 10

// const
console.log(c)  // Cannot access &#39;c&#39; before initialization
const c = 10
</code></pre>
<h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><p><code>var</code>不存在暂时性死区</p>
<p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<pre><code class="javascript">// var
console.log(a)  // undefined
var a = 10

// let
console.log(b)  // Cannot access &#39;b&#39; before initialization
let b = 10

// const
console.log(c)  // Cannot access &#39;c&#39; before initialization
const c = 10
</code></pre>
<h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p><code>var</code>不存在块级作用域</p>
<p><code>let</code>和<code>const</code>存在块级作用域</p>
<pre><code class="javascript">// var
&#123;
    var a = 20
&#125;
console.log(a)  // 20

// let
&#123;
    let b = 20
&#125;
console.log(b)  // Uncaught ReferenceError: b is not defined

// const
&#123;
    const c = 20
&#125;
console.log(c)  // Uncaught ReferenceError: c is not defined
</code></pre>
<h5 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h5><p><code>var</code>允许重复声明变量</p>
<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p>
<pre><code class="javascript">// var
var a = 10
var a = 20 // 20

// let
let b = 10
let b = 20 // Identifier &#39;b&#39; has already been declared

// const
const c = 10
const c = 20 // Identifier &#39;c&#39; has already been declared
</code></pre>
<h5 id="修改声明的变量"><a href="#修改声明的变量" class="headerlink" title="修改声明的变量"></a>修改声明的变量</h5><p><code>var</code>和<code>let</code>可以</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p>
<pre><code class="javascript">// var
var a = 10
a = 20
console.log(a)  // 20

//let
let b = 10
b = 20
console.log(b)  // 20

// const
const c = 10
c = 20
console.log(c) // Uncaught TypeError: Assignment to constant variable
</code></pre>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>能用<code>const</code>的情况尽量使用<code>const</code>，其他情况下大多数使用<code>let</code>，避免使用<code>var</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中数组新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中数组新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中数组新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中数组新增了哪些扩展?</h3><h4 id="一、扩展运算符的应用"><a href="#一、扩展运算符的应用" class="headerlink" title="一、扩展运算符的应用"></a>一、扩展运算符的应用</h4><p>ES6通过扩展元素符<code>...</code>，好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<pre><code class="javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre>
<p>主要用于函数调用的时候，将一个数组变为参数序列</p>
<pre><code class="javascript">function push(array, ...items) &#123;
  array.push(...items);
&#125;

function add(x, y) &#123;
  return x + y;
&#125;

const numbers = [4, 38];
add(...numbers) // 42
</code></pre>
<p>可以将某些数据结构转为数组</p>
<pre><code class="javascript">[...document.querySelectorAll(&#39;div&#39;)]
</code></pre>
<p>能够更简单实现数组复制</p>
<pre><code class="javascript">const a1 = [1, 2];
const [...a2] = a1;
// [1,2]
</code></pre>
<p>数组的合并也更为简洁了</p>
<pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;];
const arr2 = [&#39;c&#39;];
const arr3 = [&#39;d&#39;, &#39;e&#39;];
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</code></pre>
<p>注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组</p>
<p>下面看个例子就清楚多了</p>
<pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;,[1,2]];
const arr2 = [&#39;c&#39;];
const arr3  = [...arr1,...arr2]
arr1[2][0] = 9999 // 修改arr1里面数组成员值
console.log(arr3) // 影响到arr3,[&#39;a&#39;,&#39;b&#39;,[9999,2],&#39;c&#39;]
</code></pre>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组</p>
<pre><code class="javascript">const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = [&quot;foo&quot;];
first  // &quot;foo&quot;
rest   // []
</code></pre>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p>
<pre><code class="javascript">const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</code></pre>
<p>可以将字符串转为真正的数组</p>
<pre><code class="javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
<p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p>
<pre><code class="javascript">let nodeList = document.querySelectorAll(&#39;div&#39;);
let array = [...nodeList];

let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]
</code></pre>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错</p>
<pre><code class="javascript">const obj = &#123;a: 1, b: 2&#125;;
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
</code></pre>
<h4 id="二、构造函数新增的方法"><a href="#二、构造函数新增的方法" class="headerlink" title="二、构造函数新增的方法"></a>二、构造函数新增的方法</h4><p>关于构造函数，数组新增的方法有如下：</p>
<ul>
<li>Array.from()</li>
<li>Array.of()</li>
</ul>
<h5 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h5><p>将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>
<pre><code class="javascript">let arrayLike = &#123;
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
&#125;;
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<pre><code class="javascript">Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]
</code></pre>
<h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h5><p>用于将一组值，转换为数组</p>
<pre><code class="javascript">Array.of(3, 11, 8) // [3,11,8]
</code></pre>
<p>没有参数的时候，返回一个空数组</p>
<p>当参数只有一个的时候，实际上是指定数组的长度</p>
<p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p>
<pre><code class="javascript">Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
</code></pre>
<h4 id="三、实例对象新增的方法"><a href="#三、实例对象新增的方法" class="headerlink" title="三、实例对象新增的方法"></a>三、实例对象新增的方法</h4><p>关于数组实例对象新增的方法有如下：</p>
<ul>
<li>copyWithin()</li>
<li>find()、findIndex()</li>
<li>fill()</li>
<li>entries()，keys()，values()</li>
<li>includes()</li>
<li>flat()，flatMap()</li>
</ul>
<h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h5><p>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p>
<p>参数如下：</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<pre><code>[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2
// [4, 5, 3, 4, 5] 
</code></pre>
<h5 id="find-、findIndex"><a href="#find-、findIndex" class="headerlink" title="find()、findIndex()"></a>find()、findIndex()</h5><p><code>find()</code>用于找出第一个符合条件的数组成员</p>
<p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p>
<pre><code class="javascript">[1, 5, 10, 15].find(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 10
findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1
[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 2
</code></pre>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>
<pre><code class="javascript">function f(v)&#123;
  return v &gt; this.age;
&#125;
let person = &#123;name: &#39;John&#39;, age: 20&#125;;
[10, 12, 26, 15].find(f, person);    // 26
</code></pre>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p>使用给定值，填充一个数组</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre>
<p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
</code></pre>
<p>注意，如果填充的类型为对象，则是浅拷贝</p>
<h5 id="entries-，keys-，values"><a href="#entries-，keys-，values" class="headerlink" title="entries()，keys()，values()"></a>entries()，keys()，values()</h5><p><code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历</p>
<pre><code class="javascript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;
  console.log(index);
&#125;
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;
  console.log(elem);
&#125;
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;
  console.log(index, elem);
&#125;
// 0 &quot;a&quot;
</code></pre>
<h5 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h5><p>用于判断数组是否包含给定的值</p>
<pre><code class="javascript">[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
</code></pre>
<p>方法的第二个参数表示搜索的起始位置，默认为<code>0</code></p>
<p>参数为负数则表示倒数的位置</p>
<pre><code class="javascript">[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</code></pre>
<h5 id="flat-，flatMap"><a href="#flat-，flatMap" class="headerlink" title="flat()，flatMap()"></a>flat()，flatMap()</h5><p>将数组扁平化处理，返回一个新数组，对原数据没有影响</p>
<pre><code class="javascript">[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
</code></pre>
<p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1</p>
<pre><code class="javascript">[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
</code></pre>
<p><code>flatMap()</code>方法对原数组的每个成员执行一个函数相当于执行<code>Array.prototype.map()</code>，然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组</p>
<pre><code class="javascript">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) =&gt; [x, x * 2])
// [2, 4, 3, 6, 4, 8]
flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this
</code></pre>
<h4 id="四、数组的空位"><a href="#四、数组的空位" class="headerlink" title="四、数组的空位"></a>四、数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值</p>
<p>ES6 则是明确将空位转为<code>undefined</code>，包括<code>Array.from</code>、扩展运算符、<code>copyWithin()</code>、<code>fill()</code>、<code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code></p>
<p>建议大家在日常书写中，避免出现空位</p>
<h4 id="五、排序稳定性"><a href="#五、排序稳定性" class="headerlink" title="五、排序稳定性"></a>五、排序稳定性</h4><p>将<code>sort()</code>默认设置为稳定的排序算法</p>
<pre><code class="javascript">const arr = [
  &#39;peach&#39;,
  &#39;straw&#39;,
  &#39;apple&#39;,
  &#39;spork&#39;
];

const stableSorting = (s1, s2) =&gt; &#123;
  if (s1[0] &lt; s2[0]) return -1;
  return 1;
&#125;;

arr.sort(stableSorting)
// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]
</code></pre>
<p>排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中对象新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中对象新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中对象新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中对象新增了哪些扩展?</h3><h4 id="一、属性的简写"><a href="#一、属性的简写" class="headerlink" title="一、属性的简写"></a>一、属性的简写</h4><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写</p>
<pre><code class="javascript">const baz = &#123;foo:foo&#125;

// 等同于
const baz = &#123;foo&#125;
</code></pre>
<p>方法也能够进行简写</p>
<pre><code class="javascript">const o = &#123;
  method() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;;

// 等同于

const o = &#123;
  method: function() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;
</code></pre>
<p>在函数内作为返回值，也会变得方便很多</p>
<pre><code class="javascript">function getPoint() &#123;
  const x = 1;
  const y = 10;
  return &#123;x, y&#125;;
&#125;

getPoint()
// &#123;x:1, y:10&#125;
</code></pre>
<p>注意：简写的对象方法不能用作构造函数，否则会报错</p>
<pre><code class="javascript">const obj = &#123;
  f() &#123;
    this.foo = &#39;bar&#39;;
  &#125;
&#125;;

new obj.f() // 报错
</code></pre>
<h4 id="二、属性名表达式"><a href="#二、属性名表达式" class="headerlink" title="二、属性名表达式"></a>二、属性名表达式</h4><p>ES6 允许字面量定义对象时，将表达式放在括号内</p>
<pre><code class="javascript">let lastWord = &#39;last word&#39;;

const a = &#123;
  &#39;first word&#39;: &#39;hello&#39;,
  [lastWord]: &#39;world&#39;
&#125;;

a[&#39;first word&#39;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&#39;last word&#39;] // &quot;world&quot;
</code></pre>
<p>表达式还可以用于定义方法名</p>
<pre><code class="javascript">let obj = &#123;
  [&#39;h&#39; + &#39;ello&#39;]() &#123;
    return &#39;hi&#39;;
  &#125;
&#125;;

obj.hello() // hi
</code></pre>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错</p>
<pre><code class="javascript">// 报错
const foo = &#39;bar&#39;;
const bar = &#39;abc&#39;;
const baz = &#123; [foo] &#125;;

// 正确
const foo = &#39;bar&#39;;
const baz = &#123; [foo]: &#39;abc&#39;&#125;;
</code></pre>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code></p>
<pre><code class="javascript">const keyA = &#123;a: 1&#125;;
const keyB = &#123;b: 2&#125;;

const myObject = &#123;
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
&#125;;

myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;
</code></pre>
<h4 id="三、super关键字"><a href="#三、super关键字" class="headerlink" title="三、super关键字"></a>三、super关键字</h4><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象</p>
<pre><code class="javascript">const proto = &#123;
  foo: &#39;hello&#39;
&#125;;

const obj = &#123;
  foo: &#39;world&#39;,
  find() &#123;
    return super.foo;
  &#125;
&#125;;

Object.setPrototypeOf(obj, proto); // 为obj设置原型对象
obj.find() // &quot;hello&quot;
</code></pre>
<h4 id="四、扩展运算符的应用"><a href="#四、扩展运算符的应用" class="headerlink" title="四、扩展运算符的应用"></a>四、扩展运算符的应用</h4><p>在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面</p>
<pre><code class="javascript">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;
x // 1
y // 2
z // &#123; a: 3, b: 4 &#125;
</code></pre>
<p>注意：解构赋值必须是最后一个参数，否则会报错</p>
<p>解构赋值是浅拷贝</p>
<pre><code class="javascript">let obj = &#123; a: &#123; b: 1 &#125; &#125;;
let &#123; ...x &#125; = obj;
obj.a.b = 2; // 修改obj里面a属性中键值
x.a.b // 2，影响到了结构出来x的值
</code></pre>
<p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法</p>
<h4 id="五、属性的遍历"><a href="#五、属性的遍历" class="headerlink" title="五、属性的遍历"></a>五、属性的遍历</h4><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<ul>
<li>for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li>
<li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li>
<li>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li>
<li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</li>
<li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li>
</ul>
<p>上述遍历，都遵守同样的属性遍历的次序规则：</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排</li>
</ul>
<pre><code class="javascript">Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)
// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]
</code></pre>
<h4 id="六、对象新增的方法"><a href="#六、对象新增的方法" class="headerlink" title="六、对象新增的方法"></a>六、对象新增的方法</h4><p>关于对象新增的方法，分别有以下：</p>
<ul>
<li>Object.is()</li>
<li>Object.assign()</li>
<li>Object.getOwnPropertyDescriptors()</li>
<li>Object.setPrototypeOf()，Object.getPrototypeOf()</li>
<li>Object.keys()，Object.values()，Object.entries()</li>
<li>Object.fromEntries()</li>
</ul>
<h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><p>严格判断两个值是否相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致，不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</p>
<pre><code class="javascript">+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><pre><code class="javascript">Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target
</code></pre>
<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象</p>
<pre><code class="javascript">const target = &#123; a: 1, b: 1 &#125;;

const source1 = &#123; b: 2, c: 2 &#125;;
const source2 = &#123; c: 3 &#125;;

Object.assign(target, source1, source2);
target // &#123;a:1, b:2, c:3&#125;
</code></pre>
<p>注意：<code>Object.assign()</code>方法是浅拷贝，遇到同名属性会进行替换</p>
<h5 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h5><p>返回指定对象所有自身属性（非继承属性）的描述对象</p>
<pre><code class="javascript">const obj = &#123;
  foo: 123,
  get bar() &#123; return &#39;abc&#39; &#125;
&#125;;

Object.getOwnPropertyDescriptors(obj)
// &#123; foo:
//    &#123; value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true &#125;,
//   bar:
//    &#123; get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true &#125; &#125;
</code></pre>
<h5 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h5><p><code>Object.setPrototypeOf</code>方法用来设置一个对象的原型对象</p>
<pre><code class="javascript">Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf(&#123;&#125;, null);
</code></pre>
<h5 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h5><p>用于读取一个对象的原型对象</p>
<pre><code class="javascript">Object.getPrototypeOf(obj);
</code></pre>
<h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组</p>
<pre><code class="javascript">var obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre>
<h5 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h5><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组</p>
<pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.values(obj)
// [&quot;bar&quot;, 42]
</code></pre>
<h5 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h5><p>返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组</p>
<pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
</code></pre>
<h5 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h5><p>用于将一个键值对数组转为对象</p>
<pre><code class="javascript">Object.fromEntries([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
])
// &#123; foo: &quot;bar&quot;, baz: 42 &#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中函数新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中函数新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中函数新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中函数新增了哪些扩展?</h3><h4 id="一、参数"><a href="#一、参数" class="headerlink" title="一、参数"></a>一、参数</h4><p><code>ES6</code>允许为函数的参数设置默认值</p>
<pre><code class="javascript">function log(x, y = &#39;World&#39;) &#123;
  console.log(x, y);
&#125;

console.log(&#39;Hello&#39;) // Hello World
console.log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
console.log(&#39;Hello&#39;, &#39;&#39;) // Hello
</code></pre>
<p>函数的形参是默认声明的，不能使用<code>let</code>或<code>const</code>再次声明</p>
<pre><code class="javascript">function foo(x = 5) &#123;
    let x = 1; // error
    const x = 2; // error
&#125;
</code></pre>
<p>参数默认值可以与解构赋值的默认值结合起来使用</p>
<pre><code class="javascript">function foo(&#123;x, y = 5&#125;) &#123;
  console.log(x, y);
&#125;

foo(&#123;&#125;) // undefined 5
foo(&#123;x: 1&#125;) // 1 5
foo(&#123;x: 1, y: 2&#125;) // 1 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined
</code></pre>
<p>上面的<code>foo</code>函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量<code>x</code>和<code>y</code>就不会生成，从而报错，这里设置默认值避免</p>
<pre><code class="javascript">function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;
  console.log(x, y);
&#125;

foo() // undefined 5
</code></pre>
<p>参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的</p>
<pre><code class="javascript">function f(x = 1, y) &#123;
  return [x, y];
&#125;

f() // [1, undefined]
f(2) // [2, undefined]
f(, 1) // 报错
f(undefined, 1) // [1, 1]
</code></pre>
<h4 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h4><h5 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h5><p><code>length</code>将返回没有指定默认值的参数个数</p>
<pre><code class="javascript">(function (a) &#123;&#125;).length // 1
(function (a = 5) &#123;&#125;).length // 0
(function (a, b, c = 5) &#123;&#125;).length // 2
</code></pre>
<p><code>rest</code> 参数也不会计入<code>length</code>属性</p>
<pre><code class="javascript">(function(...args) &#123;&#125;).length // 0
</code></pre>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</p>
<pre><code class="javascript">(function (a = 0, b, c) &#123;&#125;).length // 0
(function (a, b = 1, c) &#123;&#125;).length // 1
</code></pre>
<h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><p>返回该函数的函数名</p>
<pre><code class="javascript">var f = function () &#123;&#125;;

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;
</code></pre>
<p>如果将一个具名函数赋值给一个变量，则 <code>name</code>属性都返回这个具名函数原本的名字</p>
<pre><code class="javascript">const bar = function baz() &#123;&#125;;
bar.name // &quot;baz&quot;
Function`构造函数返回的函数实例，`name`属性的值为`anonymous
(new Function).name // &quot;anonymous&quot;
</code></pre>
<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀</p>
<pre><code class="javascript">function foo() &#123;&#125;;
foo.bind(&#123;&#125;).name // &quot;bound foo&quot;

(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;
</code></pre>
<h4 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</p>
<p>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p>
<p>下面例子中，<code>y=x</code>会形成一个单独作用域，<code>x</code>没有被定义，所以指向全局变量<code>x</code></p>
<pre><code class="javascript">let x = 1;

function f(y = x) &#123; 
  // 等同于 let y = x  
  let x = 2; 
  console.log(y);
&#125;

f() // 1
</code></pre>
<h4 id="四、严格模式"><a href="#四、严格模式" class="headerlink" title="四、严格模式"></a>四、严格模式</h4><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p>
<pre><code class="javascript">// 报错
function doSomething(a, b = a) &#123;
  &#39;use strict&#39;;
  // code
&#125;

// 报错
const doSomething = function (&#123;a, b&#125;) &#123;
  &#39;use strict&#39;;
  // code
&#125;;

// 报错
const doSomething = (...a) =&gt; &#123;
  &#39;use strict&#39;;
  // code
&#125;;

const obj = &#123;
  // 报错
  doSomething(&#123;a, b&#125;) &#123;
    &#39;use strict&#39;;
    // code
  &#125;
&#125;;
</code></pre>
<h4 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h4><p>使用“箭头”（<code>=&gt;</code>）定义函数</p>
<pre><code class="javascript">var f = v =&gt; v;

// 等同于
var f = function (v) &#123;
  return v;
&#125;;
</code></pre>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</p>
<pre><code class="javascript">var f = () =&gt; 5;
// 等同于
var f = function () &#123; return 5 &#125;;

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) &#123;
  return num1 + num2;
&#125;;
</code></pre>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回</p>
<pre><code class="javascript">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;
</code></pre>
<p>如果返回对象，需要加括号将对象包裹</p>
<pre><code class="javascript">let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);
</code></pre>
<p>注意点：</p>
<ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中新增的Set、Map两种数据结构怎么理解"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中新增的Set、Map两种数据结构怎么理解" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中新增的Set、Map两种数据结构怎么理解?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中新增的Set、Map两种数据结构怎么理解?</h3><p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p>
<p>什么是集合？什么又是字典？</p>
<ul>
<li>集合<br>是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</li>
<li>字典<br>是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</li>
</ul>
<p>区别？</p>
<ul>
<li>共同点：集合、字典都可以存储不重复的值</li>
<li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li>
</ul>
<h4 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h4><p><code>Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</p>
<pre><code>const s = new Set();
</code></pre>
<h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><p><code>Set</code>的实例关于增删改查的方法：</p>
<ul>
<li>add()</li>
<li>delete()</li>
<li>has()</li>
<li>clear()</li>
</ul>
<h6 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h6><p>添加某个值，返回 <code>Set</code> 结构本身</p>
<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>
<pre><code>s.add(1).add(2).add(2); // 2只被添加了一次
</code></pre>
<h6 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h6><p>删除某个值，返回一个布尔值，表示删除是否成功</p>
<pre><code>s.delete(1)
</code></pre>
<h6 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h6><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>
<pre><code>s.has(2)
</code></pre>
<h6 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h6><p>清除所有成员，没有返回值</p>
<pre><code>s.clear()
</code></pre>
<h6 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h6><p><code>Set</code>实例遍历的方法有如下：</p>
<p>关于遍历的方法，有如下：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<p><code>Set</code>的遍历顺序就是插入顺序</p>
<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象</p>
<pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

for (let item of set.keys()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.values()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.entries()) &#123;
  console.log(item);
&#125;
// [&quot;red&quot;, &quot;red&quot;]
// [&quot;green&quot;, &quot;green&quot;]
// [&quot;blue&quot;, &quot;blue&quot;]
forEach()`用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的`forEach`方法有第二个参数，用于绑定处理函数的`this
let set = new Set([1, 4, 9]);
set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
// 1 : 1
// 4 : 4
// 9 : 9
</code></pre>
<p>扩展运算符和<code> Set</code> 结构相结合实现数组或字符串去重</p>
<pre><code class="javascript">// 数组
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)]; // [3, 5, 2]

// 字符串
let str = &quot;352255&quot;;
let unique = [...new Set(str)].join(&quot;&quot;); // &#39;352&#39;
</code></pre>
<p>实现并集、交集、和差集</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<h4 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h4><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>
<p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p>
<pre><code class="javascript">const m = new Map()
</code></pre>
<h5 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h5><p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p>
<ul>
<li>size 属性</li>
<li>set()</li>
<li>get()</li>
<li>has()</li>
<li>delete()</li>
<li>clear()</li>
</ul>
<h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><p><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="javascript">const map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
</code></pre>
<h6 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h6><p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p>
<p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p>
<p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p>
<pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6)        // 键是字符串
m.set(262, &#39;standard&#39;)     // 键是数值
m.set(undefined, &#39;nah&#39;)    // 键是 undefined
m.set(1, &#39;a&#39;).set(2, &#39;b&#39;).set(3, &#39;c&#39;) // 链式操作
</code></pre>
<h6 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h6><pre><code class="javascript">get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined
const m = new Map();

const hello = function() &#123;console.log(&#39;hello&#39;);&#125;;
m.set(hello, &#39;Hello ES6!&#39;) // 键是函数

m.get(hello)  // Hello ES6!
</code></pre>
<h6 id="has-1"><a href="#has-1" class="headerlink" title="has()"></a>has()</h6><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p>
<pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6);
m.set(262, &#39;standard&#39;);
m.set(undefined, &#39;nah&#39;);

m.has(&#39;edition&#39;)     // true
m.has(&#39;years&#39;)       // false
m.has(262)           // true
m.has(undefined)     // true
</code></pre>
<h6 id="delete-1"><a href="#delete-1" class="headerlink" title="delete()"></a>delete()</h6><pre><code class="javascript">delete`方法删除某个键，返回`true`。如果删除失败，返回`false
const m = new Map();
m.set(undefined, &#39;nah&#39;);
m.has(undefined)     // true

m.delete(undefined)
m.has(undefined)       // false
</code></pre>
<h6 id="clear-1"><a href="#clear-1" class="headerlink" title="clear()"></a>clear()</h6><p><code>clear</code>方法清除所有成员，没有返回值</p>
<pre><code class="javascript">let map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
map.clear()
map.size // 0
</code></pre>
<h6 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h6><p><code>Map </code>结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回所有成员的遍历器</li>
<li>forEach()：遍历 Map 的所有成员</li>
</ul>
<p>遍历顺序就是插入顺序</p>
<pre><code class="javascript">const map = new Map([
  [&#39;F&#39;, &#39;no&#39;],
  [&#39;T&#39;,  &#39;yes&#39;],
]);

for (let key of map.keys()) &#123;
  console.log(key);
&#125;
// &quot;F&quot;
// &quot;T&quot;

for (let value of map.values()) &#123;
  console.log(value);
&#125;
// &quot;no&quot;
// &quot;yes&quot;

for (let item of map.entries()) &#123;
  console.log(item[0], item[1]);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 或者
for (let [key, value] of map.entries()) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 等同于使用map.entries()
for (let [key, value] of map) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

map.forEach(function(value, key, map) &#123;
  console.log(&quot;Key: %s, Value: %s&quot;, key, value);
&#125;);
</code></pre>
<h4 id="三、WeakSet-和-WeakMap"><a href="#三、WeakSet-和-WeakMap" class="headerlink" title="三、WeakSet 和 WeakMap"></a>三、WeakSet 和 WeakMap</h4><h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>创建<code>WeakSet</code>实例</p>
<pre><code class="javascript">const ws = new WeakSet();
</code></pre>
<p><code>WeakSet </code>可以接受一个具有 <code>Iterable </code>接口的对象作为参数</p>
<pre><code class="javascript">const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet &#123;[1, 2], [3, 4]&#125;
</code></pre>
<p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>size</code>属性</li>
</ul>
<p><code>WeackSet</code>只能成员只能是引用类型，而不能是其他类型的值</p>
<pre><code class="javascript">let ws=new WeakSet();

// 成员不是引用类型
let weakSet=new WeakSet([2,3]);
console.log(weakSet) // 报错

// 成员为引用类型
let obj1=&#123;name:1&#125;
let obj2=&#123;name:1&#125;
let ws=new WeakSet([obj1,obj2]); 
console.log(ws) //WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125;
</code></pre>
<p><code>WeakSet </code>里面的引用只要在外部消失，它在 <code>WeakSet </code>里面的引用就会自动消失</p>
<h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p>
<p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>clear</code>清空方法</li>
</ul>
<pre><code class="javascript">// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = &#123;foo: 1&#125;;
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]);
wm2.get(k2) // &quot;bar&quot;
</code></pre>
<p><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p>
<pre><code class="javascript">const map = new WeakMap();
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
</code></pre>
<p><code>WeakMap</code>的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p>
<p>举个场景例子：</p>
<p>在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构，当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除</p>
<pre><code class="javascript">const wm = new WeakMap();
const element = document.getElementById(&#39;example&#39;);
wm.set(element, &#39;some information&#39;);
wm.get(element) // &quot;some information&quot;
</code></pre>
<p>注意：<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用</p>
<p>下面代码中，键值<code>obj</code>会在<code>WeakMap</code>产生新的引用，当你修改<code>obj</code>不会影响到内部</p>
<pre><code class="javascript">const wm = new WeakMap();
let key = &#123;&#125;;
let obj = &#123;foo: 1&#125;;

wm.set(key, obj);
obj = null;
wm.get(key)
// Object &#123;foo: 1&#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-你是怎么理解ES6中-Promise的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-你是怎么理解ES6中-Promise的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 你是怎么理解ES6中 Promise的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 你是怎么理解ES6中 Promise的？使用场景？</h3><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p><code>Promise </code>，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p>
<p>在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码</p>
<pre><code class="javascript">doSomething(function(result) &#123;
  doSomethingElse(result, function(newResult) &#123;
    doThirdThing(newResult, function(finalResult) &#123;
      console.log(&#39;得到最终结果: &#39; + finalResult);
    &#125;, failureCallback);
  &#125;, failureCallback);
&#125;, failureCallback);
</code></pre>
<p>阅读上面代码，是不是很难受，上述形成了经典的回调地狱</p>
<p>现在通过<code>Promise</code>的改写上面的代码</p>
<pre><code class="javascript">doSomething().then(function(result) &#123;
  return doSomethingElse(result);
&#125;)
.then(function(newResult) &#123;
  return doThirdThing(newResult);
&#125;)
.then(function(finalResult) &#123;
  console.log(&#39;得到最终结果: &#39; + finalResult);
&#125;)
.catch(failureCallback);
</code></pre>
<p>瞬间感受到<code>promise</code>解决异步操作的优点：</p>
<ul>
<li>链式操作减低了编码难度</li>
<li>代码可读性明显增强</li>
</ul>
<p>下面我们正式来认识<code>promise</code>：</p>
<h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p><code>promise</code>对象仅有三种状态</p>
<ul>
<li><code>pending</code>（进行中）</li>
<li><code>fulfilled</code>（已成功）</li>
<li><code>rejected</code>（已失败）</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li>
<li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li>
</ul>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>认真阅读下图，我们能够轻松了解<code>promise</code>整个流程</p>
<p><img src="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31623032616539302d353861392d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例</p>
<pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;&#125;);
Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject
</code></pre>
<ul>
<li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li>
<li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”</li>
</ul>
<h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><p><code>Promise</code>构建出来的实例存在以下方法：</p>
<ul>
<li>then()</li>
<li>catch()</li>
<li>finally()</li>
</ul>
<h6 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h6><p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因</p>
<pre><code class="javascript">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  return json.post;
&#125;).then(function(post) &#123;
  // ...
&#125;);
</code></pre>
<h6 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h6><p><code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</p>
<pre><code class="javascript">getJSON(&#39;/posts.json&#39;).then(function(posts) &#123;
  // ...
&#125;).catch(function(error) &#123;
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&#39;发生错误！&#39;, error);
&#125;);
</code></pre>
<p><code>Promise </code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p>
<pre><code class="javascript">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;
  return getJSON(post.commentURL);
&#125;).then(function(comments) &#123;
  // some code
&#125;).catch(function(error) &#123;
  // 处理前面三个Promise产生的错误
&#125;);
</code></pre>
<p>一般来说，使用<code>catch</code>方法代替<code>then()</code>第二个参数</p>
<p><code>Promise </code>对象抛出的错误不会传递到外层代码，即不会有任何反应</p>
<pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;
</code></pre>
<p>浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程</p>
<p><code>catch()</code>方法之中，还能再抛出错误，通过后面<code>catch</code>方法捕获到</p>
<h6 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h6><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p>
<pre><code class="javascript">promise
.then(result =&gt; &#123;···&#125;)
.catch(error =&gt; &#123;···&#125;)
.finally(() =&gt; &#123;···&#125;);
</code></pre>
<h5 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h5><p><code>Promise</code>构造函数存在以下方法：</p>
<ul>
<li>all()</li>
<li>race()</li>
<li>allSettled()</li>
<li>resolve()</li>
<li>reject()</li>
<li>try()</li>
</ul>
<h6 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h6><p><code>Promise.all()</code>方法用于将多个 <code>Promise </code>实例，包装成一个新的 <code>Promise </code>实例</p>
<pre><code class="javascript">const p = Promise.all([p1, p2, p3]);
</code></pre>
<p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p>
<p>实例<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分为两种：</p>
<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li>
</ul>
<p>注意，如果作为参数的 <code>Promise</code> 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// Error: 报错了
</code></pre>
<h6 id="race"><a href="#race" class="headerlink" title="race()"></a>race()</h6><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p>
<pre><code class="javascript">const p = Promise.race([p1, p2, p3]);
</code></pre>
<p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变</p>
<p>率先改变的 Promise 实例的返回值则传递给<code>p</code>的回调函数</p>
<pre><code class="javascript">const p = Promise.race([
  fetch(&#39;/resource-that-may-take-a-while&#39;),
  new Promise(function (resolve, reject) &#123;
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)
  &#125;)
]);

p
.then(console.log)
.catch(console.error);
</code></pre>
<h6 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled()"></a>allSettled()</h6><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p>
<p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束</p>
<pre><code class="javascript">const promises = [
  fetch(&#39;/api-1&#39;),
  fetch(&#39;/api-2&#39;),
  fetch(&#39;/api-3&#39;),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
</code></pre>
<h6 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a>resolve()</h6><p>将现有对象转为 <code>Promise </code>对象</p>
<pre><code class="javascript">Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))
</code></pre>
<p>参数可以分成四种情况，分别如下：</p>
<ul>
<li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li>
<li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise </code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li>
<li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li>
<li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li>
</ul>
<h6 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h6><pre><code class="javascript">Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected
const p = Promise.reject(&#39;出错了&#39;);
// 等同于
const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))

p.then(null, function (s) &#123;
  console.log(s)
&#125;);
// 出错了
</code></pre>
<p><code>Promise.reject()</code>方法的参数，会原封不动地变成后续方法的参数</p>
<pre><code class="javascript">Promise.reject(&#39;出错了&#39;)
.catch(e =&gt; &#123;
  console.log(e === &#39;出错了&#39;)
&#125;)
// true
</code></pre>
<h4 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化</p>
<pre><code class="javascript">const preloadImage = function (path) &#123;
  return new Promise(function (resolve, reject) &#123;
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  &#125;);
&#125;;
</code></pre>
<p>通过链式操作，将多个渲染数据分别给个<code>then</code>，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题</p>
<pre><code class="javascript">// 各司其职
getInfo().then(res=&gt;&#123;
    let &#123; bannerList &#125; = res
    //渲染轮播图
    console.log(bannerList)
    return res
&#125;).then(res=&gt;&#123;
    
    let &#123; storeList &#125; = res
    //渲染店铺列表
    console.log(storeList)
    return res
&#125;).then(res=&gt;&#123;
    let &#123; categoryList &#125; = res
    console.log(categoryList)
    //渲染分类列表
    return res
&#125;)
</code></pre>
<p>通过<code>all()</code>实现多个请求合并在一起，汇总所有请求结果，只需设置一个<code>loading</code>即可</p>
<pre><code class="javascript">function initLoad()&#123;
    // loading.show() //加载loading
    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=&gt;&#123;
        console.log(res)
        loading.hide() //关闭loading
    &#125;).catch(err=&gt;&#123;
        console.log(err)
        loading.hide()//关闭loading
    &#125;)
&#125;
//数据初始化    
initLoad()
</code></pre>
<p>通过<code>race</code>可以设置图片请求超时</p>
<pre><code class="javascript">//请求某个图片资源
function requestImg()&#123;
    var p = new Promise(function(resolve, reject)&#123;
        var img = new Image();
        img.onload = function()&#123;
           resolve(img);
        &#125;
        //img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的
        img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;;
    &#125;);
    return p;
&#125;

//延时函数，用于给请求计时
function timeout()&#123;
    var p = new Promise(function(resolve, reject)&#123;
        setTimeout(function()&#123;
            reject(&#39;图片请求超时&#39;);
        &#125;, 5000);
    &#125;);
    return p;
&#125;

Promise
.race([requestImg(), timeout()])
.then(function(results)&#123;
    console.log(results);
&#125;)
.catch(function(reason)&#123;
    console.log(reason);
&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Generator的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Generator的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Generator的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Generator的？使用场景？</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p>回顾下上文提到的解决异步的手段：</p>
<ul>
<li>回调函数</li>
<li>promise</li>
</ul>
<p>那么，上文我们提到<code>promsie</code>已经是一种比较流行的解决异步方案，那么为什么还出现<code>Generator</code>？甚至<code>async/await</code>呢？</p>
<p>该问题我们留在后面再进行分析，下面先认识下<code>Generator</code></p>
<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>执行 <code>Generator</code> 函数会返回一个遍历器对象，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p>
<p>形式上，<code>Generator </code>函数是一个普通函数，但是有两个特征：</p>
<ul>
<li><code>function</code>关键字与函数名之间有一个星号</li>
<li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态</li>
</ul>
<pre><code class="javascript">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
</code></pre>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p><code>Generator</code> 函数会返回一个遍历器对象，即具有<code>Symbol.iterator</code>属性，并且返回给自己</p>
<pre><code class="javascript">function* gen()&#123;
  // some code
&#125;

var g = gen();

g[Symbol.iterator]() === g
// true
</code></pre>
<p>通过<code>yield</code>关键字可以暂停<code>generator</code>函数返回的遍历器对象的状态</p>
<pre><code class="javascript">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
var hw = helloWorldGenerator();
</code></pre>
<p>上述存在三个状态：<code>hello</code>、<code>world</code>、<code>return</code></p>
<p>通过<code>next</code>方法才会遍历到下一个内部状态，其运行逻辑如下：</p>
<ul>
<li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</li>
<li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li>
</ul>
<pre><code class="javascript">hw.next()
// &#123; value: &#39;hello&#39;, done: false &#125;

hw.next()
// &#123; value: &#39;world&#39;, done: false &#125;

hw.next()
// &#123; value: &#39;ending&#39;, done: true &#125;

hw.next()
// &#123; value: undefined, done: true &#125;
</code></pre>
<p><code>done</code>用来判断是否存在下个状态，<code>value</code>对应状态值</p>
<pre><code class="javascript">yield`表达式本身没有返回值，或者说总是返回`undefined
</code></pre>
<p>通过调用<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值</p>
<pre><code class="javascript">function* foo(x) &#123;
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
&#125;

var a = foo(5);
a.next() // Object&#123;value:6, done:false&#125;
a.next() // Object&#123;value:NaN, done:false&#125;
a.next() // Object&#123;value:NaN, done:true&#125;

var b = foo(5);
b.next() // &#123; value:6, done:false &#125;
b.next(12) // &#123; value:8, done:false &#125;
b.next(13) // &#123; value:42, done:true &#125;
</code></pre>
<p>正因为<code>Generator </code>函数返回<code>Iterator</code>对象，因此我们还可以通过<code>for...of</code>进行遍历</p>
<pre><code class="javascript">function* foo() &#123;
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
&#125;

for (let v of foo()) &#123;
  console.log(v);
&#125;
// 1 2 3 4 5
</code></pre>
<p>原生对象没有遍历接口，通过<code>Generator </code>函数为它加上这个接口，就能使用<code>for...of</code>进行遍历了</p>
<pre><code class="javascript">function* objectEntries(obj) &#123;
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) &#123;
    yield [propKey, obj[propKey]];
  &#125;
&#125;

let jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;

for (let [key, value] of objectEntries(jane)) &#123;
  console.log(`$&#123;key&#125;: $&#123;value&#125;`);
&#125;
// first: Jane
// last: Doe
</code></pre>
<h4 id="三、异步解决方案"><a href="#三、异步解决方案" class="headerlink" title="三、异步解决方案"></a>三、异步解决方案</h4><p>回顾之前展开异步解决的方案：</p>
<ul>
<li>回调函数</li>
<li>Promise 对象</li>
<li>generator 函数</li>
<li>async&#x2F;await</li>
</ul>
<p>这里通过文件读取案例，将几种解决异步的方案进行一个比较：</p>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数</p>
<pre><code class="javascript">fs.readFile(&#39;/etc/fstab&#39;, function (err, data) &#123;
  if (err) throw err;
  console.log(data);
  fs.readFile(&#39;/etc/shells&#39;, function (err, data) &#123;
    if (err) throw err;
    console.log(data);
  &#125;);
&#125;);
</code></pre>
<p><code>readFile</code>函数的第三个参数，就是回调函数，等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行</p>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p><code>Promise</code>就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;);

const readFile = function (fileName) &#123;
  return new Promise(function (resolve, reject) &#123;
    fs.readFile(fileName, function(error, data) &#123;
      if (error) return reject(error);
      resolve(data);
    &#125;);
  &#125;);
&#125;;


readFile(&#39;/etc/fstab&#39;).then(data =&gt;&#123;
    console.log(data)
    return readFile(&#39;/etc/shells&#39;)
&#125;).then(data =&gt; &#123;
    console.log(data)
&#125;)
</code></pre>
<p>这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强</p>
<h5 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h5><p><code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化</p>
<pre><code class="javascript">const gen = function* () &#123;
  const f1 = yield readFile(&#39;/etc/fstab&#39;);
  const f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<h5 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h5><p>将上面<code>Generator</code>函数改成<code>async/await</code>形式，更为简洁，语义化更强了</p>
<pre><code class="javascript">const asyncReadFile = async function () &#123;
  const f1 = await readFile(&#39;/etc/fstab&#39;);
  const f2 = await readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><p>通过上述代码进行分析，将<code>promise</code>、<code>Generator</code>、<code>async/await</code>进行比较：</p>
<ul>
<li><code>promise</code>和<code>async/await</code>是专门用于处理异步操作的</li>
<li><code>Generator</code>并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署<code>Interator</code>接口…）</li>
<li><code>promise</code>编写代码相比<code>Generator</code>、<code>async</code>更为复杂化，且可读性也稍差</li>
<li><code>Generator</code>、<code>async</code>需要与<code>promise</code>对象搭配处理异步情况</li>
<li><code>async</code>实质是<code>Generator</code>的语法糖，相当于会自动执行<code>Generator</code>函数</li>
<li><code>async</code>使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案</li>
</ul>
<h4 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h4><p><code>Generator</code>是异步解决的一种方案，最大特点则是将异步操作同步化表达出来</p>
<pre><code class="javascript">function* loadUI() &#123;
  showLoadingScreen();
  yield loadUIDataAsynchronously();
  hideLoadingScreen();
&#125;
var loader = loadUI();
// 加载UI
loader.next()

// 卸载UI
loader.next()
</code></pre>
<p>包括<code>redux-saga </code>中间件也充分利用了<code>Generator</code>特性</p>
<pre><code class="javascript">import &#123; call, put, takeEvery, takeLatest &#125; from &#39;redux-saga/effects&#39;
import Api from &#39;...&#39;

function* fetchUser(action) &#123;
   try &#123;
      const user = yield call(Api.fetchUser, action.payload.userId);
      yield put(&#123;type: &quot;USER_FETCH_SUCCEEDED&quot;, user: user&#125;);
   &#125; catch (e) &#123;
      yield put(&#123;type: &quot;USER_FETCH_FAILED&quot;, message: e.message&#125;);
   &#125;
&#125;

function* mySaga() &#123;
  yield takeEvery(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);
&#125;

function* mySaga() &#123;
  yield takeLatest(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);
&#125;

export default mySaga;
</code></pre>
<p>还能利用<code>Generator</code>函数，在对象上实现<code>Iterator</code>接口</p>
<pre><code class="javascript">function* iterEntries(obj) &#123;
  let keys = Object.keys(obj);
  for (let i=0; i &lt; keys.length; i++) &#123;
    let key = keys[i];
    yield [key, obj[key]];
  &#125;
&#125;

let myObj = &#123; foo: 3, bar: 7 &#125;;

for (let [key, value] of iterEntries(myObj)) &#123;
  console.log(key, value);
&#125;

// foo 3
// bar 7
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Proxy的？使用场景"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Proxy的？使用场景" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Proxy的？使用场景?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Proxy的？使用场景?</h3><p>定义： 用于定义基本操作的自定义行为</p>
<p>本质： 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程<code>(meta programming)</code></p>
<p>元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作</p>
<p>一段代码来理解</p>
<pre><code class="c">#!/bin/bash
# metaprogram
echo &#39;#!/bin/bash&#39; &gt;program
for ((I=1; I&lt;=1024; I++)) do
    echo &quot;echo $I&quot; &gt;&gt;program
done
chmod +x program
</code></pre>
<p>这段程序每执行一次能帮我们生成一个名为<code>program</code>的文件，文件内容为1024行<code>echo</code>，如果我们手动来写1024行代码，效率显然低效</p>
<ul>
<li>元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译</li>
</ul>
<p><code>Proxy</code> 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）</p>
<h4 id="二、用法-1"><a href="#二、用法-1" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Proxy</code>为 构造函数，用来生成 <code>Proxy </code>实例</p>
<pre><code class="javascript">var proxy = new Proxy(target, handler)
</code></pre>
<p>参数</p>
<p><code>target</code>表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））</p>
<p><code>handler</code>通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为</p>
<p>handler解析</p>
<p>关于<code>handler</code>拦截属性，有如下：</p>
<ul>
<li>get(target,propKey,receiver)：拦截对象属性的读取</li>
<li>set(target,propKey,value,receiver)：拦截对象属性的设置</li>
<li>has(target,propKey)：拦截<code>propKey in proxy</code>的操作，返回一个布尔值</li>
<li>deleteProperty(target,propKey)：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值</li>
<li>ownKeys(target)：拦截<code>Object.keys(proxy)</code>、<code>for...in</code>等循环，返回一个数组</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象</li>
<li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>，返回一个布尔值</li>
<li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值</li>
<li>getPrototypeOf(target)：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象</li>
<li>isExtensible(target)：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值</li>
<li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作</li>
</ul>
<p>Reflect</p>
<p>若需要在<code>Proxy</code>内部调用对象的默认行为，建议使用<code>Reflect</code>，其是<code>ES6</code>中操作对象而提供的新 <code>API</code></p>
<p>基本特点：</p>
<ul>
<li>只要<code>Proxy</code>对象具有的代理方法，<code>Reflect</code>对象全部具有，以静态方法的形式存在</li>
<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回<code>false</code>）</li>
<li>让<code>Object</code>操作都变成函数行为</li>
</ul>
<p>下面我们介绍<code>proxy</code>几种用法：</p>
<h5 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h5><p><code>get</code>接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身，最后一个参数可选</p>
<pre><code class="javascript">var person = &#123;
  name: &quot;张三&quot;
&#125;;

var proxy = new Proxy(person, &#123;
  get: function(target, propKey) &#123;
    return Reflect.get(target,propKey)
  &#125;
&#125;);

proxy.name // &quot;张三&quot;
</code></pre>
<p><code>get</code>能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引</p>
<pre><code class="javascript">function createArray(...elements) &#123;
  let handler = &#123;
    get(target, propKey, receiver) &#123;
      let index = Number(propKey);
      if (index &lt; 0) &#123;
        propKey = String(target.length + index);
      &#125;
      return Reflect.get(target, propKey, receiver);
    &#125;
  &#125;;

  let target = [];
  target.push(...elements);
  return new Proxy(target, handler);
&#125;

let arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
arr[-1] // c
</code></pre>
<p>注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错</p>
<pre><code class="javascript">const target = Object.defineProperties(&#123;&#125;, &#123;
  foo: &#123;
    value: 123,
    writable: false,
    configurable: false
  &#125;,
&#125;);

const handler = &#123;
  get(target, propKey) &#123;
    return &#39;abc&#39;;
  &#125;
&#125;;

const proxy = new Proxy(target, handler);

proxy.foo
// TypeError: Invariant check failed
</code></pre>
<h5 id="set-1"><a href="#set-1" class="headerlink" title="set()"></a>set()</h5><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 <code>Proxy</code> 实例本身</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求</p>
<pre><code class="javascript">let validator = &#123;
  set: function(obj, prop, value) &#123;
    if (prop === &#39;age&#39;) &#123;
      if (!Number.isInteger(value)) &#123;
        throw new TypeError(&#39;The age is not an integer&#39;);
      &#125;
      if (value &gt; 200) &#123;
        throw new RangeError(&#39;The age seems invalid&#39;);
      &#125;
    &#125;

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  &#125;
&#125;;

let person = new Proxy(&#123;&#125;, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错
</code></pre>
<p>如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用</p>
<pre><code class="javascript">const obj = &#123;&#125;;
Object.defineProperty(obj, &#39;foo&#39;, &#123;
  value: &#39;bar&#39;,
  writable: false,
&#125;);

const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = &#39;baz&#39;;
  &#125;
&#125;;

const proxy = new Proxy(obj, handler);
proxy.foo = &#39;baz&#39;;
proxy.foo // &quot;bar&quot;
</code></pre>
<p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错</p>
<pre><code class="javascript">&#39;use strict&#39;;
const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;
</code></pre>
<h5 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h5><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除</p>
<pre><code class="javascript">var handler = &#123;
  deleteProperty (target, key) &#123;
    invariant(key, &#39;delete&#39;);
    Reflect.deleteProperty(target,key)
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`无法删除私有属性`);
  &#125;
&#125;

var target = &#123; _prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: 无法删除私有属性
</code></pre>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错</p>
<h5 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h5><pre><code class="javascript">Proxy.revocable(target, handler);
</code></pre>
<h4 id="三、使用场景-1"><a href="#三、使用场景-1" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p><code>Proxy</code>其功能非常类似于设计模式中的代理模式，常用功能如下：</p>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<p>使用 <code>Proxy</code> 保障数据类型的准确性</p>
<pre><code class="javascript">let numericDataStore = &#123; count: 0, amount: 1234, total: 14 &#125;;
numericDataStore = new Proxy(numericDataStore, &#123;
    set(target, key, value, proxy) &#123;
        if (typeof value !== &#39;number&#39;) &#123;
            throw Error(&quot;属性只能是number类型&quot;);
        &#125;
        return Reflect.set(target, key, value, proxy);
    &#125;
&#125;);

numericDataStore.count = &quot;foo&quot;
// Error: 属性只能是number类型

numericDataStore.count = 333
// 赋值成功
</code></pre>
<p>声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></p>
<pre><code class="javascript">let api = &#123;
    _apiKey: &#39;123abc456def&#39;,
    getUsers: function()&#123; &#125;,
    getUser: function(userId)&#123; &#125;,
    setUser: function(userId, config)&#123; &#125;
&#125;;
const RESTRICTED = [&#39;_apiKey&#39;];
api = new Proxy(api, &#123;
    get(target, key, proxy) &#123;
        if(RESTRICTED.indexOf(key) &gt; -1) &#123;
            throw Error(`$&#123;key&#125; 不可访问.`);
        &#125; return Reflect.get(target, key, proxy);
    &#125;,
    set(target, key, value, proxy) &#123;
        if(RESTRICTED.indexOf(key) &gt; -1) &#123;
            throw Error(`$&#123;key&#125; 不可修改`);
        &#125; return Reflect.get(target, key, value, proxy);
    &#125;
&#125;);

console.log(api._apiKey)
api._apiKey = &#39;987654321&#39;
// 上述都抛出错误
</code></pre>
<p>还能通过使用<code>Proxy</code>实现观察者模式</p>
<p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行</p>
<p><code>observable</code>函数返回一个原始对象的 <code>Proxy</code> 代理，拦截赋值操作，触发充当观察者的各个函数</p>
<pre><code class="javascript">const queuedObservers = new Set();

const observe = fn =&gt; queuedObservers.add(fn);
const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);

function set(target, key, value, receiver) &#123;
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer =&gt; observer());
  return result;
&#125;
</code></pre>
<p>观察者函数都放进<code>Set</code>集合，当修改<code>obj</code>的值，在会<code>set</code>函数中拦截，自动执行<code>Set</code>所有的观察者</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Module的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Module的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Module的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Module的？使用场景？</h3><h4 id="一、介绍-1"><a href="#一、介绍-1" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>模块，（Module），是能够单独命名并独立地完成一定功能的程序语句集合（即程序代码和数据结构的集合体）。</p>
<p>两个基本的特征：外部特征和内部</p>
<ul>
<li>外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能</li>
<li>内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）</li>
</ul>
<h5 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h5><ul>
<li>代码抽象</li>
<li>代码封装</li>
<li>代码复用</li>
<li>依赖管理</li>
</ul>
<p>如果没有模块化，我们代码会怎样？</p>
<ul>
<li>变量和方法不容易维护，容易污染全局作用域</li>
<li>加载资源的方式通过script标签从上到下。</li>
<li>依赖的环境主观逻辑偏重，代码较多就会比较复杂。</li>
<li>大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃</li>
</ul>
<p>因此，需要一种将<code>JavaScript</code>程序模块化的机制，如</p>
<ul>
<li>CommonJs (典型代表：node.js早期)</li>
<li>AMD (典型代表：require.js)</li>
<li>CMD (典型代表：sea.js)</li>
</ul>
<h5 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h5><p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p>
<p>代表库为<code>require.js</code></p>
<pre><code class="javascript">/** main.js 入口文件/主模块 **/
// 首先用config()指定各模块路径和引用名
require.config(&#123;
  baseUrl: &quot;js/lib&quot;,
  paths: &#123;
    &quot;jquery&quot;: &quot;jquery.min&quot;,  //实际路径为js/lib/jquery.min.js
    &quot;underscore&quot;: &quot;underscore.min&quot;,
  &#125;
&#125;);
// 执行基本操作
require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123;
  // some code here
&#125;);
</code></pre>
<h5 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h5><p><code>CommonJS</code> 是一套 <code>Javascript</code> 模块规范，用于服务端</p>
<pre><code class="javascript">// a.js
module.exports=&#123; foo , bar&#125;

// b.js
const &#123; foo,bar &#125; = require(&#39;./a.js&#39;)
</code></pre>
<p>其有如下特点：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li>
<li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>
<li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li>
</ul>
<p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p>
<p>ES6 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以取代 <code>CommonJS </code>和 <code>AMD </code>规范，成为浏览器和服务器通用的模块解决方案</p>
<p><code>CommonJS</code> 和<code> AMD</code> 模块，都只能在运行时确定这些东西。比如，<code>CommonJS </code>模块就是对象，输入时必须查找对象属性</p>
<pre><code class="javascript">// CommonJS模块
let &#123; stat, exists, readfile &#125; = require(&#39;fs&#39;);

// 等同于
let _fs = require(&#39;fs&#39;);
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
</code></pre>
<p><code>ES6</code>设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
<pre><code class="javascript">// ES6模块
import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;
</code></pre>
<p>上述代码，只加载3个方法，其他方法不加载，即 <code>ES6</code> 可以在编译时就完成模块加载</p>
<p>由于编译加载，使得静态分析成为可能。包括现在流行的<code>typeScript</code>也是依靠静态分析实现功能</p>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p><code>ES6</code>模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是<code>ES5</code>之前就已经规定好</p>
<p>模块功能主要由两个命令构成：</p>
<ul>
<li><code>export</code>：用于规定模块的对外接口</li>
<li><code>import</code>：用于输入其他模块提供的功能</li>
</ul>
<h5 id="export"><a href="#export" class="headerlink" title="export"></a>export</h5><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p>
<pre><code class="javascript">// profile.js
export var firstName = &#39;Michael&#39;;
export var lastName = &#39;Jackson&#39;;
export var year = 1958;

或 
// 建议使用下面写法，这样能瞬间确定输出了哪些变量
var firstName = &#39;Michael&#39;;
var lastName = &#39;Jackson&#39;;
var year = 1958;

export &#123; firstName, lastName, year &#125;;
</code></pre>
<p>输出函数或类</p>
<pre><code class="javascript">export function multiply(x, y) &#123;
  return x * y;
&#125;;
</code></pre>
<p>通过<code>as</code>可以进行输出变量的重命名</p>
<pre><code class="javascript">function v1() &#123; ... &#125;
function v2() &#123; ... &#125;

export &#123;
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
&#125;;
</code></pre>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块</p>
<pre><code class="javascript">// main.js
import &#123; firstName, lastName, year &#125; from &#39;./profile.js&#39;;

function setName(element) &#123;
  element.textContent = firstName + &#39; &#39; + lastName;
&#125;
</code></pre>
<p>同样如果想要输入变量起别名，通过<code>as</code>关键字</p>
<pre><code class="javascript">import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;
</code></pre>
<p>当加载整个模块的时候，需要用到星号<code>*</code></p>
<pre><code class="javascript">// circle.js
export function area(radius) &#123;
  return Math.PI * radius * radius;
&#125;

export function circumference(radius) &#123;
  return 2 * Math.PI * radius;
&#125;

// main.js
import * as circle from &#39;./circle&#39;;
console.log(circle)   // &#123;area:area,circumference:circumference&#125;
</code></pre>
<p>输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性</p>
<pre><code class="javascript">import &#123;a&#125; from &#39;./xxx.js&#39;

a.foo = &#39;hello&#39;; // 合法操作
a = &#123;&#125;; // Syntax Error : &#39;a&#39; is read-only;
</code></pre>
<p>不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错</p>
<p><code>import</code>后面我们常接着<code>from</code>关键字，<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径</p>
<pre><code class="javascript">import &#123; a &#125; from &#39;./a&#39;;
</code></pre>
<p>如果只有一个模块名，需要有配置文件，告诉引擎模块的位置</p>
<pre><code class="javascript">import &#123; myMethod &#125; from &#39;util&#39;;
</code></pre>
<p>在编译阶段，<code>import</code>会提升到整个模块的头部，首先执行</p>
<pre><code class="javascript">foo();

import &#123; foo &#125; from &#39;my_module&#39;;
</code></pre>
<p>多次重复执行同样的导入，只会执行一次</p>
<pre><code class="javascript">import &#39;lodash&#39;;
import &#39;lodash&#39;;
</code></pre>
<p>上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载</p>
<p>如果不需要知道变量名或函数就完成加载，就要用到<code>export default</code>命令，为模块指定默认输出</p>
<pre><code class="javascript">// export-default.js
export default function () &#123;
    console.log(&#39;foo&#39;);
&#125;
</code></pre>
<p>加载该模块的时候，<code>import</code>命令可以为该函数指定任意名字</p>
<pre><code class="javascript">// import-default.js
import customName from &#39;./export-default&#39;;
customName(); // &#39;foo&#39;
</code></pre>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p>
<p>这个新功能允许您将<code>import()</code>作为函数调用，将其作为参数传递给模块的路径。 它返回一个 <code>promise</code>，它用一个模块对象来实现，让你可以访问该对象的导出</p>
<pre><code class="javascript">import(&#39;/modules/myModule.mjs&#39;)
  .then((module) =&gt; &#123;
    // Do something with the module.
  &#125;);
</code></pre>
<h4 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h4><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起</p>
<pre><code class="javascript">export &#123; foo, bar &#125; from &#39;my_module&#39;;

// 可以简单理解为
import &#123; foo, bar &#125; from &#39;my_module&#39;;
export &#123; foo, bar &#125;;
</code></pre>
<p>同理能够搭配<code>as</code>、<code>*</code>搭配使用</p>
<h4 id="三、使用场景-2"><a href="#三、使用场景-2" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>如今，<code>ES6</code>模块化已经深入我们日常项目开发中，像<code>vue</code>、<code>react</code>项目搭建项目，组件化开发处处可见，其也是依赖模块化实现</p>
<p><code>vue</code>组件</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;App&quot;&gt;
      组件化开发 ---- 模块化
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;HelloWorld&#39;,
  props: &#123;
    msg: String
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p><code>react</code>组件</p>
<pre><code class="javascript">function App() &#123;
  return (
    &lt;div className=&quot;App&quot;&gt;
        组件化开发 ---- 模块化
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>包括完成一些复杂应用的时候，我们也可以拆分成各个模块</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Decorator-的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Decorator-的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Decorator 的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Decorator 的？使用场景？</h3><h4 id="一、介绍-2"><a href="#一、介绍-2" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>Decorator，即装饰器，从名字上很容易让我们联想到装饰者模式</p>
<p>简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。</p>
<p><code>ES6</code>中<code>Decorator</code>功能亦如此，其本质也不是什么高大上的结构，就是一个普通的函数，用于扩展类属性和类方法</p>
<p>这里定义一个士兵，这时候他什么装备都没有</p>
<pre><code class="javascript">class soldier&#123; 
&#125;
</code></pre>
<p>定义一个得到 AK 装备的函数，即装饰器</p>
<pre><code class="javascript">function strong(target)&#123;
    target.AK = true
&#125;
</code></pre>
<p>使用该装饰器对士兵进行增强</p>
<pre><code class="javascript">@strong
class soldier&#123;
&#125;
</code></pre>
<p>这时候士兵就有武器了</p>
<pre><code class="javascript">soldier.AK // true
</code></pre>
<p>上述代码虽然简单，但也能够清晰看到了使用<code>Decorator</code>两大优点：</p>
<ul>
<li>代码可读性变强了，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原来功能进行扩展</li>
</ul>
<h4 id="二、用法-2"><a href="#二、用法-2" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Docorator</code>修饰对象为下面两种：</p>
<ul>
<li>类的装饰</li>
<li>类属性的装饰</li>
</ul>
<h5 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h5><p>当对类本身进行装饰的时候，能够接受一个参数，即类本身</p>
<p>将装饰器行为进行分解，大家能够有个更深入的了解</p>
<pre><code class="javascript">@decorator
class A &#123;&#125;

// 等同于

class A &#123;&#125;
A = decorator(A) || A;
</code></pre>
<p>下面<code>@testable</code>就是一个装饰器，<code>target</code>就是传入的类，即<code>MyTestableClass</code>，实现了为类添加静态属性</p>
<pre><code class="javascript">@testable
class MyTestableClass &#123;
  // ...
&#125;

function testable(target) &#123;
  target.isTestable = true;
&#125;

MyTestableClass.isTestable // true
</code></pre>
<p>如果想要传递参数，可以在装饰器外层再封装一层函数</p>
<pre><code class="javascript">function testable(isTestable) &#123;
  return function(target) &#123;
    target.isTestable = isTestable;
  &#125;
&#125;

@testable(true)
class MyTestableClass &#123;&#125;
MyTestableClass.isTestable // true

@testable(false)
class MyClass &#123;&#125;
MyClass.isTestable // false
</code></pre>
<h5 id="类属性的装饰"><a href="#类属性的装饰" class="headerlink" title="类属性的装饰"></a>类属性的装饰</h5><p>当对类属性进行装饰的时候，能够接受三个参数：</p>
<ul>
<li>类的原型对象</li>
<li>需要装饰的属性名</li>
<li>装饰属性名的描述对象</li>
</ul>
<p>首先定义一个<code>readonly</code>装饰器</p>
<pre><code class="javascript">function readonly(target, name, descriptor)&#123;
  descriptor.writable = false; // 将可写属性设为false
  return descriptor;
&#125;
</code></pre>
<p>使用<code>readonly</code>装饰类的<code>name</code>方法</p>
<pre><code class="javascript">class Person &#123;
  @readonly
  name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;
&#125;
</code></pre>
<p>相当于以下调用</p>
<pre><code class="javascript">readonly(Person.prototype, &#39;name&#39;, descriptor);
</code></pre>
<p>如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行</p>
<pre><code class="javascript">function dec(id)&#123;
    console.log(&#39;evaluated&#39;, id);
    return (target, property, descriptor) =&gt;console.log(&#39;executed&#39;, id);
&#125;

class Example &#123;
    @dec(1)
    @dec(2)
    method()&#123;&#125;
&#125;
// evaluated 1
// evaluated 2
// executed 2
// executed 1
</code></pre>
<p>外层装饰器<code>@dec(1)</code>先进入，但是内层装饰器<code>@dec(2)</code>先执行</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>装饰器不能用于修饰函数，因为函数存在变量声明情况</p>
<pre><code class="javascript">var counter = 0;

var add = function () &#123;
  counter++;
&#125;;

@add
function foo() &#123;
&#125;
</code></pre>
<p>编译阶段，变成下面</p>
<pre><code class="javascript">var counter;
var add;

@add
function foo() &#123;
&#125;

counter = 0;

add = function () &#123;
  counter++;
&#125;;
</code></pre>
<p>意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0</p>
<h4 id="三、使用场景-3"><a href="#三、使用场景-3" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>基于<code>Decorator</code>强大的作用，我们能够完成各种场景的需求，下面简单列举几种：</p>
<p>使用<code>react-redux</code>的时候，如果写成下面这种形式，既不雅观也很麻烦</p>
<pre><code class="javascript">class MyReactComponent extends React.Component &#123;&#125;

export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);
</code></pre>
<p>通过装饰器就变得简洁多了</p>
<pre><code class="javascript">@connect(mapStateToProps, mapDispatchToProps)
export default class MyReactComponent extends React.Component &#123;&#125;
</code></pre>
<p>将<code>mixins</code>，也可以写成装饰器，让使用更为简洁了</p>
<pre><code class="javascript">function mixins(...list) &#123;
  return function (target) &#123;
    Object.assign(target.prototype, ...list);
  &#125;;
&#125;

// 使用
const Foo = &#123;
  foo() &#123; console.log(&#39;foo&#39;) &#125;
&#125;;

@mixins(Foo)
class MyClass &#123;&#125;

let obj = new MyClass();
obj.foo() // &quot;foo&quot;
</code></pre>
<p>下面再讲讲<code>core-decorators.js</code>几个常见的装饰器</p>
<h5 id="antobind"><a href="#antobind" class="headerlink" title="@antobind"></a>@antobind</h5><p><code>autobind</code>装饰器使得方法中的<code>this</code>对象，绑定原始对象</p>
<pre><code class="javascript">import &#123; autobind &#125; from &#39;core-decorators&#39;;

class Person &#123;
  @autobind
  getPerson() &#123;
    return this;
  &#125;
&#125;

let person = new Person();
let getPerson = person.getPerson;

getPerson() === person;
// true
</code></pre>
<h5 id="readonly"><a href="#readonly" class="headerlink" title="@readonly"></a>@readonly</h5><p><code>readonly</code>装饰器使得属性或方法不可写</p>
<pre><code class="javascript">import &#123; readonly &#125; from &#39;core-decorators&#39;;

class Meal &#123;
  @readonly
  entree = &#39;steak&#39;;
&#125;

var dinner = new Meal();
dinner.entree = &#39;salmon&#39;;
// Cannot assign to read only property &#39;entree&#39; of [object Object]
</code></pre>
<h4 id="deprecate"><a href="#deprecate" class="headerlink" title="@deprecate"></a>@deprecate</h4><p><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除</p>
<pre><code class="javascript">import &#123; deprecate &#125; from &#39;core-decorators&#39;;

class Person &#123;
  @deprecate
  facepalm() &#123;&#125;

  @deprecate(&#39;功能废除了&#39;)
  facepalmHard() &#123;&#125;
&#125;

let person = new Person();

person.facepalm();
// DEPRECATION Person#facepalm: This function will be removed in future versions.

person.facepalmHard();
// DEPRECATION Person#facepalmHard: 功能废除了
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-Symbol数据类型"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-Symbol数据类型" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Symbol数据类型"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Symbol数据类型</h3><p>ES6引入一种新的原始数据类型为 Symbol ，表示为 独一无二 的值，用来定义独一无二的对象属性名。</p>
<h4 id="Symbol的讲解"><a href="#Symbol的讲解" class="headerlink" title="Symbol的讲解"></a>Symbol的讲解</h4><p>4个方面说说Symbol数据类型：</p>
<ol>
<li>Symbol的定义；</li>
<li>Symbol作为对象属性名；</li>
<li>Symbol使用场景；</li>
<li>Symbol获取。</li>
</ol>
<h4 id="Symbol的定义"><a href="#Symbol的定义" class="headerlink" title="Symbol的定义"></a>Symbol的定义</h4><ul>
<li>一种Symbol类型可以通过使用Symbol()函数来生成；</li>
<li>Symbol()函数可以接收一个字符串作为参数</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let s1 = Symbol(&#39;web&#39;);
let s2 = Symbol(&#39;web&#39;);
console.log(s1 === s2);
console.log(typeof s1);
console.log(typeof s2);
复制代码
</code></pre>
<p>chrome截图：</p>
<p><img src="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/170563012a3ecec6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p>由图可知：Symbol()函数接收的参数相同，其变量的值也不同，s1和s2是Symbol类型的变量，因为变量的值不同，所以打印的结果为false。使用typeof来获取相应的类型，所以打印的结果都为symbol。</p>
<h4 id="Symbol作为对象属性名"><a href="#Symbol作为对象属性名" class="headerlink" title="Symbol作为对象属性名"></a>Symbol作为对象属性名</h4><p>Symbol可以通过三种方式作为对象属性名。</p>
<ul>
<li>第一种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;&#125;;
a[symbol] = &#39;web&#39;;
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，一个空的对象为a，通过a[symbol]给a对象赋值一个web的字符串。表示symbol作为对象属性名，web作为它的属性值。</p>
<ul>
<li>第二种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;
    [symbol]:&#39;web&#39;
&#125;;
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，接着在声明对象a的同时通过[symbol]给a对象性赋值为web的字符串。</p>
<ul>
<li>第三种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;&#125;;
Object.defineProperty(a, symbol, &#123;value: &#39;web&#39;&#125;);
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，一个空对象为a，通过Object.defineProperty()方法给a对象赋值为web的字符串。</p>
<blockquote>
<p>Symbol的值作为对象属性名，是不能用点运算符的。</p>
</blockquote>
<h4 id="Symbol使用场景"><a href="#Symbol使用场景" class="headerlink" title="Symbol使用场景"></a>Symbol使用场景</h4><p>一种有两种使用场景：</p>
<ol>
<li>因为Symbol的值是均不相等的，所以Symbol类型的值作为对象属性名，不会出现重复。</li>
<li>代码形成强耦合的某一个具体的字符串。</li>
</ol>
<h4 id="Symbol获取"><a href="#Symbol获取" class="headerlink" title="Symbol获取"></a>Symbol获取</h4><p>通过Object.getOwnPropertySymbols()方法，可以获取指定对象的所有Symbols属性名。:</p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全Vue-Vue3</title>
    <url>/2022/10/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8Vue-Vue3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（Vue-Vue3）"><a href="#前端面试题大全（Vue-Vue3）" class="headerlink" title="前端面试题大全（Vue + Vue3）"></a>前端面试题大全（Vue + Vue3）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="Vue-Vue3"><a href="#Vue-Vue3" class="headerlink" title="Vue + Vue3"></a>Vue + Vue3</h2><h3 id="♥︎♥︎vue-router-3-1-0新增的v-slot属性怎么用？"><a href="#♥︎♥︎vue-router-3-1-0新增的v-slot属性怎么用？" class="headerlink" title="♥︎♥︎vue-router 3.1.0新增的v-slot属性怎么用？"></a>♥︎♥︎vue-router 3.1.0新增的v-slot属性怎么用？</h3><p>router-link 通过一个作用域插槽暴露底层的定制能力。这是一个更高阶的 API，主要面向库作者，但也可以为开发者提供便利，多数情况用在一个类似 NavLink 这样的自定义组件里。</p>
<p>在使用 v-slot API 时，需要向 router-link 传入一个单独的子元素。否则 router-link 将会把子元素包裹在一个 span 元素内。</p>
<h3 id="♥︎♥︎说一下-root，-parent，-refs"><a href="#♥︎♥︎说一下-root，-parent，-refs" class="headerlink" title="♥︎♥︎说一下$root，$parent，$refs"></a>♥︎♥︎说一下$root，$parent，$refs</h3><p>$root，和$parent都能访问父组件的属性和方法，区别在于如果存在多级子组件，通过parent 访问得到的是它最近一级的父组件，通过root 访问得到的是根父组件。</p>
<p>通过在子组件标签定义 ref 属性，在父组件中可以使用$refs 访问子组件实例。</p>
<h3 id="♥︎♥︎对比-jQuery，Vue-有什么不同"><a href="#♥︎♥︎对比-jQuery，Vue-有什么不同" class="headerlink" title="♥︎♥︎对比 jQuery，Vue 有什么不同"></a>♥︎♥︎对比 jQuery，Vue 有什么不同</h3><p>jQuery 专注视图层，通过直接操作 DOM 去实现页面的一些逻辑渲染；</p>
<p>Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作。</p>
<p>Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发</p>
<h3 id="♥︎♥︎-Vue中如何实现子组件内的css样式名在项目中绝对唯一性"><a href="#♥︎♥︎-Vue中如何实现子组件内的css样式名在项目中绝对唯一性" class="headerlink" title="♥︎♥︎ Vue中如何实现子组件内的css样式名在项目中绝对唯一性"></a>♥︎♥︎ Vue中如何实现子组件内的css样式名在项目中绝对唯一性</h3><p>在style标签上加上scoped属性</p>
<h3 id="♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？"><a href="#♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？" class="headerlink" title="♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？"></a>♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？</h3><p>v-model是一个语法糖，这一个指令可以分为几个指令，它内部已经帮我们处理整合了。对于普通的文本框来说，v-model &#x3D; v-bind:value + @input。对单选框和复选框来说，v-model &#x3D; v-bind:checked +@change，并且它还有一个非常重要的功能，就是解决父子组件之间的通讯问题，可以提升我们的开发效率。在vue中通过使用&lt;v-on:事件名 &#x3D; 函数名&gt;的方式来绑定事件。</p>
<h3 id="♥︎♥︎Vue生命周期通常使用哪些"><a href="#♥︎♥︎Vue生命周期通常使用哪些" class="headerlink" title="♥︎♥︎Vue生命周期通常使用哪些"></a>♥︎♥︎Vue生命周期通常使用哪些</h3><p>常用的生命周期有，beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed</p>
<h3 id="♥︎♥︎Vue深层次的组件怎么和父组件通讯"><a href="#♥︎♥︎Vue深层次的组件怎么和父组件通讯" class="headerlink" title="♥︎♥︎Vue深层次的组件怎么和父组件通讯"></a>♥︎♥︎Vue深层次的组件怎么和父组件通讯</h3><p>使用$attrs和$listeners</p>
<pre><code class="vue">//C
Vue.component(&#39;C&#39;, &#123;
 template: &lt;div&gt; &lt;p&gt;我是C组件&lt;/p&gt; &lt;input type=&#39;text&#39; v-model=&#39;$attrs.msgc&#39; @input=&#39;$emit(&quot;getC&quot;, $attrs.msgc)&#39; /&gt; &lt;/div&gt;
&#125;)

//B
Vue.component(&#39;B&#39;, &#123;
 /**
 给C组件绑定$attrs属性和$listeners事件，C组件可以直接获取到A组件中传递下来的props（除了B组
件中props声明的）
 */
 template: &lt;div&gt; &lt;p&gt;我是B组件&lt;/p&gt; &lt;input type=&#39;text&#39; v-model=&#39;mymsg1&#39; @input=&quot;$emit(&#39;getChild&#39;, mymsg1)&quot; /&gt;&lt;C v-bind=&#39;$attrs&#39; v-on=&#39;$listeners&#39;/&gt; &lt;/div&gt; ,
 props: [&#39;msg1&#39;],
 data () &#123;
 return &#123;
 mymsg1: this.msg1
 &#125;
 &#125;
&#125;)

Vue.component(&#39;A&#39;, &#123;
 template: &lt;div id=&#39;app&#39;&gt; &lt;p&gt;我是A组件&lt;/p&gt; &lt;B:msg1=&#39;msg1&#39; :msgc=&#39;msgc&#39; @getChild=&#39;getChild&#39; @getC=&#39;getC&#39; /&gt; &lt;/div&gt; ,
 data () &#123;
 return &#123;
 msg1: &#39;A&#39;,
 msgc: &#39;hello c!&#39;
 &#125;
 &#125;,
 methods: &#123;
 getChild (val) &#123;
 console.log( val )
 &#125;,
 getC (val) &#123;
 console.log( val )
 &#125;
 &#125;
&#125;)
const app = new Vue(&#123;
 el: &#39;#app&#39;,
 template: &lt;A /&gt;
&#125;)
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？"><a href="#♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？" class="headerlink" title="♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？"></a>♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？</h3><p>在style标签上不加上scoped的属性，默认为全局css样式</p>
<h3 id="♥︎♥︎♥︎如何实现一个路径渲染多个组件？"><a href="#♥︎♥︎♥︎如何实现一个路径渲染多个组件？" class="headerlink" title="♥︎♥︎♥︎如何实现一个路径渲染多个组件？"></a>♥︎♥︎♥︎如何实现一个路径渲染多个组件？</h3><p>可以通过命名视图(router-view)，它容许同一界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。通过设置components即可同时渲染多个组件。</p>
<h3 id="♥︎♥︎♥︎-如何实现多个路径共享一个组件？"><a href="#♥︎♥︎♥︎-如何实现多个路径共享一个组件？" class="headerlink" title="♥︎♥︎♥︎ 如何实现多个路径共享一个组件？"></a>♥︎♥︎♥︎ 如何实现多个路径共享一个组件？</h3><p>只需将多个路径的component字段的值设置为同一个组件即可。</p>
<h3 id="♥︎♥︎♥︎如何监测动态路由的变化"><a href="#♥︎♥︎♥︎如何监测动态路由的变化" class="headerlink" title="♥︎♥︎♥︎如何监测动态路由的变化"></a>♥︎♥︎♥︎如何监测动态路由的变化</h3><p>可以通过watch方法来对$route进行监听，或者通过导航守卫的钩子函数beforeRouteUpdate来监听它的变化。</p>
<h3 id="♥︎♥︎♥︎对MVC，MVP，MVVM的理解"><a href="#♥︎♥︎♥︎对MVC，MVP，MVVM的理解" class="headerlink" title="♥︎♥︎♥︎对MVC，MVP，MVVM的理解"></a>♥︎♥︎♥︎对MVC，MVP，MVVM的理解</h3><p>mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。</p>
<p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。</p>
<p>1：Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>
<p>2：在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>
<p>3：ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<p>MVP与MVC很接近，P指的是Presenter，presenter可以理解为一个中间人，它负责着View和Model之间的数据流动，防止View和Model之间直接交流。</p>
<p><img src="/2022/10/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8Vue-Vue3/2021022520492697.png" alt="MVP"></p>
<p>presenter负责和Model进行双向交互，还和View进行双向交互。这种交互方式，相对于MVC来说少了一些灵活，Vlew变成了被动视图，并且本身变得很小。虽然它分离了View和Model。但是presenter除了要做事件监听，还要更新DOM等各种事情，应用逐渐变大之后，导致presenter的体积增大，难以维护。</p>
<h3 id="♥︎♥︎♥︎什么情况下使用-Vuex"><a href="#♥︎♥︎♥︎什么情况下使用-Vuex" class="headerlink" title="♥︎♥︎♥︎什么情况下使用 Vuex"></a>♥︎♥︎♥︎<strong>什么情况下使用</strong> Vuex</h3><p>如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可，需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态</p>
<h3 id="♥︎♥︎♥︎Vuex可以直接修改state的值吗？"><a href="#♥︎♥︎♥︎Vuex可以直接修改state的值吗？" class="headerlink" title="♥︎♥︎♥︎Vuex可以直接修改state的值吗？"></a>♥︎♥︎♥︎Vuex可以直接修改state的值吗？</h3><p>可以直接修改，但是极其不推荐，state的修改必须在mutation来修改，否则无法被devtool所监测，无法监测数据的来源，无法保存状态快照，也就无法实现时间漫游&#x2F;回滚之类的操作。</p>
<h3 id="♥︎♥︎♥︎v-model和vuex有冲突吗？"><a href="#♥︎♥︎♥︎v-model和vuex有冲突吗？" class="headerlink" title="♥︎♥︎♥︎v-model和vuex有冲突吗？"></a>♥︎♥︎♥︎v-model和vuex有冲突吗？</h3><p>当我们v-model的数据是存储在vuex中时写法如下时会报错</p>
<pre><code class="javascript">computed:&#123;
  editableTabsValue2:&#123;
     return this.$store.state.activeName
  &#125;
&#125;
</code></pre>
<p>报错：Computed property  “editableTabsValue2”  was assigned  to but  it has no  setter</p>
<p>原因：v-model是双向数据绑定 vue实例的data改变或者用户输入的改变都会触发视图更新。vuex是一个状态的存储，对于里面的状态的改变都是通过commit mutation 所以当用户输入直接修改editableTabsValue2,又不是通过commit更改状态时会报错</p>
<p>解决方法:</p>
<pre><code class="javascript">computed:&#123;
  editableTabsValue2:&#123;
    get:function () &#123;
      return this.$store.state.activeName
    &#125;,
    set:function () &#123;
    &#125;
  &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎解释单向数据流和双向数据绑定"><a href="#♥︎♥︎♥︎解释单向数据流和双向数据绑定" class="headerlink" title="♥︎♥︎♥︎解释单向数据流和双向数据绑定"></a>♥︎♥︎♥︎解释单向数据流和双向数据绑定</h3><p>对于 Vue 来说，组件之间的数据传递具有单向数据流这样的特性称为单向数据流，单向数据流（Unidirectional data flow）方式使用一个上传数据流和一个下传数据流进行双向数据通信，两个数据流之间相互独立，单向数据流指只能从一个方向来修改状态。</p>
<p>而双向数据绑定即为当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化，两个数据流之间互为影响。</p>
<h3 id="♥︎♥︎♥︎-route和-router的区别"><a href="#♥︎♥︎♥︎-route和-router的区别" class="headerlink" title="♥︎♥︎♥︎$route和 $router的区别"></a>♥︎♥︎♥︎$route和 $router的区别</h3><p>$route用来获取路由的信息的，它是路由信息的一个对象，里面包含路由的一些基本信息，包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom等。</p>
<p>而$router主要是用来操作路由的，它是VueRouter的实例，包含了一些路由的跳转方法，钩子函数等</p>
<h3 id="♥︎♥︎♥︎Vue-中怎么自定义指令"><a href="#♥︎♥︎♥︎Vue-中怎么自定义指令" class="headerlink" title="♥︎♥︎♥︎Vue 中怎么自定义指令"></a>♥︎♥︎♥︎Vue <strong>中怎么自定义指令</strong></h3><p>通过directive来自定义指令，自定义指令分为全局指令和局部指令，自定义指令也有几个的钩子函数，常用的有bind和update，当 bind 和 update 时触发相同行为，而不关心其它的钩子时可以简写。一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右。</p>
<h3 id="♥︎♥︎♥︎Vue中怎么自定义过滤器"><a href="#♥︎♥︎♥︎Vue中怎么自定义过滤器" class="headerlink" title="♥︎♥︎♥︎Vue中怎么自定义过滤器"></a>♥︎♥︎♥︎Vue中怎么自定义过滤器</h3><p>通过filter来定义过滤器，过滤器分为全局和局部过滤器，过滤器的主体为一个普通的函数，来对数据进行处理，可以传递参数。当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用。</p>
<h3 id="♥︎♥︎♥︎Vue等单页面应用的优缺点"><a href="#♥︎♥︎♥︎Vue等单页面应用的优缺点" class="headerlink" title="♥︎♥︎♥︎Vue等单页面应用的优缺点"></a>♥︎♥︎♥︎Vue等单页面应用的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、单页应用的内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。</p>
<p>2、单页应用没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象</p>
<p>3、单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提</p>
<p>高几倍。</p>
<p>4、良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代</p>
<p>码，不用修改就可以用于Web界面、手机、平板等多种客户端。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1、首次加载耗时比较多。</p>
<p>2、SEO问题，不利于百度，360等搜索引擎收录。</p>
<p>3、容易造成Css命名冲突。</p>
<p>4、前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开</p>
<p>发成本高。</p>
<h3 id="♥︎♥︎♥︎Vue-router使用params与query传参有什么区别"><a href="#♥︎♥︎♥︎Vue-router使用params与query传参有什么区别" class="headerlink" title="♥︎♥︎♥︎Vue-router使用params与query传参有什么区别"></a>♥︎♥︎♥︎Vue-router使用params与query传参有什么区别</h3><p>&#x2F;&#x2F; 用法上</p>
<p>query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和this.$route.params.name。</p>
<p>&#x2F;&#x2F; 展示上</p>
<p>1：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p>
<p>2：params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。</p>
<p>3：params、query不设置也可以传参，params不设置的时候，刷新页面或者返回参数会丢失</p>
<h3 id="♥︎♥︎♥︎Vue中keep-alive的作用"><a href="#♥︎♥︎♥︎Vue中keep-alive的作用" class="headerlink" title="♥︎♥︎♥︎Vue中keep-alive的作用"></a>♥︎♥︎♥︎Vue中keep-alive的作用</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。一旦使用keepalive包裹组件，此时mouted，created等钩子函数只会在第一次进入组件时调用，当再次切换回来时将不会调用。此时如果我们还想在每次切换时做一些事情，就需要用到另外的周期函数，actived和deactived，这两个钩子函数只有被keepalive包裹后才会调用。</p>
<h3 id="♥︎♥︎♥︎Vue如何实现单页面应用"><a href="#♥︎♥︎♥︎Vue如何实现单页面应用" class="headerlink" title="♥︎♥︎♥︎Vue如何实现单页面应用"></a>♥︎♥︎♥︎Vue如何实现单页面应用</h3><p>通常的url 地址由以下内容构成：协议名 域名 端口号 路径 参数 哈希值，当哈希值改变，页面不会发生跳转，单页面应用就是利用了这一点，给window注册onhashchange事件，当哈希值改变时通过location.hash就能获得相应的哈希值，然后就能跳到相应的页面。</p>
<h3 id="♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？"><a href="#♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？" class="headerlink" title="♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？"></a>♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？</h3><pre><code class="css">v-if(判断是否隐藏，用来判断元素是否创建)
v-show(元素的显示隐藏，类似css中的display的block和hidden)
v-for(把数据遍历出来)
v-bind(绑定属性)
v-model(实现双向绑定)
</code></pre>
<h3 id="♥︎♥︎♥︎-Vuex是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#♥︎♥︎♥︎-Vuex是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="♥︎♥︎♥︎ Vuex是什么？怎么使用？描述使用它实现登录功能的流程？"></a>♥︎♥︎♥︎ Vuex是什么？怎么使用？描述使用它实现登录功能的流程？</h3><p>Vuex是一个专为Vue.js应用程序开发的状态管理模式；它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex可以管理复杂应用的数据状态，比如兄弟组件的通信、多层嵌套的组件的传值等等。</p>
<p>如何使用</p>
<pre><code class="css">1.安装vuex
按照官网给出的步骤
npm install vuex --save  //安装vuex

2.Vuex 依赖 Promise  浏览器支持promise的此步骤可省略
注意：Vuex 依赖 Promise (opens new window)。如果你支持的浏览器并没有实现 Promise (比如 IE)，那么你可以使用一个 polyfill 的库，例如 es6-promise (opens new window)。

你可以通过 CDN 将其引入：
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js&quot;&gt;
&lt;/script&gt;
然后 window.Promise 会自动可用。
如果你喜欢使用诸如 npm 或 Yarn 等包管理器，可以按照下列方式执行安装：
npm install es6-promise --save # npm
yarn add es6-promise # Yarn
或者更进一步，将下列代码添加到你使用 Vuex 之前的一个地方：
import &#39;es6-promise/auto&#39;

3.在项目引用
找到项目中的main.js文件，将内容引入
import store from &#39;./store&#39;
.use(store)
</code></pre>
<p>4.使用方法<br>    首先，在项目中找到store文件夹，如果没有就自己建一个文件夹，在文件夹内再新建一个js文件。</p>
<pre><code class="css">import &#123; createStore &#125; from &#39;vuex&#39;
 
export default createStore(&#123;
  state: &#123;  //数据存放的位置
        data:&#39;&#39;
  &#125;,
  mutations: &#123;//在mutations写方法更改state中的值
      data(state,data)&#123;
        state.data=data
   &#125;
  &#125;,
  actions: &#123;//通过actions触发mutations的方法
      dataone(context,data)&#123;
          context.commit(&#39;data&#39;,data);//带引号的data是mutation里的，第二个data，是页面上
                                      //传过来的参数
    &#125;
  &#125;,
  modules: &#123;
      
  &#125;
&#125;)
然后，将要保存的数据从页面传过来
这是页面：
import &#123;useStore&#125; from &#39;vuex&#39;
    export default&#123;
        setup()&#123;
            let A =124
            const store=useStore();
            store.dispatch(&#39;dataone&#39;,A)
              //括号内第一个参数为actions中的方法名,方法名不能与mutations中重复    
              //第二个为需要存储改变的值的变量
        &#125;
    &#125;
</code></pre>
<h3 id="♥︎♥︎♥︎Vue-loader解释一下"><a href="#♥︎♥︎♥︎Vue-loader解释一下" class="headerlink" title="♥︎♥︎♥︎Vue-loader解释一下"></a>♥︎♥︎♥︎Vue-loader解释一下</h3><p>解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。</p>
<h3 id="♥︎♥︎♥︎-用过插槽吗？用的是具名插槽还是匿名插槽"><a href="#♥︎♥︎♥︎-用过插槽吗？用的是具名插槽还是匿名插槽" class="headerlink" title="♥︎♥︎♥︎ 用过插槽吗？用的是具名插槽还是匿名插槽"></a>♥︎♥︎♥︎ 用过插槽吗？用的是具名插槽还是匿名插槽</h3><p>用过，都使用过。插槽相当于预留了一个位置，可以将我们书写在组件内的内容放入，写一个插槽就会将组件内的内容替换一次，两次则替换两次。为了自定义插槽的位置我们可以给插槽取名，它会根据插槽名来插入内容，一一对应。</p>
<h3 id="♥︎♥︎♥︎Vue路由守卫"><a href="#♥︎♥︎♥︎Vue路由守卫" class="headerlink" title="♥︎♥︎♥︎Vue路由守卫"></a>♥︎♥︎♥︎Vue路由守卫</h3><p>vue-router 提供的导航守卫主要用来对路由的跳转进行监控，控制它的跳转或取消，路由守卫有全局的,单个路由独享的, 或者组件级的。导航钩子有3个参数：</p>
<p>1、to:即将要进入的目标路由对象；</p>
<p>2、from:当前导航即将要离开的路由对象；</p>
<p>3、next ：调用该方法后，才能进入下一个钩子函数（afterEach）。</p>
<h3 id="♥︎♥︎♥︎请你说一下Vue中create和mount的区别"><a href="#♥︎♥︎♥︎请你说一下Vue中create和mount的区别" class="headerlink" title="♥︎♥︎♥︎请你说一下Vue中create和mount的区别"></a>♥︎♥︎♥︎请你说一下Vue中create和mount的区别</h3><p>create为组件初始化阶段，在此阶段主要完成数据观测(data observer)，属性和方法的运算，watch&#x2F;event 事件回调。</p>
<p>然而，挂载阶段还没开始，此时还未生成真实的DOM，也就无法获取和操作DOM元素。</p>
<p>而mount主要完成从虚拟DOM到真实DOM的转换挂载，此时html已经渲染出来了，所以可以直接操作dom节点。</p>
<h3 id="♥︎♥︎♥︎路由懒加载"><a href="#♥︎♥︎♥︎路由懒加载" class="headerlink" title="♥︎♥︎♥︎路由懒加载"></a>♥︎♥︎♥︎路由懒加载</h3><p>把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应的组件即为路由的懒加载，可以加快项目的加载速度，提高效率。通过这种格式来导入组件const foo &#x3D; () &#x3D;&gt;import(‘.&#x2F;foo.vue’);</p>
<h3 id="♥︎♥︎♥︎Vue中computed的原理"><a href="#♥︎♥︎♥︎Vue中computed的原理" class="headerlink" title="♥︎♥︎♥︎Vue中computed的原理"></a>♥︎♥︎♥︎Vue中computed的原理</h3><p>computed是vue中的计算属性，在依赖的值发生变化的时候进行重新计算，否则使用缓存。</p>
<p>前面说到computed只有在依赖发生变化才会重新计算，那么如何得知computed的值发生了变化呢</p>
<p>这主要是Watcher中的dirty属性，dirty属性为true时，说明computed中的值需要重新计算，dirty为false时，则说明依赖没有变化，不需要重新计算</p>
<p>当计算属性的值发生变化时，计算属性的watcher和组件的watcher都会得到通知。</p>
<p>计算属性的watcher会将dirty置为true,组件的Watcher得到通知，同样将dirty属性置为false,重新计算值，用于本次渲染。</p>
<p>简单来说,computed就是定义在vm上的一个getter属性，这个getter属性被触发时会做两件事</p>
<ol>
<li><p>计算当前属性的值，此时会使用Watcher去观察计算属性中用到的所有其他数据的变化。同时将计算属性的Watcher的dirty属性设置为false.</p>
</li>
<li><p>当计算属性中用到的数据发生变化时,将得到通知从而进行重新渲染</p>
</li>
</ol>
<p>Watcher中的depend和evaluate方法是专门用于实现计算属性的两个API</p>
<pre><code class="javascript">export default class Watcher &#123;
     constructor(vm, expOrFn, cb, options) &#123;
         if(options) &#123;
             this.lazy = !!options.lazy;
         &#125;  else &#123;
             this.lazy = false;
         &#125;
         this.dirty = this.lazy;
         this.value = this.lazy ? undefined : this.get()
     &#125;
     evaluate() &#123;
        this.value = this.get()
        this.dirty = false; 
    &#125;
    depend() &#123;
        let i = this.deps.length
        while(i--) &#123;
            this.deps[i].depend()
        &#125;
    &#125;
&#125;
</code></pre>
<p>执行depend方法可以将组件中的watcher实例添加到dep实例的依赖列表中。换句话说,this.deps是计算属性中用到的所有状态的dep实例,而依次执行了dep实例的depend方法就是将组件的watcher依次加入到这些dep实例的依赖列表。这就实现了让组件的watcher观察计算属性中用到的所有的状态的变化。</p>
<p>Computed逻辑变化</p>
<p>computed在vue2.5.2中的实现发生了一些变化,因为之前的computed的计算存在一些逻辑上的漏洞,因为只要依赖的值发生了变化,vue就认为值发生了变化，组件会重新走一遍渲染的流程，但实际上UI不会由变化，浪费了一些性能。</p>
<p>改动之后的逻辑：</p>
<p>组件的watcher不再监听计算属性的变化,而是让计算属性的watcher得到通知后,计算一次计算属性的值，如果发现这一次计算出来的值与上一次计算出来的值不一样，再去主动通知组件的watcher进行重新渲染。</p>
<h3 id="♥︎♥︎♥︎Vuex的缺点"><a href="#♥︎♥︎♥︎Vuex的缺点" class="headerlink" title="♥︎♥︎♥︎Vuex的缺点"></a>♥︎♥︎♥︎Vuex的缺点</h3><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的，并且state中的值会伴随着浏览器的刷新而初始化，无缓存。</p>
<h3 id="♥︎♥︎♥︎Vue路由传参，刷新后还有吗"><a href="#♥︎♥︎♥︎Vue路由传参，刷新后还有吗" class="headerlink" title="♥︎♥︎♥︎Vue路由传参，刷新后还有吗"></a>♥︎♥︎♥︎Vue路由传参，刷新后还有吗</h3><p>通过params传参会出现参数丢失的情况，可以通过query的传参方式或者在路由匹配规则加入占位符即可以解决参数丢失的情况。</p>
<h3 id="♥︎♥︎♥︎Vue组件如何引入使用"><a href="#♥︎♥︎♥︎Vue组件如何引入使用" class="headerlink" title="♥︎♥︎♥︎Vue组件如何引入使用"></a>♥︎♥︎♥︎Vue组件如何引入使用</h3><ol>
<li><p>定义组件并抛出</p>
</li>
<li><p>import引入，并在component里面定义</p>
</li>
<li><p>使用组件（注意首字母大写）</p>
</li>
</ol>
<h3 id="♥︎♥︎♥︎-Vue-forceUpdate的原理"><a href="#♥︎♥︎♥︎-Vue-forceUpdate的原理" class="headerlink" title="♥︎♥︎♥︎ Vue $forceUpdate的原理"></a>♥︎♥︎♥︎ Vue $forceUpdate的原理</h3><p>1、作用：</p>
<p>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
<p>2、内部原理：</p>
<pre><code class="javascript">Vue.prototype.$forceUpdate = function () &#123;
 const vm: Component = this
 if (vm.watcher) &#123;
 vm.watcher.update()
 &#125;
&#125;
</code></pre>
<p>实例需要重新渲染是在依赖发生变化的时候会通知watcher，然后通知watcher来调用update方法，就是这么简单。</p>
<h3 id="♥︎♥︎♥︎v-for-key"><a href="#♥︎♥︎♥︎v-for-key" class="headerlink" title="♥︎♥︎♥︎v-for key"></a>♥︎♥︎♥︎v-for key</h3><p>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</p>
<p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p>
<p>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. </p>
<p>快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1)</p>
<p>建议使用id，不建议使用索引</p>
<h3 id="♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？"><a href="#♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？" class="headerlink" title="♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？"></a>♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？</h3><p>虚拟DOM中key的作用：<br>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,<br>随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
<p>对比规则：<br>(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。<br>(2).旧虚拟DOM中未找到与新虚拟DOM相同的key<br>创建新的真实DOM，随后渲染到到页面。</p>
<p>用index作为key可能会引发的问题：<br>1.若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br>会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</p>
<p>如果结构中还包含输入类的DOM：<br>会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。</p>
<p>开发中如何选择key?:<br>1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br>使用index作为key是没有问题的。</p>
<h3 id="♥︎♥︎♥︎-Vue的虚拟dom"><a href="#♥︎♥︎♥︎-Vue的虚拟dom" class="headerlink" title="♥︎♥︎♥︎ Vue的虚拟dom"></a>♥︎♥︎♥︎ Vue的虚拟dom</h3><p>从本质来说，Virtual Dom 是一个 JavaScript 对象，通过对象的方式来表示 DOM 结构。将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次 DOM 修改的结果一次性更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p>
<p>虚拟 DOM 是对 DOM 的抽象，这个对象是更加轻量级的对 DOM 的描述。它设计的最初目的就是更好的跨平台，比如 Node.js 就没有 DOM，如果想实现 SSR，那么就只能借助虚拟 DOM，因为虚拟 DOM 本身就是 JS 对象，在代码渲染到页面之前，Vue 和 React 会把代码转化成一个对象（虚拟 DOM），以对象的形式来描述真实 DOM 结构，最终渲染到页面。在每次数据发生变化前，虚拟 DOM 都会缓存一份，变化之时，现在的虚拟 DOM 会与缓存的虚拟 DOM 进行比较。</p>
<p>Vue 和 React 内部都封装了 diff 算法用来进行比较渲染时的变化（具体 diff 算法内容后续重点分析），精准更新发生变化的节点，而没有发生变化的直接通过原先的数据进行渲染。</p>
<p>另外现代前端框架基本都要求无须手动操作 DOM，一方面是因为手动操作 DOM 无法保证程序的性能，多人协作的项目中如果 code review 不严格，很容易出现性能较低的代码，另一方面更重要的是省略手动操作 DOM 可以大大提高开发效率。</p>
<h3 id="♥︎♥︎♥︎diff复杂度原理及具体过程画图"><a href="#♥︎♥︎♥︎diff复杂度原理及具体过程画图" class="headerlink" title="♥︎♥︎♥︎diff复杂度原理及具体过程画图"></a>♥︎♥︎♥︎diff复杂度原理及具体过程画图</h3><p>diff算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。</p>
<p>diff算法有两个比较显著的特点：</p>
<p>1、比较只会在同层级进行, 不会跨层级比较。</p>
<p>2、在diff比较的过程中，循环从两边向中间收拢。</p>
<p>diff流程： 首先定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode的两边的索引。</p>
<p>接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<p>while 循环中会遇到四种情况：</p>
<p>情形一：当新老 VNode 节点的 start 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。</p>
<p>情形二：当新老 VNode 节点的 end 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。</p>
<p>情形三：当老 VNode 节点的 start 和新 VNode 节点的 end 是同一节点时，这说明这次数据更新后oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 patchVnode 后，还需要将当前真实dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1。</p>
<p>情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 是同一节点时，这说明这次数据更新后oldEndVnode 跑到了 oldStartVnode 的前面去了。这时候在 patchVnode 后，还需要将当前真实 dom节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加1。</p>
<p>while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<p>情形一：如果在循环中，oldStartIdx大于oldEndIdx了，那就表示oldChildren比newChildren先循环完毕，那么newChildren里面剩余的节点都是需要新增的节点，把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中</p>
<p>情形二：如果在循环中，newStartIdx大于newEndIdx了，那就表示newChildren比oldChildren先循环完毕，那么oldChildren里面剩余的节点都是需要删除的节点，把[oldStartIdx, oldEndIdx]之间的所有节点都删除</p>
<h3 id="♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法"><a href="#♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法" class="headerlink" title="♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法"></a>♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法</h3><ul>
<li>通过this.$store.state.属性的方法来访问状态</li>
<li>通过this.$store.commit(‘mutation中的方法’) 来修改状态</li>
</ul>
<pre><code class="javascript">// App.vue
&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;
    &lt;button @click=&quot;addition&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;App&#39;,
  computed:&#123;
    count() &#123;
      return this.$store.state.count
    &#125;
  &#125;,
  methods:&#123;
    addition() &#123;
      this.$store.commit(&#39;increment&#39;)
    &#125;,
    decrement() &#123;
      this.$store.commit(&#39;decrement&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="♥︎♥︎♥︎vue-router路由传参的方式"><a href="#♥︎♥︎♥︎vue-router路由传参的方式" class="headerlink" title="♥︎♥︎♥︎vue-router路由传参的方式"></a>♥︎♥︎♥︎vue-router路由传参的方式</h3><p>query</p>
<pre><code class="javascript">this.$router.push(&#123;
 path: &#39;blogDetail&#39;, 
 query: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<p>params</p>
<pre><code class="javascript">this.$router.push(&#123;
 name: &#39;blogDetail&#39;, 
 params: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<h3 id="♥︎♥︎♥︎-hash-history区别"><a href="#♥︎♥︎♥︎-hash-history区别" class="headerlink" title="♥︎♥︎♥︎ hash history区别"></a>♥︎♥︎♥︎ hash history区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">hash</th>
<th align="center">history</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url显示</td>
<td align="center">有#，很Low</td>
<td align="center">无#，好看</td>
</tr>
<tr>
<td align="center">回车刷新</td>
<td align="center">可以加载到hash值对应页面</td>
<td align="center">一般就是404掉了</td>
</tr>
<tr>
<td align="center">支持版本</td>
<td align="center">支持低版本浏览器和IE浏览器</td>
<td align="center">HTML5新推出的API</td>
</tr>
</tbody></table>
<h3 id="♥︎♥︎♥︎-用过beforeEach吗？"><a href="#♥︎♥︎♥︎-用过beforeEach吗？" class="headerlink" title="♥︎♥︎♥︎ 用过beforeEach吗？"></a>♥︎♥︎♥︎ 用过beforeEach吗？</h3><p>每次通过vue-router进行页面跳转，都会触发beforeEach这个钩子函数，这个回调函数共有三个参数，to，from，next这三个参数，to表示我要跳转的目标路由对应的参数，from表示来自那个路由，就是操作路由跳转之前的，即将离开的路由对应的参数，next是一个回调函数，一定要调用next方法来resolve这个钩子函数；</p>
<h3 id="♥︎♥︎♥︎-Vnode的优缺点"><a href="#♥︎♥︎♥︎-Vnode的优缺点" class="headerlink" title="♥︎♥︎♥︎ Vnode的优缺点"></a>♥︎♥︎♥︎ Vnode的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>1、降低浏览器性能消耗</p>
<p>因为Javascript的运算速度远大于DOM操作的执行速度，因此，运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而提高性能。</p>
<blockquote>
<p>在vnode技术出现之前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom，然后修改样式行为或者结构，来达到更新 ui的目的。这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom树。</p>
</blockquote>
<blockquote>
<p>在vnode技术出现之后，我们建立一个虚拟 dom 对象来对应真实的 dom 树，那么每次 dom 的更改就变成了 js 对象的属性的更改 ，这样一来就能查找 js 对象的属性变化要比查询 dom 树的 性能开销小。</p>
</blockquote>
<p>2、diff算法,减少回流和重绘</p>
<p>通过diff算法，优化遍历，对真实dom进行打补丁式的新增、修改、删除，实现局部更新，减少回流和重绘。</p>
<blockquote>
<p>vnode优化性能核心思想，就是每次更新 dom 都尽量避免刷新整个页面，而是有针对性的 去刷新那被更改的一部分，来释放掉被无效渲染占用的 gpu，cup性能。同时，也减少了大量的dom操作，减少了浏览器的回流和重绘。</p>
</blockquote>
<p>3、跨平台</p>
<p>虚拟 DOM 本质上是 JavaScript 对象，而 DOM 与平台强相关，相比之下虚拟 DOM ，可以进行更方便地跨平台操作，例如：<code>服务器渲染、weex 开发</code>等等</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><code>首次显示要慢些</code>:<br>首次渲染大量DOM时，由于多了一层虚拟DOM的计算, 会比innerHTML插入慢</li>
<li><code>无法进行极致优化</code>：<br>虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中 无法进行针对性的极致优化。</li>
</ul>
<h3 id="♥︎♥︎♥︎Vue中的单项数据流"><a href="#♥︎♥︎♥︎Vue中的单项数据流" class="headerlink" title="♥︎♥︎♥︎Vue中的单项数据流"></a>♥︎♥︎♥︎Vue中的单项数据流</h3><p>单向数据流指只能从一个方向来修改状态。</p>
<p>数据从父级组件传递给子组件，只能单向绑定。</p>
<p>子组件内部不能直接修改从父级传递过来的数据。</p>
<h3 id="♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？"><a href="#♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？" class="headerlink" title="♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？"></a>♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？</h3><p>如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p>
<p>所以说vue组件的data必须是函数。这都是因为js的特性带来的，跟vue本身设计无关。</p>
<h3 id="♥︎♥︎♥︎介绍下vue单页面和多页面区别"><a href="#♥︎♥︎♥︎介绍下vue单页面和多页面区别" class="headerlink" title="♥︎♥︎♥︎介绍下vue单页面和多页面区别"></a>♥︎♥︎♥︎介绍下vue单页面和多页面区别</h3><p>单页应用 页面跳转—-&gt;js渲染 优点：页面切换快 缺点：首屏加载稍慢，seo差</p>
<p>多页应用 页面跳转—-&gt;返回html 优点：首屏时间快，seo效果好 缺点：页面切换慢</p>
<h3 id="♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序"><a href="#♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序" class="headerlink" title="♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序"></a>♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序</h3><p>挂载阶段</p>
<blockquote>
<p>执行顺序为：<br>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p>
</blockquote>
<p>更新阶段</p>
<blockquote>
<p>执行顺序为：<br>父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</p>
</blockquote>
<p>销毁阶段</p>
<blockquote>
<p>执行顺序为：<br>父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</p>
</blockquote>
<p>规律就是：父组件先开始执行，然后等到子组件执行完，父组件收尾。</p>
<h3 id="♥︎♥︎♥︎Vue中key的作用？不加会怎么样？"><a href="#♥︎♥︎♥︎Vue中key的作用？不加会怎么样？" class="headerlink" title="♥︎♥︎♥︎Vue中key的作用？不加会怎么样？"></a>♥︎♥︎♥︎Vue中key的作用？不加会怎么样？</h3><p>vue中列表循环需加:key&#x3D;”唯一标识” 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM.</p>
<h3 id="♥︎♥︎♥︎Vue的常用修饰符"><a href="#♥︎♥︎♥︎Vue的常用修饰符" class="headerlink" title="♥︎♥︎♥︎Vue的常用修饰符"></a>♥︎♥︎♥︎Vue的常用修饰符</h3><blockquote>
<ol>
<li>事件修饰符 - 处理 DOM 事件细节</li>
<li>按键修饰符 - 为 v-on 在监听键盘事件时添加按键修饰符</li>
<li>系统修饰键 - 实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</li>
<li>鼠标按钮修饰符 - 限制处理函数仅响应特定的鼠标按键</li>
<li>表单修饰符 - v-model增强的修饰符</li>
</ol>
</blockquote>
<h4 id="一、事件修饰符"><a href="#一、事件修饰符" class="headerlink" title="一、事件修饰符"></a>一、事件修饰符</h4><ol>
<li><p>.stop - 阻止单击事件继续传播, 也就是阻止冒泡</p>
</li>
<li><p>.prevent - 提交事件不再重新加载页面, 可以用来阻止表单提交的默认行为</p>
</li>
</ol>
<blockquote>
<p>注意点: .stop和.prevent可以串联在一起使用,都会生效</p>
</blockquote>
<ol start="3">
<li><p>.capture - 内部元素触发的事件先在此处理，然后才交由内部元素进行处理</p>
</li>
<li><p>.self - 只当在 event.target 是当前元素自身时触发处理函数,即事件不是从内部元素触发的</p>
</li>
</ol>
<blockquote>
<p>注意点: 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p>
</blockquote>
<ol start="5">
<li><p>.once - 点击事件将只会触发一次, 不只能对原生DOM时间生效,还可以用在自定义组件上</p>
</li>
<li><p>.passive - 立即触发默认行为,能够提升移动端性能,和.prevent一起使用时.prevent会被忽略并警告</p>
</li>
<li><p>.native - 使用时将被当做原生的HTML标签看待,绑定事件可以生效</p>
</li>
</ol>
<h4 id="二、按键修饰符"><a href="#二、按键修饰符" class="headerlink" title="二、按键修饰符"></a>二、按键修饰符</h4><ol>
<li><p>.keyup - 键盘抬起</p>
</li>
<li><p>.keydow - 键盘按下</p>
</li>
<li><p>按键码 - 在按键修饰符后面添加,用于监听键盘按下哪个键</p>
</li>
</ol>
<p>常用按键码: </p>
<ul>
<li><p>.enter</p>
</li>
<li><p>.tab</p>
</li>
<li><p>.delete (捕获“删除”和“退格”键)</p>
</li>
<li><p>.esc</p>
</li>
<li><p>.space</p>
</li>
<li><p>.up</p>
</li>
<li><p>.down</p>
</li>
<li><p>.left</p>
</li>
<li><p>.right</p>
</li>
</ul>
<h4 id="三、系统修饰键"><a href="#三、系统修饰键" class="headerlink" title="三、系统修饰键"></a>三、系统修饰键</h4><ul>
<li><p>.ctrl</p>
</li>
<li><p>.alt</p>
</li>
<li><p>.shift</p>
</li>
<li><p>.meta</p>
</li>
</ul>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<blockquote>
<p>注意点: 修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。<br>.exact 修饰符 - 使用系统修饰符时使用可以单击系统修饰键触发,不适用系统修饰符时使用</p>
</blockquote>
<h4 id="四、鼠标按键修饰符"><a href="#四、鼠标按键修饰符" class="headerlink" title="四、鼠标按键修饰符"></a>四、鼠标按键修饰符</h4><p>.left - 只有鼠标左键点击触发<br>.right - 只有鼠标右键点击触发<br>.middle - 只有鼠标中键点击触发</p>
<h4 id="五、表单修饰符"><a href="#五、表单修饰符" class="headerlink" title="五、表单修饰符"></a>五、表单修饰符</h4><ol>
<li><p>.lazy - 在表单输入时不会马上显示在页面,而是等输入完成失去焦点时才会显示在页面</p>
</li>
<li><p>.trim - 过滤表单输入时前后的空格</p>
</li>
<li><p>.number - 限制输入数字或将输入的数据转为数字</p>
</li>
</ol>
<blockquote>
<p>注意点: 如果先输入数字,会限制只能输数字, 如果先输字符串则相当于没加.number</p>
</blockquote>
<h3 id="♥︎♥︎♥︎Vue计算属性和-Watch-的区别"><a href="#♥︎♥︎♥︎Vue计算属性和-Watch-的区别" class="headerlink" title="♥︎♥︎♥︎Vue计算属性和 Watch 的区别"></a>♥︎♥︎♥︎Vue计算属性和 <strong>Watch</strong> 的区别</h3><p>methods（方法）：</p>
<p>只要进行调用就会执行，不管依赖的值有没有改变。无缓存。</p>
<p>computed（计算属性)：</p>
<p>监听其所有依赖的变化，如果有变化会执行，没有变化不执行。有缓存，不用每次重新算。不支持异步。</p>
<p>详解:在vue的 模板内是可以写一些简单的js表达式的 ，很便利。但是如果在页面中使用大量或是复杂的表达式去处理数据，对页面的维护会有很大的影响。这个时候就需要用到computed 计算属性来处理复杂的逻辑运算。</p>
<p>1.优点：</p>
<p>在数据未发生变化时，优先读取缓存。computed 计算属性只有在相关的数据发生变化时才会改变要计算的属性，当相关数据没有变化是，它会读取缓存。而不必想 motheds方法 和 watch 方法是否每次都去执行函数。</p>
<p>2.setter 和 getter方法：（注意在vue中书写时用set 和 get）</p>
<p>setter 方法在设置值是触发。</p>
<p>getter 方法在获取值时触发。</p>
<p>watch（侦听属性）:</p>
<p>观察某一个变量，发生变化会执行。支持异步。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>
<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。</p>
<p>❕小结：</p>
<p>1.主动调用的方法写在methods里，依据某些变量的更新进行某种操作用computed或者watch。</p>
<p>2.computed和watch：如果要异步，只能用watch。如果是计算某个值推荐用computed，比如购物车全选单选功能，购物车计算总价小计功能。</p>
<h3 id="♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？"><a href="#♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？" class="headerlink" title="♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？"></a>♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？</h3><p>vue中v-on是可以绑定多个方法的</p>
<p>1、v-on绑定多个方法（采用的是对象形式）</p>
<pre><code class="html">&lt;button v-on=&quot;&#123;click: clickMethods, mousemove: mouseMethods&#125;&quot;&gt;按钮&lt;button&gt;
</code></pre>
<p>2.v-on 一个事件绑定多个方法 （语法糖 @）</p>
<pre><code class="html">&lt;button @click=&quot;click1,click2&quot;&gt;按钮&lt;/button&gt;
</code></pre>
<h3 id="♥︎♥︎♥︎Vue中template的编译过程"><a href="#♥︎♥︎♥︎Vue中template的编译过程" class="headerlink" title="♥︎♥︎♥︎Vue中template的编译过程"></a>♥︎♥︎♥︎Vue中template的编译过程</h3><p>vue template模板编译的过程经过parse()生成ast(抽象语法树),optimize对静态节点优化，generate()生 成render字符串 之后调用new Watcher()函数，用来监听数据的变化，render 函数就是数据监听的回调,所调用的，其结果便是重新生成 vnode。 当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。 如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode做 diff，对内容做改动之后，就会更新到 我们真正的 DOM</p>
<h3 id="♥︎♥︎♥︎Vue中router-link和传统a链接的区别？"><a href="#♥︎♥︎♥︎Vue中router-link和传统a链接的区别？" class="headerlink" title="♥︎♥︎♥︎Vue中router-link和传统a链接的区别？"></a>♥︎♥︎♥︎Vue中router-link和传统a链接的区别？</h3><p>组件支持用户在具有路由功能的应用中 (点击) 导航。 </p>
<p>通过 to 属性指定目标地址，默认渲染成带有正确链接的 标签，可以通过配置 tag 属性生成别的标签.。 </p>
<p>通过router-link进行跳转不会跳转到新的页面，也不会重新渲染，它会选择路由所指的组件进行渲染，避免了重复渲染的“无用功”。 </p>
<p>总结：对比，router-link组件避免了不必要的重渲染,它只更新变化的部分从而减少DOM性能消耗</p>
<h3 id="♥︎♥︎♥︎-Vue插槽是什么？"><a href="#♥︎♥︎♥︎-Vue插槽是什么？" class="headerlink" title="♥︎♥︎♥︎ Vue插槽是什么？"></a>♥︎♥︎♥︎ Vue插槽是什么？</h3><p>slot用于封装组件中，写在子组件 接收父组件动态传递子组件内容片断</p>
<p>slot插槽的使用方法其实就是类似于一个子组件或者标签的引用的过程，在父组件里面定义一个slot，给她起个name，然后组件引入到子组件，子组件里面有个元素的属性slot值等于name，然后父组件里面没有值的时候就可以显示子组件里面的信息了（切记：插槽slot要写在父组件里面！！！）</p>
<h3 id="♥︎♥︎♥︎-说一下Vue-router守卫有哪些。如何实现路由懒加载？"><a href="#♥︎♥︎♥︎-说一下Vue-router守卫有哪些。如何实现路由懒加载？" class="headerlink" title="♥︎♥︎♥︎ 说一下Vue-router守卫有哪些。如何实现路由懒加载？"></a>♥︎♥︎♥︎ 说一下Vue-router守卫有哪些。如何实现路由懒加载？</h3><ul>
<li>router.beforeEach 全局前置守卫 进入路由之前</li>
<li>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用</li>
<li>router.afterEach 全局后置钩子 进入路由之后</li>
</ul>
<p>1、 Vue异步加载技术</p>
<blockquote>
<p>1：vue-router配置路由，使用vue的异步组件技术，可以实现懒加载，此时一个组件会生成一个js文件。 </p>
<p>2：component: resolve &#x3D;&gt; require([‘放入需要加载的路由地址’], resolve)</p>
</blockquote>
<p>2、 ES6推荐方式imprort ()—-推荐使用</p>
<pre><code class="javascript">import Vue from &#39;vue&#39;;
import Router from &#39;vue-router&#39;;
// 官网可知：下面没有指定webpackChunkName，每个组件打包成一个js文件。
const Foo = () =&gt; import(&#39;../components/Foo&#39;)
const Aoo = () =&gt; import(&#39;../components/Aoo&#39;)
// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。
// const Foo = () =&gt; import(/* webpackChunkName: &#39;ImportFuncDemo&#39; / &#39;../components/Foo&#39;)
// const Aoo = () =&gt; import(/ webpackChunkName: &#39;ImportFuncDemo&#39; */ &#39;../components/Aoo&#39;)
export default new Router(&#123;
 routes: [
 &#123;
 path: &#39;/Foo&#39;,
 name: &#39;Foo&#39;,
 component: Foo
 &#125;,
 &#123;
 path: &#39;/Aoo&#39;,
 name: &#39;Aoo&#39;,
 component: Aoo
 &#125;
 ]
&#125;)
</code></pre>
<p>3、 webpack提供的require.ensure()实现懒加载</p>
<ul>
<li>1：vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。</li>
<li>2：这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</li>
<li>3：require.ensure可实现按需加载资源，包括js,css等。他会给里面require的文件单独打包，不会和主文件打包在一起。</li>
<li>4：第一个参数是数组，表明第二个参数里需要依赖的模块，这些会提前加载。</li>
<li>5：第二个是回调函数,在这个回调函数里面require的文件会被单独打包成一个chunk,不会和主文件打包在一起，这样就生成了两个chunk,第一次加载时只加载主文件。</li>
<li>6：第三个参数是错误回调。</li>
<li>7：第四个参数是单独打包的chunk的文件名</li>
</ul>
<pre><code class="javascript">import Vue from &#39;vue&#39;;
import Router from &#39;vue-router&#39;;
const HelloWorld=resolve=&gt;&#123;
 require.ensure([&#39;@/components/HelloWorld&#39;],()=&gt;&#123;
 resolve(require(&#39;@/components/HelloWorld&#39;))
 &#125;)
 &#125;
Vue.use(&#39;Router&#39;)
export default new Router(&#123;
 routes:[&#123;
 &#123;path:&#39;./&#39;,
 name:&#39;HelloWorld&#39;,
 component:HelloWorld
 &#125;
 &#125;]
&#125;)
</code></pre>
<h3 id="♥︎♥︎♥︎什么是Vue-js动态组件与异步组件？"><a href="#♥︎♥︎♥︎什么是Vue-js动态组件与异步组件？" class="headerlink" title="♥︎♥︎♥︎什么是Vue.js动态组件与异步组件？"></a>♥︎♥︎♥︎什么是Vue.js动态组件与异步组件？</h3><h4 id="1-动态组件"><a href="#1-动态组件" class="headerlink" title="1.动态组件"></a>1.动态组件</h4><ul>
<li>:is &#x3D; “component-name” 用法</li>
<li>需要根据数据，动态渲染的场景。即组件类型不确定</li>
</ul>
<pre><code class="html">//代码实例
&lt;template&gt;
  &lt;div&gt;
      &lt;p&gt;vue高级特性&lt;/p&gt;
      &lt;hr&gt;
      &lt;!-- 动态组件 --&gt;
      &lt;component :is=&quot;NextTickName&quot;&gt;&lt;/component&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
&lt;/style&gt;
</code></pre>
<pre><code class="javascript">&lt;script&gt;
import NextTick from &#39;./nextTick&#39;
export default &#123;
  components: &#123;
    NextTick
  &#125;,
  data () &#123;
    return &#123;
      name: &#39;夹心&#39;,
      website: &#123;
        url: &#39;http://imooc.com/&#39;,
        title: &#39;imooc&#39;,
        subTitle: &#39;程序员的梦工厂&#39;
      &#125;,
      NextTickName: &#39;NextTick&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h4 id="2-异步组件"><a href="#2-异步组件" class="headerlink" title="2.异步组件"></a>2.异步组件</h4><ul>
<li>import() 函数</li>
<li>按需加载，异步加载大组件</li>
</ul>
<pre><code class="javascript">export default &#123;
  components: &#123;
    FormDemo: () =&gt; import(&#39;../components/FormDemo&#39;)
  &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式"><a href="#♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式" class="headerlink" title="♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式"></a>♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式</h3><p>1、路由跳转</p>
<p>router-link组件 默认会被渲染成一个 标签，进行跳转，在组件中可以通过绑定to属性来指定要跳转的链接；tag属性指本来的标签</p>
<blockquote>
<p>$router.push()方法</p>
</blockquote>
<p>2、路由传参</p>
<p>query</p>
<pre><code class="javascript">this.$router.push(&#123;
 path: &#39;blogDetail&#39;, 
 query: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<p>params</p>
<pre><code class="javascript">this.$router.push(&#123;
 name: &#39;blogDetail&#39;, 
 params: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<h3 id="♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3-0与Vue2-0对比"><a href="#♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3-0与Vue2-0对比" class="headerlink" title="♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3.0与Vue2.0对比)"></a>♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3.0与Vue2.0对比)</h3><p>[Vue3.0与Vue2.0区别]: 	“<a href="https://zhuanlan.zhihu.com/p/389421424">https://zhuanlan.zhihu.com/p/389421424</a>  “</p>
<h4 id="一、六大亮点"><a href="#一、六大亮点" class="headerlink" title="一、六大亮点"></a>一、六大亮点</h4><p>性能比vue2.x快1.2~2倍</p>
<p>支持tree-shaking，按需编译，体积比vue2.x更小</p>
<p>支持组合API</p>
<p>更好的支持TS</p>
<p>更先进的组件</p>
<h4 id="二、性能比vue2-x快1-2-2倍如何实现的呢"><a href="#二、性能比vue2-x快1-2-2倍如何实现的呢" class="headerlink" title="二、性能比vue2.x快1.2~2倍如何实现的呢"></a>二、性能比vue2.x快1.2~2倍如何实现的呢</h4><p>1.diff算法更快</p>
<p>vue2.0是需要全局去比较每个节点的，若发现有节点发生变化后，就去更新该节点</p>
<p>vue3.0是在创建虚拟dom中，会根据DOM的的内容会不会发生内容变化，添加静态标记， 谁有flag！比较谁。</p>
<p>2、静态提升</p>
<p>vue2中无论元素是否参与更新，每次都会重新创建，然后再渲染 vue3中对于不参与更新的元素，会做静态提升，只被创建一次，在渲染时直接复用即可</p>
<p>3、事件侦听缓存默认情况下，onclick为动态绑定，所以每次都会追踪它的变化，但是因为是同一函数，没有必要追踪变化，直接缓存复用即可在之前会添加静态标记8 会把点击事件当做动态属性 会进行diff算法比较， 但是在事件监听缓存之后就没有静态标记了，就会进行缓存复用</p>
<h4 id="三、为什么vue3-0体积比vue2-x小"><a href="#三、为什么vue3-0体积比vue2-x小" class="headerlink" title="三、为什么vue3.0体积比vue2.x小"></a>三、为什么vue3.0体积比vue2.x小</h4><p>在vue3.0中创建vue项目 除了vue-cli，webpack外还有 一种创建方法是Vite Vite是作者开发的一款有意取代webpack的工具，其实现原理是利用ES6的import会发送请求去加载文件的特性，拦截这些请求，做一些预编译，省去webpack冗长的打包时间</p>
<h4 id="四、vue3-0组合API"><a href="#四、vue3-0组合API" class="headerlink" title="四、vue3.0组合API"></a>四、vue3.0组合API</h4><p>1.说一说vue3.0的组合API跟之前vue2.0在完成业务逻辑上的区别：</p>
<p>在vue2.0中： 主要是往data 和method里面添加内容，一个业务逻辑需要什么data和method就往里面添加，而组合API就是 有一个自己的方法，里面有自己专注的data 和method。</p>
<p>2.再说一下组合API的本质是什么： 首先composition API（组合API） 和 Option API（vue2.0中的data和method）可以共用 composition API（组合API）本质就是把内容添加到Option API中进行使用</p>
<h4 id="五、ref和reactive的简单理解"><a href="#五、ref和reactive的简单理解" class="headerlink" title="五、ref和reactive的简单理解"></a>五、ref和reactive的简单理解</h4><p>1.ref和reactive都是vue3的监听数据的方法，本质是proxy </p>
<p>2.ref 基本类型复杂类型都可以监听(我们一般用ref监听基本类型)，reactive只能监听对象（arr，json） </p>
<p>3.ref底层还是reactive</p>
<h4 id="六、对生命周期的监听（ref获取属性）"><a href="#六、对生命周期的监听（ref获取属性）" class="headerlink" title="六、对生命周期的监听（ref获取属性）"></a>六、对生命周期的监听（ref获取属性）</h4><h4 id="七、proxy响应式本质"><a href="#七、proxy响应式本质" class="headerlink" title="七、proxy响应式本质"></a>七、proxy响应式本质</h4><h3 id="♥︎♥︎♥︎v-if和v-show的区别"><a href="#♥︎♥︎♥︎v-if和v-show的区别" class="headerlink" title="♥︎♥︎♥︎v-if和v-show的区别"></a>♥︎♥︎♥︎v-if和v-show的区别</h3><p>1、手段：v-if是动态的向DOM树添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显示和隐藏。</p>
<p>2、编译过程：v-if切换有一个局部编译&#x2F;卸载的过程， 切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换。</p>
<p>3、编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留</p>
<p>4、性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换</p>
<p>6、相同点： v-show 都可以动态控制着dom元素的显示隐藏 </p>
<p>​    不同点： v-if 的显示隐藏是将DOM元素整个添加或删除，v-show 的显示隐藏是为DOM元素添</p>
<p>7、加css的样式display，设置none或者是block，DOM元素是还存在的</p>
<p>8、在渲染多个元素的时候，可以把一个 元素作为包装元素，并使用v-if 进行条件判断，最终的渲染不会包含这个元素，v-show是不支持 语法</p>
<h3 id="♥︎♥︎♥︎-简述Vue每个生命周期具体适合哪些场景"><a href="#♥︎♥︎♥︎-简述Vue每个生命周期具体适合哪些场景" class="headerlink" title="♥︎♥︎♥︎ 简述Vue每个生命周期具体适合哪些场景"></a>♥︎♥︎♥︎ 简述Vue每个生命周期具体适合哪些场景</h3><table>
<thead>
<tr>
<th align="center">钩子函数</th>
<th align="center">具体发生了什么</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beforeCreate</td>
<td align="center">初始化界面前 : 在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问，都还没有完成初始化。</td>
</tr>
<tr>
<td align="center">created</td>
<td align="center">初始化界面后 : 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数,也就是不会更新视图。实例的data数据和methods方法都已经被初始化完毕了，可以正常访问</td>
</tr>
<tr>
<td align="center">beforeMount</td>
<td align="center">挂载前 ：完成模板编译，虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。数据还没有更新到页面上去。当编译完成之后，只是在内存中已经有了编译好的页面，但并未渲染。</td>
</tr>
<tr>
<td align="center">mounted</td>
<td align="center">挂载完成 ： 将编译好的模板挂载到页面 (虚拟DOM挂载) ，可以在这进行异步请求以及DOM节点的访问，在vue用$ref操作</td>
</tr>
<tr>
<td align="center">beforeUpdate</td>
<td align="center">更新数据前 ： 组件数据更新之前调用，数据都是新的,页面上数据都是旧的。将要根据最新的data数据，重新解析所有指令，从而重新渲染浏览器页面。</td>
</tr>
<tr>
<td align="center">updated</td>
<td align="center">组件更新后 ： render重新渲染 , 此时数据和界面都是新的 ,要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新</td>
</tr>
<tr>
<td align="center">beforeDestroy</td>
<td align="center">组件卸载前 : 实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器</td>
</tr>
<tr>
<td align="center">destroyed</td>
<td align="center">组件卸载后 ： 组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</td>
</tr>
<tr>
<td align="center">activited</td>
<td align="center">keep-alive 专属 , 组件被激活时调用</td>
</tr>
<tr>
<td align="center">deactivated</td>
<td align="center">keep-alive 专属 , 组件被销毁时调用</td>
</tr>
</tbody></table>
<h3 id="♥︎♥︎♥︎-什么是v-model？它的原理是什么？"><a href="#♥︎♥︎♥︎-什么是v-model？它的原理是什么？" class="headerlink" title="♥︎♥︎♥︎ 什么是v-model？它的原理是什么？"></a>♥︎♥︎♥︎ 什么是v-model？它的原理是什么？</h3><p>1、v-model本质上是一个语法糖，可以看成是value + input 方法的语法糖。可以通过model的prop属性和event事件来进行自定义。</p>
<p>2、v-model是vue的双向绑定的指令，能将页面上控件输入的值同步更新到相关绑定的data属性， 也会在更新data绑定属性时候，更新页面上输入控件的值。</p>
<h3 id="♥︎♥︎♥︎简单说一下-微信小程序-与Vue的区别（了解即可，具体区别请看各自具体部分）"><a href="#♥︎♥︎♥︎简单说一下-微信小程序-与Vue的区别（了解即可，具体区别请看各自具体部分）" class="headerlink" title="♥︎♥︎♥︎简单说一下 微信小程序 与Vue的区别（了解即可，具体区别请看各自具体部分）"></a>♥︎♥︎♥︎简单说一下 微信小程序 与Vue的区别（了解即可，具体区别请看各自具体部分）</h3><p>1、生命周期：</p>
<p>小程序的钩子函数要简单得多 。 vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。</p>
<p>在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。</p>
<p>2、数据绑定：</p>
<p>vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：</p>
<p>小程序 绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串</p>
<p>3、列表循环</p>
<p>4、显示与隐藏元素</p>
<p>vue中，使用v-if 和v-show控制元素的显示和隐藏</p>
<p>小程序中，使用wx-if和hidden控制元素的显示和隐藏</p>
<p>5、事件处理</p>
<p>vue：使用v-on:event绑定事件，或者使用@event绑定事件</p>
<p>小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件</p>
<p>6、数据的双向绑定</p>
<p>在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变 。</p>
<p>当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值 。 </p>
<p>7、绑定事件传参</p>
<p>在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了</p>
<p>在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取</p>
<p>8、父子组件通信</p>
<p>父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量 在子组件properties中，接收传递的值</p>
<h3 id="♥︎♥︎♥︎Vue的组件通信"><a href="#♥︎♥︎♥︎Vue的组件通信" class="headerlink" title="♥︎♥︎♥︎Vue的组件通信"></a>♥︎♥︎♥︎Vue的组件通信</h3><p>1、props和$emit</p>
<p>父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件</p>
<p>2、$attrs和$listeners</p>
<p>3、中央事件总线 bus</p>
<p>上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。</p>
<p>4、provide和inject</p>
<p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p>
<p>5、v-model</p>
<p>父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</p>
<p>6、$parent和$children</p>
<p>7、boradcast和dispatch</p>
<p>8、vuex处理组件之间的数据交互 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>
<h3 id="♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？"><a href="#♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？" class="headerlink" title="♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？"></a>♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？</h3><p>现在 我们需要实现这样 一个功能，登录拦截，其实就是 路由拦截，首先在定义路由的时候就需要多添加一个自定义字段requireAuth，用于判断该路由的访问是否需要登录。如果用户已经登录，则顺利进入路由， 否则就进入登录页面。在路由管理页面添加meta字段</p>
<pre><code class="javascript">&#123;
 path:&#39;/manage&#39;,
 name:&#39;manage&#39;,
 component:manage,
 meta:&#123;requireAuth:true&#125;
&#125;
</code></pre>
<p>在入口文件中，添加路由守卫</p>
<p>先判断该路由是否需要登录权限</p>
<p>判断本地是否存在token，如果存在token就next()，不存在token重定向到登录页</p>
<h3 id="♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。"><a href="#♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。" class="headerlink" title="♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。"></a>♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。</h3><p>Redux和Vuex区别</p>
<p>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值就可以</p>
<p>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state就可以</p>
<p>Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数 – store改变(vue检测到数据变化自动渲染)</p>
<p>共同思想</p>
<ul>
<li>单一的数据源</li>
<li>变化可以预测</li>
<li>本质上:Redux和Vuex都是对MVVM思想的服务，将数据从视图中抽离的一种方案</li>
<li>形式上:Vuex借鉴了Redux，将store作为全局的数据中心，进行数据管理</li>
</ul>
<hr>
<h3 id="♥︎♥︎♥︎♥︎Composition-API的出现带来哪些新的开发体验，为啥需要这个？"><a href="#♥︎♥︎♥︎♥︎Composition-API的出现带来哪些新的开发体验，为啥需要这个？" class="headerlink" title="♥︎♥︎♥︎♥︎Composition API的出现带来哪些新的开发体验，为啥需要这个？"></a>♥︎♥︎♥︎♥︎Composition API的出现带来哪些新的开发体验，为啥需要这个？</h3><p>1：在Compostion API 中时根据逻辑相关组织代码的，提高可读性和可维护性，类似于react的hook写法。</p>
<p>2：更好的重用逻辑代码，在Options API中通过MIxins重用逻辑代码，容易发生命名冲突且关系不清。</p>
<p>3：解决在生命周期函数经常包含不相关的逻辑，但又不得不把相关逻辑分离到了几个不同方法中的问题，如在mounted中设置定时器，但需要在destroyed中来清除定时器，将同一功能的代码拆分到不同的位置，造成后期代码维护的困难。</p>
<h3 id="♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作"><a href="#♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作" class="headerlink" title="♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作"></a>♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作</h3><p>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，否则无法被devtools所监测。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>
<h3 id="♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法"><a href="#♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法" class="headerlink" title="♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法"></a>♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法</h3><p>[封装vue组件的原则和技巧]: 	“<a href="https://blog.csdn.net/leilei__66/article/details/119348108">https://blog.csdn.net/leilei__66/article/details/119348108</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎Object-defineProperty有什么缺点"><a href="#♥︎♥︎♥︎♥︎Object-defineProperty有什么缺点" class="headerlink" title="♥︎♥︎♥︎♥︎Object.defineProperty有什么缺点"></a>♥︎♥︎♥︎♥︎Object.defineProperty有什么缺点</h3><p>1：无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</p>
<p>2：只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。</p>
<h3 id="♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程"><a href="#♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程" class="headerlink" title="♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程?"></a>♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程?</h3><p>axios 是请求后台资源的模块。 </p>
<p>通过npm install axios -S来安装，在大多数情况下我们需要封装拦截器。</p>
<p>在实现登录的过程中我们一般在请求拦截器中来加入token，在响应请求器中通过判断后端返回的状态码来对返回的数据进行不同的处理。如果发送的是跨域请求，需在配置文件中 config&#x2F;index.js 进行代理配置。</p>
<h3 id="♥︎♥︎♥︎♥︎-computed和watcher的区别？watch实现原理？watch有几种写法？"><a href="#♥︎♥︎♥︎♥︎-computed和watcher的区别？watch实现原理？watch有几种写法？" class="headerlink" title="♥︎♥︎♥︎♥︎ computed和watcher的区别？watch实现原理？watch有几种写法？"></a>♥︎♥︎♥︎♥︎ computed和watcher的区别？watch实现原理？watch有几种写法？</h3><p>计算属性computed :</p>
<ol>
<li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li>
<li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li>
<li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>
<li>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li>
</ol>
<p>侦听属性watch： </p>
<ol>
<li>不支持缓存，数据变，直接会触发相应的操作；</li>
<li>watch支持异步；</li>
<li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li>
<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>
<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</li>
</ol>
<p>immediate：组件加载立即触发回调函数执行，</p>
<p>deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。</p>
<p>注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p>
<p>watch工作原理:</p>
<p>watch在一开始初始化的时候，会读取一遍监听的数据的值，此时那个数据就收集到watch的watcher了，然后你给watch设置的handler，watch 会放入watcher的更新函数中，当数据改变时，通知watch的watcher进行更新，于是你设置的handler就被调用了。</p>
<h3 id="♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？"><a href="#♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？" class="headerlink" title="♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？"></a>♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？</h3><p>评估项目成员的水平，如果成员js基础较好、编码能力较强则选择React，否则Vue。</p>
<p>评估系统的大小，如果想构建生态系统，则选择React，如果要求而快，简单和“能用就行”,则选择Vue。</p>
<p>评估系统运行环境，如果你想要一个同时适用于Web端和原生APP的框架，请选择React(RN)。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue和React区别"><a href="#♥︎♥︎♥︎♥︎Vue和React区别" class="headerlink" title="♥︎♥︎♥︎♥︎Vue和React区别"></a>♥︎♥︎♥︎♥︎Vue和React区别</h3><p>1：Vue 使用的是 web 开发者更熟悉的模板与特性，Vue的API跟传统web开发者熟悉的模板契合度更高，比如Vue的单文件组件是以模板+JavaScript+CSS的组合模式呈现，它跟web现有的HTML、JavaScript、CSS能够更好地配合。React 的特色在于函数式编程的理念和丰富的技术选型，Vue更加注重web开发者的习惯。</p>
<p>2：Vue跟React的最大区别在于数据的reactivity，就是反应式系统上。Vue提供反应式的数据，当数据改动时，界面就会自动更新，而React里面需要调用方法SetState。我把两者分别称为Push-based和Pull-based</p>
<h3 id="♥︎♥︎♥︎♥︎Vue路由实现的底层原理"><a href="#♥︎♥︎♥︎♥︎Vue路由实现的底层原理" class="headerlink" title="♥︎♥︎♥︎♥︎Vue路由实现的底层原理"></a>♥︎♥︎♥︎♥︎Vue路由实现的底层原理</h3><p>在Vue中利用数据劫持defineProperty在原型prototype上初始化了一些getter,分别是router代表当前Router的实例 、route 代表当前Router的信息。在install中也全局注册了router-view,router-link,其中的Vue.util.defineReactive, 这是Vue里面观察者劫持数据的方法，劫持<em>route</em>，当route触发setter方法的时候，则会通知到依赖的组件。</p>
<p>接下来在init中，会挂载判断是路由的模式，是history或者是hash,点击行为按钮，调用hashchange或 者popstate的同时更*route,*route的更新会触发route-view的重新渲染。</p>
<h3 id="♥︎♥︎♥︎♥︎如何封装一个通用组件"><a href="#♥︎♥︎♥︎♥︎如何封装一个通用组件" class="headerlink" title="♥︎♥︎♥︎♥︎如何封装一个通用组件"></a>♥︎♥︎♥︎♥︎如何封装一个通用组件</h3><p>通用组件的封装就是对可复用组件的解耦和样式复用，为了解耦一般数据都是通过父组件传递过来，在子组件中进行数据处理，对于一些较为复杂的数据可能还需要做数据验证，为了避免高耦合，逻辑最好放在父组件中，通过自定义事件将数据回传，子组件只是一个承载体，这样既降低耦合，保证子组件中数据和逻辑不会混乱。如果同一组件需要适应不同需求时，我们需要配合slot来使用，可以通过具名插槽灵活地解决了不同场景同一组件不同配置的问题。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue-proxy的原理"><a href="#♥︎♥︎♥︎♥︎Vue-proxy的原理" class="headerlink" title="♥︎♥︎♥︎♥︎Vue proxy的原理"></a>♥︎♥︎♥︎♥︎Vue proxy的原理</h3><p>主要通过Proxy对对象进行绑定监听处理，通过new Map对对象的属性操作进行处理，将要执行的函数匹配到存到对应的prop上面，通过每次的访问触发get方法，进行存方法的操作，通过修改触发set的方法，此时执行回调监听的函数，这样达到修改数据和视图的</p>
<h3 id="♥︎♥︎♥︎♥︎-defineProperty在数据劫持后是如何通知数据的更新和视图的更新的"><a href="#♥︎♥︎♥︎♥︎-defineProperty在数据劫持后是如何通知数据的更新和视图的更新的" class="headerlink" title="♥︎♥︎♥︎♥︎ defineProperty在数据劫持后是如何通知数据的更新和视图的更新的"></a>♥︎♥︎♥︎♥︎ defineProperty在数据劫持后是如何通知数据的更新和视图的更新的</h3><p>vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的，那么什么是数据劫持？vue是如何进行数据劫持的？说白了就是通过Object.defineProperty()来劫持对象属性的setter和getter操作，在数据变动时做你想要做的事情</p>
<p>我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发生变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：</p>
<p>1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p>
<p>2.实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。</p>
<p>3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的"><a href="#♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的" class="headerlink" title="♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的"></a>♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的</h3><p>[Vue虚拟DOM以及diff算法]: 	“<a href="https://blog.csdn.net/wytraining/article/details/110831015">https://blog.csdn.net/wytraining/article/details/110831015</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听"><a href="#♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听" class="headerlink" title="♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听"></a>♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听</h3><p>[Vuex跨组价的数据监听]: 	“<a href="https://blog.csdn.net/Flowering_Vivian/article/details/108868907">https://blog.csdn.net/Flowering_Vivian/article/details/108868907</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的"><a href="#♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的" class="headerlink" title="♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的"></a>♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的</h3><pre><code class="javascript">// 使用axios用于对数据的请求
import axios from &#39;axios&#39;
// 创建axios实例
const instance = axios.create(&#123;
 baseURL: baseURL + version,
 timeout: 5000
&#125;)
// 创建请求的拦截器
instance.interceptors.request.use(config =&gt; &#123;
 config.headers[&#39;Authorization&#39;] = localStorage.getItem(&#39;token&#39;)
 return config
&#125;, error =&gt; &#123;
 return Promise.reject(error)
&#125;)
// 创建响应的拦截器
instance.interceptors.response.use(response =&gt; &#123;
 let res = null
 // 对相应的数据进行过滤
 if (response.status === 200) &#123;
 if (response.data &amp;&amp; response.data.err === 0) &#123;
 res = response.data.data
 &#125; else if (response.data.err === -1) &#123;
 return alert(&#39;token无效&#39;)
 &#125;
 &#125; else &#123;
 return alert(&#39;请求失败&#39;)
 &#125;
 return res
&#125;, error =&gt; &#123;
 return Promise.reject(error)
&#125;)
export default instance
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？"><a href="#♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？" class="headerlink" title="♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？"></a>♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？</h3><p>1、虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom 的 diff 算法避免了没有必要的 dom 操作，从而提高性能。<br>2、用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中，当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue的computed的原理"><a href="#♥︎♥︎♥︎♥︎Vue的computed的原理" class="headerlink" title="♥︎♥︎♥︎♥︎Vue的computed的原理"></a>♥︎♥︎♥︎♥︎Vue的computed的原理</h3><h4 id="1-computed大致流程"><a href="#1-computed大致流程" class="headerlink" title="1.computed大致流程"></a>1.computed大致流程</h4><p>computed是vue中的计算属性，在依赖的值发生变化的时候进行重新计算，否则使用缓存。</p>
<p>前面说到computed只有在依赖发生变化才会重新计算，那么如何得知computed的值发生了变化呢</p>
<p>这主要是Watcher中的dirty属性，dirty属性为true时，说明computed中的值需要重新计算，dirty为false时，则说明依赖没有变化，不需要重新计算</p>
<p>当计算属性的值发生变化时，计算属性的watcher和组件的watcher都会得到通知。</p>
<p>计算属性的watcher会将dirty置为true,组件的Watcher得到通知，同样将dirty属性置为false,重新计算值，用于本次渲染。</p>
<p>简单来说,computed就是定义在vm上的一个getter属性，这个getter属性被触发时会做两件事</p>
<ol>
<li>计算当前属性的值，此时会使用Watcher去观察计算属性中用到的所有其他数据的变化。同时将计算属性的Watcher的dirty属性设置为false.</li>
</ol>
<p>2.当计算属性中用到的数据发生变化时,将得到通知从而进行重新渲染</p>
<p>Watcher中的depend和evaluate方法是专门用于实现计算属性的两个API</p>
<pre><code class="javascript">export default class Watcher &#123;
     constructor(vm, expOrFn, cb, options) &#123;
         if(options) &#123;
             this.lazy = !!options.lazy;
         &#125;  else &#123;
             this.lazy = false;
         &#125;
         this.dirty = this.lazy;
         this.value = this.lazy ? undefined : this.get()
     &#125;
     evaluate() &#123;
        this.value = this.get()
        this.dirty = false; 
    &#125;
    depend() &#123;
        let i = this.deps.length
        while(i--) &#123;
            this.deps[i].depend()
        &#125;
    &#125;
&#125;
</code></pre>
<p>执行depend方法可以将组件中的watcher实例添加到dep实例的依赖列表中。换句话说,this.deps是计算属性中用到的所有状态的dep实例,而依次执行了dep实例的depend方法就是将组件的watcher依次加入到这些dep实例的依赖列表。这就实现了让组件的watcher观察计算属性中用到的所有的状态的变化。</p>
<h4 id="2-Computed逻辑变化"><a href="#2-Computed逻辑变化" class="headerlink" title="2.Computed逻辑变化"></a>2.Computed逻辑变化</h4><p>computed在vue2.5.2中的实现发生了一些变化,因为之前的computed的计算存在一些逻辑上的漏洞,因为只要依赖的值发生了变化,vue就认为值发生了变化，组件会重新走一遍渲染的流程，但实际上UI不会由变化，浪费了一些性能。</p>
<p>改动之后的逻辑：</p>
<p>组件的watcher不再监听计算属性的变化,而是让计算属性的watcher得到通知后,计算一次计算属性的值，如果发现这一次计算出来的值与上一次计算出来的值不一样，再去主动通知组件的watcher进行重新渲染。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改"><a href="#♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改" class="headerlink" title="♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改"></a>♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改</h3><p>vue是单向数据流，父组件通过props传值给子组件，如果在子组件中修改会报错，一般是不在子组件中修改props的，但偶尔有需要在子组件有修改props,这里介绍三种可以修改子组件props的方法。</p>
<p>1.父组件用sync修饰，子组件通过<code>$emit(&#39;update:参数&#39;，值)</code>函数去修改。在项目中通常可以用改方法关闭弹框</p>
<pre><code class="vue">&lt;template&gt;
    //父组件
   &lt;CommonDialog
     :title=&quot;dialogTitle&quot;
     :showDialog.sync=&quot;isShowDialog&quot;
     :footer=&quot;true&quot;
     :width=&quot;dialogWidth&quot;
   &gt;
      ....
   &lt;/CommonDialog&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="vue">//子组件 弹框是否打开props: showDialog
&lt;el-dialog :title=&quot;title&quot; :visible=&quot;showDialog&quot; :show-close=&quot;false&quot; :width=&quot;width&quot;&gt;
      &lt;i class=&quot;el-dialog__headerbtn&quot; @click=&quot;closeModal&quot;&gt;
        &lt;span class=&quot;iconfont iconclose&quot;&gt;&lt;/span&gt;
      &lt;/i&gt;
      &lt;div class=&quot;dialog-body&quot;&gt;
          &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
      &lt;div v-if=&quot;!footer&quot; slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
    &lt;/el-dialog&gt;
</code></pre>
<pre><code class="javascript">//关闭弹框------子组件修改props
 closeModal() &#123;
   this.$emit(&quot;update:showDialog&quot;, false);
 &#125;,
</code></pre>
<p>2.如果props是对象，在子组件中修改props</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;csd-select&quot;&gt;
    &lt;el-popover
      placement=&quot;bottom&quot;
      :width=&quot;width&quot;
      :trigger=&quot;config.trigger&quot;
      :config=&quot;config&quot;
      transition=&quot;fade-in&quot;
      popper-class=&quot;casade-selector&quot;
      v-model=&quot;options_show&quot;
    &gt;
    ...
    &lt;/el-popover&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  name: &quot;CasadeSelector&quot;,
  props: &#123;
    config: &#123;
      type: Object,
      //让props默认返回
      default() &#123;
        return &#123;&#125;;
      &#125;
    &#125;,
  &#125;,
&lt;/script&gt;
</code></pre>
<p>3.props是双向绑定的</p>
<pre><code class="vue">&lt;template&gt;
    &lt;control v-model=&quot;deviceF&quot;&gt;&lt;/control&gt;
&lt;/template&gt;

 //v-model里面写上我们要传给子组件，并且还会在子组件中改变这个值
 &lt;script&gt;
 import control from &#39;@/components/control&#39;
 export default &#123;
    name:&quot;test&quot;,
    components: &#123;
        control
    &#125;,
    data () &#123;
        return &#123;
        deviceF: true,
        &#125;
    &#125;
&#125;
 &lt;/script&gt;
</code></pre>
<pre><code class="vue">&lt;template&gt;
   &lt;div&gt;
       &#123;&#123;device&#125;&#125;
       &lt;button @click=&quot;look&quot;&gt;改变值&lt;/button&gt;
   &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
 data () &#123;
   return &#123;
     device: this.value,  //定义一下
   &#125;
 &#125;,
 props: [&#39;value&#39;],//因为想要改变device，所以device要写成value，这里是写死的
 components: &#123;
 &#125;,
 methods: &#123;
   look () &#123;
     this.device = !this.device
     this.$emit(&#39;input&#39;, this.device)  //这样this.device就会被修改；前面的input是固定写死的
   &#125;
 &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？"><a href="#♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？" class="headerlink" title="♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？"></a>♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？</h3><p>1、问题描述：页面刷新的时候vuex里的数据会重新初始化，导致数据丢失。因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被重新赋值。</p>
<p>2、解决思路：</p>
<p>办法一：将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie） </p>
<p>办法二：在页面刷新的时候再次请求远程数据，使之动态更新vuex数据 办法三：在父页面向后台请求远程数据，并且在页面刷新前将vuex的数据先保存至sessionStorage（以防请求数据量过大页面加载时拿不到返回的数据）</p>
<p>3、 解决过程：</p>
<p>3.1、选择合适的浏览器存储</p>
<p>3.2、解决方案由于state里的数据是响应式，所以sessionStorage存储也要跟随变化，而且只能通过mutations来改变state中的值。 首先在用户登录成功之后，然后把用户信息，菜单信息通过actions分发保存至vuex中。然后在菜单页面计算vuex中state的菜单数据，将数据解析组装成前端组件所需的格式，然后渲染组件，生成菜单树。如果页面没有刷新，则一切正常。</p>
<p>监听浏览器刷新前事件，在浏览器刷新之前就把vuex里的数据保存至sessionStorage中，刷新成功后如果异步请求的数据还没返回则直接获取sessionStorage里的数据，否则获取vuex里的数据。</p>
<h3 id="♥︎♥︎♥︎♥︎什么是Vue-nextTick-？"><a href="#♥︎♥︎♥︎♥︎什么是Vue-nextTick-？" class="headerlink" title="♥︎♥︎♥︎♥︎什么是Vue.nextTick()？"></a>♥︎♥︎♥︎♥︎什么是Vue.nextTick()？</h3><p>$nextTick 是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM，意思是 等你dom加载完毕以后再去调用nextTick()里面的数据内容</p>
<hr>
<h3 id="♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object-defineProperty优劣对比？"><a href="#♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object-defineProperty优劣对比？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object.defineProperty优劣对比？"></a>♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object.defineProperty优劣对比？</h3><p>1、响应式原理</p>
<p>vue的响应式实现主要是利用了Object.defineProperty的方法里面的setter 与getter方法的观察者模式来实现。在组件初始化时会给每一个data属性注册getter和setter，然后再new 一个自己的Watcher对象，此时watcher会立即调用组件的render函数去生成虚拟DOM。在调用render的时候，就会需要用到data的属性值，此时会触发getter函数，将当前的Watcher函数注册进sub里。当data属性发生改变之后，就会遍历sub里所有的watcher对象，通知它们去重新渲染组件。</p>
<p>2、proxy的优势如下：</p>
<p>Proxy 可以直接监听对象而非属性，可以直接监听数组的变化；</p>
<p>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是</p>
<p>Object.defineProperty 不具备的；</p>
<p>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</p>
<p>3、Object.defineProperty 的优势如下:</p>
<p>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill(垫片)来弥补</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-vue-router路由实现原理"><a href="#♥︎♥︎♥︎♥︎♥︎-vue-router路由实现原理" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ vue-router路由实现原理"></a>♥︎♥︎♥︎♥︎♥︎ vue-router路由实现原理</h3><p>[vue-router路由模式]: 	“<a href="https://blog.csdn.net/weixin_43638968/article/details/109303363">https://blog.csdn.net/weixin_43638968/article/details/109303363</a>  “</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-Vue3中的双向数据绑定proxy"><a href="#♥︎♥︎♥︎♥︎♥︎-Vue3中的双向数据绑定proxy" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ Vue3中的双向数据绑定proxy"></a>♥︎♥︎♥︎♥︎♥︎ Vue3中的双向数据绑定proxy</h3><p>Proxy相当于在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy是Object.defineProperty的全方位加强版，它解决了之前defineProperty无法监听到数组变化等缺点。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-Vue和React中diff算法区别"><a href="#♥︎♥︎♥︎♥︎♥︎-Vue和React中diff算法区别" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ Vue和React中diff算法区别"></a>♥︎♥︎♥︎♥︎♥︎ Vue和React中diff算法区别</h3><p>vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。</p>
<p>1.vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。</p>
<p>2.vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎Vue-响应式原理"><a href="#♥︎♥︎♥︎♥︎♥︎Vue-响应式原理" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎Vue 响应式原理"></a>♥︎♥︎♥︎♥︎♥︎Vue 响应式原理</h3><p>[Vue 响应式原理]: 	“<a href="https://juejin.cn/post/6844903561327820808">https://juejin.cn/post/6844903561327820808</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"><a href="#♥︎♥︎♥︎♥︎♥︎-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"></a>♥︎♥︎♥︎♥︎♥︎ nextTick知道吗、实现的原理是什么？是宏任务还是微任务？</h3><p>微任务</p>
<p>原理：nextTick方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空队列。</p>
<p>作用： nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick,则可以在回调中获取更新后的DOM。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-Vue项目常见优化点"><a href="#♥︎♥︎♥︎♥︎♥︎-Vue项目常见优化点" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ Vue项目常见优化点"></a>♥︎♥︎♥︎♥︎♥︎ Vue项目常见优化点</h3><p>1、首屏加载优化</p>
<p>2、路由懒加载</p>
<pre><code class="javascript">&#123; 
 path: &#39;/&#39;,
 name: &#39;home&#39;, 
 component: () =&gt; import(&#39;./views/home/index.vue&#39;), 
 meta: &#123; isShowHead: true &#125;
&#125;
</code></pre>
<p>3、开启服务器 Gzip</p>
<p>开启 Gzip 就是一种压缩技术，需要前端提供压缩包，然后在服务器开启压缩，文件在服务器压缩后传给浏览器，浏览器解压后进行再进行解析。首先安装 webpack 提供的compression-webpack-plugin进行压缩,然后在 vue.config.js：</p>
<pre><code class="javascript">const CompressionWebpackPlugin = require(&#39;compression-webpack-plugin&#39;)
const productionGzipExtensions = [&#39;js&#39;, &#39;css&#39;]......plugins: [ 
 new CompressionWebpackPlugin(
 &#123; 
 algorithm: &#39;gzip&#39;, 
 test: new RegExp(&#39;\.(&#39; + productionGzipExtensions.join(&#39;|&#39;) + &#39;)$&#39;), 
 threshold: 10240, 
 minRatio: 0.8 
 &#125;
)]....
</code></pre>
<p>4、启动 CDN 加速</p>
<p>我们继续采用 cdn 的方式来引入一些第三方资源，就可以缓解我们服务器的压力，原理是将我们的压力分给其他服务器点。</p>
<p>5、代码层面优化</p>
<p>computed 和 watch 区分使用场景</p>
<p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>
<p> watch：类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<p>v-if 和 v-show 区分使用场景 v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景。这里要说的优化点在于减少页面中 dom 总数，我比较倾向于使用 v-if，因为减少了 dom 数量。</p>
<p>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if v-for 遍历必须为 item 添加 key，循环调用子组件时添加 key，key 可以唯一标识一个循环个体，可以使用例如 item.id 作为 key 避免同时使用 v-if，vfor 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度。</p>
<p>6、Webpack 对图片进行压缩</p>
<p>7、避免内存泄漏</p>
<p>8、减少 ES6 转为 ES5 的冗余代码</p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>Vue-Vue3</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全算法篇</title>
    <url>/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（算法）"><a href="#前端面试题大全（算法）" class="headerlink" title="前端面试题大全（算法）"></a>前端面试题大全（算法）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-算法中时间复杂度，空间复杂度的理解？如何计算？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-算法中时间复杂度，空间复杂度的理解？如何计算？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 算法中时间复杂度，空间复杂度的理解？如何计算？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 算法中时间复杂度，空间复杂度的理解？如何计算？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别</p>
<p>衡量不同算法之间的优劣主要是通过时间和空间两个维度去考量：</p>
<ul>
<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>
<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述</li>
</ul>
<p>通常会遇到一种情况，时间和空间维度不能够兼顾，需要在两者之间取得一个平衡点是我们需要考虑的</p>
<p>一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况</p>
<p>最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差</p>
<h4 id="二、时间复杂度"><a href="#二、时间复杂度" class="headerlink" title="二、时间复杂度"></a>二、时间复杂度</h4><p>时间复杂度是指执行这个算法所需要的计算工作量，其复杂度反映了程序执行时间「随输入规模增长而增长的量级」，在很大程度上能很好地反映出算法的优劣与否</p>
<p>一个算法花费的时间与算法中语句的「执行次数成正比」，执行次数越多，花费的时间就越多</p>
<p>算法的复杂度通常用大O符号表述，定义为<code>T(n) = O(f(n))</code>，常见的时间复杂度有：O(1)常数型、O(log n)对数型、O(n)线性型、O(nlogn)线性对数型、O(n^2)平方型、O(n^3)立方型、O(n^k)k次方型、O(2^n)指数型，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33336435656266302d313666632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>从上述可以看到，随着问题规模<code>n</code>的不断增大，上述时间复杂度不断增大，算法的执行效率越低，由小到大排序如下：</p>
<pre><code class="ini">Ο(1)＜Ο(log n)＜Ο(n)＜Ο(nlog n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n)＜Ο(n!)
</code></pre>
<p>注意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效，如果常数项过大的时候也会导致算法的执行时间变长</p>
<p>关于如何计算时间复杂度，可以看看如下简单例子：</p>
<pre><code class="javascript">function process(n) &#123;
  let a = 1
  let b = 2
  let sum = a + b
  for(let i = 0; i &lt; n; i++) &#123;
    sum += i
  &#125;
  return sum
&#125;
</code></pre>
<p>该函数算法需要执行的运算次数用输入大小<code>n</code>的函数表示，即 <code>T(n) = 2 + n + 1</code>，那么时间复杂度为<code>O(n + 3)</code>，又因为时间复杂度只关注最高数量级，且与之系数也没有关系，因此上述的时间复杂度为<code>O(n)</code></p>
<p>又比如下面的例子：</p>
<pre><code class="javascript">function process(n) &#123;
 let count = 0
  for(let i = 0; i &lt; n; i++)&#123;
    for(let i = 0; i &lt; n; i++)&#123;
      count += 1
    &#125;
  &#125;
&#125;
</code></pre>
<p>循环里面嵌套循环，外面的循环执行一次，里面的循环执行<code>n</code>次，因此时间复杂度为 <code>O(n*n*1 + 2) = O(n^2)</code></p>
<p>对于顺序执行的语句，总的时间复杂度等于其中最大的时间复杂度，如下：</p>
<pre><code class="javascript">function process(n) &#123;
  let sum = 0
  for(let i = 0; i &lt; n; i++) &#123;
    sum += i
  &#125;
  for(let i = 0; i &lt; n; i++)&#123;
    for(let i = 0; i &lt; n; i++)&#123;
      sum += 1
    &#125;
  &#125;
  return sum
&#125;
</code></pre>
<p>上述第一部分复杂度为<code>O(n)</code>，第二部分复杂度为<code>O(n^2)</code>，总复杂度为<code>max(O(n^2), O(n)) = O(n^2)</code></p>
<p>又如下一个例子：</p>
<pre><code class="javascript">function process(n) &#123;
  let i = 1; // ①
  while (i &lt;= n) &#123;
     i = i * 2; // ②
  &#125;
&#125;
</code></pre>
<p>循环语句中以2的倍数来逼近<code>n</code>，每次都乘以2。如果用公式表示就是1 * 2 * 2 * 2 … * 2 &lt;&#x3D;n，也就是说2的<code>x</code>次方小于等于<code>n</code>时会执行循环体，记作<code>2^x &lt;= n</code>，于是得出<code>x&lt;=logn</code></p>
<p>因此循环在执行<code>logn</code>次之后，便结束，因此时间复杂度为<code>O(logn)</code></p>
<p>同理，如果一个<code>O(n)</code>循环里面嵌套<code>O(logn)</code>的循环，则时间复杂度为<code>O(nlogn)</code>，像<code>O(n^3)</code>无非也就是嵌套了三层<code>O(n)</code>循环</p>
<h4 id="三、空间复杂度"><a href="#三、空间复杂度" class="headerlink" title="三、空间复杂度"></a>三、空间复杂度</h4><p>空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量</p>
<p>除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间</p>
<p>下面给出空间复杂度为<code>O(1)</code>的示例，如下</p>
<pre><code class="javascript">let a = 1
let b = 2
let c = 3
</code></pre>
<p>上述代码的临时空间不会随着<code>n</code>的变化而变化，因此空间复杂度为<code>O(1)</code></p>
<pre><code class="javascript">let arr []
for(i=1; i&lt;=n; ++i)&#123;
  arr.push(i)
&#125;
</code></pre>
<p>上述可以看到，随着<code>n</code>的增加，数组的占用的内存空间越大</p>
<p>通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为<code>O(1)</code>，一个一维数组<code>a[n]</code>，空间复杂度<code>O(n)</code>，二维数组为<code>O(n^2)</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对数据结构的理解？有哪些？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对数据结构的理解？有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对数据结构的理解？有哪些？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对数据结构的理解？有哪些？区别？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合</p>
<p>前面讲到，一个程序 &#x3D; 算法 + 数据结构，数据结构是实现算法的基础，选择合适的数据结构可以带来更高的运行或者存储效率</p>
<p>数据元素相互之间的关系称为结构，根据数据元素之间关系的不同特性，通常有如下四类基本的结构：</p>
<ul>
<li>集合结构：该结构的数据元素间的关系是“属于同一个集合”</li>
<li>线性结构：该结构的数据元素之间存在着一对一的关系</li>
<li>树型结构：该结构的数据元素之间存在着一对多的关系</li>
<li>图形结构：该结构的数据元素之间存在着多对多的关系，也称网状结构</li>
</ul>
<p>由于数据结构种类太多，逻辑结构可以再分成为：</p>
<ul>
<li>线性结构：有序数据元素的集合，其中数据元素之间的关系是一对一的关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的</li>
<li>非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生关联</li>
</ul>
<p><a href="https://camo.githubusercontent.com/c16cd7ef078a9270d5e13a8eca64d7b5469bf5ba3cfa7b88564c0065ba3ba230/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39616564633564302d316161362d313165632d386536342d3931666465633066303561312e706e67"><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39616564633564302d316161362d313165632d386536342d3931666465633066303561312e706e67.png" alt="img"></a></p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的数据结构有如下：</p>
<ul>
<li>数组</li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>树</li>
<li>图</li>
<li>堆</li>
<li>散列表</li>
</ul>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>在程序设计中，为了处理方便， 一般情况把具有相同类型的若干变量按有序的形式组织起来，这些按序排列的同类数据元素的集合称为数组</p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>一种特殊的线性表，只能在某一端插入和删除的特殊线性表，按照先进后出的特性存储数据</p>
<p>先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>跟栈基本一致，也是一种特殊的线性表，其特性是先进先出，只允许在表的前端进行删除操作，而在表的后端进行插入操作</p>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p>
<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成</p>
<p>一般情况，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><p>树是典型的非线性结构，在树的结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个以上的后继结点</p>
<h5 id="图"><a href="#图" class="headerlink" title="图"></a>图</h5><p>一种非线性结构。在图结结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系</p>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆是一种特殊的树形数据结构，每个结点都有一个值，特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆</p>
<h5 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h5><p>若结构中存在关键字和<code>K</code>相等的记录，则必定在<code>f(K)</code>的存储位置上，不需比较便可直接取得所查记录</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>上述的数据结构，之前的区别可以分成线性结构和非线性结构：</p>
<ul>
<li>线性结构有：数组、栈、队列、链表等</li>
<li>非线性结构有：树、图、堆等</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对栈、队列的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对栈、队列的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对栈、队列的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对栈、队列的理解？应用场景？</h3><h4 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h4><p>栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表</p>
<p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p>
<p>所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p>
<p>关于栈的简单实现，如下：</p>
<pre><code class="javascript">class Stack &#123;
  constructor() &#123;
    this.items = [];
  &#125;

  /**
   * 添加一个（或几个）新元素到栈顶
   * @param &#123;*&#125; element 新元素
   */
  push(element) &#123;
    this.items.push(element)
  &#125;

  /**
   * 移除栈顶的元素，同时返回被移除的元素
   */
  pop() &#123;
    return this.items.pop()
  &#125;

  /**
   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）
   */
  peek() &#123;
    return this.items[this.items.length - 1]
  &#125;

  /**
   * 如果栈里没有任何元素就返回true,否则返回false
   */
  isEmpty() &#123;
    return this.items.length === 0
  &#125;

  /**
   * 移除栈里的所有元素
   */
  clear() &#123;
    this.items = []
  &#125;

  /**
   * 返回栈里的元素个数。这个方法和数组的length属性很类似
   */
  size() &#123;
    return this.items.length
  &#125;
&#125;
</code></pre>
<p>关于栈的操作主要的方法如下：</p>
<ul>
<li>push：入栈操作</li>
<li>pop：出栈操作</li>
</ul>
<h4 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h4><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</p>
<p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p>
<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出</p>
<p>简单实现一个队列的方式，如下：</p>
<pre><code>class Queue &#123;
    constructor() &#123;
        this.list = []
        this.frontIndex = 0
        this.tailIndex = 0
    &#125;
    enqueue(item) &#123;
        this.list[this.tailIndex++] = item
    &#125;
    unqueue() &#123;
        const item  = this.list[this.frontIndex]
        this.frontIndex++        
        return item
    &#125;
&#125;
</code></pre>
<p>上述这种入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用</p>
<p>当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作，出该现象称为”假溢”</p>
<p>在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：</p>
<p>无论插入或删除，一旦<code>rear</code>指针增1或<code>front</code>指针增1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置，这种队列也就是循环队列</p>
<p>下面实现一个循环队列，如下：</p>
<pre><code class="javascript">class Queue &#123;
    constructor(size) &#123;
        this.size = size; // 长度需要限制, 来达到空间的利用, 代表空间的长度
        this.list = [];
        this.font = 0; // 指向首元素
        this.rear = 0;  // 指向准备插入元素的位置
    &#125;
    enQueue() &#123;
        if (this.isFull() == true) &#123;
            return false
        &#125;
        this.rear = this.rear % this.k;
        this._data[this.rear++] = value;
        return true
    &#125;
    deQueue() &#123;
        if(this.isEmpty())&#123;
            return false;
        &#125;
        this.font++;
        this.font = this.font % this.k;
        return true;
    &#125;
    isEmpty() &#123;
        return this.font == this.rear - 1;
    &#125;
    isFull() &#123;
        return this.rear % this.k == this.font;
    &#125;
&#125;
</code></pre>
<p>上述通过求余的形式代表首尾指针增1 时超出了所分配的队列空间</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><h5 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h5><p>借助栈的先进后出的特性，可以简单实现一个逆序数处的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p>
<p>包括编译器的在对输入的语法进行分析的时候，例如<code>&quot;()&quot;</code>、<code>&quot;&#123;&#125;&quot;</code>、<code>&quot;[]&quot;</code>这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>
<p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p>
<p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p>
<h5 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h5><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p>
<p>队列的使用广泛应用在广度优先搜索种，例如层次遍历一个二叉树的节点值（后续将到）</p>
<p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对链表的理解？常见的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对链表的理解？常见的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对链表的理解？常见的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对链表的理解？常见的操作有哪些？</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>链表（Linked List）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，由一系列结点（链表中每一个元素称为结点）组成</p>
<p>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65346539333439302d316337362d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>节点用代码表示，则如下：</p>
<pre><code class="javascript">class Node &#123;
  constructor(val) &#123;
    this.val = val;
    this.next = null;
  &#125;
&#125;
</code></pre>
<ul>
<li>data 表示节点存放的数据</li>
<li>next 表示下一个节点指向的内存空间</li>
</ul>
<p>相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到<code>O(1)</code>的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是<code>O(logn)</code>和<code>O(1)</code></p>
<p>链表的结构也十分多，常见的有四种形式：</p>
<ul>
<li>单链表：除了头节点和尾节点，其他节点只包含一个后继指针</li>
<li>循环链表：跟单链表唯一的区别就在于它的尾结点又指回了链表的头结点，首尾相连，形成了一个环</li>
<li>双向链表：每个结点具有两个方向指针，后继指针(next)指向后面的结点，前驱指针(prev)指向前面的结点，其中节点的前驱指针和尾结点的后继指针均指向空地址NULL</li>
<li>双向循环链表：跟双向链表基本一致，不过头节点前驱指针指向尾迹诶单和尾节点的后继指针指向头节点</li>
</ul>
<h4 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于链表的操作可以主要分成如下：</p>
<ul>
<li>遍历</li>
<li>插入</li>
<li>删除</li>
</ul>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>遍历很好理解，就是根据<code>next</code>指针遍历下去，直到为<code>null</code>，如下：</p>
<pre><code class="javascript">let current = head
while(current)&#123;
 console.log(current.val)
  current = current.next
&#125;
</code></pre>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>向链表中间插入一个元素，可以如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66356665356664302d316337362d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>可以看到，插入节点可以分成如下步骤：</p>
<ul>
<li>存储插入位置的前一个节点</li>
<li>存储插入位置的后一个节点</li>
<li>将插入位置的前一个节点的 next 指向插入节点</li>
<li>将插入节点的 next 指向前面存储的 next 节点</li>
</ul>
<p>相关代码如下所示：</p>
<pre><code class="javascript">let current = head
while (current &lt; position)&#123;
  pervious = current;
  current = current.next;
&#125;
pervious.next = node;
node.next = current;
</code></pre>
<p>如果在头节点进行插入操作的时候，会实现<code>previousNode</code>节点为<code>undefined</code>，不适合上述方式</p>
<p>解放方式可以是在头节点前面添加一个虚拟头节点，保证插入行为一致</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>向链表任意位置删除节点，如下图操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30313630636439302d316337372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>从上图可以看到删除节点的步骤为如下：</p>
<ul>
<li>获取删除节点的前一个节点</li>
<li>获取删除节点的后一个节点</li>
<li>将前一个节点的 next 指向后一个节点</li>
<li>向删除节点的 next 指向为null</li>
</ul>
<p>如果想要删除制定的节点，示意代码如下：</p>
<pre><code class="javascript">while (current != node)&#123;
  pervious = current;
  current = current.next;
  nextNode = current.next;
&#125;
pervious.next = nextNode
</code></pre>
<p>同样如何希望删除节点处理行为一致，可以在头节点前面添加一个虚拟头节点</p>
<h5 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h5><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的<code>CPU</code>缓存、数据库缓存、浏览器缓存等等</p>
<p>当缓存空间被用满时，我们可能会使用<code>LRU</code>最近最好使用策略去清楚，而实现<code>LRU</code>算法的数据结构是链表，思路如下：</p>
<p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表</p>
<ul>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部</li>
<li>如果此数据没在缓存链表中<ul>
<li>如果此时缓存未满，可直接在链表头部插入新节点存储此数据</li>
<li>如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点</li>
</ul>
</li>
</ul>
<p>由于链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据的情况的时候，都可以使用链表</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对集合的理解？常见的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对集合的理解？常见的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对集合的理解？常见的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对集合的理解？常见的操作有哪些？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>集合（Set），指具有某种特定性质的事物的总体，里面的每一项内容称作元素</p>
<p>在数学中，我们经常会遇到集合的概念：</p>
<ul>
<li>有限集合：例如一个班集所有的同学构成的集合</li>
<li>无限集合：例如全体自然数集合</li>
</ul>
<p>在计算机中集合道理也基本一致，具有三大特性：</p>
<ul>
<li>确定性：于一个给定的集合，集合中的元素是确定的。即一个元素，或者属于该集合，或者不属于该集合，两者必居其一</li>
<li>无序性：在一个集合中，不考虑元素之间的顺序，只要元素完全相同，就认为是同一个集合</li>
<li>互异性：集合中任意两个元素都是不同的</li>
</ul>
<h4 id="二、操作-1"><a href="#二、操作-1" class="headerlink" title="二、操作"></a>二、操作</h4><p>在<code>ES6</code>中，集合本身是一个构建函数<code>Set</code>，用来生成 <code>Set</code> 数据结构，如下：</p>
<pre><code class="javascript">const s = new Set();
</code></pre>
<p>关于集合常见的方法有：</p>
<ul>
<li>add()：增</li>
<li>delete()：删</li>
<li>has()：改</li>
<li>clear()：查</li>
</ul>
<h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><p>添加某个值，返回 <code>Set</code> 结构本身</p>
<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>
<pre><code class="javascript">s.add(1).add(2).add(2); // 2只被添加了一次
</code></pre>
<p>体现了集合的互异性特性</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h5><p>删除某个值，返回一个布尔值，表示删除是否成功</p>
<pre><code class="ini">s.delete(1)
</code></pre>
<h5 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h5><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>
<pre><code class="ini">s.has(2)
</code></pre>
<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p>清除所有成员，没有返回值</p>
<pre><code class="ini">s.clear()
</code></pre>
<p>关于多个集合常见的操作有：</p>
<ul>
<li>并集</li>
<li>交集</li>
<li>差集</li>
</ul>
<h5 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h5><p>两个集合的共同元素，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65643936646635302d316433362d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>代码实现方式如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;
</code></pre>
<h5 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h5><p>两个集合<code>A</code> 和 <code>B</code>，即属于<code>A</code>又属于<code>B</code>的元素，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66386139636438302d316433362d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>用代码标识则如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;
</code></pre>
<h5 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h5><p>两个集合<code>A</code> 和 <code>B</code>，属于<code>A</code>的元素但不属于<code>B</code>的元素称为<code>A</code>相对于<code>B</code>的差集，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30313931633536302d316433372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>代码标识则如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>一般情况下，使用数组的概率会比集合概率高很多</p>
<p>使用<code>set</code>集合的场景一般是借助其确定性，其本身只包含不同的元素</p>
<p>所以，可以利用<code>Set</code>的一些原生方法轻松的完成数组去重，查找数组公共元素及不同元素等操作</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对树的理解？相关的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对树的理解？相关的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对树的理解？相关的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对树的理解？相关的操作有哪些？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机领域，树形数据结构是一类重要的非线性数据结构，可以表示数据之间一对多的关系。以树与二叉树最为常用，直观看来，树是以分支关系定义的层次结构</p>
<p>二叉树满足以下两个条件：</p>
<ul>
<li>本身是有序树</li>
<li>树中包含的各个结点的不能超过 2，即只能是 0、1 或者 2</li>
</ul>
<p>如下图，左侧的为二叉树，而右侧的因为头结点的子结点超过2，因此不属于二叉树：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36363735383830302d316466652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>同时，二叉树可以继续进行分类，分成了满二叉树和完成二叉树：</p>
<ul>
<li>满二叉树：如果二叉树中除了叶子结点，每个结点的度都为 2</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353964623035302d316466652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>完成二叉树：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38346165333166302d316466652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h4 id="二、操作-2"><a href="#二、操作-2" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于二叉树的遍历，常见的有：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问根节点</li>
<li>访问当前节点的左子树</li>
<li>若当前节点无左子树，则访问当前节点的右子</li>
</ul>
<p>根据遍历特性，递归版本用代码表示则如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  console.log(root)
  preOrder(root.left)
  preOrder(root.right)
&#125;
</code></pre>
<p>如果不使用递归版本，可以借助栈先进后出的特性实现，先将根节点压入栈，再分别压入右节点和左节点，直到栈中没有元素，如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  const stack = [root]
  while (stack.length) &#123;
    const n = stack.pop()
    console.log(n.val)
    if (n.right) &#123;
      stack.push(n.right)
    &#125;
    if (n.left) &#123;
      stack.push(n.left)
    &#125;
  &#125;
&#125;
</code></pre>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问当前节点的左子树</li>
<li>访问根节点</li>
<li>访问当前节点的右子</li>
</ul>
<p>递归版本很好理解，用代码表示则如下：</p>
<pre><code class="javascript">const inOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  inOrder(root.left)
  console.log(root.val)
  inOrder(root.right)
&#125;
</code></pre>
<p>非递归版本也是借助栈先进后出的特性，可以一直首先一直压入节点的左元素，当左节点没有后，才开始进行出栈操作，压入右节点，然后有依次压入左节点，如下：</p>
<pre><code class="javascript">const inOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  const stack = [root]
  let p = root
  while(stack.length || p)&#123;
    while (p) &#123;
      stack.push(p)
      p = p.left
    &#125;
    const n = stack.pop()
    console.log(n.val)
    p = n.right
  &#125;
&#125;
</code></pre>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问当前节点的左子树</li>
<li>访问当前节点的右子</li>
<li>访问根节点</li>
</ul>
<p>递归版本，用代码表示则如下：</p>
<pre><code class="javascript">const postOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  postOrder(root.left)
  postOrder(root.right)
  console.log(n.val)
 &#125;
</code></pre>
<p>后序遍历非递归版本实际根全序遍历是逆序关系，可以再多创建一个栈用来进行输出，如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  const stack = [root]
  const outPut = []
  while (stack.length) &#123;
    const n = stack.pop()
    outPut.push(n.val)
    if (n.right) &#123;
      stack.push(n.right)
    &#125;
    if (n.left) &#123;
      stack.push(n.left)
    &#125;
  &#125;
  while (outPut.length) &#123;
    const n = outPut.pop()
    console.log(n.val)
  &#125;
&#125;
</code></pre>
<h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>按照二叉树中的层次从左到右依次遍历每层中的结点</p>
<p>借助队列先进先出的特性，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果</p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const levelOrder = (root) =&gt; &#123;
    if (!root) &#123; return [] &#125;
    const queue = [[root, 0]]
    const res = []
    while (queue.length) &#123;
        const n = queue.shift()
        const [node, leval] = n
        if (!res[leval]) &#123;
            res[leval] = [node.val]
        &#125; else &#123;
            res[leval].push(node.val)
        &#125;
        if (node.left) &#123; queue.push([node.left, leval + 1]) &#125;
        if (node.right) &#123; queue.push([node.right, leval + 1]) &#125;
    &#125;
    return res
&#125;;
</code></pre>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>树是一个非常重要的非线性结构，其中二叉树以二叉树最常见，二叉树的遍历方式可以分成前序遍历、中序遍历、后序遍历</p>
<p>同时，二叉树又分成了完成二叉树和满二叉树</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对堆的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对堆的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对堆的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对堆的理解？如何实现？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称</p>
<p>堆通常是一个可以被看做一棵完全二叉树的数组对象，如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613066643166302d316564372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>总是满足下列性质：</p>
<ul>
<li>堆中某个结点的值总是不大于或不小于其父结点的值</li>
<li>堆总是一棵完全二叉树</li>
</ul>
<p>堆又可以分成最大堆和最小堆：</p>
<ul>
<li>最大堆：每个根结点，都有根结点的值大于两个孩子结点的值</li>
<li>最小堆：每个根结点，都有根结点的值小于孩子结点的值</li>
</ul>
<h4 id="二、操作-3"><a href="#二、操作-3" class="headerlink" title="二、操作"></a>二、操作</h4><p>堆的元素存储方式，按照完全二叉树的顺序存储方式存储在一个一维数组中，如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613066643166302d316564372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用一维数组存储则如下：</p>
<pre><code class="javascript">[0, 1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<p>根据完全二叉树的特性，可以得到如下特性：</p>
<ul>
<li>数组零坐标代码的是堆顶元素</li>
<li>一个节点的父亲节点的坐标等于其坐标除以2整数部分</li>
<li>一个节点的左节点等于其本身节点坐标 * 2 + 1</li>
<li>一个节点的右节点等于其本身节点坐标 * 2 + 2</li>
</ul>
<p>根据上述堆的特性，下面构建最小堆的构造函数和对应的属性方法：</p>
<pre><code class="javascript">class MinHeap &#123;
  constructor() &#123;
    // 存储堆元素
    this.heap = []
  &#125;
  // 获取父元素坐标
  getParentIndex(i) &#123;
    return (i - 1) &gt;&gt; 1
  &#125;
  
  // 获取左节点元素坐标
  getLeftIndex(i) &#123;
    return i * 2 + 1
  &#125;
  
 // 获取右节点元素坐标
  getRightIndex(i) &#123;
    return i * 2 + 2
  &#125;
  
  // 交换元素
  swap(i1, i2) &#123;
    const temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp
  &#125;
  
  // 查看堆顶元素
  peek() &#123;
    return this.heap[0]
  &#125;
  
  // 获取堆元素的大小
  size() &#123;
    return this.heap.length
  &#125;
&#125;
</code></pre>
<p>涉及到堆的操作有：</p>
<ul>
<li>插入</li>
<li>删除</li>
</ul>
<h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><p>将值插入堆的底部，即数组的尾部，当插入一个新的元素之后，堆的结构就会被破坏，因此需要堆中一个元素做上移操作</p>
<p>将这个值和它父节点进行交换，直到父节点小于等于这个插入的值，大小为<code>k</code>的堆中插入元素的时间复杂度为<code>O(logk)</code></p>
<p>如下图所示，22节点是新插入的元素，然后进行上移操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30363839336662302d316564382d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>相关代码如下：</p>
<pre><code class="java">// 插入元素
insert(value) &#123;
  this.heap.push(value)
  this.shifUp(this.heap.length - 1)
&#125;

// 上移操作
shiftUp(index) &#123;
  if (index === 0) &#123; return &#125;
  const parentIndex = this.getParentIndex(index)
  if(this.heap[parentIndex] &gt; this.heap[index])&#123;
    this.swap(parentIndex, index)
    this.shiftUp(parentIndex)
  &#125;
&#125;
</code></pre>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>常见操作是用数组尾部元素替换堆顶，这里不直接删除堆顶，因为所有的元素会向前移动一位，会破坏了堆的结构</p>
<p>然后进行下移操作，将新的堆顶和它的子节点进行交换，直到子节点大于等于这个新的堆顶，删除堆顶的时间复杂度为<code>O(logk)</code></p>
<p>整体如下图操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31326132613136302d316564382d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>相关代码如下：</p>
<pre><code class="javascript">// 删除元素
pop() &#123;
  this.heap[0] = this.heap.pop()
  this.shiftDown(0)
&#125;

// 下移操作
shiftDown(index) &#123;
  const leftIndex = this.getLeftIndex(index)
  const rightIndex = this.getRightIndex(index)
  if (this.heap[leftIndex] &lt; this.heap[index])&#123;
    this.swap(leftIndex, index)
    this.shiftDown(leftIndex)
  &#125;
  if (this.heap[rightIndex] &lt; this.heap[index])&#123;
    this.swap(rightIndex, index)
    this.shiftDown(rightIndex)
  &#125;
&#125;
</code></pre>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>关于堆的插入和删除时间复杂度都是<code>Olog(n)</code>，原因在于包含n个节点的完全二叉树，树的高度不会超过<code>log2n</code></p>
<p>堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是<code>Olog(n)</code>，插入数据和删除堆顶元素的主要逻辑就是堆化</p>
<h3 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h3><ul>
<li>堆是一个完全二叉树</li>
<li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值</li>
<li>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”</li>
<li>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“小顶堆”</li>
<li>根据堆的特性，我们可以使用堆来进行排序操作，也可以使用其来求第几大或者第几小的值</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对图的理解？相关操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对图的理解？相关操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对图的理解？相关操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对图的理解？相关操作有哪些？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机科学中，图是一种抽象的数据类型，在图中的数据元素通常称为结点，<code>V</code>是所有顶点的集合，<code>E</code>是所有边的集合</p>
<p>如果两个顶点<code>v</code>,<code> w</code>，只能由<code>v</code>向<code>w</code>，而不能由<code>w</code>向<code>v</code>，那么我们就把这种情况叫做一个从 <code>v</code> 到 <code>w</code> 的有向边。<code>v </code>也被称做初始点，<code>w</code>也被称为终点。这种图就被称做有向图</p>
<p>如果<code>v</code>和<code>w</code>是没有顺序的，从<code>v</code>到达<code>w</code>和从<code>w</code>到达<code>v</code>是完全相同的，这种图就被称为无向图</p>
<p>图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系</p>
<p>常见表达图的方式有如下：</p>
<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
</ul>
<h5 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h5><p>通过使用一个二维数组<code>G[N][N]</code>进行表示<code>N</code>个点到<code>N-1</code>编号，通过邻接矩阵可以立刻看出两顶点之间是否存在一条边，只需要检查邻接矩阵行<code>i</code>和列<code>j</code>是否是非零值，对于无向图，邻接矩阵是对称的</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38383164343330302d323035392d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><p>存储方式如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39343966656464302d323035392d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>在<code>javascript</code>中，可以使用<code>Object</code>进行表示，如下：</p>
<pre><code class="javascript">const graph = &#123;
  A: [2, 3, 5],
  B: [2],
  C: [0, 1, 3],
  D: [0, 2],
  E: [6],
  F: [0, 6],
  G: [4, 5]
&#125;
</code></pre>
<p>图的数据结构还可能包含和每条边相关联的数值（edge value），例如一个标号或一个数值（即权重，weight；表示花费、容量、长度等）</p>
<h4 id="二、操作-4"><a href="#二、操作-4" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于的图的操作常见的有：</p>
<ul>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
</ul>
<p>首先构建一个图的邻接矩阵表示，如下面的图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61313331313739302d323035392d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const graph = &#123;
  0: [1, 4],
  1: [2, 4],
  2: [2, 3],
  3: [],
  4: [3],
&#125;
</code></pre>
<h5 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h5><p>也就是尽可能的往深处的搜索图的分支</p>
<p>实现思路是，首先应该确定一个根节点，然后对根节点的没访问过的相邻节点进行深度优先遍历</p>
<p>确定以 0 为根节点，然后进行深度遍历，然后遍历1，接着遍历 2，然后3，此时完成一条分支<code>0 - 1- 2- 3</code>的遍历，换一条分支，也就是4，4后面因为3已经遍历过了，所以就不访问了</p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const visited = new Set()
const dfs = (n) =&gt; &#123;
  console.log(n)
  visited.add(n) // 访问过添加记录
  graph[n].forEach(c =&gt; &#123;
    if(!visited.has(c))&#123; // 判断是否访问呢过
      dfs(c)
    &#125;
  &#125;)
&#125;
</code></pre>
<h5 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h5><p>先访问离根节点最近的节点，然后进行入队操作，解决思路如下：</p>
<ul>
<li>新建一个队列，把根节点入队</li>
<li>把队头出队并访问</li>
<li>把队头的没访问过的相邻节点入队</li>
<li>重复二、三步骤，知道队列为空</li>
</ul>
<p>用代码标识则如下：</p>
<pre><code class="javascript">const visited = new Set()
const dfs = (n) =&gt; &#123;
  visited.add(n)
  const q = [n]
  while(q.length)&#123;
    const n = q.shift()
    console.log(n)
    graph[n].forEach(c =&gt; &#123;
      if(!visited.has(c))&#123;
        q.push(c)  
        visited.add(c)
      &#125;
    &#125;)
  &#125;
&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面的初步了解，可以看到图就是由顶点的有穷非空集合和顶点之间的边组成的集合，分成了无向图与有向图</p>
<p>图的表达形式可以分成邻接矩阵和邻接表两种形式，在<code>javascript</code>中，则可以通过二维数组和对象的形式进行表达</p>
<p>图实际是很复杂的，后续还可以延伸出无向图和带权图，对应如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62306438383230302d323035392d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-常见的排序算法有哪些？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-常见的排序算法有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 常见的排序算法有哪些？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 常见的排序算法有哪些？区别？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列</p>
<p>排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的</p>
<p>对与排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性</p>
<p>时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义</p>
<p>稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变</p>
<p>即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的</p>
<h4 id="二、有哪些-1"><a href="#二、有哪些-1" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的算法排序算法有：</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来</p>
<p>思路如下：</p>
<ul>
<li>比较相邻的元素，如果第一个比第二个大，就交换它们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>重复上述步骤，直到没有任何一堆数字需要比较</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963342e7a68696d672e636f6d2f76322d33336139343763373161643632623235346361623632653533363464323831335f622e77656270.gif"></p>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法</p>
<p>无论什么数据进去都是 <code>O(n²) </code>的时间复杂度。所以用到它的时候，数据规模越小越好</p>
<p>唯一的好处是不占用额外的内存存储空间</p>
<p>思路如下：</p>
<ul>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963312e7a68696d672e636f6d2f76322d31633765323066333036646463303265623465336135306661373831376666345f622e77656270.gif"></p>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>插入排序是一种简单直观的排序算法</p>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<p>解决思路如下：</p>
<ul>
<li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的</li>
<li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
<li>重复上述过程直到最后一个元素被插入有序子数组中</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d39316237366538653464616239623063616439613031376437646434333165325f622e77656270.gif"></p>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>归并排序是建立在归并操作上的一种有效的排序算法</p>
<p>该算法是采用分治法的一个非常典型的应用</p>
<p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p>
<p>解决思路如下：</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d63646461336631316336656662633031353737663563323961393036363737325f622e6a7067.jpeg"></p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小</p>
<p>再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列</p>
<p>解决思路如下：</p>
<ul>
<li>从数列中挑出一个元素，称为”基准”（pivot）</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963312e7a68696d672e636f6d2f76322d63343131333339623739663932343939646362376235663330346338323666345f622e6a7067.jpeg"></p>
<h2 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h2><p>除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等……</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对冒泡排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对冒泡排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对冒泡排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对冒泡排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法</p>
<p>冒泡排序的思想就是在每次遍历一遍未排序的数列之后，将一个数据元素浮上去（也就是排好了一个数据）</p>
<p>如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”</p>
<p>假如我们要把 12、35、99、18、76 这 5 个数从大到小进行排序，那么数越大，越需要把它放在前面</p>
<p>思路如下：</p>
<ul>
<li>从后开始遍历，首先比较 18 和 76，发现 76 比 18 大，就把两个数交换顺序，得到 12、35、99、76、18</li>
<li>接着比较 76 和 99，发现 76 比 99 小，所以不用交换顺序</li>
<li>接着比较 99 和 35，发现 99 比 35 大，交换顺序</li>
<li>接着比较 99 和 12，发现 99 比 12 大，交换顺序</li>
</ul>
<p>最终第 1 趟排序的结果变成了 99、12、35、76、18，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37613336333737302d323635322d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>上述可以看到，经过第一趟的排序，可以得到最大的元素，接下来第二趟排序则对剩下的的4个元素进行排序，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38346239646466302d323635322d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>经过第 2 趟排序，结果为 99、76、12、35、18</p>
<p>然后开始第3趟的排序，结果为99、76、35、12、18</p>
<p>然后第四趟排序结果为99、76、35、18、12</p>
<p>经过 4 趟排序之后，只剩一个 12 需要排序了，这时已经没有可比较的元素了，这时排序完成</p>
<h4 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>如果要实现一个从小到大的排序，算法原理如下：</p>
<ul>
<li>首先比较相邻的元素，如果第一个元素比第二个元素大，则交换它们</li>
<li>针对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样，最后的元素回事最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li>
</ul>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function bubbleSort(arr) &#123;
    const len = arr.length;
    for (let i = 0; i &lt; len - 1; i++) &#123;
        for (let j = 0; j &lt; len - 1 - i; j++) &#123;
            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
    return arr;
&#125;
</code></pre>
<p>可以看到：冒泡排序在每一轮排序中都会使一个元素排到一趟， 也就是最终需要 n-1 轮这样的排序</p>
<p>而在每轮排序中都需要对相邻的两个元素进行比较，在最坏的情况下，每次比较之后都需要交换位置，此时时间复杂度为<code>O(n^2)</code></p>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>对冒泡排序常见的改进方法是加入一标志性变量<code>exchange</code>，用于标志某一趟排序过程中是否有数据交换</p>
<p>如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程</p>
<p>可以设置一标志性变量<code>pos</code>，用于记录每趟排序中最后一次进行交换的位置，由于<code>pos</code>位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到<code>pos</code>位置即可，如下：</p>
<pre><code class="javascript">function bubbleSort1(arr)&#123;
 const i=arr.length-1;//初始时,最后位置保持不变  
 while(i&gt;0)&#123;
  let pos = 0;//每趟开始时,无记录交换
  for(let j = 0; j &lt; i; j++)&#123;
   if(arr[j] &gt; arr[j+1])&#123;
        let tmp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = tmp;
    pos = j;//记录最后交换的位置  
   &#125;   
  &#125;
  i = pos;//为下一趟排序作准备
 &#125;
 return arr;
&#125;
</code></pre>
<p>在待排序的数列有序的情况下，只需要一轮排序并且不用交换，此时情况最好，时间复杂度为<code>O(n)</code></p>
<p>并且从上述比较中看到，只有后一个元素比前面的元素大（小）时才会对它们交换位置并向上冒出，对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对位置是不会改变的，因此， 冒泡排序是稳定的</p>
<h4 id="三、应用场景-3"><a href="#三、应用场景-3" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>冒泡排的核心部分是双重嵌套循环，<br>时间复杂度是 O(N 2 )，相比其它排序算法，这是一个相对较高的时间复杂度，一般情况不推荐使用，由于冒泡排序的简洁性，通常被用来对于程序设计入门的学生介绍算法的概念</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对选择排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对选择排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对选择排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对选择排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>选择排序（Selection sort）是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²) </code>的时间复杂度，所以用到它的时候，数据规模越小越好</p>
<p>其基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置</p>
<p>然后再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾</p>
<p>以此类推，直到所有元素均排序完毕</p>
<p>举个例子，一个数组为 56、12、80、91、29，其排序过程如下：</p>
<ul>
<li>第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置。此时数组为 12、56、80、91、20</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36306264323035302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置，此时数组为12、20、80、91、56</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36623034636634302d323637312d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<ul>
<li>第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置，此时数组为 12、20、56、91、80</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353766346530302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置，此时排序完成，变成有序数组</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353766346530302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h4 id="二、如何实现-1"><a href="#二、如何实现-1" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>从上面可以看到，对于具有 <code>n</code> 个记录的无序表遍历 <code>n-1</code> 次，第<code> i</code> 次从无序表中第 <code>i</code> 个记录开始，找出后序关键字中最小的记录，然后放置在第 <code>i</code> 的位置上</p>
<p>直至到从第<code>n</code>个和第<code>n-1</code>个元素中选出最小的放在第<code>n-1</code>个位置</p>
<p>如下动画所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f73656c656374696f6e536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function selectionSort(arr) &#123;
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) &#123;
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) &#123;
            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    return arr;
&#125;
</code></pre>
<p>第一次内循环比较<code>N - 1</code>次，然后是<code>N-2</code>次，<code>N-3</code>次，……，最后一次内循环比较1次<br>共比较的次数是 <code>(N - 1) + (N - 2) + ... + 1</code>，求等差数列和，得 <code>(N - 1 + 1)* N / 2 = N^2 / 2</code>，舍去最高项系数，其时间复杂度为 <code>O(N^2)</code></p>
<p>从上述也可以看到，选择排序是一种稳定的排序</p>
<h4 id="三、应用场景-4"><a href="#三、应用场景-4" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>和冒泡排序一致，相比其它排序算法，这也是一个相对较高的时间复杂度，一般情况不推荐使用</p>
<p>但是我们还是要掌握冒泡排序的思想及实现，这对于我们的算法思维是有很大帮助的</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对插入排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对插入排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对插入排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对插入排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-9"><a href="#一、是什么-9" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>插入排序（Insertion Sort），一般也被称为直接插入排序。对于少量元素的排序，它是一个有效、简单的算法</p>
<p>其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据</p>
<p>插入排序的工作方式像许多人排序一手扑克牌，开始时，我们的左手为空并且桌子上的牌面向下</p>
<p>然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置，该正确位置需要从右到左将它与已在手中的每张牌进行比较</p>
<p>例如一个无序数组 3、1、7、5、2、4、9、6，将其升序的结果则如下：</p>
<p>一开始有序表中无数据，直接插入3</p>
<p>从第二个数开始，插入一个元素1，然后和有序表中记录3比较，1&lt;3，所以插入到记录 3 的左侧</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39643234663566302d323637662d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>向有序表插入记录 7 时，同有序表中记录 3 进行比较，3&lt;7，所以插入到记录 3 的右侧</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61366139353465302d323637662d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>向有序表中插入记录 5 时，同有序表中记录 7 进行比较，5&lt;7，同时 5&gt;3，所以插入到 3 和 7 中间</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62313938313934302d323637662d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>照此规律，依次将无序表中的记录 4，9 和 6插入到有序表中</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62633265643239302d323637662d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h4 id="二、如何实现-2"><a href="#二、如何实现-2" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置</p>
<p>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f696e73657274696f6e536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function insertionSort(arr) &#123;
    const len = arr.length;
    let preIndex, current;
    for (let i = 1; i &lt; len; i++) &#123;
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        &#125;
        arr[preIndex+1] = current;
    &#125;
    return arr;
&#125;
</code></pre>
<p>在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较<code>N- 1</code>次，时间复杂度为<code>O(n)</code></p>
<p>最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为<code>O(n^2)</code></p>
<p>通过上面了解，可以看到插入排序是一种稳定的排序方式</p>
<h4 id="三、应用场景-5"><a href="#三、应用场景-5" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>插入排序时间复杂度是 O(n2)，适用于数据量不大，算法稳定性要求高，且数据局部或整体有序的数列排序</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对归并排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对归并排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对归并排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对归并排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-10"><a href="#一、是什么-10" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>归并排序（Merge Sort）是建立归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用</p>
<p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p>
<p>例如对于含有 <code>n</code> 个记录的无序表，首先默认表中每个记录各为一个有序表（只不过表的长度都为 1）</p>
<p>然后进行两两合并，使 <code>n</code> 个有序表变为<code>n/2</code> 个长度为 2 或者 1 的有序表（例如 4 个小有序表合并为 2 个大的有序表）</p>
<p>通过不断地进行两两合并，直到得到一个长度为 <code>n</code> 的有序表为止</p>
<p>例如对无序表{49，38，65，97，76，13，27}进行归并排序分成了分、合两部分：</p>
<p>如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30356631346236302d323661642d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>归并合过程中，每次得到的新的子表本身有序，所以最终得到有序表</p>
<p>上述分成两部分，则称为二路归并，如果分成三个部分则称为三路归并，以此类推</p>
<h4 id="二、如何实现-3"><a href="#二、如何实现-3" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>关于归并排序的算法思路如下：</p>
<ul>
<li>分：把数组分成两半，再递归对子数组进行分操作，直至到一个个单独数字</li>
<li>合：把两个数合成有序数组，再对有序数组进行合并操作，直到全部子数组合成一个完整的数组<ul>
<li>合并操作可以新建一个数组，用于存放排序后的数组</li>
<li>比较两个有序数组的头部，较小者出队并且推入到上述新建的数组中</li>
<li>如果两个数组还有值，则重复上述第二步</li>
<li>如果只有一个数组有值，则将该数组的值出队并推入到上述新建的数组中</li>
</ul>
</li>
</ul>
<p>用代码表示则如下图所示：</p>
<pre><code class="javascript">function mergeSort(arr) &#123;  // 采用自上而下的递归方法
    const len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    let middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    const result = [];

    while (left.length &amp;&amp; right.length) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
&#125;
</code></pre>
<p>上述归并分成了分、合两部分，在处理分过程中递归调用两个分的操作，所花费的时间为2乘<code>T(n/2)</code>，合的操作时间复杂度则为<code>O(n)</code>，因此可以得到以下公式：</p>
<p>总的执行时间 &#x3D; 2 × 输入长度为<code>n/2</code>的<code>sort</code>函数的执行时间 + <code>merge</code>函数的执行时间<code>O(n)</code></p>
<p>当只有一个元素时，<code>T(1) = O(1)</code></p>
<p>如果对<code>T(n) = 2 * T(n/2) + O(n) </code>进行左右 &#x2F; n的操作，得到 <code>T(n) / n = (n / 2) * T(n/2) + O(1)</code></p>
<p>现在令 <code>S(n) = T(n)/n</code>，则<code>S(1) = O(1)</code>，然后利用表达式带入得到<code>S(n) = S(n/2) + O(1)</code></p>
<p>所以可以得到：<code>S(n) = S(n/2) + O(1) = S(n/4) + O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)</code></p>
<p>综上可得，<code>T(n) = n * log(n) = nlogn</code></p>
<p>关于归并排序的稳定性，在进行合并过程，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也不会交换，由此可见归并排序是稳定的排序算法</p>
<h4 id="三、应用场景-6"><a href="#三、应用场景-6" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>在外排序中通常使用排序-归并的策略，外排序是指处理超过内存限度的数据的排序算法，通常将中间结果放在读写较慢的外存储器，如下分成两个阶段：</p>
<ul>
<li>排序阶段：读入能够放进内存中的数据量，将其排序输出到临时文件，一次进行，将带排序数据组织为多个有序的临时文件</li>
<li>归并阶段：将这些临时文件组合为大的有序文件</li>
</ul>
<p>例如，使用100m内存对900m的数据进行排序，过程如下：</p>
<ul>
<li>读入100m数据内存，用常规方式排序</li>
<li>将排序后的数据写入磁盘</li>
<li>重复前两个步骤，得到9个100m的临时文件</li>
<li>将100m的内存划分为10份，将9份为输入缓冲区，第10份为输出缓冲区</li>
<li>进行九路归并排序，将结果输出到缓冲区<ul>
<li>若输出缓冲区满，将数据写到目标文件，清空缓冲区</li>
<li>若缓冲区空，读入相应文件的下一份数据</li>
</ul>
</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对快速排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对快速排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对快速排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对快速排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-11"><a href="#一、是什么-11" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>快速排序（Quick Sort）算法是在冒泡排序的基础上进行改进的一种算法，从名字上看就知道该排序算法的特点是快、效率高，是处理大数据最快的排序算法之一</p>
<p>实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小</p>
<p>然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就变成有序序列</p>
<p>例如，对无序表49，38，65，97，76，13，27，49进行快速排序，大致过程为：</p>
<ul>
<li>首先从表中选取一个记录的关键字作为分割点（称为“枢轴”或者支点，一般选择第一个关键字），例如选取 49</li>
<li>将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：{27，38，13，49，65，97，76，49}</li>
<li>以 49 为支点，将整个无序表分割成了两个部分，分别为{27，38，13}和{65，97，76，49}，继续采用此种方法分别对两个子表进行排序</li>
<li>前部分子表以 27 为支点，排序后的子表为{13，27，38}，此部分已经有序；后部分子表以 65 为支点，排序后的子表为{49，65，97，76}</li>
<li>此时前半部分子表中的数据已完成排序；后部分子表继续以 65 为支点，将其分割为{49}和{97，76}，前者不需排序，后者排序后的结果为{76， 97}</li>
<li>通过以上几步的排序，最后由子表{13，27，38}、{49}、{49}、{65}、{76，97}构成有序表：{13，27，38，49，49，65，76，97}</li>
</ul>
<h4 id="二、如何实现-4"><a href="#二、如何实现-4" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>可以分成以下步骤：</p>
<ul>
<li>分区：从数组中选择任意一个基准，所有比基准小的元素放在基准的左边，比基准大的元素放到基准的右边</li>
<li>递归：递归地对基准前后的子数组进行分区</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f717569636b536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function quickSort (arr) &#123;
  const rec = (arr) =&gt; &#123;
    if (arr.length &lt;= 1) &#123; return arr; &#125;
    const left = [];
    const right = [];
    const mid = arr[0]; // 基准元素
    for (let i = 1; i &lt; arr.length; i++)&#123;
      if (arr[i] &lt; mid) &#123;
        left.push(arr[i]);
      &#125; else &#123;
        right.push(arr[i]);
      &#125;
    &#125;
    return [...rec(left), mid, ...rec(right)]
  &#125;
  return rec(arr)
&#125;;
</code></pre>
<p>快速排序是冒泡排序的升级版，最坏情况下每一次基准元素都是数组中最小或者最大的元素，则快速排序就是冒泡排序</p>
<p>这种情况时间复杂度就是冒泡排序的时间复杂度：<code>T[n] = n * (n-1) = n^2 + n</code>，也就是<code>O(n^2)</code></p>
<p>最好情况下是<code>O(nlogn)</code>，其中递归算法的时间复杂度公式：<code>T[n] = aT[n/b] + f(n)</code>，推导如下所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62363031393534302d326235652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>关于上述代码实现的快速排序，可以看到是稳定的</p>
<h4 id="三、应用场景-7"><a href="#三、应用场景-7" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>快速排序时间复杂度为<code>O(nlogn)</code>，是目前基于比较的内部排序中被认为最好的方法，当数据过大且数据杂乱无章时，则适合采用快速排序</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对二分查找的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对二分查找的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对二分查找的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对二分查找的理解？如何实现？应用场景？</h3><h4 id="一、是什么-12"><a href="#一、是什么-12" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机科学中，二分查找算法，也称折半搜索算法，是一种在有序数组中查找某一特定元素的搜索算法</p>
<p>想要应用二分查找法，则这一堆数应有如下特性：</p>
<ul>
<li>存储在数组中</li>
<li>有序排序</li>
</ul>
<p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束</p>
<p>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较</p>
<p>如果在某一步骤数组为空，则代表找不到</p>
<p>这种搜索算法每一次比较都使搜索范围缩小一半</p>
<p>如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65323130383532302d323938372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>相比普通的顺序查找，除了数据量很少的情况下，二分查找会比顺序查找更快，区别如下所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963322e7a68696d672e636f6d2f76322d34333333396239363364623633623333313037623536353033616436623162355f622e676966.gif"></p>
<h4 id="二、如何实现-5"><a href="#二、如何实现-5" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>基于二分查找的实现，如果数据是有序的，并且不存在重复项，实现代码如下：</p>
<pre><code class="javascript">function BinarySearch(arr, target) &#123;
    if (arr.length &lt;= 1) return -1
    // 低位下标
    let lowIndex = 0
    // 高位下标
    let highIndex = arr.length - 1

    while (lowIndex &lt;= highIndex) &#123;
        // 中间下标
        const midIndex = Math.floor((lowIndex + highIndex) / 2)
        if (target &lt; arr[midIndex]) &#123;
            highIndex = midIndex - 1
        &#125; else if (target &gt; arr[midIndex]) &#123;
            lowIndex = midIndex + 1
        &#125; else &#123;
            // target === arr[midIndex]
            return midIndex
        &#125;
    &#125;
    return -1
&#125;
</code></pre>
<p>如果数组中存在重复项，而我们需要找出第一个制定的值，实现则如下：</p>
<pre><code class="javascript">function BinarySearchFirst(arr, target) &#123;
    if (arr.length &lt;= 1) return -1
    // 低位下标
    let lowIndex = 0
    // 高位下标
    let highIndex = arr.length - 1

    while (lowIndex &lt;= highIndex) &#123;
        // 中间下标
        const midIndex = Math.floor((lowIndex + highIndex) / 2)
        if (target &lt; arr[midIndex]) &#123;
            highIndex = midIndex - 1
        &#125; else if (target &gt; arr[midIndex]) &#123;
            lowIndex = midIndex + 1
        &#125; else &#123;
            // 当 target 与 arr[midIndex] 相等的时候，如果 midIndex 为0或者前一个数比 target 小那么就找到了第一个等于给定值的元素，直接返回
            if (midIndex === 0 || arr[midIndex - 1] &lt; target) return midIndex
            // 否则高位下标为中间下标减1，继续查找
            highIndex = midIndex - 1
        &#125;
    &#125;
    return -1
&#125;
</code></pre>
<p>实际上，除了有序的数组可以使用，还有一种特殊的数组可以应用，那就是轮转后的有序数组</p>
<p>有序数组即一个有序数字以某一个数为轴，将其之前的所有数都轮转到数组的末尾所得</p>
<p>例如，[4, 5, 6, 7, 0, 1, 2]就是一个轮转后的有序数组</p>
<p>该数组的特性是存在一个分界点用来分界两个有序数组，如下：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65656565323133302d323938372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>分界点有如下特性：</p>
<ul>
<li>分界点元素 &gt;&#x3D; 第一个元素</li>
<li>分界点元素 &lt; 第一个元素</li>
</ul>
<p>代码实现如下：</p>
<pre><code class="javascript">function search (nums, target) &#123;
  // 如果为空或者是空数组的情况
  if (nums == null || !nums.length) &#123;
    return -1;
  &#125;
  // 搜索区间是前闭后闭
  let begin = 0,
    end = nums.length - 1;
  while (begin &lt;= end) &#123;
    // 下面这样写是考虑大数情况下避免溢出
    let mid = begin + ((end - begin) &gt;&gt; 1);
    if (nums[mid] == target) &#123;
      return mid;
    &#125;
    // 如果左边是有序的
    if (nums[begin] &lt;= nums[mid]) &#123;
      //同时target在[ nums[begin],nums[mid] ]中，那么就在这段有序区间查找
      if (nums[begin] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;
        end = mid - 1;
      &#125; else &#123;
        //否则去反方向查找
        begin = mid + 1;
      &#125;
      //如果右侧是有序的
    &#125; else &#123;
      //同时target在[ nums[mid],nums[end] ]中，那么就在这段有序区间查找
      if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end]) &#123;
        begin = mid + 1;
      &#125; else &#123;
        end = mid - 1;
      &#125;
    &#125;
  &#125;
  return -1;
&#125;;
</code></pre>
<p>对比普通的二分查找法，为了确定目标数会落在二分后的哪个部分，我们需要更多的判定条件</p>
<h4 id="三、应用场景-8"><a href="#三、应用场景-8" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>二分查找法的<code>O(logn)</code>让它成为十分高效的算法。不过它的缺陷却也是比较明显，就在它的限定之上：</p>
<ul>
<li>有序：我们很难保证我们的数组都是有序的</li>
<li>数组：数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)，并且数组的存储是需要连续的内存空间，不适合大数据的情况</li>
</ul>
<p>关于二分查找的应用场景，主要如下：</p>
<ul>
<li>不适合数据量太小的数列；数列太小，直接顺序遍历说不定更快，也更简单</li>
<li>每次元素与元素的比较是比较耗时的，这个比较操作耗时占整个遍历算法时间的大部分，那么使用二分查找就能有效减少元素比较的次数</li>
<li>不适合数据量太大的数列，二分查找作用的数据结构是顺序表，也就是数组，数组是需要连续的内存空间的，系统并不一定有这么大的连续内存空间可以使用</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对分而治之、动态规划的理解？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对分而治之、动态规划的理解？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对分而治之、动态规划的理解？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对分而治之、动态规划的理解？区别？</h3><h4 id="一、分而治之"><a href="#一、分而治之" class="headerlink" title="一、分而治之"></a>一、分而治之</h4><p>分而治之是算法设计中的一种方法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p>
<p>关于分而治之的实现，都会经历三个步骤：</p>
<ul>
<li>分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题</li>
<li>解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题</li>
<li>合并：将各子问题的解合并为原问题的解</li>
</ul>
<p>实际上，关于分而治之的思想，我们在前面已经使用，例如归并排序的实现，同样经历了实现分而治之的三个步骤：</p>
<ul>
<li>分解：把数组从中间一分为二</li>
<li>解决：递归地对两个子数组进行归并排序</li>
<li>合并：将两个字数组合并称有序数组</li>
</ul>
<p>同样关于快速排序的实现，亦如此：</p>
<ul>
<li>分：选基准，按基准把数组分成两个字数组</li>
<li>解：递归地对两个字数组进行快速排序</li>
<li>合：对两个字数组进行合并</li>
</ul>
<p>同样二分搜索也能使用分而治之的思想去实现，代码如下：</p>
<pre><code class="javascript">function binarySearch(arr,l,r,target)&#123;
    if(l&gt; r)&#123;
        return -1;
    &#125;
    let mid = l + Math.floor((r-l)/2)
    if(arr[mid] === target)&#123;
        return mid;
    &#125;else if(arr[mid] &lt; target )&#123;
        return binarySearch(arr,mid + 1,r,target)
    &#125;else&#123;
        return binarySearch(arr,l,mid - 1,target)
    &#125;
&#125;
</code></pre>
<h4 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h4><p>动态规划，同样是算法设计中的一种方法，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</p>
<p>常常适用于有重叠子问题和最优子结构性质的问题</p>
<p>简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决</p>
<p>然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。</p>
<p>一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2的时候，F(n) &#x3D; F(n-1) + F(n-2) ，</p>
<p>f(10)&#x3D; f(9)+f(8),f(9) &#x3D; f(8) + f(7)…是重叠子问题，当n &#x3D; 1、2的时候，对应的值为2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划</p>
<p>比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景</p>
<p>关于动态规划题目解决的步骤，一般如下：</p>
<ul>
<li>描述最优解的结构</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值</li>
<li>由计算出的结果构造一个最优解</li>
</ul>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</p>
<p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的，而分而治之的子问题是相互独立的</p>
<p>若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次</p>
<p>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间</p>
<p>综上，可得：</p>
<ul>
<li>动态规划：有最优子结构和重叠子问题</li>
<li>分而治之：各子问题独立</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对贪心算法、回溯算法的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对贪心算法、回溯算法的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对贪心算法、回溯算法的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对贪心算法、回溯算法的理解？应用场景？</h3><h4 id="一、贪心算法"><a href="#一、贪心算法" class="headerlink" title="一、贪心算法"></a>一、贪心算法</h4><p>贪心算法，又称贪婪算法，是算法设计中的一种思想</p>
<p>其期待每一个阶段都是局部最优的选择，从而达到全局最优，但是结果并不一定是最优的</p>
<p>举个零钱兑换的例子，如果你有1元、2元、5元的钱币数张，用于兑换一定的金额，但是要求兑换的钱币张数最少</p>
<p>如果现在你要兑换11元，按照贪心算法的思想，先选择面额最大的5元钱币进行兑换，那么就得到11 &#x3D; 5 + 5 + 1 的选择，这种情况是最优的</p>
<p>但是如果你手上钱币的面额为1、3、4，想要兑换6元，按照贪心算法的思路，我们会 6 &#x3D; 4 + 1 + 1这样选择，这种情况结果就不是最优的选择</p>
<p>从上面例子可以看到，贪心算法存在一些弊端，使用到贪心算法的场景，都会存在一个特性：</p>
<p>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法</p>
<p>至于是否选择贪心算法，主要看是否有如下两大特性：</p>
<ul>
<li>贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择</li>
<li>最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在</li>
</ul>
<h4 id="二、回溯算法"><a href="#二、回溯算法" class="headerlink" title="二、回溯算法"></a>二、回溯算法</h4><p>回溯算法，也是算法设计中的一种思想，是一种渐进式寻找并构建问题解决方式的策略</p>
<p>回溯算法会先从一个可能的工作开始解决问题，如果不行，就回溯并选择另一个动作，知道将问题解决</p>
<p>使用回溯算法的问题，有如下特性：</p>
<ul>
<li>有很多路，例如一个矩阵的方向或者树的路径</li>
<li>在这些的路里面，有死路也有生路，思路即不符合题目要求的路，生路则符合</li>
<li>通常使用递归来模拟所有的路</li>
</ul>
<p>常见的伪代码如下：</p>
<pre><code class="javascript">result = []
function backtrack(路径, 选择列表):
  if 满足结束条件:
    result.add(路径)
  return

  for 选择 of 选择列表:
    做选择
    backtrack(路径, 选择列表)
    撤销选择
</code></pre>
<p>重点解决三个问题：</p>
<ul>
<li>路径：也就是已经做出的选择</li>
<li>选择列表</li>
<li>结束条件</li>
</ul>
<p>例如经典使用回溯算法为解决全排列的问题，如下：</p>
<p>一个不含重复数字的数组 <code>nums</code> ，我们要返回其所有可能的全排列，解决这个问题的思路是：</p>
<ul>
<li>用递归模拟所有的情况</li>
<li>遇到包含重复元素的情况则回溯</li>
<li>收集到所有到达递归终点的情况，并返回、</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32613033306630302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">var permute = function(nums) &#123;
    const res = [], path = [];
    backtracking(nums, nums.length, []);
    return res;
    
    function backtracking(n, k, used) &#123;
        if(path.length === k) &#123;
            res.push(Array.from(path));
            return;
        &#125;
        for (let i = 0; i &lt; k; i++ ) &#123;
            if(used[i]) continue;
            path.push(n[i]);
            used[i] = true; // 同支
            backtracking(n, k, used);
            path.pop();
            used[i] = false;
        &#125;
    &#125;
&#125;;
</code></pre>
<h4 id="三、总结-3"><a href="#三、总结-3" class="headerlink" title="三、总结"></a>三、总结</h4><p>前面也初步了解到分而治之、动态规划，现在再了解到贪心算法、回溯算法</p>
<p>其中关于分而治之、动态规划、贪心策略三者的求解思路如下：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35303462353233302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>其中三者对应的经典问题如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36326364633931302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>算法篇</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题大全前端工程化</title>
    <url>/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（前端工程化）"><a href="#前端面试题大全（前端工程化）" class="headerlink" title="前端面试题大全（前端工程化）"></a>前端面试题大全（前端工程化）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="♥︎-♥︎-♥︎-什么是-bundle-什么是-chunk，什么是module？"><a href="#♥︎-♥︎-♥︎-什么是-bundle-什么是-chunk，什么是module？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是 bundle, 什么是 chunk，什么是module？"></a>♥︎ ♥︎ ♥︎ 什么是 bundle, 什么是 chunk，什么是module？</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>bundle</code>、<code>module</code>、<code>chunk</code> 都是 webpack 中的术语，下面就一个一个介绍他们的定义是什么，怎么产生的。</p>
<h5 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h5><p>Bundle是由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本。 Bundle 分离（Bundle Splitting）:这个流程提供了一个优化 build 的方法，允许 webpack 为应用程序生成多个 bundle。最终效果是，当其他某些 bundle 的改动时，彼此独立的另一些 bundle 都可以不受到影响，减少需要重新发布的代码量，因此由客户端重新下载并利用浏览器缓存。</p>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h5><p>模块（Module）提供比较完整程序接触面（surface area）更小的离散功能块。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。 模块解析（Module Resolution）一个模块可以作为另一个模块的依赖模块，resolver 是一个库（libary）用于帮助找不到模块的绝对路径，模块将在resolve.modules中指定的所有目录内搜索。</p>
<h5 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h5><p>Chunk这是 webpack 特定的术语被用在内部来管理 building 过程。bundle 是由 chunk 组成，其中有几种类型（例如，入口 chunk(entry chunk)和子 chunk(child chunk)）。通常 chunk 会直接对应所输出的 bundle，但是有一些配置并不会产生一对一的关系。 代码分离（Code Splitting）指将代码分离到每个 bundles&#x2F;chunks 里面，你可以按需加载，而不是加载一个包含全部的 bundle。 配置（Configuration）webpack 的配置文件是一个普通的 JavaScript 文件，它导出为一个对象。然后由 webpack 根据这个对象定义的属性进行处理。</p>
<h4 id="Bundle-VS-Chunk-VS-Module"><a href="#Bundle-VS-Chunk-VS-Module" class="headerlink" title="Bundle VS Chunk VS Module"></a>Bundle VS Chunk VS Module</h4><p>我们从定义和时期来说：</p>
<ul>
<li>“模块”<code>(module)</code>的概念大家都比较熟悉，如 <code>CommonJS 模块</code>、<code>AMD</code>、<code>ES6 Modules</code> 模块</li>
<li><code>chunk</code> 表示打包的时候产生得模块，由他来组成 <code>bundle</code></li>
<li>打包完成的源代码</li>
</ul>
<p>我们现在就只创建一个能编译<code>js</code>的<code>webpack</code>配置，步骤如下：</p>
<ol>
<li>创建一个空文件夹，并且在当文件夹中打开 <code>bash or cmd</code>。</li>
<li><code>npm init -y</code> 生成<code>package.json</code>。</li>
<li>如果你安装了<code>cnpm or yarn</code> 就执行 <code>cnpm i webpack webpack-cli -D</code>, 安装<code>webpack</code>的包。</li>
<li>创建<code>src</code>，在<code>src</code>内部创建<code>chunk0.js</code>、<code>chunk1.js</code>、<code>common.js</code>、<code>index.js</code>、<code>style.css</code>，并且编写内部代码</li>
<li>在项目根目录创建 <code>webpack.config.js</code></li>
<li>直接在<code>cmd</code>中运行 <code>webpack</code></li>
</ol>
<p>下面是代码 </p>
<p>chunk0.js</p>
<pre><code class="javascript">export default function add(a, b) &#123;
  return a + b;
&#125;
</code></pre>
<p>chunk1.js</p>
<pre><code class="javascript">export default function flow() &#123;
  return &quot;flow&quot;;
&#125;
</code></pre>
<p>common.js</p>
<pre><code class="javascript">export default function commonJs() &#123;
  return &quot;commonJs&quot;;
&#125;
</code></pre>
<p>index.js</p>
<pre><code class="javascript">import add from &quot;./chunk0.js&quot;;
import commonJs from &quot;./common&quot;;
console.log(add(1, 2));
console.log(commonJs());
</code></pre>
<p>webpack.config.js</p>
<pre><code class="java">module.exports = &#123;
  mode: &quot;production&quot;, // 如果不添加就会警告
  entry: &#123;
    index: &quot;./src/index.js&quot;, // 一个入口文件
    chunk1: &quot;./src/chunk1.js&quot; // 两一个入口文件
  &#125;,
  output: &#123;
    filename: &quot;[name].bundle.js&quot; // 出口文件
  &#125;
&#125;;
</code></pre>
<p>运行的效果如下</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image-20221104082742567.png"></p>
<p>通过上面的代码知道，<code>module</code> 就是没有被编译之前的代码，通过 <code>webpack</code> 的根据文件引用关系生成 <code>chunk</code> 文件，webpack 处理好 <code>chunk</code> 文件后，生成运行在浏览器中的代码 <code>bundle</code>。</p>
<h3 id="♥︎-♥︎-♥︎-hash-chunkhash-contenthash三者区别"><a href="#♥︎-♥︎-♥︎-hash-chunkhash-contenthash三者区别" class="headerlink" title="♥︎ ♥︎ ♥︎ hash chunkhash contenthash三者区别"></a>♥︎ ♥︎ ♥︎ hash chunkhash contenthash三者区别</h3><h4 id="一、Webpack与hash算法"><a href="#一、Webpack与hash算法" class="headerlink" title="一、Webpack与hash算法"></a>一、Webpack与hash算法</h4><p>在使用Webpack对构建的时候，Webpack会根据所有的文件内容计算出一个特殊的字符串。只要有文件的内容变化了，Webpack就会计算出一个新的特殊字符串。</p>
<p>Webpack在根据文件内容计算出一个特殊字符串的时候，使用的就是hash算法，这个特殊字符串一般叫做hash值。</p>
<p>我们一般取计算出的特殊字符串的前八位作为文件名的一部分，因为hash算法计算出的前八位基本可以保证唯一性了。</p>
<p>在Webpack里，我们通常用[hash:8]这种形式表示取hash值的前八位，例如在Webpack配置文件中，我们用 filename: ‘jQuery-[hash:8].js’。</p>
<h4 id="二、webpack中hash、chunkhash和contenthash的区别"><a href="#二、webpack中hash、chunkhash和contenthash的区别" class="headerlink" title="二、webpack中hash、chunkhash和contenthash的区别"></a>二、webpack中hash、chunkhash和contenthash的区别</h4><p>Webpack通过对文件进行hash算法获得的hash值，除了有hash，还有chunkhash和contenthash，那么这三者有什么不同呢？</p>
<p>首先，hash、chunkhash和contenthash这三者都是根据文件内容计算出的hash值，只是它们所计算的文件不一样。</p>
<p>hash是根据打包中所有的文件计算出的hash值。在一次打包中，所有出口文件的filename获得的[hash]都是一样的。</p>
<p>chunkhash是根据打包过程中当前chunk计算出的hash值。如果Webpack配置是多入口配置，那么通常会生成多个chunk，每个chunk对应的出口filename获得的[chunkhash]是不一样的。这样可以保证打包后每一个JS文件名都不一样（这么说不太严谨，但有助于理解）。</p>
<p>Webpack配置文件如下，第一次打包filename取值为’[name]-[hash:8].js’，第二次为’[name]-[chunkhash:8].js’。</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
module.exports = &#123;
    entry: &#123;
        app1: &#39;./a.js&#39;,
        app2: &#39;./b.js&#39;,
        app3: &#39;./c.js&#39;,
&#125;,
output: &#123;
path: path.resolve(__dirname, &#39;&#39;),
filename: &#39;[name]-[hash:8].js&#39;
// filename: &#39;[name]-[chunkhash:8].js&#39;
&#125;,
mode: &#39;none&#39;
&#125;;
</code></pre>
<p>contenthash有点像chunkhash，是根据打包时CSS内容计算出的hash值。一般在使用提取CSS的插件的时候，我们使用contenthash。例如下面的配置，我们生成的CSS文件名可能会是main.3aa2e3c6.css。</p>
<pre><code class="javascript">plugins:[
new miniExtractPlugin(&#123;
        filename: &#39;main.[contenthash:8].css&#39;
&#125;)
]
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Webpack中hash、chunkhash和contenthash主要与浏览器缓存行为有关。浏览器在初次请求服务端资源的时候，服务器给JS、CSS和图片等资源一个较长的缓存时间，我们通过给资源名称增加hash值来控制浏览器是否继续使用本地缓存。hash、chunkhash和contenthash这三者都是根据文件内容计算出的hash值，[hash]是根据全部参与打包的文件计算出来的，[chunkhash]是根据当前打包的chunk计算出来的，[contenthash]是CSS文件的。</p>
<h3 id="♥︎-♥︎-♥︎-你知道什么是脚手架吗？"><a href="#♥︎-♥︎-♥︎-你知道什么是脚手架吗？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你知道什么是脚手架吗？"></a>♥︎ ♥︎ ♥︎ 你知道什么是脚手架吗？</h3><p>脚手架的概念和作用：就是拥有完整的开发环境，帮助我们快速的生成一套既定的项目架构、文件、配置。使用者只需要专注自己的业务代码即可，不需要使用者单独配置 </p>
<p>脚手架的构成：常见的脚手架的开发环境主要分为三种模式：生产模式，开发模式，测试模式。以及需要配置完整的路由系统(vue-router,react-router-dom)，和状态管理系统(vuex,redux)才能保证开发环境的完整性 </p>
<p>常见的脚手架：Vue-cli,Creat-React-app,umi-app</p>
<h3 id="♥︎-♥︎-♥︎-你对webpack的理解？解决了什么问题？"><a href="#♥︎-♥︎-♥︎-你对webpack的理解？解决了什么问题？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你对webpack的理解？解决了什么问题？"></a>♥︎ ♥︎ ♥︎ 你对webpack的理解？解决了什么问题？</h3><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p><code>Webpack</code> 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p>
<h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的<code> JS</code> 文件中</p>
<p>约定每个文件是一个独立的模块，然后再将这些<code>js</code>文件引入到页面，一个<code>script</code>标签对应一个模块，然后调用模块化的成员</p>
<pre><code class="ini">&lt;script src=&quot;module-a.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;module-b.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题</p>
<p>项目一旦变大，上述问题会尤其明显</p>
<p>随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p>
<pre><code class="javascript">window.moduleA = &#123;
  method1: function () &#123;
    console.log(&#39;moduleA#method1&#39;)
  &#125;
&#125;
</code></pre>
<p>这种方式也并没有解决第一种方式的依赖等问题</p>
<p>再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下</p>
<pre><code class="javascript">// module-a.js
(function ($) &#123;
  var name = &#39;module-a&#39;

  function method1 () &#123;
    console.log(name + &#39;#method1&#39;)
    $(&#39;body&#39;).animate(&#123; margin: &#39;200px&#39; &#125;)
  &#125;
    
  window.moduleA = &#123;
    method1: method1
  &#125;
&#125;)(jQuery)
</code></pre>
<p>上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过<code>script</code>标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦</p>
<p>理想的解决方式是，在页面中引入一个<code>JS</code>入口文件，其余用到的模块可以通过代码控制，按需加载进来</p>
<p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS </code>、<code>ES Modules</code></p>
<h4 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h4><p>从后端渲染的<code>JSP</code>、<code>PHP</code>，到前端原生<code>JavaScript</code>，再到<code>jQuery</code>开发，再到目前的三大框架<code>Vue</code>、<code>React</code>、<code>Angular</code></p>
<p>开发方式，也从<code>javascript</code>到后面的<code>es5</code>、<code>es6、7、8、9、10</code>，再到<code>typescript</code>，包括编写<code>CSS</code>的预处理器<code>less</code>、<code>scss</code>等</p>
<p>现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：</p>
<ul>
<li>需要通过模块化的方式来开发</li>
<li>使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码</li>
<li>监听文件的变化来并且反映到浏览器上，提高开发的效率</li>
<li>JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题</li>
<li>开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化</li>
</ul>
<p>而<code>webpack</code>恰巧可以解决以上问题</p>
<h4 id="三、是什么"><a href="#三、是什么" class="headerlink" title="三、是什么"></a>三、是什么</h4><p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具</p>
<ul>
<li>静态模块</li>
</ul>
<p>这里的静态模块指的是开发阶段，可以被 <code>webpack</code> 直接引用的资源（可以直接被获取打包进<code>bundle.js</code>的资源）</p>
<p>当 <code>webpack </code>处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限<code>js</code>文件），并生成一个或多个 <code>bundle</code></p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39636531393461302d613537382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="webpack的能力："><a href="#webpack的能力：" class="headerlink" title="webpack的能力："></a><code>webpack</code>的能力：</h5><p>编译代码能力，提高效率，解决浏览器兼容问题<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63356332643336302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"><br>模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64333036643236302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"><br>万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65336335613034302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-webpack的核心思想是什么"><a href="#♥︎-♥︎-♥︎-webpack的核心思想是什么" class="headerlink" title="♥︎ ♥︎ ♥︎ webpack的核心思想是什么"></a>♥︎ ♥︎ ♥︎ webpack的核心思想是什么</h3><p>万物皆模块：在webpacck的世界中，其他任何资源都可以当做模块的方式引入 </p>
<p>代码分割：webapp 的优化关键在于代码体积，当应用体积增大，实现代码的按需加载是刚需，这也是 webpack 出现的根本原因 </p>
<p>可定制化：任何一个工具都不可能解决所有问题，提供解决方案才是最可行的，webpack基于可定制化的理念构建，通过插件系统，配置文件，可实现大型项目的定制需求</p>
<h3 id="♥︎-♥︎-♥︎-说说webpack的构建流程"><a href="#♥︎-♥︎-♥︎-说说webpack的构建流程" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说webpack的构建流程?"></a>♥︎ ♥︎ ♥︎ 说说webpack的构建流程?</h3><h4 id="一、运行流程"><a href="#一、运行流程" class="headerlink" title="一、运行流程"></a>一、运行流程</h4><p><code>webpack</code> 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来</p>
<p>在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条<code>webpack</code>机制中，去改变<code>webpack</code>的运作，使得整个系统扩展性良好</p>
<p>从启动到结束会依次执行以下三大步骤：</p>
<ul>
<li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li>编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>
<li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li>
</ul>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62353636643430302d613635382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h5><p>从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数</p>
<p>配置文件默认下为<code>webpack.config.js</code>，也或者通过命令的形式指定配置文件，主要作用是用于激活<code>webpack</code>的加载项和插件</p>
<p>关于文件配置内容分析，如下注释：</p>
<pre><code class="javascript">var path = require(&#39;path&#39;);
var node_modules = path.resolve(__dirname, &#39;node_modules&#39;);
var pathToReact = path.resolve(node_modules, &#39;react/dist/react.min.js&#39;);

module.exports = &#123;
  // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。
  entry: &#39;./path/to/my/entry/file.js&#39;，
  // 文件路径指向(可加快打包过程)。
  resolve: &#123;
    alias: &#123;
      &#39;react&#39;: pathToReact
    &#125;
  &#125;,
  // 生成文件，是模块构建的终点，包括输出文件与输出路径。
  output: &#123;
    path: path.resolve(__dirname, &#39;build&#39;),
    filename: &#39;[name].js&#39;
  &#125;,
  // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。
  module: &#123;
    loaders: [
      &#123;
        test: /\.js$/,
        loader: &#39;babel&#39;,
        query: &#123;
          presets: [&#39;es2015&#39;, &#39;react&#39;]
        &#125;
      &#125;
    ],
    noParse: [pathToReact]
  &#125;,
  // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
&#125;;
webpack` 将 `webpack.config.js` 中的各个配置项拷贝到 `options` 对象中，并加载用户配置的 `plugins
</code></pre>
<p>完成上述步骤之后，则开始初始化<code>Compiler</code>编译对象，该对象掌控者<code>webpack</code>声明周期，不执行具体的任务，只是进行一些调度工作</p>
<pre><code class="javascript">class Compiler extends Tapable &#123;
    constructor(context) &#123;
        super();
        this.hooks = &#123;
            beforeCompile: new AsyncSeriesHook([&quot;params&quot;]),
            compile: new SyncHook([&quot;params&quot;]),
            afterCompile: new AsyncSeriesHook([&quot;compilation&quot;]),
            make: new AsyncParallelHook([&quot;compilation&quot;]),
            entryOption: new SyncBailHook([&quot;context&quot;, &quot;entry&quot;])
            // 定义了很多不同类型的钩子
        &#125;;
        // ...
    &#125;
&#125;

function webpack(options) &#123;
  var compiler = new Compiler();
  ...// 检查options,若watch字段为true,则开启watch线程
  return compiler;
&#125;
...
</code></pre>
<p><code>Compiler</code> 对象继承自 <code>Tapable</code>，初始化时定义了很多钩子函数</p>
<h5 id="编译构建流程"><a href="#编译构建流程" class="headerlink" title="编译构建流程"></a>编译构建流程</h5><p>根据配置中的 <code>entry</code> 找出所有的入口文件</p>
<pre><code class="javascript">module.exports = &#123;
  entry: &#39;./src/file.js&#39;
&#125;
</code></pre>
<p>初始化完成后会调用<code>Compiler</code>的<code>run</code>来真正启动<code>webpack</code>编译构建流程，主要流程如下：</p>
<ul>
<li><code>compile</code> 开始编译</li>
<li><code>make</code> 从入口点分析模块及其依赖的模块，创建这些模块对象</li>
<li><code>build-module</code> 构建模块</li>
<li><code>seal</code> 封装构建结果</li>
<li><code>emit</code> 把各个chunk输出到结果文件</li>
</ul>
<h5 id="compile-编译"><a href="#compile-编译" class="headerlink" title="compile 编译"></a>compile 编译</h5><p>执行了<code>run</code>方法后，首先会触发<code>compile</code>，主要是构建一个<code>Compilation</code>对象</p>
<p>该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象</p>
<h5 id="make-编译模块"><a href="#make-编译模块" class="headerlink" title="make 编译模块"></a>make 编译模块</h5><p>当完成了上述的<code>compilation</code>对象后，就开始从<code>Entry</code>入口文件开始读取，主要执行<code>_addModuleChain()</code>函数，如下：</p>
<pre><code class="javascript">_addModuleChain(context, dependency, onModule, callback) &#123;
   ...
   // 根据依赖查找对应的工厂函数
   const Dep = /** @type &#123;DepConstructor&#125; */ (dependency.constructor);
   const moduleFactory = this.dependencyFactories.get(Dep);
   
   // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象
   moduleFactory.create(&#123;
       dependencies: [dependency]
       ...
   &#125;, (err, module) =&gt; &#123;
       ...
       const afterBuild = () =&gt; &#123;
        this.processModuleDependencies(module, err =&gt; &#123;
         if (err) return callback(err);
         callback(null, module);
           &#125;);
    &#125;;
       
       this.buildModule(module, false, null, null, err =&gt; &#123;
           ...
           afterBuild();
       &#125;)
   &#125;)
&#125;
</code></pre>
<p>过程如下：</p>
<p><code>_addModuleChain</code>中接收参数<code>dependency</code>传入的入口依赖，使用对应的工厂函数<code>NormalModuleFactory.create</code>方法生成一个空的<code>module</code>对象</p>
<p>回调中会把此<code>module</code>存入<code>compilation.modules</code>对象和<code>dependencies.module</code>对象中，由于是入口文件，也会存入<code>compilation.entries</code>中</p>
<p>随后执行<code>buildModule</code>进入真正的构建模块<code>module</code>内容的过程</p>
<h5 id="build-module-完成模块编译"><a href="#build-module-完成模块编译" class="headerlink" title="build module 完成模块编译"></a>build module 完成模块编译</h5><p>这里主要调用配置的<code>loaders</code>，将我们的模块转成标准的<code>JS</code>模块</p>
<p>在用<code> Loader</code> 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 <code>Webpack </code>后面对代码的分析</p>
<p>从配置的入口模块开始，分析其 <code>AST</code>，当遇到<code>require</code>等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</p>
<h5 id="输出流程"><a href="#输出流程" class="headerlink" title="输出流程"></a>输出流程</h5><h5 id="seal-输出资源"><a href="#seal-输出资源" class="headerlink" title="seal 输出资源"></a>seal 输出资源</h5><p><code>seal</code>方法主要是要生成<code>chunks</code>，对<code>chunks</code>进行一系列的优化操作，并生成要输出的代码</p>
<p><code>webpack</code> 中的 <code>chunk</code> ，可以理解为配置在 <code>entry</code> 中的模块，或者是动态引入的模块</p>
<p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表</p>
<h5 id="emit-输出完成"><a href="#emit-输出完成" class="headerlink" title="emit 输出完成"></a>emit 输出完成</h5><p>在确定好输出内容后，根据配置确定输出的路径和文件名</p>
<pre><code class="javascript">output: &#123;
    path: path.resolve(__dirname, &#39;build&#39;),
        filename: &#39;[name].js&#39;
&#125;
</code></pre>
<p>在 <code>Compiler</code> 开始生成文件前，钩子 <code>emit</code> 会被执行，这是我们修改最终文件的最后一个机会</p>
<p>从而<code>webpack</code>整个打包过程则结束了</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64373766633536302d613635382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-Loader和Plugin的区别"><a href="#♥︎-♥︎-♥︎-Loader和Plugin的区别" class="headerlink" title="♥︎ ♥︎ ♥︎  Loader和Plugin的区别"></a>♥︎ ♥︎ ♥︎  Loader和Plugin的区别</h3><h4 id="loader是一个转换器"><a href="#loader是一个转换器" class="headerlink" title="loader是一个转换器"></a>loader是一个转换器</h4><p>1、用于对模块源码文件的预编译和转换，，loader描述了webpack如何处理非javascript模块。</p>
<p>2、没有loader，构建的打包过程无法顺利完成</p>
<p>3、loader作用在打包前</p>
<p>4、将A文件转换为B文件，操作的是文件，比如将A.scss转换为A.css，是单纯的文件转换过程</p>
<h4 id="Plugin是插件扩展器"><a href="#Plugin是插件扩展器" class="headerlink" title="Plugin是插件扩展器"></a>Plugin是插件扩展器</h4><p>1、plugin构建过程更完整的补充和优化，如使用new UglifyJsPlugin(),new CssMinimizerPlugin()压缩js和css</p>
<p>2、没有plugin，文件的打包过程可以完成</p>
<p>3、plugin作用于整个打包过程，</p>
<p>4、针对webpack的打包过程，他不直接操作文件，而是基于事件机制工作，会监听webpack打包过程的事件钩子，执行任务，通过事件钩子拦截webpack的执行。</p>
<h3 id="♥︎-♥︎-♥︎-有哪些常见的Loader"><a href="#♥︎-♥︎-♥︎-有哪些常见的Loader" class="headerlink" title="♥︎ ♥︎ ♥︎ 有哪些常见的Loader"></a>♥︎ ♥︎ ♥︎ 有哪些常见的Loader</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>loader</code> 用于对模块的”源代码”进行转换，在 <code>import</code> 或”加载”模块时预处理文件</p>
<p><code>webpack</code>做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。如下图所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37623864393634302d613666662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在<code>webpack</code>内部中，任何文件都是模块，不仅仅只是<code>js</code>文件</p>
<p>默认情况下，在遇到<code>import</code>或者<code>load</code>加载模块的时候，<code>webpack</code>只支持对<code>js</code>文件打包</p>
<p>像<code>css</code>、<code>sass</code>、<code>png</code>等这些类型的文件的时候，<code>webpack</code>则无能为力，这时候就需要配置对应的<code>loader</code>进行文件内容的解析</p>
<p>在加载模块的时候，执行顺序如下：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39633263343362302d613666662d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>当 <code>webpack</code> 碰到不识别的模块的时候，<code>webpack</code> 会在配置的中查找该文件解析规则</p>
<p>关于配置<code>loader</code>的方式有三种：</p>
<ul>
<li>配置方式（推荐）：在 webpack.config.js文件中指定 loader</li>
<li>内联方式：在每个 import 语句中显式指定 loader</li>
<li>CLI 方式：在 shell 命令中指定它们</li>
</ul>
<h5 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h5><p>关于<code>loader</code>的配置，我们是写在<code>module.rules</code>属性中，属性介绍如下：</p>
<ul>
<li><code>rules</code>是一个数组的形式，因此我们可以配置很多个<code>loader</code></li>
<li>每一个<code>loader</code>对应一个对象的形式，对象属性<code>test</code> 为匹配的规则，一般情况为正则表达式</li>
<li>属性<code>use</code>针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</li>
</ul>
<p>代码编写，如下形式：</p>
<pre><code class="javascript">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        test: /\.css$/,
        use: [
          &#123; loader: &#39;style-loader&#39; &#125;,
          &#123;
            loader: &#39;css-loader&#39;,
            options: &#123;
              modules: true
            &#125;
          &#125;,
          &#123; loader: &#39;sass-loader&#39; &#125;
        ]
      &#125;
    ]
  &#125;
&#125;;
</code></pre>
<h4 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h4><p>这里继续拿上述代码，来讲讲<code>loader</code>的特性</p>
<p>从上述代码可以看到，在处理<code>css</code>模块的时候，<code>use</code>属性中配置了三个<code>loader</code>分别处理<code>css</code>文件</p>
<p>因为<code>loader </code>支持链式调用，链中的每个<code>loader</code>会处理之前已处理过的资源，最终变为<code>js</code>代码。顺序为相反的顺序执行，即上述执行方式为<code>sass-loader</code>、<code>css-loader</code>、<code>style-loader</code></p>
<p>除此之外，<code>loader</code>的特性还有如下：</p>
<ul>
<li>loader 可以是同步的，也可以是异步的</li>
<li>loader 运行在 Node.js 中，并且能够执行任何操作</li>
<li>除了常见的通过 <code>package.json</code> 的 <code>main</code> 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 <code>loader</code> 字段直接引用一个模块</li>
<li>插件(plugin)可以为 loader 带来更多特性</li>
<li>loader 能够产生额外的任意文件</li>
</ul>
<p>可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和更多其他特性</p>
<h4 id="三、常见的loader"><a href="#三、常见的loader" class="headerlink" title="三、常见的loader"></a>三、常见的loader</h4><p>在页面开发过程中，我们经常性加载除了<code>js</code>文件以外的内容，这时候我们就需要配置响应的<code>loader</code>进行加载</p>
<p>常见的<code>loader</code>如下：</p>
<ul>
<li>style-loader: 将css添加到DOM的内联样式标签style里</li>
<li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li>
<li>less-loader: 处理less</li>
<li>sass-loader: 处理sass</li>
<li>postcss-loader: 用postcss来处理CSS</li>
<li>autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss</li>
<li>file-loader: 分发文件到output目录并返回相对路径</li>
<li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li>
<li>html-minify-loader: 压缩HTML</li>
<li>babel-loader :用babel来转换ES6文件到ES</li>
</ul>
<p>下面给出一些常见的<code>loader</code>的使用：</p>
<h5 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h5><p>分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p>
<pre><code class="javascript">npm install --save-dev css-loader
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: &#123;
      loader: &quot;css-loader&quot;,
      options: &#123;
     // 启用/禁用 url() 处理
     url: true,
     // 启用/禁用 @import 处理
     import: true,
        // 启用/禁用 Sourcemap
        sourceMap: false
      &#125;
    &#125;
 &#125;
]
</code></pre>
<p>如果只通过<code>css-loader</code>加载文件，这时候页面代码设置的样式并没有生效</p>
<p>原因在于，<code>css-loader</code>只是负责将<code>.css</code>文件进行一个解析，而并不会将解析后的<code>css</code>插入到页面中</p>
<p>如果我们希望再完成插入<code>style</code>的操作，那么我们还需要另外一个<code>loader</code>，就是<code>style-loader</code></p>
<h5 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h5><p>把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到页面的 <code>head</code> 中</p>
<pre><code class="javascript">npm install --save-dev style-loader
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;]
 &#125;
]
</code></pre>
<p>同一个任务的 <code>loader</code> 可以同时挂载多个，处理顺序为：从右到左，从下往上</p>
<h5 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h5><p>开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高，这里需要使用<code>less-loader</code></p>
<pre><code class="javascript">npm install less-loader -D
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;,&quot;less-loader&quot;]
 &#125;
]
</code></pre>
<h5 id="raw-loader"><a href="#raw-loader" class="headerlink" title="raw-loader"></a>raw-loader</h5><p>在 <code>webpack </code>中通过 <code>import </code>方式导入文件内容，该<code>loader </code>并不是内置的，所以首先要安装</p>
<pre><code class="shell">npm install --save-dev raw-loader
</code></pre>
<p>然后在 webpack.config.js 中进行配置</p>
<pre><code class="javascript">module.exports = &#123;  
...,  
module: &#123;      
rules: [      
&#123;        
test: /\.(txt|md)$/,  
use: &#39;raw-loader&#39;   
&#125;   
] &#125;&#125;
</code></pre>
<h5 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h5><p>把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串)</p>
<pre><code class="javascript">npm install --save-dev file-loader
rules: [  ..., &#123;  
test: /\.(png|jpe?g|gif)$/,    
use: &#123;      
loader: &quot;file-loader&quot;,  
options: &#123;       
// placeholder 占位符 [name] 源资源模块的名称        
// [ext] 源资源模块的后缀       
name: &quot;[name]_[hash].[ext]&quot;,        //打包后的存放位置        
outputPath: &quot;./images&quot;,        // 打包后文件的 url        
publicPath: &#39;./images&#39;,      &#125;    &#125; &#125;]
</code></pre>
<h5 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h5><p>可以处理理 <code>file-loader</code> 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code> 格式的字符串，并打包到 <code>js</code> 中，对小体积的图片比较合适，大图片不合适。</p>
<pre><code class="javascript">npm install --save-dev url-loader
rules: [  ..., &#123;  
        test: /\.(png|jpe?g|gif)$/,    
        use: &#123;     
        loader: &quot;url-loader&quot;,      
        options: &#123;        
        // placeholder 占位符 [name] 源资源模块的名称        
        // [ext] 源资源模块的后缀        
        name: &quot;[name]_[hash].[ext]&quot;,        //打包后的存放位置        
        outputPath: &quot;./images&quot;        // 打包后文件的 url        
        publicPath: &#39;./images&#39;,        // 小于 100 字节转成 base64 格式        limit: 100      &#125;    &#125; &#125;]
</code></pre>
<h3 id="♥︎-♥︎-♥︎-有哪些常见的Plugin"><a href="#♥︎-♥︎-♥︎-有哪些常见的Plugin" class="headerlink" title="♥︎ ♥︎ ♥︎ 有哪些常见的Plugin"></a>♥︎ ♥︎ ♥︎ 有哪些常见的Plugin</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>Plugin</code>（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能</p>
<p>是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据</p>
<p><code>webpack</code>中的<code>plugin</code>也是如此，<code>plugin</code>赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 <code>webpack</code> 的不同阶段（钩子 &#x2F; 生命周期），贯穿了<code>webpack</code>整个编译周期</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39613034656334302d613763322d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>目的在于解决<code>loader</code> 无法实现的其他事</p>
<h5 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h5><p>这里讲述文件的配置方式，一般情况，通过配置文件导出对象中<code>plugins</code>属性传入<code>new</code>实例对象。如下所示：</p>
<pre><code class="javascript">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); // 通过 npm 安装
const webpack = require(&#39;webpack&#39;); // 访问内置的插件
module.exports = &#123;
  ...
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin(&#123; template: &#39;./src/index.html&#39; &#125;),
  ],
&#125;;
</code></pre>
<h4 id="二、特性-1"><a href="#二、特性-1" class="headerlink" title="二、特性"></a>二、特性</h4><p>其本质是一个具有<code>apply</code>方法<code>javascript</code>对象</p>
<p><code>apply</code> 方法会被 <code>webpack compiler </code>调用，并且在整个编译生命周期都可以访问 <code>compiler </code>对象</p>
<pre><code class="javascript">const pluginName = &#39;ConsoleLogOnBuildWebpackPlugin&#39;;

class ConsoleLogOnBuildWebpackPlugin &#123;
  apply(compiler) &#123;
    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;
      console.log(&#39;webpack 构建过程开始！&#39;);
    &#125;);
  &#125;
&#125;

module.exports = ConsoleLogOnBuildWebpackPlugin;
</code></pre>
<p><code>compiler hook</code> 的 <code>tap </code>方法的第一个参数，应是驼峰式命名的插件名称</p>
<p>关于整个编译生命周期钩子，有如下：</p>
<ul>
<li>entry-option ：初始化 option</li>
<li>run</li>
<li>compile： 真正开始的编译，在创建 compilation 对象之前</li>
<li>compilation ：生成好了 compilation 对象</li>
<li>make 从 entry 开始递归分析依赖，准备对每个模块进行 build</li>
<li>after-compile： 编译 build 过程结束</li>
<li>emit ：在将内存中 assets 内容写到磁盘文件夹之前</li>
<li>after-emit ：在将内存中 assets 内容写到磁盘文件夹之后</li>
<li>done： 完成所有的编译过程</li>
<li>failed： 编译失败的时候</li>
</ul>
<h4 id="三、常见的Plugin"><a href="#三、常见的Plugin" class="headerlink" title="三、常见的Plugin"></a>三、常见的Plugin</h4><p>常见的<code>plugin</code>有如图所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643734393430302d613763322d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>下面介绍几个常用的插件用法：</p>
<h5 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h5><p>在打包结束后，⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code> js</code> 模块引⼊到该 <code>html</code> 中</p>
<pre><code class="javascript">npm install --save-dev html-webpack-plugin
// webpack.config.js
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
module.exports = &#123;
 ...
  plugins: [
     new HtmlWebpackPlugin(&#123;
       title: &quot;My App&quot;,
       filename: &quot;app.html&quot;,
       template: &quot;./src/html/index.html&quot;
     &#125;) 
  ]
&#125;;
&lt;!--./src/html/index.html--&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;%=htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;html-webpack-plugin&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在 <code>html</code> 模板中，可以通过 <code>&lt;%=htmlWebpackPlugin.options.XXX%&gt;</code> 的方式获取配置的值</p>
<p>更多的配置可以自寻查找</p>
<h5 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h5><p>删除（清理）构建目录</p>
<pre><code class="javascript">npm install --save-dev clean-webpack-plugin
const &#123;CleanWebpackPlugin&#125; = require(&#39;clean-webpack-plugin&#39;);
module.exports = &#123;
 ...
  plugins: [
    ...,
    new CleanWebpackPlugin(),
    ...
  ]
&#125;
</code></pre>
<h5 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h5><p>提取 <code>CSS</code> 到一个单独的文件中</p>
<pre><code class="javascript">npm install --save-dev mini-css-extract-plugin
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
module.exports = &#123; ...,  
                  module: &#123;   
                  rules: [    
                  &#123;     test: /\.s[ac]ss$/,     
                  use: [     
                  &#123;      loader: MiniCssExtractPlugin.loader     &#125;,          
  &#39;css-loader&#39;,          &#39;sass-loader&#39;        ]   &#125;   ] &#125;,  
    plugins: [    ...,    
              new MiniCssExtractPlugin(&#123;     filename: &#39;[name].css&#39;    &#125;),    ...  ]&#125;
</code></pre>
<h5 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h5><p>允许在编译时创建配置的全局对象，是一个<code>webpack</code>内置的插件，不需要安装</p>
<pre><code class="javascript">const &#123; DefinePlugun &#125; = require(&#39;webpack&#39;)module.exports = &#123; ...    plugins:[        new DefinePlugin(&#123;            BASE_URL:&#39;&quot;./&quot;&#39;        &#125;)    ]&#125;
</code></pre>
<p>这时候编译<code>template</code>模块的时候，就能通过下述形式获取全局对象</p>
<pre><code class="javascript">&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL%&gt;favicon.ico&gt;&quot;
</code></pre>
<h5 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h5><p>复制文件或目录到执行区域，如<code>vue</code>的打包过程中，如果我们将一些文件放到<code>public</code>的目录下，那么这个目录会被复制到<code>dist</code>文件夹中</p>
<pre><code class="javascript">npm install copy-webpack-plugin -D
new CopyWebpackPlugin(&#123;    parrerns:[        &#123;            
  from:&quot;public&quot;,            
  globOptions:&#123;                i
               gnore:[                    &#39;**/index.html&#39;                ]            &#125;        &#125;    ]&#125;)
</code></pre>
<p>复制的规则在<code>patterns</code>属性中设置：</p>
<ul>
<li>from：设置从哪一个源中开始复制</li>
<li>to：复制到的位置，可以省略，会默认复制到打包的目录下</li>
<li>globOptions：设置一些额外的选项，其中可以编写需要忽略的文件</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-说一下-Webpack-的热更新原理"><a href="#♥︎-♥︎-♥︎-说一下-Webpack-的热更新原理" class="headerlink" title="♥︎ ♥︎ ♥︎ 说一下 Webpack 的热更新原理"></a>♥︎ ♥︎ ♥︎ 说一下 Webpack 的热更新原理</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>HMR </code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</p>
<p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失</p>
<p>如果使用的是 <code>HMR</code>，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用</p>
<p>在<code>webpack</code>中配置开启热模块也非常的简单，如下代码：</p>
<pre><code class="javascript">const webpack = require(&#39;webpack&#39;)
module.exports = &#123;
  // ...
  devServer: &#123;
    // 开启 HMR 特性
    hot: true
    // hotOnly: true
  &#125;
&#125;
</code></pre>
<p>通过上述这种配置，如果我们修改并保存<code>css</code>文件，确实能够以不刷新的形式更新到页面中</p>
<p>但是，当我们修改并保存<code>js</code>文件之后，页面依旧自动刷新了，这里并没有触发热模块</p>
<p>所以，<code>HMR </code>并不像 <code>Webpack</code> 的其他特性一样可以开箱即用，需要有一些额外的操作</p>
<p>我们需要去指定哪些模块发生更新时进行<code>HRM</code>，如下代码：</p>
<pre><code class="javascript">if(module.hot)&#123;
    module.hot.accept(&#39;./util.js&#39;,()=&gt;&#123;
        console.log(&quot;util.js更新了&quot;)
    &#125;)
&#125;
</code></pre>
<h4 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h4><p>首先来看看一张图，如下：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61646330353738302d616364342d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<ul>
<li>Webpack Compile：将 JS 源代码编译成 bundle.js</li>
<li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li>
<li>Bundle Server：静态资源文件服务器，提供文件访问路径</li>
<li>HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化</li>
<li>bundle.js：构建输出的文件</li>
<li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li>
</ul>
<p>上面图中，可以分成两个阶段：</p>
<ul>
<li>启动阶段为上图 1 - 2 - A - B</li>
</ul>
<p>在编写未经过<code>webpack</code>打包的源代码后，<code>Webpack Compile</code> 将源代码和 <code>HMR Runtime</code> 一起编译成 <code>bundle </code>文件，传输给<code> Bundle Server</code> 静态资源服务器</p>
<ul>
<li>更新阶段为上图 1 - 2 - 3 - 4</li>
</ul>
<p>当某一个文件或者模块发生变化时，<code>webpack </code>监听到文件变化对文件重新编译打包，编译生成唯一的<code>hash</code>值，这个<code>hash </code>值用来作为下一次热更新的标识</p>
<p>根据变化的内容生成两个补丁文件：<code>manifest</code>（包含了 <code>hash</code> 和 <code>chundId </code>，用来说明变化的内容）和<code> chunk.js</code> 模块</p>
<p>由于<code>socket</code>服务器在<code>HMR Runtime</code> 和 <code>HMR Server</code>之间建立 <code>websocket</code>链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的<code>hash</code>值，如下图的<code>h</code>属性，作为下一次热更细的标识</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30356130656466302d616434612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在浏览器接受到这条消息之前，浏览器已经在上一次<code> socket</code> 消息中已经记住了此时的<code> hash</code> 标识，这时候我们会创建一个 <code>ajax</code> 去服务端请求获取到变化内容的 <code>manifest</code> 文件</p>
<p><code>mainfest</code>文件包含重新<code>build</code>生成的<code>hash</code>值，以及变化的模块，对应上图的<code>c</code>属性</p>
<p>浏览器根据 <code>manifest</code> 文件获取模块变化的内容，从而触发<code>render</code>流程，实现局部模块更新</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30653762373835302d616434612d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>关于<code>webpack</code>热模块更新的总结如下：</p>
<ul>
<li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li>
<li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li>
<li>socket server 是一个 websocket 的长连接，双方可以通信</li>
<li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li>
<li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li>
<li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何优化-Webpack-的构建速度"><a href="#♥︎-♥︎-♥︎-如何优化-Webpack-的构建速度" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何优化 Webpack 的构建速度"></a>♥︎ ♥︎ ♥︎ 如何优化 Webpack 的构建速度</h3><h4 id="一、背景-1"><a href="#一、背景-1" class="headerlink" title="一、背景"></a>一、背景</h4><p>随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 <code>webpack</code> 的构建时间也会越来越久</p>
<p>构建时间与我们日常开发效率密切相关，当我们本地开发启动 <code>devServer</code> 或者 <code>build</code> 的时候，如果时间过长，会大大降低我们的工作效率</p>
<p>所以，优化<code>webpack</code> 构建速度是十分重要的环节</p>
<h4 id="二、如何优化"><a href="#二、如何优化" class="headerlink" title="二、如何优化"></a>二、如何优化</h4><p>常见的提升构建速度的手段有如下：</p>
<ul>
<li>优化 loader 配置</li>
<li>合理使用 resolve.extensions</li>
<li>优化 resolve.modules</li>
<li>优化 resolve.alias</li>
<li>使用 DLLPlugin 插件</li>
<li>使用 cache-loader</li>
<li>terser 启动多线程</li>
<li>合理使用 sourceMap</li>
</ul>
<h5 id="优化loader配置"><a href="#优化loader配置" class="headerlink" title="优化loader配置"></a>优化loader配置</h5><p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件，接触<code>include</code>、<code>exclude</code>规定哪些匹配应用<code>loader</code></p>
<p>如采用 ES6 的项目为例，在配置 <code>babel-loader </code>时，可以这样：</p>
<pre><code class="javascript">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        // 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能
        test: /\.js$/,
        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启
        use: [&#39;babel-loader?cacheDirectory&#39;],
        // 只对项目根目录下的 src 目录中的文件采用 babel-loader
        include: path.resolve(__dirname, &#39;src&#39;),
      &#125;,
    ]
  &#125;,
&#125;;
</code></pre>
<h5 id="合理使用-resolve-extensions"><a href="#合理使用-resolve-extensions" class="headerlink" title="合理使用 resolve.extensions"></a>合理使用 resolve.extensions</h5><p>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， <code>resolve</code>可以帮助<code>webpack</code>从每个 <code>require/import</code> 语句中，找到需要引入到合适的模块代码</p>
<p>通过<code>resolve.extensions</code>是解析到文件时自动添加拓展名，默认情况如下：</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    extensions:[&quot;.warm&quot;,&quot;.mjs&quot;,&quot;.js&quot;,&quot;.json&quot;]
&#125;
</code></pre>
<p>当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找</p>
<p>当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度</p>
<h5 id="优化-resolve-modules"><a href="#优化-resolve-modules" class="headerlink" title="优化 resolve.modules"></a>优化 resolve.modules</h5><p><code>resolve.modules</code> 用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。默认值为<code>[&#39;node_modules&#39;]</code>，所以默认会从<code>node_modules</code>中查找文件<br>当安装的第三方模块都放在项目根目录下的 <code>./node_modules </code>目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p>
<pre><code class="javascript">module.exports = &#123;
  resolve: &#123;
    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤
    // 其中 __dirname 表示当前工作目录，也就是项目根目录
    modules: [path.resolve(__dirname, &#39;node_modules&#39;)]
  &#125;,
&#125;;
</code></pre>
<h5 id="优化-resolve-alias"><a href="#优化-resolve-alias" class="headerlink" title="优化 resolve.alias"></a>优化 resolve.alias</h5><p><code>alias</code>给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式</p>
<p>通过配置<code>alias</code>以减少查找过程</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    resolve:&#123;
        alias:&#123;
            &quot;@&quot;:path.resolve(__dirname,&#39;./src&#39;)
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="使用-DLLPlugin-插件"><a href="#使用-DLLPlugin-插件" class="headerlink" title="使用 DLLPlugin 插件"></a>使用 DLLPlugin 插件</h5><p><code>DLL</code>全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中</p>
<p>使用步骤分成两部分：</p>
<ul>
<li>打包一个 DLL 库</li>
<li>引入 DLL 库</li>
</ul>
<h6 id="打包一个-DLL-库"><a href="#打包一个-DLL-库" class="headerlink" title="打包一个 DLL 库"></a>打包一个 DLL 库</h6><p><code>webpack</code>内置了一个<code>DllPlugin</code>可以帮助我们打包一个DLL的库文件</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    plugins:[
        new webpack.DllPlugin(&#123;
            name:&#39;dll_[name]&#39;,
            path:path.resolve(__dirname,&quot;./dll/[name].mainfest.json&quot;)
        &#125;)
    ]
&#125;
</code></pre>
<h6 id="引入-DLL-库"><a href="#引入-DLL-库" class="headerlink" title="引入 DLL 库"></a>引入 DLL 库</h6><p>使用 <code>webpack</code> 自带的 <code>DllReferencePlugin</code> 插件对 <code>mainfest.json</code> 映射文件进行分析，获取要使用的<code>DLL</code>库</p>
<p>然后再通过<code>AddAssetHtmlPlugin</code>插件，将我们打包的<code>DLL</code>库引入到<code>Html</code>模块中</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    new webpack.DllReferencePlugin(&#123;
        context:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;),
        mainfest:path.resolve(__dirname,&quot;./dll/react.mainfest.json&quot;)
    &#125;),
    new AddAssetHtmlPlugin(&#123;
        outputPath:&quot;./auto&quot;,
        filepath:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;)
    &#125;)
&#125;
</code></pre>
<h5 id="使用-cache-loader"><a href="#使用-cache-loader" class="headerlink" title="使用 cache-loader"></a>使用 cache-loader</h5><p>在一些性能开销较大的 <code>loader </code>之前添加 <code>cache-loader</code>，以将结果缓存到磁盘里，显著提升二次构建速度</p>
<p>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code> loader</code></p>
<pre><code class="javascript">module.exports = &#123;
    module: &#123;
        rules: [
            &#123;
                test: /\.ext$/,
                use: [&#39;cache-loader&#39;, ...loaders],
                include: path.resolve(&#39;src&#39;),
            &#125;,
        ],
    &#125;,
&#125;;
</code></pre>
<h5 id="terser-启动多线程"><a href="#terser-启动多线程" class="headerlink" title="terser 启动多线程"></a>terser 启动多线程</h5><p>使用多进程并行运行来提高构建速度</p>
<pre><code class="javascript">module.exports = &#123;
  optimization: &#123;
    minimizer: [
      new TerserPlugin(&#123;
        parallel: true,
      &#125;),
    ],
  &#125;,
&#125;;
</code></pre>
<h5 id="合理使用-sourceMap"><a href="#合理使用-sourceMap" class="headerlink" title="合理使用 sourceMap"></a>合理使用 sourceMap</h5><p>打包生成 <code>sourceMap</code> 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31313634376166302d623031642d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，优化<code>webpack</code>构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手</p>
<h3 id="♥︎-♥︎-♥︎-自己写过Loader和Plugin么"><a href="#♥︎-♥︎-♥︎-自己写过Loader和Plugin么" class="headerlink" title="♥︎ ♥︎ ♥︎ 自己写过Loader和Plugin么"></a>♥︎ ♥︎ ♥︎ 自己写过Loader和Plugin么</h3><h4 id="一、编写loader"><a href="#一、编写loader" class="headerlink" title="一、编写loader"></a>一、编写loader</h4><p>在编写 <code>loader</code> 前，我们首先需要了解 <code>loader</code> 的本质</p>
<p>其本质为函数，函数中的 <code>this</code> 作为上下文会被 <code>webpack</code> 填充，因此我们不能将 <code>loader</code>设为一个箭头函数</p>
<p>函数接受一个参数，为 <code>webpack</code> 传递给 <code>loader</code> 的文件源内容</p>
<p>函数中 <code>this</code> 是由 <code>webpack</code> 提供的对象，能够获取当前 <code>loader</code> 所需要的各种信息</p>
<p>函数中有异步操作或同步操作，异步操作通过 <code>this.callback</code> 返回，返回值要求为 <code>string</code> 或者 <code>Buffer</code></p>
<p>代码如下所示：</p>
<pre><code class="javascript">// 导出一个函数，source为webpack传递给loader的文件源内容
module.exports = function(source) &#123;
    const content = doSomeThing2JsString(source);
    
    // 如果 loader 配置了 options 对象，那么this.query将指向 options
    const options = this.query;
    
    // 可以用作解析其他模块路径的上下文
    console.log(&#39;this.context&#39;);
    
    /*
     * this.callback 参数：
     * error：Error | null，当 loader 出错时向外抛出一个 error
     * content：String | Buffer，经过 loader 编译后需要导出的内容
     * sourceMap：为方便调试生成的编译后内容的 source map
     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程
     */
    this.callback(null, content); // 异步
    return content; // 同步
&#125;
</code></pre>
<p>一般在编写<code>loader</code>的过程中，保持功能单一，避免做多种功能</p>
<p>如<code>less</code>文件转换成 <code>css </code>文件也不是一步到位，而是 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code>几个 <code>loader </code>的链式调用才能完成转换</p>
<h4 id="二、编写plugin"><a href="#二、编写plugin" class="headerlink" title="二、编写plugin"></a>二、编写plugin</h4><p>由于<code>webpack</code>基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务</p>
<p>在之前也了解过，<code>webpack</code>编译会创建两个核心对象：</p>
<ul>
<li>compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子</li>
<li>compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建</li>
</ul>
<p>如果自己要实现<code>plugin</code>，也需要遵循一定的规范：</p>
<ul>
<li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例</li>
<li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，因此不建议修改</li>
<li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住</li>
</ul>
<p>实现<code>plugin</code>的模板如下：</p>
<pre><code class="javascript">class MyPlugin &#123;
    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象
  apply (compiler) &#123;
    // 找到合适的事件钩子，实现自己的插件功能
    compiler.hooks.emit.tap(&#39;MyPlugin&#39;, compilation =&gt; &#123;
        // compilation: 当前打包构建流程的上下文
        console.log(compilation);
        
        // do something...
    &#125;)
  &#125;
&#125;
</code></pre>
<p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容</p>
<h4 id="三、手写一个loader和plugin"><a href="#三、手写一个loader和plugin" class="headerlink" title="三、手写一个loader和plugin"></a>三、手写一个loader和plugin</h4><p><a href="https://juejin.cn/post/6844903689442820110">手写一个loader和plugin</a></p>
<h3 id="♥︎-♥︎-♥︎-webpack-proxy工作原理？为什么能解决跨域"><a href="#♥︎-♥︎-♥︎-webpack-proxy工作原理？为什么能解决跨域" class="headerlink" title="♥︎ ♥︎ ♥︎ webpack proxy工作原理？为什么能解决跨域?"></a>♥︎ ♥︎ ♥︎ webpack proxy工作原理？为什么能解决跨域?</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p>
<p>基本行为就是接收客户端发送的请求后转发给其他服务器</p>
<p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p>
<p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p>
<h5 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h5><p><code>webpack-dev-server</code>是 <code>webpack</code> 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起</p>
<p>目的是为了提高开发者日常的开发效率，只适用在开发阶段</p>
<p>关于配置方面，在<code>webpack</code>配置对象属性中通过<code>devServer</code>属性提供，如下：</p>
<pre><code class="javascript">// ./webpack.config.js
const path = require(&#39;path&#39;)

module.exports = &#123;
    // ...
    devServer: &#123;
        contentBase: path.join(__dirname, &#39;dist&#39;),
        compress: true,
        port: 9000,
        proxy: &#123;
            &#39;/api&#39;: &#123;
                target: &#39;https://api.github.com&#39;
            &#125;
        &#125;
        // ...
    &#125;
&#125;
</code></pre>
<p><code>devServetr</code>里面<code>proxy</code>则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p>
<p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为<code> /api</code>，值为对应的代理匹配规则，对应如下：</p>
<ul>
<li>target：表示的是代理到的目标地址</li>
<li>pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite</li>
<li>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false</li>
<li>changeOrigin：它表示是否更新代理后请求的 headers 中host地址</li>
</ul>
<h4 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h4><p><code>proxy</code>工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器</p>
<p>举个例子：</p>
<p>在开发阶段，本地地址为<code>http://localhost:3000</code>，该浏览器发送一个前缀带有<code>/api</code>标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p>
<pre><code class="javascript">const express = require(&#39;express&#39;);
const proxy = require(&#39;http-proxy-middleware&#39;);

const app = express();

app.use(&#39;/api&#39;, proxy(&#123;target: &#39;http://www.example.org&#39;, changeOrigin: true&#125;));
app.listen(3000);

// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar
</code></pre>
<h4 id="三、跨域"><a href="#三、跨域" class="headerlink" title="三、跨域"></a>三、跨域</h4><p>在开发阶段， <code>webpack-dev-server</code> 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 <code>localhost </code>的一个端口上，而后端服务又是运行在另外一个地址上</p>
<p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p>
<p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p>
<p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36356235653563302d616365352d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据</p>
<p>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</p>
<h3 id="♥︎-♥︎-♥︎-如何借助webpack来优化前端性能？"><a href="#♥︎-♥︎-♥︎-如何借助webpack来优化前端性能？" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何借助webpack来优化前端性能？"></a>♥︎ ♥︎ ♥︎ 如何借助webpack来优化前端性能？</h3><h4 id="一、背景-2"><a href="#一、背景-2" class="headerlink" title="一、背景"></a>一、背景</h4><p>随着前端的项目逐渐扩大，必然会带来的一个问题就是性能</p>
<p>尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃</p>
<p>一般项目在完成后，会通过<code>webpack</code>进行打包，利用<code>webpack</code>对前端项目性能优化是一个十分重要的环节</p>
<h4 id="二、如何优化-1"><a href="#二、如何优化-1" class="headerlink" title="二、如何优化"></a>二、如何优化</h4><p>通过<code>webpack</code>优化前端的手段有：</p>
<ul>
<li>JS代码压缩</li>
<li>CSS代码压缩</li>
<li>Html文件代码压缩</li>
<li>文件大小压缩</li>
<li>图片压缩</li>
<li>Tree Shaking</li>
<li>代码分离</li>
<li>内联 chunk</li>
</ul>
<h5 id="JS代码压缩"><a href="#JS代码压缩" class="headerlink" title="JS代码压缩"></a>JS代码压缩</h5><p><code>terser</code>是一个<code>JavaScript</code>的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让<code>bundle</code>更小</p>
<p>在<code>production</code>模式下，<code>webpack</code> 默认就是使用 <code>TerserPlugin</code> 来处理我们的代码的。如果想要自定义配置它，配置方法如下：</p>
<pre><code class="javascript">const TerserPlugin = require(&#39;terser-webpack-plugin&#39;)
module.exports = &#123;
    ...
    optimization: &#123;
        minimize: true,
        minimizer: [
            new TerserPlugin(&#123;
                parallel: true // 电脑cpu核数-1
            &#125;)
        ]
    &#125;
&#125;
</code></pre>
<p>属性介绍如下：</p>
<ul>
<li>extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释</li>
<li>parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1</li>
<li>terserOptions：设置我们的terser相关的配置：<ul>
<li>compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true</li>
<li>mangle：设置丑化相关的选项，可以直接设置为true</li>
<li>toplevel：底层变量是否进行转换</li>
<li>keep_classnames：保留类的名称</li>
<li>keep_fnames：保留函数的名称</li>
</ul>
</li>
</ul>
<h5 id="CSS代码压缩"><a href="#CSS代码压缩" class="headerlink" title="CSS代码压缩"></a>CSS代码压缩</h5><p><code>CSS</code>压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等</p>
<p>CSS的压缩我们可以使用另外一个插件：<code>css-minimizer-webpack-plugin</code></p>
<pre><code class="ini">npm install css-minimizer-webpack-plugin -D
</code></pre>
<p>配置方法如下：</p>
<pre><code class="javascript">const CssMinimizerPlugin = require(&#39;css-minimizer-webpack-plugin&#39;)
module.exports = &#123;
    // ...
    optimization: &#123;
        minimize: true,
        minimizer: [
            new CssMinimizerPlugin(&#123;
                parallel: true
            &#125;)
        ]
    &#125;
&#125;
</code></pre>
<h5 id="Html文件代码压缩"><a href="#Html文件代码压缩" class="headerlink" title="Html文件代码压缩"></a>Html文件代码压缩</h5><p>使用<code>HtmlWebpackPlugin</code>插件来生成<code>HTML</code>的模板时候，通过配置属性<code>minify</code>进行<code>html</code>优化</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    plugin:[
        new HtmlwebpackPlugin(&#123;
            ...
            minify:&#123;
                minifyCSS:false, // 是否压缩css
                collapseWhitespace:false, // 是否折叠空格
                removeComments:true // 是否移除注释
            &#125;
        &#125;)
    ]
&#125;
</code></pre>
<p>设置了<code>minify</code>，实际会使用另一个插件<code>html-minifier-terser</code></p>
<h5 id="文件大小压缩"><a href="#文件大小压缩" class="headerlink" title="文件大小压缩"></a>文件大小压缩</h5><p>对文件的大小进行压缩，减少<code>http</code>传输过程中宽带的损耗</p>
<pre><code class="javascript">npm install compression-webpack-plugin -D
new ComepressionPlugin(&#123;
    test:/\.(css|js)$/,  // 哪些文件需要压缩
    threshold:500, // 设置文件多大开始压缩
    minRatio:0.7, // 至少压缩的比例
    algorithm:&quot;gzip&quot;, // 采用的压缩算法
&#125;)
</code></pre>
<h5 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h5><p>一般来说在打包之后，一些图片文件的大小是远远要比 <code>js</code> 或者 <code>css</code> 文件要来的大，所以图片压缩较为重要</p>
<p>配置方法如下：</p>
<pre><code class="javascript">module: &#123;
  rules: [
    &#123;
      test: /\.(png|jpg|gif)$/,
      use: [
        &#123;
          loader: &#39;file-loader&#39;,
          options: &#123;
            name: &#39;[name]_[hash].[ext]&#39;,
            outputPath: &#39;images/&#39;,
          &#125;
        &#125;,
        &#123;
          loader: &#39;image-webpack-loader&#39;,
          options: &#123;
            // 压缩 jpeg 的配置
            mozjpeg: &#123;
              progressive: true,
              quality: 65
            &#125;,
            // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭
            optipng: &#123;
              enabled: false,
            &#125;,
            // 使用 imagemin-pngquant 压缩 png
            pngquant: &#123;
              quality: &#39;65-90&#39;,
              speed: 4
            &#125;,
            // 压缩 gif 的配置
            gifsicle: &#123;
              interlaced: false,
            &#125;,
            // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式
            webp: &#123;
              quality: 75
            &#125;
          &#125;
        &#125;
      ]
    &#125;,
  ]
&#125; 
</code></pre>
<h5 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h5><p><code>Tree Shaking</code> 是一个术语，在计算机中表示消除死代码，依赖于<code>ES Module</code>的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）</p>
<p>在<code>webpack</code>实现<code>Trss shaking</code>有两种不同的方案：</p>
<ul>
<li>usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的</li>
<li>sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用</li>
</ul>
<p>两种不同的配置方案， 有不同的效果</p>
<h5 id="usedExports"><a href="#usedExports" class="headerlink" title="usedExports"></a>usedExports</h5><p>配置方法也很简单，只需要将<code>usedExports</code>设为<code>true</code></p>
<pre><code class="javascript">module.exports = &#123;
    ...
    optimization:&#123;
        usedExports
    &#125;
&#125;
</code></pre>
<p>使用之后，没被用上的代码在<code>webpack</code>打包中会加入<code>unused harmony export mul</code>注释，用来告知 <code>Terser</code> 在优化时，可以删除掉这段代码</p>
<p>如下面<code>sum</code>函数没被用到，<code>webpack</code>打包会添加注释，<code>terser</code>在优化时，则将该函数去掉</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32316232653230302d616565342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h5><p><code>sideEffects</code>用于告知<code>webpack compiler</code>哪些模块时有副作用，配置方法是在<code>package.json</code>中设置<code>sideEffects</code>属性</p>
<p>如果<code>sideEffects</code>设置为false，就是告知<code>webpack</code>可以安全的删除未用到的<code>exports</code></p>
<p>如果有些文件需要保留，可以设置为数组的形式</p>
<pre><code class="javascript">&quot;sideEffecis&quot;:[    &quot;./src/util/format.js&quot;,    &quot;*.css&quot; // 所有的css文件]
</code></pre>
<p>上述都是关于<code>javascript</code>的<code>tree shaking</code>，<code>css</code>同样也能够实现<code>tree shaking</code></p>
<h5 id="css-tree-shaking"><a href="#css-tree-shaking" class="headerlink" title="css tree shaking"></a>css tree shaking</h5><p><code>css</code>进行<code>tree shaking</code>优化可以安装<code>PurgeCss</code>插件</p>
<pre><code class="javascript">npm install purgecss-plugin-webpack -D
const PurgeCssPlugin = require(&#39;purgecss-webpack-plugin&#39;)module.exports = &#123;    ...    plugins:[        new PurgeCssPlugin(&#123;            path:glob.sync(`$&#123;path.resolve(&#39;./src&#39;)&#125;/**/*`), &#123;nodir:true&#125;// src里面的所有文件            satelist:function()&#123;                return &#123;                    standard:[&quot;html&quot;]                &#125;            &#125;        &#125;)    ]&#125;
</code></pre>
<ul>
<li>paths：表示要检测哪些目录下的内容需要被分析，配合使用glob</li>
<li>默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性</li>
</ul>
<h5 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h5><p>将代码分离到不同的<code>bundle</code>中，之后我们可以按需加载，或者并行加载这些文件</p>
<p>默认情况下，所有的<code>JavaScript</code>代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度</p>
<p>代码分离可以分出出更小的<code>bundle</code>，以及控制资源加载优先级，提供代码的加载性能</p>
<p>这里通过<code>splitChunksPlugin</code>来实现，该插件<code>webpack</code>已经默认安装和集成，只需要配置即可</p>
<p>默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all</p>
<pre><code class="javascript">module.exports = &#123;    ...    optimization:&#123;        splitChunks:&#123;            chunks:&quot;all&quot;        &#125;    &#125;&#125;
</code></pre>
<p><code>splitChunks</code>主要属性有如下：</p>
<ul>
<li>Chunks，对同步代码还是异步代码进行处理</li>
<li>minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分</li>
<li>maxSize： 将大于maxSize的包，拆分为不小于minSize的包</li>
<li>minChunks：被引入的次数，默认是1</li>
</ul>
<h5 id="内联chunk"><a href="#内联chunk" class="headerlink" title="内联chunk"></a>内联chunk</h5><p>可以通过<code>InlineChunkHtmlPlugin</code>插件将一些<code>chunk</code>的模块内联到<code>html</code>，如<code>runtime</code>的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的</p>
<pre><code class="javascript">const InlineChunkHtmlPlugin = require(&#39;react-dev-utils/InlineChunkHtmlPlugin&#39;)const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)module.exports = &#123;    ...    plugin:[        new InlineChunkHtmlPlugin(HtmlWebpackPlugin,[/runtime.+\.js/]&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>关于<code>webpack</code>对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化</p>
<h3 id="♥︎-♥︎-♥︎-与webpack类似的工具还有哪些？区别？"><a href="#♥︎-♥︎-♥︎-与webpack类似的工具还有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ 与webpack类似的工具还有哪些？区别？"></a>♥︎ ♥︎ ♥︎ 与webpack类似的工具还有哪些？区别？</h3><h4 id="一、模块化工具"><a href="#一、模块化工具" class="headerlink" title="一、模块化工具"></a>一、模块化工具</h4><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式</p>
<p>可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)</p>
<p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code></p>
<p>通过这些模块打包工具，能够提高我们的开发效率，减少开发成本</p>
<p>这里没有提及<code>gulp</code>、<code>grunt</code>是因为它们只是定义为构建工具，不能类比</p>
<h5 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h5><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup </code>要小巧的多</p>
<p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p>
<p>举个例子：</p>
<pre><code class="javascript">// ./src/messages.js
export default &#123;
  hi: &#39;Hey Guys, I am zce~&#39;
&#125;

// ./src/logger.js
export const log = msg =&gt; &#123;
  console.log(&#39;---------- INFO ----------&#39;)
  console.log(msg)
  console.log(&#39;--------------------------&#39;)
&#125;

export const error = msg =&gt; &#123;
  console.error(&#39;---------- ERROR ----------&#39;)
  console.error(msg)
  console.error(&#39;---------------------------&#39;)
&#125;

// ./src/index.js
import &#123; log &#125; from &#39;./logger&#39;
import messages from &#39;./messages&#39;
log(messages.hi)
</code></pre>
<p>然后通过<code>rollup</code>进行打包</p>
<pre><code class="ini">$ npx rollup ./src/index.js --file ./dist/bundle.js
</code></pre>
<p>打包结果如下图</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38666530373833302d623134332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>可以看到，代码非常简洁，完成不像<code>webpack</code>那样存在大量引导代码和模块函数</p>
<p>并且<code>error</code>方法由于没有被使用，输出的结果中并无<code>error</code>方法，可以看到，<code>rollup</code>默认开始<code>Tree-shaking</code> 优化输出结果</p>
<p>因此，可以看到<code>Rollup</code>的优点：</p>
<ul>
<li>代码效率更简洁、效率更高</li>
<li>默认支持 Tree-shaking</li>
</ul>
<p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup </code>需要使用插件去完成</p>
<p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p>
<p>但是在用于打包<code> JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p>
<h5 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h5><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p>
<p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。如下所示：</p>
<pre><code class="javascript">&lt;!-- ./src/index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Parcel Tutorials&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>main.js文件通过<code>ES Moudle</code>方法导入其他模块成员</p>
<pre><code class="javascript">// ./src/main.js
import &#123; log &#125; from &#39;./logger&#39;
log(&#39;hello parcel&#39;)
// ./src/logger.js
export const log = msg =&gt; &#123;
  console.log(&#39;---------- INFO ----------&#39;)
  console.log(msg)
&#125;
</code></pre>
<p>运行之后，使用命令打包</p>
<pre><code class="ini">npx parcel src/index.html
</code></pre>
<p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个开发服务器，跟<code>webpack Dev Server</code>一样</p>
<p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单</p>
<p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p>
<p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p>
<p>打包命令如下：</p>
<pre><code class="ini">npx parcel src/index.html
</code></pre>
<p>由于打包过程是多进程同时工作，构建速度会比<code>Webpack</code> 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65633137653761302d623161322d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>可以感受到，<code>Parcel </code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决</p>
<h5 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h5><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p>
<p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p>
<p>下图给出<code>webpack</code>与<code>snowpack</code>打包区别：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37393139373833302d623161332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新</p>
<h5 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h5><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p>
<p>它主要由两部分组成：</p>
<ul>
<li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR</li>
<li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li>
</ul>
<p>其作用类似<code>webpack </code>+ <code>webpack-dev-server</code>，其特点如下：</p>
<ul>
<li>快速的冷启动</li>
<li>即时的模块热更新</li>
<li>真正的按需编译</li>
</ul>
<p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p>
<p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p>
<p>原理图如下所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39663265656433302d623134332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p>
<h5 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h5><p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：一切皆模块和按需加载</p>
<p>与其他构建工具相比，有如下优势：</p>
<ul>
<li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li>
<li>万物模块：对 js、css、图片等资源文件都支持打包</li>
<li>开箱即用：HRM、Tree-shaking等功能</li>
<li>代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li>
<li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li>
<li>易于调试：支持 SourceUrls 和 SourceMaps</li>
<li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li>
<li>生态环境好：社区更丰富，出现的问题更容易解决</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-代码分割的本质是什么？有什么意义呢？"><a href="#♥︎-♥︎-♥︎-代码分割的本质是什么？有什么意义呢？" class="headerlink" title="♥︎ ♥︎ ♥︎ 代码分割的本质是什么？有什么意义呢？"></a>♥︎ ♥︎ ♥︎ 代码分割的本质是什么？有什么意义呢？</h3><p>代码分割的本质： 是能够把代码分离到不同的bundle中，避免出现大体积的代码包，然后可以按需加载或并行加载这些文件 </p>
<p>代码分离的意义： 代码分离可以获取更小的bundle，以及控制资源加载优先级，合理使用可以极大的减少加载时间 </p>
<p>代码分割的实现方式有三种： 入口起点：使用entry手动分离代码(不建议) 防止重复加载：</p>
<p>使用optimization.splitChunks配置选项，可以将第三方公共模块和业务代码直接分离 </p>
<p>动态引入：使 用import()方法来分离代码，原理是当 Webpack 解析到该语法时，会自动进行代码分割，分割出不同的chunks  </p>
<p>语法：使用的时候再去下载对应的文件，返回一个Promise，当Promise成功后再去执行回调</p>
<h3 id="♥︎-♥︎-♥︎-说下-tree-shaking-的原理"><a href="#♥︎-♥︎-♥︎-说下-tree-shaking-的原理" class="headerlink" title="♥︎ ♥︎ ♥︎ 说下 tree-shaking 的原理"></a>♥︎ ♥︎ ♥︎ 说下 tree-shaking 的原理</h3><p><a href="https://juejin.cn/post/7002410645316436004">tree-shaking 的原理</a></p>
<h3 id="♥︎-♥︎-♥︎-babel原理"><a href="#♥︎-♥︎-♥︎-babel原理" class="headerlink" title="♥︎ ♥︎ ♥︎  babel原理"></a>♥︎ ♥︎ ♥︎  babel原理</h3><p><a href="https://blog.csdn.net/wmaoshu/article/details/119813090">babel原理</a></p>
<h3 id="♥︎-♥︎-♥︎-linux部署和windows-sever服务器区别？"><a href="#♥︎-♥︎-♥︎-linux部署和windows-sever服务器区别？" class="headerlink" title="♥︎ ♥︎ ♥︎  linux部署和windows sever服务器区别？"></a>♥︎ ♥︎ ♥︎  linux部署和windows sever服务器区别？</h3><p>性价比：Linux服务器性价比更高，Linux作为资源管理器和操作系统来说，是开源的，免费的，而正版windows的操作系统是收费的。</p>
<p>性能方面：相同配置的Linux服务器的性能比windows服务器好一些，Linux服务器占用的资源少一点</p>
<p>稳定性方面：Window系统用户量大，因而攻击者多一些，所以暴露了更多的系统安全漏洞。Linux是多用户多进程系统，意味着Linux能够一次性处理大量正在进行的进程，比windows处理的多</p>
<p>安全性方面：Linux系统开源软件的开发方式有助于暴露错误，集众人智慧解决问题，补丁更新更快。这是windows不具备的，Windows的另一个不利因素是其许多应用程序依靠远程过程调用，这就迫使Windows的防火墙没有Linux那样严格。而Linux远程过程调用是限制使用的。</p>
<h3 id="♥︎-♥︎-♥︎-前端资源发布路径怎么实现非覆盖式发布（平滑升级）？"><a href="#♥︎-♥︎-♥︎-前端资源发布路径怎么实现非覆盖式发布（平滑升级）？" class="headerlink" title="♥︎ ♥︎ ♥︎ 前端资源发布路径怎么实现非覆盖式发布（平滑升级）？"></a>♥︎ ♥︎ ♥︎ 前端资源发布路径怎么实现非覆盖式发布（平滑升级）？</h3><p><a href="https://juejin.cn/post/6844903457984512014">前端资源发布路径怎么实现非覆盖式发布</a></p>
<h3 id="♥︎-♥︎-♥︎-你有发布过自己的npm包吗？流程是怎样的？"><a href="#♥︎-♥︎-♥︎-你有发布过自己的npm包吗？流程是怎样的？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你有发布过自己的npm包吗？流程是怎样的？"></a>♥︎ ♥︎ ♥︎ 你有发布过自己的npm包吗？流程是怎样的？</h3><p><a href="https://blog.csdn.net/CapejasmineY/article/details/126251986">npm包发布流程</a></p>
<h3 id="♥︎-♥︎-♥︎-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？"><a href="#♥︎-♥︎-♥︎-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？" class="headerlink" title="♥︎ ♥︎ ♥︎ 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？"></a>♥︎ ♥︎ ♥︎ 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</h3><p><a href="https://www.jianshu.com/p/75786d5c9cac">npm 模块安装机制</a></p>
<h3 id="♥︎-♥︎-♥︎-你会搭建私有的npm仓库吗？怎么搭建？"><a href="#♥︎-♥︎-♥︎-你会搭建私有的npm仓库吗？怎么搭建？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你会搭建私有的npm仓库吗？怎么搭建？"></a>♥︎ ♥︎ ♥︎ 你会搭建私有的npm仓库吗？怎么搭建？</h3><p><a href="https://zhaomenghuan.js.org/blog/npm-private-repository-verdaccio.html">私有的npm仓库</a></p>
<h3 id="♥︎-♥︎-♥︎-jenkins-上线流程"><a href="#♥︎-♥︎-♥︎-jenkins-上线流程" class="headerlink" title="♥︎ ♥︎ ♥︎  jenkins 上线流程"></a>♥︎ ♥︎ ♥︎  jenkins 上线流程</h3><p><a href="https://developer.aliyun.com/article/608413">jenkins 上线流程</a></p>
<h3 id="♥︎-♥︎-♥︎-什么是长缓存，在webpack中如何做到长缓存优化？"><a href="#♥︎-♥︎-♥︎-什么是长缓存，在webpack中如何做到长缓存优化？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是长缓存，在webpack中如何做到长缓存优化？"></a>♥︎ ♥︎ ♥︎ 什么是长缓存，在webpack中如何做到长缓存优化？</h3><p>浏览器在用户访问页面的时候，都会对静态资源进行存储，但是每次代码更新或者升级的时候，我们都需要浏览器去重新加载代码，最方便的方法就是以文件名的方式引入，只下载新的代码块，不加载旧的没有变化的代码块，这就是长缓存，</p>
<p>在webpack4中使用SplitChunkPlugin把第三方库和业务代码分离，由于第三方库的chunkHash未改变，所以只会对改变的业务代码的模块进行更新。而第三方库的代码块因为长缓存而不更新。</p>
<h3 id="♥︎-♥︎-♥︎-什么是组件？什么是模块化？有什么区别？"><a href="#♥︎-♥︎-♥︎-什么是组件？什么是模块化？有什么区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是组件？什么是模块化？有什么区别？"></a>♥︎ ♥︎ ♥︎ 什么是组件？什么是模块化？有什么区别？</h3><p>组件化</p>
<p>就是基础库或者基础组件，意思是把代码重复的部分提炼出一个个组件供给功能使用</p>
<p>模块化</p>
<p>就是业务框架或者业务模块，也可以理解为框架，意思是把功能进行划分，将同一类型的代码整合在一起，所以模</p>
<p>块的功能相对复杂，都属于同一个业务。</p>
<p>区别：</p>
<p>使用：组件的使用能在不同项目(模块)重复应用的代码，而模块按照项目功能需求划分成不同类型的业务框架 </p>
<p>目的：组件是复用，解耦，模块是为了隔离、封装 </p>
<p>依赖：组件之间低依赖，比较独立，模块之间的依赖可通过路由进行耦合 </p>
<p>架构定位：组件位于架构底层，被其它层所依赖，模块位于架构业务层</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://juejin.cn/post/6844903935795265549">https://juejin.cn/post/6844903935795265549</a></p>
<p><a href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全TypeScript</title>
    <url>/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（TypeScript）"><a href="#前端面试题大全（TypeScript）" class="headerlink" title="前端面试题大全（TypeScript）"></a>前端面试题大全（TypeScript）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-typescript-的理解？与-javascript-的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-typescript-的理解？与-javascript-的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 typescript 的理解？与 javascript 的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 typescript 的理解？与 javascript 的区别？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>TypeScript</code> 是 <code>JavaScript</code> 的类型的超集，支持<code>ES6</code>语法，支持面向对象编程的概念，如类、接口、继承、泛型等</p>
<blockquote>
<p>超集，不得不说另外一个概念，子集，怎么理解这两个呢，举个例子，如果一个集合A里面的的所有元素集合B里面都存在，那么我们可以理解集合B是集合A的超集，集合A为集合B的子集</p>
</blockquote>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36316332633166302d303935302d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>其是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误</p>
<p>同时扩展了<code> JavaScript</code> 的语法，所以任何现有的<code> JavaScript</code> 程序可以不加改变的在 <code>TypeScript</code> 下工作</p>
<p>为了保证兼容性，<code>typescript</code>在编译阶段需要编译器编译成纯<code>Javascript</code>来运行，是为大型应用之开发而设计的语言，如下：</p>
<p><code>tsx</code>文件如下：</p>
<pre><code class="typescript">const hello : string = &quot;Hello World!&quot;
console.log(hello)
</code></pre>
<p>编译文件后：</p>
<pre><code class="tsx">const hello = &quot;Hello World!&quot;
console.log(hello)
</code></pre>
<h4 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h4><p><code>typescript</code>的特性主要有如下：</p>
<ul>
<li>类型批注和编译时类型检查 ：在编译时批注变量类型</li>
<li>类型推断：ts中没有批注变量类型会自动推断变量的类型</li>
<li>类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除</li>
<li>接口：ts中用接口来定义对象类型</li>
<li>枚举：用于取值被限定在一定范围内的场景</li>
<li>Mixin：可以接受任意类型的值</li>
<li>泛型编程：写代码时使用一些以后才指定的类型</li>
<li>名字空间：名字只在该区域内有效，其他区域可重复使用该名字而不冲突</li>
<li>元组：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li>
<li>…</li>
</ul>
<h5 id="类型批注"><a href="#类型批注" class="headerlink" title="类型批注"></a>类型批注</h5><p>通过类型批注提供在编译时启动类型检查的静态类型，这是可选的，而且可以忽略而使用<code>JavaScript</code>常规的动态类型</p>
<pre><code class="tsx">function Add(left: number, right: number): number &#123;
 return left + right;
&#125;
</code></pre>
<p>对于基本类型的批注是<code>number</code>、<code>bool</code>和<code>string</code>，而弱或动态类型的结构则是<code>any</code>类型</p>
<h5 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h5><p>当类型没有给出时，TypeScript编译器利用类型推断来推断类型，如下：</p>
<pre><code class="tsx">let str = &#39;string&#39;
</code></pre>
<p>变量<code>str</code>被推断为字符串类型，这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</p>
<p>如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态<code>any</code>类型</p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口简单来说就是用来描述对象的类型 数据的类型有<code>number</code>、<code> null</code>、<code> string</code>等数据格式，对象的类型就是用接口来描述的</p>
<pre><code class="tsx">interface Person &#123;
    name: string;
    age: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25
&#125;;
</code></pre>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><ul>
<li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li>
<li>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译</li>
<li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li>
<li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件</li>
</ul>
<p>更多的区别如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36623534343034302d303935302d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-typescript-的数据类型有哪些"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-typescript-的数据类型有哪些" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ typescript 的数据类型有哪些?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ typescript 的数据类型有哪些?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>typescript</code> 和 <code>javascript</code>几乎一样，拥有相同的数据类型，另外在<code>javascript</code>基础上提供了更加实用的类型供开发使用</p>
<p>在开发阶段，可以为明确的变量定义为某种类型，这样<code>typescript</code>就能在编译阶段进行类型检查，当类型不合符预期结果的时候则会出现错误提示</p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p><code>typescript</code> 的数据类型主要有如下：</p>
<ul>
<li>boolean（布尔类型）</li>
<li>number（数字类型）</li>
<li>string（字符串类型）</li>
<li>array（数组类型）</li>
<li>tuple（元组类型）</li>
<li>enum（枚举类型）</li>
<li>any（任意类型）</li>
<li>null 和 undefined 类型</li>
<li>Symbol 类型</li>
<li>bigint类型</li>
<li>void 类型</li>
<li>never 类型</li>
<li>object 对象类型</li>
<li>unknown</li>
</ul>
<h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><p>布尔类型</p>
<pre><code class="tsx">let flag:boolean = true;
// flag = 123; // 错误
flag = false;  //正确
</code></pre>
<h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><p>数字类型，和<code>javascript</code>一样，<code>typescript</code>的数值类型都是浮点数，可支持二进制、八进制、十进制和十六进制</p>
<pre><code class="tsx">let num:number = 123;
// num = &#39;456&#39;; // 错误
num = 456;  //正确
</code></pre>
<p>进制表示：</p>
<pre><code class="tsx">let decLiteral: number = 6; // 十进制
let hexLiteral: number = 0xf00d; // 十六进制
let binaryLiteral: number = 0b1010; // 二进制
let octalLiteral: number = 0o744; // 八进制
</code></pre>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>字符串类型，和<code>JavaScript</code>一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串</p>
<pre><code class="tsx">let str:string = &#39;this is ts&#39;;
str = &#39;test&#39;;
</code></pre>
<p>作为超集，当然也可以使用模版字符串&#96;&#96;进行包裹，通过 ${} 嵌入变量</p>
<pre><code class="tsx">let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is $&#123; name &#125;
</code></pre>
<h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>数组类型，跟<code>javascript</code>一致，通过<code>[]</code>进行包裹，有两种写法：</p>
<p>方式一：元素类型后面接上 <code>[]</code></p>
<pre><code class="tsx"> let arr:string[] = [&#39;12&#39;, &#39;23&#39;];
 arr = [&#39;45&#39;, &#39;56&#39;];
</code></pre>
<p>方式二：使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<pre><code class="tsx">let arr:Array&lt;number&gt; = [1, 2];
arr = [&#39;45&#39;, &#39;56&#39;];
</code></pre>
<h5 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h5><p>元祖类型，允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p>
<pre><code class="tsx">let tupleArr:[number, string, boolean];
tupleArr = [12, &#39;34&#39;, true]; //ok
typleArr = [12, &#39;34&#39;] // no ok
</code></pre>
<p>赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致</p>
<h5 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h5><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p>
<pre><code class="tsx">enum Color &#123;Red, Green, Blue&#125;
let c: Color = Color.Green;
</code></pre>
<h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><p>可以指定任何类型的值，在编程阶段还不清楚类型的变量指定一个类型，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，这时候可以使用<code>any</code>类型</p>
<p>使用<code>any</code>类型允许被赋值为任意类型，甚至可以调用其属性、方法</p>
<pre><code class="tsx">let num:any = 123;
num = &#39;str&#39;;
num = true;
</code></pre>
<p>定义存储各种类型数据的数组时，示例代码如下：</p>
<pre><code class="tsx">let arrayList: any[] = [1, false, &#39;fine&#39;];
arrayList[1] = 100;
</code></pre>
<h5 id="null-和-和-undefined"><a href="#null-和-和-undefined" class="headerlink" title="null 和 和 undefined"></a>null 和 和 undefined</h5><p>在<code> JavaScript</code> 中 <code>null </code>表示 “什么都没有”，是一个只有一个值的特殊类型，表示一个空对象引用，而<code>undefined</code>表示一个没有设置值的变量</p>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型， 就是说你可以把 <code>null </code>和 <code>undefined </code>赋值给 <code>number </code>类型的变量</p>
<pre><code class="tsx">let num:number | undefined; // 数值类型 或者 undefined
console.log(num); // 正确
num = 123;
console.log(num); // 正确
</code></pre>
<p>但是<code>ts</code>配置了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自</p>
<h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><p>用于标识方法返回值的类型，表示该方法没有返回值。</p>
<pre><code class="tsx">function hello(): void &#123;
    alert(&quot;Hello Runoob&quot;);
&#125;
</code></pre>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>symbol我们平时用的比较少，所以可能了解也不是很多，这里就详细来说说symbol。</p>
<h6 id="（1）symbol-基本使用"><a href="#（1）symbol-基本使用" class="headerlink" title="（1）symbol 基本使用"></a>（1）symbol 基本使用</h6><p>symbol 是 ES6 新增的一种基本数据类型，它用来表示独一无二的值，可以通过 Symbol 构造函数生成。</p>
<pre><code class="typescript">const s = Symbol(); 
typeof s; // symbol
</code></pre>
<p>注意：Symbol 前面不能加 new关键字，直接调用即可创建一个独一无二的 symbol 类型的值。</p>
<p>可以在使用 Symbol 方法创建 symbol 类型值的时候传入一个参数，这个参数需要是一个字符串。如果传入的参数不是字符串，会先自动调用传入参数的 toString 方法转为字符串：</p>
<pre><code class="typescript">const s1 = Symbol(&quot;TypeScript&quot;); 
const s2 = Symbol(&quot;Typescript&quot;); 
console.log(s1 === s2); // false
</code></pre>
<p>上面代码的第三行可能会报一个错误：This condition will always return ‘false’ since the types ‘unique symbol’ and ‘unique symbol’ have no overlap. 这是因为编译器检测到这里的 s1 &#x3D;&#x3D;&#x3D; s2 始终是false，所以编译器提醒这代码写的多余，建议进行优化。</p>
<p>上面使用Symbol创建了两个symbol对象，方法中都传入了相同的字符串，但是两个symbol值仍然是false，这就说明了 Symbol 方法会返回一个独一无二的值。Symbol 方法传入的这个字符串，就是方便我们区分 symbol 值的。可以调用 symbol 值的 toString 方法将它转为字符串：</p>
<pre><code class="typescript">const s1 = Symbol(&quot;Typescript&quot;); 
console.log(s1.toString());  // &#39;Symbol(Typescript)&#39;
console.log(Boolean(s));     // true 
console.log(!s);             // false
</code></pre>
<p>在TypeScript中使用symbol就是指定一个值的类型为symbol类型：</p>
<pre><code class="typescript">let a: symbol = Symbol()
</code></pre>
<p>TypeScript 中还有一个 unique symbol 类型，它是symbol的子类型，这种类型的值只能由<code>Symbol()</code>或<code>Symbol.for()</code>创建，或者通过指定类型来指定变量是这种类型。这种类型的值只能用于常量的定义和用于属性名。需要注意，定义unique symbol类型的值，必须用 const 而不能用let来声明。下面来看在TypeScript中使用Symbol值作为属性名的例子：</p>
<pre><code class="typescript">const key1: unique symbol = Symbol()
let key2: symbol = Symbol()
const obj = &#123;
    [key1]: &#39;value1&#39;,
    [key2]: &#39;value2&#39;
&#125;
console.log(obj[key1]) // value1
console.log(obj[key2]) // error 类型“symbol”不能作为索引类型使用。
</code></pre>
<h6 id="（2）symbol-作为属性名"><a href="#（2）symbol-作为属性名" class="headerlink" title="（2）symbol 作为属性名"></a>（2）symbol 作为属性名</h6><p>在ES6中，对象的属性是支持表达式的，可以使用于一个变量来作为属性名，这对于代码的简化有很多用处，表达式必须放在大括号内：</p>
<pre><code class="typescript">let prop = &quot;name&quot;; 
const obj = &#123; 
  [prop]: &quot;TypeScript&quot; 
&#125;;
console.log(obj.name); // &#39;TypeScript&#39;
</code></pre>
<p>symbol 也可以作为属性名，因为symbol的值是独一无二的，所以当它作为属性名时，不会与其他任何属性名重复。当需要访问这个属性时，只能使用这个symbol值来访问（必须使用方括号形式来访问）：</p>
<pre><code class="typescript">let name = Symbol(); 
let obj = &#123; 
  [name]: &quot;TypeScript&quot; 
&#125;;
console.log(obj); // &#123; Symbol(): &#39;TypeScript&#39; &#125;
console.log(obj[name]); // &#39;TypeScript&#39; 
console.log(obj.name);  // undefined
</code></pre>
<p>在使用obj.name访问时，实际上是字符串name，这和访问普通字符串类型的属性名是一样的，要想访问属性名为symbol类型的属性时，必须使用方括号。方括号中的name才是我们定义的symbol类型的变量name。</p>
<h6 id="（3）symbol-属性名遍历"><a href="#（3）symbol-属性名遍历" class="headerlink" title="（3）symbol 属性名遍历"></a>（3）symbol 属性名遍历</h6><p>使用 Symbol 类型值作为属性名，这个属性是不会被 for…in遍历到的，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 、 JSON.stringify() 等方法获取到：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
for (const key in obj) &#123; 
  console.log(key); 
&#125;  
// =&gt; &#39;age&#39; 
console.log(Object.keys(obj));  // [&#39;age&#39;] 
console.log(Object.getOwnPropertyNames(obj));  // [&#39;age&#39;] 
console.log(JSON.stringify(obj)); // &#39;&#123; &quot;age&quot;: 18 &#125;
</code></pre>
<p>虽然这些方法都不能访问到Symbol类型的属性名，但是Symbol类型的属性并不是私有属性，可以使用 <code>Object.getOwnPropertySymbols</code> 方法获取对象的所有symbol类型的属性名：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
const SymbolPropNames = Object.getOwnPropertySymbols(obj); 
console.log(SymbolPropNames); // [ Symbol(name) ] 
console.log(obj[SymbolPropNames[0]]); // &#39;TypeScript&#39; 
</code></pre>
<p>除了这个方法，还可以使用ES6提供的 Reflect 对象的静态方法 Reflect.ownKeys ，它可以返回所有类型的属性名，Symbol 类型的也会返回：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
console.log(Reflect.ownKeys(obj)); // [ &#39;age&#39;, Symbol(name) ]
</code></pre>
<h6 id="（4）symbol-静态方法"><a href="#（4）symbol-静态方法" class="headerlink" title="（4）symbol 静态方法"></a>（4）symbol 静态方法</h6><p>Symbol 包含两个静态方法， for 和 keyFor 。</p>
<p>1）Symbol.for()</p>
<p>用Symbol创建的symbol类型的值都是独一无二的。使用 Symbol.for 方法传入字符串，会先检查有没有使用该字符串调用 Symbol.for 方法创建的 symbol 值。如果有，返回该值；如果没有，则使用该字符串新创建一个。使用该方法创建 symbol 值后会在全局范围进行注册。</p>
<pre><code class="typescript">const iframe = document.createElement(&quot;iframe&quot;); 
iframe.src = String(window.location); 
document.body.appendChild(iframe); 

iframe.contentWindow.Symbol.for(&quot;TypeScript&quot;) === Symbol.for(&quot;TypeScript&quot;); // true // 注意：如果你在JavaScript环境中这段代码是没有问题的，但是如果在TypeScript开发环境中，可能会报错：类型“Window”上不存在属性“Symbol”。 // 因为这里编译器推断出iframe.contentWindow是Window类型，但是TypeScript的声明文件中，对Window的定义缺少Symbol这个字段，所以会报错，
</code></pre>
<p>上面代码中，创建了一个iframe节点并把它放在body中，通过这个 iframe 对象的 contentWindow 拿到这个 iframe 的 window 对象，在 iframe.contentWindow上添加一个值就相当于在当前页面定义一个全局变量一样。可以看到，在 iframe 中定义的键为 TypeScript 的 symbol 值在和在当前页面定义的键为’TypeScript’的symbol 值相等，说明它们是同一个值。</p>
<p>2）Symbol.keyFor()</p>
<p>该方法传入一个 symbol 值，返回该值在全局注册的键名：</p>
<pre><code class="typescript">const sym = Symbol.for(&quot;TypeScript&quot;); 
console.log(Symbol.keyFor(sym)); // &#39;TypeScript&#39;
</code></pre>
<h5 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h5><p>BigInt是ES6中新引入的数据类型，它是一种内置对象，它提供了一种方法来表示大于 2- 1 的整数，BigInt可以表示任意大的整数。</p>
<p>使用 <code>BigInt</code> 可以安全地存储和操作大整数，即使这个数已经超出了JavaScript构造函数 Number 能够表示的安全整数范围。</p>
<p>我们知道，在 JavaScript 中采用双精度浮点数，这导致精度有限，比如 <code>Number.MAX_SAFE_INTEGER</code> 给出了可以安全递增的最大可能整数，即<code>2- 1</code>，来看一个例子:</p>
<pre><code class="typescript">const max = Number.MAX_SAFE_INTEGER;
const max1 = max + 1
const max2 = max + 2
max1 === max2     // true
</code></pre>
<p>可以看到，最终返回了true，这就是超过精读范围造成的问题，而<code>BigInt</code>正是解决这类问题而生的:</p>
<pre><code class="typescript">const max = BigInt(Number.MAX_SAFE_INTEGER);
const max1 = max + 1n
const max2 = max + 2n
max1 === max2    // false
</code></pre>
<p>这里需要用 <code>BigInt(number)</code> 把 Number 转化为 <code>BigInt</code>，同时如果类型是 <code>BigInt</code> ，那么数字后面需要加 <code>n</code>。</p>
<p>在TypeScript中，<code>number</code> 类型虽然和 <code>BigInt</code> 都表示数字，但是实际上两者类型是完全不同的:</p>
<pre><code class="typescript">declare let foo: number;
declare let bar: bigint;
foo = bar; // error: Type &#39;bigint&#39; is not assignable to type &#39;number&#39;.
bar = foo; // error: Type &#39;number&#39; is not assignable to type &#39;bigint&#39;.
</code></pre>
<h5 id="never"><a href="#never" class="headerlink" title="never"></a>never</h5><p><code>never</code>是其他类型 （包括<code>null</code>和 <code>undefined</code>）的子类型，可以赋值给任何类型，代表从不会出现的值</p>
<p>但是没有类型是 never 的子类型，这意味着声明 <code>never</code> 的变量只能被 <code>never</code> 类型所赋值。</p>
<p><code>never</code> 类型一般用来指定那些总是会抛出异常、无限循环</p>
<pre><code class="tsx">let a:never;
a = 123; // 错误的写法

a = (() =&gt; &#123; // 正确的写法
  throw new Error(&#39;错误&#39;);
&#125;)()

// 返回never的函数必须存在无法达到的终点
function error(message: string): never &#123;
    throw new Error(message);
&#125;
</code></pre>
<h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><p>对象类型，非原始类型，常见的形式通过<code>&#123;&#125;</code>进行包裹</p>
<pre><code class="tsx">let obj:object;
obj = &#123;name: &#39;Wang&#39;, age: 25&#125;;
</code></pre>
<h5 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h5><p>unknown 是TypeScript在3.0版本新增的类型，主要用来描述类型并不确定的变量。它看起来和any很像，但是还是有区别的，unknown相对于any更安全。</p>
<p>对于any，来看一个例子：</p>
<pre><code class="typescript">let value: any
console.log(value.name)
console.log(value.toFixed())
console.log(value.length)
</code></pre>
<p>上面这些语句都不会报错，因为value是any类型，所以后面三个操作都有合法的情况，当value是一个对象时，访问name属性是没问题的；当value是数值类型的时候，调用它的toFixed方法没问题；当value是字符串或数组时获取它的length属性是没问题的。</p>
<p>当指定值为unknown类型的时候，如果没有缩小类型范围的话，是不能对它进行任何操作的。总之，unknown类型的值不能随便操作。那什么是类型范围缩小呢？下面来看一个例子：</p>
<pre><code class="typescript">function getValue(value: unknown): string &#123;
  if (value instanceof Date) &#123; 
    return value.toISOString();
  &#125;
  return String(value);
&#125;
</code></pre>
<p>这里由于把value的类型缩小为Date实例的范围内，所以进行了value.toISOString()，也就是使用ISO标准将 Date 对象转换为字符串。</p>
<p>使用以下方式也可以缩小类型范围：</p>
<pre><code class="typescript">let result: unknown;
if (typeof result === &#39;number&#39;) &#123;
  result.toFixed();
&#125;
</code></pre>
<p>关于 unknown 类型，在使用时需要注意以下几点：</p>
<ul>
<li>任何类型的值都可以赋值给 unknown 类型：</li>
</ul>
<pre><code class="typescript">let value1: unknown;
value1 = &quot;a&quot;;
value1 = 123;
</code></pre>
<ul>
<li>unknown 不可以赋值给其它类型，只能赋值给 unknown 和 any 类型：</li>
</ul>
<pre><code class="typescript">let value2: unknown;
let value3: string = value2; // error 不能将类型“unknown”分配给类型“string”
value1 = value2;
</code></pre>
<ul>
<li>unknown 类型的值不能进行任何操作：</li>
</ul>
<pre><code class="typescript">let value4: unknown;
value4 += 1; // error 对象的类型为 &quot;unknown&quot;
</code></pre>
<ul>
<li>只能对 unknown 进行等或不等操作，不能进行其它操作：</li>
</ul>
<pre><code class="typescript">value1 === value2;
value1 !== value2;
value1 += value2;  // error
</code></pre>
<ul>
<li>unknown 类型的值不能访问其属性、作为函数调用和作为类创建实例：</li>
</ul>
<pre><code class="typescript">let value5: unknown;
value5.age;   // error
value5();     // error
new value5(); // error
</code></pre>
<p>在实际使用中，如果有类型无法确定的情况，要尽量避免使用 any，因为 any 会丢失类型信息，一旦一个类型被指定为 any，那么在它上面进行任何操作都是合法的，所以会有意想不到的情况发生。因此如果遇到无法确定类型的情况，要先考虑使用 unknown。</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>和<code>javascript</code>基本一致，也分成：</p>
<ul>
<li>基本类型</li>
<li>引用类型</li>
</ul>
<p>在基础类型上，<code>typescript</code>增添了<code>void</code>、<code>any</code>、<code>emum</code>等原始类型</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-TypeScript-中枚举类型的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-TypeScript-中枚举类型的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ TypeScript 中枚举类型的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ TypeScript 中枚举类型的理解？应用场景？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型</p>
<p>通俗来说，枚举就是一个对象的所有可能取值的集合</p>
<p>在日常生活中也很常见，例如表示星期的SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY就可以看成是一个枚举</p>
<p>枚举的说明与结构和联合相似，其形式为：</p>
<pre><code class="ini">enum 枚举名&#123;
    标识符①[=整型常数],
    标识符②[=整型常数],
    ...
    标识符N[=整型常数],
&#125;枚举变量;
</code></pre>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>枚举的使用是通过<code>enum</code>关键字进行定义，形式如下：</p>
<pre><code class="tsx">enum xxx &#123; ... &#125;
</code></pre>
<p>声明关键字为枚举类型的方式如下：</p>
<pre><code class="tsx">// 声明d为枚举类型Direction
let d: Direction;
</code></pre>
<p>类型可以分成：</p>
<ul>
<li>数字枚举</li>
<li>字符串枚举</li>
<li>异构枚举</li>
</ul>
<h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><p>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加:</p>
<pre><code class="tsx">enum Direction &#123;
    Up,   // 值默认为 0
    Down, // 值默认为 1
    Left, // 值默认为 2
    Right // 值默认为 3
&#125;

console.log(Direction.Up === 0); // true
console.log(Direction.Down === 1); // true
console.log(Direction.Left === 2); // true
console.log(Direction.Right === 3); // true
</code></pre>
<p>如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加1：</p>
<pre><code class="tsx">enum Direction &#123;
    Up = 10,
    Down,
    Left,
    Right
&#125;

console.log(Direction.Up, Direction.Down, Direction.Left, Direction.Right); // 10 11 12 13
</code></pre>
<h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><pre><code class="tsx">枚举类型的值其实也可以是字符串类型：

enum Direction &#123;
    Up = &#39;Up&#39;,
    Down = &#39;Down&#39;,
    Left = &#39;Left&#39;,
    Right = &#39;Right&#39;
&#125;

console.log(Direction[&#39;Right&#39;], Direction.Up); // Right Up
</code></pre>
<p>如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：</p>
<pre><code class="tsx">enum Direction &#123;
 Up = &#39;UP&#39;,
 Down, // error TS1061: Enum member must have initializer
 Left, // error TS1061: Enum member must have initializer
 Right // error TS1061: Enum member must have initializer
&#125;
</code></pre>
<h4 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h4><p>即将数字枚举和字符串枚举结合起来混合起来使用，如下：</p>
<pre><code class="tsx">enum BooleanLikeHeterogeneousEnum &#123;
    No = 0,
    Yes = &quot;YES&quot;,
&#125;
</code></pre>
<p>通常情况下我们很少会使用异构枚举</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>现在一个枚举的案例如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up,
    Down,
    Left,
    Right
&#125;
</code></pre>
<p>通过编译后，<code>javascript</code>如下：</p>
<pre><code class="tsx">var Direction;
(function (Direction) &#123;
    Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;;
    Direction[Direction[&quot;Down&quot;] = 1] = &quot;Down&quot;;
    Direction[Direction[&quot;Left&quot;] = 2] = &quot;Left&quot;;
    Direction[Direction[&quot;Right&quot;] = 3] = &quot;Right&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
</code></pre>
<p>上述代码可以看到， <code>Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;</code>可以分成</p>
<ul>
<li>Direction[“Up”] &#x3D; 0</li>
<li>Direction[0] &#x3D; “Up”</li>
</ul>
<p>所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up,
    Down,
    Left,
    Right
&#125;

console.log(Direction.Up === 0); // true
console.log(Direction[0]); // Up
</code></pre>
<p>并且多处定义的枚举是可以进行合并操作，如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up = &#39;Up&#39;,
    Down = &#39;Down&#39;,
    Left = &#39;Left&#39;,
    Right = &#39;Right&#39;
&#125;

enum Direction &#123;
    Center = 1
&#125;
</code></pre>
<p>编译后，<code>js</code>代码如下：</p>
<pre><code class="tsx">var Direction;
(function (Direction) &#123;
    Direction[&quot;Up&quot;] = &quot;Up&quot;;
    Direction[&quot;Down&quot;] = &quot;Down&quot;;
    Direction[&quot;Left&quot;] = &quot;Left&quot;;
    Direction[&quot;Right&quot;] = &quot;Right&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
(function (Direction) &#123;
    Direction[Direction[&quot;Center&quot;] = 1] = &quot;Center&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
</code></pre>
<p>可以看到，<code>Direction</code>对象属性回叠加</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：</p>
<pre><code class="tsx">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;

console.log(Days[&quot;Sun&quot;] === 0); // true
console.log(Days[&quot;Mon&quot;] === 1); // true
console.log(Days[&quot;Tue&quot;] === 2); // true
console.log(Days[&quot;Sat&quot;] === 6); // true
</code></pre>
<p>包括后端日常返回0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中接口的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中接口的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中接口的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中接口的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法</p>
<p>简单来讲，一个接口所描述的是一个对象相关的属性和方法，但并不提供具体创建此对象实例的方法</p>
<p><code>typescript</code>的核心功能之一就是对类型做检测，虽然这种检测方式是“鸭式辨型法”，而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定</p>
<h4 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>接口定义如下：</p>
<pre><code class="tsx">interface interface_name &#123;
&#125;
</code></pre>
<p>例如有一个函数，这个函数接受一个 <code>User</code> 对象，然后返回这个 <code>User</code> 对象的 <code>name</code> 属性:</p>
<pre><code class="tsx">const getUserName = (user) =&gt; user.name
</code></pre>
<p>可以看到，参数需要有一个<code>user</code>的<code>name</code>属性，可以通过接口描述<code>user</code>参数的结构</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
&#125;

const getUserName = (user: User) =&gt; user.name
</code></pre>
<p>这些属性并不一定全部实现，上述传入的对象必须拥有<code>name</code>和<code>age</code>属性，否则<code>typescript</code>在编译阶段会报错，如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32356433613739302d306232622d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>如果不想要<code>age</code>属性的话，这时候可以采用可选属性，如下表示：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
&#125;
</code></pre>
<p>这时候<code>age</code>属性则可以是<code>number</code>类型或者<code>undefined</code>类型</p>
<p>有些时候，我们想要一个属性变成只读属性，在<code>typescript</code>只需要使用<code>readonly</code>声明，如下：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
    readonly isMale: boolean
&#125;
</code></pre>
<p>当我们修改属性的时候，就会出现警告，如下所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32663664336333302d306232622d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>这是属性中有一个函数，可以如下表示：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
    readonly isMale: boolean
    say: (words: string) =&gt; string
&#125;
</code></pre>
<p>如果传递的对象不仅仅是上述的属性，这时候可以使用：</p>
<ul>
<li>类型推断</li>
</ul>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
&#125;

const getUserName = (user: User) =&gt; user.name
getUserName(&#123;color: &#39;yellow&#39;&#125; as User)
</code></pre>
<ul>
<li>给接口添加字符串索引签名</li>
</ul>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
    [propName: string]: any;
&#125;
</code></pre>
<p>接口还能实现继承，如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33386134313736302d306232622d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>也可以继承多个，父类通过逗号隔开，如下：</p>
<pre><code class="tsx">interface Father &#123;
    color: String
&#125;

interface Mother &#123;
    height: Number
&#125;

interface Son extends Father,Mother&#123;
    name: string
    age: Number
&#125;
</code></pre>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>例如在<code>javascript</code>中定义一个函数，用来获取用户的姓名和年龄：</p>
<pre><code class="tsx">const getUserInfo = function(user) &#123;
    // ...
    return name: $&#123;user.name&#125;, age: $&#123;user.age&#125;
&#125;
</code></pre>
<p>如果多人开发的都需要用到这个函数的时候，如果没有注释，则可能出现各种运行时的错误，这时候就可以使用接口定义参数变量：</p>
<pre><code class="tsx">// 先定义一个接口
interface IUser &#123;
  name: string;
  age: number;
&#125;

const getUserInfo = (user: IUser): string =&gt; &#123;
  return `name: $&#123;user.name&#125;, age: $&#123;user.age&#125;`;
&#125;;

// 正确的调用
getUserInfo(&#123;name: &quot;koala&quot;, age: 18&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中类的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中类的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中类的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中类的理解？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>
<blockquote>
<p>类是一种用户定义的引用数据类型，也称类类型</p>
</blockquote>
<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本</p>
<p>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多</p>
<p>但是<code> JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类</p>
<p><code>TypeScript</code> 的 <code>class</code> 支持面向对象的所有特性，比如 类、接口等</p>
<h4 id="二、使用方式-1"><a href="#二、使用方式-1" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p>
<ul>
<li>字段： 字段是类里面声明的变量。字段表示对象的有关数据。</li>
<li>构造函数： 类实例化时调用，可以为类的对象分配内存。</li>
<li>方法： 方法为对象要执行的操作</li>
</ul>
<p>如下例子：</p>
<pre><code class="tsx">class Car &#123;
    // 字段
    engine:string;

    // 构造函数
    constructor(engine:string) &#123;
        this.engine = engine
    &#125;

    // 方法
    disp():void &#123;
        console.log(&quot;发动机为 :   &quot;+this.engine)
    &#125;
&#125;
</code></pre>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>类的继承使用过<code>extends</code>的关键字</p>
<pre><code class="tsx">class Animal &#123;
    move(distanceInMeters: number = 0) &#123;
        console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);
    &#125;
&#125;

class Dog extends Animal &#123;
    bark() &#123;
        console.log(&#39;Woof! Woof!&#39;);
    &#125;
&#125;

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
</code></pre>
<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 超类</p>
<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法</p>
<p>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写，通过<code>super</code>关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>
<pre><code class="tsx">class PrinterClass &#123;
   doPrint():void &#123;
      console.log(&quot;父类的 doPrint() 方法。&quot;)
   &#125;
&#125;

class StringPrinter extends PrinterClass &#123;
   doPrint():void &#123;
      super.doPrint() // 调用父类的函数
      console.log(&quot;子类的 doPrint()方法。&quot;)
   &#125;
&#125;
</code></pre>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>可以看到，上述的形式跟<code>ES6</code>十分的相似，<code>typescript</code>在此基础上添加了三种修饰符：</p>
<ul>
<li>公共 public：可以自由的访问类程序里定义的成员</li>
<li>私有 private：只能够在该类的内部进行访问</li>
<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>
</ul>
<h6 id="私有修饰符"><a href="#私有修饰符" class="headerlink" title="私有修饰符"></a>私有修饰符</h6><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66353733363566302d306362342d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>并且继承该类的子类并不能访问，如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30303732636332302d306362352d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h6 id="受保护修饰符"><a href="#受保护修饰符" class="headerlink" title="受保护修饰符"></a>受保护修饰符</h6><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30396537323538302d306362352d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31333766383161302d306362352d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>除了上述修饰符之外，还有只读修饰符</p>
<h6 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h6><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>
<p><a href="https://camo.githubusercontent.com/f0885f89e9d2d9bc7aa7acd9b815cd6f447ab2ed9d3a5c4df4ccd6974599bf53/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31653834386432302d306362352d313165632d386536342d3931666465633066303561312e706e67"><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31653834386432302d306362352d313165632d386536342d3931666465633066303561312e706e67.png" alt="img"></a></p>
<p>除了实例属性之外，同样存在静态属性</p>
<h6 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h6><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示：</p>
<pre><code class="tsx">class Square &#123;
    static width = &#39;100px&#39;
&#125;

console.log(Square.width) // 100px
</code></pre>
<p>上述的类都能发现一个特点就是，都能够被实例化，在 <code>typescript</code>中，还存在一种抽象类</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节</p>
<p><code>abstract </code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>
<pre><code class="tsx">abstract class Animal &#123;
    abstract makeSound(): void;
    move(): void &#123;
        console.log(&#39;roaming the earch...&#39;);
    &#125;
&#125;
</code></pre>
<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>
<pre><code class="tsx">class Cat extends Animal &#123;

    makeSound() &#123;
        console.log(&#39;miao miao&#39;)
    &#125;
&#125;

const cat = new Cat()

cat.makeSound() // miao miao
cat.move() // roaming the earch...
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在 <code>React</code> 工程中是很常用的，如下：</p>
<pre><code class="tsx">export default class Carousel extends React.Component&lt;Props, State&gt; &#123;&#125;
</code></pre>
<p>由于组件需要传入 <code>props</code> 的类型 <code>Props</code> ，同时有需要设置默认 <code>props</code> 即 <code>defaultProps</code>，这时候更加适合使用<code>class</code>作为接口</p>
<p>先声明一个类，这个类包含组件 <code>props</code> 所需的类型和初始值：</p>
<pre><code class="tsx">// props的类型
export default class Props &#123;
  public children: Array&lt;React.ReactElement&lt;any&gt;&gt; | React.ReactElement&lt;any&gt; | never[] = []
  public speed: number = 500
  public height: number = 160
  public animation: string = &#39;easeInOutQuad&#39;
  public isAuto: boolean = true
  public autoPlayInterval: number = 4500
  public afterChange: () =&gt; &#123;&#125;
  public beforeChange: () =&gt; &#123;&#125;
  public selesctedColor: string
  public showDots: boolean = true
&#125;
</code></pre>
<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>
<pre><code class="tsx">public static defaultProps = new Props()
</code></pre>
<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class </code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中函数的理解？与-JavaScript-函数的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中函数的理解？与-JavaScript-函数的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中函数的理解？与 JavaScript 函数的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>函数是<code> JavaScript</code> 应用程序的基础，帮助我们实现抽象层、模拟类、信息隐藏和模块</p>
<p>在<code> TypeScript</code> 里，虽然已经支持类、命名空间和模块，但函数仍然是主要定义行为的方式，<code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，丰富了更多的应用场景</p>
<p>函数类型在 <code>TypeScript</code> 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块</p>
<h4 id="二、使用方式-2"><a href="#二、使用方式-2" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>跟<code>javascript</code> 定义函数十分相似，可以通过<code>funciton</code> 关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>
<pre><code class="tsx">const add = (a: number, b: number) =&gt; a + b
</code></pre>
<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上<code> TypeScript</code> 编译器是能够通过类型推断到这个函数的类型，如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34623334313562302d306434322d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>当鼠标放置在第三行<code>add</code>函数名的时候，会出现完整的函数定义类型，通过<code>:</code> 的形式来定于参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>
<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>
<pre><code class="tsx">// 方式一
type LongHand = &#123;
  (a: number): number;
&#125;;

// 方式二
type ShortHand = (a: number) =&gt; number;
</code></pre>
<p>当存在函数重载时，只能使用方式一的形式</p>
<h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>
<pre><code class="tsx">const add = (a: number, b?: number) =&gt; a + (b ? b : 0)
</code></pre>
<p>这时候参数<code>b</code>可以是<code>number</code>类型或者<code>undefined</code>类型，即可以传一个<code>number</code>类型或者不传都可以</p>
<h5 id="剩余类型"><a href="#剩余类型" class="headerlink" title="剩余类型"></a>剩余类型</h5><p>剩余参数与<code>JavaScript</code>的语法类似，需要用 <code>...</code> 来表示剩余参数</p>
<p>如果剩余参数 <code>rest</code> 是一个由<code>number</code>类型组成的数组，则如下表示：</p>
<pre><code class="tsx">const add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a)
</code></pre>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>
<p>关于<code>typescript</code>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|</code>操作符或者<code>?</code>操作符，把所有可能的输入类型全部包含进去，用于具体实现</p>
<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，<code>typescript</code>并不会真的将你的多个重名 <code>function </code>的函数体进行合并</p>
<p>例如我们有一个add函数，它可以接收 <code>string</code>类型的参数进行拼接，也可以接收 <code>number</code> 类型的参数进行相加，如下：</p>
<pre><code class="tsx">// 上边是声明
function add (arg1: string, arg2: string): string
function add (arg1: number, arg2: number): number
// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字

// 下边是实现
function add (arg1: string | number, arg2: string | number) &#123;
  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2
  if (typeof arg1 === &#39;string&#39; &amp;&amp; typeof arg2 === &#39;string&#39;) &#123;
    return arg1 + arg2
  &#125; else if (typeof arg1 === &#39;number&#39; &amp;&amp; typeof arg2 === &#39;number&#39;) &#123;
    return arg1 + arg2
  &#125;
&#125;
</code></pre>
<h4 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h4><p>从上面可以看到：</p>
<ul>
<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>
<li>typescript 在参数中，添加可选参数供使用者选择</li>
<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中泛型的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中泛型的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中泛型的理解？应用场景？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p>
<p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型<br>在<code>typescript</code>中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性</p>
<p>假设我们用一个函数，它可接受一个 <code>number</code> 参数并返回一个<code> number</code> 参数，如下写法：</p>
<pre><code class="tsx">function returnItem (para: number): number &#123;
    return para
&#125;
</code></pre>
<p>如果我们打算接受一个 <code>string</code> 类型，然后再返回 <code>string</code>类型，则如下写法：</p>
<pre><code class="tsx">function returnItem (para: string): string &#123;
    return para
&#125;
</code></pre>
<p>上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高</p>
<p>虽然可以使用 <code>any</code>类型去替代，但这也并不是很好的方案，因为我们的目的是接收什么类型的参数返回什么类型的参数，即在运行时传入参数我们才能确定类型</p>
<p>这种情况就可以使用泛型，如下所示：</p>
<pre><code class="tsx">function returnItem&lt;T&gt;(para: T): T &#123;
    return para
&#125;
</code></pre>
<p>可以看到，泛型给予开发者创造灵活、可重用代码的能力</p>
<h4 id="二、使用方式-3"><a href="#二、使用方式-3" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明：</p>
<ul>
<li>函数</li>
<li>接口</li>
<li>类</li>
</ul>
<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>声明函数的形式如下：</p>
<pre><code class="tsx">function returnItem&lt;T&gt;(para: T): T &#123;
    return para
&#125;
</code></pre>
<p>定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 <code>T</code> 和 泛型 <code>U</code>：</p>
<pre><code class="tsx">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;
    return [tuple[1], tuple[0]];
&#125;

swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]
</code></pre>
<h5 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h5><p>声明接口的形式如下：</p>
<pre><code class="tsx">interface ReturnItemFn&lt;T&gt; &#123;
    (para: T): T
&#125;
</code></pre>
<p>那么当我们想传入一个number作为参数的时候，就可以这样声明函数:</p>
<pre><code class="tsx">const returnItem: ReturnItemFn&lt;number&gt; = para =&gt; para
</code></pre>
<h5 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h5><p>使用泛型声明类的时候，既可以作用于类本身，也可以作用与类的成员函数</p>
<p>下面简单实现一个元素同类型的栈结构，如下所示：</p>
<pre><code class="tsx">class Stack&lt;T&gt; &#123;
    private arr: T[] = []
    public push(item: T) &#123;
        this.arr.push(item)
    &#125;
    public pop() &#123;
        this.arr.pop()
    &#125;
&#125;
</code></pre>
<p>使用方式如下：</p>
<pre><code class="tsx">const stack = new Stacn&lt;number&gt;()
</code></pre>
<p>如果上述只能传递 <code>string</code> 和 <code>number</code> 类型，这时候就可以使用 <code>&lt;T extends xx&gt;</code> 的方式猜实现约束泛型，如下所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36376432313261302d306531372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>除了上述的形式，泛型更高级的使用如下：</p>
<p>例如要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值</p>
<p>这时候就设计到泛型的索引类型和约束类型共同实现</p>
<h5 id="索引类型、约束类型"><a href="#索引类型、约束类型" class="headerlink" title="索引类型、约束类型"></a>索引类型、约束类型</h5><p>索引类型 <code>keyof T</code> 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，如下所示：</p>
<pre><code class="tsx">function getValue&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) &#123;
  return obj[key] // ok
&#125;
</code></pre>
<p>上述为什么需要使用泛型约束，而不是直接定义第一个参数为 <code>object</code>类型，是因为默认情况 <code>object</code> 指的是<code>&#123;&#125;</code>，而我们接收的对象是各种各样的，一个泛型来表示传入的对象类型，比如 <code>T extends object</code></p>
<p>使用如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37346663626434302d306531372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="多类型约束"><a href="#多类型约束" class="headerlink" title="多类型约束"></a>多类型约束</h5><p>例如如下需要实现两个接口的类型约束：</p>
<pre><code class="tsx">interface FirstInterface &#123;
  doSomething(): number
&#125;

interface SecondInterface &#123;
  doSomethingElse(): string
&#125;
</code></pre>
<p>可以创建一个接口继承上述两个接口，如下：</p>
<pre><code class="tsx">interface ChildInterface extends FirstInterface, SecondInterface &#123;

&#125;
</code></pre>
<p>正确使用如下：</p>
<pre><code class="tsx">class Demo&lt;T extends ChildInterface&gt; &#123;
  private genericProperty: T

  constructor(genericProperty: T) &#123;
    this.genericProperty = genericProperty
  &#125;
  useT() &#123;
    this.genericProperty.doSomething()
    this.genericProperty.doSomethingElse()
  &#125;
&#125;
</code></pre>
<p>通过泛型约束就可以达到多类型约束的目的</p>
<h4 id="三、应用场景-3"><a href="#三、应用场景-3" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>通过上面初步的了解，后述在编写 <code>typescript</code> 的时候，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性的时候，这种情况下就可以使用泛型</p>
<p>灵活的使用泛型定义类型，是掌握<code>typescript</code> 必经之路</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中高级类型的理解？有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中高级类型的理解？有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中高级类型的理解？有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中高级类型的理解？有哪些？</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>除了<code>string</code>、<code>number</code>、<code>boolean</code> 这种基础类型外，在 <code>typescript</code> 类型声明中还存在一些高级的类型应用</p>
<p>这些高级类型，是<code>typescript</code>为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景</p>
<h4 id="二、有哪些-1"><a href="#二、有哪些-1" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的高级类型有如下：</p>
<ul>
<li>交叉类型</li>
<li>联合类型</li>
<li>类型别名</li>
<li>类型索引</li>
<li>类型约束</li>
<li>映射类型</li>
<li>条件类型</li>
</ul>
<h5 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h5><p>通过 <code>&amp;</code> 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作</p>
<p>语法如下：</p>
<pre><code class="ini">T &amp; U
</code></pre>
<p>适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：</p>
<pre><code class="tsx">function extend&lt;T , U&gt;(first: T, second: U) : T &amp; U &#123;
    let result: &lt;T &amp; U&gt; = &#123;&#125;
    for (let key in first) &#123;
        result[key] = first[key]
    &#125;
    for (let key in second) &#123;
        if(!result.hasOwnProperty(key)) &#123;
            result[key] = second[key]
        &#125;
    &#125;
    return result
&#125;
</code></pre>
<h5 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h5><p>联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系</p>
<p>语法如下：</p>
<pre><code class="ini">T | U
</code></pre>
<p>例如 <code>number</code> | <code>string</code> | <code>boolean</code> 的类型只能是这三个的一种，不能共存</p>
<p>如下所示：</p>
<pre><code class="tsx">function formatCommandline(command: string[] | string) &#123;
  let line = &#39;&#39;;
  if (typeof command === &#39;string&#39;) &#123;
    line = command.trim();
  &#125; else &#123;
    line = command.join(&#39; &#39;).trim();
  &#125;
&#125;
</code></pre>
<h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型</p>
<p>可以使用 <code>type SomeName = someValidTypeAnnotation</code>的语法来创建类型别名：</p>
<pre><code class="tsx">type some = boolean | string

const b: some = true // ok
const c: some = &#39;hello&#39; // ok
const d: some = 123 // 不能将类型“123”分配给类型“some”
</code></pre>
<p>此外类型别名可以是泛型:</p>
<pre><code class="tsx">type Container&lt;T&gt; = &#123; value: T &#125;;
</code></pre>
<p>也可以使用类型别名来在属性里引用自己：</p>
<pre><code class="tsx">type Tree&lt;T&gt; = &#123;
    value: T;
    left: Tree&lt;T&gt;;
    right: Tree&lt;T&gt;;
&#125;
</code></pre>
<p>可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数</p>
<p>两者最大的区别在于，<code>interface </code>只能用于定义对象类型，而 <code>type</code> 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛</p>
<h5 id="类型索引"><a href="#类型索引" class="headerlink" title="类型索引"></a>类型索引</h5><p><code>keyof</code> 类似于 <code>Object.keys</code> ，用于获取一个接口中 Key 的联合类型。</p>
<pre><code class="tsx">interface Button &#123;
    type: string
    text: string
&#125;

type ButtonKeys = keyof Button
// 等效于
type ButtonKeys = &quot;type&quot; | &quot;text&quot;
</code></pre>
<h5 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h5><p>通过关键字 <code>extend</code> 进行约束，不同于在 <code>class</code> 后使用 <code>extends</code> 的继承作用，泛型内使用的主要作用是对泛型加以约束</p>
<pre><code class="tsx">type BaseType = string | number | boolean

// 这里表示 copy 的参数
// 只能是字符串、数字、布尔这几种基础类型
function copy&lt;T extends BaseType&gt;(arg: T): T &#123;
  return arg
&#125;
</code></pre>
<p>类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 <code>extends</code> 和 <code>keyof</code> 进行约束。</p>
<pre><code class="tsx">function getValue&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123;
  return obj[key]
&#125;

const obj = &#123; a: 1 &#125;
const a = getValue(obj, &#39;a&#39;)
</code></pre>
<h5 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h5><p>通过 <code>in</code> 关键字做类型的映射，遍历已有接口的 <code>key</code> 或者是遍历联合类型，如下例子：</p>
<pre><code class="tsx">type Readonly&lt;T&gt; = &#123;
    readonly [P in keyof T]: T[P];
&#125;;

interface Obj &#123;
  a: string
  b: string
&#125;

type ReadOnlyObj = Readonly&lt;Obj&gt;
</code></pre>
<p>上述的结构，可以分成这些步骤：</p>
<ul>
<li>keyof T：通过类型索引 keyof 的得到联合类型 ‘a’ | ‘b’</li>
<li>P in keyof T 等同于 p in ‘a’ | ‘b’，相当于执行了一次 forEach 的逻辑，遍历 ‘a’ | ‘b’</li>
</ul>
<p>所以最终<code>ReadOnlyObj</code>的接口为下述：</p>
<pre><code class="tsx">interface ReadOnlyObj &#123;
    readonly a: string;
    readonly b: string;
&#125;
</code></pre>
<h5 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h5><p>条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。</p>
<pre><code class="tsx">T extends U ? X : Y
</code></pre>
<p>上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y</p>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，如果只是掌握了 <code>typeScript</code> 的一些基础类型，可能很难游刃有余的去使用 <code>typeScript</code>，需要了解一些<code>typescript</code>的高阶用法</p>
<p>并且<code>typescript</code>在版本的迭代中新增了很多功能，需要不断学习与掌握</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-装饰器的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-装饰器的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 装饰器的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 装饰器的理解？应用场景？</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上</p>
<p>是一种在不改变原类和使用继承的情况下，动态地扩展对象功能</p>
<p>同样的，本质也不是什么高大上的结构，就是一个普通的函数，<code>@expression</code> 的形式其实是<code>Object.defineProperty</code>的语法糖</p>
<p><code>expression </code>求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p>
<h4 id="二、使用方式-4"><a href="#二、使用方式-4" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>由于<code>typescript</code>是一个实验性特性，若要使用，需要在<code>tsconfig.json</code>文件启动，如下：</p>
<pre><code class="tsx">&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;ES5&quot;,
        &quot;experimentalDecorators&quot;: true
    &#125;
&#125;
</code></pre>
<p><code>typescript</code>装饰器的使用和<code>javascript</code>基本一致</p>
<p>类的装饰器可以装饰：</p>
<ul>
<li>类</li>
<li>方法&#x2F;属性</li>
<li>参数</li>
<li>访问器</li>
</ul>
<h5 id="类装饰"><a href="#类装饰" class="headerlink" title="类装饰"></a>类装饰</h5><p>例如声明一个函数 <code>addAge</code> 去给 Class 的属性 <code>age</code> 添加年龄.</p>
<pre><code class="tsx">function addAge(constructor: Function) &#123;
  constructor.prototype.age = 18;
&#125;

@addAge
class Person&#123;
  name: string;
  age!: number;
  constructor() &#123;
    this.name = &#39;huihui&#39;;
  &#125;
&#125;

let person = new Person();

console.log(person.age); // 18
</code></pre>
<p>上述代码，实际等同于以下形式：</p>
<pre><code class="tsx">Person = addAge(function Person() &#123; ... &#125;);
</code></pre>
<p>上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 <code>constructor.prototype.age</code> 就是在每一个实例化对象上面添加一个 <code>age</code> 属性</p>
<h5 id="方法-x2F-属性装饰"><a href="#方法-x2F-属性装饰" class="headerlink" title="方法&#x2F;属性装饰"></a>方法&#x2F;属性装饰</h5><p>同样，装饰器可以用于修饰类的方法，这时候装饰器函数接收的参数变成了：</p>
<ul>
<li>target：对象的原型</li>
<li>propertyKey：方法的名称</li>
<li>descriptor：方法的属性描述符</li>
</ul>
<p>可以看到，这三个属性实际就是<code>Object.defineProperty</code>的三个参数，如果是类的属性，则没有传递第三个参数</p>
<p>如下例子：</p>
<pre><code class="tsx">// 声明装饰器修饰方法/属性
function method(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;
  console.log(target);
  console.log(&quot;prop &quot; + propertyKey);
  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);
  descriptor.writable = false;
&#125;;

function property(target: any, propertyKey: string) &#123;
  console.log(&quot;target&quot;, target)
  console.log(&quot;propertyKey&quot;, propertyKey)
&#125;

class Person&#123;
 @property
 name: string;
 constructor() &#123;
   this.name = &#39;huihui&#39;;
 &#125;

 @method
 say()&#123;
   return &#39;instance method&#39;;
 &#125;

 @method
 static run()&#123;
   return &#39;static method&#39;;
 &#125;
&#125;

const xmz = new Person();

// 修改实例方法say
xmz.say = function() &#123;
 return &#39;edit&#39;
&#125;
</code></pre>
<p>输出如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65393662633162302d313134642d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h5 id="参数装饰"><a href="#参数装饰" class="headerlink" title="参数装饰"></a>参数装饰</h5><p>接收3个参数，分别是：</p>
<ul>
<li>target ：当前对象的原型</li>
<li>propertyKey ：参数的名称</li>
<li>index：参数数组中的位置</li>
</ul>
<pre><code class="tsx">function logParameter(target: Object, propertyName: string, index: number) &#123;
  console.log(target);
  console.log(propertyName);
  console.log(index);
&#125;

class Employee &#123;
  greet(@logParameter message: string): string &#123;
      return `hello $&#123;message&#125;`;
  &#125;
&#125;
const emp = new Employee();
emp.greet(&#39;hello&#39;);
</code></pre>
<p>输入如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326633326465302d313134642d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="访问器装饰"><a href="#访问器装饰" class="headerlink" title="访问器装饰"></a>访问器装饰</h5><p>使用起来方式与方法装饰一致，如下：</p>
<pre><code class="tsx">function modification(target: Object, propertyKey: string, descriptor: PropertyDescriptor) &#123;
  console.log(target);
  console.log(&quot;prop &quot; + propertyKey);
  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);
&#125;;

class Person&#123;
 _name: string;
 constructor() &#123;
   this._name = &#39;huihui&#39;;
 &#125;

 @modification
 get name() &#123;
   return this._name
 &#125;
&#125;
</code></pre>
<h5 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h5><p>如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：</p>
<pre><code class="tsx">function addAge(age: number) &#123;
  return function(constructor: Function) &#123;
    constructor.prototype.age = age
  &#125;
&#125;

@addAge(10)
class Person&#123;
  name: string;
  age!: number;
  constructor() &#123;
    this.name = &#39;huihui&#39;;
  &#125;
&#125;

let person = new Person();
</code></pre>
<h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><p>当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用，例如如下：</p>
<pre><code class="tsx">function f() &#123;
    console.log(&quot;f(): evaluated&quot;);
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123;
        console.log(&quot;f(): called&quot;);
    &#125;
&#125;

function g() &#123;
    console.log(&quot;g(): evaluated&quot;);
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123;
        console.log(&quot;g(): called&quot;);
    &#125;
&#125;

class C &#123;
    @f()
    @g()
    method() &#123;&#125;
&#125;

// 输出
f(): evaluated
g(): evaluated
g(): called
f(): called
</code></pre>
<h4 id="三、应用场景-4"><a href="#三、应用场景-4" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>可以看到，使用装饰器存在两个显著的优点：</p>
<ul>
<li>代码可读性变强了，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原来功能进行扩展</li>
</ul>
<p>后面的使用场景中，借助装饰器的特性，除了提高可读性之后，针对已经存在的类，可以通过装饰器的特性，在不改变原有代码情况下，对原来功能进行扩展</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中命名空间与模块的理解？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中命名空间与模块的理解？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中命名空间与模块的理解？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中命名空间与模块的理解？区别？</h3><h4 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h4><p><code>TypeScript</code> 与<code> ECMAScript</code> 2015 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块</p>
<p>相反地，如果一个文件不带有顶级的<code>import</code>或者<code>export</code>声明，那么它的内容被视为全局可见的</p>
<p>例如我们在在一个 <code>TypeScript</code> 工程下建立一个文件 <code>1.ts</code>，声明一个变量<code>a</code>，如下：</p>
<pre><code class="tsx">const a = 1
</code></pre>
<p>然后在另一个文件同样声明一个变量<code>a</code>，这时候会出现错误信息</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61323339643937302d313337652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>提示重复声明<code>a</code>变量，但是所处的空间是全局的</p>
<p>如果需要解决这个问题，则通过<code>import</code>或者<code>export</code>引入模块系统即可，如下：</p>
<pre><code class="tsx">const a = 10;

export default a
</code></pre>
<p>在<code>typescript</code>中，<code>export</code>关键字可以导出变量或者类型，用法与<code>es6</code>模块一致，如下：</p>
<pre><code class="tsx">export const a = 1
export type Person = &#123;
    name: String
&#125;
</code></pre>
<p>通过<code>import</code> 引入模块，如下：</p>
<pre><code class="tsx">import &#123; a, Person &#125; from &#39;./export&#39;;
</code></pre>
<h4 id="二、命名空间"><a href="#二、命名空间" class="headerlink" title="二、命名空间"></a>二、命名空间</h4><p>命名空间一个最明确的目的就是解决重名问题</p>
<p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的</p>
<p>这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p>
<p><code>TypeScript</code> 中命名空间使用 <code>namespace</code> 来定义，语法格式如下：</p>
<pre><code class="tsx">namespace SomeNameSpaceName &#123;
   export interface ISomeInterfaceName &#123;      &#125;
   export class SomeClassName &#123;      &#125;
&#125;
</code></pre>
<p>以上定义了一个命名空间 <code>SomeNameSpaceName</code>，如果我们需要在外部可以调用 <code>SomeNameSpaceName</code> 中的类和接口，则需要在类和接口添加 <code>export</code> 关键字</p>
<p>使用方式如下：</p>
<pre><code class="ini">SomeNameSpaceName.SomeClassName
</code></pre>
<p>命名空间本质上是一个对象，作用是将一系列相关的全局变量组织到一个对象的属性，如下：</p>
<pre><code class="tsx">namespace Letter &#123;
  export let a = 1;
  export let b = 2;
  export let c = 3;
  // ...
  export let z = 26;
&#125;
</code></pre>
<p>编译成<code>js</code>如下：</p>
<pre><code class="tsx">var Letter;
(function (Letter) &#123;
    Letter.a = 1;
    Letter.b = 2;
    Letter.c = 3;
    // ...
    Letter.z = 26;
&#125;)(Letter || (Letter = &#123;&#125;));
</code></pre>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><ul>
<li>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中</li>
<li>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖</li>
<li>在正常的TS项目开发过程中并不建议用命名空间，但通常在通过 d.ts 文件标记 js 库类型的时候使用命名空间，主要作用是给编译器编写代码的时候参考使用</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在Vue项目中应用TypeScript？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在Vue项目中应用TypeScript？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Vue项目中应用TypeScript？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Vue项目中应用TypeScript？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>与link类似</p>
<p>在<code>VUE</code>项目中应用<code>typescript</code>，我们需要引入一个库<code>vue-property-decorator</code>，</p>
<p>其是基于<code>vue-class-component</code>库而来，这个库<code>vue</code>官方推出的一个支持使用<code>class</code>方式来开发<code>vue</code>单文件组件的库</p>
<p>主要的功能如下：</p>
<ul>
<li>methods 可以直接声明为类的成员方法</li>
<li>计算属性可以被声明为类的属性访问器</li>
<li>初始化的 data 可以被声明为类属性</li>
<li>data、render 以及所有的 Vue 生命周期钩子可以直接作为类的成员方法</li>
<li>所有其他属性，需要放在装饰器中</li>
</ul>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p>vue-property-decorator 主要提供了多个装饰器和一个函数:</p>
<ul>
<li>@prop</li>
<li>@ProPsync</li>
<li>@model</li>
<li>@watch</li>
<li>@provide</li>
<li>@Inject</li>
<li>@ProvideReactive</li>
<li>@InjectReactive</li>
<li>@emit</li>
<li>@ref</li>
<li>@component (由 vue-class-component 提供)</li>
<li>Mixins (由 vue-class-component 提供)</li>
</ul>
<h5 id="component"><a href="#component" class="headerlink" title="@component"></a><a href="https://github.com/component">@component</a></h5><p><code>Component</code>装饰器它注明了此类为一个<code>Vue</code>组件，因此即使没有设置选项也不能省略</p>
<p>如果需要定义比如 <code>name</code>、<code>components</code>、<code>filters</code>、<code>directives</code>以及自定义属性，就可以在<code>Component</code>装饰器中定义，如下：</p>
<pre><code class="tsx">import &#123;Component,Vue&#125; from &#39;vue-property-decorator&#39;;
import &#123;componentA,componentB&#125; from &#39;@/components&#39;;

 @Component(&#123;
    components:&#123;
        componentA,
        componentB,
    &#125;,
    directives: &#123;
        focus: &#123;
            // 指令的定义
            inserted: function (el) &#123;
                el.focus()
            &#125;
        &#125;
    &#125;
&#125;)
export default class YourCompoent extends Vue&#123;
   
&#125;
</code></pre>
<h5 id="computed、data、methods"><a href="#computed、data、methods" class="headerlink" title="computed、data、methods"></a>computed、data、methods</h5><p>这里取消了组件的data和methods属性，以往data返回对象中的属性、methods中的方法需要直接定义在Class中，当做类的属性和方法</p>
<pre><code class="tsx">@Component
export default class HelloDecorator extends Vue &#123;
    count: number = 123 // 类属性相当于以前的 data

    add(): number &#123; // 类方法就是以前的方法
        this.count + 1
    &#125;

    // 获取计算属性
    get total(): number &#123;
      return this.count + 1
    &#125;

    // 设置计算属性
    set total(param:number): void &#123;
      this.count = param
    &#125;
&#125;
</code></pre>
<h5 id="props"><a href="#props" class="headerlink" title="@props"></a><a href="https://github.com/props">@props</a></h5><p>组件接收属性的装饰器，如下使用：</p>
<pre><code class="tsx">import &#123;Component,Vue,Prop&#125; from vue-property-decorator;

@Component
export default class YourComponent extends Vue &#123;
    @Prop(String)
    propA:string;
    
    @Prop([String,Number])
    propB:string|number;
    
    @Prop(&#123;
     type: String, // type: [String , Number]
     default: &#39;default value&#39;, // 一般为String或Number
      //如果是对象或数组的话。默认值从一个工厂函数中返回
      // defatult: () =&gt; &#123;
      //     return [&#39;a&#39;,&#39;b&#39;]
      // &#125;
     required: true,
     validator: (value) =&gt; &#123;
        return [
          &#39;InProcess&#39;,
          &#39;Settled&#39;
        ].indexOf(value) !== -1
     &#125;
    &#125;)
    propC:string;
&#125;
</code></pre>
<h5 id="watch"><a href="#watch" class="headerlink" title="@watch"></a><a href="https://github.com/watch">@watch</a></h5><p>实际就是<code>Vue</code>中的监听器，如下：</p>
<pre><code class="tsx">import &#123; Vue, Component, Watch &#125; from &#39;vue-property-decorator&#39;

@Component
export default class YourComponent extends Vue &#123;
  @Watch(&#39;child&#39;)
  onChildChanged(val: string, oldVal: string) &#123;&#125;

  @Watch(&#39;person&#39;, &#123; immediate: true, deep: true &#125;)
  onPersonChanged1(val: Person, oldVal: Person) &#123;&#125;

  @Watch(&#39;person&#39;)
  onPersonChanged2(val: Person, oldVal: Person) &#123;&#125;
&#125;
</code></pre>
<h5 id="emit"><a href="#emit" class="headerlink" title="@emit"></a><a href="https://github.com/emit">@emit</a></h5><p><code>vue-property-decorator</code> 提供的 <code>@Emit</code> 装饰器就是代替<code>Vue </code>中的事件的触发<code>$emit</code>，如下：</p>
<pre><code class="tsx">import &#123;Vue, Component, Emit&#125; from &#39;vue-property-decorator&#39;;
    @Component(&#123;&#125;)
    export default class Some extends Vue&#123;
        mounted()&#123;
            this.$on(&#39;emit-todo&#39;, function(n) &#123;
                console.log(n)
            &#125;)
            this.emitTodo(&#39;world&#39;);
        &#125;
        @Emit()
        emitTodo(n: string)&#123;
            console.log(&#39;hello&#39;);
        &#125;
    &#125;
</code></pre>
<h4 id="三-、总结"><a href="#三-、总结" class="headerlink" title="三 、总结"></a>三 、总结</h4><p>可以看到上述<code>typescript</code>版本的<code>vue class</code>的语法与平时<code>javascript</code>版本使用起来还是有很大的不同，多处用到<code>class</code>与装饰器，但实际上本质是一致的，只有不断编写才会得心应手</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在React项目中应用TypeScript？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在React项目中应用TypeScript？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在React项目中应用TypeScript？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在React项目中应用TypeScript？</h3><h4 id="一、前言-1"><a href="#一、前言-1" class="headerlink" title="一、前言"></a>一、前言</h4><p>单独的使用 <code>TypeScript</code> 并不会导致学习成本很高，但是绝大部分前端开发者的项目都是依赖于框架的</p>
<p>例如与 <code>Vue</code>、<code>React</code> 这些框架结合使用的时候，会有一定的门槛</p>
<p>使用 <code>TypeScript</code> 编写 <code>React</code> 代码，除了需要 <code>TypeScript</code> 这个库之外，还需要安装 <code>@types/react</code>、<code>@types/react-dom</code></p>
<pre><code class="bash">npm i @types/react -s

npm i @types/react-dom -s
</code></pre>
<p>至于上述使用 <code>@types</code> 的库的原因在于，目前非常多的 <code>JavaScript</code> 库并没有提供自己关于 <code>TypeScript</code> 的声明文件</p>
<p>所以，<code>ts</code> 并不知道这些库的类型以及对应导出的内容，这里 <code>@types</code> 实际就是社区中的 <code>DefinitelyTyped</code> 库，定义了目前市面上绝大多数的 <code>JavaScript</code> 库的声明</p>
<p>所以下载相关的 <code>JavaScript</code> 对应的 <code>@types</code> 声明时，就能够使用使用该库对应的类型定义</p>
<h4 id="二、使用方式-5"><a href="#二、使用方式-5" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>在编写 <code>React</code> 项目的时候，最常见的使用的组件就是：</p>
<ul>
<li>无状态组件</li>
<li>有状态组件</li>
<li>受控组件</li>
</ul>
<h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><p>主要作用是用于展示 <code>UI</code>，如果使用 <code>js</code> 声明，则如下所示：</p>
<pre><code class="jsx">import * as React from &quot;React&quot;;

export const Logo = (props) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<p>但这时候 <code>ts</code> 会出现报错提示，原因在于没有定义 <code>porps</code> 类型，这时候就可以使用 <code>interface</code> 接口去定义 <code>porps</code> 即可，如下：</p>
<pre><code class="tsx">import * as React from &quot;React&quot;;

interface IProps &#123;
  logo?: string;
  className?: string;
  alt?: string;
&#125;

export const Logo = (props: IProps) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<p>但是我们都知道 <code>props</code> 里面存在 <code>children</code> 属性，我们不可能每个 <code>porps</code> 接口里面定义多一个 <code>children</code>，如下：</p>
<pre><code class="tsx">interface IProps &#123;
  logo?: string;
  className?: string;
  alt?: string;
  children?: ReactNode;
&#125;
</code></pre>
<p>更加规范的写法是使用 <code>React</code> 里面定义好的 <code>FC</code> 属性，里面已经定义好 <code>children</code> 类型，如下：</p>
<pre><code class="tsx">export const Logo: React.FC&lt;IProps&gt; = (props) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<ul>
<li>React.FC 显式地定义了返回类型，其他方式是隐式推导的</li>
<li>React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全</li>
<li>React.FC 为 children 提供了隐式的类型（ReactElement | null）</li>
</ul>
<h5 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h5><p>可以是一个类组件且存在 <code>props</code> 和 <code>state</code> 属性</p>
<p>如果使用 <code>TypeScript</code> 声明则如下所示：</p>
<pre><code class="tsx">import * as React from &quot;React&quot;;

interface IProps &#123;
  color: string;
  size?: string;
&#125;
interface IState &#123;
  count: number;
&#125;
class App extends React.Component&lt;IProps, IState&gt; &#123;
  public state = &#123;
    count: 1,
  &#125;;
  public render() &#123;
    return &lt;div&gt;Hello world&lt;/div&gt;;
  &#125;
&#125;
</code></pre>
<p>上述通过泛型对 <code>props</code>、<code>state</code> 进行类型定义，然后在使用的时候就可以在编译器中获取更好的智能提示</p>
<p>关于 <code>Component</code> 泛型类的定义，可以参考下 React 的类型定义文件 <code>node_modules/@types/React/index.d.ts</code>，如下所示：</p>
<pre><code class="ts">class Component&lt;P, S&gt; &#123;
  readonly props: Readonly&lt;&#123; children?: ReactNode &#125;&gt; &amp; Readonly&lt;P&gt;;

  state: Readonly&lt;S&gt;;
&#125;
</code></pre>
<p>从上述可以看到，<code>state</code> 属性也定义了可读类型，目的是为了防止直接调用 <code>this.state</code> 更新状态</p>
<h5 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h5><p>受控组件的特性在于元素的内容通过组件的状态 <code>state</code> 进行控制</p>
<p>由于组件内部的事件是合成事件，不等同于原生事件，</p>
<p>例如一个 <code>input</code> 组件修改内部的状态，常见的定义的时候如下所示：</p>
<pre><code class="ts">private updateValue(e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#123;
    this.setState(&#123; itemText: e.target.value &#125;)
&#125;
</code></pre>
<p>常用 <code>Event</code> 事件对象类型：</p>
<ul>
<li>ClipboardEvent&lt;T &#x3D; Element&gt; 剪贴板事件对象</li>
<li>DragEvent&lt;T &#x3D; Element&gt; 拖拽事件对象</li>
<li>ChangeEvent&lt;T &#x3D; Element&gt; Change 事件对象</li>
<li>KeyboardEvent&lt;T &#x3D; Element&gt; 键盘事件对象</li>
<li>MouseEvent&lt;T &#x3D; Element&gt; 鼠标事件对象</li>
<li>TouchEvent&lt;T &#x3D; Element&gt; 触摸事件对象</li>
<li>WheelEvent&lt;T &#x3D; Element&gt; 滚轮事件对象</li>
<li>AnimationEvent&lt;T &#x3D; Element&gt; 动画事件对象</li>
<li>TransitionEvent&lt;T &#x3D; Element&gt; 过渡事件对象</li>
</ul>
<p><code>T</code> 接收一个 <code>DOM</code> 元素类型</p>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>上述只是简单的在 <code>React</code> 项目使用 <code>TypeScript</code>，但在编写 <code>React</code> 项目的时候，还存在 <code>hooks</code>、默认参数、以及 <code>store</code> 等等……</p>
<p><code>TypeScript</code> 在框架中使用的学习成本相对会更高，需要不断编写才能熟练</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-使用-Typescript-有哪些优点和缺点"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-使用-Typescript-有哪些优点和缺点" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 使用 Typescript 有哪些优点和缺点"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 使用 Typescript 有哪些优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h5 id="提供可选的强静态类型"><a href="#提供可选的强静态类型" class="headerlink" title="提供可选的强静态类型"></a>提供可选的强静态类型</h5><p>既然叫 TypeScript，那它的最大亮点自然就是提供静态类型（type）。我们可以对变量设置类型，比如你给 count 变量设置为数字类型（number），如果你从 input 元素提取 value （string 类型）赋予给 count，如果你忘记将其转换为数字，编译是不会通过的。</p>
<p>当然类型不是强求设置的，为了兼容 JavaScript，你也可以设置为 any 类型。所谓 any 类型是一个特殊的类型，任何类型的的值都可以赋予给它。</p>
<h5 id="更早发现-BUG"><a href="#更早发现-BUG" class="headerlink" title="更早发现 BUG"></a>更早发现 BUG</h5><p>TypeScript 要编译后才能使用。所以我们的类型错误会在编译过程中被编译器发现，更早发现 BUG。如果直接用 JavaScript 开发，需要在程序运行时，吭哧吭哧点来点去各种测试来判断行为是否正常，费时费力，开发体验极差。</p>
<p>比如原本应该是两个数字相加的，写错成两个数字形式的字符串相加，结果是差得十万八千里，且不易察觉。TypeScript 在编译时就给你找到了，你不改对别想过我编译。</p>
<h5 id="代码可预测"><a href="#代码可预测" class="headerlink" title="代码可预测"></a>代码可预测</h5><p>声明的变量一旦指定类型，它的类型就再也不能修改。这样变量就具有可预测性。</p>
<p>JavaScript 的变量可以赋予任何类型的值。有时候，我们会看到一个变量在执行的过程中变成各种各样的类型，一会是字符串，一会是对象，非常不好预测，尤其是有复杂条件判断的时候。这其实是并不是好的开发习惯，但在 JavaScript 它就是可以这么干！</p>
<p>但如果你用 TypeScript，就没有这个烦恼，它直接给你一刀切了，你别想将字符串值赋予给一个数字类型变量，一旦声明就再也无法修改。</p>
<p>当然为了兼容，你也是可以将其设置 any 类型，但智能提升就没有了哦。</p>
<h5 id="丰富的-IDE-支持"><a href="#丰富的-IDE-支持" class="headerlink" title="丰富的 IDE 支持"></a>丰富的 IDE 支持</h5><p>因为使用了类型，所以检测某个变量是什么类型、可以使用哪些方法就变得容易，在开发体验上就可以进行改善了。</p>
<p>目前在绝大多数 IDE（集成开发环境）中已经支持 TypeScript 的 智能提示、自动补全、代码导航 等功能，并能在编写时实时反馈类型错误并提供准确的建议，比如可以指出传入函数的对象缺了哪些属性。</p>
<h5 id="方便重构"><a href="#方便重构" class="headerlink" title="方便重构"></a>方便重构</h5><p>重构时，如果函数的参数修改了，调用它时如果不对，TypeScript 会提示你。这对重构代码提供了坚实的后盾。有了 TypeScript，就放心做重构吧，前提你不要到处用 any。</p>
<h5 id="提供面向对象的写法"><a href="#提供面向对象的写法" class="headerlink" title="提供面向对象的写法"></a>提供面向对象的写法</h5><p>面向对象语言在实践中已经被证实是优秀的设计，拥有极高的可读性、可维护性。TypeScript 支持接口、抽象类、枚举等面向对象语言的特性，支持你更好地实现一些设计模式。TypeScript 还支持类型体操，有空多锻炼身体哈。</p>
<p>看了这么多优点，再看看 TypeScript 的缺点。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="不是真正的静态类型"><a href="#不是真正的静态类型" class="headerlink" title="不是真正的静态类型"></a>不是真正的静态类型</h5><p>因为需要兼容 JavaScript 的缘故，TypeScript 的类型是可选的。你可以用 any 类型，也可以进行类型的强制转换，所以如果你在代码中写了太多这样的东西，甚至将其变成 AnyScript。那么实际运行还是可能会出现一些类型上的问题。</p>
<h5 id="有一定的学习成本"><a href="#有一定的学习成本" class="headerlink" title="有一定的学习成本"></a>有一定的学习成本</h5><p>学 TypeScript 其实和学习一门新语言差不多了，还是有不小的学习成本的。但因为兼容 JavaScript 的缘故，对前端开发者来说难度会低一点。</p>
<h5 id="需要写更多的代码"><a href="#需要写更多的代码" class="headerlink" title="需要写更多的代码"></a>需要写更多的代码</h5><p>主要是类型和接口声明的部分，但能够抵消掉你 debug 类型问题的时间，总体看还是物超所值的。另外，编译后类型和接口声明都会被移除，相比直接写 JavaScript，体积不会明显更大。</p>
<h5 id="需要编译"><a href="#需要编译" class="headerlink" title="需要编译"></a>需要编译</h5><p>浏览器和 Nodejs 并不支持 TypeScript，所以多了一步编译操作。对于普通项目来说通常不长，其实还好。但如果你用来写脚本的话，就需要多安装 tsc 编译工具，还要配置好 tsconfig.json 文件，还是有点麻烦。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-Typescript中的内置类型有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-Typescript中的内置类型有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Typescript中的内置类型有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Typescript中的内置类型有哪些？</h3><h4 id="Partial（部分的）"><a href="#Partial（部分的）" class="headerlink" title="Partial（部分的）"></a>Partial（部分的）</h4><pre><code class="typescript">/**
 * Make all properties in T optional
 */
type Partial&lt;T&gt; = &#123;
    [P in keyof T]?: T[P];
&#125;;
</code></pre>
<p>作用是让传入类型中的所有属性变成都是可选的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;&#125;

const student2: Partial&lt;Student&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101152.jpeg"></p>
<p>变量student1的类型是Student，Student默认所有的属性都是不能为空的，所有会报错，student2就不会</p>
<h4 id="Required（必须的）"><a href="#Required（必须的）" class="headerlink" title="Required（必须的）"></a>Required（必须的）</h4><pre><code class="typescript">/**
 * Make all properties in T required
 */
type Required&lt;T&gt; = &#123;
    [P in keyof T]-?: T[P];
&#125;;
</code></pre>
<p>跟Partial的作用是相反的，是让传入类型中的所有属性变成都是必填的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name?: string;
  age?: number;
&#125;

const student1: Student = &#123;&#125;

const student2: Required&lt;Student&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101153.jpeg"></p>
<p>变量student1的类型是Student，Student默认所有的属性都是可以为空的，所有不会报错，student2会报错</p>
<h4 id="Readonly（只读的）"><a href="#Readonly（只读的）" class="headerlink" title="Readonly（只读的）"></a>Readonly（只读的）</h4><pre><code class="typescript">/**
 * Make all properties in T readonly
 */
type Readonly&lt;T&gt; = &#123;
    readonly [P in keyof T]: T[P];
&#125;;
</code></pre>
<p>作用是让传入类型中的所有属性变成都是只读的（不能修改属性）</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;
student1.age = 21

const student2: Readonly&lt;Student&gt; = &#123;
  name: &#39;李四&#39;,
  age: 20
&#125;
student2.age = 21
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101154.jpeg"></p>
<p>给student1的属性age重新赋值不会报错，给student2的属性age重新赋值就会报错，因为student2所有的属性都是只读的</p>
<h4 id="Pick（选择）"><a href="#Pick（选择）" class="headerlink" title="Pick（选择）"></a>Pick（选择）</h4><pre><code class="typescript">/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Pick&lt;T, K extends keyof T&gt; = &#123;
    [P in K]: T[P];
&#125;;
</code></pre>
<p>作用是选择传入类型中的部分属性组成新类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;

const student2: Pick&lt;Student, &#39;name&#39;&gt; = &#123;
  name: &#39;李四&#39;
&#125;

const student3: Pick&lt;Student, &#39;name&#39;&gt; = &#123;
  name: &#39;王五&#39;,
  age: 20
&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101155.jpeg"></p>
<p>变量student1可以有所有属性name和age，变量student2就只能有属性name，变量student3加上属性age就会报错</p>
<h4 id="Record（记录）"><a href="#Record（记录）" class="headerlink" title="Record（记录）"></a>Record（记录）</h4><pre><code class="typescript">/**
 * Construct a type with a set of properties K of type T
 */
type Record&lt;K extends keyof any, T&gt; = &#123;
    [P in K]: T;
&#125;;
</code></pre>
<p>作用是构建一个类型，这个类型用来描述一个对象，这个对象的属性都具有相同的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export const student1: Record&lt;string, any&gt; = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;
</code></pre>
<p>Record应该是日常使用频率较高的内置类型了，主要用来描述对象，一般建议是不用Object来描述对象，而是用Record代替，Record&lt;string, any&gt;几乎可以说是万金油了</p>
<h4 id="Exclude（排除）"><a href="#Exclude（排除）" class="headerlink" title="Exclude（排除）"></a>Exclude（排除）</h4><pre><code class="typescript">/**
 * Exclude from T those types that are assignable to U
 */
type Exclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre>
<p>针对联合类型（interface这种没用），用人话说，排除相同的，留下不同的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Exclude&lt;StudentAttr, PersonAttr&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101156.jpeg"></p>
<p>student1就只能被赋值为’class’ 或者’school’</p>
<h4 id="Extract（取出）"><a href="#Extract（取出）" class="headerlink" title="Extract（取出）"></a>Extract（取出）</h4><pre><code class="typescript">/**
 * Extract from T those types that are assignable to U
 */
type Extract&lt;T, U&gt; = T extends U ? T : never;
</code></pre>
<p>与Exclude相反，针对联合类型，排除不同的的，取出相同的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Extract&lt;StudentAttr, PersonAttr&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101157.jpeg"></p>
<p>student1就只能被赋值为’name’或者’age’</p>
<h4 id="Omit（省略）"><a href="#Omit（省略）" class="headerlink" title="Omit（省略）"></a>Omit（省略）</h4><pre><code class="typescript">/**
 * Construct a type with the properties of T except for those in type K.
 */
type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;
</code></pre>
<p>传入一个类型，和这个类型的几个属性，把传入的属性省略掉，组成一个新类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
  class: string;
  school: string;
&#125;

export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Omit&lt;Student, PersonAttr&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101158.jpeg"></p>
<p>student1报错，提示没有属性’name’、’age’</p>
<h4 id="NonNullable（不能为null）"><a href="#NonNullable（不能为null）" class="headerlink" title="NonNullable（不能为null）"></a>NonNullable（不能为null）</h4><pre><code class="typescript">/**
 * Exclude null and undefined from T
 */
type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;
</code></pre>
<p>字面意思，不能为空</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: NonNullable&lt;Student | undefined | null&gt; = null
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101159.jpeg"></p>
<p>student1赋值为null会报错（在tsconfig.json配置文件中开启类型检查，<code>&quot;skipLibCheck&quot;: false</code>）</p>
<h4 id="Parameters（参数）"><a href="#Parameters（参数）" class="headerlink" title="Parameters（参数）"></a>Parameters（参数）</h4><pre><code class="typescript">/**
 * Obtain the parameters of a function type in a tuple
 */
type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>获取传入函数的参数组成的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentFunc &#123;
  (name: string, age: number): Student
&#125;

const student1: Parameters&lt;StudentFunc&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101160.jpeg"></p>
<p>student1的类型为<code>[name: string, age: number]</code></p>
<h4 id="ConstructorParameters（构造参数）"><a href="#ConstructorParameters（构造参数）" class="headerlink" title="ConstructorParameters（构造参数）"></a>ConstructorParameters（构造参数）</h4><pre><code class="typescript">/**
 * Obtain the parameters of a constructor function type in a tuple
 */
type ConstructorParameters&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>获取传入构造函数的参数组成的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentConstructor &#123;
  new (name: string, age: number): Student
&#125;

const student1: ConstructorParameters&lt;StudentConstructor&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101161.jpeg"></p>
<p>student1的类型为<code>[name: string, age: number]</code></p>
<h4 id="ReturnType（返回类型）"><a href="#ReturnType（返回类型）" class="headerlink" title="ReturnType（返回类型）"></a>ReturnType（返回类型）</h4><pre><code class="typescript">/**
 * Obtain the return type of a function type
 */
type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;
</code></pre>
<p>获取传入函数的返回类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentFunc &#123;
  (name: string, age: number): Student
&#125;

const student1: ReturnType&lt;StudentFunc&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101162.jpeg"></p>
<p>student1的类型为<code>Student</code></p>
<h4 id="InstanceType（构造返回类型、实例类型）"><a href="#InstanceType（构造返回类型、实例类型）" class="headerlink" title="InstanceType（构造返回类型、实例类型）"></a>InstanceType（构造返回类型、实例类型）</h4><pre><code class="typescript">/**
 * Obtain the return type of a constructor function type
 */
type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any;
</code></pre>
<p>获取传入构造函数的返回类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">const Student = class &#123;
  name: string;
  age: number;
  constructor (name: string, age: number) &#123;
    this.name = name
    this.age = age
  &#125;
  showInfo () &#123;
    console.log(&#39;name: &#39;, this.name, &#39;age: &#39;, this.age);
  &#125;
&#125;

const student1: InstanceType&lt;typeof Student&gt; = new Student(&#39;张三&#39;, 20)
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101163.jpeg"></p>
<p>个人认为这是一个非常好用的内置类型，目前在前端项目中，class是用的越来越多了，在TS中，class其实也是可以用作类型声明空间的，用来描述对象类型，但是一般来说好像很少这样用的，一般用interface或者type居多</p>
<pre><code class="typescript">export class Student &#123;
  name: string;
  age: number;
&#125;
</code></pre>
<p>所以一般就是直接把class用作变量声明空间，但是对于 class new 出的实例，怎么描述它的类型呢，就如上文的，直接<code>const student1: Student</code>那是铁定会报错的，因为Student用作变量声明空间，没有用作类型声明空间（听起来好绕），这时候就可以用到InstanceType，完美解决问题</p>
<h4 id="Uppercase（大写）"><a href="#Uppercase（大写）" class="headerlink" title="Uppercase（大写）"></a>Uppercase（大写）</h4><pre><code class="typescript">/**
 * Convert string literal type to uppercase
 */
type Uppercase&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>变大写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;male&#39; | &#39;female&#39;

const studentSex: Uppercase&lt;StudentSexType&gt; = &#39;MALE&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101164.jpeg"></p>
<h4 id="Lowercase（小写）"><a href="#Lowercase（小写）" class="headerlink" title="Lowercase（小写）"></a>Lowercase（小写）</h4><pre><code class="typescript">/**
 * Convert string literal type to lowercase
 */
type Lowercase&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>变小写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;MALE&#39; | &#39;FEMALE&#39;

const studentSex: Lowercase&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101165.jpeg"></p>
<h4 id="Capitalize（首字母大写）"><a href="#Capitalize（首字母大写）" class="headerlink" title="Capitalize（首字母大写）"></a>Capitalize（首字母大写）</h4><pre><code class="typescript">/**
 * Convert first character of string literal type to uppercase
 */
type Capitalize&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>首字母变大写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;male&#39; | &#39;female&#39;

const studentSex: Capitalize&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101166.jpeg"></p>
<h4 id="Uncapitalize（首字母小写）"><a href="#Uncapitalize（首字母小写）" class="headerlink" title="Uncapitalize（首字母小写）"></a>Uncapitalize（首字母小写）</h4><pre><code class="typescript">/**
 * Convert first character of string literal type to lowercase
 */
type Uncapitalize&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>首字母变小写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;MALE&#39; | &#39;FEMALE&#39;

const studentSex: Uncapitalize&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101167.jpeg"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-能否将多个-ts-文件组合成一个-js-文件？-如果是，那么如何？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-能否将多个-ts-文件组合成一个-js-文件？-如果是，那么如何？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 能否将多个 .ts 文件组合成一个 .js 文件？ 如果是，那么如何？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 能否将多个 <code>.ts</code> 文件组合成一个 <code>.js</code> 文件？ 如果是，那么如何？</h3><p>这是可以的。需要添加 —outFILE [OutputJSFileName] 编译选项。</p>
<pre><code class="shell">$ tsc --outFile comman.js file1.ts file2.ts file3.ts
</code></pre>
<p>上述命令将编译所有三个<code>.ts</code>文件，结果将存储到单个<code>comman.js</code>文件中。在这种情况下，当没有像下面的命令那样提供输出文件名时。</p>
<pre><code class="shell">$ tsc --outFile file1.ts file2.ts file3.ts
</code></pre>
<p>然后，<code>file2.ts</code>和<code>file3.ts</code>会被编译，输出会放在<code>file1.ts</code>中。所以现在的 <code>file1.ts</code> 包含 JavaScript 代码。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-是否可以通过-ts-文件中的实时更改自动编译-ts-？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-是否可以通过-ts-文件中的实时更改自动编译-ts-？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 是否可以通过 .ts 文件中的实时更改自动编译 .ts ？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 是否可以通过 <code>.ts</code> 文件中的实时更改自动编译 <code>.ts</code> ？</h3><p>是的，可以通过 <code>.ts</code> 文件中的实时更改自动编译<code>.ts</code>。这可以通过使用 <code>--watch</code> 编译器选项来实现。</p>
<pre><code class="shell">tsc --watch file1.ts
</code></pre>
<p>上面的命令首先编译 <code>file1.js</code> 中的 <code>file1.ts</code> 并观察文件的变化。如果检测到任何更改，它将再次编译该文件。在这里，需要确保在使用 <code>--watch</code> 选项运行时不能关闭命令提示符。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-interface语句和type语句有什么区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-interface语句和type语句有什么区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ interface语句和type语句有什么区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ interface语句和type语句有什么区别？</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>都可以描述一个对象或者函数</p>
<p>interface</p>
<pre><code class="typescript">interface User &#123;
  name: string
  age: number
&#125;

interface SetUser &#123;
  (name: string, age: number): void;
&#125;
</code></pre>
<p>type</p>
<pre><code class="typescript">type User = &#123;
  name: string
  age: number
&#125;;

type SetUser = (name: string, age: number)=&gt; void;
</code></pre>
<p>都允许拓展（extends）</p>
<p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p>
<p>interface extends interface</p>
<pre><code class="typescript">interface Name &#123; 
  name: string; 
&#125;
interface User extends Name &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<p>type extends type</p>
<pre><code class="ini">type Name = &#123; 
  name: string; 
&#125;
type User = Name &amp; &#123; age: number  &#125;;
复制代码
</code></pre>
<p>interface extends type</p>
<pre><code class="typescript">type Name = &#123; 
  name: string; 
&#125;
interface User extends Name &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<p>type extends interface</p>
<pre><code class="ini">interface Name &#123; 
  name: string; 
&#125;
type User = Name &amp; &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>type 可以而 interface 不行</p>
<ul>
<li>type 可以声明基本类型别名，联合类型，元组等类型</li>
</ul>
<pre><code class="go">// 基本类型别名
type Name = string

// 联合类型
interface Dog &#123;
    wong();
&#125;
interface Cat &#123;
    miao();
&#125;

type Pet = Dog | Cat

// 具体定义数组每个位置的类型
type PetList = [Dog, Pet]

复制代码
</code></pre>
<ul>
<li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</li>
</ul>
<pre><code class="ini">// 当你想获取一个变量的类型时，使用 typeof
let div = document.createElement(&#39;div&#39;);
type B = typeof div
复制代码
</code></pre>
<ul>
<li>其他骚操作</li>
</ul>
<pre><code class="ini">type StringOrNumber = string | number;  
type Text = string | &#123; text: string &#125;;  
type NameLookup = Dictionary&lt;string, Person&gt;;  
type Callback&lt;T&gt; = (data: T) =&gt; void;  
type Pair&lt;T&gt; = [T, T];  
type Coordinates = Pair&lt;number&gt;;  
type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;
复制代码
</code></pre>
<p>interface 可以而 type 不行</p>
<p>interface 能够声明合并</p>
<pre><code class="typescript">interface User &#123;
  name: string
  age: number
&#125;

interface User &#123;
  sex: string
&#125;

/*
User 接口为 &#123;
  name: string
  age: number
  sex: string 
&#125;
*/
复制代码
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在Proxy中代理apply方法"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在Proxy中代理apply方法" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Proxy中代理apply方法"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Proxy中代理apply方法</h3><pre><code class="javascript"> &#123;
            var target = function () &#123;
                return &#39;I am the target&#39;;
            &#125;
            var handler = &#123;
                apply: function () &#123;
                    return &#39;I am the proxy&#39;;
                &#125;
            &#125;;
            var p = new Proxy(target,handler);
            console.log(&quot;p&quot;,p());
        &#125;
//上面代码中，变量p是Proxy的实例，当他作为函数调用时（p（））
//,就会被apply方法拦截，返回一个字符串
</code></pre>
<pre><code class="javascript">&#123;
    var twice = &#123;
                    //目标对象，目标对象的上下文对象，目标对象的参数数组
        apply:function (target,ctx,args) &#123;
            //return console.log(&quot;target&quot;,target,&quot;ctx&quot;,ctx,&quot;args&quot;,args);
           return Reflect.apply(...arguments)*2;
        &#125;
    &#125;;
    function sum (left,right) &#123;
         return left*right;
    &#125;;
    var proxy = new Proxy(sum,twice);
    console.log(&quot;proxy1&quot;,proxy(1,2));
    console.log(&quot;proxy.call&quot;,proxy.call(null,5,6));
    console.log(&quot;proxy,apply&quot;,proxy.apply(null,[7,8]));
    console.log(&quot;proxy,apply&quot;,Reflect.apply(proxy,null,[7,8]));

&#125;
//上面的实例执行顺序是当sum（）执行完后再执行twice中的apply()，
//上面代码中每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截
//另外，直接调用Reflect.apply方法，也会被拦截。
</code></pre>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题大全node</title>
    <url>/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（node-js）"><a href="#前端面试题大全（node-js）" class="headerlink" title="前端面试题大全（node.js）"></a>前端面试题大全（node.js）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><h3 id="♥︎-♥︎-说说你对Node-js-的理解？优缺点？应用场景？"><a href="#♥︎-♥︎-说说你对Node-js-的理解？优缺点？应用场景？" class="headerlink" title="♥︎ ♥︎ 说说你对Node.js 的理解？优缺点？应用场景？"></a>♥︎ ♥︎ 说说你对Node.js 的理解？优缺点？应用场景？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>Node.js</code> 是一个开源与跨平台的 <code>JavaScript</code> 运行时环境</p>
<p>在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能</p>
<p>可以理解为 <code>Node.js</code> 就是一个服务器端的、非阻塞式I&#x2F;O的、事件驱动的<code>JavaScript</code>运行环境</p>
<h5 id="非阻塞异步"><a href="#非阻塞异步" class="headerlink" title="非阻塞异步"></a>非阻塞异步</h5><p><code>Nodejs</code>采用了非阻塞型<code>I/O</code>机制，在做<code>I/O</code>操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作</p>
<p>例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率</p>
<h5 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h5><p>事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数</p>
<p>比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61373732393539302d633165382d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、优缺点"><a href="#二、优缺点" class="headerlink" title="二、优缺点"></a>二、优缺点</h4><p>优点：</p>
<ul>
<li>处理高并发场景性能更佳</li>
<li>适合I&#x2F;O密集型应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I&#x2F;O硬盘内存读写操作</li>
</ul>
<p>因为<code>Nodejs</code>是单线程，带来的缺点有：</p>
<ul>
<li>不适合CPU密集型应用</li>
<li>只支持单核CPU，不能充分利用CPU</li>
<li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>
</ul>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>借助<code>Nodejs</code>的特点和弊端，其应用场景分类如下：</p>
<ul>
<li>善于<code>I/O</code>，不善于计算。因为Nodejs是一个单线程，如果计算（同步）太多，则会阻塞这个线程</li>
<li>大量并发的I&#x2F;O，应用程序内部并不需要进行非常复杂的处理</li>
<li>与 websocket 配合，开发长连接的实时交互应用程序</li>
</ul>
<p>具体场景可以表现为如下：</p>
<ul>
<li>第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序</li>
<li>第二大类：基于web、canvas等多人联网游戏</li>
<li>第三大类：基于web的多人实时聊天客户端、聊天室、图文直播</li>
<li>第四大类：单页面浏览器应用程序</li>
<li>第五大类：操作数据库、为前端和移动端提供基于<code>json</code>的API</li>
</ul>
<p>其实，<code>Nodejs</code>能实现几乎一切的应用，只考虑适不适合使用它</p>
<h3 id="♥︎-♥︎-为什么-Node-js-是单线程的？"><a href="#♥︎-♥︎-为什么-Node-js-是单线程的？" class="headerlink" title="♥︎ ♥︎ 为什么 Node.js 是单线程的？"></a>♥︎ ♥︎ 为什么 Node.js 是单线程的？</h3><p>回答一：怼：如果不幸遇到面试官问这个问题，你反问他 nodejs 为什么叫做 nodejs.</p>
<p>回答二：苟：您好，贵公司的面试题还挺有深度的，这让我越来越期待加入贵公司了。关于 ndoejs 是单线程的，刚好前段时间阅读过有关 node 的文章。node 的作者在设计之初选择语言时，评估过当时的流行语言，最终选择了存在多年在后端却一直没有市场的 js,正是 js 的不被关注，使得使用 js 没有额外阻力，而 js 在浏览器中有广泛的事件驱动方面的应用，正符合作者的喜好。于是 node 使用了 js 作为开发语言，node 的作者在开发时保持了 js 单线程的特点，所以 nodejs 是单线程的。</p>
<h3 id="♥︎-♥︎-什么是回调函数？"><a href="#♥︎-♥︎-什么是回调函数？" class="headerlink" title="♥︎ ♥︎ 什么是回调函数？"></a>♥︎ ♥︎ 什么是回调函数？</h3><p>概念：</p>
<p>回调就是一种利用函数指针进行函数调用的过程。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。</p>
<p>对普通函数的调用：</p>
<p>调用程序发出对普通函数的调用后，程序执行立即转向被调用函数执行，直到被调用函数执行完毕后，再返回调用程序继续执行。从发出调用的程序的角度看，这个过程为“调用–&gt;等待被调用函数执行完毕–&gt;继续执行”</p>
<p>对回调函数调用：</p>
<p>调用程序发出对回调函数的调用后，不等函数执行完毕，立即返回并继续执行。这样，调用程序执和被调用函数同时在执行。当被调函数执行完毕后，被调函数会反过来调用某个事先指定函数，以通知调用程序：函数调用结束。这个过程称为回调(Callback)，这正是回调函数名称的由来。<br>回调函数机制：</p>
<p>1、定义一个函数（图中的sub&#x2F;mul函数）；</p>
<p>2、将此函数的地址注册给调用者test函数；</p>
<p>3、特定的事件或条件发生时（main主函数），调用者使用函数指针调用回调函数。</p>
<p>回调函数的缺点：</p>
<p>1）回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。</p>
<p>2）回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。</p>
<h3 id="♥︎-♥︎-Node-js-和-ajax-的区别是什么"><a href="#♥︎-♥︎-Node-js-和-ajax-的区别是什么" class="headerlink" title="♥︎ ♥︎  Node.js 和 ajax 的区别是什么?"></a>♥︎ ♥︎  Node.js 和 ajax 的区别是什么?</h3><p>区别一：</p>
<p>Ajax（异步Javascript和XML的简称）是一种客户端技术，通常用于更新页面内容而不刷新它。</p>
<p>而Node.js是服务器端Javascript，是一个基于 Chrome V8 引擎的 JavaScript 运行环境，是一个让 JavaScript 运行在服务端的开发平台。</p>
<p>区别二：</p>
<p>Node.js不在浏览器中执行，而是由服务器执行。而Ajax在浏览器中执行。</p>
<p>区别三：</p>
<p>node主要是提供后台服务，而ajax主要是用来前后台数据的请求与发送数据的。</p>
<h3 id="♥︎-♥︎-请使用-Node-js-原生的-HTTP-模块创建一个-web-Server。"><a href="#♥︎-♥︎-请使用-Node-js-原生的-HTTP-模块创建一个-web-Server。" class="headerlink" title="♥︎ ♥︎ 请使用 Node.js 原生的 HTTP 模块创建一个 web Server。"></a>♥︎ ♥︎ 请使用 Node.js 原生的 HTTP 模块创建一个 web Server。</h3><pre><code class="js">const http = require(&#39;http&#39;)
const port = 3000
const server = http.createServer((req, res) =&gt; &#123;
 res.statusCode = 200
 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;)
 res.end(&#39;Hello World&#39;)
&#125;)
server.listen(port, () =&gt; &#123;
 console.log( Server is running on http://127.0.0.1:$&#123;port&#125;/ )
&#125;)
</code></pre>
<hr>
<h3 id="♥︎-♥︎-♥︎-如何使用原生-Node-js-操做-cookie？"><a href="#♥︎-♥︎-♥︎-如何使用原生-Node-js-操做-cookie？" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何使用原生 Node.js 操做 cookie？"></a>♥︎ ♥︎ ♥︎ 如何使用原生 Node.js 操做 cookie？</h3><p>获取 cookie： req.headers.cookie</p>
<p>设置 cookie： res.writeHead(200, { ‘Set-Cookie’: ‘myCookie&#x3D;test’, ‘Content-Type’: ‘text&#x2F;plain’ }) </p>
<p><a href="https://blog.csdn.net/u012732909/article/details/119107135">node操作cookie</a>参考请点击</p>
<h3 id="♥︎-♥︎-♥︎-setImmediate-和-setTimeOut-区别在哪里"><a href="#♥︎-♥︎-♥︎-setImmediate-和-setTimeOut-区别在哪里" class="headerlink" title="♥︎ ♥︎ ♥︎ setImmediate 和 setTimeOut 区别在哪里?"></a>♥︎ ♥︎ ♥︎ setImmediate 和 setTimeOut 区别在哪里?</h3><p>setImmediate 和 setTimeOut 都是延迟加载。而当这两个定时器同时运行在主模块时，运行顺序是不一定的。setTimeOut 受进程性能的约束，有可能比 setImmediate 快，也有可能慢于 setImmediate。</p>
<p>而在 I&#x2F;O 事件的回调中，setImmediate 方法的回调永远在 setTimeOut 的回调前执行。</p>
<h3 id="♥︎-♥︎-♥︎-如何更新-Node-js-的版本"><a href="#♥︎-♥︎-♥︎-如何更新-Node-js-的版本" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何更新 Node.js 的版本?"></a>♥︎ ♥︎ ♥︎ 如何更新 Node.js 的版本?</h3><pre><code class="css">npm install npm -g (在命令行中将 npm 在重新安装一遍，如需指定版本需要加上 @版本数字 )
</code></pre>
<h3 id="♥︎-♥︎-♥︎-nextTick-和-setImmediate-的区别是什么？"><a href="#♥︎-♥︎-♥︎-nextTick-和-setImmediate-的区别是什么？" class="headerlink" title="♥︎ ♥︎ ♥︎  nextTick 和 setImmediate 的区别是什么？"></a>♥︎ ♥︎ ♥︎  nextTick 和 setImmediate 的区别是什么？</h3><p>nextTick 和 setImmediate 都是延迟加载。但是 nextTick 是放在当前队列的最后一个执行，</p>
<p>setImmediate 是在下一个队列的队首执行</p>
<h3 id="♥︎-♥︎-♥︎-请使用-Node-js-编写代码实现遍历文件夹并输出所有的文件名"><a href="#♥︎-♥︎-♥︎-请使用-Node-js-编写代码实现遍历文件夹并输出所有的文件名" class="headerlink" title="♥︎ ♥︎ ♥︎ 请使用 Node.js 编写代码实现遍历文件夹并输出所有的文件名"></a>♥︎ ♥︎ ♥︎ 请使用 Node.js 编写代码实现遍历文件夹并输出所有的文件名</h3><pre><code class="js">const fs = require(&#39;fs&#39;)
const path = require(&#39;path&#39;)
const getAllFile = function (dir) &#123;
 function traverse(dir) &#123;
 fs.readdirSync(dir).forEach(file =&gt; &#123;
 const pathname = path.join(dir, file)
 if (fs.statSync(pathname).isDirectory()) &#123;
 traverse(pathname)
 &#125; else &#123;
 console.log(file)
 &#125;
 &#125;)
 &#125;
 traverse(dir)
&#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？"><a href="#♥︎-♥︎-♥︎-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？" class="headerlink" title="♥︎ ♥︎ ♥︎ token 存储在 localStorage 里，当过期时过期的 token 怎么处理？"></a>♥︎ ♥︎ ♥︎ token 存储在 localStorage 里，当过期时过期的 token 怎么处理？</h3><p>当前端进行页面跳转或者需要鉴权的操作时，会发送请求到后台，而 token 会跟随请求头一起发送，后台通过请求头接收到 token 时会进行判断，若是过期了，应该返回一个 401 的状态码给前端，前端接收到以后，应该重定向到登录页要求用户重新登陆。</p>
<h3 id="♥︎-♥︎-♥︎-MySQL-和-MongoDB-的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？"><a href="#♥︎-♥︎-♥︎-MySQL-和-MongoDB-的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？" class="headerlink" title="♥︎ ♥︎ ♥︎ MySQL 和 MongoDB 的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？"></a>♥︎ ♥︎ ♥︎ MySQL 和 MongoDB 的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>数据库模型 mysql 是关系型数据库，现在使用最多的数据存储技术 mongodb 是非关系型数据库，并且是非关系型数据库中最像关系型的数据库</p>
<p>存储方式 mongodb-以类 JSON 的文档的格式存储 mysql-不同引擎有不同的存储方式</p>
<p>数据处理方式 mongodb-基于内存，将热数据存放在物理内存中，从而达到高速读写 mysql-不同引擎有自己的特点</p>
<h4 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h4><p>mongodb 的查询语句类似于 js 使用 api 的场景，通过 . 来调用，并传递参数来进行控制查询内容 如：查询 username 为张三，age 为 27 的数据</p>
<pre><code class="ini">db.users.find(&#123; username: &#39;张三&#39;, age: 27 &#125;)
</code></pre>
<p>而 mysql 则是标准的 sql 语句，同样查询代码如下：</p>
<pre><code class="ini">select * from users where &quot;username&quot; = &quot;张三&quot; and age = 27
</code></pre>
<h3 id="♥︎-♥︎-♥︎-什么是服务端渲染，服务端渲染的优点？"><a href="#♥︎-♥︎-♥︎-什么是服务端渲染，服务端渲染的优点？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是服务端渲染，服务端渲染的优点？"></a>♥︎ ♥︎ ♥︎ 什么是服务端渲染，服务端渲染的优点？</h3><p>服务端渲染：页面渲染过程是在服务端完成，最终的 HTML 字符串，直接通过请求发送给客户端。</p>
<p>服务器端渲染的优势就是利于 SEO 优化，首屏加载快，因为客户端接收到的是完整的 HTML 页面。</p>
<h3 id="♥︎-♥︎-♥︎-如何在-Node-js-中操作-MongoDb-数据库"><a href="#♥︎-♥︎-♥︎-如何在-Node-js-中操作-MongoDb-数据库" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何在 Node.js 中操作 MongoDb 数据库"></a>♥︎ ♥︎ ♥︎ 如何在 Node.js 中操作 MongoDb 数据库</h3><h4 id="一、在-Nodejs-中使用-Mongodb"><a href="#一、在-Nodejs-中使用-Mongodb" class="headerlink" title="一、在 Nodejs 中使用 Mongodb"></a>一、在 Nodejs 中使用 Mongodb</h4><p>Nodejs 操作 mongodb 数据库官方文档：</p>
<p><a href="http://mongodb.github.io/node-mongodb-native/">http://mongodb.github.io/node-mongodb-native/</a></p>
<pre><code class="ini">npm install mongodb --save 
或者
cnpm install mongodb --save 
或者
yarn add mongodb
</code></pre>
<h4 id="二、Nodejs-操作-MongoDb-数据库"><a href="#二、Nodejs-操作-MongoDb-数据库" class="headerlink" title="二、Nodejs 操作 MongoDb 数据库"></a>二、Nodejs 操作 MongoDb 数据库</h4><pre><code class="javascript">// 1 cnpm install mongodb --save

//2、引入mongodb
const &#123; MongoClient &#125; = require(&#39;mongodb&#39;);

//3、定义数据库连接的地址
const url = &#39;mongodb://127.0.0.1:27017&#39;;

//4、定义要操作的数据库
const dbName = &#39;itying&#39;;

//5、实例化MongoClient 传入数据库连接地址
const client = new MongoClient(url, &#123; useUnifiedTopology: true &#125;);

//6、连接数据库 操作数据

client.connect((err) =&gt; &#123;
    if (err) &#123;
        console.log(err);
        return;
    &#125;
    console.log(&quot;数据库连接成功&quot;);

    let db = client.db(dbName);

    // //1、查找数据
    db.collection(&quot;user&quot;).find(&#123;&quot;age&quot;:13&#125;).toArray((err,data)=&gt;&#123;
       if(err)&#123; 
            console.log(err);
            return;
        &#125;
        console.log(data);       
        //操作数据库完毕以后一定要 关闭数据库连接
        client.close();
    &#125;)


    //2、增加数据

    // db.collection(&quot;user&quot;).insertOne(&#123;&quot;username&quot;:&quot;nodejs操作mongodb&quot;,&quot;age&quot;:10&#125;,(err,result)=&gt;&#123;
    //     if(err)&#123; //增加失败
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;增加成功&quot;);
    //     console.log(result);
    //       //操作数据库完毕以后一定要 关闭数据库连接
    //      client.close();

    // &#125;)


    //3、修改数据

    // db.collection(&quot;user&quot;).updateOne(&#123; &quot;name&quot;: &quot;zhangsan&quot; &#125;, &#123; $set: &#123; &quot;age&quot;: 10 &#125; &#125;, (err, result) =&gt; &#123;
    //     if (err) &#123; //修改失败
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;修改成功&quot;);
    //     console.log(result);
    //     //操作数据库完毕以后一定要 关闭数据库连接
    //     client.close();
    // &#125;)


    //4、删除一条数据

    // db.collection(&quot;user&quot;).deleteOne(&#123; &quot;username&quot;: &quot;nodejs&quot; &#125;, (err)=&gt;&#123;

    //     if (err) &#123; 
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;删除一条数据成功&quot;);
    //     client.close();
    // &#125;)

     //5、删除多条数据

    // db.collection(&quot;user&quot;).deleteMany(&#123; &quot;username&quot;: &quot;nodejs&quot; &#125;, (err)=&gt;&#123;

    //     if (err) &#123; 
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;删除多条数据成功&quot;);
    //     client.close();
    // &#125;)

&#125;)
</code></pre>
<h3 id="♥︎-♥︎-♥︎-谈谈-socket-的三种常见使用方式"><a href="#♥︎-♥︎-♥︎-谈谈-socket-的三种常见使用方式" class="headerlink" title="♥︎ ♥︎ ♥︎ 谈谈 socket 的三种常见使用方式"></a>♥︎ ♥︎ ♥︎ 谈谈 socket 的三种常见使用方式</h3><p>第一种方式是 netSocket，主要使用的是 node 中的 net 模块。服务端通过 new net.createServer() 创建服务，使用 on(‘connection’) 方法建立连接，在回调函数中即可获取到客户端发送的信息。客户端通过 new net.Socket() 创建 Socket，通过 connect 连接指定端口和域名后，即可调用 write 方法发送数据</p>
<p>第二种方式是 webSocket，服务端引入第三方插件 ws 创建 socket 服务，客户端使用 H5 新增 API new WebSocket 连接服务端，通过 send 方法发送数据，onmessage 方法接收数据</p>
<p>第三种方式是 socket.io，服务端引入 socket.io’ 模块创建服务，客户端引入 socket.io.js’ 文件，建立连接后，客户端和服务端都是通过 on 方法接收数据，都是使用 emit 方法发送数据。</p>
<h3 id="♥︎-♥︎-♥︎-前后端数据交互的常见使用方式"><a href="#♥︎-♥︎-♥︎-前后端数据交互的常见使用方式" class="headerlink" title="♥︎ ♥︎ ♥︎ 前后端数据交互的常见使用方式"></a>♥︎ ♥︎ ♥︎ 前后端数据交互的常见使用方式</h3><p>cookie：前端可以直接设置或获取 cookie，后端可以使用 req.set(‘set-cookie’， ‘’)设置 cookie，在前端发送请求时通过 req 的 header 字段中获取 cookie</p>
<p>利用 AJAX，和 JQuery 中已经封装好的 $.ajax、$.post、$.getJSON 通过创建一个 XMLHttpRequest 对象，来进行前后端交互。</p>
<p>服务端渲染，浏览器请求到的内容可以通过后端加工一下，将数据直接渲染好，再返回给浏览器。</p>
<h3 id="♥︎-♥︎-♥︎-Node-js-优缺点以及适用场景"><a href="#♥︎-♥︎-♥︎-Node-js-优缺点以及适用场景" class="headerlink" title="♥︎ ♥︎ ♥︎ Node.js 优缺点以及适用场景"></a>♥︎ ♥︎ ♥︎ Node.js 优缺点以及适用场景</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Node.js 采用事件驱动、异步编程，为网络服务而设计。简单易学，可以很快上手做后端设计。</p>
<p>Node.js 非阻塞模式的 IO 处理给 Node.js 带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它 IO 资源的中间层服务。</p>
<p>Node.js 轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>单线程，可靠性低，一旦这个进程崩掉，那么整个 web 服务就崩掉了。</p>
<p>开源组件库质量参差不齐，更新快，向下不兼容</p>
<p>不适合做企业级应用开发，特别是复杂业务逻辑的，代码不好维护，事务支持不是很好。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>大量 Ajax 请求的应用，例如个性化应用，每个用户看到的页面都不一样，需要在页面加载的时候发起Ajax 请求，NodeJS 能响应大量的并发请求。</p>
<p>实时应用：如在线聊天，实时通知推送等等</p>
<p>工具类应用：海量的工具，小到前端压缩部署，大到桌面图形界面应用程序</p>
<p>总而言之，NodeJS 适合运用在高并发、I&#x2F;O 密集、少量业务逻辑的场景。</p>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-process-的理解？有哪些常用方法？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-process-的理解？有哪些常用方法？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 process 的理解？有哪些常用方法？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 process 的理解？有哪些常用方法？</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>process</code> 对象是一个全局变量，提供了有关当前 <code>Node.js </code>进程的信息并对其进行控制，作为一个全局变量</p>
<p>我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器</p>
<p>当我们启动一个<code>js</code>文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享</p>
<p>由于<code>JavaScript</code>是一个单线程语言，所以通过<code>node xxx</code>启动一个文件后，只有一条主线程</p>
<h4 id="二、属性与方法"><a href="#二、属性与方法" class="headerlink" title="二、属性与方法"></a>二、属性与方法</h4><p>关于<code>process</code>常见的属性有如下：</p>
<ul>
<li>process.env：环境变量，例如通过 &#96;process.env.NODE_ENV 获取不同环境项目配置信息</li>
<li>process.nextTick：这个在谈及 <code>EventLoop</code> 时经常为会提到</li>
<li>process.pid：获取当前进程id</li>
<li>process.ppid：当前进程对应的父进程</li>
<li>process.cwd()：获取当前进程工作目录，</li>
<li>process.platform：获取当前进程运行的操作系统平台</li>
<li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li>
<li>进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</li>
<li>三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li>
<li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li>
</ul>
<p>下面再稍微介绍下某些方法的使用：</p>
<h5 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h5><p>返回当前 <code>Node </code>进程执行的目录</p>
<p>一个<code> Node</code> 模块 <code>A</code> 通过 NPM 发布，项目 <code>B</code> 中使用了模块 <code>A</code>。在 <code>A</code> 中需要操作 <code>B</code> 项目下的文件时，就可以用 <code>process.cwd()</code> 来获取 <code>B</code> 项目的路径</p>
<h5 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h5><p>在终端通过 Node 执行命令的时候，通过 <code>process.argv</code> 可以获取传入的命令行参数，返回值是一个数组：</p>
<ul>
<li>0: Node 路径（一般用不到，直接忽略）</li>
<li>1: 被执行的 JS 文件路径（一般用不到，直接忽略）</li>
<li>2~n: 真实传入命令的参数</li>
</ul>
<p>所以，我们只要从 <code>process.argv[2]</code> 开始获取就好了</p>
<pre><code class="ini">const args = process.argv.slice(2);
</code></pre>
<h5 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h5><p>返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。</p>
<p>一般我们会在 <code>process.env</code> 上挂载一些变量标识当前的环境。比如最常见的用 <code>process.env.NODE_ENV</code> 区分 <code>development</code> 和 <code>production</code></p>
<p>在 <code>vue-cli</code> 的源码中也经常会看到 <code>process.env.VUE_CLI_DEBUG</code> 标识当前是不是 <code>DEBUG</code> 模式</p>
<h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h5><p>我们知道<code>NodeJs</code>是基于事件轮询，在这个过程中，同一时间只会处理一件事情</p>
<p>在这种处理模式下，<code>process.nextTick()</code>就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行</p>
<p>例如下面例子将一个<code>foo</code>函数在下一个时间点调用</p>
<pre><code class="js">function foo() &#123;
    console.error(&#39;foo&#39;);
&#125;

process.nextTick(foo);
console.error(&#39;bar&#39;);
</code></pre>
<p>输出结果为<code>bar</code>、<code>foo</code></p>
<p>虽然下述方式也能实现同样效果：</p>
<pre><code class="javascript">setTimeout(foo, 0);
console.log(&#39;bar&#39;);
</code></pre>
<p>两者区别在于：</p>
<ul>
<li>process.nextTick()会在这一次event loop的call stack清空后（下一次event loop开始前）再调用callback</li>
<li>setTimeout()是并不知道什么时候call stack清空的，所以何时调用callback函数是不确定的</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-fs模块的理解-有哪些常用方法"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-fs模块的理解-有哪些常用方法" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 fs模块的理解? 有哪些常用方法"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 fs模块的理解? 有哪些常用方法</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>fs（filesystem），该模块提供本地文件的读写能力，基本上是<code>POSIX</code>文件操作命令的简单包装</p>
<p>可以说，所有与文件的操作都是通过<code>fs</code>核心模块实现</p>
<p>导入模块如下：</p>
<pre><code class="ini">const fs = require(&#39;fs&#39;);
</code></pre>
<p>这个模块对所有文件系统操作提供异步（不具有<code>sync</code> 后缀）和同步（具有 <code>sync</code> 后缀）两种操作方式，而供开发者选择</p>
<h4 id="二、文件知识"><a href="#二、文件知识" class="headerlink" title="二、文件知识"></a>二、文件知识</h4><p>在计算机中有关于文件的知识：</p>
<ul>
<li>权限位 mode</li>
<li>标识位 flag</li>
<li>文件描述为 fd</li>
</ul>
<h5 id="权限位-mode"><a href="#权限位-mode" class="headerlink" title="权限位 mode"></a>权限位 mode</h5><p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34663464343161302d633436622d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位4、2、1，不具备权限为0</p>
<p>如在<code>linux</code>查看文件权限位：</p>
<pre><code class="javascript">drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core
-rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md
</code></pre>
<p>在开头前十位中，<code>d</code>为文件夹，<code>-</code>为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限</p>
<h5 id="标识位"><a href="#标识位" class="headerlink" title="标识位"></a>标识位</h5><p>标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读取文件，如果文件不存在则抛出异常。</td>
</tr>
<tr>
<td>r+</td>
<td>读取并写入文件，如果文件不存在则抛出异常。</td>
</tr>
<tr>
<td>rs</td>
<td>读取并写入文件，指示操作系统绕开本地文件系统缓存。</td>
</tr>
<tr>
<td>w</td>
<td>写入文件，文件不存在会被创建，存在则清空后写入。</td>
</tr>
<tr>
<td>wx</td>
<td>写入文件，排它方式打开。</td>
</tr>
<tr>
<td>w+</td>
<td>读取并写入文件，文件不存在则创建文件，存在则清空后写入。</td>
</tr>
<tr>
<td>wx+</td>
<td>和 w+ 类似，排他方式打开。</td>
</tr>
<tr>
<td>a</td>
<td>追加写入，文件不存在则创建文件。</td>
</tr>
<tr>
<td>ax</td>
<td>与 a 类似，排他方式打开。</td>
</tr>
<tr>
<td>a+</td>
<td>读取并追加写入，不存在则创建。</td>
</tr>
<tr>
<td>ax+</td>
<td>与 a+ 类似，排他方式打开。</td>
</tr>
</tbody></table>
<h5 id="文件描述为-fd"><a href="#文件描述为-fd" class="headerlink" title="文件描述为 fd"></a>文件描述为 fd</h5><p>操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件</p>
<p><code>Window </code>系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，<code>NodeJS </code>抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符</p>
<p>在 <code>NodeJS </code>中，每操作一个文件，文件描述符是递增的，文件描述符一般从 <code>3</code> 开始，因为前面有 <code>0</code>、<code>1</code>、<code>2</code>三个比较特殊的描述符，分别代表 <code>process.stdin</code>（标准输入）、<code>process.stdout</code>（标准输出）和 <code>process.stderr</code>（错误输出）</p>
<h4 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h4><p>下面针对<code>fs</code>模块常用的方法进行展开：</p>
<ul>
<li>文件读取</li>
<li>文件写入</li>
<li>文件追加写入</li>
<li>文件拷贝</li>
<li>创建目录</li>
</ul>
<h5 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h5><h6 id="fs-readFileSync"><a href="#fs-readFileSync" class="headerlink" title="fs.readFileSync"></a>fs.readFileSync</h6><p>同步读取，参数如下：</p>
<ul>
<li>第一个参数为读取文件的路径或文件描述符</li>
<li>第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding</li>
</ul>
<p>结果为返回文件的内容</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

let buf = fs.readFileSync(&quot;1.txt&quot;);
let data = fs.readFileSync(&quot;1.txt&quot;, &quot;utf8&quot;);

console.log(buf); // &lt;Buffer 48 65 6c 6c 6f&gt;
console.log(data); // Hello
</code></pre>
<h6 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile"></a>fs.readFile</h6><p>异步读取方法 <code>readFile</code> 与 <code>readFileSync</code> 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 <code>err</code>（错误）和 <code>data</code>（数据），该方法没有返回值，回调函数在读取文件成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.readFile(&quot;1.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
   if(!err)&#123;
       console.log(data); // Hello
   &#125;
&#125;);
</code></pre>
<h5 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h5><h6 id="writeFileSync"><a href="#writeFileSync" class="headerlink" title="writeFileSync"></a>writeFileSync</h6><p>同步写入，有三个参数：</p>
<ul>
<li>第一个参数为写入文件的路径或文件描述符</li>
<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>
<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>
</ul>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.writeFileSync(&quot;2.txt&quot;, &quot;Hello world&quot;);
let data = fs.readFileSync(&quot;2.txt&quot;, &quot;utf8&quot;);

console.log(data); // Hello world
</code></pre>
<h6 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h6><p>异步写入，<code>writeFile</code> 与 <code>writeFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件写入数据成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.writeFile(&quot;2.txt&quot;, &quot;Hello world&quot;, err =&gt; &#123;
    if (!err) &#123;
        fs.readFile(&quot;2.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
            console.log(data); // Hello world
        &#125;);
    &#125;
&#125;);
</code></pre>
<h5 id="文件追加写入"><a href="#文件追加写入" class="headerlink" title="文件追加写入"></a>文件追加写入</h5><h6 id="appendFileSync"><a href="#appendFileSync" class="headerlink" title="appendFileSync"></a>appendFileSync</h6><p>参数如下：</p>
<ul>
<li>第一个参数为写入文件的路径或文件描述符</li>
<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>
<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>
</ul>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.appendFileSync(&quot;3.txt&quot;, &quot; world&quot;);
let data = fs.readFileSync(&quot;3.txt&quot;, &quot;utf8&quot;);
</code></pre>
<h6 id="appendFile"><a href="#appendFile" class="headerlink" title="appendFile"></a>appendFile</h6><p>异步追加写入方法 <code>appendFile</code> 与 <code>appendFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件追加写入数据成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.appendFile(&quot;3.txt&quot;, &quot; world&quot;, err =&gt; &#123;
    if (!err) &#123;
        fs.readFile(&quot;3.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
            console.log(data); // Hello world
        &#125;);
    &#125;
&#125;);
</code></pre>
<h5 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h5><h6 id="copyFileSync"><a href="#copyFileSync" class="headerlink" title="copyFileSync"></a>copyFileSync</h6><p>同步拷贝</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.copyFileSync(&quot;3.txt&quot;, &quot;4.txt&quot;);
let data = fs.readFileSync(&quot;4.txt&quot;, &quot;utf8&quot;);

console.log(data); // Hello world
</code></pre>
<h6 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h6><p>异步拷贝</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.copyFile(&quot;3.txt&quot;, &quot;4.txt&quot;, () =&gt; &#123;
    fs.readFile(&quot;4.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
        console.log(data); // Hello world
    &#125;);
&#125;);
</code></pre>
<h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><h6 id="mkdirSync"><a href="#mkdirSync" class="headerlink" title="mkdirSync"></a>mkdirSync</h6><p>同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常</p>
<pre><code class="javascript">// 假设已经有了 a 文件夹和 a 下的 b 文件夹
fs.mkdirSync(&quot;a/b/c&quot;)
</code></pre>
<h6 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h6><p>异步创建，第二个参数为回调函数</p>
<pre><code class="javascript">fs.mkdir(&quot;a/b/c&quot;, err =&gt; &#123;
    if (!err) console.log(&quot;创建成功&quot;);
&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-Buffer-的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-Buffer-的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 Buffer 的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 Buffer 的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在<code>Node</code>应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而<code>Buffer</code>就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据</p>
<p>在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量</p>
<p>如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理</p>
<p>这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 <code>RAM</code> 中</p>
<p>简单来讲，<code>Nodejs</code>不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在<code>Buffer</code>中，即在<code>RAM</code>中，直至将它们发送完毕</p>
<p>上面讲到了<code>Buffer</code>是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存8位二进制：<code>00000000</code>，也就是一个字节</p>
<p>例如：</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;why&quot;)
</code></pre>
<p>其存储过程如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32303337313235302d633639632d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h4><p><code>Buffer</code> 类在全局作用域中，无须<code>require</code>导入</p>
<p>创建<code>Buffer</code>的方法有很多种，我们讲讲下面的两种常见的形式：</p>
<ul>
<li>Buffer.from()</li>
<li>Buffer.alloc()</li>
</ul>
<h5 id="Buffer-from"><a href="#Buffer-from" class="headerlink" title="Buffer.from()"></a>Buffer.from()</h5><pre><code class="javascript">const b1 = Buffer.from(&#39;10&#39;);
const b2 = Buffer.from(&#39;10&#39;, &#39;utf8&#39;);
const b3 = Buffer.from([10]);
const b4 = Buffer.from(b3);

console.log(b1, b2, b3, b4); // &lt;Buffer 31 30&gt; &lt;Buffer 31 30&gt; &lt;Buffer 0a&gt; &lt;Buffer 0a&gt;
</code></pre>
<h5 id="Buffer-alloc"><a href="#Buffer-alloc" class="headerlink" title="Buffer.alloc()"></a>Buffer.alloc()</h5><pre><code class="javascript">const bAlloc1 = Buffer.alloc(10); // 创建一个大小为 10 个字节的缓冲区
const bAlloc2 = Buffer.alloc(10, 1); // 建一个长度为 10 的 Buffer,其中全部填充了值为 `1` 的字节
console.log(bAlloc1); // &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;
console.log(bAlloc2); // &lt;Buffer 01 01 01 01 01 01 01 01 01 01&gt;
</code></pre>
<p>在上面创建<code>buffer</code>后，则能够<code>toString</code>的形式进行交互，默认情况下采取<code>utf8</code>字符编码形式，如下</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;你好&quot;);
console.log(buffer);
// &lt;Buffer e4 bd a0 e5 a5 bd&gt;
const str = buffer.toString();
console.log(str);
// 你好
</code></pre>
<p>如果编码与解码不是相同的格式则会出现乱码的情况，如下：</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;你好&quot;,&quot;utf-8 &quot;);
console.log(buffer);
// &lt;Buffer e4 bd a0 e5 a5 bd&gt;
const str = buffer.toString(&quot;ascii&quot;);
console.log(str); 
// d= e%=
</code></pre>
<p>当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下：</p>
<pre><code class="javascript">const buf = Buffer.from(&#39;Node.js 技术栈&#39;, &#39;UTF-8&#39;);

console.log(buf)          // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;
console.log(buf.length)   // 17

console.log(buf.toString(&#39;UTF-8&#39;, 0, 9))  // Node.js �
console.log(buf.toString(&#39;UTF-8&#39;, 0, 11)) // Node.js 技
</code></pre>
<p>所支持的字符集有如下：</p>
<ul>
<li>ascii：仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的</li>
<li>utf8：多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8</li>
<li>utf16le：2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000至 U+10FFFF）</li>
<li>ucs2，utf16le 的别名</li>
<li>base64：Base64 编码</li>
<li>latin：一种把 Buffer 编码成一字节编码的字符串的方式</li>
<li>binary：latin1 的别名，</li>
<li>hex：将每个字节编码为两个十六进制字符</li>
</ul>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p><code>Buffer</code>的应用场景常常与流的概念联系在一起，例如有如下：</p>
<ul>
<li>I&#x2F;O操作</li>
<li>加密解密</li>
<li>zlib.js</li>
</ul>
<h5 id="I-x2F-O操作"><a href="#I-x2F-O操作" class="headerlink" title="I&#x2F;O操作"></a>I&#x2F;O操作</h5><p>通过流的形式，将一个文件的内容读取到另外一个文件</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;);

const inputStream = fs.createReadStream(&#39;input.txt&#39;); // 创建可读流
const outputStream = fs.createWriteStream(&#39;output.txt&#39;); // 创建可写流

inputStream.pipe(outputStream); // 管道读写
</code></pre>
<h5 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h5><p>在一些加解密算法中会遇到使用 <code>Buffer</code>，例如 <code>crypto.createCipheriv</code> 的第二个参数 <code>key</code> 为 <code>string</code> 或 <code>Buffer</code> 类型</p>
<h5 id="zlib-js"><a href="#zlib-js" class="headerlink" title="zlib.js"></a>zlib.js</h5><p><code>zlib.js</code> 为 <code>Node.js</code> 的核心库之一，其利用了缓冲区（<code>Buffer</code>）的功能来操作二进制数据流，提供了压缩或解压功能</p>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-Stream-的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-Stream-的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 Stream 的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 Stream 的理解？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>流（Stream），是一个数据传输手段，是端到端信息交换的一种方式，而且是有顺序的,是逐块读取数据、处理内容，用于顺序读取输入或写入输出</p>
<p><code>Node.js</code>中很多对象都实现了流，总之它是会冒数据（以 <code>Buffer</code> 为单位）</p>
<p>它的独特之处在于，它不像传统的程序那样一次将一个文件读入内存，而是逐块读取数据、处理其内容，而不是将其全部保存在内存中</p>
<p>流可以分成三部分：<code>source</code>、<code>dest</code>、<code>pipe</code></p>
<p>在<code>source</code>和<code>dest</code>之间有一个连接的管道<code>pipe</code>,它的基本语法是<code>source.pipe(dest)</code>，<code>source</code>和<code>dest</code>就是通过pipe连接，让数据从<code>source</code>流向了<code>dest</code>，如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61656330353637302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、种类"><a href="#二、种类" class="headerlink" title="二、种类"></a>二、种类</h4><p>在<code>NodeJS</code>，几乎所有的地方都使用到了流的概念，分成四个种类：</p>
<ul>
<li>可写流：可写入数据的流。例如 fs.createWriteStream() 可以使用流将数据写入文件</li>
<li>可读流： 可读取数据的流。例如fs.createReadStream() 可以从文件读取内容</li>
<li>双工流： 既可读又可写的流。例如 net.Socket</li>
<li>转换流： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据</li>
</ul>
<p>在<code>NodeJS</code>中<code>HTTP</code>服务器模块中，<code>request</code> 是可读流，<code>response</code> 是可写流。还有<code>fs</code> 模块，能同时处理可读和可写文件流</p>
<p>可读流和可写流都是单向的，比较容易理解，而另外两个是双向的</p>
<h5 id="双工流"><a href="#双工流" class="headerlink" title="双工流"></a>双工流</h5><p>之前了解过<code>websocket</code>通信，是一个全双工通信，发送方和接受方都是各自独立的方法，发送和接收都没有任何关系</p>
<p>如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62376163366430302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>基本代码如下：</p>
<pre><code class="javascript">const &#123; Duplex &#125; = require(&#39;stream&#39;);

const myDuplex = new Duplex(&#123;
  read(size) &#123;
    // ...
  &#125;,
  write(chunk, encoding, callback) &#123;
    // ...
  &#125;
&#125;);
</code></pre>
<h5 id="双工流-1"><a href="#双工流-1" class="headerlink" title="双工流"></a>双工流</h5><p>双工流的演示图如下所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63303238383362302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>除了上述压缩包的例子，还比如一个 <code>babel</code>，把<code>es6</code>转换为，我们在左边写入 <code>es6</code>，从右边读取 <code>es5</code></p>
<p>基本代码如下所示：</p>
<pre><code class="javascript">const &#123; Transform &#125; = require(&#39;stream&#39;);

const myTransform = new Transform(&#123;
  transform(chunk, encoding, callback) &#123;
    // ...
  &#125;
&#125;);
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p><code>stream</code>的应用场景主要就是处理<code>IO</code>操作，而<code>http</code>请求和文件操作都属于<code>IO</code>操作</p>
<p>思想一下，如果一次<code>IO</code>操作过大，硬件的开销就过大，而将此次大的<code>IO</code>操作进行分段操作，让数据像水管一样流动，知道流动完成</p>
<p>常见的场景有：</p>
<ul>
<li>get请求返回文件给客户端</li>
<li>文件操作</li>
<li>一些打包工具的底层操作</li>
</ul>
<h5 id="get请求返回文件给客户端"><a href="#get请求返回文件给客户端" class="headerlink" title="get请求返回文件给客户端"></a>get请求返回文件给客户端</h5><p>使用<code>stream</code>流返回文件，<code>res</code>也是一个<code>stream</code>对象，通过<code>pipe</code>管道将文件数据返回</p>
<pre><code class="javascript">const server = http.createServer(function (req, res) &#123;
    const method = req.method; // 获取请求方法
    if (method === &#39;GET&#39;) &#123; // get 请求
        const fileName = path.resolve(__dirname, &#39;data.txt&#39;);
        let stream = fs.createReadStream(fileName);
        stream.pipe(res); // 将 res 作为 stream 的 dest
    &#125;
&#125;);
server.listen(8000);
</code></pre>
<h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><p>创建一个可读数据流<code>readStream</code>，一个可写数据流<code>writeStream</code>，通过<code>pipe</code>管道把数据流转过去</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;)
const path = require(&#39;path&#39;)

// 两个文件名
const fileName1 = path.resolve(__dirname, &#39;data.txt&#39;)
const fileName2 = path.resolve(__dirname, &#39;data-bak.txt&#39;)
// 读取文件的 stream 对象
const readStream = fs.createReadStream(fileName1)
// 写入文件的 stream 对象
const writeStream = fs.createWriteStream(fileName2)
// 通过 pipe执行拷贝，数据流转
readStream.pipe(writeStream)
// 数据读取完成监听，即拷贝完成
readStream.on(&#39;end&#39;, function () &#123;
    console.log(&#39;拷贝完成&#39;)
&#125;)
</code></pre>
<h5 id="一些打包工具的底层操作"><a href="#一些打包工具的底层操作" class="headerlink" title="一些打包工具的底层操作"></a>一些打包工具的底层操作</h5><p>目前一些比较火的前端打包构建工具，都是通过<code>node.js</code>编写的，打包和构建的过程肯定是文件频繁操作的过程，离不来<code>stream</code>，如<code>gulp</code></p>
<h3 id="♥︎-♥︎-♥︎-说说Node中的EventEmitter-如何实现一个EventEmitter"><a href="#♥︎-♥︎-♥︎-说说Node中的EventEmitter-如何实现一个EventEmitter" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说Node中的EventEmitter? 如何实现一个EventEmitter?"></a>♥︎ ♥︎ ♥︎ 说说Node中的EventEmitter? 如何实现一个EventEmitter?</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>我们了解到，<code>Node </code>采用了事件驱动机制，而<code>EventEmitter </code>就是<code>Node</code>实现事件驱动的基础</p>
<p>在<code>EventEmitter</code>的基础上，<code>Node </code>几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作</p>
<p><code>Node.js</code> 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件</p>
<p>这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上</p>
<h4 id="二、使用方法-1"><a href="#二、使用方法-1" class="headerlink" title="二、使用方法"></a>二、使用方法</h4><p><code>Node </code>的<code>events</code>模块只提供了一个<code>EventEmitter</code>类，这个类实现了<code>Node</code>异步事件驱动架构的基本模式——观察者模式</p>
<p>在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们</p>
<p>基本代码如下所示：</p>
<pre><code class="javascript">const EventEmitter = require(&#39;events&#39;)

class MyEmitter extends EventEmitter &#123;&#125;
const myEmitter = new MyEmitter()

function callback() &#123;
    console.log(&#39;触发了event事件！&#39;)
&#125;
myEmitter.on(&#39;event&#39;, callback)
myEmitter.emit(&#39;event&#39;)
myEmitter.removeListener(&#39;event&#39;, callback);
</code></pre>
<p>通过实例对象的<code>on</code>方法注册一个名为<code>event</code>的事件，通过<code>emit</code>方法触发该事件，而<code>removeListener</code>用于取消事件的监听</p>
<p>关于其常见的方法如下：</p>
<ul>
<li>emitter.addListener&#x2F;on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部</li>
<li>emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部</li>
<li>emitter.emit(eventName[, …args])：触发类型为 eventName 的监听事件</li>
<li>emitter.removeListener&#x2F;off(eventName, listener)：移除类型为 eventName 的监听事件</li>
<li>emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除</li>
<li>emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件</li>
</ul>
<h4 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h4><p>通过上面的方法了解，<code>EventEmitter</code>是一个构造函数，内部存在一个包含所有事件的对象</p>
<pre><code class="javascript">class EventEmitter &#123;
    constructor() &#123;
        this.events = &#123;&#125;;
    &#125;
&#125;
</code></pre>
<p>其中<code>events</code>存放的监听事件的函数的结构如下：</p>
<pre><code class="javascript">&#123;
  &quot;event1&quot;: [f1,f2,f3]，
  &quot;event2&quot;: [f4,f5]，
  ...
&#125;
</code></pre>
<p>然后开始一步步实现实例方法，首先是<code>emit</code>，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：</p>
<pre><code class="javascript">emit(type, ...args) &#123;
    this.events[type].forEach((item) =&gt; &#123;
        Reflect.apply(item, this, args);
    &#125;);
&#125;
</code></pre>
<p>当实现了<code>emit</code>方法之后，然后实现<code>on</code>、<code>addListener</code>、<code>prependListener</code>这三个实例方法，都是添加事件监听触发函数，实现也是大同小异</p>
<pre><code class="javascript">on(type, handler) &#123;
    if (!this.events[type]) &#123;
        this.events[type] = [];
    &#125;
    this.events[type].push(handler);
&#125;

addListener(type,handler)&#123;
    this.on(type,handler)
&#125;

prependListener(type, handler) &#123;
    if (!this.events[type]) &#123;
        this.events[type] = [];
    &#125;
    this.events[type].unshift(handler);
&#125;
</code></pre>
<p>紧接着就是实现事件监听的方法<code>removeListener/on</code></p>
<pre><code class="javascript">removeListener(type, handler) &#123;
    if (!this.events[type]) &#123;
        return;
    &#125;
    this.events[type] = this.events[type].filter(item =&gt; item !== handler);
&#125;

off(type,handler)&#123;
    this.removeListener(type,handler)
&#125;
</code></pre>
<p>最后再来实现<code>once</code>方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过<code>fired</code>属性值判断事件函数是否执行过</p>
<pre><code class="javascript">once(type, handler) &#123;
    this.on(type, this._onceWrap(type, handler, this));
  &#125;

  _onceWrap(type, handler, target) &#123;
    const state = &#123; fired: false, handler, type , target&#125;;
    const wrapFn = this._onceWrapper.bind(state);
    state.wrapFn = wrapFn;
    return wrapFn;
  &#125;

  _onceWrapper(...args) &#123;
    if (!this.fired) &#123;
      this.fired = true;
      Reflect.apply(this.handler, this.target, args);
      this.target.off(this.type, this.wrapFn);
    &#125;
 &#125;
</code></pre>
<p>完整代码如下：</p>
<pre><code class="javascript">class EventEmitter &#123;
    constructor() &#123;
        this.events = &#123;&#125;;
    &#125;

    on(type, handler) &#123;
        if (!this.events[type]) &#123;
            this.events[type] = [];
        &#125;
        this.events[type].push(handler);
    &#125;

    addListener(type,handler)&#123;
        this.on(type,handler)
    &#125;

    prependListener(type, handler) &#123;
        if (!this.events[type]) &#123;
            this.events[type] = [];
        &#125;
        this.events[type].unshift(handler);
    &#125;

    removeListener(type, handler) &#123;
        if (!this.events[type]) &#123;
            return;
        &#125;
        this.events[type] = this.events[type].filter(item =&gt; item !== handler);
    &#125;

    off(type,handler)&#123;
        this.removeListener(type,handler)
    &#125;

    emit(type, ...args) &#123;
        this.events[type].forEach((item) =&gt; &#123;
            Reflect.apply(item, this, args);
        &#125;);
    &#125;

    once(type, handler) &#123;
        this.on(type, this._onceWrap(type, handler, this));
    &#125;

    _onceWrap(type, handler, target) &#123;
        const state = &#123; fired: false, handler, type , target&#125;;
        const wrapFn = this._onceWrapper.bind(state);
        state.wrapFn = wrapFn;
        return wrapFn;
    &#125;

    _onceWrapper(...args) &#123;
        if (!this.fired) &#123;
            this.fired = true;
            Reflect.apply(this.handler, this.target, args);
            this.target.off(this.type, this.wrapFn);
        &#125;
    &#125;
&#125;
</code></pre>
<p>测试代码如下：</p>
<pre><code class="javascript">const ee = new EventEmitter();// 注册所有事件ee.once(&#39;wakeUp&#39;, (name) =&gt; &#123; console.log(`$&#123;name&#125; 1`); &#125;);ee.on(&#39;e
</code></pre>
<h3 id="♥︎-♥︎-♥︎-说说-Node-文件查找的优先级以及-Require-方法的文件查找策略"><a href="#♥︎-♥︎-♥︎-说说-Node-文件查找的优先级以及-Require-方法的文件查找策略" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?"></a>♥︎ ♥︎ ♥︎ 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?</h3><h4 id="一、模块规范"><a href="#一、模块规范" class="headerlink" title="一、模块规范"></a>一、模块规范</h4><p><code>NodeJS</code>对<code>CommonJS</code>进行了支持和实现，让我们在开发<code>node</code>的过程中可以方便的进行模块化开发：</p>
<ul>
<li>在Node中每一个js文件都是一个单独的模块</li>
<li>模块中包括CommonJS规范的核心变量：exports、module.exports、require</li>
<li>通过上述变量进行模块化开发</li>
</ul>
<p>而模块化的核心是导出与导入，在<code>Node</code>中通过<code>exports</code>与<code>module.exports</code>负责对模块中的内容进行导出，通过<code>require</code>函数导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</p>
<h4 id="二、查找策略"><a href="#二、查找策略" class="headerlink" title="二、查找策略"></a>二、查找策略</h4><p><code>require</code>方法接收一下几种参数的传递：</p>
<ul>
<li>原生模块：http、fs、path等</li>
<li>相对路径的文件模块：.&#x2F;mod或..&#x2F;mod</li>
<li>绝对路径的文件模块：&#x2F;pathtomodule&#x2F;mod</li>
<li>目录作为模块：.&#x2F;dirname</li>
<li>非原生模块的文件模块：mod</li>
</ul>
<p><code>require</code>参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33336165386566302d633962612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会优先从缓存中加载已经存在的模块</p>
<h5 id="原生模块"><a href="#原生模块" class="headerlink" title="原生模块"></a>原生模块</h5><p>而像原生模块这些，通过<code>require </code>方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载</p>
<h5 id="绝对路径、相对路径"><a href="#绝对路径、相对路径" class="headerlink" title="绝对路径、相对路径"></a>绝对路径、相对路径</h5><p>如果<code>require</code>绝对路径的文件，则直接查找对应的路径，速度最快</p>
<p>相对路径的模块则相对于当前调用<code>require</code>的文件去查找</p>
<p>如果按确切的文件名没有找到模块，则 <code>NodeJs</code> 会尝试带上 <code>.js</code>、<code>.json </code>或 <code>.node </code>拓展名再加载</p>
<h5 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h5><p>默认情况是根据根目录中<code>package.json</code>文件的<code>main</code>来指定目录模块，如：</p>
<pre><code class="javascript">&#123; &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;main.js&quot; &#125;
</code></pre>
<p>如果这是在<code>./some-library node_modules</code>目录中，则 <code>require(&#39;./some-library&#39;)</code> 会试图加载 <code>./some-library/main.js</code></p>
<p>如果目录里没有 <code>package.json</code>文件，或者 <code>main</code>入口不存在或无法解析，则会试图加载目录下的 <code>index.js</code> 或 <code>index.node</code> 文件</p>
<h5 id="非原生模块"><a href="#非原生模块" class="headerlink" title="非原生模块"></a>非原生模块</h5><p>在每个文件中都存在<code>module.paths</code>，表示模块的搜索路径，<code>require</code>就是根据其来寻找文件</p>
<p>在<code>window</code>下输出如下：</p>
<pre><code class="javascript">[ &#39;c:\\nodejs\\node_modules&#39;,
&#39;c:\\node_modules&#39; ]
</code></pre>
<p>可以看出<code>module path</code>的生成规则为：从当前文件目录开始查找<code>node_modules</code>目录；然后依次进入父目录，查找父目录下的<code>node_modules</code>目录，依次迭代，直到根目录下的<code>node_modules</code>目录</p>
<p>当都找不到的时候，则会从系统<code>NODE_PATH</code>环境变量查找</p>
<h5 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h5><p>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ul>
<li>&#x2F;home&#x2F;ry&#x2F;projects&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;home&#x2F;ry&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;home&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;node_modules&#x2F;bar.js</li>
</ul>
<p>这使得程序本地化它们的依赖，避免它们产生冲突</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面模块的文件查找策略之后，总结下文件查找的优先级：</p>
<ul>
<li>缓存的模块优先级最高</li>
<li>如果是内置模块，则直接返回，优先级仅次缓存的模块</li>
<li>如果是绝对路径 &#x2F; 开头，则从根目录找</li>
<li>如果是相对路径 .&#x2F;开头，则从当前require文件相对位置找</li>
<li>如果文件没有携带后缀，先从js、json、node按顺序查找</li>
<li>如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js</li>
<li>如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何实现jwt鉴权机制？说说你的思路"><a href="#♥︎-♥︎-♥︎-如何实现jwt鉴权机制？说说你的思路" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何实现jwt鉴权机制？说说你的思路"></a>♥︎ ♥︎ ♥︎ 如何实现jwt鉴权机制？说说你的思路</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>JWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30353239303463302d636438392d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在目前前后端分离的开发过程中，使用<code>token</code>鉴权机制用于身份验证是最常见的方案，流程如下：</p>
<ul>
<li>服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证</li>
<li>后续访问会根据这个令牌判断用户时候有权限进行访问</li>
</ul>
<p><code>Token</code>，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以<code>.</code>进行拼接。其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31313735663939302d636438392d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="header"><a href="#header" class="headerlink" title="header"></a>header</h5><p>每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为<code>alg</code>，同时还有一个<code>typ</code>的字段，默认<code>JWT</code>即可。以下示例中算法为HS256</p>
<pre><code class="javascript">&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot; &#125; 
</code></pre>
<p>因为JWT是字符串，所以我们还需要对以上内容进行Base64编码，编码后字符串如下：</p>
<pre><code class="ini">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9        
</code></pre>
<h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p>载荷即消息体，这里会存放实际的内容，也就是<code>Token</code>的数据声明，例如用户的<code>id</code>和<code>name</code>，默认情况下也会携带令牌的签发时间<code>iat</code>，通过还可以设置过期时间，如下：</p>
<pre><code class="javascript">&#123;
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;iat&quot;: 1516239022
&#125;
</code></pre>
<p>同样进行Base64编码后，字符串如下：</p>
<pre><code class="ini">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
</code></pre>
<h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>签名是对头部和载荷内容进行签名，一般情况，设置一个<code>secretKey</code>，对前两个的结果进行<code>HMACSHA25</code>算法，公式如下：</p>
<pre><code class="javascript">Signature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)
</code></pre>
<p>一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致</p>
<h4 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p><code>Token</code>的使用分成了两部分：</p>
<ul>
<li>生成token：登录成功的时候，颁发token</li>
<li>验证token：访问某些资源或者接口时，验证token</li>
</ul>
<h5 id="生成-token"><a href="#生成-token" class="headerlink" title="生成 token"></a>生成 token</h5><p>借助第三方库<code>jsonwebtoken</code>，通过<code>jsonwebtoken</code> 的 <code>sign</code> 方法生成一个 <code>token</code>：</p>
<ul>
<li>第一个参数指的是 Payload</li>
<li>第二个是秘钥，服务端特有</li>
<li>第三个参数是 option，可以定义 token 过期时间</li>
</ul>
<pre><code class="javascript">const crypto = require(&quot;crypto&quot;),
  jwt = require(&quot;jsonwebtoken&quot;);
// TODO:使用数据库
// 这里应该是用数据库存储，这里只是演示用
let userList = [];

class UserController &#123;
  // 用户登录
  static async login(ctx) &#123;
    const data = ctx.request.body;
    if (!data.name || !data.password) &#123;
      return ctx.body = &#123;
        code: &quot;000002&quot;, 
        message: &quot;参数不合法&quot;
      &#125;
    &#125;
    const result = userList.find(item =&gt; item.name === data.name &amp;&amp; item.password === crypto.createHash(&#39;md5&#39;).update(data.password).digest(&#39;hex&#39;))
    if (result) &#123;
      // 生成token
      const token = jwt.sign(  
        &#123;
          name: result.name
        &#125;,
        &quot;test_token&quot;, // secret
        &#123; expiresIn: 60 * 60 &#125; // 过期时间：60 * 60 s
      );
      return ctx.body = &#123;
        code: &quot;0&quot;,
        message: &quot;登录成功&quot;,
        data: &#123;
          token
        &#125;
      &#125;;
    &#125; else &#123;
      return ctx.body = &#123;
        code: &quot;000002&quot;,
        message: &quot;用户名或密码错误&quot;
      &#125;;
    &#125;
  &#125;
&#125;

module.exports = UserController;
</code></pre>
<p>在前端接收到<code>token</code>后，一般情况会通过<code>localStorage</code>进行缓存，然后将<code>token</code>放到<code>HTTP </code>请求头<code>Authorization</code> 中，关于<code>Authorization</code> 的设置，前面要加上 Bearer ，注意后面带有空格</p>
<pre><code class="javascript">axios.interceptors.request.use(config =&gt; &#123;
  const token = localStorage.getItem(&#39;token&#39;);
  config.headers.common[&#39;Authorization&#39;] = &#39;Bearer &#39; + token; // 留意这里的 Authorization
  return config;
&#125;)
</code></pre>
<h5 id="校验token"><a href="#校验token" class="headerlink" title="校验token"></a>校验token</h5><p>使用 <code>koa-jwt</code> 中间件进行验证，方式比较简单</p>
<pre><code class="javascript">/ 注意：放在路由前面
app.use(koajwt(&#123;
  secret: &#39;test_token&#39;
&#125;).unless(&#123; // 配置白名单
  path: [/\/api\/register/, /\/api\/login/]
&#125;))
</code></pre>
<ul>
<li>secret 必须和 sign 时候保持一致</li>
<li>可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆&#x2F;注册都可以不用校验</li>
<li>校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验</li>
</ul>
<p>获取<code>token</code>用户的信息方法如下：</p>
<pre><code class="javascript">router.get(&#39;/api/userInfo&#39;,async (ctx,next) =&gt;&#123;    const authorization =  ctx.header.authorization // 获取jwt    const token = authorization.replace(&#39;Beraer &#39;,&#39;&#39;)    const result = jwt.verify(token,&#39;test_token&#39;)    ctx.body = result
</code></pre>
<p>注意：上述的<code>HMA256</code>加密算法为单秘钥的形式，一旦泄露后果非常的危险</p>
<p>在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌</p>
<p>这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择<code>RS256</code></p>
<h4 id="三、优缺点"><a href="#三、优缺点" class="headerlink" title="三、优缺点"></a>三、优缺点</h4><p>优点：</p>
<ul>
<li>json具有通用性，所以可以跨语言</li>
<li>组成简单，字节占用小，便于传输</li>
<li>服务端无需保存会话信息，很容易进行水平扩展</li>
<li>一处生成，多处使用，可以在分布式系统中，解决单点登录问题</li>
<li>可防护CSRF攻击</li>
</ul>
<p>缺点：</p>
<ul>
<li>payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息</li>
<li>需要保护好加密密钥，一旦泄露后果不堪设想</li>
<li>为避免token被劫持，最好使用https协议</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何实现文件上传？说说你的思路"><a href="#♥︎-♥︎-♥︎-如何实现文件上传？说说你的思路" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何实现文件上传？说说你的思路"></a>♥︎ ♥︎ ♥︎ 如何实现文件上传？说说你的思路</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能</p>
<p>因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里</p>
<p>对于文件上传，我们需要设置请求头为<code>content-type:multipart/form-data</code></p>
<blockquote>
<p>multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件</p>
</blockquote>
<p>结构如下：</p>
<pre><code class="http">POST /t2/upload.do HTTP/1.1
User-Agent: SOHUWapRebot
Accept-Language: zh-cn,zh;q=0.5
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Content-Length: 60408
Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Host: w.sohu.com

--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data; name=&quot;city&quot;

Santa colo
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name=&quot;desc&quot;
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
 
...
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name=&quot;pic&quot;; filename=&quot;photo.jpg&quot;
Content-Type: application/octet-stream
Content-Transfer-Encoding: binary
 
... binary data of the jpg ...
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--
</code></pre>
<p><code>boundary</code>表示分隔符，如果要上传多个表单项，就要使用<code>boundary</code>分割，每个表单项由<code>———XXX</code>开始，以<code>———XXX</code>结尾</p>
<p>而<code>xxx</code>是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现</p>
<p>每个表单项必须包含一个 <code>Content-Disposition</code> 头，其他的头信息则为可选项， 比如 <code>Content-Type</code></p>
<p><code>Content-Disposition</code> 包含了 <code>type </code>和 一个名字为<code>name</code>的 <code>parameter</code>，<code>type</code> 是 <code>form-data</code>，<code>name </code>参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 <code>filename </code>参数，值就是文件名</p>
<pre><code class="javascript">Content-Disposition: form-data; name=&quot;user&quot;; filename=&quot;logo.png&quot;
</code></pre>
<p>至于使用<code>multipart/form-data</code>，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高</p>
<h4 id="二、如何实现-1"><a href="#二、如何实现-1" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>关于文件的上传的上传，我们可以分成两步骤：</p>
<ul>
<li>文件的上传</li>
<li>文件的解析</li>
</ul>
<h5 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h5><p>传统前端文件上传的表单结构如下：</p>
<pre><code class="html">&lt;form action=&quot;http://localhost:8080/api/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; value=&quot;&quot; multiple=&quot;multiple&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;
action` 就是我们的提交到的接口，`enctype=&quot;multipart/form-data&quot;` 就是指定上传文件格式，`input` 的 `name` 属性一定要等于`file
</code></pre>
<h5 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h5><p>在服务器中，这里采用<code>koa2</code>中间件的形式解析上传的文件数据，分别有下面两种形式：</p>
<ul>
<li>koa-body</li>
<li>koa-multer</li>
</ul>
<h5 id="koa-body"><a href="#koa-body" class="headerlink" title="koa-body"></a>koa-body</h5><p>安装依赖</p>
<pre><code class="nginx">npm install koa-body
</code></pre>
<p>引入<code>koa-body</code>中间件</p>
<pre><code class="javascript">const koaBody = require(&#39;koa-body&#39;);
app.use(koaBody(&#123;
    multipart: true,
    formidable: &#123;
        maxFileSize: 200*1024*1024    // 设置上传文件大小最大限制，默认2M
    &#125;
&#125;));
</code></pre>
<p>获取上传的文件</p>
<pre><code class="javascript">const file = ctx.request.files.file; // 获取上传文件
</code></pre>
<p>获取文件数据后，可以通过<code>fs</code>模块将文件保存到指定目录</p>
<pre><code class="javascript">router.post(&#39;/uploadfile&#39;, async (ctx, next) =&gt; &#123;
  // 上传单个文件
  const file = ctx.request.files.file; // 获取上传文件
  // 创建可读流
  const reader = fs.createReadStream(file.path);
  let filePath = path.join(__dirname, &#39;public/upload/&#39;) + `/$&#123;file.name&#125;`;
  // 创建可写流
  const upStream = fs.createWriteStream(filePath);
  // 可读流通过管道写入可写流
  reader.pipe(upStream);
  return ctx.body = &quot;上传成功！&quot;;
&#125;);
</code></pre>
<h5 id="koa-multer"><a href="#koa-multer" class="headerlink" title="koa-multer"></a>koa-multer</h5><p>安装依赖：</p>
<pre><code class="ini">npm install koa-multer
</code></pre>
<p>使用 <code>multer</code> 中间件实现文件上传</p>
<pre><code class="javascript">const storage = multer.diskStorage(&#123;  destination: (req, file, cb) =&gt; &#123;    cb(null, &quot;./upload/&quot;)  &#125;,  filename: (req, file, cb) =&gt; &#123;    cb(null, Date.now() + path.extname(file.originalname))  &#125;&#125;)
const upload = multer(&#123;  storage&#125;);
const fileRouter = new Router();
fileRouter.post(&quot;/upload&quot;, upload.single(&#39;file&#39;), (ctx, next) =&gt; &#123;  console.log(ctx.req.file); // 获取文件&#125;)app.use(fileRouter.routes());
</code></pre>
<h3 id="♥︎-♥︎-♥︎-如果让你来设计一个分页功能-你会怎么设计-前后端如何交互"><a href="#♥︎-♥︎-♥︎-如果让你来设计一个分页功能-你会怎么设计-前后端如何交互" class="headerlink" title="♥︎ ♥︎ ♥︎ 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?"></a>♥︎ ♥︎ ♥︎ 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在我们做数据查询的时候，如果数据量很大，比如几万条数据，放在一个页面显示的话显然不友好，这时候就需要采用分页显示的形式，如每次只显示10条数据</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36303730653863302d636631342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>要实现分页功能，实际上就是从结果集中显示第1<del>10条记录作为第1页,显示第11</del>20条记录作为第2页，以此类推</p>
<p>因此，分页实际上就是从结果集中截取出第M~N条记录</p>
<h4 id="二、如何实现-2"><a href="#二、如何实现-2" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>前端实现分页功能，需要后端返回必要的数据，如总的页数，总的数据量，当前页，当前的数据</p>
<pre><code class="javascript">&#123;
 &quot;totalCount&quot;: 1836,   // 总的条数
 &quot;totalPages&quot;: 92,  // 总页数
 &quot;currentPage&quot;: 1   // 当前页数
 &quot;data&quot;: [     // 当前页的数据
   &#123;
 ...
   &#125;
]
</code></pre>
<p>后端采用<code>mysql</code>作为数据的持久性存储</p>
<p>前端向后端发送目标的页码<code>page</code>以及每页显示数据的数量<code>pageSize</code>，默认情况每次取10条数据，则每一条数据的起始位置<code>start</code>为：</p>
<pre><code class="javascript">const start = (page - 1) * pageSize
</code></pre>
<p>当确定了<code>limit</code>和<code>start</code>的值后，就能够确定<code>SQL</code>语句：</p>
<pre><code class="javascript">const sql = `SELECT * FROM record limit $&#123;pageSize&#125; OFFSET $&#123;start&#125;;`
</code></pre>
<p>上诉<code>SQL</code>语句表达的意思为：截取从<code>start</code>到<code>start</code>+<code>pageSize</code>之间（左闭右开）的数据</p>
<p>关于查询数据总数的<code>SQL</code>语句为，<code>record</code>为表名：</p>
<pre><code class="javascript">SELECT COUNT(*) FROM record
</code></pre>
<p>因此后端的处理逻辑为：</p>
<ul>
<li>获取用户参数页码数page和每页显示的数目 pageSize ，其中page 是必须传递的参数，pageSize为可选参数，默认为10</li>
<li>编写 SQL 语句，利用 limit 和 OFFSET 关键字进行分页查询</li>
<li>查询数据库，返回总数据量、总页数、当前页、当前页数据给前端</li>
</ul>
<p>代码如下所示：</p>
<pre><code class="javascript">router.all(&#39;/api&#39;, function (req, res, next) &#123;
  var param = &#39;&#39;;
  // 获取参数
  if (req.method == &quot;POST&quot;) &#123;
    param = req.body;
  &#125; else &#123;
    param = req.query || req.params;
  &#125;
  if (param.page == &#39;&#39; || param.page == null || param.page == undefined) &#123;
    res.end(JSON.stringify(&#123; msg: &#39;请传入参数page&#39;, status: &#39;102&#39; &#125;));
    return;
  &#125;
  const pageSize = param.pageSize || 10;
  const start = (param.page - 1) * pageSize;
  const sql = `SELECT * FROM record limit $&#123;pageSize&#125; OFFSET $&#123;start&#125;;`
  pool.getConnection(function (err, connection) &#123;
    if (err) throw err;
    connection.query(sql, function (err, results) &#123;
      connection.release();
      if (err) &#123;
        throw err
      &#125; else &#123;
        // 计算总页数
        var allCount = results[0][0][&#39;COUNT(*)&#39;];
        var allPage = parseInt(allCount) / 20;
        var pageStr = allPage.toString();
        // 不能被整除
        if (pageStr.indexOf(&#39;.&#39;) &gt; 0) &#123;
          allPage = parseInt(pageStr.split(&#39;.&#39;)[0]) + 1;
        &#125;
        var list = results[1];
        res.end(JSON.stringify(&#123; msg: &#39;操作成功&#39;, status: &#39;200&#39;, totalPages: allPage, currentPage: param.page, totalCount: allCount, data: list &#125;));
      &#125;
    &#125;)
  &#125;)
&#125;);
</code></pre>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面的分析，可以看到分页查询的关键在于，要首先确定每页显示的数量<code>pageSize</code>，然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p>
<ul>
<li>LIMIT 总是设定为 pageSize</li>
<li>OFFSET 计算公式为 pageSize * (pageIndex - 1)</li>
</ul>
<p>确定了这两个值，就能查询出第 <code>N</code>页的数据</p>
<hr>
<h3 id="♥︎-♥︎-♥︎-♥︎-koa-中间件的实现原理"><a href="#♥︎-♥︎-♥︎-♥︎-koa-中间件的实现原理" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎  koa 中间件的实现原理"></a>♥︎ ♥︎ ♥︎ ♥︎  koa 中间件的实现原理</h3><p>每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next 函数。只要调用 next函数，就可以把执行权转交给下一个中间件。</p>
<p>如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。</p>
<p>多个中间件会形成一个栈结构，以“先进后出”的顺序执行。整个过程就像，先是入栈，然后出栈的操作。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-图片上传到服务器的过程"><a href="#♥︎-♥︎-♥︎-♥︎-图片上传到服务器的过程" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 图片上传到服务器的过程"></a>♥︎ ♥︎ ♥︎ ♥︎ 图片上传到服务器的过程</h3><h4 id="前端业务"><a href="#前端业务" class="headerlink" title="前端业务"></a>前端业务</h4><p>根据后台接口发送请求，图片作为参数，需要带上一个 name 字段</p>
<h4 id="后台业务"><a href="#后台业务" class="headerlink" title="后台业务"></a>后台业务</h4><p>后台接收图片可以使用 ndoe 的 fs、path 文件系统加上 multer 的 npm 包实现。主要思想是通过multer 创建一个临时空间用来接收并存储前端发送过来的二进制图片数据。通过 fs 模块读取临时空间的数据，并使用 pipe 方法注入到 fs 模块创建 path 模块指向的服务器文件夹下</p>
<p>后台代码试例，express 环境</p>
<pre><code class="javascript">var express = require(&#39;express&#39;)
var router = express.Router()
var fs = require(&#39;fs&#39;)
var path = require(&#39;path&#39;)
/* 用于处理非表单的文件数据流 */
var multer = require(&#39;multer&#39;)
// 配置数据流向的文件,绝对路径，相对于根目录
var upload = multer(&#123; dest: &#39;upload/&#39; &#125;)
// 创建一个接收为编码的二进制数据流的方法实例 接收 name 为 newimg 字段的上传文件，最大接收
为 1
var cpUpload = upload.fields([&#123; name: &#39;newimg&#39;, maxCount: 1 &#125;])
// 接口
router.post(&#39;/add&#39;, cpUpload, (req, res) =&gt; &#123;
 // 前端发送请求后，服务器已经接受到了前端传递过来的图片数据，保存在 files 对象下
 // 加上 cpUpload，数据就会从这个方法所设置的地址流过来，生成一个本地临时空间，类似于虚拟
DOM
 // 获取这段数据
 var img = req.files.newimg[0]
 
 // fs 模块读取临时空间的数据 
 var readStream = fs.createReadStream(img.path) 
 // 设置图片存入的路径，并给文件名前面加上一个时间轴，防止命名重复 
 var imgpath = `/cdn/$&#123;Date.now()&#125;-$&#123;img.originalname&#125;` 
 // 创建一个写入图片数据的地址 
 var writeStram = fs.createWriteStream( path.resolve(__dirname, `../public$&#123;imgpath&#125;`) )
 // 设置一个 pipe 管道，将读取的数据解析并注入到写入地址 
 readStream.pipe(writeStram) 
 // 监听注入地址的 close 事件，表示注入完毕 
 writeStram.on(&#39;close&#39;, () =&gt; &#123; 
   // 返回给前端一个图片地址 
   res.json(&#123; err: 0, msg: &#39;success&#39;, data: &#123; img: imgpath &#125; &#125;) &#125;)
   &#125;)
module.exports = router
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-koa-和-express-的区别"><a href="#♥︎-♥︎-♥︎-♥︎-koa-和-express-的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ koa 和 express 的区别"></a>♥︎ ♥︎ ♥︎ ♥︎ koa 和 express 的区别</h3><p>最大的区别在于语法，experss 的异步采用的是回调函数的形式，而 koa1 支持 generator + yeild，koa2 支持 await&#x2F;async，无疑更加优雅。</p>
<p>中间件的区别：koa 采用洋葱模型，进行顺序执行，出去反向执行，支持 context 传递数据 。express 本身无洋葱模型，需要引入插件，不支持 context express 的中间件中执行异步函数，执行顺序不会按照洋葱模型，异步的执行结果有可能被放到最后，response 之前。 这是由于，其中间件执行机制，递归回调中没有等待中间件中的异步函数执行完毕，就是没有 await 中间件异步函数</p>
<p>集成度区别：express 内置了很多中间件，集成度高，使用省心， koa 轻量简洁，容易定制</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-了解-eggjs-吗？"><a href="#♥︎-♥︎-♥︎-♥︎-了解-eggjs-吗？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 了解 eggjs 吗？"></a>♥︎ ♥︎ ♥︎ ♥︎ 了解 eggjs 吗？</h3><p>eggjs 的特性 提供基于 Egg 定制上层框架的能力 高度可扩展的插件机制 内置多进程管理 基于 Koa 开发，性能优异 框架稳定，测试覆盖率高 渐进式开发</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-说说对Nodejs中的事件循环机制理解"><a href="#♥︎-♥︎-♥︎-♥︎-说说对Nodejs中的事件循环机制理解" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说说对Nodejs中的事件循环机制理解?"></a>♥︎ ♥︎ ♥︎ ♥︎ 说说对Nodejs中的事件循环机制理解?</h3><h4 id="一、是什么-9"><a href="#一、是什么-9" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在浏览器事件循环中，我们了解到<code>javascript</code>在浏览器中的事件循环机制，其是根据<code>HTML5</code>定义的规范来实现</p>
<p>而在<code>NodeJS</code>中，事件循环是基于<code>libuv</code>实现，<code>libuv</code>是一个多平台的专注于异步IO的库，如下图最右侧所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613639306239302d633930652d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>上图<code>EVENT_QUEUE</code> 给人看起来只有一个队列，但<code>EventLoop</code>存在6个阶段，每个阶段都有对应的一个先进先出的回调队列</p>
<h4 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h4><p>上节讲到事件循环分成了六个阶段，对应如下：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326533346438302d633930652d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<ul>
<li>timers阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li>
<li>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数</li>
<li>I&#x2F;O事件回调阶段(I&#x2F;O callbacks)：执行延迟到下一个循环迭代的 I&#x2F;O 回调，即上一轮循环中未被执行的一些I&#x2F;O回调</li>
<li>闲置阶段(idle, prepare)：仅系统内部使用</li>
<li>轮询阶段(poll)：检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞</li>
<li>检查阶段(check)：setImmediate() 回调函数在这里执行</li>
<li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)</li>
</ul>
<p>每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段</p>
<p>除了上述6个阶段，还存在<code>process.nextTick</code>，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队</p>
<p>流程图如下所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66626537333164302d633930652d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在<code>Node</code>中，同样存在宏任务和微任务，与浏览器中的事件循环相似</p>
<p>微任务对应有：</p>
<ul>
<li>next tick queue：process.nextTick</li>
<li>other queue：Promise的then回调、queueMicrotask</li>
</ul>
<p>宏任务对应有：</p>
<ul>
<li>timer queue：setTimeout、setInterval</li>
<li>poll queue：IO事件</li>
<li>check queue：setImmediate</li>
<li>close queue：close事件</li>
</ul>
<p>其执行顺序为：</p>
<ul>
<li>next tick microtask queue</li>
<li>other microtask queue</li>
<li>timer queue</li>
<li>poll queue</li>
<li>check queue</li>
<li>close queue</li>
</ul>
<h4 id="三、题目"><a href="#三、题目" class="headerlink" title="三、题目"></a>三、题目</h4><p>通过上面的学习，下面开始看看题目</p>
<pre><code class="javascript">async function async1() &#123;
    console.log(&#39;async1 start&#39;)
    await async2()
    console.log(&#39;async1 end&#39;)
&#125;

async function async2() &#123;
    console.log(&#39;async2&#39;)
&#125;

console.log(&#39;script start&#39;)

setTimeout(function () &#123;
    console.log(&#39;setTimeout0&#39;)
&#125;, 0)

setTimeout(function () &#123;
    console.log(&#39;setTimeout2&#39;)
&#125;, 300)

setImmediate(() =&gt; console.log(&#39;setImmediate&#39;));

process.nextTick(() =&gt; console.log(&#39;nextTick1&#39;));

async1();

process.nextTick(() =&gt; console.log(&#39;nextTick2&#39;));

new Promise(function (resolve) &#123;
    console.log(&#39;promise1&#39;)
    resolve();
    console.log(&#39;promise2&#39;)
&#125;).then(function () &#123;
    console.log(&#39;promise3&#39;)
&#125;)

console.log(&#39;script end&#39;)
</code></pre>
<p>分析过程：</p>
<ul>
<li>先找到同步任务，输出script start</li>
<li>遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</li>
<li>遇到第二个 setTimeout，300ms后将里面的回调函数放到 timer 队列中</li>
<li>遇到第一个setImmediate，将里面的回调函数放到 check 队列中</li>
<li>遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</li>
<li>执行 async1函数，输出 async1 start</li>
<li>执行 async2 函数，输出 async2，async2 后面的输出 async1 end进入微任务，等待下一轮的事件循环</li>
<li>遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行</li>
<li>遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</li>
<li>then里面的回调函数进入微任务队列</li>
<li>遇到同步任务，输出 script end</li>
<li>执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</li>
<li>然后执行微任务队列，依次输出 async1 end、promise3</li>
<li>执行timer 队列，依次输出 setTimeout0</li>
<li>接着执行 check 队列，依次输出 setImmediate</li>
<li>300ms后，timer 队列存在任务，执行输出 setTimeout2</li>
</ul>
<p>执行结果如下：</p>
<pre><code class="javascript">script start
async1 start
async2
promise1
promise2
script end
nextTick1
nextTick2
async1 end
promise3
setTimeout0
setImmediate
setTimeout2
</code></pre>
<p>最后有一道是关于<code>setTimeout</code>与<code>setImmediate</code>的输出顺序</p>
<pre><code class="javascript">setTimeout(() =&gt; &#123;
  console.log(&quot;setTimeout&quot;);
&#125;, 0);

setImmediate(() =&gt; &#123;
  console.log(&quot;setImmediate&quot;);
&#125;);
</code></pre>
<p>输出情况如下：</p>
<pre><code class="javascript">情况一：
setTimeout
setImmediate

情况二：
setImmediate
setTimeout
</code></pre>
<p>分析下流程：</p>
<ul>
<li>外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段</li>
<li>遇到<code>setTimeout</code>，虽然设置的是0毫秒触发，但实际上会被强制改成1ms，时间到了然后塞入<code>times</code>阶段</li>
<li>遇到<code>setImmediate</code>塞入<code>check</code>阶段</li>
<li>同步代码执行完毕，进入Event Loop</li>
<li>先进入<code>times</code>阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足<code>setTimeout</code>条件，执行回调，如果没过1毫秒，跳过</li>
<li>跳过空的阶段，进入check阶段，执行<code>setImmediate</code>回调</li>
</ul>
<p>这里的关键在于这1ms，如果同步代码执行时间较长，进入<code>Event Loop</code>的时候1毫秒已经过了，<code>setTimeout</code>先执行，如果1毫秒还没到，就先执行了<code>setImmediate</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-说说对中间件概念的理解，如何封装-node-中间件？"><a href="#♥︎-♥︎-♥︎-♥︎-说说对中间件概念的理解，如何封装-node-中间件？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说说对中间件概念的理解，如何封装 node 中间件？"></a>♥︎ ♥︎ ♥︎ ♥︎ 说说对中间件概念的理解，如何封装 node 中间件？</h3><h4 id="一、是什么-10"><a href="#一、是什么-10" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的</p>
<p>在<code>NodeJS</code>中，中间件主要是指封装<code>http</code>请求细节处理的方法</p>
<p>例如在<code>express</code>、<code>koa</code>等<code>web</code>框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36613665643366302d636365342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作</p>
<h4 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h4><p><code>koa</code>是基于<code>NodeJS</code>当前比较流行的<code>web</code>框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。通过添加不同的中间件，实现不同的需求，从而构建一个 <code>Koa</code> 应用</p>
<p><code>Koa</code> 中间件采用的是洋葱圈模型，每次执行下一个中间件传入两个参数：</p>
<ul>
<li>ctx ：封装了request 和 response 的变量</li>
<li>next ：进入下一个要执行的中间件的函数</li>
</ul>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353037623032302d636365342d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>下面就针对<code>koa</code>进行中间件的封装：</p>
<p><code>Koa </code>的中间件就是函数，可以是<code> async</code> 函数，或是普通函数</p>
<pre><code class="javascript">// async 函数
app.use(async (ctx, next) =&gt; &#123;
  const start = Date.now();
  await next();
  const ms = Date.now() - start;
  console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);
&#125;);

// 普通函数
app.use((ctx, next) =&gt; &#123;
  const start = Date.now();
  return next().then(() =&gt; &#123;
    const ms = Date.now() - start;
    console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);
  &#125;);
&#125;);
</code></pre>
<p>下面则通过中间件封装<code>http</code>请求过程中几个常用的功能：</p>
<h5 id="token校验"><a href="#token校验" class="headerlink" title="token校验"></a>token校验</h5><pre><code class="javascript">module.exports = (options) =&gt; async (ctx, next) &#123;
  try &#123;
    // 获取 token
    const token = ctx.header.authorization
    if (token) &#123;
      try &#123;
          // verify 函数验证 token，并获取用户相关信息
          await verify(token)
      &#125; catch (err) &#123;
        console.log(err)
      &#125;
    &#125;
    // 进入下一个中间件
    await next()
  &#125; catch (err) &#123;
    console.log(err)
  &#125;
&#125;
</code></pre>
<h5 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h5><pre><code class="javascript">const fs = require(&#39;fs&#39;)
module.exports = (options) =&gt; async (ctx, next) =&gt; &#123;
  const startTime = Date.now()
  const requestTime = new Date()
  await next()
  const ms = Date.now() - startTime;
  let logout = `$&#123;ctx.request.ip&#125; -- $&#123;requestTime&#125; -- $&#123;ctx.method&#125; -- $&#123;ctx.url&#125; -- $&#123;ms&#125;ms`;
  // 输出日志文件
  fs.appendFileSync(&#39;./log.txt&#39;, logout + &#39;\n&#39;)
&#125;
</code></pre>
<p><code>Koa</code>存在很多第三方的中间件，如<code>koa-bodyparser</code>、<code>koa-static</code>等</p>
<p>下面再来看看它们的大体的简单实现：</p>
<h5 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h5><p><code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值</p>
<pre><code class="javascript">// 文件：my-koa-bodyparser.js
const querystring = require(&quot;querystring&quot;);

module.exports = function bodyParser() &#123;
    return async (ctx, next) =&gt; &#123;
        await new Promise((resolve, reject) =&gt; &#123;
            // 存储数据的数组
            let dataArr = [];

            // 接收数据
            ctx.req.on(&quot;data&quot;, data =&gt; dataArr.push(data));

            // 整合数据并使用 Promise 成功
            ctx.req.on(&quot;end&quot;, () =&gt; &#123;
                // 获取请求数据的类型 json 或表单
                let contentType = ctx.get(&quot;Content-Type&quot;);

                // 获取数据 Buffer 格式
                let data = Buffer.concat(dataArr).toString();

                if (contentType === &quot;application/x-www-form-urlencoded&quot;) &#123;
                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body
                    ctx.request.body = querystring.parse(data);
                &#125; else if (contentType === &quot;applaction/json&quot;) &#123;
                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body
                    ctx.request.body = JSON.parse(data);
                &#125;

                // 执行成功的回调
                resolve();
            &#125;);
        &#125;);

        // 继续向下执行
        await next();
    &#125;;
&#125;;
</code></pre>
<h5 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h5><p><code>koa-static</code> 中间件的作用是在服务器接到请求时，帮我们处理静态文件</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const mime = require(&quot;mime&quot;);
const &#123; promisify &#125; = require(&quot;util&quot;);

// 将 stat 和 access 转换成 Promise
const stat = promisify(fs.stat);
const access = promisify(fs.access)

module.exports = function (dir) &#123;
    return async (ctx, next) =&gt; &#123;
        // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /
        let realPath = path.join(dir, ctx.path);

        try &#123;
            // 获取 stat 对象
            let statObj = await stat(realPath);

            // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html
            if (statObj.isFile()) &#123;
                ctx.set(&quot;Content-Type&quot;, `$&#123;mime.getType()&#125;;charset=utf8`);
                ctx.body = fs.createReadStream(realPath);
            &#125; else &#123;
                let filename = path.join(realPath, &quot;index.html&quot;);

                // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理
                await access(filename);

                // 存在设置文件类型并响应内容
                ctx.set(&quot;Content-Type&quot;, &quot;text/html;charset=utf8&quot;);
                ctx.body = fs.createReadStream(filename);
            &#125;
        &#125; catch (e) &#123;
            await next();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据</p>
<p><code>koa</code>本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得<code>web</code>应用具备良好的可拓展性和组合性</p>
<p>通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗杂代码，过程就如装饰者模式</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-Node性能如何进行监控以及优化？"><a href="#♥︎-♥︎-♥︎-♥︎-Node性能如何进行监控以及优化？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ Node性能如何进行监控以及优化？"></a>♥︎ ♥︎ ♥︎ ♥︎ Node性能如何进行监控以及优化？</h3><h4 id="一、-是什么"><a href="#一、-是什么" class="headerlink" title="一、 是什么"></a>一、 是什么</h4><p><code>Node</code>作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下：</p>
<ul>
<li>CPU</li>
<li>内存</li>
<li>I&#x2F;O</li>
<li>网络</li>
</ul>
<h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><p>主要分成了两部分：</p>
<ul>
<li>CPU负载：在某个时间段内，占用以及等待CPU的进程总数</li>
<li>CPU使用率：CPU时间占用状况，等于 1 - 空闲CPU时间(idle time) &#x2F; CPU总时间</li>
</ul>
<p>这两个指标都是用来评估系统当前CPU的繁忙程度的量化指标</p>
<p><code>Node</code>应用一般不会消耗很多的<code>CPU</code>，如果<code>CPU</code>占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞</p>
<h5 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h5><p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标</p>
<pre><code class="javascript">// /app/lib/memory.js
const os = require(&#39;os&#39;);
// 获取当前Node内存堆栈情况
const &#123; rss, heapUsed, heapTotal &#125; = process.memoryUsage();
// 获取系统空闲内存
const sysFree = os.freemem();
// 获取系统总内存
const sysTotal = os.totalmem();

module.exports = &#123;
  memory: () =&gt; &#123;
    return &#123;
      sys: 1 - sysFree / sysTotal,  // 系统内存占用率
      heap: heapUsed / headTotal,   // Node堆内存占用率
      node: rss / sysTotal,         // Node占用系统内存的比例
    &#125;
  &#125;
&#125;
</code></pre>
<ul>
<li>rss：表示node进程占用的内存总量。</li>
<li>heapTotal：表示堆内存的总量。</li>
<li>heapUsed：实际堆内存的使用量。</li>
<li>external ：外部程序的内存使用量，包含Node核心的C++程序的内存使用量</li>
</ul>
<p>在<code>Node</code>中，一个进程的最大内存容量为1.5GB。因此我们需要减少内存泄露</p>
<h5 id="磁盘-I-x2F-O"><a href="#磁盘-I-x2F-O" class="headerlink" title="磁盘 I&#x2F;O"></a>磁盘 I&#x2F;O</h5><p>硬盘的<code> IO</code> 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍</p>
<p>内存 <code>IO </code>比磁盘<code> IO</code> 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 <code>redis</code>、<code>memcached </code>等</p>
<p>并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决</p>
<h4 id="二、如何监控"><a href="#二、如何监控" class="headerlink" title="二、如何监控"></a>二、如何监控</h4><p>关于性能方面的监控，一般情况都需要借助工具来实现</p>
<p>这里采用<code>Easy-Monitor 2.0</code>，其是轻量级的 <code>Node.js</code> 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 <code>require</code> 一次，无需改动任何业务代码即可开启内核级别的性能监控分析</p>
<p>使用方法如下：</p>
<p>在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：</p>
<pre><code class="javascript">const easyMonitor = require(&#39;easy-monitor&#39;);
easyMonitor(&#39;你的项目名称&#39;);
</code></pre>
<p>打开你的浏览器，访问 <code>http://localhost:12333</code> ，即可看到进程界面</p>
<p>关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档</p>
<h4 id="三、如何优化"><a href="#三、如何优化" class="headerlink" title="三、如何优化"></a>三、如何优化</h4><p>关于<code>Node</code>的性能优化的方式有：</p>
<ul>
<li>使用最新版本Node.js</li>
<li>正确使用流 Stream</li>
<li>代码层面优化</li>
<li>内存管理优化</li>
</ul>
<h5 id="使用最新版本Node-js"><a href="#使用最新版本Node-js" class="headerlink" title="使用最新版本Node.js"></a>使用最新版本Node.js</h5><p>每个版本的性能提升主要来自于两个方面：</p>
<ul>
<li>V8 的版本更新</li>
<li>Node.js 内部代码的更新优化</li>
</ul>
<h5 id="正确使用流-Stream"><a href="#正确使用流-Stream" class="headerlink" title="正确使用流 Stream"></a>正确使用流 Stream</h5><p>在<code>Node</code>中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存</p>
<pre><code class="javascript">const http = require(&#39;http&#39;);
const fs = require(&#39;fs&#39;);

// bad
http.createServer(function (req, res) &#123;
    fs.readFile(__dirname + &#39;/data.txt&#39;, function (err, data) &#123;
        res.end(data);
    &#125;);
&#125;);

// good
http.createServer(function (req, res) &#123;
    const stream = fs.createReadStream(__dirname + &#39;/data.txt&#39;);
    stream.pipe(res);
&#125;);
</code></pre>
<h5 id="代码层面优化"><a href="#代码层面优化" class="headerlink" title="代码层面优化"></a>代码层面优化</h5><p>合并查询，将多次查询合并一次，减少数据库的查询次数</p>
<pre><code class="javascript">// bad
for user_id in userIds 
     let account = user_account.findOne(user_id)

// good
const user_account_map = &#123;&#125;   // 注意这个对象将会消耗大量内存。
user_account.find(user_id in user_ids).forEach(account)&#123;
    user_account_map[account.user_id] =  account
&#125;
for user_id in userIds 
    var account = user_account_map[user_id]
</code></pre>
<h5 id="内存管理优化"><a href="#内存管理优化" class="headerlink" title="内存管理优化"></a>内存管理优化</h5><p>在 V8 中，主要将内存分为新生代和老生代两代：</p>
<ul>
<li>新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象</li>
<li>老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象</li>
</ul>
<p>若新生代内存空间不够，直接分配到老生代</p>
<p>通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低</p>
<p>如下面情况：</p>
<pre><code class="javascript">const buffer = fs.readFileSync(__dirname + &#39;/source/index.htm&#39;);

app.use(
    mount(&#39;/&#39;, async (ctx) =&gt; &#123;
        ctx.status = 200;
        ctx.type = &#39;html&#39;;
        ctx.body = buffer;
        leak.push(fs.readFileSync(__dirname + &#39;/source/index.htm&#39;));
    &#125;)
);

const leak = [];
</code></pre>
<p><code>leak</code>的内存非常大，造成内存泄露，应当避免这样的操作，通过减少内存使用，是提高服务性能的手段之一</p>
<p>而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作</p>
<p>例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新new这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动</p>
<p>使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中。每次用到该对象时，就取对象池空闲的对象，并对它进行初始化操作，从而提高框架的性能</p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题大全之HTML5+CSS3</title>
    <url>/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（HTML5-CSS3）"><a href="#前端面试题大全（HTML5-CSS3）" class="headerlink" title="前端面试题大全（HTML5+CSS3）"></a>前端面试题大全（HTML5+CSS3）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="HTML5-CSS3"><a href="#HTML5-CSS3" class="headerlink" title="HTML5 + CSS3"></a>HTML5 + CSS3</h2><h3 id="♥︎-父元素和子元素宽高不固定，如何实现水平垂直居中"><a href="#♥︎-父元素和子元素宽高不固定，如何实现水平垂直居中" class="headerlink" title="♥︎ 父元素和子元素宽高不固定，如何实现水平垂直居中"></a>♥︎ 父元素和子元素宽高不固定，如何实现水平垂直居中</h3><p>方法一：flex布局</p>
<p>-父元素设置：display:flex; justify-content:center; align-items:center;</p>
<p>-另一种：父元素设置弹性盒display:flex; 子元素可以设置margin:auto;实现水平居中</p>
<p>方法二:定位属性（position）配合位移属性（transform）</p>
<p>-子元素设置：position:absolute; top:50%;left:50%;transform:translate(-50%,-50%)</p>
<pre><code class="html">//方法一：
&lt;div class=&quot;parent&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">body,html&#123;
    width: 100%;
    height: 100%;
&#125;
.parent&#123;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
    background-color: antiquewhite;
&#125;
.parent .child&#123;
    width: 200px;
    height: 300px;
    background-color: rgb(78,151,211);
&#125;
</code></pre>
<pre><code class="html">//方法二
&lt;div class=&quot;parent&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;
        &lt;p&gt;&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">//css部分
.parent&#123;
         width: 100%;
         height: 100%;
         background-color: antiquewhite;
        &#125;
.child&#123;
         position: absolute;
         top:50%;
         left:50%;
         transform: translate(-50%,-50%);
        &#125;
.child p&#123;
         width: 300px;
         height: 400px;
         background-color: rgb(78, 151, 211);
        &#125;/
</code></pre>
<h3 id="♥︎简述title与h1的区别，b与strong的区别，i与em的区别"><a href="#♥︎简述title与h1的区别，b与strong的区别，i与em的区别" class="headerlink" title="♥︎简述title与h1的区别，b与strong的区别，i与em的区别"></a>♥︎简述title与h1的区别，b与strong的区别，i与em的区别</h3><p>《title与h1》</p>
<p>1.从网站的角度来说，title更侧重于网站消息。title可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的。</p>
<p>2.从文章的角度看，h1则是侧重于概括文章主题。</p>
<p>3.一个网站可以有多个title，但最好一个单页用一个title，以便突出网站页面主体信息，从seo看，title权重比h1高，适用性比h1广。</p>
<p>4.标记了h1的文字页面给予的权重会比页面内其他权重高很多，一个好的网站是h1和title并存，既突出h1文章主题，又突出网站主题和关键字。达到双重优化网站的效果。</p>
<p>《b和strong》</p>
<p>1.b只是对文本的简单加粗，strong是一个语义化标签，对相关文本具有强调作用。</p>
<p>2.b标签只是侧重于字体加粗，strong标签加强字体的语气都是通过粗体来实现的，相比之下，搜索引擎更喜欢侧重于strong标签。</p>
<p>3.strong标签更注重于内容上的应用，在html中，对关键词的标明。还有一些网站上，也有使用strong标签对小标题进行强调，但是在页面中，如果出现过多的strong标签，可能会对于排名不利。</p>
<p>《i与em》</p>
<p>1.i是实体标签，用来使字符倾斜，em是逻辑标签，作用是强调文本内容。</p>
<p>2.i标签只是斜体的样式，没有实际含义，常用来表达无强调或者重意味的斜体，比如生物学名、术语、外来语。</p>
<p>3.em表示标签内字符重要，用以强调，其默认格式是斜体，但是可以通过css添加样式。</p>
<p>‼️建议：为了符合css的规范，i标签应尽量少用，应改用em。</p>
<h3 id="♥︎什么是标准文档流"><a href="#♥︎什么是标准文档流" class="headerlink" title="♥︎什么是标准文档流"></a>♥︎什么是标准文档流</h3><p>标准文档流指的是元素排版布局过程中，元素会默认自动从左往右，从上往下的流式排列方式。当前面内容发生了变化，后面的内容位置也会随着发生变化。</p>
<p>HTML就是一种标准文档流文件。</p>
<h3 id="♥︎z-index是什么？在position的值什么时候可以触发"><a href="#♥︎z-index是什么？在position的值什么时候可以触发" class="headerlink" title="♥︎z-index是什么？在position的值什么时候可以触发"></a>♥︎z-index是什么？在position的值什么时候可以触发</h3><ul>
<li>z-index堆叠上下文只有在postion:relative&#x2F;absolute&#x2F;fixed脱离文档流控制时才生效，static时无效。</li>
<li>当父元素和子元素都处于堆叠上下文时，子元素继承父元素的优先级，故父元素大的就大，如果父元素没有处于堆叠上下文时，即z-index:auto;或者position:static;时，子元素不会继承父元素的优先级。</li>
<li>z-index为0时依然处于堆叠上下文中，比负值高，比正值低。</li>
<li>z-index为负值时不仅会处于z-index为0和正值元素的后面，还会处于非堆叠元素的后面。</li>
</ul>
<h3 id="♥︎简述一下src和href的区别，title和alt的区别"><a href="#♥︎简述一下src和href的区别，title和alt的区别" class="headerlink" title="♥︎简述一下src和href的区别，title和alt的区别"></a>♥︎简述一下src和href的区别，title和alt的区别</h3><p>href：href表示超文本引用，用来建立当前元素和文档的链接，常用在link和a等元素上。</p>
<p>‼️注：当浏览器解析到这一句时会识别该文档为css文件，会下载并不会停止对当前文档的处理，所以建议使用link的方式而不是使用@import加载css。</p>
<p>src：src表示引用资源，替换当前元素，是页面内容不可缺少的一部分，常用在img，script，iframe上。src指向外部资源的位置，指向的内部会嵌入到文档中当前标签所在的位置；请求src资源时会将其指向的资源下载并应用到当前文档中，例如js脚本、img图片等。</p>
<p>‼️注：src链接内的地址不会有跨域问题。当浏览器解析到这一句时会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕。这也是js脚本放在底部而不是头部的问题。</p>
<p>title：</p>
<p>1.title属性是为元素提供额外的注释信息，当鼠标放在元素上时会有title文字显示，以达到补充说明或提示。</p>
<p>2.title属性更倾向于用户体验的考虑。</p>
<p>3.title既可以是元素的属性也可以是标签。</p>
<p>alt：</p>
<p>1.alt属性是在你图片无法显示时的替代文本，它会直接输出在原本加载图片的地方。</p>
<p>2.alt属性是有利于SEO，是搜索引擎搜录时判断图片与文字是否相关的重要依据。</p>
<p>3.alt只能是元素的属性，只能用在img、area和input标签中（img，area中的alt必须指定）。</p>
<p>‼️注：当a标签内嵌套img标签时，起作用的是img的title属性。</p>
<h3 id="♥︎CSS清除浮动的方法"><a href="#♥︎CSS清除浮动的方法" class="headerlink" title="♥︎CSS清除浮动的方法"></a>♥︎CSS清除浮动的方法</h3><p>浮动问题，例如：</p>
<p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221012073825650.png"></p>
<p>浮动代码实现：</p>
<pre><code class="html">&lt;div class=&quot;fater&quot;&gt;
    &lt;div class=&quot;box1&quot;&gt;one&lt;/div&gt;
    &lt;div class=&quot;box2&quot;&gt;two&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;box3&quot;&gt;three&lt;/div&gt;
</code></pre>
<pre><code class="css">.fater&#123;
    width: 300px;
    border:1px solid pink;
&#125;
.box1&#123;
    width: 100px;
    height: 100px;
    background-color: blue;
    float: left;
&#125;
.box2&#123;
    width: 140px;
    height: 120px;
    background-color: blueviolet;
    float: left;
&#125;
.box3&#123;
    width: 200px;
    height: 150px;
    background-color: brown;
&#125;
</code></pre>
<p>如上图所示，因为盒子1和2的浮动，脱离了文档流，那么在他们下面的盒子就会顶上来，又因为父盒子没有设置高度，此时父盒子的高度为零，浮动的元素不能撑开父盒子的高度是因为子元素脱离文档流，父元素没有脱离文档流，所以现在的父盒子相当于没有元素，所以高度为零。</p>
<p>清除浮动的方法：</p>
<p>1.在标签尾部添加空的块级标签，设置样式属性为：clear：both；</p>
<p>缺点：如果页面浮动布局过多，就要添加很多空的块级元素，不利于页面的优化。</p>
<pre><code class="html">//html
&lt;div class=&quot;fater&quot;&gt;
    &lt;div class=&quot;box1&quot;&gt;one&lt;/div&gt;
    &lt;div class=&quot;box2&quot;&gt;two&lt;/div&gt;
    &lt;div class=&quot;box4&quot;&gt;空元素&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;box3&quot;&gt;three&lt;/div&gt;
//css
.box4&#123;
    clear:both;
    background-color: aqua;
&#125;
</code></pre>
<p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221012081413822.png"></p>
<p>2.给父盒子添加overflow：hidden；（触发BFC）</p>
<p>缺点：不能和position配合使用；内容增多的时候容易造成不会自动换行导致内容被隐藏，无法显示要溢出的元素。</p>
<pre><code class="html">//html
&lt;div class=&quot;fater&quot;&gt;
    &lt;div class=&quot;box1&quot;&gt;one&lt;/div&gt;
    &lt;div class=&quot;box2&quot;&gt;two&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;box3&quot;&gt;three&lt;/div&gt;
//css
.fater&#123;
    width: 300px;
    border:1px solid pink;
    overflow: hidden;
&#125;
</code></pre>
<p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221012081713849.png"></p>
<p>3.使用伪元素清除浮动（推荐）</p>
<p>缺点：ie6-7不支持伪元素 :after，使用zoom:1 触发hasLayout。</p>
<pre><code class="html">//html
&lt;div class=&quot;fater clear&quot;&gt;
    &lt;div class=&quot;box1&quot;&gt;one&lt;/div&gt;
    &lt;div class=&quot;box2&quot;&gt;two&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;box3&quot;&gt;three&lt;/div&gt;
//css
.clear::after&#123;
    content: &quot;&quot;;
    display: block;
    clear: both;
&#125;
.clearfix&#123;
        *zoom:1 // *ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行
&#125;
</code></pre>
<p>4.直接给父元素单独设置高度（height）(不推荐)</p>
<p>缺点：只适合高度固定的布局，不利于响应式布局。</p>
<h3 id="♥︎hasLayout是什么？-了解即可"><a href="#♥︎hasLayout是什么？-了解即可" class="headerlink" title="♥︎hasLayout是什么？(了解即可)"></a>♥︎hasLayout是什么？(了解即可)</h3><p>hasLayout是IE特有的一个属性。很多的ie下的css bug都与其息息相关。在ie中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。<br>下列元素默认 hasLayout&#x3D;true</p>
<pre><code class="html">&lt;table&gt; &lt;td&gt; &lt;body&gt; &lt;img&gt; &lt;hr&gt; &lt;input&gt; &lt;select&gt; &lt;textarea&gt; &lt;button&gt; &lt;iframe&gt; &lt;embed&gt; &lt;object&gt; &lt;applet&gt; &lt;marquee&gt; 
很多情况下，我们把 hasLayout的状态改成true 就可以解决很大部分ie下显示的bug。 
hasLayout属性不能直接设定，你只能通过设定一些特定的css属性来触发并改变 hasLayout 状态。下面列出可以触发hasLayout的一些CSS属性值。 
------------------------------------- 
display 
启动haslayout的值:inline-block 
取消hasLayout的值:其他值 
-------------------------------------- 
width/height 
启动hasLayout的值：除了auto以外的值 
取消hasLayout的值：auto 
--------------------------------------- 
position 
启动hasLayout的值：absolute 
取消hasLayout的值：static 
---------------------------------------- 
float 
启动hasLayout的值：left或right 
取消hasLayout的值：none 
--------------------------------------- 
zoom 
启动hasLayout的值：有值 
取消hasLayout的值：narmal或者空值 
（zoom是微软IE专有属性，可以触发hasLayout但不会影响页面的显示效果。zoom: 1常用来除错，不过 ie 5 对这个属性不支持。）
</code></pre>
<h3 id="♥︎什么是CSS3-transform-animation-区别是什么？"><a href="#♥︎什么是CSS3-transform-animation-区别是什么？" class="headerlink" title="♥︎什么是CSS3 transform? animation? 区别是什么？"></a>♥︎什么是CSS3 transform? animation? 区别是什么？</h3><p>一、transform描述的是元素静态样式</p>
<p>​	transform属性应用与元素的2D和3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。必须是鼠标移上或者点击执行属性变化，鼠标离开属性回归。说到底就是属性不会变化。配合-webkit-transition: 0.3s;transition: 0.3s;才会有动画的效果，否则会很生硬。</p>
<pre><code class="css">旋转：rote(30deg)    水平面以元素中心旋转多少度；
     rotateX(angle)   定义沿着 X 轴的 3D 旋转；
     rotateY(angle)   定义沿着 Y 轴的 3D 旋转；
位移：translate(x,y)   定义 2D 转换;
     translate3d(x,y,z)  定义 3D 转换;
缩放：scale(x,y)   定义 2D 缩放转换;
     scale3d(x,y,z)   定义 3D 缩放转换;
</code></pre>
<p>二、实现动画效果的：transition  animation</p>
<p>1、transition</p>
<pre><code class="css">transition 属性是一个简写属性，用于设置四个过渡属性 
transition: property    duration      timing-function   delay;
            过渡的属性 | 完成过度效果需要时间 | 速度曲线  |  延迟时间
.one1&#123;transition: width 3s linear 2s;&#125;    
.one1:hover&#123;width:300px;&#125;

transition定义了动画的属性、时间、速度曲线以及延迟时间  ；通常和hover等事件配合使用，由事件触发。
</code></pre>
<p>2、animation</p>
<pre><code class="css">animation 属性是一个简写属性，用于设置六个动画属性：
animation的使用必须结合@keyframes animation-name使用
    @keyframes  move&#123;
                                        form&#123; left:0px;&#125;  
                                        to&#123; left:200px;&#125;
                                    &#125;
在需要动画的元素上面添加动画  div&#123;animation:move 5s infinite;&#125;
animation: name duration timing-function delay iteration-count direction;
动画名称，动画执行时间，速度曲线，动画延迟时间，播放次数，是否反向播放
animation可以设定每一帧的样式和时间
</code></pre>
<p>区别：</p>
<ol>
<li>触发条件不同。transition通常和hover等事件配合使用，由事件触发。animation则立即播放。</li>
<li>循环。 animation可以设定循环次数。</li>
<li>精确性。 animation可以设定每一帧的样式和时间。tranistion 只能设定头尾。 animation中可以设置每一帧需要单独变化的样式属性， transition中所有样式属性都要一起变化。</li>
<li>与javascript的交互。animation与js的交互不是很紧密。tranistion和js的结合更强大。js设定要变化的样式，transition负责动画效果，天作之合，比之前只能用js时爽太多。</li>
</ol>
<p>‼️总结：</p>
<p>1.transition是css中检测指定属性变化进行自动补间动画的属性。</p>
<p>2.animation是先指定好动画过程中的关键帧属性，进行动画的属性。</p>
<h3 id="♥︎如何理解HTML结构语义化？"><a href="#♥︎如何理解HTML结构语义化？" class="headerlink" title="♥︎如何理解HTML结构语义化？"></a>♥︎如何理解HTML结构语义化？</h3><h4 id="一、什么是语义化？"><a href="#一、什么是语义化？" class="headerlink" title="一、什么是语义化？"></a>一、什么是语义化？</h4><p>字面意思就是说根据我们所说的话，就能了解其中的含义。语义化，故名思意，就是你写的HTML结构，是用相对应的有一定语义的英文字母(标签)表示的，标记的，因为HTML本身就是标记语言。不仅对自己来说，容易阅读，书写。别人看你的代码和结构也容易理解，甚至对一些不是做网页开发的人来说，也容易阅读。</p>
<h4 id="二、什么是HTML语义化？"><a href="#二、什么是HTML语义化？" class="headerlink" title="二、什么是HTML语义化？"></a>二、什么是HTML语义化？</h4><p>首先标签语义化是指HTML，不是CSS, 语义化标签只是HTML，CSS不存在语义化。HTML是标签，CSS是属性。</p>
<p>在最初html里标签的语义，我们看到table,就会知道这是列表，看到p，就知道这是段落，看到img知道是图片，看到input就知道这是一个表单，h1~h6是标题。 机器和人类相比笨多了，但是只要我们设定好程序，上面的标签的意思机器也能读懂。</p>
<h4 id="三、怎样判断标签是否语义化"><a href="#三、怎样判断标签是否语义化" class="headerlink" title="三、怎样判断标签是否语义化"></a>三、怎样判断标签是否语义化</h4><p>去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性。</p>
<h4 id="四、写HTML代码时应注意什么？"><a href="#四、写HTML代码时应注意什么？" class="headerlink" title="四、写HTML代码时应注意什么？"></a>四、写HTML代码时应注意什么？</h4><p>1.尽可能少的使用无语义的标签div和span；</p>
<p>2.在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</p>
<p>3.不要使用纯样式标签，如：b、font、u等，改用css设置。</p>
<p>4.需要强调的文本，可以包含在strong或者em标签中(浏览器预设样式，能用CSS指定就不用他们)，strong默认样式是加粗(不要用b)，em是斜体(不用i)；</p>
<p>5.使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</p>
<p>6.每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for&#x3D;someld来让说明文本和相对应的input关联起来；</p>
<h4 id="五、解决的问题（好处）"><a href="#五、解决的问题（好处）" class="headerlink" title="五、解决的问题（好处）"></a>五、解决的问题（好处）</h4><p>1.清晰的页面结构。去掉或样式丢失的时候,也能让页面呈现清晰的结构，增强页面的可读性。</p>
<p>2.支持更多的设备。屏幕阅读器会完全根据你的标记来“读”你的网页。更好的支持浏览器的阅读模式等。</p>
<p>3.有利于SEO(搜索引擎优化)。和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重。</p>
<p>4.便于团队开发和维护。在团队中大家都遵循同一个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。</p>
<p>5.方便其他设备解析(如屏幕阅读器、盲人阅读器、移动设备)以意义的方式来渲染网页；</p>
<h3 id="♥︎块级元素？行内元素？空元素？"><a href="#♥︎块级元素？行内元素？空元素？" class="headerlink" title="♥︎块级元素？行内元素？空元素？"></a>♥︎块级元素？行内元素？空元素？</h3><p>1.行内元素：</p>
<p>不独占一行、会和其他的行内元素排成一排；</p>
<p>不能设置宽高，默认的宽高是由其内容宽高撑起来的；</p>
<p>margin 上下不生效，左右生效；</p>
<p>2.块级元素</p>
<p>独占一行，不会和其他的元素排成一排；</p>
<p>可以设置宽高，默认的宽度是继承父元素的宽度、高度默认是其内容的高度；</p>
<p>margin 上下左右都可以设置，margin : auto;不生效；</p>
<p>3.行内块元素</p>
<p>不独占一行，可以和其他的行内元素或者行内块级元素排成一排；</p>
<p>设置宽高生效、默认宽度为父元素的宽度，默认高度为其内容的高度；</p>
<p>margin 上下左右生效，margin : auto;不生效；</p>
<hr>
<p>常见行内元素：a、b、u、span、i、em、strong等文字标签</p>
<p>常见块级元素： div、table、tr、form、ul、li、ol、h1~h6、p</p>
<p>常见行内块元素： img、select、input</p>
<p>常见空元素： img、hr、br、input、meta</p>
<hr>
<h3 id="♥︎meta标签的name属性值"><a href="#♥︎meta标签的name属性值" class="headerlink" title="♥︎meta标签的name属性值"></a>♥︎meta标签的name属性值</h3><p>meta标签的name属性是用来定义一个HTML文档的描述、关键词，规定了元数据的名称，规定了content属性的信息&#x2F;值的名称。</p>
<pre><code class="html">//属性值
1.application-name  //规定页面所代表的Web应用程序的名称
2.author  //规定页面文档的作者的名字
</code></pre>
<pre><code class="html">1.description  //规定页面的描述。搜索引擎会把这个描述显示在搜索结果中
实例：&lt;meta name=&quot;description&quot; content=&quot;页面描述&quot;&gt;
2.gennerator  //规定用于生成文档的一个软件包（不用于手写页面）
实例：&lt;meta name=&quot;gennerator&quot; content=&quot;FrontPage 4.0&quot;&gt;
3.keywords  //规定一个逗号分隔的关键词列表 - 相关的网页（告诉搜索引擎页面是与什么相关的）
实例：&lt;meta name=&quot;keywords&quot; content=&quot;HTML，meta tag，tag reference&quot;&gt;
</code></pre>
<h3 id="♥︎如何实现图片和文字在同一行显示？"><a href="#♥︎如何实现图片和文字在同一行显示？" class="headerlink" title="♥︎如何实现图片和文字在同一行显示？"></a>♥︎如何实现图片和文字在同一行显示？</h3><p>1.给img标签添加“vertical-align：middle”属性</p>
<p>2.如果是背景图，则通过background的定位属性来设置位置</p>
<p>3.分别把图片和文字放入不同的div中，设置“vertical-align：middle”属性</p>
<h3 id="♥︎简述video标签的几个属性和方法"><a href="#♥︎简述video标签的几个属性和方法" class="headerlink" title="♥︎简述video标签的几个属性和方法"></a>♥︎简述video标签的几个属性和方法</h3><h4 id="1、video"><a href="#1、video" class="headerlink" title="1、video"></a>1、video</h4><p>video标签的使用方法，如下：</p>
<pre><code class="html"> &lt;video src=&quot;视频文件路径&quot; controls&gt;请选择兼容的浏览器&lt;/video&gt;
    &lt;!-- 
        其中src时video的基本属性用于存放视频文件路径；
        而controls是video标签提供的一套默认的控制栏功能；
        而video标签中包含的文字是用于浏览器不支持时显示的；
     --&gt;
</code></pre>
<p>通过在video中使用更多的视频格式，从而兼容更多的浏览器</p>
<pre><code class="html">&lt;video controls&gt;
    &lt;source src = &quot;视频文件路径&quot; type = &quot;video/格式&quot;&gt;
    &lt;source src = &quot;视频文件路径&quot; type = &quot;video/格式&quot;&gt;
    &lt;source src = &quot;视频文件路径&quot; type = &quot;video/格式&quot;&gt;
    ...
&lt;/video&gt;
</code></pre>
<h4 id="2、video常用的标签播放属性"><a href="#2、video常用的标签播放属性" class="headerlink" title="2、video常用的标签播放属性"></a>2、video常用的标签播放属性</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">允许取的值</th>
<th align="center">取值的说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">autoplay</td>
<td align="center">autoplay</td>
<td align="center">如果出现了该属性，则视频在缓冲就绪后马上播放</td>
</tr>
<tr>
<td align="center">controls</td>
<td align="center">controls</td>
<td align="center">如果出现了该属性，则向用户显示控件，比如播放按钮</td>
</tr>
<tr>
<td align="center">height</td>
<td align="center">px(多少像素)、100%</td>
<td align="center">设置视频播放器的高度</td>
</tr>
<tr>
<td align="center">width</td>
<td align="center">px(多少像素)、100%</td>
<td align="center">设置视频播放器的宽度</td>
</tr>
<tr>
<td align="center">loop</td>
<td align="center">loop</td>
<td align="center">如果出现该属性，则当媒体文件播放完后再次播放（循环播放）</td>
</tr>
<tr>
<td align="center">preload</td>
<td align="center">preload</td>
<td align="center">如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用了autoplay，则忽略该属性）</td>
</tr>
<tr>
<td align="center">src</td>
<td align="center">视频文件的路径</td>
<td align="center">视频文件的路径</td>
</tr>
</tbody></table>
<h4 id="3、video对象的常用方法"><a href="#3、video对象的常用方法" class="headerlink" title="3、video对象的常用方法"></a>3、video对象的常用方法</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">load()</td>
<td align="center">该方法用于加载视频文件，为播放做准备。常用于播放前的预加载，也会用于重新加载媒体文件</td>
</tr>
<tr>
<td align="center">play()</td>
<td align="center">用于播放视频文件。如果视频没有加载，则加载并播放；如果视频时暂停的，则变为播放</td>
</tr>
<tr>
<td align="center">pause()</td>
<td align="center">暂停视频</td>
</tr>
<tr>
<td align="center">canPlayType()</td>
<td align="center">测试浏览器是否支持指定的视频类型</td>
</tr>
</tbody></table>
<h4 id="4、video对象的常用属性"><a href="#4、video对象的常用属性" class="headerlink" title="4、video对象的常用属性"></a>4、video对象的常用属性</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">属性描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">currentSrc</td>
<td align="center">返回当前视频文件的地址</td>
</tr>
<tr>
<td align="center">currentTime</td>
<td align="center">设置或者返回视频中的当前播放位置（以秒为单位）</td>
</tr>
<tr>
<td align="center">duration</td>
<td align="center">返回视频的长度（以秒为单位）</td>
</tr>
<tr>
<td align="center">ended</td>
<td align="center">返回视频的播放是否以及结束</td>
</tr>
<tr>
<td align="center">error</td>
<td align="center">返回视频错误状态的MediaError对象</td>
</tr>
<tr>
<td align="center">paused</td>
<td align="center">设置或者返回视频是否暂停</td>
</tr>
<tr>
<td align="center">muted</td>
<td align="center">设置或者返回视频是否关闭声音</td>
</tr>
<tr>
<td align="center">volume</td>
<td align="center">设置或者返回视频的音量大小</td>
</tr>
<tr>
<td align="center">height &#x2F; width</td>
<td align="center">设置或者返回视频的高度值 &#x2F; 宽度值</td>
</tr>
</tbody></table>
<h3 id="♥︎什么是border-image？什么是box-sizing"><a href="#♥︎什么是border-image？什么是box-sizing" class="headerlink" title="♥︎什么是border-image？什么是box-sizing?"></a>♥︎什么是border-image？什么是box-sizing?</h3><h4 id="一、border-image"><a href="#一、border-image" class="headerlink" title="一、border-image"></a>一、border-image</h4><p>border-image 属性可以通过一些简单的规则，将一副图像划分为 9 个单独的部分，浏览器会自动使用相应的部分来替换边框的默认样式。border-image 属性是五个 border-image-* 属性的简写，其语法格式如下：</p>
<pre><code class="css">//集成属性
border-image：border-image-source || border-image-slice [ / border-image-width | / border-image-width ? / border-image-outset ]? || border-image-repeat；
//单个属性
border-image-source：定义边框图像的路径；
border-image-slice：定义边框图像从什么位置开始分割；
border-image-width：定义边框图像的厚度（宽度）；
border-image-outset：定义边框图像的外延尺寸（边框图像区域超出边框的量）；
border-image-repeat：定义边框图像的平铺方式。
</code></pre>
<h4 id="二、box-sizing"><a href="#二、box-sizing" class="headerlink" title="二、box-sizing"></a>二、box-sizing</h4><p>当布局使用的是自适应的布局方式时，盒子的宽度给的是百分比的形式，但是边框和内边距是用像素来表示的话就会改变盒子视觉上的大小，但是给加上<code>box-sizing:border-box</code>的话就会在不改变宽高的情况下，让边框和内边距满足我们所需要的条件之下，让<code>content</code>的大小自适应。</p>
<p>使用box-sizing:border-box；时的盒子模型：</p>
<p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/28377643-162495979b0b252c.png"></p>
<p>使用了box-sizing:border-box；盒模型：</p>
<p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/28377643-b283527c28a3d1c4.png"></p>
<h3 id="♥︎div-css的布局比较table布局有什么有点？"><a href="#♥︎div-css的布局比较table布局有什么有点？" class="headerlink" title="♥︎div+css的布局比较table布局有什么有点？"></a>♥︎div+css的布局比较table布局有什么有点？</h3><h4 id="一、table布局"><a href="#一、table布局" class="headerlink" title="一、table布局"></a>一、table布局</h4><p>优点：</p>
<p>1、对于新手而言，容易上手，尤其对于一些布局中规中矩的网页，更让人首先想到excel，进而通过使用table去实现它。</p>
<p>2、表现上更加“严谨”，在不同浏览器中都能得到很好的兼容</p>
<p>3、通过复杂的表格套表格的形式，也可以实现比较复杂的布局需求。布置好表格，然后将内容放进去就可以了。</p>
<p>4、它可以不用顾及垂直居中的问题。</p>
<p>5、数据化的存放更合理。</p>
<p>缺点：</p>
<p>1、标签结构多，复杂，在表格布局中，主要是用到表格的相互嵌套使用，这样就会造成代码的复杂度更高！</p>
<p>2、表格布局，不利于搜索引擎抓取信息，直接影响到网站的排名；</p>
<h4 id="二、div-css布局"><a href="#二、div-css布局" class="headerlink" title="二、div + css布局"></a>二、div + css布局</h4><p>优点：</p>
<p>1、符合W3C标准的，W3C标准提出网页由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。结构清晰明了，结构、样式和行为分离，带来足够好的可维护性。</p>
<p>2、布局更加灵活多样，能够通过样式选择来实现界面设计方面的更多要求。</p>
<p>3、布局改版方便，不需要过多地变动页面内容，通常只要更换相应的css样式就可以将网页变成另外一种风格展现出来。</p>
<p>4、布局可以让一些重要的链接和文字信息等优先让搜索引擎抓取，内容更便于搜索。</p>
<p>5、增加网页打开速度，增强用户体验。</p>
<p>缺点：</p>
<p>1、开发技术高，要考虑兼容版本浏览器。目前来看，DIV+CSS还没有实现所有浏览器的统一兼容。</p>
<p>2、CSS网站制作的设计元素通常放在1个外部文件中，或几个文件，</p>
<p>有可能相当复杂，甚至比较庞大，如果CSS文件调用出现异常，那么整个网站将变得惨不忍睹。</p>
<p>‼️总结：div+css的布局较table布局的明显优势；</p>
<p>1，其实也是div+css布局的第一个特点，table标签被严格地定义为存放数据的一个区域，而不是布局工具，它的布局形式不符合W3C标准，没有实现结构和表现的分离，它既有css的表现功能，也有html的结构功能。</p>
<p>2，table布局加载网页时，必须整体加载完，降低了网页的呈现速度，而div+css布局是边加载边显示的。</p>
<p>3，table布局在网页代码编写时，有时需要嵌套多重表格才能实现，但使用div+css布局，相对而言会减少许多嵌套时的代码，更容易检查和维护。</p>
<p>4，table布局不方便表现的更换，使用div+css布局，大多只要更改css样式表就能变化表现形式。</p>
<p>5、易于维护和改版。</p>
<h3 id="♥︎display-none和visbility-hidden的区别是什么？"><a href="#♥︎display-none和visbility-hidden的区别是什么？" class="headerlink" title="♥︎display:none和visbility:hidden的区别是什么？"></a>♥︎display:none和visbility:hidden的区别是什么？</h3><p>display：none 和visibility：hidden都可以实现让元素隐藏的效果，但原理是大不相同。</p>
<p>1.display:none是让这个元素失去块元素的效果，其本身这个元素也是直接消失，会影响到布局问题。</p>
<p>2.visibility:hidden:可以让元素消失，属于css样式，它只是简单的让元素看不见，但本身的位置还在，如果对div进行hidden，那么div除了看不见，其他所有的样式都在。</p>
<hr>
<h3 id="♥︎♥︎分别实现骰子中的一点-和-三点的布局。"><a href="#♥︎♥︎分别实现骰子中的一点-和-三点的布局。" class="headerlink" title="♥︎♥︎分别实现骰子中的一点 和 三点的布局。"></a>♥︎♥︎分别实现骰子中的一点 <strong>和</strong> 三点的布局。</h3><p>1.一点布局</p>
<pre><code class="html">&lt;div class=&quot;father&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">.father&#123;
    width: 100px;
    height: 100px;
    background-color: black;
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
&#125;
.child&#123;
    width: 20px;
    height: 20px;
    background-color: white;
    border-radius: 50%;
&#125;
</code></pre>
<p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221012151555911.png" alt="一点"></p>
<p>2.三点布局</p>
<pre><code class="html">&lt;div class=&quot;father&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;child1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;child2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">.father&#123;
    width: 100px;
    height: 100px;
    background-color: black;
    padding: 5px;
    border-radius: 10px;
    display: flex;
    justify-content: space-between;
&#125;
.child&#123;
    width: 20px;
    height: 20px;
    background-color: white;
    border-radius: 50%;
&#125;
.child1&#123;
    width: 20px;
    height: 20px;
    background-color: white;
    border-radius: 50%;
    align-self: center;
&#125;
.child2&#123;
    width: 20px;
    height: 20px;
    background-color: white;
    border-radius: 50%;
    align-self: flex-end;
&#125;
</code></pre>
<p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221012152019924.png" alt="三点布局"></p>
<h3 id="♥︎♥︎简述选择器-和-的区别。"><a href="#♥︎♥︎简述选择器-和-的区别。" class="headerlink" title="♥︎♥︎简述选择器~和+的区别。"></a>♥︎♥︎简述选择器~和+的区别。</h3><p>～选择器的作用：</p>
<p>​	1.选择紧跟着当前符合条件元素后面的同级元素</p>
<p>​	2.可以匹配多个</p>
<p>+选择器的作用：</p>
<p>​	1.选择紧跟在当前符合条件元素后面的同级元素</p>
<p>​	2.只能匹配一个</p>
<h3 id="♥︎♥︎简述align-items和align-content的区别。"><a href="#♥︎♥︎简述align-items和align-content的区别。" class="headerlink" title="♥︎♥︎简述align-items和align-content的区别。"></a>♥︎♥︎简述align-items和align-content的区别。</h3><p>1.align-item属性是针对单独的每一个flex子项起作用，它的基本单位是每一个子项，在所有情况下都有效果（当然要看具体的属性值）。</p>
<p>2.align-content属性是将flex子项作为一个整体起作用，它的基本单位是子项构成的行，只在两种情况下有效果：①子项多行且flex容器高度固定 ②子项单行，flex容器高度固定且设置了flex-wrap:wrap;</p>
<p>‼️总结列表</p>
<table>
<thead>
<tr>
<th align="center">条件</th>
<th align="center"></th>
<th align="center"></th>
<th align="center">属性（是否有效果  是&#x2F;否）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">子项</td>
<td align="center">flex容器</td>
<td align="center">align-items</td>
<td align="center">align-content</td>
</tr>
<tr>
<td align="center">单行</td>
<td align="center">不指定高度</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">固定高度</td>
<td align="center">是</td>
<td align="center">否（但是有设置flex-wrap:wrap;时，有效果）</td>
</tr>
<tr>
<td align="center">多行</td>
<td align="center">不指定高度</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">固定高度</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<h3 id="♥︎♥︎简述data-属性的用法（如何设置，如何获取），有何优势？"><a href="#♥︎♥︎简述data-属性的用法（如何设置，如何获取），有何优势？" class="headerlink" title="♥︎♥︎简述data-属性的用法（如何设置，如何获取），有何优势？"></a>♥︎♥︎简述data-属性的用法（如何设置，如何获取），有何优势？</h3><p>data-*定义：</p>
<p>1.是用于存储页面或应用程序的私有自定义数据。</p>
<p>2.赋予我们在所以html元素上嵌入自定义data属性的能力。</p>
<p>data-*用法：</p>
<p>1.属性名不应该包含任何大写字母，并且在前缀“data-”之后必须有至少一个字母。</p>
<p>2.属性值可以是任何字符。</p>
<p>3.一个元素可以拥有任意数量的data属性。</p>
<p>4.data属性无法存储对象，如需存储，可以通过对象序列化。</p>
<p>data-*设置方法：</p>
<p>1.如何设置</p>
<pre><code class="javascript">通过javascript内置的setAttribute（‘data属性名’，‘新内容’）即可设置。

（兼容性方法）通过该数据类型的（dataset）API设置data值，IE10以上才支持；

​		var button = document.queryselector(&#39;button&#39;)

​		button.dataset.data属性名 = ‘新内容’；//这里的data属性名是指data-后面的名字
</code></pre>
<p>2.如果获取</p>
<pre><code class="javascript">通过javascript内置的getAttribute（‘data属性名’）即可获取。
兼容性方法）通过该数据类型的（dataset）API设置data值，IE10以上才支持；

​		var button = document.queryselector(&#39;button&#39;)

​		data = button.dataset.data属性名；//这里的data属性名是指data-后面的名字
</code></pre>
<p>❗️data-*优势：</p>
<p>1.其存储的自定义数据能够被页面的javascript利用，可以创建更好的用户体验。</p>
<p>2.可以通过javascript来构造数据、填充数据。</p>
<p>3.代码体积小、较为灵活。</p>
<p>4.解决网站的外观和实用性之间产生的冲突。</p>
<h3 id="♥︎♥︎CSS3-如何实现圆角？"><a href="#♥︎♥︎CSS3-如何实现圆角？" class="headerlink" title="♥︎♥︎CSS3 如何实现圆角？"></a>♥︎♥︎CSS3 如何实现圆角？</h3><h4 id="一、border-radius-完整写法："><a href="#一、border-radius-完整写法：" class="headerlink" title="一、border-radius 完整写法："></a>一、border-radius 完整写法：</h4><p>border-radius:为元素添加圆角边框。<br>border-radius:10px 20px 30px 40px &#x2F; 40px 30px 20px 10px<br>“&#x2F;”前的四个数值表示圆角的水平半径，后面四个值表示圆角的垂直半径。</p>
<p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221013161227251.png"></p>
<pre><code class="css">比如：
border-radius: 2em 1em 4em / 0.5em 3em;
等同于：
border-top-left-radius: 2em 0.5em; //左上角
border-top-right-radius: 1em 3em; //右上角
border-bottom-right-radius: 4em 0.5em; //右下角
border-bottom-left-radius: 1em 3em; //左下角
</code></pre>
<p>常见简写方式：</p>
<ul>
<li>border-radius：30px&#x2F;20px；表示每个圆角的水平半径时30px,垂直半径为20px;</li>
<li>border-radius:30px; 等同于：border-radius：30px 30px 30px 30px&#x2F;30px 30px 30px 30px；</li>
</ul>
<h3 id="♥︎♥︎HTML5有哪些缓存方式？"><a href="#♥︎♥︎HTML5有哪些缓存方式？" class="headerlink" title="♥︎♥︎HTML5有哪些缓存方式？"></a>♥︎♥︎HTML5有哪些缓存方式？</h3><p>1、localstorege缓存，将数据储存在本地客户端，只有用户手动清除才能清除缓存</p>
<pre><code class="javascript">API：
    1.localstorege.setItem(key,value)，键值对的形式缓存
  2.localstorege.getItem(key)，根据键名来缓存值
  3.localstorege.length ，获取总缓存数量
</code></pre>
<p>2、sessionStorege 会话缓存，会话机制是指从打开浏览器开始访问页面的时候，到关闭这个页面的过程成为一个会话，sessionStorege储存的数据会随着页面关闭而销毁</p>
<pre><code class="javascript">API: 
    1. sessionStorage.setItem(key,val)，localStorage是以键值对的形式创建的；
  2. sessionStorage.getItem(key)，根据键名来获取缓存的值；
  3. sessionStorage.length；获取总共缓存值得数量， localStoarge返回的是个对象；
</code></pre>
<p>3、离线缓存机制(Application Cache)</p>
<pre><code class="javascript">一、配置manifest文件，manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）
二、manifest 文件可分为三个部分：
    1、CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存
    2、NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
    3、FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）
三、API： 0（UNCACHED） : 无缓存， 即没有与页面相关的应用缓存
    1 （IDLE） : 闲置，即应用缓存未得到更新
    2 （CHECKING） : 检查中，即正在下载描述文件并检查更新
    3 （DOWNLOADING） : 下载中，即应用缓存正在下载描述文件中指定的资源
    4 （UPDATEREADY） : 更新完成，所有资源都已下载完毕
    5 （IDLE） : 废弃，即应用缓存的描述文件已经不存在了，因此页面无法再访问应用缓存
</code></pre>
<p>4、web SQL</p>
<pre><code class="javascript">1. 关系数据库，通过SQL语句访问
2. Web SQL 数据库API并不是HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用SQL操作客户端数据库的APIs
3. 支持情况：Web SQL 数据库可以在最新版的 Safari, Chrome 和 Opera 浏览器中工作。
4. API：
    openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。
    transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。
    executeSql：这个方法用于执行实际的 SQL 查询。
</code></pre>
<p>5、 IndexDB</p>
<pre><code class="javascript">    索引数据库 (IndexedDB) API（作为 HTML5 的一部分）对创建具有丰富本地存储数据的数据密集型的离线 HTML5 Web 应用程序很有用。同时它还有助于本地缓存数据，使传统在线 Web 应用程序（比如移动 Web 应用程序）能够更快地运行和响应。
</code></pre>
<h3 id="♥︎♥︎CSS3新增伪类有那些"><a href="#♥︎♥︎CSS3新增伪类有那些" class="headerlink" title="♥︎♥︎CSS3新增伪类有那些"></a>♥︎♥︎CSS3新增伪类有那些</h3><pre><code class="javascript">常用的伪类：
     1. :link 选择所有未访问的链接
     2. :visited 选择所有访问过的链接
     3. :active 选择正在活动的链接（或理解为鼠标点击瞬间效果）
     4. :hover 鼠标放到链接后的状态
     5. :focus 选择元素输入后具有焦点
     6. :before 在元素之前插入内容
     7. :after 在元素之后插入内容
</code></pre>
<h3 id="♥︎♥︎什么叫做优雅降级和渐进增强？"><a href="#♥︎♥︎什么叫做优雅降级和渐进增强？" class="headerlink" title="♥︎♥︎什么叫做优雅降级和渐进增强？"></a>♥︎♥︎什么叫做优雅降级和渐进增强？</h3><h4 id="一、渐进增强-progressive-enhancement："><a href="#一、渐进增强-progressive-enhancement：" class="headerlink" title="一、渐进增强 progressive enhancement："></a>一、渐进增强 progressive enhancement：</h4><ol>
<li><p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
</li>
<li><p>渐进增强观点则认为应关注于内容本身。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p>
</li>
</ol>
<h4 id="二、优雅降级-graceful-degradation："><a href="#二、优雅降级-graceful-degradation：" class="headerlink" title="二、优雅降级 graceful degradation："></a>二、优雅降级 graceful degradation：</h4><ol>
<li><p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
</li>
<li><p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。</p>
</li>
</ol>
<p>‼️区别：</p>
<ol>
<li><p>优雅降级是从复杂的现状开始，并试图减少用户体验的供给</p>
</li>
<li><p>渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</p>
</li>
<li><p>降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>
</li>
</ol>
<h3 id="♥︎♥︎请问苹果原生浏览器中默认样式如何清除，例如button，input默认样式？"><a href="#♥︎♥︎请问苹果原生浏览器中默认样式如何清除，例如button，input默认样式？" class="headerlink" title="♥︎♥︎请问苹果原生浏览器中默认样式如何清除，例如button，input默认样式？"></a>♥︎♥︎请问苹果原生浏览器中默认样式如何清除，例如button，input默认样式？</h3><pre><code class="css">清除苹果默认样式：css样式中加入 
input,textarea,button &#123; 
  -webkit-appearance: none; 
  border-radius:0px; 
  border:none;
&#125;
input、button默认样式： 
input[type=&quot;button&quot;], input[type=&quot;submit&quot;], input[type=&quot;reset&quot;] &#123;
  -webkit-appearance: none;
&#125;
</code></pre>
<h3 id="♥︎♥︎PC端常用的布局方法。"><a href="#♥︎♥︎PC端常用的布局方法。" class="headerlink" title="♥︎♥︎PC端常用的布局方法。"></a>♥︎♥︎PC端常用的布局方法。</h3><h4 id="一、两列布局"><a href="#一、两列布局" class="headerlink" title="一、两列布局"></a>一、两列布局</h4><p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221013164125310.png"></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            /* 宽度适配 */
            html,
            body &#123;
                width: 100%;
                overflow-x: hidden;/* 外层盒子设置最小宽度的话看不到横向滚动条 */
            &#125;

            /*1. pc端适配的需求：目前我们pc项目的设计稿尺寸是宽度1920，高度最小是1080。
            2.放大或者缩小屏幕，网页可以正常显示 */
            /* 一、两列布局 */
            /* 1.左定宽 右边自适应 或者 右边定宽左边自适应 */
            .content&#123;
                width: 1200px; /* 主容器 */
                min-width: 960px;
                margin: 0 auto;
                background: #fff;
            &#125;
            .left &#123;
                float: left;
                width: 200px;/* 定宽 */
                background: #ccc;
                height: 800px;/* 测试设了一个高度和背景（为了更好看效果） */
            &#125;

            .right &#123;
                margin-left: 100px;
                background: #999;
                height: 800px;/* 测试设了一个高度和背景（为了更好看效果） */
            &#125;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;content&quot;&gt;
            &lt;div class=&quot;left&quot;&gt;左边&lt;/div&gt;
            &lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="二、三列布局"><a href="#二、三列布局" class="headerlink" title="二、三列布局"></a>二、三列布局</h4><p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221013164657269.png"></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            /* 宽度适配 */
            html,
            body &#123;
                width: 100%;
                overflow-x: hidden;
                /* 外层盒子设置最小宽度的话看不到横向滚动条 */
            &#125;
            /* 一、三列布局 */
            /* 1.左右定宽中间自适应 */
            .content &#123;
                width: 1200px;
                /* 主容器 */
                min-width: 960px;
                margin: 0 auto;
                background: firebrick;/* 测试设了一个背景（为了更好看效果） */
                display: table;
            &#125;

            .left &#123;
                width: 100px;
                /* 定宽 */
                background: #ccc;
                height: 800px;
                /* 测试设了一个高度和背景（为了更好看效果） */
            &#125;
            .right &#123;
                width: 100px;
                /* 定宽 */
                background: fuchsia;
                height: 800px;
                /* 测试设了一个高度和背景（为了更好看效果） */
            &#125;

            .left,
            .right,
            .center &#123;
                display: table-cell;
            &#125;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;content&quot;&gt;
            &lt;div class=&quot;left&quot;&gt;左边&lt;/div&gt;
            &lt;div class=&quot;center&quot;&gt;中间&lt;/div&gt;
            &lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="三、双飞翼布局"><a href="#三、双飞翼布局" class="headerlink" title="三、双飞翼布局"></a>三、双飞翼布局</h4><p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221013165000520.png"></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;实现三栏水平布局之双飞翼布局&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            .container &#123;
                width: 1200px;
                /* 主容器 */
                min-width: 960px;
                margin: 0 auto;
                background: #ccc;
                /* 测试设了一个背景（为了更好看效果） */
            &#125;

            .left,
            .center,
            .right &#123;
                float: left;
                min-height: 400px;
                /* 测试更好观看效果 统一高度*/
                text-align: center;
            &#125;

            .left &#123;
                margin-left: -100%;
                background: #0000FF;
                width: 200px;
                /* 定宽 */
            &#125;

            .right &#123;
                margin-left: -300px;
                background-color: #FF0000;
                width: 300px;
                /* 定宽 */
            &#125;

            .center &#123;
                background-color: #f2f1f1;
                width: 100%;
            &#125;

            .content &#123;
                margin: 0 300px 0 200px;
            &#125;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;container&quot;&gt;
            　　&lt;div class=&quot;center&quot;&gt;
                　　&lt;div class=&quot;content&quot;&gt;中间自适应&lt;/div&gt;
            　  &lt;/div&gt;
            　　&lt;div class=&quot;left&quot;&gt;左边&lt;/div&gt;
            　　&lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="四、圣杯布局"><a href="#四、圣杯布局" class="headerlink" title="四、圣杯布局"></a>四、圣杯布局</h4><p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/1186521-20190213150008412-487648273.png"></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;实现三栏水平布局之圣杯布局&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            .container &#123;
                width: 1200px;
                /* 主容器 */
                min-width: 960px;
                margin: 0 auto;
                background: #ccc;/* 测试设了一个背景（为了更好看效果） */
                padding: 0 300px 0 200px;
            &#125;

            .left,
            .center,
            .right &#123;
                position: relative;
                min-height: 200px;
                float: left;
            &#125;

            .left &#123;
                left: -200px;
                margin-left: -100%;
                background: green;/* 测试设了一个背景（为了更好看效果） */
                width: 200px;
            &#125;

            .right &#123;
                right: -300px;
                margin-left: -300px;
                background: red;/* 测试设了一个背景（为了更好看效果） */
                width: 300px;
            &#125;

            .center &#123;
                background: blue;/* 测试设了一个背景（为了更好看效果） */
                width: 100%;
            &#125;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;container&quot;&gt;
            　　&lt;div class=&quot;center&quot;&gt;center&lt;/div&gt;
            　　&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
            　　&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;tip_expand&quot;&gt;双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="五、flex弹性盒布局"><a href="#五、flex弹性盒布局" class="headerlink" title="五、flex弹性盒布局"></a>五、flex弹性盒布局</h4><p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221013165402722.png"></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;实现三栏水平布局-Flex布局&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            .container &#123;
                display: flex;
                width: 1200px;
                /* 主容器 */
                min-width: 960px;
                margin: 0 auto;
                background: #ccc;
                /* 测试设了一个背景（为了更好看效果） */
                min-height: 800px;
                font-size: 0; /* 间隙处理 */
            &#125;

            .main &#123;
                flex-grow: 1;
                background-color: blue;
                font-size: 24px;
            &#125;

            .left &#123;
                order: -1;/* 对于order属性：定义项目的排列顺序，越小越靠前，默认为0。 */
                flex-basis: 200px;/* 通过项目属性flex-basis 设置left和right的固定宽度 */
                background-color: green;
                font-size: 24px;
            &#125;

            .right &#123;
                flex-basis: 300px;/* 通过项目属性flex-basis 设置left和right的固定宽度 */
                background-color: red;
                font-size: 24px;
            &#125;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;container&quot;&gt;
            　　&lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;
            　　&lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
            　　&lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="♥︎♥︎行内元素和块级元素？img算什么？行内元素怎么转化为块元素？"><a href="#♥︎♥︎行内元素和块级元素？img算什么？行内元素怎么转化为块元素？" class="headerlink" title="♥︎♥︎行内元素和块级元素？img算什么？行内元素怎么转化为块元素？"></a>♥︎♥︎行内元素和块级元素？img算什么？行内元素怎么转化为块元素？</h3><pre><code class="css">行内元素：
    1. 无法设置宽高；
    2. 对margin仅设置左右有效，上下无效；
    3. padding上下左右有效；不会自动换行
块级元素：
    1. 可以设置宽高;
    2. margin和padding的上下左右均对其有效
    3. 超出当前行会自动换行
     4. 多个块状元素标签写在一起，默认排列方式为从上至下
img：属于行内块元素(inline-block),即有行内元素的属性也有块级元素的属性
元素之间的转化可以通过设置样式：display:block/inline/inline-block来改变自身的元素属性
</code></pre>
<h3 id="♥︎♥︎nth-of-type和nth-child的区别是什么？"><a href="#♥︎♥︎nth-of-type和nth-child的区别是什么？" class="headerlink" title="♥︎♥︎nth-of-type和nth-child的区别是什么？"></a>♥︎♥︎nth-of-type和nth-child的区别是什么？</h3><p>MDN上的概念：</p>
<p>某个元素:nth-of-type(n)这个CSS 伪类是针对具有一组兄弟节点的标签, 用 n 来筛选出在一组兄弟节点的位置。(一组标签内选择)</p>
<p>某个元素:nth-child(n)这个CSS 伪类首先找到所有当前元素的兄弟元素，, 用 n 来筛选出在当前元素的兄弟元素节点的位置。（兄弟元素里选择）</p>
<p>我们可以注意到:nth-of-type他是当前元素的兄弟元素的第n个，而nth-child是当前元素的兄弟节点的第n个当前元素。</p>
<h3 id="♥︎♥︎-before和-before区别是什么？"><a href="#♥︎♥︎-before和-before区别是什么？" class="headerlink" title="♥︎♥︎:before和 ::before区别是什么？"></a>♥︎♥︎:before和 ::before区别是什么？</h3><pre><code class="css">区别：
 1. 叫法不同：一个是伪类，一个是伪元素
 2. 版本不同：作用都是一样，但单冒号伪类写法是旧版本css2写法， 双冒号伪元素是新版本css3写法
 3. 兼容性差异：单冒号伪类写法 兼容性比 双冒号要好。 :before &gt; ::before
</code></pre>
<h3 id="♥︎♥︎简述-viewport所有属性"><a href="#♥︎♥︎简述-viewport所有属性" class="headerlink" title="♥︎♥︎简述 viewport所有属性"></a>♥︎♥︎简述 viewport所有属性</h3><pre><code class="css">width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。
height：和 width 相对应，指定高度。
initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例（调整页面缩放比例）。
maximum-scale：允许用户缩放到的最大比例。
minimum-scale：允许用户缩放到的最小比例。
user-scalable：用户是否可以手动缩放
</code></pre>
<h3 id="♥︎♥︎伪类选择器和伪元素？CSS3中引入的伪元素有什么？"><a href="#♥︎♥︎伪类选择器和伪元素？CSS3中引入的伪元素有什么？" class="headerlink" title="♥︎♥︎伪类选择器和伪元素？CSS3中引入的伪元素有什么？"></a>♥︎♥︎伪类选择器和伪元素？CSS3中引入的伪元素有什么？</h3><pre><code class="css">1. 伪类选择器是css2版本中的旧写法，相对于css3中伪元素的的新写法兼容性会更好。
2. 伪元素只能在一个选择器中出现一次，且需要配合content属性一起使用
3. 伪元素不会出现在DOM中，所以不能通过js来进行操作，仅仅是在渲染层加入而已

css3引入的伪元素：
 1、 ::after //在xxx之后插入内容
 2、 ::before // 在xxx之前插入内容
 3、 ::first-letter //选择xxx元素的首字母
 4、 ::first-line //选择xxx元素的首行
 5、 ::selection //选择用户选择的元素部分
</code></pre>
<h3 id="♥︎♥︎HTML5有哪些新特性，移除了哪些元素？如何处理HTML5"><a href="#♥︎♥︎HTML5有哪些新特性，移除了哪些元素？如何处理HTML5" class="headerlink" title="♥︎♥︎HTML5有哪些新特性，移除了哪些元素？如何处理HTML5"></a>♥︎♥︎HTML5有哪些新特性，移除了哪些元素？如何处理HTML5</h3><h4 id="HTML5-现在已经不是-SGML-的子集，主要是关于图像，位置，存储，多任务等功能的增加"><a href="#HTML5-现在已经不是-SGML-的子集，主要是关于图像，位置，存储，多任务等功能的增加" class="headerlink" title="HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加"></a>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加</h4><pre><code class="css">新增选择器 document.querySelector、document.querySelectorAll
拖拽释放(Drag and drop) API
媒体播放的 video 和 audio
本地存储 localStorage 和 sessionStorage
离线应用 manifest
桌面通知 Notifications
语意化标签 article、footer、header、nav、section
增强表单控件 calendar、date、time、email、url、search
地理位置 Geolocation
多任务 webworker
全双工通信协议 websocket
历史管理 history
跨域资源共享(CORS) Access-Control-Allow-Origin
页面可见性改变事件 visibilitychange
跨窗口通信 PostMessage
Form Data 对象
绘画 canvas
移除的元素：

纯表现的元素：basefont、big、center、font、 s、strike、tt、u
对可用性产生负面影响的元素：frame、frameset、noframes
</code></pre>
<h3 id="♥︎♥︎新标签兼容问题？如何区分HTML和HTML5？"><a href="#♥︎♥︎新标签兼容问题？如何区分HTML和HTML5？" class="headerlink" title="♥︎♥︎新标签兼容问题？如何区分HTML和HTML5？"></a>♥︎♥︎新标签兼容问题？如何区分HTML和HTML5？</h3><h4 id="支持HTML5新标签："><a href="#支持HTML5新标签：" class="headerlink" title="支持HTML5新标签："></a>支持HTML5新标签：</h4><p>IE8&#x2F;IE7&#x2F;IE6支持通过document.createElement方法产生的标签<br>可以利用这一特性让这些浏览器支持HTML5新标签<br>浏览器支持新标签后，还需要添加标签默认的样式<br>当然也可以直接使用成熟的框架、比如html5shim</p>
<h4 id="如何区分HTML和HTML5："><a href="#如何区分HTML和HTML5：" class="headerlink" title="如何区分HTML和HTML5："></a>如何区分HTML和HTML5：</h4><pre><code class="css">HTML： 

    1）标识文本（eg: 定义标题文本、段落文本、列表文本、预定义文本）；

     2）建立超链接，便于页面链接的跳转；

     3）创建列表，把信息有序地组织在一起，方便浏览；

     4）在网页中显示“图像、声音、视频、动画”等多媒体信息，使网页设计更具冲击力；

     5）可制作表格，以便显示大量数据；

     6）可制作表单，允许在网页内输入文本信息，执行其他用户操作，方便信息互动；

     7）没有体现结构语义化的标签;

HTML5： 

    1）用于绘画的canvas元素； 

    2）用于媒介回放的video和audio元素； 

    3）对本地离线存储有更好的支持； 

    4）新的特殊内容元素（eg: article、footer、header、nav、section等）； 

    5）新的表单控件（eg: calendar、date、time、email、url、search等）； 

    6）有语义优势，提供了一些新标签，（eg: &lt;header&gt; &lt;article&gt; &lt;footer&gt; 提供了语义化标 

签），可以更好地支持搜索引擎的读取，便于SEO蜘蛛的爬行。
</code></pre>
<h3 id="♥︎♥︎常见浏览器兼容性问题？"><a href="#♥︎♥︎常见浏览器兼容性问题？" class="headerlink" title="♥︎♥︎常见浏览器兼容性问题？"></a>♥︎♥︎常见浏览器兼容性问题？</h3><p>[常见浏览器兼容问题]: 	“<a href="https://blog.csdn.net/weixin_43214644/article/details/125872520">https://blog.csdn.net/weixin_43214644/article/details/125872520</a> “</p>
<h3 id="♥︎♥︎media属性？screen-All-max-width-min-width"><a href="#♥︎♥︎media属性？screen-All-max-width-min-width" class="headerlink" title="♥︎♥︎media属性？screen? All? max-width? min-width?"></a>♥︎♥︎media属性？screen? All? max-width? min-width?</h3><p>media： 媒体查询</p>
<p>screen ：计算机屏幕</p>
<p>All ：默认，适合所有设备</p>
<p>max(min)-width ：规定目标显示区域的宽度</p>
<p>css合并写法： @media screen and (min-width:xxxpx) {}</p>
<h3 id="♥︎♥︎-一般做手机页面切图的几种方式"><a href="#♥︎♥︎-一般做手机页面切图的几种方式" class="headerlink" title="♥︎♥︎ 一般做手机页面切图的几种方式"></a>♥︎♥︎ 一般做手机页面切图的几种方式</h3><p>针对手机端页面，通常情况下，需要对设计图片切两种图片。</p>
<p>①：dpr:2——切两倍图（即设计原图大小，因为设计图是按原来的手机尺寸放大两倍之后的）  一般保存为xxx@2x</p>
<p>②：dpr:3——切三倍图（即设计原图大小的1.5倍，因为设计图是按原来的手机尺寸放大两倍之后的）   一般保存为xxx@3x</p>
<p>例如：设计图是720px的宽度。</p>
<p>由于设计图是放大两倍的。所以一倍的大小是&#x3D;720&#x2F;2 &#x3D; 360px;</p>
<p>放大三倍图就是&#x3D; 360<em>3 &#x3D; 720</em>1.5 &#x3D; 1080px;</p>
<h3 id="♥︎♥︎px-x2F-em-x2F-rem有什么区别？为什么通常给font-size设置的字体为62-5"><a href="#♥︎♥︎px-x2F-em-x2F-rem有什么区别？为什么通常给font-size设置的字体为62-5" class="headerlink" title="♥︎♥︎px&#x2F;em&#x2F;rem有什么区别？为什么通常给font-size设置的字体为62.5%"></a>♥︎♥︎px&#x2F;em&#x2F;rem有什么区别？为什么通常给font-size设置的字体为62.5%</h3><p>px（像素）：页面默认的尺寸计算单位，绝对长度,它是相对于显示器屏幕分辨率而言的；</p>
<pre><code class="css">特点：
        1. IE无法调整那些使用px作为单位的字体大小；
        2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位； 
        3. Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。
</code></pre>
<p>em：相对长度，相对于应用在当前元素的字体尺寸；一般浏览器默认字体大小为16px，则 1em &#x3D; 16px</p>
<pre><code class="css">特点：1. em的值并不是固定的； 2. em会继承父级元素的字体大小。
</code></pre>
<p>rem（root em）：相对单位，相对于html根元素字体大小的单位，当html的font-size：16px时，</p>
<p>1rem &#x3D; 16px</p>
<pre><code class="css">特点：
        1. 这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。 
        2. 除了IE8及更早版本外，所有浏览器均已支持rem。
</code></pre>
<p>为什么给font-size设置为62.5%： 方便换算！</p>
<pre><code class="css">1. 因为绝大多数浏览器的默认字体大小为 16px ，而将font-size设置为 62.5% 则等价于字体大小的font-size:10px;
2. 随之在其他的换算单位，如 rem 的字体换算时，则可以表示为 1rem = 10px， 整数值对于单位的
换算会比较方便;
3. 但是在Chrome（谷歌浏览器）中，支持最小字体的大小为 12px ，解决办法就是 将html根字体设置为 font-size: 625%; 意：1rem = 100px ，以此单位换算;
</code></pre>
<h3 id="♥︎♥︎sass和scss有什么区别-sass一般怎么样编译的"><a href="#♥︎♥︎sass和scss有什么区别-sass一般怎么样编译的" class="headerlink" title="♥︎♥︎sass和scss有什么区别? sass一般怎么样编译的"></a>♥︎♥︎sass和scss有什么区别? sass一般怎么样编译的</h3><p>Sass和SCSS其实是同一种东西，我们平时称之为Sass，两者之间不同之处有以下两点：</p>
<p>1、文件扩展名不同，Sass是以“.sass”后缀为扩展名，而SCSS是以“.scss”后缀为扩展名<br>2、语法书写方式不同，Sass是以严格的缩进式语法规则来书写，不带大括号（{}）和分号（;），而SCSS的语法书写和我们的CSS语法书写方法非常类似。</p>
<h4 id="Sass语法"><a href="#Sass语法" class="headerlink" title="Sass语法"></a>Sass语法</h4><pre><code class="css">$font-stack:Helvetica,sans-serif //定义变量
$primary-color:#eee  //定义变量
 
html
  font:100% $font-stack
  color:$primary-color
</code></pre>
<h4 id="SCSS语法"><a href="#SCSS语法" class="headerlink" title="SCSS语法"></a>SCSS语法</h4><pre><code class="css">$font-stack:Helvetica,sans-serif //定义变量
$primary-color:#eee  //定义变量
 
html &#123;
  font:100% $font-stack
  color:$primary-color
&#125;
</code></pre>
<h3 id="♥︎♥︎如果对css进行优化如何处理？"><a href="#♥︎♥︎如果对css进行优化如何处理？" class="headerlink" title="♥︎♥︎如果对css进行优化如何处理？"></a>♥︎♥︎如果对css进行优化如何处理？</h3><p>优化原则：减少css样式的渲染加载时间，通过削减css样式的代码体积等相关操作</p>
<h4 id="实践型优化："><a href="#实践型优化：" class="headerlink" title="实践型优化："></a>实践型优化：</h4><p> 1、内联首屏关键CSS（Critical CSS）：内联CSS能够使浏览器开始页面渲染的时间提前,性能优化中有一个重要的指标——首次有效绘制（First Meaningful Paint，简称FMP）即指页面的首要内容（primary content）出现在屏幕上的时间,这一指标影响用户看到页面前所需等待的时间，而内联首屏关键CSS（即Critical CSS，可以称之为首屏关键CSS）能减少这一时间。</p>
<p>‼️注：内联css并不是不加以限制的，它的初始拥堵窗口3存在限制（TCP相关概念，通常是 14.6kb， 压缩后的大小），如果内联CSS后的文件超出了这一限制，系统就需要在服务器和浏览器之间进行更多次的往返，这样并不能提前页面渲染时间。</p>
<p>2、异步加载CSS ：CSS会阻塞渲染，在CSS文件请求、下载、解析完成之前，浏览器将不会渲染任何已处理的内容。 有时，这种阻塞是必须的，因为我们并不希望在所需的CSS加载之前，浏览器就开始渲染页面。 那么将首屏关键CSS内联后，剩余的CSS内容的阻塞渲染就不是必需的了，可以使用外部CSS，并且异步加载；</p>
<pre><code class="css">方式一、 使用JavaScript动态创建样式表link元素，并插入到DOM中。 
方式二、 将link元素的media属性设置为用户浏览器不匹配的媒体类型（或媒体查询），如 media=&quot;print&quot;，甚至可以是完全不存在的类型media=&quot;noexist&quot;。对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。
</code></pre>
<p> 3、文件压缩 </p>
<pre><code class="css">通过相关的构建工具对css样式进行打包压缩，去除多余的空格和换行。如 webpack、rollup、 
grunt/gulp.js 等 
</code></pre>
<p>4、去除无用CSS </p>
<pre><code class="css">1. 筛选去除相关重复的css样式 

2. 去除在页面中无法生效或不生效的css样式
</code></pre>
<h4 id="建议型优化："><a href="#建议型优化：" class="headerlink" title="建议型优化："></a>建议型优化：</h4><p> 1、有选择地使用选择器;</p>
<p>2、减少使用昂贵的属性;</p>
<pre><code class="css">1. 在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。 
2. 当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写CSS时，我们应该尽量减少使用昂贵 属性 * 昂贵属性： 如box-shadow/border-radius/filter/透明度/伪类:nth-child()等
</code></pre>
<p>3、优化重排与重绘;</p>
<pre><code class="css">减少重排 
        1. 重排会导致浏览器重新计算整个文档，重新构建渲染树，这一过程会降低浏览器的渲染速度。有 很多操作会触发重排，我们应该避免频繁触发这些操作。

避免不必要的重绘 
        1. 当元素的外观（如color，background，visibility等属性）发生改变时，会触发重绘。 
        2. 在网站的使用过程中，重绘是无法避免的。不过，浏览器对此做了优化，它会将多次的重排、重 绘操作合并为一次执行。 
        3. 不过我们仍需要避免不必要的重绘，如页面滚动时触发的hover事件，可以在滚动的时候禁用 hover事件，这样页面在滚动时会更加流畅。
</code></pre>
<p>4、不要使用@import;</p>
<pre><code class="css">不建议使用@import主要有以下两点原因。 
  1.使用@import引入CSS会影响浏览器的并行下载。
  2.使用@import引用的CSS文件只有在引用它的 那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始 解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。 
  3.多个@import会导致下载顺序紊乱。在IE中，@import会引发资源文件的下载顺序被打乱， 即排列在@import后面的js文件先于@import下载，并且打乱甚至破坏@import自身的并行下载.
</code></pre>
<h3 id="♥︎♥︎如何对css文件进行压缩合并-gulp如何实现？"><a href="#♥︎♥︎如何对css文件进行压缩合并-gulp如何实现？" class="headerlink" title="♥︎♥︎如何对css文件进行压缩合并? gulp如何实现？"></a>♥︎♥︎如何对css文件进行压缩合并? gulp如何实现？</h3><p>[Gulp压缩css]: 	“<a href="https://www.jianshu.com/p/00b3f479dc90">https://www.jianshu.com/p/00b3f479dc90</a> “</p>
<pre><code class="css">如何压缩合并：

通过相关的构建工具对css样式进行打包压缩，去除多余的空格和换行。如 webpack、rollup、
grunt/gulp.js 等
</code></pre>
<h3 id="♥︎♥︎a标签中active-hover-link-visited正确的设置顺序是什么"><a href="#♥︎♥︎a标签中active-hover-link-visited正确的设置顺序是什么" class="headerlink" title="♥︎♥︎a标签中active hover link visited正确的设置顺序是什么?"></a>♥︎♥︎a标签中active hover link visited正确的设置顺序是什么?</h3><pre><code class="css">a标签的设置顺序：
     1. link ， 链接平常的状态
     2. hover ，鼠标放置在链接上显示的样式
     3. active ，链接被按下的样式
     4. visited ， 链接被访问过后的状态
</code></pre>
<h3 id="♥︎♥︎常见的视频编码格式有几种？视频格式有几种？"><a href="#♥︎♥︎常见的视频编码格式有几种？视频格式有几种？" class="headerlink" title="♥︎♥︎常见的视频编码格式有几种？视频格式有几种？"></a>♥︎♥︎常见的视频编码格式有几种？视频格式有几种？</h3><pre><code class="css">常见的视频编码格式，H264 , VP8， AVS, RMVB，WMV，QuickTime（mov）

视频格式有MPEG、AVI、nAVI、ASF、MOV、3GP、WMV、DivX、XviD、RM、RMVB、FLV/F4V。
</code></pre>
<h3 id="♥︎♥︎canvas在标签上设置宽高和在style中设置宽高有什么区别？"><a href="#♥︎♥︎canvas在标签上设置宽高和在style中设置宽高有什么区别？" class="headerlink" title="♥︎♥︎canvas在标签上设置宽高和在style中设置宽高有什么区别？"></a>♥︎♥︎canvas在标签上设置宽高和在style中设置宽高有什么区别？</h3><p>  在canvas标签上设置宽高， canvas画布发生的变化不会影响到画布内容，即画布内容不会发生改变相反的，在style样式中设置宽高则会影响到画布内容的形状;</p>
<h3 id="♥︎♥︎canvas如何绘制一个三角形-正方形"><a href="#♥︎♥︎canvas如何绘制一个三角形-正方形" class="headerlink" title="♥︎♥︎canvas如何绘制一个三角形|正方形"></a>♥︎♥︎canvas如何绘制一个三角形|正方形</h3><p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221013174601774.png"></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
    canvas &#123;
        margin: 0 auto;
        border: 2px solid #aaa;
        display: block; /*画布居中*/
    &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id=&quot;cont&quot; width=&quot;500px&quot; height=&quot;500px&quot;&gt;Hello Canvas&lt;/canvas&gt;
    &lt;script&gt;
        
        //获取画布
        var canvas = document.querySelector(&quot;#cont&quot;);
        //获取画布上下文
        var ctx = canvas.getContext(&#39;2d&#39;);
        function drawLine(x1, y1, x2, y2, color, width) &#123;
            ctx.beginPath();  //开启一条路径
            ctx.moveTo(x1, y1); //确定起始点
            ctx.lineTo(x2, y2); //确定结束点
            ctx.strokeStyle = color;  //着色之前设置颜色和线宽
            ctx.lineWidth = width;
            ctx.stroke(); //着色
            ctx.closePath(); //结束路径
        &#125;
        drawLine(100, 100, 400, 100, &#39;green&#39;, 5);
        drawLine(400, 100, 400, 400, &#39;purple&#39;, 5);
        drawLine(400, 400, 100, 400, &#39;orange&#39;, 5);
        drawLine(100, 400, 100, 100, &#39;blue&#39;, 5);

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/image-20221013174702007.png"></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
    canvas &#123;
        margin: 0 auto;
        border: 2px solid #aaa;
        display: block; /*画布居中*/
    &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id=&quot;cont&quot; width=&quot;500px&quot; height=&quot;500px&quot;&gt;Hello Canvas&lt;/canvas&gt;
    &lt;script&gt;
        var canvas = document.querySelector(&quot;#cont&quot;);
        //获取画布上下文
        var ctx = canvas.getContext(&#39;2d&#39;);
        ctx.beginPath();
        ctx.moveTo(100, 100);
        //此处直线连用，画完三条线再关闭路径
        ctx.lineTo(400, 100);
        ctx.lineTo(400, 400);
        ctx.lineTo(100, 100);
        ctx.strokeStyle = &#39;purple&#39;;
        ctx.lineWidth = 5;
        ctx.stroke();
        ctx.closePath();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="♥︎♥︎解释下CSS-sprites，以及你要如何在页面或者网站中使用它。"><a href="#♥︎♥︎解释下CSS-sprites，以及你要如何在页面或者网站中使用它。" class="headerlink" title="♥︎♥︎解释下CSS sprites，以及你要如何在页面或者网站中使用它。"></a>♥︎♥︎解释下CSS sprites，以及你要如何在页面或者网站中使用它。</h3><pre><code class="css">css sprites直译过来就是CSS精灵。通常被解释为“CSS图像拼合”或“CSS贴图定位”。其实就是通过将多个图片融合到一张图里面，然后通过CSS background背景定位技术技巧布局网页背景。这样做的好处也是显而易见的，因为图片多的话，会增加http的请求，无疑促使了网站性能的减低，特别是图片特别多的网站，如果能用css sprites降低图片数量，带来的将是速度的提升。

css sprites是什么通俗解释：CSS Sprites其实就是把网页中一些背景图片整合拼合成一张图片中，再利用DIV CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片在布局盒子对象位置。

//如何使用
ps切好图，利用定位代码实现
</code></pre>
<h3 id="♥︎♥︎a点击出现框，解决方法。"><a href="#♥︎♥︎a点击出现框，解决方法。" class="headerlink" title="♥︎♥︎a点击出现框，解决方法。"></a>♥︎♥︎a点击出现框，解决方法。</h3><pre><code class="css">解决a标签点击会出现虚框现象。
    当a标签获得焦点的时候，a标签的周围就会出现虚框，它不同于border，不占任何宽度，a失去焦点的时候就会消失，就是outline。在遨游，Firefox ，IE的几个版本中就会看到、而Safari、Opera、Google 本身不支持这个效果，就看不到。

解决方法： 
    1、可以给a标签设置 outline： none；但在IE6、IE7 遨游中都不能实现。只有在IE8、Firefox中才会消除虚框。
    2、在a标签中加入js控制，当a标签活的焦点是就强制取消焦点。&lt;a href=&quot;#&quot;  onfocus=&quot;this.blur();&quot;&gt;&lt;/a&gt;,这里设置聚焦时触发blur()，强制取消焦点。
    3、在a标签里面嵌入其他标签，如span ，这样点击时，嵌套的标签活的焦点，a标签自然就不会出现虚框。
    4、不用a标签做链接，采用其他标签，用js控制实现点击跳转。
</code></pre>
<h3 id="♥︎♥︎CSS3中多列布局的用处是什么"><a href="#♥︎♥︎CSS3中多列布局的用处是什么" class="headerlink" title="♥︎♥︎CSS3中多列布局的用处是什么?"></a>♥︎♥︎CSS3中多列布局的用处是什么?</h3><p>多列布局是专门针对于文本（图文）排版的一种布局形式，作用对象是容器中的内容数据。<br>常见应用于电子杂志、阅读APP类型的项目，兼容性较好，IE10+及现代浏览器都支持（加前缀）</p>
<p>[多列布局属性]: 	“<a href="https://www.jianshu.com/p/6776f811b6d3">https://www.jianshu.com/p/6776f811b6d3</a> “</p>
<h3 id="♥︎♥︎WebSQL是什么？WebSQL是HTML5规范的一部分吗？"><a href="#♥︎♥︎WebSQL是什么？WebSQL是HTML5规范的一部分吗？" class="headerlink" title="♥︎♥︎WebSQL是什么？WebSQL是HTML5规范的一部分吗？"></a>♥︎♥︎WebSQL是什么？WebSQL是HTML5规范的一部分吗？</h3><p>WebSQl是前端的一个独立模块，是web存储方式的一种，用于存储或管理数据库中数据的网页。我们调试的时候会经常看到，只是一般很少使用。并且，当前只有谷歌支持，ie和火狐均不支持。</p>
<p>我们对数据库的一般概念是后端才会跟数据库打交道，进行一些业务性的增删改查。而这里的数据库也不同于真正意义上的数据库。</p>
<p>WebSQl API不是HTML5规范的一部分，而是一个单独的规范。它提供了一组API来操作客户数据库。</p>
<h3 id="♥︎♥︎介绍一下CSS的盒子模型？弹性盒子模型是什么？"><a href="#♥︎♥︎介绍一下CSS的盒子模型？弹性盒子模型是什么？" class="headerlink" title="♥︎♥︎介绍一下CSS的盒子模型？弹性盒子模型是什么？"></a>♥︎♥︎介绍一下CSS的盒子模型？弹性盒子模型是什么？</h3><p>盒子模型分为IE盒子和W3C盒子两种</p>
<pre><code class="css">W3C盒子（标准盒子模型）由margin，border，padding，content，设置的width height是针对content的
IE盒子（怪异盒子模型）由margin，border，padding，content构成，但是设置的width height是包括border+padding+content

弹性盒子模型：弹性盒模型决定一个盒子在其他盒子中的分布方式以及如何处理可用的空间；可以很轻松的创建自适应浏览器窗口的流动布局或自适应字体大小的弹性布局;

盒模型是CSS的基石之一，它指定元素如何显示以及如何相互交互。页面上的每个元素被看做一个矩形框，这个框由元素的内容、内边距、边框和外边距组成;
</code></pre>
<pre><code class="css">置为怪异盒模型，如何设置为怪异盒模型
如果在.html页面中缺少&lt;!doctype&gt;声明的话，就会触发怪异盒子模型
设置怪异盒子模型：通过box-sizing:border-box来设置怪异盒子模型
</code></pre>
<h3 id="♥︎♥︎Doctype的作用？标准模式与兼容模式各有什么区别？"><a href="#♥︎♥︎Doctype的作用？标准模式与兼容模式各有什么区别？" class="headerlink" title="♥︎♥︎Doctype的作用？标准模式与兼容模式各有什么区别？"></a>♥︎♥︎Doctype的作用？标准模式与兼容模式各有什么区别？</h3><pre><code class="css">一、Doctype作用
&lt;!DOCTYPE&gt;声明位于HTML文档中的第一行，处于&lt;html&gt;标签之前。告知浏览器的解析器用什么文档标准解析这个文档。
DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。

二、兼容模式与标准模式的区别
标准模式的排版和js运作模式，都是以该浏览器支持的最高标准运行。
在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。
</code></pre>
<h3 id="♥︎♥︎前端页面有哪三层构成？-分别是什么？-作用是什么？"><a href="#♥︎♥︎前端页面有哪三层构成？-分别是什么？-作用是什么？" class="headerlink" title="♥︎♥︎前端页面有哪三层构成？ 分别是什么？ 作用是什么？"></a>♥︎♥︎前端页面有哪三层构成？ 分别是什么？ 作用是什么？</h3><pre><code class="css">一、网页的**结构层(structural layer)**由HTML或XHTML之类的标记语言负责创建。
标记语言也就是指网页的标签，标签只对网页内容的语义和含义做出描述，不包含任何关于如何显示内容的信息。

二、网页的**表示层(resentation layer)**由CSS负责创建。
作用是对内容如何显示做一定的控制。

三、网页的**行为层(behavior layer)**由JavaScript语言和DOM创建。
作用是控制用户做出一个事件该如何显示。例如：用户悬浮在某个元素上，弹出一个显示元素标题内容的提示框
</code></pre>
<h3 id="♥︎♥︎rem和em。"><a href="#♥︎♥︎rem和em。" class="headerlink" title="♥︎♥︎rem和em。"></a>♥︎♥︎rem和em。</h3><p>rem和em很容易混淆，其实两个都是css的单位，并且也都是相对单位，现有的em，css3才引入的rem。</p>
<h4 id="一、em"><a href="#一、em" class="headerlink" title="一、em"></a>一、em</h4><p>em作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小——MDN</p>
<p>em可以让我们的页面更灵活，更健壮，比起到处写死的px值，em似乎更有张力，改动父元素的字体大小，子元素会等比例变化，这一变化似乎预示了无限可能</p>
<p>有些人提出用em来做弹性布局页面，但其复杂的计算让人诟病，甚至有人专门做了个px和em的计算器，不同节点像素值对应的em值。</p>
<p><img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/v2-efc617ae2b76557c376fcd3d2a78f6d6_r.jpg"></p>
<p>缺点：牵一发而动全身，一旦某个节点的字体大小发生变化，那么其后代元素都得重新计算。</p>
<h4 id="二、rem"><a href="#二、rem" class="headerlink" title="二、rem"></a>二、rem</h4><p>rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小——MDN</p>
<pre><code class="css">rem取值分为两种情况，设置在根元素时和非根元素时，举个例子

/* 作用于根元素，相对于原始大小（16px），所以html的font-size为32px*/
html &#123;font-size: 2rem&#125;

/* 作用于非根元素，相对于根元素字体大小，所以为64px */
p &#123;font-size: 2rem&#125;
</code></pre>
<p>本质：rem布局的本质是等比缩放，一般是基于宽度.</p>
<h3 id="♥︎♥︎pointer-events-none-是干什么的？"><a href="#♥︎♥︎pointer-events-none-是干什么的？" class="headerlink" title="♥︎♥︎pointer-events: none 是干什么的？"></a>♥︎♥︎pointer-events: none 是干什么的？</h3><pre><code class="css">pointer-events: none;理解：你可以看的到某个元素，但是你无法摸的着，点击不到，点击会穿透触发到下层的元素
display：none; 是你摸不着，但是你也看不见

大家都知道 input[type=text|button|radio|checkbox]支持 disabled 属性，可以实现事件的完全禁用。
如果其他标签需要类似的禁用效果，可以试试 pointer-events: none
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎-html中元素的margin是否会叠加（合并）？如何解决？"><a href="#♥︎♥︎♥︎-html中元素的margin是否会叠加（合并）？如何解决？" class="headerlink" title="♥︎♥︎♥︎ html中元素的margin是否会叠加（合并）？如何解决？"></a>♥︎♥︎♥︎ html中元素的margin是否会叠加（合并）？如何解决？</h3><pre><code class="css">/* 会叠加 */
问题详解1： flex布局对子元素的影响
 1.子元素的float、clear和vertical-align属性将会失效
 2.解决了margin传递、重叠（叠加）问题

问题详解2：flex布局的margin传递叠加问题主要有以下两种
 1.父子间的margin，会由子级传递到父级
 —— 解决方法： margin传递的产生的原因是父级的高度没有被自动撑开，所以在父级父级增加属
性：overflow: auto 即可解决
 2.兄弟间的margin值会重复叠加
 —— 解决方法： 浏览器为了保证列表的整齐，上下margin产生了叠加，不能直接解决。只能通过减
少一个margin的方式。如只定义margin-top:100px; margin-bottom:0px。的方式解决。
</code></pre>
<h3 id="♥︎♥︎♥︎-移动端适配怎么做？"><a href="#♥︎♥︎♥︎-移动端适配怎么做？" class="headerlink" title="♥︎♥︎♥︎ 移动端适配怎么做？"></a>♥︎♥︎♥︎ 移动端适配怎么做？</h3><pre><code class="css">方法一：@media 媒体查询，通过查询设备的宽度来执行不同的 css 代码，最终达到界面的配置。
方法二：Flex弹性布局
方法三：rem + viewport 缩放，屏幕宽度设定 rem 值，需要适配的元素都使用 rem 为单位，不需要适配的元素还是使用 px 为单位。
</code></pre>
<h3 id="♥︎♥︎♥︎-手机端上图片长时间点击会选中图片，如何处理？"><a href="#♥︎♥︎♥︎-手机端上图片长时间点击会选中图片，如何处理？" class="headerlink" title="♥︎♥︎♥︎ 手机端上图片长时间点击会选中图片，如何处理？"></a>♥︎♥︎♥︎ 手机端上图片长时间点击会选中图片，如何处理？</h3><pre><code class="css">img&#123; pointer-events:none &#125;，禁止事件，但会把整个标签的事件都禁用掉，不建议使用
img&#123; -webkit-user-select:none &#125;，用户选中状态

推荐：
img&#123;
       -webkit-touch-callout: none; //触摸
         -webkit-user-select: none;
         -moz-user-select: none;
         -ms-user-select: none;
         user-select: none;
 &#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-说说对transition的了解。"><a href="#♥︎♥︎♥︎-说说对transition的了解。" class="headerlink" title="♥︎♥︎♥︎ 说说对transition的了解。"></a>♥︎♥︎♥︎ 说说对transition的了解。</h3><p>1、transition 属性是一个简写属性，可用于设置四个过渡属性：</p>
<pre><code class="css">transition-property 过渡效果的 CSS 属性的名称（height、width、opacity等）。
transition-duration 完成过渡效果需要时间。
transition-timing-function 规定速度效果的速度曲线。
transition-delay 过渡效果何时开始（延迟时间）。
注：如果 transition-duration属性时长为 0，就不会产生过渡效果。
</code></pre>
<p>2、渐变函数的值：</p>
<p>渐变函数是transition-timing-function；</p>
<p>其中贝塞尔曲线的预设值</p>
<pre><code class="css">ease渐快，匀速，减慢cubic-bezier(0.25,0.1,0.25,1)
ease-in渐快，匀速cubic-bezier(0.42,0,1,1)
ease-out匀速，减慢cubic-bezier(0,0,0.58,1)
ease-in-out和ease类似，但比ease的加速度大（幅度大）cubic-bezier(0.42,0,0.58,1)
linear全程匀速cubic-bezier(0,0,1,1)
</code></pre>
<p>3、简写方式：</p>
<pre><code class="css">transition：css属性名 过度时间 渐变函数值 延迟时间
</code></pre>
<h3 id="♥︎♥︎♥︎-为什么要初始化CSS样式？"><a href="#♥︎♥︎♥︎-为什么要初始化CSS样式？" class="headerlink" title="♥︎♥︎♥︎ 为什么要初始化CSS样式？"></a>♥︎♥︎♥︎ 为什么要初始化CSS样式？</h3><p>1、浏览器差异</p>
<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>
<p>2、提高编码质量</p>
<p>初始化CSS可以节约网页代码，节约网页下载时间；还会使得我们开发网页内容时更加方便简洁，不用考虑很多。</p>
<p>如果不初始化，整个页面做完会很糟糕，重复的css样式很多。</p>
<p>我们在开发比较复杂的网页时候就不会知道自己是否已经设置了此处的CSS属性，是否和前面的CSS属性相同，是否统一整个网页的风格和样式。</p>
<p>‼️弊端：初始化样式会对seo有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>
<p>⁉️总结：CSS初始化是指重设浏览器的样式。不同的浏览器默认的样式可能不尽相同，所以开发时的第一件事可能就是如何把它们统一。如果没对CSS初始化往往会出现浏览器之间的页面差异。每次新开发网站或新网页时候通过初始化CSS样式的属性，为我们将用到的CSS或html标签更加方便准确，使得我们开发网页内容时更加方便简洁，同时减少CSS代码量，节约网页下载时间。</p>
<h3 id="♥︎♥︎♥︎-CSS3中的选择器都有什么？"><a href="#♥︎♥︎♥︎-CSS3中的选择器都有什么？" class="headerlink" title="♥︎♥︎♥︎ CSS3中的选择器都有什么？"></a>♥︎♥︎♥︎ CSS3中的选择器都有什么？</h3><p>[CSS3所有选择器讲解汇总]: 	“<a href="https://blog.csdn.net/weixin_44860226/article/details/126031813">https://blog.csdn.net/weixin_44860226/article/details/126031813</a> “</p>
<h3 id="♥︎♥︎♥︎-本地存储有生命周期吗？"><a href="#♥︎♥︎♥︎-本地存储有生命周期吗？" class="headerlink" title="♥︎♥︎♥︎ 本地存储有生命周期吗？"></a>♥︎♥︎♥︎ 本地存储有生命周期吗？</h3><p>没有</p>
<pre><code class="css">cookie: expire 和 max-age 都能控制数据的存储时间。expire 是一个绝对的过期时间，max-age是文档被访问之后的存活时间（是相对时间）。默认是 session。
sessionStorage 当会话被关闭后（浏览器、标签页被关闭），就会被清除。与 localStorage 用法一样。
localStorage: 除非被主动清除，不然永久储存在浏览器中。
IndexedDB: 没有过期时间，除非主动清除。
</code></pre>
<h3 id="♥︎♥︎♥︎-CSS选择符有哪些？优先级算法如何计算？"><a href="#♥︎♥︎♥︎-CSS选择符有哪些？优先级算法如何计算？" class="headerlink" title="♥︎♥︎♥︎ CSS选择符有哪些？优先级算法如何计算？"></a>♥︎♥︎♥︎ CSS选择符有哪些？优先级算法如何计算？</h3><p>问题一：对多个选择器使用的优先级是怎么进行计算的？</p>
<p>对于不同类别的选择器，以以下原则进行排序：</p>
<pre><code class="css">1、在属性后面使用！important会覆盖页面内任何位置定义的元素样式。

2、作为style属性写在元素内的样式

3、id选择器

4、类选择器

5、标签选择器

6、通配符选择器

7、浏览器自定义或子元素集成父类的样式

将上面的稍微总结一下就是：

！important&gt;行内样式&gt;ID选择器&gt;类选择器&gt;标签&gt;通配符&gt;继承&gt;浏览器默认属性

同一级别中后写的会覆盖先写的样式。
</code></pre>
<p>问题二：当不同类别的多个选择器混合使用个怎么计算优先级？</p>
<p>有一个简单的算法，设</p>
<p>a.内联样式表的权值为1000</p>
<p>b.ID选择器的权值为100</p>
<p>c.class类选择器的权值为10</p>
<p>d.HTML标签选择器的权值为1</p>
<p>[<img src="/2022/10/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E4%B9%8BHTML5-CSS3/attachments-2022-03-W59PaeQe6222c03c261ba.jpeg"></p>
<p>我们可以把选择器中规则对应多加法，比较权值，如果权值相同那就后面的覆盖前面的。如图，div.test1.test3的权值是1+10+10&#x3D;21，而.test1.test2.test3的权值是10+10+10&#x3D;30，所以div会应用.test1.test2.test3变成绿色。</p>
<h3 id="♥︎♥︎♥︎-iframe的优缺点？"><a href="#♥︎♥︎♥︎-iframe的优缺点？" class="headerlink" title="♥︎♥︎♥︎ iframe的优缺点？"></a>♥︎♥︎♥︎ iframe的优缺点？</h3><h4 id="iframe的优点："><a href="#iframe的优点：" class="headerlink" title="iframe的优点："></a>iframe的优点：</h4><p>1、iframe能够原封不动的把嵌入的网页展现出来;</p>
<p>2、如果有多个网页引用iframe，那么只需要修改iframe的内容，就可以实现调用每一个页面的更改，方便快捷;</p>
<p>3、网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe嵌套，可以增加代码的可重用;</p>
<p>4、如果遇到加载缓慢的第三方内容，如图标或广告，这些问题可以由iframe来解决;</p>
<h4 id="iframe的缺点："><a href="#iframe的缺点：" class="headerlink" title="iframe的缺点："></a>iframe的缺点：</h4><p>1、iframe会阻塞主页面的Onload事件;</p>
<p>2、iframe和主页面共享链接池，而浏览器对相同城的链接有限制，所以会影响页面的并行加载;</p>
<p>3、使用iframe之前需要考虑这两个缺点，如果需要使用iframe，最好是通过JavaScript;</p>
<p>4、动态给iframe添加src属性值，这样可以可以绕开以上两个问题</p>
<p>5、不利于seo</p>
<p>6、代码复杂，无法一下被搜索引擎索引到</p>
<p>7、iframe框架页面会增加服务器的http请求，对于大型网站不可取。</p>
<p>8、很多的移动设备无法完全显示框架，设备兼容性差。</p>
<h3 id="♥︎♥︎♥︎-DPR？"><a href="#♥︎♥︎♥︎-DPR？" class="headerlink" title="♥︎♥︎♥︎ DPR？"></a>♥︎♥︎♥︎ DPR？</h3><p>设备像素比DPR(devicePixelRatio)是默认缩放为100%的情况下，设备像素和CSS像素的比值</p>
<p>举例：</p>
<p>iPhone6的设备宽度是375px&#x2F;设备独立像素(或css像素)，但是它一行有750个像素颗粒，dpr就是2。</p>
<p>了解几个概念</p>
<pre><code class="css">1.设备像素
设备像素(device pixel)又称物理像素(physical pixel)，设备能控制显示的最小单位，我们可以把这些像素看作成显示器上一个个的点。

2.CSS 中的像素
CSS 中的像素是一个相对值，不是绝对值，因此1px 的 CSS 像素并不一定等于 1px 的物理像素。
需要注意的是，CSS 中的像素单位是抽象的，只是一种规范，最终的显示是取决于物理设备的。物理设备根据某种规则，决定该采用几个物理像素去显示 1px 的 CSS 像素，这个规则就是设备像素比。
CSS像素是一个抽象概念，设备无关像素，简称-“DIPS”，device-independent像素，主要使用在浏览器上，用来精确的度量(确定)Web页面上的内容。

3.PPI
像素密度(屏幕密度)，即每英寸所拥有的像素数目(比如：上面iPhone 7的PPI是326)，PPI数值越高，代表显示屏能够以越高的密度显示图像，画面的细节就会越丰富。

4.DPR:
设备像素比DPR(devicePixelRatio)是默认缩放为100%的情况下，设备像素和CSS像素的比值
dpr，也被成为device pixel ratio，即物理像素与逻辑像素的比，那也就不难理解：iphone6下dpr=2，iphone6+下dpr=3(考虑的是栅格化时的像素，并非真实的物理像素);
DPR = 设备像素 / CSS像素(某一方向上)
公式表示就是：window.devicePixelRatio = 物理像素(device pixel) / (设备无关像素/CSS像素/dips)
</code></pre>
<h3 id="♥︎♥︎♥︎-简述一下Sass，Less，请说明区别？"><a href="#♥︎♥︎♥︎-简述一下Sass，Less，请说明区别？" class="headerlink" title="♥︎♥︎♥︎ 简述一下Sass，Less，请说明区别？"></a>♥︎♥︎♥︎ 简述一下Sass，Less，请说明区别？</h3><p>一. Sass 和 Less 的定义</p>
<p>sass 与 less都是一种动态样式语言，对css赋予了一些动态语言特性</p>
<p>二. 它们的区别大致有以下几种</p>
<pre><code class="css">//编译环境不一样
sass的安装需要Ruby环境的，是在服务端上处理的；
而less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中

//变量符不一样
Less是@，而Scss是$
  
//输出设置
Less没有输出设置
Sass提供四种输出选项：
nested： 嵌套缩进的css代码
expanded：展示的多行css代码
compact：简洁格式的css代码
conpressed： 压缩后的css代码
Sass支持条件语句，可以使用if&#123;&#125;else&#123;&#125;，for&#123;&#125;循环等等，而Less不支持

//引入外部CSS文件
scss引用的外部文件命名必须以开头，文件名如果以下划线开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件

//Sass和Less的工具库不同
Sass有工具库 Compass
Less有UI组件库Bootstrap
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎♥︎重排（reflow）与重绘（repaint）"><a href="#♥︎♥︎♥︎♥︎重排（reflow）与重绘（repaint）" class="headerlink" title="♥︎♥︎♥︎♥︎重排（reflow）与重绘（repaint）"></a>♥︎♥︎♥︎♥︎重排（reflow）与重绘（repaint）</h3><p>[重排（reflow）与重绘（repaint）]: 	“<a href="https://blog.csdn.net/lhz_333/article/details/125001060">https://blog.csdn.net/lhz_333/article/details/125001060</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎BFC是什么东西"><a href="#♥︎♥︎♥︎♥︎BFC是什么东西" class="headerlink" title="♥︎♥︎♥︎♥︎BFC是什么东西"></a>♥︎♥︎♥︎♥︎BFC是什么东西</h3><h4 id="一、什么是BFC"><a href="#一、什么是BFC" class="headerlink" title="一、什么是BFC"></a>一、什么是BFC</h4><p>1、BFC即 Block Formatting Contexts (块级格式化上下文)， 是 W3C CSS2.1 规范中的一个概念。<br>2、BFC是指浏览器中创建了一个独立的渲染区域，并且拥有一套渲染规则，他决定了其子元素如何定位，以及与其他元素的相互关系和作用。</p>
<h4 id="二、BFC的特点"><a href="#二、BFC的特点" class="headerlink" title="二、BFC的特点"></a>二、BFC的特点</h4><p>1、具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>
<h4 id="三、BFC布局规则"><a href="#三、BFC布局规则" class="headerlink" title="三、BFC布局规则"></a>三、BFC布局规则</h4><p>内部的Box会在垂直方向，一个接一个地放置。<br>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠<br>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。<br>BFC的区域不会与float box重叠,而是紧贴浮动元素。<br>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>计算BFC的高度时，浮动元素也参与计算</p>
<h4 id="四、哪些元素会产生BFC"><a href="#四、哪些元素会产生BFC" class="headerlink" title="四、哪些元素会产生BFC"></a>四、哪些元素会产生BFC</h4><p>1、根元素<br>2、float属性不为none<br>3、position为absolute或fixed<br>4、 display为inline-block, table-cell, table-caption, flex, inline-flex<br>5、 overflow不为visible</p>
<h4 id="五、在布局中BFC的应用场景"><a href="#五、在布局中BFC的应用场景" class="headerlink" title="五、在布局中BFC的应用场景"></a>五、在布局中BFC的应用场景</h4><p>（1）清除盒子垂直方向上外边距合并——盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子垂直方向的margin会发生重叠。<br>解决方法：<br>根据属于同一个BFC的两个相邻盒子垂直方向的margin会发生重叠的性质，可以给其中一个盒子再包裹一个盒子父元素，并触发其BFC功能（例如添加overflow:hidden;）这样垂直方向的两个盒子就不在同一个BFC中了，因此也不会发生垂直外边距合并的问题了。<br>（2）在子元素设置成浮动元素的时候，会产生父元素高度塌陷的问题。<br>解决方法：<br>给父元素设置overflow:hidden；的时候会产生BFC<br>由于在计算BFC高度时，自然也会检测浮动的子盒子高度。所以当子盒子有高度但是浮动的时候，通过激发父盒子的BFC功能，会产生清除浮动的效果。</p>
<h3 id="♥︎♥︎♥︎♥︎flex布局有哪些属性"><a href="#♥︎♥︎♥︎♥︎flex布局有哪些属性" class="headerlink" title="♥︎♥︎♥︎♥︎flex布局有哪些属性"></a>♥︎♥︎♥︎♥︎flex布局有哪些属性</h3><h4 id="1）Flex布局父容器属性"><a href="#1）Flex布局父容器属性" class="headerlink" title="1）Flex布局父容器属性"></a>1）Flex布局父容器属性</h4><pre><code class="css">flex-direction / flex-wrap / flex-flow / justify-content / align-items / align-content
</code></pre>
<p>1》水平（主轴上）对齐方式：</p>
<pre><code class="css">justify-content：flex-start | flex-end | center | space-between | space-around;
flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，子元素间隔相等。
space-around：子元素两侧的间隔相等。
</code></pre>
<p>2》十字交叉轴上对齐方式</p>
<pre><code class="css">align-items：flex-start | flex-end | center | baseline | stretch;
flex-start：上对齐。
flex-end：下对齐。
center：交叉轴对齐。
baseline: 第一行文字的基线对齐。
stretch（默认值）：如果子元素未设置高度或设为auto，将占满整个容器。
</code></pre>
<p>3》项目排列方向</p>
<pre><code class="css">flex-direction：row | row-reverse | column | column-reverse;
row（默认值）：从左1/2/3/...。
row-reverse：从左../3/2/1。
column：从上1/2/3/...。
column-reverse：从上../3/2/1。
</code></pre>
<p>4》换行方式</p>
<pre><code class="css">flex-wrap：nowrap（不换行） | wrap（向下换） | wrap-reverse（向上换）;
</code></pre>
<p>5》flex-flow</p>
<pre><code class="css">flex-direction和flex-wrap的简写
flex-flow：row nowrap
</code></pre>
<p>6》多根轴线的对齐方式</p>
<pre><code class="css">align-content：flex-start | flex-end | center | space-between | space-around | stretch;
flex-start：上对齐。
flex-end：下对齐。
center：居中对齐。
space-between：两端对齐，间隔平均。
space-around：间隔相等。
stretch（默认值）：占满。
</code></pre>
<h4 id="2）Flex布局子元素属性"><a href="#2）Flex布局子元素属性" class="headerlink" title="2）Flex布局子元素属性"></a>2）Flex布局子元素属性</h4><pre><code class="css">order/flex-grow/flex-shrink/flex-basis/flex/align-self
</code></pre>
<p>1》order属性（num）</p>
<pre><code class="css">order定义自身排列顺序。数值越小，越靠前，默认为0。-1/0/1/2/3/...
</code></pre>
<p>2》flex-grow属性（num）</p>
<pre><code class="css">flex-grow 定义自身放大比例，默认为0不放大。例如：1/2/1=25%:50%:25%
</code></pre>
<p>3》flex-shrink属性（num）</p>
<pre><code class="css">flex-shrink定义了空间不足时自身缩小比例，默认为1自动缩小，0不缩小。
</code></pre>
<p>4》flex-basis属性</p>
<pre><code class="css">flex-basis定义最小空间，默认值为auto，即自身的本来大小。
</code></pre>
<p>5》flex属性</p>
<pre><code class="css">flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
</code></pre>
<p>6》align-self属性</p>
<pre><code class="css">align-self定义自身对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎单行或者多行文本溢出展示省略号的实现方法。"><a href="#♥︎♥︎♥︎♥︎单行或者多行文本溢出展示省略号的实现方法。" class="headerlink" title="♥︎♥︎♥︎♥︎单行或者多行文本溢出展示省略号的实现方法。"></a>♥︎♥︎♥︎♥︎单行或者多行文本溢出展示省略号的实现方法。</h3><p>在页面布局时，经常会遇到文本内容超出盒子的情况，如果要实现单行文本的溢出显示省略号,大家应该都知道用text-overflow:ellipsis属性，当然还需要加宽度width属来兼容部分浏览，接下来，我们一起看看。</p>
<pre><code class="css">//单行溢出 ... 显示
overflow:hidden;
text-overflow:ellipsis;
white-space:nowrap;
</code></pre>
<p>但是这个属性只支持单行文本的溢出显示省略号，如果我们要实现多行文本溢出显示省略号呢。接下来重点说一说多行文本溢出显示省略号，如下。</p>
<pre><code class="css">//多行溢出 ... 显示
display:-webkit-box;
-webkit-box-orient:vertical;
-webkit-line-clamp:3;
overflow:hidden;
</code></pre>
<p>‼️注：<br>1、-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：<br>2、display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。<br>3、-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</p>
<h3 id="♥︎♥︎♥︎♥︎position-sticky用过没，有啥效果？"><a href="#♥︎♥︎♥︎♥︎position-sticky用过没，有啥效果？" class="headerlink" title="♥︎♥︎♥︎♥︎position:sticky用过没，有啥效果？"></a>♥︎♥︎♥︎♥︎position:sticky用过没，有啥效果？</h3><p>[position:sticky 粘性定位的几种巧妙应用]: 	“<a href="https://www.bbsmax.com/A/qVdeoVOrJP/">https://www.bbsmax.com/A/qVdeoVOrJP/</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎说说你对GPU的理解，举例说明哪些元素能触发GPU硬件加速？"><a href="#♥︎♥︎♥︎♥︎说说你对GPU的理解，举例说明哪些元素能触发GPU硬件加速？" class="headerlink" title="♥︎♥︎♥︎♥︎说说你对GPU的理解，举例说明哪些元素能触发GPU硬件加速？"></a>♥︎♥︎♥︎♥︎说说你对GPU的理解，举例说明哪些元素能触发GPU硬件加速？</h3><pre><code class="css">GPU: 图形处理器,用于处理图形有关的任务,用于渲染页面
在css中使用 transform: translateZ(0),可以开启GPU硬件加速
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎纯CSS方式实现CSS动画的暂停与播放"><a href="#♥︎♥︎♥︎♥︎纯CSS方式实现CSS动画的暂停与播放" class="headerlink" title="♥︎♥︎♥︎♥︎纯CSS方式实现CSS动画的暂停与播放"></a>♥︎♥︎♥︎♥︎纯CSS方式实现CSS动画的暂停与播放</h3><p>动画控制要完成的效果是：</p>
<ol>
<li>页面 render 后，无任何操作，动画不会开始。只有当鼠标对元素进行 <code>click</code> ，触发元素的 <code>:active</code> 伪类效果的时候，动画才开始进行；</li>
<li>动画进行到任意时刻，鼠标停止点击，则动画停止；</li>
<li>重新对元素进行点击，动画继续从上一帧结束的状态开始</li>
<li>如果动画播放完，再点击不会重复播放，动画状态保留在动画的最后一帧</li>
</ol>
<pre><code class="css">//html
&lt;div&gt;&lt;/div&gt;

//css
div &#123;
    margin: 50px auto;
    width: 100px;
    height: 100px;
    background: #000;
    animation: move 1s linear;
    animation-fill-mode: forwards;
&#125;
@keyframes move &#123;
    100% &#123;
        transform: translate(200px, 0) rotate(180deg);
    &#125;
&#125;
</code></pre>
<pre><code class="css">div &#123;
    margin: 50px auto;
    width: 100px;
    height: 100px;
    background: #000;
    animation: move 1s linear;
    animation-fill-mode: forwards;
+   animation-play-state: paused; //添加了动画播放状态默认暂停
&#125;
</code></pre>
<p> 只有通过点击的时候，动画才会运行：</p>
<pre><code class="css">body:active div &#123;
    animation-play-state: running;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎使用CSS3动画代替JS动画的好处"><a href="#♥︎♥︎♥︎♥︎使用CSS3动画代替JS动画的好处" class="headerlink" title="♥︎♥︎♥︎♥︎使用CSS3动画代替JS动画的好处"></a>♥︎♥︎♥︎♥︎使用CSS3动画代替JS动画的好处</h3><h4 id="导致JavaScript效率低的两大原因：操作DOM和使用页面动画。"><a href="#导致JavaScript效率低的两大原因：操作DOM和使用页面动画。" class="headerlink" title="导致JavaScript效率低的两大原因：操作DOM和使用页面动画。"></a>导致JavaScript效率低的两大原因：操作DOM和使用页面动画。</h4><p>通常我们会通过频繁的操作 DOM的css来实现视觉上的动画效果，导致js效率低的两个因素都包括在内了在频繁的操作DOM和css时，浏览器会不停的执行重排和重绘，在PC版本的浏览器中，因为浏览器可用的内存比较大，用户肉眼几乎看不见页面动画产生的repaint和reflow，所以工程师几乎无需过多的考虑动画带来的性能问题，但在移动设备上可大有不同，移动设备分配给内置浏览器的内存可没有PC版本的浏览器内存可观，目前对CSS3支持最好的莫过于webkit浏览器了，在webkit内核的浏览器，一是safari其次是chrome. </p>
<h4 id="用CSS3动画替代js模拟动画的好处："><a href="#用CSS3动画替代js模拟动画的好处：" class="headerlink" title="用CSS3动画替代js模拟动画的好处："></a>用CSS3动画替代js模拟动画的好处：</h4><ul>
<li>不占用JS主线程；</li>
<li>可以利用硬件加速；</li>
<li>浏览器可对动画做优化（元素不可见时不动画减少对FPS影响）</li>
</ul>
<p>CSS3动画提供了2D和3D以及常规动画属性接口，它可以工作在页面的任何一个元素的任意一个属性，CSS3的动画是利用C语言编写的，它是系统层面的动画。</p>
<p>采用js动画还是css3动画，需要开发者根据不同的需求做出不同的抉择，但应该遵循一个基本的原则是：如果你需要做2D动画，请勿必使用CSS3的transition或animation</p>
<h4 id="CSS3动画与JavaScript模拟动画有以下区别："><a href="#CSS3动画与JavaScript模拟动画有以下区别：" class="headerlink" title="CSS3动画与JavaScript模拟动画有以下区别："></a>CSS3动画与JavaScript模拟动画有以下区别：</h4><ol>
<li>CSS 3D动画在js中无法实现<br>CSS3的3D动画是CSS3中非常强大的功能，因为它的工作原理是在一个三维的空间里，因此js是无法模拟出像CSS3那样的3D动画</li>
<li>CSS 2D矩阵动画效率高于js利用margin和left,top模拟的矩阵动画<br>CSS3的2D动画是指是2D矩阵Transform变化，js当然是不能做变形动画的。就拿坐标动画来说，使用CSS3的transform做translateXY动画比js中的position left，position right快了近700mm!而且视觉上也比js动画流畅很多。</li>
<li>CSS3其它常规动画属性的效率均低于js模拟的动画<br>常规动画属性在这里是指：height，width,opacity,border-width,color</li>
</ol>
<hr>
<h3 id="♥︎♥︎♥︎♥︎♥︎flex-1是什么"><a href="#♥︎♥︎♥︎♥︎♥︎flex-1是什么" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎flex:1是什么"></a>♥︎♥︎♥︎♥︎♥︎flex:1是什么</h3><p>[css弹性盒flex-grow、flex-shrink、flex-basis详解]: 	“<a href="https://www.qetool.com/scripts/view/24368.html">https://www.qetool.com/scripts/view/24368.html</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎移动端通用的1px边框的实现原理？"><a href="#♥︎♥︎♥︎♥︎♥︎移动端通用的1px边框的实现原理？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎移动端通用的1px边框的实现原理？"></a>♥︎♥︎♥︎♥︎♥︎移动端通用的1px边框的实现原理？</h3><p>[7种方法实现移动端屏幕1px边框效果]: 	“<a href="https://blog.csdn.net/z591102/article/details/106404049/">https://blog.csdn.net/z591102/article/details/106404049/</a> “</p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>HTML5+CSS3</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全React</title>
    <url>/2022/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8React/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（React-js）"><a href="#前端面试题大全（React-js）" class="headerlink" title="前端面试题大全（React.js）"></a>前端面试题大全（React.js）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h2><h3 id="♥︎♥︎-fetch的延时操作"><a href="#♥︎♥︎-fetch的延时操作" class="headerlink" title="♥︎♥︎  fetch的延时操作"></a>♥︎♥︎  fetch的延时操作</h3><pre><code class="javascript">// fetch语法：fetch(resource, config).then( function(response) &#123; ... &#125; )；resource为要获取的资源，
config是配置对象，包含method请求方法，headers请求头信息等
// 定义一个延时函数，返回一个promise
const delayPromise = (timeout=5000) =&gt; &#123;
 return new Promise((resolve, reject) =&gt; &#123;
 setTimeout(()=&gt;&#123;
 reject(new Error(&quot;网络错误&quot;))
 &#125;, timeout)
 &#125;)
&#125;
// 定义一个fetch网络请求，返回一个promise
const fetchPromise = (resource, config) =&gt; &#123;
 return new Promise((resolve, reject)=&gt;&#123;
 fetch(resource, config).then(res=&gt;&#123;
 resolve(res)
 &#125;)
 &#125;)
&#125;
// promise的race静态方法接受多个promise对象组成的数组，该数组中哪个promise先执行完成，race方法就返回这个promise的执行结果
const fetchRequest = (resource, config, timeout) =&gt; &#123;
 Promise.race([
 delayPromise(timeout), 
 fetchPromise(resource,config)
 ])
&#125;
</code></pre>
<h3 id="♥︎♥︎-A-组件嵌套-B-组件，生命周期执行顺序"><a href="#♥︎♥︎-A-组件嵌套-B-组件，生命周期执行顺序" class="headerlink" title="♥︎♥︎   A 组件嵌套 B 组件，生命周期执行顺序"></a>♥︎♥︎   A 组件嵌套 B 组件，生命周期执行顺序</h3><pre><code class="css">父组件创建阶段的生命周期钩子函数 constructor
父组件创建阶段的生命周期钩子函数 render
子组件创建阶段的生命周期钩子函数 constructor
子组件创建阶段的生命周期钩子函数 render
子组件创建阶段的生命周期钩子函数 componentDidMount
父组件创建阶段的生命周期钩子函数 componentDidMount

父-&gt;父-&gt;子-&gt;子-&gt;子-&gt;父
</code></pre>
<h3 id="♥︎♥︎-React-组件中-props-和-state-有什么区别？"><a href="#♥︎♥︎-React-组件中-props-和-state-有什么区别？" class="headerlink" title="♥︎♥︎  React 组件中 props 和 state 有什么区别？"></a>♥︎♥︎  React 组件中 props 和 state 有什么区别？</h3><p>1、props是从外部传入组件的参数，一般用于父组件向子组件通信，在组件之间通信使用；state一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等</p>
<p> 2、props不可以在组件内部修改，只能通过父组件进行修改；state在组件内部通过setState修改；</p>
<h3 id="♥︎♥︎-react中组件分为那两种？"><a href="#♥︎♥︎-react中组件分为那两种？" class="headerlink" title="♥︎♥︎ react中组件分为那两种？"></a>♥︎♥︎ react中组件分为那两种？</h3><p>类组件和函数组件</p>
<h3 id="♥︎♥︎-描述-Flux-与-MVC？"><a href="#♥︎♥︎-描述-Flux-与-MVC？" class="headerlink" title="♥︎♥︎ 描述 Flux 与 MVC？"></a>♥︎♥︎ 描述 Flux 与 MVC？</h3><p>传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</p>
<ol>
<li>数据流不够清晰——跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。</li>
<li>缺乏数据完整性——模型数据可以在任何地方发生突变，从而在整个UI中产生不可预测的结果。</li>
</ol>
<p>使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。</p>
<h3 id="♥︎♥︎-在-React-中使用构造函数和-getInitialState-有什么区别？"><a href="#♥︎♥︎-在-React-中使用构造函数和-getInitialState-有什么区别？" class="headerlink" title="♥︎♥︎ 在 React 中使用构造函数和 getInitialState 有什么区别？"></a>♥︎♥︎ 在 React 中使用构造函数和 getInitialState 有什么区别？</h3><pre><code class="react">// ES6
class MyComponent extends React.Component &#123;
constructor(props) &#123;
super(props);
this.state = &#123; /* initial state */ &#125;;
&#125;
&#125;
// ES5
var MyComponent = React.createClass(&#123;
getInitialState() &#123;
  return &#123; /* initial state */ &#125;;
&#125;,
&#125;);
</code></pre>
<p>本质上其实是等价的？</p>
<p>区别在于ES6和ES5本身，getInitialState 是搭配 React.createClass 使用的， constructor 是搭配React.Component 使用的,在React组件的生命周期中 constructor 先于 getInitialState</p>
<h3 id="♥︎♥︎-为什么说React是view（视图层）"><a href="#♥︎♥︎-为什么说React是view（视图层）" class="headerlink" title="♥︎♥︎ 为什么说React是view（视图层）"></a>♥︎♥︎ 为什么说React是view（视图层）</h3><p>react, 是 Facebook 推出的一个用来构建用户界面的 JavaScript 库. React 主要用于构建 UI</p>
<p>React被认为是视图层的框架是因为它是基于组件的，一切都是组件，而组件就是渲染页面的基础。不论组件中包含的jsx，methods，state，props，都是属于组件内部的</p>
<p>View（视图）是应用程序中处理数据显示的部分。视图层主要包括二个部分：</p>
<p>1.视图层显示及交互逻辑；</p>
<p>2.视图层的数据结构ViewObj， 包括React中的props和stats；</p>
<hr>
<h3 id="♥︎♥︎♥︎-React-事件绑定原理"><a href="#♥︎♥︎♥︎-React-事件绑定原理" class="headerlink" title="♥︎♥︎♥︎ React 事件绑定原理"></a>♥︎♥︎♥︎ React 事件绑定原理</h3><p>一、react并没有使用原生的浏览器事件，而是在基于Virtual DOM的基础上实现了合成事件，采用小驼峰命名法，默认的事件传播方式是冒泡，如果想改为捕获的话，直接在事件名后面加上Capture即可；事件对象event也不是原生事件对象，而是合成对象，但通过nativeEvent属性可以访问原生事件对象；</p>
<p>二、react合成事件主要分为以下三个过程：</p>
<p> 1、事件注册</p>
<p> 在该阶段主要做了两件事：document上注册、存储事件回调。所有事件都会注册到document上，</p>
<p>拥有统一的回调函数dispatchEvent来执行事件分发，类似于</p>
<pre><code class="javascript">document.addEventListener(&quot;click&quot;,dispatchEvent)。
 register:
 addEventListener-click
 addEventListener-change
listenerBank: 
&#123; 
click: &#123;key1: fn1, key2: fn2&#125;, 
change: &#123;key1: fn3, key3: fn4&#125; 
&#125; 
</code></pre>
<p>2、事件合成 </p>
<p>事件触发后，会执行一下过程： </p>
<p>（1）进入统一的事件分发函数dispatchEvent； </p>
<p>（2）找到触发事件的 ReactDOMComponent； </p>
<p>（3）开始事件的合成； </p>
<p>—— 根据当前事件类型生成指定的合成对象 </p>
<p>—— 封装原生事件和冒泡机制 </p>
<p>—— 查找当前元素以及他所有父级 </p>
<p>—— 在listenerBank根据key值查找事件回调并合成到 event(合成事件结束) </p>
<p>3、批处理</p>
<p> 批量处理合成事件内的回调函数</p>
<h3 id="♥︎♥︎♥︎-React中的-setState-缺点是什么呢"><a href="#♥︎♥︎♥︎-React中的-setState-缺点是什么呢" class="headerlink" title="♥︎♥︎♥︎ React中的 setState 缺点是什么呢"></a>♥︎♥︎♥︎ React中的 setState 缺点是什么呢</h3><p>setState执行的时候可以简单的认为，隶属于原生js执行的空间，那么就是属于同步，被react处理过的空间属于异步，这其实也是一种性能的优化，如果多次使用setState修改值，那么在异步中会先进行合并，再进行渲染，降低了操作dom的次数，具体如下：</p>
<p>（1）setState 在合成事件和钩子函数中是“异步”的，在原生事件和 <code>setTimeout</code> 中都是同步的。 </p>
<p>（2）setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更 新后的结果。 </p>
<p>（3）setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。 </p>
<p>（4）正是由于setState存在异步的机制，如果setState修改值的时候依赖于state本身的值，有时候并不可靠，这时候我们需要传入一个回调函数作为其入参，这个回调函数的第一个参数为更新前的state值。</p>
<h3 id="♥︎♥︎♥︎-React组件通信如何实现"><a href="#♥︎♥︎♥︎-React组件通信如何实现" class="headerlink" title="♥︎♥︎♥︎ React组件通信如何实现"></a>♥︎♥︎♥︎ React组件通信如何实现</h3><p>react本身:</p>
<p> (1) props ——父组件向子组件通过props传参</p>
<p> (2) 实例方法——在父组件中可以用 refs 引用子组件，之后就可以调用子组件的实例方法了</p>
<p> (3) 回调函数——用于子组件向父组件通信，子组件调用props传递过来的方法</p>
<p> (4) 状态提升——两个子组件可以通过父组件定义的参数进行传参</p>
<p> (5) Context上下文——一般用作全局主题</p>
<p> (6) Render Props——渲染的细节由父组件控制</p>
<p>状态管理: </p>
<p>(1) mobx&#x2F;redux&#x2F;dva——通过在view中触发action，改变state，进而改变其他组件的view</p>
<h3 id="♥︎♥︎♥︎-类组件和函数组件的区别"><a href="#♥︎♥︎♥︎-类组件和函数组件的区别" class="headerlink" title="♥︎♥︎♥︎ 类组件和函数组件的区别"></a>♥︎♥︎♥︎ 类组件和函数组件的区别</h3><p>（1）语法上：函数组件是一个函数，返回一个jsx元素，而类组件是用es6语法糖class定义，继承component这个类</p>
<p>（2）类组件中可以通过state进行状态管理，而在函数组件中不能使用setState()，在react16.8以后，函数组件可以通过hooks中的useState来模拟类组件中的状态管理；</p>
<p>（3）类组件中有一系列的生命周期钩子函数，在函数组件中也需要借助hooks来使用生命周期函数；</p>
<p>（4）类组件能够捕获最新的值（永远保持一致），这是因为当实例的props属性发生修改时，class组件能够直接通过this捕获到组件最新的props；而函数式组件是捕获渲染所使用的值，已经因为javascript闭包的特性，之前的props参数保存在内存之中，无法从外部进行修改。</p>
<h3 id="♥︎♥︎♥︎-请你说说React的路由是什么？"><a href="#♥︎♥︎♥︎-请你说说React的路由是什么？" class="headerlink" title="♥︎♥︎♥︎ 请你说说React的路由是什么？"></a>♥︎♥︎♥︎ 请你说说React的路由是什么？</h3><p>路由分为前端路由和后端路由，后端路由是服务器根据用户发起的请求而返回不同内容，前端路由是客户端根据不同的URL去切换组件；在web应用前端开发中，路由系统是最核心的部分，当页面的URL发生改变时，页面的显示结果可以根据URL的变化而变化，但是页面不会刷新。</p>
<p>react生态中路由通常是使用react-router来进行配置，其主要构成为：</p>
<p>（1）Router——对应路由的两种模式，包括与BrowserRouter与HashRoute； </p>
<p>（2）route matching组件——控制路径对应的显示组件，可以进行同步加载和异步加载； </p>
<p>（3）navigation组件——用做路由切换和跳转；</p>
<p>BrowserRouter与HashRouter的区别：</p>
<p>（1）底层原理不一样：BrowserRouter使用的是H5的history API，不兼容IE9及以下版本；HashRouter使用的是URL的哈希值；</p>
<p>（2）path表现形式不一样：BrowserRouter的路径中没有#,例如：localhost:3000&#x2F;demo&#x2F;test；HashRouter的路径包含#,例如：localhost:3000&#x2F;#&#x2F;demo&#x2F;test； </p>
<p>（3）刷新后对路由state参数的影响：BrowserRouter没有任何影响，因为state保存在history对象中；</p>
<p>react生态中路由通常是使用react-router来进行配置，其主要构成为： </p>
<p>BrowserRouter与HashRouter的区别：HashRouter刷新后会导致路由state参数的丢失；</p>
<h3 id="♥︎♥︎♥︎-聊聊-Redux-和-Vuex-的设计思想"><a href="#♥︎♥︎♥︎-聊聊-Redux-和-Vuex-的设计思想" class="headerlink" title="♥︎♥︎♥︎ 聊聊 Redux 和 Vuex 的设计思想"></a>♥︎♥︎♥︎ 聊聊 Redux 和 Vuex 的设计思想</h3><p>Flux的核心思想就是数据和逻辑永远单向流动，由三大部分组成 dispatcher(负责分发事件),store(负责保存数据，同时响应事件并更新数据)和 view(负责订阅store中的数据，并使用这些数据渲染相应的页面)，Redux和Vuex是flux思想的具体实现，都是用来做状态管理的工具，Redux主要在react中使用，Vuex主要在vue中使用。</p>
<pre><code class="css">Redux设计和使用的三大原则： 
（1）单一的数据源：整个应用的 state被储存在唯一一个 store中； 
（2）状态是只读的：Store.state不能直接修改（只读），必须调用dispatch(action) =&gt; store.reducer =&gt; return newState；action是一个对象，有type（操作类型）和payload（新值） 属性；
（3）状态修改均由纯函数完成：在Redux中，通过纯函数reducer来确定状态的改变，因为reducer是纯 函数，所以相同的输入，一定会得到相同的输出，同时也不支持异步；返回值是一个全新的state； 

vuex由State + Muatations(commit) + Actions(dispatch) 组成： 
（1）全局只有一个Store实例（单一数据源）；
（2）Mutations必须是同步事务，不同步修改的话，会很难调试，不知道改变什么时候发生，也很难确定 先后顺序，A、B两个mutation，调用顺序可能是A -&gt; B，但是最终改变 State的结果可能是B -&gt; A； 
（3）Actions负责处理异步事务，然后在异步回调中触发一个或多个mutations，也可以在业务代码中处 理异步事务，然后在回调中同样操作； 
（4）模块化通过module方式来处理，这个跟Redux-combineReducer类似，在应用中可以通过 namespaceHelper来简化使用；
</code></pre>
<h3 id="♥︎♥︎♥︎-React中不同组件之间如何做到数据交互？"><a href="#♥︎♥︎♥︎-React中不同组件之间如何做到数据交互？" class="headerlink" title="♥︎♥︎♥︎  React中不同组件之间如何做到数据交互？"></a>♥︎♥︎♥︎  React中不同组件之间如何做到数据交互？</h3><h4 id="正向传值–使用-props"><a href="#正向传值–使用-props" class="headerlink" title="正向传值–使用 props"></a>正向传值–使用 props</h4><p>父组件发送数据在子组件中使用 this.props.xxx 来接收数据，如果父级的某个props 改变了，React 会重渲染所有的子节点</p>
<h4 id="逆向传值—函数传值"><a href="#逆向传值—函数传值" class="headerlink" title="逆向传值—函数传值"></a>逆向传值—函数传值</h4><ul>
<li>子组件通过事件调用函数传递</li>
<li>在子组件中使用 this.props调用的函数名绑定发送数据。</li>
<li>在父组件中进行函数传递。</li>
<li>父组件中必须要有一个形参用来接收子组件发送过来的数据。</li>
</ul>
<h4 id="同级传值—pubsub-js"><a href="#同级传值—pubsub-js" class="headerlink" title="同级传值—pubsub-js"></a>同级传值—pubsub-js</h4><ul>
<li>在第一个要传值的组件中进行数据抛出 PubSub.publish(“ 事件名”,”数据”)。</li>
<li>在第二个要接收数据的组件中接收 PubSub.subscribe(“监听的事件”,(事件,数 据)&#x3D;&gt;{})。</li>
</ul>
<h4 id="跨组件传值—context"><a href="#跨组件传值—context" class="headerlink" title="跨组件传值—context"></a>跨组件传值—context</h4><p>context 上下文对象，无需为每一层组件手动添加 props，就能在组件数间进行数据传递的方法。<br>使用 createContext()方法提供了两个对象 - Provider 对象生产者—-&gt;用来生产数据 - Consumer对象消费者—-&gt;用来使用数据。</p>
<h3 id="♥︎♥︎♥︎-React中refs的作用是什么？"><a href="#♥︎♥︎♥︎-React中refs的作用是什么？" class="headerlink" title="♥︎♥︎♥︎ React中refs的作用是什么？"></a>♥︎♥︎♥︎ React中refs的作用是什么？</h3><p> ref是React提供的用来操纵React组件实例或者DOM元素的接口。主要用来做文本框的聚焦、触发强制动画等；</p>
<pre><code class="javascript">//类组件
class Foo extends React.Component &#123;
   constructor(props) &#123;
 super(props)
 this.myRef = React.createRef()
 &#125;
 render() &#123;
 return &#125;
  
&lt;input ref=&#123; this.myRef &#125; /&gt; &lt;button onClick = &#123;()=&gt;this.handle()&#125;&gt;聚焦
&#125; 
handle() &#123; 
 // 通过current属性访问到当前元素 this.myRef.current.focus() 
&#125; 
// 函数组件 function
Foo() &#123; const inputEl = useRef(null) const handle = () =&gt; &#123; inputEl.current.focus() &#125; 
return
&lt;input type=&quot;text&quot; ref=&#123; inputEl &#125;/&gt; 聚焦&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-组件绑定和js原生绑定事件哪个先执行？"><a href="#♥︎♥︎♥︎-组件绑定和js原生绑定事件哪个先执行？" class="headerlink" title="♥︎♥︎♥︎ 组件绑定和js原生绑定事件哪个先执行？"></a>♥︎♥︎♥︎ 组件绑定和js原生绑定事件哪个先执行？</h3><p> 先执行js原生绑定事件，再执行合成事件，因为合成事件是发生在冒泡阶段</p>
<h3 id="♥︎♥︎♥︎-diff-和-Key-之间的联系"><a href="#♥︎♥︎♥︎-diff-和-Key-之间的联系" class="headerlink" title="♥︎♥︎♥︎ diff 和 Key 之间的联系"></a>♥︎♥︎♥︎ diff 和 Key 之间的联系</h3><p>diff算法即差异查找算法，对于DOM结构即为tree的差异查找算法，只有在React更新阶段才会有Diff算法的运用；react的diff运算为了降低时间复杂度，是按层比较新旧两个虚拟dom树的。diff运算的主要流程见下：</p>
<pre><code class="css">1、tree diff : 新旧两棵dom树，逐层对比的过程就是 tree diff, 当整棵DOM树逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到。 
2、component diff ： 在进行tree diff的时候，每一层中，都有自己的组件，组件级别的对比， 叫做 component diff。如果对比前后，组件的类型相同，则暂时认为此组件不需要更新；如果对比前后， 组件的类型不同，则需要移除旧组件，创建新组件，并渲染到页面上。 React只会匹配类型相同的组件，也就是说如果&lt;A&gt;被&lt;B&gt;替换，那么React将直接删除A组件然后创建一 个B组件；如果某组件A转移到同层B组件上，那么这个A组件会先被销毁，然后在B组件下重新生成，以A为根节 点的树整个都被重新创建，这会比较耗费性能，但实际上我们很少跨层移动dom节点，一般都是同层横向移动； 
3、element diff ：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比， 这叫做element diff。 对于列表渲染，react会在创建时要求为每一项输入一个独一无二的key，这样就能进行高效的diff运算 了。比如我们要在b和c节点中间插入一个节点f，jquery会将f这个节点后面的每一个节点都进行更新，比如c 更新成f，d更新成c，e更新成d，这样操作的话就会特别多，而加了key的react咋不会频繁操作dom，而是优先采用移动的方式，找到正确的位置去插入新节点；所以我们不能省略key值，因为在对比两个新旧的子元素是通过key值来精确地判断两个节点是否为同一个，如果没有key的话则是见到谁就更新谁，非常耗费性能。 

当我们通过this.setState()改变数据的时候，React会将其标记为脏节点，在事件循环的最后 才会重新渲染所有的脏节点以及脏节点的子树；另外我们可以使用shouldComponentUpdate这个生命周期来 选择性的渲染子树，可以基于组件之前的状态或者下一个状态来决定它是否需要重新渲染，这样的话可以组织 重新渲染大的子树。
</code></pre>
<h3 id="♥︎♥︎♥︎-虚拟-dom-和原生-dom"><a href="#♥︎♥︎♥︎-虚拟-dom-和原生-dom" class="headerlink" title="♥︎♥︎♥︎ 虚拟 dom 和原生 dom"></a>♥︎♥︎♥︎ 虚拟 dom 和原生 dom</h3><p>（1）原生dom是浏览器通过dom树渲染的复杂对象，属性非常多；</p>
<p> （2）虚拟dom是存在于内存中的js对象，属性远少于原生的dom对象，它用来描述真实的dom，并不会直接在浏览器中显示；</p>
<p> （3）原生dom操作、频繁排版与重绘的效率是相当低的，虚拟dom则是利用了计算机内存高效的运算性能减少了性能的损耗；</p>
<p> （4）虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分，最后并在真实DOM中对修改部分进行排版与重绘，减少过多DOM节点排版与重绘损耗</p>
<h3 id="♥︎♥︎♥︎-react中如何打包上传图片文件"><a href="#♥︎♥︎♥︎-react中如何打包上传图片文件" class="headerlink" title="♥︎♥︎♥︎ react中如何打包上传图片文件"></a>♥︎♥︎♥︎ react中如何打包上传图片文件</h3><p>通过 base64 前端处理图片为 base64 的解决方案</p>
<ul>
<li>利用 FileReader 对数据进行读取，如果是图片会将图片读取为 base64 的形式</li>
<li>将得到的 base64 的字符串传给后端</li>
<li>后端直接保存该html字符串，之后调用接口查询该数据直接前端通过img标签完成自动解析即可</li>
</ul>
<p>代码实现：</p>
<pre><code class="react">function App() &#123;
  const handleFileChange = e =&gt; &#123;
    const file = e.currentTarget.files[0];
    const reader = new FileReader();

    reader.onload = function() &#123;
      // reader.results当完成onload后会将图片转为base64
      // 后端只要解析base64对应的字符串即可
      const result = this.result;
      console.log(result);
    &#125;;

    reader.readAsDataURL(file); // 得到经过base64编码的图片信息
  &#125;;

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;input type=&quot;file&quot; onChange=&#123;handleFileChange&#125; /&gt;
    &lt;/div&gt;
  );
&#125;
</code></pre>
<p>利用input,xhr,formData来实现</p>
<ul>
<li>利用input[type&#x3D;‘file’]来实现</li>
<li>点击选择文件，且选择文件完毕后，触发onChange事件</li>
<li>通过event.targer.files(react中)获取所选文件</li>
<li>通过FormData这个类，将文件添加到其实例中</li>
<li>配置xhr，通过POST的方式发送formData到后端即可</li>
</ul>
<p>代码实现：</p>
<pre><code class="react">import React, &#123; useState &#125; from &#39;react&#39;;
import &#123; ApiHost &#125; from &#39;../../constant&#39;;
import &#123; Button, FormControl, Progress &#125; from &#39;zent&#39;;

export type UploadCompletCallback&lt;T&gt; = (
  e: ProgressEvent&lt;XMLHttpRequestEventTarget&gt;,
  reponse: T
) =&gt; void;

export type UploadStartCallback = (
  e: ProgressEvent&lt;XMLHttpRequestEventTarget&gt;
) =&gt; void;

export type UploadProcessCallback = (loaded: number, total: number) =&gt; void;

interface Props &#123;
  onComplete?: UploadCompletCallback&lt;any&gt;;
  onStart?: UploadStartCallback;
  onProcess?: UploadProcessCallback;
  hasProcess?: boolean;
  title: string;
&#125;

export const UploadBtn: React.FC&lt;Props&gt; = props =&gt; &#123;
  const &#123; onComplete, onStart, onProcess, hasProcess = false, title &#125; = props;
  const [progress, setProgress] = useState&lt;number&gt;(0);
  const [uploadStatus, setStatus] = useState&lt;boolean&gt;(false);

  // 处理文件上传的核心方法
  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;
    const files = e.target.files;

    if (files) &#123;
      if (!files.length) return;

  // 将文件处理成formData
      let formData = new FormData();
      for (let k in files) &#123;
        formData.append(&#39;file&#39;, files[k], window.encodeURI(files[k].name));
      &#125;

      let xhr = new XMLHttpRequest();

      xhr.responseType = &#39;json&#39;;
      xhr.timeout = 5000;
      xhr.open(&#39;POST&#39;, `$&#123;ApiHost&#125;/user/upload`, true);

   // 事件监听
      xhr.addEventListener(&#39;loadstart&#39;, e =&gt; &#123;
        setProgress(0);
        setStatus(true);
        onStart &amp;&amp; onStart(e);
      &#125;);

      xhr.upload.onprogress = function(e) &#123;
        const &#123; total, loaded &#125; = e;
        setProgress((loaded / total) * 100);
        onProcess &amp;&amp; onProcess(loaded, total);
      &#125;;

      xhr.addEventListener(&#39;load&#39;, e =&gt; &#123;
        const result = xhr.response;
        onComplete &amp;&amp; onComplete(e, result);
      &#125;);

      xhr.send(formData);
    &#125; else &#123;
      return;
    &#125;
  &#125;;

  const selectFile = () =&gt; &#123;
    const btn = document.querySelector(&quot;input[type=&#39;file&#39;]&quot;);
    
 //@ts-ignore
    btn &amp;&amp; btn.click();
  &#125;;
  return (
    &lt;FormControl label=&#123;title&#125;&gt;
      &lt;input type=&quot;file&quot; onChange=&#123;handleChange&#125; style=&#123;&#123; display: 'none' &#125;&#125; /&gt;
      &lt;Button onClick=&#123;selectFile&#125;&gt;上传&lt;/Button&gt;
      &#123;hasProcess &amp;&amp; uploadStatus &amp;&amp; &lt;Progress percent=&#123;progress&#125;&gt;&lt;/Progress&gt;&#125;
    &lt;/FormControl&gt;
  );
&#125;;
</code></pre>
<p>后端对于该文件上传请求的处理nodejs版本</p>
<p>主要步骤：</p>
<ul>
<li>利用fs.createReadStream 来读取本地的传过去文件的地址</li>
<li>利用fs.createWriteStream来写到服务器上的某个文件地址</li>
<li>通过reader.pipe来将readFile里面的内容复制到writeFile中</li>
</ul>
<h3 id="♥︎♥︎♥︎-对单向数据流和双向数据绑定的理解，好处？"><a href="#♥︎♥︎♥︎-对单向数据流和双向数据绑定的理解，好处？" class="headerlink" title="♥︎♥︎♥︎ 对单向数据流和双向数据绑定的理解，好处？"></a>♥︎♥︎♥︎ 对单向数据流和双向数据绑定的理解，好处？</h3><p>react的单向数据流是指只允许父组件向子组件传递数据，子组件绝对不能修改父组件传的数据，如果想要修改数据，则要在子组件中执行父组件传递过来的回调函数，提醒父组件对数据进行修改。数据单向流让所有的状态改变可以追溯，有利于应用的可维护性；</p>
<p> angular中实现了双向数据绑定，代码编写方便，但是不利于维护</p>
<h3 id="♥︎♥︎♥︎-React-按需加载"><a href="#♥︎♥︎♥︎-React-按需加载" class="headerlink" title="♥︎♥︎♥︎ React 按需加载"></a>♥︎♥︎♥︎ React 按需加载</h3><p>1、使用React.lazy， 但是React.lazy技术还不支持服务端渲染</p>
<pre><code class="react">const OtherComponent = React.lazy(() =&gt; import(&#39;./OtherComponent&#39;))
</code></pre>
<p>2、使用Loadable Components这个库</p>
<pre><code class="react">import loadable from &#39;@loadable/component&#39;
const OtherComponent = loadable(() =&gt; import(&#39;./OtherComponent&#39;))
</code></pre>
<h3 id="♥︎♥︎♥︎-React-实现目录树（组件自身调用自身）"><a href="#♥︎♥︎♥︎-React-实现目录树（组件自身调用自身）" class="headerlink" title="♥︎♥︎♥︎ React 实现目录树（组件自身调用自身）"></a>♥︎♥︎♥︎ React 实现目录树（组件自身调用自身）</h3><p>需求描述：实现n级属性目录展开，该实现使用react，antd-mobile</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code class="react">import TreesMenu from &quot;./treeMenu.jsx&quot;;
&lt;TreesMenu
       datas=&#123;treesData&#125;
       onselected=&#123;item =&gt; &#123;
           console.log(&quot;选择了树形目录的数据：&quot;, item);
       &#125;&#125;
&gt;&lt;/TreesMenu&gt;
</code></pre>
<h4 id="实现数据"><a href="#实现数据" class="headerlink" title="实现数据"></a>实现数据</h4><pre><code class="react">export let treesData = [&#123;&quot;Childs&quot;:[&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;班子成员&quot;,&quot;ShortName&quot;:&quot;班子成员&quot;,&quot;DeptCode&quot;:&quot;81&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408498041056&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;调研员&quot;,&quot;ShortName&quot;:&quot;调研员&quot;,&quot;DeptCode&quot;:&quot;82&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408531598048&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;党政办公室&quot;,&quot;ShortName&quot;:&quot;党政办公室&quot;,&quot;DeptCode&quot;:&quot;83&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408548375776&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;党政办公室（财务）&quot;,&quot;ShortName&quot;:&quot;党政办公室（财务）&quot;,&quot;DeptCode&quot;:&quot;84&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408581929184&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;党建办公室&quot;,&quot;ShortName&quot;:&quot;党建办公室&quot;,&quot;DeptCode&quot;:&quot;85&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408598709728&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;平安办公室&quot;,&quot;ShortName&quot;:&quot;平安办公室&quot;,&quot;DeptCode&quot;:&quot;86&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408615482336&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;信访办公室&quot;,&quot;ShortName&quot;:&quot;信访办公室&quot;,&quot;DeptCode&quot;:&quot;87&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408632263392&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;管理办公室&quot;,&quot;ShortName&quot;:&quot;管理办公室&quot;,&quot;DeptCode&quot;:&quot;88&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408649039584&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;自治办公室&quot;,&quot;ShortName&quot;:&quot;自治办公室&quot;,&quot;DeptCode&quot;:&quot;89&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408665815776&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;综合事务办公室&quot;,&quot;ShortName&quot;:&quot;综合事务办公室&quot;,&quot;DeptCode&quot;:&quot;90&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408665819872&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;监察办公室&quot;,&quot;ShortName&quot;:&quot;监察办公室&quot;,&quot;DeptCode&quot;:&quot;91&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408682596576&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;武装部&quot;,&quot;ShortName&quot;:&quot;武装部&quot;,&quot;DeptCode&quot;:&quot;92&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408699368672&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;司法所&quot;,&quot;ShortName&quot;:&quot;司法所&quot;,&quot;DeptCode&quot;:&quot;93&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408699371232&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;城运中心&quot;,&quot;ShortName&quot;:&quot;城运中心&quot;,&quot;DeptCode&quot;:&quot;94&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408716144864&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;工会&quot;,&quot;ShortName&quot;:&quot;工会&quot;,&quot;DeptCode&quot;:&quot;95&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408749699296&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;团委&quot;,&quot;ShortName&quot;:&quot;团委&quot;,&quot;DeptCode&quot;:&quot;96&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408749700320&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;妇联&quot;,&quot;ShortName&quot;:&quot;妇联&quot;,&quot;DeptCode&quot;:&quot;97&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408749703648&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;房管办&quot;,&quot;ShortName&quot;:&quot;房管办&quot;,&quot;DeptCode&quot;:&quot;98&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408749704672&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;安监所&quot;,&quot;ShortName&quot;:&quot;安监所&quot;,&quot;DeptCode&quot;:&quot;99&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408766480352&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;党建服务中心&quot;,&quot;ShortName&quot;:&quot;党建服务中心&quot;,&quot;DeptCode&quot;:&quot;100&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408783258080&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;社区事务受理中心&quot;,&quot;ShortName&quot;:&quot;社区事务受理中心&quot;,&quot;DeptCode&quot;:&quot;101&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408816808672&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;社区文化中心&quot;,&quot;ShortName&quot;:&quot;社区文化中心&quot;,&quot;DeptCode&quot;:&quot;102&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408917476576&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;社区学校&quot;,&quot;ShortName&quot;:&quot;社区学校&quot;,&quot;DeptCode&quot;:&quot;103&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408951031264&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;绿化市容&quot;,&quot;ShortName&quot;:&quot;绿化市容&quot;,&quot;DeptCode&quot;:&quot;104&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408951033824&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;周家渡城管中队&quot;,&quot;ShortName&quot;:&quot;周家渡城管中队&quot;,&quot;DeptCode&quot;:&quot;105&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408967806688&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;商会&quot;,&quot;ShortName&quot;:&quot;商会&quot;,&quot;DeptCode&quot;:&quot;106&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408967810016&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;开发人员&quot;,&quot;ShortName&quot;:&quot;开发人员&quot;,&quot;DeptCode&quot;:&quot;107&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408967811040&#125;,&#123;&quot;Childs&quot;:[&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南八村&quot;,&quot;ShortName&quot;:&quot;上南八村&quot;,&quot;DeptCode&quot;:&quot;109&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409034918368&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南四村&quot;,&quot;ShortName&quot;:&quot;上南四村&quot;,&quot;DeptCode&quot;:&quot;110&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409051695840&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南五村&quot;,&quot;ShortName&quot;:&quot;上南五村&quot;,&quot;DeptCode&quot;:&quot;111&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409068471776&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南六村&quot;,&quot;ShortName&quot;:&quot;上南六村&quot;,&quot;DeptCode&quot;:&quot;112&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409102022368&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南七村&quot;,&quot;ShortName&quot;:&quot;上南七村&quot;,&quot;DeptCode&quot;:&quot;113&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409118800352&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南九村&quot;,&quot;ShortName&quot;:&quot;上南九村&quot;,&quot;DeptCode&quot;:&quot;114&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409135576544&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河一&quot;,&quot;ShortName&quot;:&quot;齐河一&quot;,&quot;DeptCode&quot;:&quot;115&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409152353760&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河二&quot;,&quot;ShortName&quot;:&quot;齐河二&quot;,&quot;DeptCode&quot;:&quot;116&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409152360928&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南十村1&quot;,&quot;ShortName&quot;:&quot;上南十村1&quot;,&quot;DeptCode&quot;:&quot;117&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409169135840&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南十二村&quot;,&quot;ShortName&quot;:&quot;上南十二村&quot;,&quot;DeptCode&quot;:&quot;118&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409185911520&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南十村2&quot;,&quot;ShortName&quot;:&quot;上南十村2&quot;,&quot;DeptCode&quot;:&quot;119&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409202686432&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南十一村&quot;,&quot;ShortName&quot;:&quot;上南十一村&quot;,&quot;DeptCode&quot;:&quot;120&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409219461344&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;都市庭院&quot;,&quot;ShortName&quot;:&quot;都市庭院&quot;,&quot;DeptCode&quot;:&quot;121&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409219466976&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;川新&quot;,&quot;ShortName&quot;:&quot;川新&quot;,&quot;DeptCode&quot;:&quot;122&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409236243680&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;雪野二村&quot;,&quot;ShortName&quot;:&quot;雪野二村&quot;,&quot;DeptCode&quot;:&quot;123&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409253021152&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南花苑&quot;,&quot;ShortName&quot;:&quot;上南花苑&quot;,&quot;DeptCode&quot;:&quot;124&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409269798368&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;昌里花园&quot;,&quot;ShortName&quot;:&quot;昌里花园&quot;,&quot;DeptCode&quot;:&quot;125&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409286570976&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;恒大&quot;,&quot;ShortName&quot;:&quot;恒大&quot;,&quot;DeptCode&quot;:&quot;126&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409303348192&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南三村&quot;,&quot;ShortName&quot;:&quot;上南三村&quot;,&quot;DeptCode&quot;:&quot;127&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409303353824&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南一村&quot;,&quot;ShortName&quot;:&quot;上南一村&quot;,&quot;DeptCode&quot;:&quot;128&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409320130784&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南二村&quot;,&quot;ShortName&quot;:&quot;上南二村&quot;,&quot;DeptCode&quot;:&quot;129&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409336908000&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;昌里五&quot;,&quot;ShortName&quot;:&quot;昌里五&quot;,&quot;DeptCode&quot;:&quot;130&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409353685728&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;云台一&quot;,&quot;ShortName&quot;:&quot;云台一&quot;,&quot;DeptCode&quot;:&quot;131&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409370462176&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;云台二&quot;,&quot;ShortName&quot;:&quot;云台二&quot;,&quot;DeptCode&quot;:&quot;132&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409387237344&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;云莲一&quot;,&quot;ShortName&quot;:&quot;云莲一&quot;,&quot;DeptCode&quot;:&quot;133&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409404012512&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;昌里七&quot;,&quot;ShortName&quot;:&quot;昌里七&quot;,&quot;DeptCode&quot;:&quot;134&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409420789472&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;动迁联合&quot;,&quot;ShortName&quot;:&quot;动迁联合&quot;,&quot;DeptCode&quot;:&quot;135&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409437567200&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河四&quot;,&quot;ShortName&quot;:&quot;齐河四&quot;,&quot;DeptCode&quot;:&quot;146&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409487902688&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河三&quot;,&quot;ShortName&quot;:&quot;齐河三&quot;,&quot;DeptCode&quot;:&quot;147&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409504677856&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;昌里四&quot;,&quot;ShortName&quot;:&quot;昌里四&quot;,&quot;DeptCode&quot;:&quot;148&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409521452768&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河八&quot;,&quot;ShortName&quot;:&quot;齐河八&quot;,&quot;DeptCode&quot;:&quot;149&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409538229984&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河五&quot;,&quot;ShortName&quot;:&quot;齐河五&quot;,&quot;DeptCode&quot;:&quot;150&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409555007968&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河七&quot;,&quot;ShortName&quot;:&quot;齐河七&quot;,&quot;DeptCode&quot;:&quot;151&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409555013600&#125;],&quot;DeptName&quot;:&quot;居委会&quot;,&quot;ShortName&quot;:&quot;居委会&quot;,&quot;DeptCode&quot;:&quot;108&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409034918112&#125;,&#123;&quot;Childs&quot;:[&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;办公室&quot;,&quot;ShortName&quot;:&quot;办公室&quot;,&quot;DeptCode&quot;:&quot;137&quot;,&quot;ParentID&quot;:2073409437571296,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409437571296,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409437571552&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;事务所&quot;,&quot;ShortName&quot;:&quot;事务所&quot;,&quot;DeptCode&quot;:&quot;138&quot;,&quot;ParentID&quot;:2073409437571296,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409437571296,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409454343904&#125;],&quot;DeptName&quot;:&quot;队伍建设办公室&quot;,&quot;ShortName&quot;:&quot;队伍建设办公室&quot;,&quot;DeptCode&quot;:&quot;136&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409437571296&#125;,&#123;&quot;Childs&quot;:[&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;办公室&quot;,&quot;ShortName&quot;:&quot;办公室&quot;,&quot;DeptCode&quot;:&quot;140&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409454347488&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;慈善超市&quot;,&quot;ShortName&quot;:&quot;慈善超市&quot;,&quot;DeptCode&quot;:&quot;141&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409471121632&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;残联&quot;,&quot;ShortName&quot;:&quot;残联&quot;,&quot;DeptCode&quot;:&quot;142&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409471122656&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;计生办&quot;,&quot;ShortName&quot;:&quot;计生办&quot;,&quot;DeptCode&quot;:&quot;143&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409471124448&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;爱卫办&quot;,&quot;ShortName&quot;:&quot;爱卫办&quot;,&quot;DeptCode&quot;:&quot;144&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409487897568&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;老龄办&quot;,&quot;ShortName&quot;:&quot;老龄办&quot;,&quot;DeptCode&quot;:&quot;145&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409487900896&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;居家养老服务中心&quot;,&quot;ShortName&quot;:&quot;居家养老服务中心&quot;,&quot;DeptCode&quot;:&quot;152&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2080463921349388&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;综合为老服务中心&quot;,&quot;ShortName&quot;:&quot;综合为老服务中心&quot;,&quot;DeptCode&quot;:&quot;153&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2080464005240076&#125;],&quot;DeptName&quot;:&quot;服务办公室&quot;,&quot;ShortName&quot;:&quot;服务办公室&quot;,&quot;DeptCode&quot;:&quot;139&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409454347232&#125;],&quot;DeptName&quot;:&quot;周家渡街道办事处&quot;,&quot;ShortName&quot;:&quot;周家渡街道办事处&quot;,&quot;DeptCode&quot;:&quot;SHRGBTRJJSYXGS &quot;,&quot;ParentID&quot;:0,&quot;Layer&quot;:0,&quot;Path&quot;:&quot;,0,&quot;,&quot;Sequence&quot;:11,&quot;LeaderID&quot;:0,&quot;ManagerID&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:1,&quot;ID&quot;:1,&quot;SystemID&quot;:1&#125;];
</code></pre>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="react">import React from &quot;react&quot;;
import &#123; Accordion, List &#125; from &quot;antd-mobile&quot;;

class TreesMenu extends React.Component &#123;
  render() &#123;
    let datas = this.props.datas;
    return (
      &lt;div&gt;
        &#123;datas instanceof Array ? (
          &lt;div&gt;
            &#123;datas.map((d, index) =&gt; &#123;
              return &lt;TreeNode datas=&#123;d&#125; key=&#123;index&#125; onselected=&#123;(item) =&gt; this.props.onselected(item)&#125;&gt;&lt;/TreeNode&gt;;
            &#125;)&#125;
          &lt;/div&gt;
        ) : (
          &lt;div&gt;请传入正确格式&lt;/div&gt;
        )&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;

export default TreesMenu;

class TreeNode extends React.Component &#123;
  renderItems(datas) &#123;
    return (
      &lt;List className=&quot;my-list&quot;&gt;
        &lt;List.Item&gt;content 1&lt;/List.Item&gt;
        &lt;List.Item&gt;content 2&lt;/List.Item&gt;
        &lt;List.Item&gt;content 3&lt;/List.Item&gt;
      &lt;/List&gt;
    );
  &#125;
  render() &#123;
    let data = this.props.datas;
    return data &amp;&amp; (!data.Childs || data.Childs.length === 0) ? (
      &lt;div&gt;
        &lt;List className=&quot;my-list&quot; onClick=&#123;() =&gt; &#123;
            this.props.onselected(data)
        &#125;&#125;&gt;
          &lt;List.Item&gt;&#123;data.DeptName&#125;&lt;/List.Item&gt;
        &lt;/List&gt;
      &lt;/div&gt;
    ) : (
      &lt;div&gt;
        &lt;Accordion
          onChange=&#123;this.onChange&#125;
        &gt;
          &lt;Accordion.Panel header=&#123;data.DeptName&#125; className=&quot;tree-accordion-panel&quot;&gt;
            &#123;data &amp;&amp; data.Childs &amp;&amp; data.Childs.map((item, index) =&gt; &#123;
              return &lt;TreeNode datas=&#123;item&#125; onselected=&#123;(item) =&gt; this.props.onselected(item)&#125; key=&#123;index&#125;&gt;&lt;/TreeNode&gt;;
            &#125;)&#125;
          &lt;/Accordion.Panel&gt;
        &lt;/Accordion&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-如果我进行三次setState会发生什么"><a href="#♥︎♥︎♥︎-如果我进行三次setState会发生什么" class="headerlink" title="♥︎♥︎♥︎ 如果我进行三次setState会发生什么"></a>♥︎♥︎♥︎ 如果我进行三次setState会发生什么</h3><p> 如果是在原生js空间，则会同步执行，修改三次state的值，调用三次render函数；</p>
<p>如果是在react函数空间下，则会进行合并，只修改一次state的值，调用一次render。</p>
<h3 id="♥︎♥︎♥︎-渲染一个react组件的过程"><a href="#♥︎♥︎♥︎-渲染一个react组件的过程" class="headerlink" title="♥︎♥︎♥︎ 渲染一个react组件的过程"></a>♥︎♥︎♥︎ 渲染一个react组件的过程</h3><pre><code class="css">1、babel编译
 当我们对代码进行编译的时候，babel会将我们在组件中编写的jsx代码转化为React.createElement的表达式，createElement方法有三个参数，分别为type(元素类型）、attributes(元素所有属性)、children(元素所有子节点)；2、生成element
 当render方法被触发以后，createElement方法会执行，返回一个element对象，这个对象描述了真实节点的信息，其实就是虚拟dom节点；
3、生成真实节点(初次渲染)
 这时候我们会判断element的类型，如果是null、false则实例一个ReactDOMEmptyComponent对 象; 是string、number类型的话则实例一个ReactDOMTextComponent对象； 如果element是对象的话，会进一步判断type元素类型，是原生dom元素，则实例化ReactDOMComponent； 如果是自定义组件，则实例化ReactCompositeComponentWrapper；在这些类生成实例对象的时候，在其内部会调用 mountComponent方法，这个方法里面有一系列浏览器原生dom方法，可以将element渲染成真实的dom并插入到文档中；
 4、生命周期
 componentDidMount：会在组件挂载后(插入DOM树中) 立即调用。一般可以在这里请求数据；
 componentDidUpdate：会在数据更新后立即调用，首次渲染不会执行此方法；可以在其中直接调用 setState，但必须用if语句进行判断，防止死循环；
 conponentWillUnmount：会在组件卸载及销毁之前调用，在此方法中执行必要的清理操作，如清除timer；
 static getDerivedStateFromProps(prps,state)：这个生命周期函数代替了componentWillMount和componentWillUpdate生命周期；props和state发生改变则调用，在初始化挂载及后续更新时都会被调用，返回一个对象来更新state，如果返回null则不更新任何内容；
 shouldComponentUpdate(nextProps,nextState)：这个生命周期函数的返回值用来判断React组件是否因为当前 state 或 props 更改而重新渲染，默认返回值是true；这个方法在初始化渲染或使用forceUpdate()时不会调用；当将旧的state的值原封不动赋值给新的state（即不改变state的值，但是调用了setState）和 无数据交换的父组件的重新渲染都会导致组件重新渲染，这时候都可以通过shouldComponentUpdate来优化。
</code></pre>
<h3 id="♥︎♥︎♥︎-useEffect-和-useLayoutEffect-的区别"><a href="#♥︎♥︎♥︎-useEffect-和-useLayoutEffect-的区别" class="headerlink" title="♥︎♥︎♥︎ useEffect 和 useLayoutEffect 的区别"></a>♥︎♥︎♥︎ useEffect 和 useLayoutEffect 的区别</h3><p>useEffect和useLayout都是副作用hooks，两则非常相似，同样都接收两个参数：</p>
<p> (1)第一个参数为函数，第二个参数为依赖列表，只有依赖更新时才会执行函数；返回一个函数，当页面刷新的或销毁的时候执行return后的代码；</p>
<p> (2)如果不接受第二个参数，那么在第一次渲染完成之后和每次更新渲染页面的时候，都会调用useEffect的回调函数；</p>
<blockquote>
<p>useEffect和 useLayout的主要区别就是他们的执行时机不同，在浏览器中js线程与渲染线程是互斥的，当js线程执行时，渲染线程呈挂起状态，只有当js线程空闲时渲染线程才会执行，将生成的 dom绘制。 </p>
<p>useLayoutEffect在js线程执行完毕即dom更新之后立即执行，而useEffect是在渲染结束后才执行，也就是说 useLayoutEffect比 useEffect先执行。</p>
</blockquote>
<h3 id="♥︎♥︎♥︎-hooks-的使用有什么注意事项"><a href="#♥︎♥︎♥︎-hooks-的使用有什么注意事项" class="headerlink" title="♥︎♥︎♥︎  hooks 的使用有什么注意事项"></a>♥︎♥︎♥︎  hooks 的使用有什么注意事项</h3><p>（1）只能在React函数式组件或自定义Hook中使用Hook。</p>
<p>（2）不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。</p>
<h3 id="♥︎♥︎♥︎-纯函数有什么特点，副作用函数特点"><a href="#♥︎♥︎♥︎-纯函数有什么特点，副作用函数特点" class="headerlink" title="♥︎♥︎♥︎ 纯函数有什么特点，副作用函数特点"></a>♥︎♥︎♥︎ 纯函数有什么特点，副作用函数特点</h3><p>纯函数与外界交换数据只有一个唯一渠道——参数和返回值；函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部。</p>
<p> 纯函数的优点：无状态，线程安全；纯函数相互调用组装起来的函数，还是纯函数；应用程序或者运行环境可以对纯函数的运算结果进行缓存，运算加快速度。</p>
<p> 函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。比如调接口、修改全局变量、抛出一个异常或以一个错误终止、打印到终端或读取用户输入、读取或写入一个文件等，所以说副作用是编程中最关键的部分，因为我们需要跟用户、跟数据进行交互。</p>
<h3 id="♥︎♥︎♥︎-在构造函数调用-super-并将-props-作为参数传入的作用是啥？"><a href="#♥︎♥︎♥︎-在构造函数调用-super-并将-props-作为参数传入的作用是啥？" class="headerlink" title="♥︎♥︎♥︎ 在构造函数调用 super 并将 props 作为参数传入的作用是啥？"></a>♥︎♥︎♥︎ 在构造函数调用 super 并将 props 作为参数传入的作用是啥？</h3><p>ES6 中在调用 super()方法之前，子类构造函数无法使用this引用，在react的类组件中也是如此；将props 参数传递给 super() 调用的主要原因是在子构造函数中能够通过this.props来获取传入的 props。</p>
<h3 id="♥︎♥︎♥︎-讲讲什么是-JSX-？"><a href="#♥︎♥︎♥︎-讲讲什么是-JSX-？" class="headerlink" title="♥︎♥︎♥︎ 讲讲什么是 JSX ？"></a>♥︎♥︎♥︎ 讲讲什么是 JSX ？</h3><p>JSX全称为JavaScript XML，是react中的一种语法糖，可以让我们在js代码中脱离字符串直接编写html代码；本身不能被浏览器读取，必须使用@babel&#x2F;preset-react和webpack等工具将其转换为传统的JS。</p>
<p> 主要有以下特点：</p>
<p> （1）类XML语法容易接受，结构清晰；</p>
<p> （2）增强JS语义；</p>
<p> （3）抽象程度高，屏蔽DOM操作，跨平台；</p>
<p> （4）代码模块化；</p>
<h3 id="♥︎♥︎♥︎-为什么不直接更新-state-呢？"><a href="#♥︎♥︎♥︎-为什么不直接更新-state-呢？" class="headerlink" title="♥︎♥︎♥︎ 为什么不直接更新 state 呢？"></a>♥︎♥︎♥︎ 为什么不直接更新 state 呢？</h3><p>如果试图直接更新 state ，则不会重新渲染组件；需要使用setState()方法来更新 state这样组件才会重新渲染；</p>
<h3 id="♥︎♥︎♥︎-这三个点-…-在-React-干嘛用的？"><a href="#♥︎♥︎♥︎-这三个点-…-在-React-干嘛用的？" class="headerlink" title="♥︎♥︎♥︎ 这三个点(…)在 React 干嘛用的？"></a>♥︎♥︎♥︎ 这三个点(…)在 React 干嘛用的？</h3><p> …是es6语法新出的规范，叫做展开运算符；在react中可以将对象或数组进行展开，让我们操作改变数据结构非常方便。</p>
<h3 id="♥︎♥︎♥︎-React-中的-useState-是什么？"><a href="#♥︎♥︎♥︎-React-中的-useState-是什么？" class="headerlink" title="♥︎♥︎♥︎ React 中的 useState() 是什么？"></a>♥︎♥︎♥︎ React 中的 useState() 是什么？</h3><p>useState是一个内置的React Hook，可以让我们在函数组件中像类组件一样使用state并且改变state的值。</p>
<h3 id="♥︎♥︎♥︎-React-中的StrictMode-严格模式-是什么？"><a href="#♥︎♥︎♥︎-React-中的StrictMode-严格模式-是什么？" class="headerlink" title="♥︎♥︎♥︎ React 中的StrictMode(严格模式)是什么？"></a>♥︎♥︎♥︎ React 中的StrictMode(严格模式)是什么？</h3><p>React的StrictMode是一种辅助组件，用包装组件，可以帮助我们编写更好的react组件，不会渲染出任何可见的ui；仅在开发模式下运行，它们不会影响生产构建，可以做以下检查：</p>
<p> （1）验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告；</p>
<p> （2）验证是否使用的已经废弃的方法，如果有，会在控制台给出警告；</p>
<p> （3）通过识别潜在的风险预防一些副作用。</p>
<h3 id="♥︎♥︎♥︎-为什么类方法需要绑定到类实例？"><a href="#♥︎♥︎♥︎-为什么类方法需要绑定到类实例？" class="headerlink" title="♥︎♥︎♥︎ 为什么类方法需要绑定到类实例？"></a>♥︎♥︎♥︎ 为什么类方法需要绑定到类实例？</h3><p> 在 JS 中，this 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:</p>
<h3 id="♥︎♥︎♥︎-这段代码有什么问题吗？"><a href="#♥︎♥︎♥︎-这段代码有什么问题吗？" class="headerlink" title="♥︎♥︎♥︎ 这段代码有什么问题吗？"></a>♥︎♥︎♥︎ 这段代码有什么问题吗？</h3><pre><code class="react">this.setState((prevState, props) =&gt; &#123;
 return &#123;
 streak: prevState.streak + props.count
 &#125;
&#125;)
// 没有问题
</code></pre>
<h3 id="♥︎♥︎♥︎-如何在-React-的-Props-上应用验证？"><a href="#♥︎♥︎♥︎-如何在-React-的-Props-上应用验证？" class="headerlink" title="♥︎♥︎♥︎ 如何在 React 的 Props 上应用验证？"></a>♥︎♥︎♥︎ 如何在 React 的 Props 上应用验证？</h3><p>1、使用PropTypes进行类型检查</p>
<p>PropTypes自React v15.5起，请使用这个库prop-types</p>
<p>2、What &amp; Why &amp; When</p>
<p>随着应用的不断增长，也是为了使程序设计更加严谨，我们通常需要对数据的类型（值）进行一些必要的验证。出于性能方面的考虑，propTypes仅在开发模式下进行检测,在程序运行时就能检测出错误，不能使用到用户交互提醒用户操作错误等，也可以使用Flow或者TypeScript做类型检查，后期建议用typescript进行替代更好</p>
<p>3、Where</p>
<ul>
<li>class组件</li>
<li>函数组件</li>
<li>React.memo高阶组件 可自行扩展</li>
<li>React.forwardRef组件 可自行扩展</li>
</ul>
<p>4、How</p>
<p>我们在组件类下添加一个静态属性 propTypes (属性名不能更改)，它的值也是一个对象，用来设置组件中props的验证规则，key 是要验证的属性名称，value 是验证规则。</p>
<pre><code class="react">// 类组件
import PropTypes from &#39;prop-types&#39;;
class Greeting extends React.Component &#123;
 render() &#123;
 return ()
 &#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-如何有条件地向-React-组件添加属性？"><a href="#♥︎♥︎♥︎-如何有条件地向-React-组件添加属性？" class="headerlink" title="♥︎♥︎♥︎ 如何有条件地向 React 组件添加属性？"></a>♥︎♥︎♥︎ 如何有条件地向 React 组件添加属性？</h3><p>对于某些属性，React足够智能可以忽略该属性，比如值为boolean值属性的值也可以写控制语句管理是否给组件添加属性</p>
<h3 id="♥︎♥︎♥︎-如何避免组件的重新渲染？"><a href="#♥︎♥︎♥︎-如何避免组件的重新渲染？" class="headerlink" title="♥︎♥︎♥︎ 如何避免组件的重新渲染？"></a>♥︎♥︎♥︎ 如何避免组件的重新渲染？</h3><ol>
<li>当porps&#x2F;state改变时组件会执行render函数也就是重新渲染</li>
<li>class组件中使用shouldComponentUpdate钩子函数</li>
<li>PureComponent默认有避免重新渲染的功能</li>
<li>函数组件使用高阶组件memo处理</li>
</ol>
<h3 id="♥︎♥︎♥︎-什么是纯函数？"><a href="#♥︎♥︎♥︎-什么是纯函数？" class="headerlink" title="♥︎♥︎♥︎ 什么是纯函数？"></a>♥︎♥︎♥︎ 什么是纯函数？</h3><p>一个不会更改入参，且多次调用下相同的入参始终返回相同的结果</p>
<h3 id="♥︎♥︎♥︎-如何避免在React重新绑定实例？"><a href="#♥︎♥︎♥︎-如何避免在React重新绑定实例？" class="headerlink" title="♥︎♥︎♥︎ 如何避免在React重新绑定实例？"></a>♥︎♥︎♥︎ 如何避免在React重新绑定实例？</h3><ol>
<li>将事件处理程序定义为内联箭头函数</li>
<li>使用箭头函数来定义方法</li>
<li>使用带有 Hooks 的函数组件</li>
</ol>
<h3 id="♥︎♥︎♥︎-在js原生事件中-onclick-和-jsx-里-onclick-的区别"><a href="#♥︎♥︎♥︎-在js原生事件中-onclick-和-jsx-里-onclick-的区别" class="headerlink" title="♥︎♥︎♥︎ 在js原生事件中 onclick 和 jsx 里 onclick 的区别"></a>♥︎♥︎♥︎ 在js原生事件中 onclick 和 jsx 里 onclick 的区别</h3><p>1、js原生中</p>
<p>onclick添加事件处理函数是在全局环境下执行，污染了全局环境，且给很多dom元素添加onclick事件，影响网页的性能，同时如果动态的从dom树种删除了该元素，还要手动注销事件处理器，不然就可能造成内存泄露</p>
<p>2、jsx里的onClick</p>
<p>挂载的函数都控制在组件范围内，不会污染全局空间</p>
<p>jsx中不是直接使用onclick，而是采取了事件委托的方式，挂载最顶层DOM节点，所有点击事件被这个事件捕获，然后根据具体组件分配给特定函数，性能当然比每个onClick都挂载一个事件处理函数要高，加上React控制了组件的生命周期，在unmount的时候自然能够清除相关的所有事件处理函数，内存泄露不再是一个问题</p>
<h3 id="♥︎♥︎♥︎-React组件间信息传递"><a href="#♥︎♥︎♥︎-React组件间信息传递" class="headerlink" title="♥︎♥︎♥︎ React组件间信息传递"></a>♥︎♥︎♥︎ React组件间信息传递</h3><p>1.（父组件）向（子组件）传递信息 : porps传值</p>
<p>2.（父组件）向更深层的（子组件） 进行传递信息 : context</p>
<p>3.（子组件）向（父组件）传递信息：callback</p>
<p>4.没有任何嵌套关系的组件之间传值（比如：兄弟组件之间传值）: 利用共同父组件context通信、自定义事件</p>
<p>5.利用react-redux进行组件之间的状态信息共享 : 组件间状态信息共享：redux、flux、mobx等</p>
<h3 id="♥︎♥︎♥︎-React状态管理工具有哪些？redux-actionCreator都有什么？"><a href="#♥︎♥︎♥︎-React状态管理工具有哪些？redux-actionCreator都有什么？" class="headerlink" title="♥︎♥︎♥︎ React状态管理工具有哪些？redux actionCreator都有什么？"></a>♥︎♥︎♥︎ React状态管理工具有哪些？redux actionCreator都有什么？</h3><p>简单状态管理：组件内部state、基于Context API封装</p>
<p>复杂状态管理：redux(单项数据流)、mobx(响应式数据流)、RxJS(stream)、dva</p>
<p>创建各种action，包含同步、异步，然后在组件中通过dispatch调用</p>
<h3 id="♥︎♥︎♥︎-vuex-和-redux-的区别？"><a href="#♥︎♥︎♥︎-vuex-和-redux-的区别？" class="headerlink" title="♥︎♥︎♥︎  vuex 和 redux 的区别？"></a>♥︎♥︎♥︎  vuex 和 redux 的区别？</h3><h4 id="vuex的流向："><a href="#vuex的流向：" class="headerlink" title="vuex的流向："></a>vuex的流向：</h4><p>view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作）<br>view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作）</p>
<h4 id="redux的流向："><a href="#redux的流向：" class="headerlink" title="redux的流向："></a>redux的流向：</h4><p>view——&gt;actions——&gt;reducer——&gt;state变化——&gt;view变化（同步异步一样）</p>
<h4 id="Redux相对于Flux的改进："><a href="#Redux相对于Flux的改进：" class="headerlink" title="Redux相对于Flux的改进："></a>Redux相对于Flux的改进：</h4><p>（1）把store和Dispatcher合并,结构更加简单清晰</p>
<p>新增state角色，代表每个时间点store对应的值，对状态的管理更加明确</p>
<p>Redux数据流的顺序是:</p>
<p>（2）View调用store.dispatch发起Action-&gt;store接受Action(action传入reducer函数,reducer函数返回一个新的state)-&gt;通知store.subscribe订阅的重新渲染函数</p>
<p>Vuex是专门为Vue设计的状态管理框架, 同样基于Flux架构，并吸收了Redux的优点</p>
<h4 id="Vuex相对于Redux的不同点有"><a href="#Vuex相对于Redux的不同点有" class="headerlink" title="Vuex相对于Redux的不同点有:"></a>Vuex相对于Redux的不同点有:</h4><p>（1）改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch,只需在对应的mutation函数里改变state值即可</p>
<p>（2）由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</p>
<p>（3）Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变(vue检测到数据变化自动渲染)</p>
<h3 id="♥︎♥︎♥︎-Redux遵循的三个原则是什么？"><a href="#♥︎♥︎♥︎-Redux遵循的三个原则是什么？" class="headerlink" title="♥︎♥︎♥︎  Redux遵循的三个原则是什么？"></a>♥︎♥︎♥︎  Redux遵循的三个原则是什么？</h3><p>1、单一数据源</p>
<p>整个应用的state被存储在一棵object tree中，并且整个 object tree 只存在于唯一一个 store 中</p>
<p>2、State是只读的</p>
<p>唯一改变state的方法就是触发 action，action是一个描述已发生事件的普通对象，这样确保视图和网络请求不能直接修改state</p>
<p>3、使用纯函数来执行修改</p>
<p>为了描述action如何改变state tree，你需要编写reducers</p>
<h3 id="♥︎♥︎♥︎-React中的keys的作用是什么？"><a href="#♥︎♥︎♥︎-React中的keys的作用是什么？" class="headerlink" title="♥︎♥︎♥︎  React中的keys的作用是什么？"></a>♥︎♥︎♥︎  React中的keys的作用是什么？</h3><p>key 是用来帮助 react 识别哪些内容被更改、添加或者删除。key 需要写在用数组渲染出来的元素内部，并且需要赋予其一个稳定的值。稳定在这里很重要，因为如果 key 值发生了变更，react 则会触发 UI 的重渲染。这是一个非常有用的特性。</p>
<p>1、key 的唯一性</p>
<p>在相邻的元素间，key 值必须是唯一的，如果出现了相同的 key，同样会抛出一个 Warning，告诉相邻组件间有重复的 key 值。并且只会渲染第一个重复 key 值中的元素，因为 react 会认为后续拥有相同key 的都是同一个组件。</p>
<p>2、key 值不可读</p>
<p>虽然我们在组件上定义了 key，但是在其子组件中，我们并没有办法拿到 key 的值，因为 key 仅仅是给react 内部使用的。如果我们需要使用到 key 值，可以通过其他方式传入，比如将 key 值赋给 id 等</p>
<h3 id="♥︎♥︎♥︎-redux中使用setState不能立刻获取值，怎么办"><a href="#♥︎♥︎♥︎-redux中使用setState不能立刻获取值，怎么办" class="headerlink" title="♥︎♥︎♥︎  redux中使用setState不能立刻获取值，怎么办"></a>♥︎♥︎♥︎  redux中使用setState不能立刻获取值，怎么办</h3><p>setState 只在合成事件和钩子函数中是异步的，在原生事件和 setTimeout 中都是同步</p>
<p>①addeventListener添加的事件或者dom事件中触发</p>
<p>②setState接收的参数还可以是一个函数，在这个函数中可以拿先前的状态，并通过这个函数的返回值得到下一个状态。</p>
<pre><code class="react"> this.setState((preState) =&gt; &#123;
 return &#123;
 xxx: preState.xxx + yyy
 &#125;
&#125;)
</code></pre>
<p>③async&#x2F;await 异步调用处理</p>
<h3 id="♥︎♥︎♥︎-React新老版生命周期函数"><a href="#♥︎♥︎♥︎-React新老版生命周期函数" class="headerlink" title="♥︎♥︎♥︎  React新老版生命周期函数"></a>♥︎♥︎♥︎  React新老版生命周期函数</h3><h4 id="New-Version"><a href="#New-Version" class="headerlink" title="New Version"></a>New Version</h4><p>挂载：constructor –&gt; getDerivedStateFromProps –&gt; render –&gt; componentDidMount</p>
<p>更新：</p>
<p>setState() –&gt; getDerivedStateFromProps –&gt; shouldComponentUpdate –&gt; render –&gt;getSnapshotBeforeUpdate –&gt; componentDidUpdate</p>
<p>forceUpdate() –&gt; getDerivedStateFromProps –&gt; render –&gt; getSnapshotBeforeUpdate –&gt;componentDidUpdate</p>
<p>卸载： componentWillUnmount</p>
<h4 id="Old-Version"><a href="#Old-Version" class="headerlink" title="Old Version"></a>Old Version</h4><p>挂载：constructor –&gt; getDerivedStateFromProps –&gt; render –&gt; ComponentDidMount</p>
<p>更新：</p>
<p>New props –&gt; getDerivedStateFromProps –&gt; shouldComponentUpdate –&gt; render –&gt;getSnapshotBeforeUpdate –&gt; componentDidUpdate</p>
<p>setState() –&gt; shouldComponentUpdate –&gt; render –&gt; getSnapshotBeforeUpdate –&gt;componentDidUpdate</p>
<p>forceUpdate() –&gt; render –&gt; getSnapshotBeforeUpdate –&gt; componentDidUpdate</p>
<p>卸载：componentWillUnmount</p>
<h3 id="♥︎♥︎♥︎-React中怎么让-setState-同步更新？"><a href="#♥︎♥︎♥︎-React中怎么让-setState-同步更新？" class="headerlink" title="♥︎♥︎♥︎ React中怎么让 setState 同步更新？"></a>♥︎♥︎♥︎ React中怎么让 setState 同步更新？</h3><p>setState 回调，setState,第二个参数是一个回调函数，可实现同步</p>
<p>引入 Promise 封装 setState，在调用时我们可以使用 Async&#x2F;Await 语法来优化代码风格</p>
<pre><code class="react">setStateAsync(state) &#123;
 return new Promise((resolve) =&gt; &#123;
 this.setState(state, resolve)
 &#125;);
&#125;

//传入状态计算函数， setState 的第一个参数，
this.setState((prevState, props) =&gt; (&#123; count: prevState.count + 1
&#125;));

//在 setTimeout 函数中调用 setState
</code></pre>
<h3 id="♥︎♥︎♥︎-为什么不建议在-componentWillMount-做AJAX操作"><a href="#♥︎♥︎♥︎-为什么不建议在-componentWillMount-做AJAX操作" class="headerlink" title="♥︎♥︎♥︎ 为什么不建议在 componentWillMount 做AJAX操作"></a>♥︎♥︎♥︎ 为什么不建议在 componentWillMount 做AJAX操作</h3><p>Fiber原因，React16之后，采用了Fiber架构，只有componentDidMount的生命周期函数确定会执行一次，其他像componentWillMount可能会执行多次</p>
<p>render 阶段 可能会被React暂停，中止或重启</p>
<h3 id="♥︎♥︎♥︎-怎么用useEffect模拟生命周期函数？"><a href="#♥︎♥︎♥︎-怎么用useEffect模拟生命周期函数？" class="headerlink" title="♥︎♥︎♥︎ 怎么用useEffect模拟生命周期函数？"></a>♥︎♥︎♥︎ 怎么用useEffect模拟生命周期函数？</h3><ul>
<li>默认函数组件没有生命周期</li>
<li>函数组件是一个纯函数，执行完即销毁，自己无法实现生命周期</li>
<li>通过Effect hook把生命周期“钩”到纯函数中</li>
</ul>
<pre><code class="react">    // 模拟 class 组件的 DidMount 和 DidUpdate
    useEffect(() =&gt; &#123;
      console.log(&#39;在此发送一个 ajax 请求&#39;)
    &#125;)
 
    // 模拟 class 组件的 DidMount
     useEffect(() =&gt; &#123;
        console.log(&#39;加载完了&#39;)
     &#125;, []) // 第二个参数是 [] （不依赖于任何 state）
 
     // 模拟 class 组件的 DidUpdate
     useEffect(() =&gt; &#123;
         console.log(&#39;更新了&#39;)
     &#125;, [count, name]) // 第二个参数就是依赖的 state
 
    // 模拟 class 组件的 DidMount
    useEffect(() =&gt; &#123;
        let timerId = window.setInterval(() =&gt; &#123;
            console.log(Date.now())
        &#125;, 1000)
 
        // 返回一个函数
        // 模拟 WillUnMount 组件销毁的时候 停止计时器
        return () =&gt; &#123;
            window.clearInterval(timerId)
        &#125;
    &#125;, [])
</code></pre>
<ul>
<li>模拟componentDidMount  -  useEffect 依赖 [ ]</li>
<li>模拟compenentDidUpdate - useEffect 无依赖 ，或者 依赖 [a,b,c]</li>
<li>模拟componentWillUnMount - useEffect 中返回一个函数</li>
</ul>
<h3 id="♥︎♥︎♥︎-各种useEffect使用情况？"><a href="#♥︎♥︎♥︎-各种useEffect使用情况？" class="headerlink" title="♥︎♥︎♥︎ 各种useEffect使用情况？"></a>♥︎♥︎♥︎ 各种useEffect使用情况？</h3><p>1、默认情况下，它在第一次渲染之后和每次更新之后都会执行，无需清除的effect</p>
<pre><code class="react">// 在函数式组件中 在 return之前
// Similar to componentDidMount and componentDidUpdate:
 useEffect(() =&gt; &#123;
 // Update the document title using the browser API
 document.title = You clicked $&#123;count&#125; times ;
 &#125;);
</code></pre>
<p>2、需要清除的effect：React 会在组件卸载的时候执行清除操作</p>
<pre><code class="react"> useEffect(() =&gt; &#123;
 function handleStatusChange(status) &#123;
 setIsOnline(status.isOnline);
 &#125;
 ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
 // Specify how to clean up after this effect:
 return function cleanup() &#123;
 ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
 &#125;;
 &#125;);
</code></pre>
<p>3、使用多个effect实现关注点的分离</p>
<p>把类组件中的分散在多个生命周期中的同一件事件的处理，合并到同一个effect中处理</p>
<p>4、通过跳过effect进行性能优化</p>
<pre><code class="react">useEffect(() =&gt; &#123;
 document.title = You clicked $&#123;count&#125; times ;
&#125;, [count]); // 仅在 count 更改时更新
</code></pre>
<h3 id="♥︎♥︎♥︎-useCallback是干什么的？使用useCallback有什么好处？"><a href="#♥︎♥︎♥︎-useCallback是干什么的？使用useCallback有什么好处？" class="headerlink" title="♥︎♥︎♥︎  useCallback是干什么的？使用useCallback有什么好处？"></a>♥︎♥︎♥︎  useCallback是干什么的？使用useCallback有什么好处？</h3><p>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized(缓存)版本，该回调函数仅在某个依赖项改变时才会更新 好处 当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用</p>
<h3 id="♥︎♥︎♥︎-能简单说一下redux-sage的使用流程吗？"><a href="#♥︎♥︎♥︎-能简单说一下redux-sage的使用流程吗？" class="headerlink" title="♥︎♥︎♥︎  能简单说一下redux-sage的使用流程吗？"></a>♥︎♥︎♥︎  能简单说一下redux-sage的使用流程吗？</h3><p>redux-saga 是一个用于管理 Redux 应用异步操作的中间件（又称异步 action）。 redux-saga 通过创建 Sagas 将所有的异步操作逻辑收集在一个地方集中处理，可以用来代替 redux-thunk 中间件。</p>
<p>Reducers 负责处理 action 的 state 更新</p>
<p>Sagas 负责协调那些复杂或异步的操作</p>
<p>1、connet to the store：本质是管理 Redux 应用异步操作的中间件</p>
<pre><code class="react">import &#123; createStore, applyMiddleware &#125; from &#39;redux&#39;
import createSagaMiddleware from &#39;redux-saga&#39;
import reducer from &#39;./reducers&#39;
import mySaga from &#39;./sagas&#39;
// Create the saga middleware
const sagaMiddleware = createSagaMiddleware()
// Mount it on the Store
const store = createStore(
 reducer,
 applyMiddleware(sagaMiddleware)
)
// Then run the saga
sagaMiddleware.run(mySaga)
// Render the application
</code></pre>
<p>2、initiate a side effect：初始化副作用</p>
<pre><code class="react">import &#123; call, put, takeEvery, takeLatest &#125; from &#39;redux-saga/effects&#39;
import Api from &#39;...&#39;
// Worker saga will be fired on USER_FETCH_REQUESTED actions
function* fetchUser(action) &#123;
 try &#123;
 const user = yield call(Api.fetchUser, action.payload.userId);
 yield put(&#123;type: &quot;USER_FETCH_SUCCEEDED&quot;, user: user&#125;);
 &#125; catch (e) &#123;
 yield put(&#123;type: &quot;USER_FETCH_FAILED&quot;, message: e.message&#125;);
 &#125;
&#125;
// Starts fetchUser on each dispatched USER_FETCH_REQUESTED action
// Allows concurrent fetches of user
function* mySaga() &#123;
 yield takeEvery(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);
&#125;
</code></pre>
<p>3、dispath an action：组件中使用</p>
<pre><code class="react"> ...
 onSomeButtonClicked() &#123;
 const &#123; userId, dispatch &#125; = this.props
 dispatch(&#123;type: &#39;USER_FETCH_REQUESTED&#39;, payload: &#123;userId&#125;&#125;)
 &#125;
 ...
&#125;
</code></pre>
<p>4、more：takeEvery、takeLatest、take、put、call、fork、select</p>
<h3 id="♥︎♥︎♥︎-redux-和-mobx-的区别"><a href="#♥︎♥︎♥︎-redux-和-mobx-的区别" class="headerlink" title="♥︎♥︎♥︎  redux 和 mobx 的区别"></a>♥︎♥︎♥︎  redux 和 mobx 的区别</h3><p>1、Redux的编程范式是函数式的而Mobx是面向对象的</p>
<p>2、因此数据上来说Redux理想的是immutable的，每次都返回一个新的数据，而Mobx从始至终都是一份引用。因此Redux是支持数据回溯的</p>
<p>3、然而和Redux相比，使用Mobx的组件可以做到精确更新，这一点得益于Mobx的observable；对应的，Redux是用dispatch进行广播，通过Provider和connect来比对前后差别控制更新粒度，有时需要自己写SCU；Mobx更加精细一点</p>
<p>4、Mobx-react vs React-rdux：</p>
<p>redux,采取Provider和connect方式，mobx采取Provider和inject、observer</p>
<h3 id="♥︎♥︎♥︎-react中如何实现命名插槽"><a href="#♥︎♥︎♥︎-react中如何实现命名插槽" class="headerlink" title="♥︎♥︎♥︎ react中如何实现命名插槽"></a>♥︎♥︎♥︎ react中如何实现命名插槽</h3><p>由于在React组件中写的内容会被挂载到props中，以此来实现类似vue中的插槽功能</p>
<p>这是最外层代码</p>
<pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;
import NavBar from &#39;./NavBar&#39;
import NavBar2 from &#39;./NavBar2&#39;

export default class App extends Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;NavBar&gt;
          &lt;span&gt;aaa&lt;/span&gt;
          &lt;strong&gt;bbb&lt;/strong&gt;
          &lt;a href=&quot;/#&quot;&gt;ccc&lt;/a&gt;
        &lt;/NavBar&gt;

        &lt;NavBar2 leftslot=&#123;&lt;span&gt;aaa&lt;/span&gt;&#125;
        centerslot=&#123;&lt;strong&gt;bbb&lt;/strong&gt;&#125;
        rightslot=&#123;&lt;a href=&quot;/#&quot;&gt;ccc&lt;/a&gt;&#125;/&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<p>1.用this.props.children[index]</p>
<pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;

import &#39;./style.css&#39;
export default class NavBar extends Component &#123;
  render () &#123;
    return (
      &lt;div className=&quot;nav-bar&quot;&gt;
        &lt;div className=&quot;nav-left&quot;&gt;
          &#123;this.props.children[0]&#125;
        &lt;/div&gt;
        &lt;div className=&quot;nav-center&quot;&gt;
          &#123;this.props.children[1]&#125;
        &lt;/div&gt;
        &lt;div className=&quot;nav-right&quot;&gt;
          &#123;this.props.children[2]&#125;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<p>2.用直接命名方式</p>
<pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;

import &#39;./style.css&#39;
export default class NavBar extends Component &#123;
  render () &#123;
    const &#123;leftslot, centerslot,rightslot&#125; = this.props
    return (
      &lt;div className=&quot;nav-bar&quot;&gt;
        &lt;div className=&quot;nav-left&quot;&gt;
          &#123;leftslot&#125;
        &lt;/div&gt;
        &lt;div className=&quot;nav-center&quot;&gt;
          &#123;centerslot&#125;
        &lt;/div&gt;
        &lt;div className=&quot;nav-right&quot;&gt;
          &#123;rightslot&#125;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-简单说一下，如何在react中实现瀑布流加载？（左右两列的一个商品长列表）"><a href="#♥︎♥︎♥︎-简单说一下，如何在react中实现瀑布流加载？（左右两列的一个商品长列表）" class="headerlink" title="♥︎♥︎♥︎  简单说一下，如何在react中实现瀑布流加载？（左右两列的一个商品长列表）"></a>♥︎♥︎♥︎  简单说一下，如何在react中实现瀑布流加载？（左右两列的一个商品长列表）</h3><p>根据红线，将数据分为两部分，然后根据两边的高度（哪边少往那边加内容）去渲染两个盒子，然后达到一个瀑布流的效果</p>
<pre><code class="react">import React, &#123; Component,Fragment &#125; from &#39;react&#39;;
import &#123;connect&#125; from&#39;react-redux&#39;
import Axios from &#39;_axios@0.19.0@axios&#39;;
class Waterfall extends Component &#123;
 constructor(props) &#123;
 super(props);
 this.state = &#123; 
 data:[],//整体的数据
 leftData:[],//左边的数据
 rightData:[]//右边的数据
 &#125;
 &#125;
 getHW(data)&#123;
 let heightDate = [0,0];//接收累计高度的容器数组
 let rightData =[]//渲染右侧盒子的数组
 let leftData = []//渲染左侧盒子的数组
 data.forEach(item =&gt; &#123;
 let height = item.src.replace(&#39;http://dummyimage.com/&#39;,&#39;&#39;).substr(0,7).split(&#39;x&#39;)[1]*1;//对url地址进行一
个截取，拿到高度
 let minNum = Math.min.apply(null,heightDate)// 从heighetData筛选最小项
 let minIndex = heightDate.indexOf(minNum);// 获取 最小项的小标 准备开始进行累加
 heightDate[minIndex] = heightDate[minIndex] + height;//从 heightData 中找到最小的项后进行累加，
 if(minIndex===0)&#123;//[0]加到left [1]加到 right
 leftData.push(item)
 &#125;else&#123;
 rightData.push(item)
 &#125;
 &#125;)
 this.setState(&#123; leftData,rightData &#125;);//重新set state
 &#125;
 render() &#123; 
 let &#123;leftData,rightData&#125; = this.state;
 console.log(leftData,rightData)
 return ( 
 
 
&#123; leftData &amp;&amp; leftData.map((item,index)=&gt;&#123; return &#125;) &#125; &#123; rightData &amp;&amp; rightData.map((item,index)=&gt;&#123; return &#125;) &#125;
); &#125; componentDidMount()&#123; Axios.get(&#39;/api/data&#39;).then(res=&gt;&#123; this.props.dispatch(&#123; type:&#39;SET_DATA&#39;,
data:res.data.data &#125;) this.getHW(this.props.data) //调用 &#125;) &#125; &#125;
export default connect(
 (state)=&gt;&#123;
 return&#123;
 data:state.data,
 &#125;
 &#125;
)(Waterfall);
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎♥︎-React-hooks-用过吗，为什么要用？"><a href="#♥︎♥︎♥︎♥︎-React-hooks-用过吗，为什么要用？" class="headerlink" title="♥︎♥︎♥︎♥︎ React hooks 用过吗，为什么要用？"></a>♥︎♥︎♥︎♥︎ React hooks 用过吗，为什么要用？</h3><p>Hooks 是React在16.8版本中出的一个新功能，本质是一种函数，可以实现组件逻辑复用，让我们在函数式组件中使用类组件中的状态、生命周期等功能，hooks的名字都是以use开头。</p>
<pre><code class="css">1、useState——创建状态 接收一个参数作为初始值；返回一个数组，第一个值为状态，第二个值为改变状态的函数 
2、useEffect——副作用（数据获取、dom操作影响页面——在渲染结束之后执行)
        (1)第一个参数为函数，第二个参数为依赖列表，只有依赖更新时才会执行函数；返回一个函 数，当页面刷新的时候先执行返回函数再执行参数函数 
        (2)如果不接受第二个参数，那么在第一次渲染完成之后和每次更新渲染页面的时候，都会调 用useEffect的回调函数 
3、useRef 返回一个可变的ref对象，此索引在整个生命周期中保持不变。可以用来获取元素或组件的实例，用来做 输入框的聚焦或者动画的触发。 
4、useMemo——优化函数组件中的功能函数——在渲染期间执行 
    （1）接收一个函数作为参数，同样接收第二个参数作为依赖列表，返回值可以是任何，函数、对象等都可 以 
    （2）这种优化有助于避免在每次渲染时都进行高开销的计算，仅会在某个依赖项改变时才重新计算 
5、useContext——获取上下文注入的值 
        (1)接受一个context 对象，并返回该对象&lt;MyContext.Provider&gt; 元素的 value值； const value = useContext(MyContext)； 
6、useLayoutEffect——有DOM操作的副作用——在DOM更新之后执行 和useEffet类似，但是执行时机不同，useLayoutEffect在DOM更新之后执行， useEffect在render渲染结束后执行，也就是说useLayoutEffect比useEffect先执行，这是因为DOM更 新之后，渲染才结束或者渲染还会结束 
7、useCallback——与useMemo类似
useMemo与useCallback相同，接收一个函数作为参数，也同样接收第二个参数作为依赖列 表；useCallback是对传过来的回调函数优化，返回的是一个函数
</code></pre>
<pre><code class="css">react-router:
 被route包裹的组件，可以直接使用props进行路由相关操作，但是没有被route包裹的组件只能用withRouter高阶组件修饰或者使用hooks进行操作
 1、useHistory——跳转路由
 2、useLocation——得到url对象
 3、useParams——得到url上的参数

react-redux:
 1、useSelector——共享状态——从redux的store中提取数据
 2、useDispatch——共享状态——返回redux的store中对dispatch的引用
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-虚拟DOM的优劣如何？实现原理？"><a href="#♥︎♥︎♥︎♥︎-虚拟DOM的优劣如何？实现原理？" class="headerlink" title="♥︎♥︎♥︎♥︎ 虚拟DOM的优劣如何？实现原理？"></a>♥︎♥︎♥︎♥︎ 虚拟DOM的优劣如何？实现原理？</h3><p>虚拟dom是用js模拟一颗dom树,放在浏览器内存中，相当于在js和真实dom中加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。</p>
<p> 优点：</p>
<p> （1）虚拟DOM具有批处理和高效的Diff算法,最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染,优化性能；</p>
<p> （2）虚拟DOM不会立马进行排版与重绘操作，对虚拟DOM进行频繁修改，最后一次性比较并修改真实DOM中需要改的部分；</p>
<p> （3）虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部；</p>
<p> 缺点：</p>
<p> （1）首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢；</p>
<pre><code class="css">React组件的渲染过程： 
（1）使用JSX编写React组件后所有的JSX代码会通过Babel转化为 React.createElement执行; 
（2）createElement函数对 key和 ref等特殊的 props进行处理，并获取 defaultProps对默认 props进行赋值，并且对传入的子节点进行处理，最终构造成一个 ReactElement对象（所谓的虚拟 DOM）。
（3）ReactDOM.render将生成好的虚拟 DOM渲染到指定容器上，其中采用了批处理、事务等机制并且 对特定浏览器进行了性能优化，最终转换为真实 DOM。

虚拟DOM的组成——ReactElementelement对象结构： 
（1）type：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或class） 
（2）key：组件的唯一标识，用于Diff算法，下面会详细介绍 
（3）ref：用于访问原生dom节点 
（4）props：传入组件的props，chidren是props中的一个属性，它存储了当前组件的孩子节点，可 以是数组（多个孩子节点）或对象（只有一个孩子节点） 
（5）owner：当前正在构建的Component所属的Component 
（6）self：（非生产环境）指定当前位于哪个组件实例 
（7）_source：（非生产环境）指定调试代码来自的文件(fileName)和代码行数(lineNumber)
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-React-和-Vue-的-diff-时间复杂度从-O-n-3-优化到-O-n-，那么-O-n-3-和-O-n-是如何计算出来的？"><a href="#♥︎♥︎♥︎♥︎-React-和-Vue-的-diff-时间复杂度从-O-n-3-优化到-O-n-，那么-O-n-3-和-O-n-是如何计算出来的？" class="headerlink" title="♥︎♥︎♥︎♥︎ React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？"></a>♥︎♥︎♥︎♥︎ React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？</h3><p>react的diff算法只需要O(n)，这是因为react对树节点的比较做了一些前提假设，限定死了一些东西，不做过于复杂的计算操作，所以降低了复杂度。react和vue做了以下的假设，这样的话diff运算时只进行同层比较，每一个节点只遍历了一次。</p>
<p> （1）Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计；</p>
<p> （2）拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构；</p>
<p> （3）对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</p>
<blockquote>
<p>而传统的diff运算时间复杂度为O(n^3)，这是因为传统的树节点要做非常完整的检查，首先需要节点之 间需要两两比较，找到所有差异，这个对比过程时间复杂度为O(n^2)，找到差异后还要计算出最小的转换方式，最终复杂度为O(n^3) </p>
</blockquote>
<h3 id="♥︎♥︎♥︎♥︎-请列举react生命周期函数。"><a href="#♥︎♥︎♥︎♥︎-请列举react生命周期函数。" class="headerlink" title="♥︎♥︎♥︎♥︎ 请列举react生命周期函数。"></a>♥︎♥︎♥︎♥︎ 请列举react生命周期函数。</h3><table>
<thead>
<tr>
<th align="center">阶段</th>
<th align="center">生命周期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一阶段：装载阶段3</td>
<td align="center">constructor()    render()    componentDidMount()</td>
</tr>
<tr>
<td align="center">第二阶段：更新阶段2</td>
<td align="center">shouldComponentUpdate()     render()    componentDidUpdate()</td>
</tr>
<tr>
<td align="center">第三阶段：卸载阶段1</td>
<td align="center">componentWillUnmount()</td>
</tr>
</tbody></table>
<h4 id="constructor生命周期："><a href="#constructor生命周期：" class="headerlink" title="constructor生命周期："></a>constructor生命周期：</h4><p> (1)当react组件实例化时，是第一个运行的生命周期；</p>
<p> (2)在这个生命周期中，不能使用this.setState()；</p>
<p> (3)在这个生命周期中，不能使用副作用(调接口、dom操作、定时器、长连接等)；</p>
<p> (4)不能把props和state交叉赋值；</p>
<h4 id="componentDidMount生命周期："><a href="#componentDidMount生命周期：" class="headerlink" title="componentDidMount生命周期："></a>componentDidMount生命周期：</h4><p> (1)相当于是vue中的mounted；</p>
<p> (2)它表示DOM结构在浏览器中渲染已完成；</p>
<p> (3)在这里可以使用任何的副作用；</p>
<h4 id="shouldComponentUpdate-nextProps-nextState-生命周期："><a href="#shouldComponentUpdate-nextProps-nextState-生命周期：" class="headerlink" title="shouldComponentUpdate(nextProps,nextState)生命周期："></a>shouldComponentUpdate(nextProps,nextState)生命周期：</h4><p> (1)相当于一个开关，如果返回true则更新机制正常执行，如果为false则更新机制停止；</p>
<p> (2)在vue中是没有的；</p>
<p> (3)存在的意义：可以用于性能优化，但是不常用，最新的解决方案是使用PureComponent；</p>
<p> (4)理论上，这个生命周期的作用，用于精细地控制声明式变量的更新问题，如果变化的声明式变量参与了视图渲染则返回true，如果被变化的声明式变量没有直接或间接参与视图渲染，则返回false；</p>
<h4 id="componentDidUpdate生命周期："><a href="#componentDidUpdate生命周期：" class="headerlink" title="componentDidUpdate生命周期："></a>componentDidUpdate生命周期：</h4><p> (1)相当于vue中的updated()；</p>
<p> (2)它表示DOM结构渲染更新已完成，只发生在更新阶段；</p>
<p> (3)在这里，可以执行大多数的副作用，但是不建议；</p>
<p> (4)在这里，可以使用this.setState()，但是要有终止条件判断。</p>
<h4 id="componentWillUnmount生命周期："><a href="#componentWillUnmount生命周期：" class="headerlink" title="componentWillUnmount生命周期："></a>componentWillUnmount生命周期：</h4><p> (1)一般在这里清除定时器、长连接等其他占用内存的构造器；render生命周期：</p>
<p> (1)render是类组件中唯一必须有的生命周期，同时必须有return（return 返回的jsx默认只能是单一根节点，但是在fragment的语法支持下，可以返回多个兄弟节点）；</p>
<p> (2)Fragment碎片写法: &lt;React.Fragment&gt;&lt;&#x2F;React.Fragment&gt; 简写成&lt;&gt;&lt;&#x2F;&gt;；</p>
<p> (3)return之前，可以做任意的业务逻辑，但是不能使用this.setState()，会造成死循环；</p>
<p> (4)render()在装载阶段和更新阶段都会运行；</p>
<p> (5)当render方法返回null的时候，不会影响生命周期函数的正常执行。</p>
<h3 id="♥︎♥︎♥︎♥︎-新出来两个钩子函数？和砍掉的will系列有啥区别？"><a href="#♥︎♥︎♥︎♥︎-新出来两个钩子函数？和砍掉的will系列有啥区别？" class="headerlink" title="♥︎♥︎♥︎♥︎  新出来两个钩子函数？和砍掉的will系列有啥区别？"></a>♥︎♥︎♥︎♥︎  新出来两个钩子函数？和砍掉的will系列有啥区别？</h3><pre><code class="javascript">/ react16 中废弃了三个钩子
componentWillMount // 组件将要挂载的钩子
componentWillReceiveProps // 组件将要接收一个新的参数时的钩子
componentWillUpdate // 组件将要更新的钩子
</code></pre>
<pre><code class="javascript">/ 新增了方法
getDerivedStateFromProps // 静态方法
getSnapshotBeforeUpdate
</code></pre>
<p>在16.8版本以后，react将diff运算改进为Fiber，这样的话当我们调用setState方法进行更新的时候，在reconciler 层中js运算会按照节点为单位拆分成一个个小的工作单元，在render前可能会中断或恢复，就有可能导致在render前这些生命周期在进行一次更新时存在多次执行的情况，此时如果我们在里面使用ref操作dom的话，就会造成页面频繁重绘，影响性能。 所以废弃了这几个will系列的勾子，增加了 getDerivedStateFromProps这个静态方法，这样的话我们就不能在其中使用this.refs以及this上的方法了；getSnapshotBeforeUpdate 这个方法已经到了commit阶段，只会执行一次，给想读取 dom 的用户一些空间。</p>
<h3 id="♥︎♥︎♥︎♥︎-react中-setState-之后做了什么？"><a href="#♥︎♥︎♥︎♥︎-react中-setState-之后做了什么？" class="headerlink" title="♥︎♥︎♥︎♥︎  react中 setState 之后做了什么？"></a>♥︎♥︎♥︎♥︎  react中 setState 之后做了什么？</h3><p>如果是在隶属于原生js执行的空间，比如说setTimeout里面，setState是同步的，那么每次执行setState将立即更新this.state，然后触发render方法，渲染数据；</p>
<p> 如果是在被react处理过的空间执行，比如说合成事件里，此时setState是异步执行的，并不会立即更新this.state的值，当执行setState的时候，会将需要更新的state放入状态队列，在这个空间最后再合并修改this.state，触发render；</p>
<h3 id="♥︎♥︎♥︎♥︎-redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？"><a href="#♥︎♥︎♥︎♥︎-redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？" class="headerlink" title="♥︎♥︎♥︎♥︎  redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？"></a>♥︎♥︎♥︎♥︎  redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？</h3><p>当我们需要修改store中值的时候，我们是通过 dispatch(action)将要修改的值传到reducer中的，这个过程是同步的，如果我们要进行异步操作的时候，就需要用到中间件；中间件其实是提供了一个分类处理action的机会，在 middleware 中，我们可以检阅每一个流过的action，并挑选出特定类型的action进行相应操作，以此来改变 action；</p>
<pre><code class="css">applyMiddleware 是个三级柯里化的函数。它将陆续的获得三个参数：第一个是 middlewares 数 组，第二个是 Redux 原生的 createStore，最后一个是 reducer；然后applyMiddleware会将不同的 中间件一层一层包裹到原生的 dispatch 之上； 
redux-thunk 中间件的作用就是让我们可以异步执行redux，首先检查参数 action 的类型，如果 是函数的话，就执行这个 action这个函数，并把 dispatch, getState, extraArgument 作为参数传 递进去，否则就调用next让下一个中间件继续处理action。
</code></pre>
<pre><code class="react">// redux-thunk部分源码
function createThunkMiddleware(extraArgument) &#123;
 return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;
 if (typeof action === &#39;function&#39;) &#123;
 return action(dispatch, getState, extraArgument)
 &#125;
 return next(action)
 &#125;
&#125;
const thunk = createThunkMiddleware()
thunk.withExtraArgument = createThunkMiddleware
export default thunk
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-列举重新渲染-render-的情况"><a href="#♥︎♥︎♥︎♥︎-列举重新渲染-render-的情况" class="headerlink" title="♥︎♥︎♥︎♥︎ 列举重新渲染 render 的情况"></a>♥︎♥︎♥︎♥︎ 列举重新渲染 render 的情况</h3><ol>
<li>this.setState() </li>
<li>this.forceUpdate()</li>
<li>接受到新的props</li>
<li>通过状态管理，mobx、redux等</li>
<li>改变上下文</li>
</ol>
<h3 id="♥︎♥︎♥︎♥︎-类组件怎么做性能优化？函数组件怎么做性能优化？"><a href="#♥︎♥︎♥︎♥︎-类组件怎么做性能优化？函数组件怎么做性能优化？" class="headerlink" title="♥︎♥︎♥︎♥︎ 类组件怎么做性能优化？函数组件怎么做性能优化？"></a>♥︎♥︎♥︎♥︎ 类组件怎么做性能优化？函数组件怎么做性能优化？</h3><p>类组件：</p>
<pre><code class="css"> （1）使用shouldComponentUpdate：这个生命周期可以让我们决定当前状态或属性的改变是否重新渲染组件，默认返回ture，返回false时不会执行render，在初始化渲染或使用forceUpdate()时不会调用；如果在shouldComponentUpdate比较的值是引用类型的话，可能达不到我们想要的效果，因为引用类型指向同一个地址；当将旧的state的值原封不动赋值给新的state（即不改变state的值，但是调用了setState）和 无数据交换的父组件的重新渲染都会导致组件重新渲染，这时候都可以通过shouldComponentUpdate来优化；

 （2）React.PureComponent：基本上和Component用法一致，不同之处在于 PureComponent不需要开发者自己设置shouldComponentUpdate，因为PureComponent自带通过props和state的浅对比来实现 shouldComponentUpate；但是如果props和state对象包含复杂的数据结构，它可能会判断错误(表现为对象深层的数据已改变，视图却没有更新）；

 （4）使用Immutable：immutable是一种持久化数据，一旦被创建就不会被修改，修改immutable对象的时候返回新的immutable；也就是说在使用旧数据创建新数据的时候，会保证旧数据同时可用且不变；为了避免深度复制所有节点的带来的性能损耗，immutable使用了结构共享，即如果对象树中的一个节点发生变化，只修改这个节点和受他影响的父节点，其他节点仍然共享；

 （5）bind函数：在react中改变this的指向有三种方法，a)constructor中用bind绑定; b)使用时通过bind绑定; c)使用箭头函数；选择第一种只在组件初始化的时候执行一次，第二种组件在每次render都要重新绑定，第三种在每次render时候都会生成新的箭头函数，所以选择第一种；
</code></pre>
<p>函数组件：</p>
<pre><code class="css"> （1）useCallback：接收一个函数作为参数，接收第二个参数作为依赖列表，返回值为函数，有助于避免在每次渲染时都进行高开销的计算，仅会在某个依赖项改变时才重新计算；可以使用useCallback把要传递给子组件的函数包裹起来，这样父组件刷新的时候，传递给子组件的函数指向不会发生改变，可以减少子组件的渲染次数；

 const handleUseCallback=useCallback(handleClick,[])

 （2）useMemo：useMemo的使用和useCallback差不多，只是useCallback返回的是一个函数，useMemo返回值可以是函数、对象等都可以；
</code></pre>
<p>两者都可使用：</p>
<pre><code class="css">（1）React.memo：React.memo 功能同React.PureComponent，但React.memo是高阶组件，既可以用在类组件中也可以用在函数组件中；memo还可以接收第二个参数，是一个可定制化的比较函数，其返回值与 shouldComponentUpdate的相反；

（2）使用key：在列表渲染时使用key，这样当组件发生增删改、排序等操作时，diff运算后可以根据key值直接调整DOM顺序，避免不必要的渲染而避免性能的浪费；

（3）不要滥用props：尽量只传需要的数据，避免多余的更新，尽量避免使用&#123;…props&#125;；
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-什么是-prop-drilling，如何避免？"><a href="#♥︎♥︎♥︎♥︎-什么是-prop-drilling，如何避免？" class="headerlink" title="♥︎♥︎♥︎♥︎ 什么是 prop drilling，如何避免？"></a>♥︎♥︎♥︎♥︎ 什么是 prop drilling，如何避免？</h3><p>从一个外部组件一层层将prop传递到内部组件很不方便，这个问题就叫做 prop drilling；主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护，代码看起来也变得冗余，不优雅；</p>
<p>为了避免prop drilling，一种常用的方法是使用React Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过 Consumer组件或 useContext Hook 使用上下文数据。</p>
<h3 id="♥︎♥︎♥︎♥︎-什么是-React-Context"><a href="#♥︎♥︎♥︎♥︎-什么是-React-Context" class="headerlink" title="♥︎♥︎♥︎♥︎ 什么是 React Context?"></a>♥︎♥︎♥︎♥︎ 什么是 React Context?</h3><p>React Context源码解析</p>
<p>1、What</p>
<p>Context提供了一个无需为每层组件手动添加props，就能在组件树间进行数据传递的功能</p>
<p>2、Why</p>
<p>某些全局属性，通过父子props传递太过繁琐，Context提供了一种组件之间共享此类值的方式，而不必显式的通过组件树逐层传递props</p>
<p>3、When</p>
<p>共享那些对于一个组件树而言是全局的数据，例如当前认证的用户、主题或者首选语言等</p>
<p>4、Where</p>
<p>Context应用场景在于很多不同层级的组件访问同样的数据，这样也使得组件的复用性变差。</p>
<p>如果你只是想避免层层传递一些属性，组件组合有时候是一个比Context更好的方案，也就是直接传递组件</p>
<p>所以一个技术方案的选定需要针对不同的场景具体分析，采取合适的方案</p>
<p>5、How</p>
<pre><code class="css">// ①创建

const ThemeContext = React.createContext(&#39;xxx&#39;)

// ②注入---提供者 在入口或者你想要注入的父类中，且可以嵌套，里层覆盖外层

return (
&lt;ThemeContext.Provider value=&quot;yyy&quot;&gt;
&#123;children&#125;
&lt;ThemeContext.Provider&gt;
)

// ③使用---消费者 需要使用共享数据的子类中

// 方式一
static contextType = ThemeContext
// 方式二
Class.contextType = ThemeContext 
render() &#123;
let value = this.context
/* 基于这个值进行渲染工作 */ 
&#125;
//方式三
return(
&lt;ThemeContext.Consumer&gt;
&#123; value =&gt; /* 基于 context 值进行渲染*/ &#125;
&lt;/ThemeContext.Consumer&gt;
)
</code></pre>
<p>6、More</p>
<p>动态Context—类似父子组件</p>
<pre><code class="css">// ①创建

const ThemeContext = React.createContext(&#123;
value: &#39;xxx&#39;,
changeFunc: () =&gt; &#123;&#125; /*通过context传递这个函数，让consumers组件更新context*/
&#125;)

// ②注入
return (
&lt;ThemeContext.Provider value=&quot;yyy&quot;&gt;
&lt;ThemeContext.Provider&gt;
)

// ③消费

return(
&lt;ThemeContext.Consumer&gt;
&#123; (&#123;value, changeFunc&#125;) =&gt; /* 基于 context 值进行渲染,同时把changeFunc绑定*/ &#125;
 &lt;/ThemeContext.Consumer&gt;
)
消费多个Context、注意事项等参考React中文网
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-Hooks-会取代-render-props-和高阶组件吗"><a href="#♥︎♥︎♥︎♥︎-Hooks-会取代-render-props-和高阶组件吗" class="headerlink" title="♥︎♥︎♥︎♥︎  Hooks 会取代 render props 和高阶组件吗?"></a>♥︎♥︎♥︎♥︎  Hooks 会取代 render props 和高阶组件吗?</h3><p>可以取代，但没必要</p>
<p>在Hook的渐进策略中也有提到，没有计划从React中移除class，在新的代码中同时使用Hook和class，所以这些方案目前还是可以有勇武之地</p>
<p>1、What</p>
<p>为什么要把这3种技术拿过来对比？</p>
<p>都在处理同一个问题，逻辑复用</p>
<p>高阶组件HOC—不是 React API 的一部分，是基于 React 的组合特性形成的设计模式。</p>
<p>高阶组件是参数为组件，返回值为新组件的函数（将组件转换为另一个组件，纯函数，无副作用）</p>
<p>Render Props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的 简单技术</p>
<p>Hooks 是React16.8新增的特性，是一些可以让你在函数组件里“钩入”React state及生命周期等特性的函数</p>
<p>虽然 HOC &amp; Render Props 能处理逻辑复用的问题，但是却存在各自的问题。</p>
<p>HOC 存在的问题</p>
<ul>
<li>写法破坏了原来组件的结构，DevTools中组件会形成“嵌套地狱”</li>
<li>不要在 render 方法中使用 HOC 每次调用render函数会创建一个新的高阶组件导致该组件及其子组件的状态丢失</li>
<li>需要修复静态方法，即拷贝原组件的静态方法到高级组件中</li>
<li>如需传递Ref则需要通过React.forwardRef创建组件</li>
</ul>
<p>Render Props 存在的问题</p>
<ul>
<li>同样的写法会破坏原来组件的结构，DevTools中组件会形成“嵌套地狱” </li>
<li>与React.PureComponent组件使用有冲突</li>
<li>Hook 目前最优雅的实现，React为共享状态逻辑提供最好的原生途径</li>
<li>没有破坏性改动，完全可选，100%向后兼容</li>
<li>解决复杂组件，中逻辑状态、副作用和各种生命周期函数中逻辑代码混在一起，难以拆分，甚至形成bug的问题</li>
</ul>
<p>2、When</p>
<ul>
<li>在函数组件中意识到要向其添加一些state—useState</li>
<li>有副作用的行为时</li>
</ul>
<p>3、Where</p>
<p>只能在函数最外层调用Hook，不要在循环、条件判断或者子函数中调用</p>
<p>只能在函数组件或者自定义Hook中调用Hook</p>
<h3 id="♥︎♥︎♥︎♥︎-当调用setState时，React-render-是如何工作的？"><a href="#♥︎♥︎♥︎♥︎-当调用setState时，React-render-是如何工作的？" class="headerlink" title="♥︎♥︎♥︎♥︎ 当调用setState时，React render 是如何工作的？"></a>♥︎♥︎♥︎♥︎ 当调用setState时，React render 是如何工作的？</h3><p>调用setState()</p>
<ol>
<li>检查上下文环境生成更新时间相关参数并判定事件优先级（fiber，currenttime，expirationtime等…）</li>
<li>根据优先级相关参数判断更新模式是sync（同步更新）或是batched（批量处理）</li>
<li>加入执行更新事件的队列，生成事件队列的链表结构</li>
<li>根据链表顺序执行更新</li>
<li>setState既是同步的，也是异步的。同步异步取决于setState运行时的上下文。且setState 只在合成事件和钩子函数中是“异步”的，在原生DOM事件和 setTimeout 中都是同步的</li>
</ol>
<p>render如何工作</p>
<ol>
<li>React在props或state发生改变时，会调用React的render方法，创建一颗不同的树</li>
<li>React需要基于这两颗不同的树之间的差别来判断如何有效的更新UI diff算法，将两颗树完全比较更新的算法从O(n^3^),优化成O(n)；</li>
<li>同层节点之间相互比较，不会跨节点比较</li>
<li>不同类型的节点，产生不同的树结构</li>
<li>设置key来指定节点在不同的渲染下保持稳定</li>
</ol>
<h3 id="♥︎♥︎♥︎♥︎-diff复杂度原理及具体过程画图"><a href="#♥︎♥︎♥︎♥︎-diff复杂度原理及具体过程画图" class="headerlink" title="♥︎♥︎♥︎♥︎ diff复杂度原理及具体过程画图"></a>♥︎♥︎♥︎♥︎ diff复杂度原理及具体过程画图</h3><ul>
<li>React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；</li>
<li>React 通过分层求异的策略，对 tree diff 进行算法优化；</li>
<li>React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；</li>
<li>React 通过设置唯一 key的策略，对 element diff 进行算法优化；</li>
<li>建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；</li>
<li>建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎-shouldComponentUpdate的作用是什么？"><a href="#♥︎♥︎♥︎♥︎-shouldComponentUpdate的作用是什么？" class="headerlink" title="♥︎♥︎♥︎♥︎  shouldComponentUpdate的作用是什么？"></a>♥︎♥︎♥︎♥︎  shouldComponentUpdate的作用是什么？</h3><p>shouldComponentUpdate的作用</p>
<p>1、What</p>
<p>不常用的生命周期方法，能影响组件是否重新渲染</p>
<p>在更新阶段，当有new props 或者 调用了 setState()方法，在render方法执行前会执行到，默认返回值为true，如果返回false则不刷新组件</p>
<p>2、Why &amp; When &amp; Where</p>
<ol>
<li>如果你知道在什么情况下组件不需要更新，你可以让其返回值为false跳过整个渲染过程</li>
<li>次方法仅作为 性能优化方式 而存在，不要企图靠此方法来阻止渲染，</li>
<li>大部分情况下，使用PureComponent代替手写shouldComponentUpdate，仅浅层对比</li>
<li>不建议在shoulComponentUpdate中进行深层或者使用JSON.stringify()，这样非常影响效率和性能</li>
<li>作为React组件中不常用的生命周期函数，能影响组件是否重渲染</li>
<li>建议做浅层次的比较，来优化性能，当然这里也可以用PureComponent组件代替</li>
<li>如果有较深层次的比较则可能会导致更严重的性能问题，因此在这种情况下不要靠手动管理组件的重新渲染来优化性能，要找其他方式</li>
</ol>
<h3 id="♥︎♥︎♥︎♥︎-什么是高阶组件、受控组件及非受控组件？都有啥区别"><a href="#♥︎♥︎♥︎♥︎-什么是高阶组件、受控组件及非受控组件？都有啥区别" class="headerlink" title="♥︎♥︎♥︎♥︎ 什么是高阶组件、受控组件及非受控组件？都有啥区别"></a>♥︎♥︎♥︎♥︎ 什么是高阶组件、受控组件及非受控组件？都有啥区别</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>高阶组件HOC—不是 React API 的一部分，是基于 React 的组合特性形成的设计模式。</p>
<p>高阶组件是参数为组件，返回值为新组件的函数（将组件转换为另一个组件，纯函数，无副作用）</p>
<h4 id="2、受控组件"><a href="#2、受控组件" class="headerlink" title="2、受控组件"></a>2、受控组件</h4><p>在表单元素中，state是唯一数据源，渲染表单的React组件控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素叫做受控组件</p>
<h3 id="3、非受控组件"><a href="#3、非受控组件" class="headerlink" title="3、非受控组件"></a>3、非受控组件</h3><p>表单数据由DOM节点来处理，而不是用state来管理数据，一般可以使用ref来从DOM节点中获取表单数据</p>
<p>‼️区别</p>
<ul>
<li>受控组件和非受控组件是表单中的组件，高阶组件相当于对某个组件注入一些属性方法</li>
<li>高阶组件是解决代码复用性问题产生的技术</li>
<li>受控组件必须要有一个value，结合onChange来控制这个value，取值为event.target.value&#x2F;event.target.checked</li>
<li>非受控组件相当于操作DOM，一般有个defaultValue，通过onBlur触发响应方法</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎-vue-react都怎么检测数据变化"><a href="#♥︎♥︎♥︎♥︎-vue-react都怎么检测数据变化" class="headerlink" title="♥︎♥︎♥︎♥︎ vue react都怎么检测数据变化"></a>♥︎♥︎♥︎♥︎ vue react都怎么检测数据变化</h3><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><p>React默认是通过比较引用的方式（diff）进行的，不精确监听数据变化，如果不优化可能导致大量不必要的VDOM重新渲染</p>
<p>16之前 componentWillReveiveProps 监听 props 变化</p>
<p>16之后 getDerivedStateFromProps 监听 props</p>
<h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><p>vue监听变量变化依靠 watch Object.defineProperty，Vue通过“getter&#x2F;setter”以及一些函数的劫持，能精确知道数据变化</p>
<h3 id="♥︎♥︎♥︎♥︎-什么是-immutable？为什么要使用它？"><a href="#♥︎♥︎♥︎♥︎-什么是-immutable？为什么要使用它？" class="headerlink" title="♥︎♥︎♥︎♥︎ 什么是 immutable？为什么要使用它？"></a>♥︎♥︎♥︎♥︎ 什么是 immutable？为什么要使用它？</h3><p>immutable是一种持久化数据。一旦被创建就不会被修改。修改immutable对象的时候返回新的immutable。但是原数据不会改变。</p>
<p>在Rudux中因为深拷贝对性能的消耗太大了（用到了递归，逐层拷贝每个节点）。 但当你使用immutable数据的时候：只会拷贝你改变的节点，从而达到了节省性能。 </p>
<p>总结：immutable的不可变性</p>
<p>让纯函数更强大，每次都返回新的immutable的特性让程序员可以对其进行链式操作，用起来更方便。</p>
<p>因为在react中，react的生命周期中的setState()之后的shouldComponentUpdate()阶段默认返回true，所以会造成本组件和子组件的多余的render，重新生成virtual dom，并进行virtual dom diff，所以解决办法是我们在本组件或者子组件中的shouldComponentUpdate()函数中比较，当不需要render时，不render。 </p>
<p>当state中的值是对象时，我们必须使用深拷贝和深比较！</p>
<p>如果不进行深拷贝后再setState，会造成this.state和nextState指向同一个引用，所以shouldComponentUpdate()返回值一定是false，造成state值改了，而组件未渲染（这里不管shouldComponentUpdate中使用的是深比较还是浅比较）。所以必须深拷贝。</p>
<p>如果不在shouldComponentUpdate中进行深比较，会造成即使state中的对象值没有改变，因为是不同的对象，而在shouldComponentUpdate返回true，造成不必要的渲染。</p>
<p>所以只能是深拷贝和深比较。</p>
<h3 id="♥︎♥︎♥︎♥︎-React路由懒加载的实现"><a href="#♥︎♥︎♥︎♥︎-React路由懒加载的实现" class="headerlink" title="♥︎♥︎♥︎♥︎ React路由懒加载的实现"></a>♥︎♥︎♥︎♥︎ React路由懒加载的实现</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>webpack代码分割</p>
<p>React利用 React.lazy与import()实现了渲染时的动态加载</p>
<p>利用Suspense来处理异步加载资源时页面应该如何显示的问题</p>
<h4 id="1-React-lazy"><a href="#1-React-lazy" class="headerlink" title="1.React.lazy"></a>1.React.lazy</h4><p>通过lazy() api来动态import需要懒加载的组件</p>
<p>import的组件目前只支持export default的形式导出</p>
<p>Suspense来包裹懒加载的组件进行加载，可以设置fallback现实加载中效果</p>
<p>React.lazy可以结合Router来对模块进行懒加载。</p>
<pre><code class="react">import &#123; BrowserRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;;
import &#123; Suspense, lazy &#125; from &#39;react&#39;;
const Home = lazy(() =&gt; import(&#39;./routes/Home&#39;))
const AnyComponent = lazy(() =&gt; import(&#39;./routes/AnyComponent&#39;))
...
return (
 &lt;Suspense fallback=&#123;
Loading...
&#125;&gt; ...
</code></pre>
<h4 id="2-react-loadable"><a href="#2-react-loadable" class="headerlink" title="2.react-loadable"></a>2.react-loadable</h4><p>react-loadable是以组件级别来分割代码的，这意味着，我们不仅可以根据路由按需加载，还可以根据组件按需加载，使用方式和路由分割一样，只用修改组件的引入方式即可</p>
<pre><code class="react">// 路由懒加载（异步组件）
import Loadable from &#39;react-loadable&#39;;
//通用过场组件
const LoadingComponent = () =&gt; &#123;
 return (
loading
) &#125; ... export default (loader, loading=LoadingComponent) =&gt; &#123; return Loadable(&#123; loader, loading &#125;) &#125;
//Route中调用
import &#123; BrowserRouter, Route &#125; from &#39;react-router-dom&#39;
const loadable from &#39;./loadable&#39;;
const AnyComponent = loadable(() =&gt; import(&#39;./AnyComponent&#39;))
const Routes = () =&gt; (
);
export default Routes;
</code></pre>
<p>以下是老版中的方法</p>
<h4 id="3-webpack配置中使用lazyload-loader"><a href="#3-webpack配置中使用lazyload-loader" class="headerlink" title="3.webpack配置中使用lazyload-loader"></a>3.webpack配置中使用lazyload-loader</h4><pre><code class="react">// webpack 配置中
module: &#123;
 rules: [
 &#123;
 test: /.(js|jsx)$/,,
 use: [
 &#39;babel-loader&#39;,
 &#39;lazyload-loader&#39;
 ]
&#125;,
// 业务代码中
// 使用lazy! 前缀 代表需要懒加载的Router
 import Shop from &#39;lazy!./src/view/Shop&#39;;
 // Router 正常使用
</code></pre>
<h4 id="4-import-webpack-v2"><a href="#4-import-webpack-v2" class="headerlink" title="4.import() webpack v2+"></a>4.import() webpack v2+</h4><p>符合ECMAScript提议的import()语法，该提案与普通 import 语句或 require 函数的类似，但返回一个 Promise 对象</p>
<pre><code class="react">function component() &#123;
 return import( /* webpackChunkName: &quot;lodash&quot; / &#39;lodash&#39;).then(_ =&gt; &#123;
 var element = document.createElement(&#39;div&#39;);
 element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;);
 return element;
 &#125;).catch(error =&gt; &#39;An error occurred while loading the component&#39;);
&#125;
// 或者使用async
async function getComponent() &#123;
 var element = document.createElement(&#39;div&#39;);
 const _ = await import(/ webpackChunkName: &quot;lodash&quot; */ &#39;lodash&#39;);
 element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;);
 return element;
&#125;
</code></pre>
<h4 id="5-requre-ensure-webpack-v1-v2"><a href="#5-requre-ensure-webpack-v1-v2" class="headerlink" title="5.requre.ensure webpack v1 v2"></a>5.requre.ensure webpack v1 v2</h4><pre><code class="react">require.ensure([], function(require)&#123;
 var list = require(&#39;./list&#39;);
 list.show();
，&#39;list&#39;);
const Foo = require.ensure([], () =&gt; &#123;
 require(&quot;Foo&quot;);
&#125;, err =&gt; &#123;
 console.error(&quot;We failed to load chunk: &quot; + err);
&#125;, &quot;chunk-name&quot;);
//react-router2 or 3
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-React-router-dom内部是怎么样实现的，怎么做路由守卫？"><a href="#♥︎♥︎♥︎♥︎-React-router-dom内部是怎么样实现的，怎么做路由守卫？" class="headerlink" title="♥︎♥︎♥︎♥︎ React-router-dom内部是怎么样实现的，怎么做路由守卫？"></a>♥︎♥︎♥︎♥︎ React-router-dom内部是怎么样实现的，怎么做路由守卫？</h3><p>1、总</p>
<p>react-router-dom利用了Context API，通过上下文对象将当前路由信息对象注入到 Router 组件中，所以 Router组件中 render() 渲染的内容就是 ContextAPI 提供的 Provider 组件，然后接收 Router 组件中的当前路由信息对象。 这样 Router 组件下的所有组件都能通过上下文拿到当前路由信息对象，即其中的Switch 、 Route 、 Link 、Redirect 等组件都可以拿到当前路由信息对象，然后通过改变当前路由信息来实现动态切换 Route 组件的渲染。</p>
<p>2、分</p>
<p>RouterContext：react-router使用context实现跨组件间数据传递，所以react-router定义了一个routerContext作为数据源，</p>
<p>Router：BrowserRouter和HashRouter将当前路由注入到上下文中，同时路由信息包含location、match、history</p>
<p>Route：路由规则，获取RouterContext的信息(location对象)，获取path和component属性，判断path和当前的location是否匹配，如果匹配，则渲染component，否则返回null，不渲染任何内容</p>
<p>Switch：遍历所有子元素(Route)，判断Route的path和location是否匹配，如果匹配，则渲染，否则不渲染</p>
<p>Redireact：未能配则重定向到指定页面</p>
<p>Link&#x2F;NavLink: Link组件本质就是a标签，它修改了a标签的默认行为，当点击Link时，会导航到对应的路由，导致locaiton对象的改变，出发组件的更新</p>
<p>withRouter：对传入的组件进行加强，功能就是获取routerContext上面的信息，然后作为props传给需要加强的组件</p>
<p>3、怎么做路由守卫</p>
<p>路由里设置meta元字符实现路由拦截</p>
<p>React Router 4.0之前也像vue中一样有个钩子函数 onEnter 可实现</p>
<p>ReactRouter 4.0开始自己实现如下</p>
<pre><code class="react">// routerMap.js中
import Index from &#39;./page/index&#39;
export default [
 &#123; path:&#39;/&#39;, name: &#39;App&#39;, component:Index, auth: true &#125;,
 ...
]
//入口文件 app.js中
import &#123; BrowserRouter as Router, Switch &#125; from &quot;react-router-dom&quot;;
import FrontendAuth from &quot;./FrontendAuth&quot;;
import routerMap from &quot;./routerMap&quot;;
...
return (
 
 
)
// 高阶组件FrontendAuth 处理路由跳转，即路由守卫功能
//FrontendAuth.js
import React, &#123; Component &#125; from &quot;react&quot;;
import &#123; Route, Redirect &#125; from &quot;react-router-dom&quot;;
class FrontendAuth extends Component &#123;
 // eslint-disable-next-line no-useless-constructor
 constructor(props) &#123;
 super(props);
 &#125;
 render() &#123;
 const &#123; routerConfig, location &#125; = this.props;
 const &#123; pathname &#125; = location;
 const isLogin = sessionStorage.getItem(&quot;username&quot;);
 console.log(pathname, isLogin);
 console.log(location);
 // 如果该路由不用进行权限校验，登录状态下登陆页除外
 // 因为登陆后，无法跳转到登陆页
 // 这部分代码，是为了在非登陆状态下，访问不需要权限校验的路由
 const targetRouterConfig = routerConfig.find(
 (item) =&gt; item.path === pathname
 );
 console.log(targetRouterConfig);
 if (targetRouterConfig &amp;&amp; !targetRouterConfig.auth &amp;&amp; !isLogin) &#123;
 const &#123; component &#125; = targetRouterConfig;
 return ;
 &#125;
 if (isLogin) &#123;
 // 如果是登陆状态，想要跳转到登陆，重定向到主页
 if (pathname === &quot;/login&quot;) &#123;
 return ;
 &#125; else &#123;
 // 如果路由合法，就跳转到相应的路由
 if (targetRouterConfig) &#123;
 return (
 
 );
 &#125; else &#123;
 // 如果路由不合法，重定向到 404 页面
 return ;
 &#125;
 &#125;
 &#125; else &#123;
 // 非登陆状态下，当路由合法时且需要权限校验时，跳转到登陆页面，要求登陆
 if (targetRouterConfig &amp;&amp; targetRouterConfig.auth) &#123;
 return ;
 &#125; else &#123;
 // 非登陆状态下，路由不合法时，重定向至 404
 return ;
 &#125;
 &#125;
 &#125;
&#125;
export default FrontendAuth;
</code></pre>
<p>总结一下，实现路由守卫需要考虑到以下的问题：</p>
<p>未登录情况下，访问不需要权限校验的合法页面：允许访问</p>
<p>未登录情况下，访问需要权限校验的页面：禁止访问，跳转至登陆页</p>
<p>未登录情况下，访问所有的非法页面：禁止访问，跳转至 404</p>
<p>登陆情况下，访问登陆页面：禁止访问，跳转至主页</p>
<p>登陆情况下，访问除登陆页以外的合法页面：允许访问</p>
<p>登陆情况下，访问所有的非法页面：禁止访问，跳转至 404</p>
<h3 id="♥︎♥︎♥︎♥︎-redux中sages和thunk中间件的区别，优缺点"><a href="#♥︎♥︎♥︎♥︎-redux中sages和thunk中间件的区别，优缺点" class="headerlink" title="♥︎♥︎♥︎♥︎ redux中sages和thunk中间件的区别，优缺点"></a>♥︎♥︎♥︎♥︎ redux中sages和thunk中间件的区别，优缺点</h3><p>1、区别</p>
<ul>
<li>redux-thunk异步采取 async&#x2F;await </li>
<li>redux-saga采取generate函数</li>
</ul>
<p>2、优缺点</p>
<p>redux-thunk</p>
<ul>
<li>优点： 库小，代码就几行 </li>
<li>缺点：代码臃肿，reducer不再是纯粹函数，直接返回对象，违背了当初的设计原则；action的形式不统一，异步操作太为分散，分散在了各个action中</li>
</ul>
<p>redux-saga</p>
<ul>
<li>优点： 将异步与reducer区分开了，更加优雅，适合大量APi请求，而且每个请求之间存在复杂的依赖关系</li>
<li>缺点：学习曲线比较陡，理解async await；而且库也比较大，即使发布的最小也有25kb,gzip压缩后也有7KB,React压缩后才45kb</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎-React复用组件的状态和增强功能的方法"><a href="#♥︎♥︎♥︎♥︎-React复用组件的状态和增强功能的方法" class="headerlink" title="♥︎♥︎♥︎♥︎  React复用组件的状态和增强功能的方法"></a>♥︎♥︎♥︎♥︎  React复用组件的状态和增强功能的方法</h3><ul>
<li>render props模式</li>
<li>高阶组件（HOC）</li>
</ul>
<p>注意：以上两种方式不是新的API，而是演化而成的一种固定模式（写法)</p>
<ul>
<li><p>思路：将要复用的state和操作state的方法封装在一个组件里面（在组件中提供复用的状态逻辑代码，即状态和操作状态的方法）</p>
</li>
<li><p>这时，我们就要思考两个问题：（1）状态是组件内部私有的，那么如何在复用组件的时候拿到组件内部的state呢？—-&gt; 可以在使用组件的时候，添加一个值为函数的props，那么就可以通过函数参数来获取组件内部的state。（2）复用组件时，需要渲染的UI结构会不一样，那么怎么在复用组件时实现渲染任意的UI呢？—–&gt;将函数的返回值作为要渲染的UI</p>
</li>
<li><p>注意：复用的组件并没有渲染任何的UI结构，而且通过函数的返回值来渲染的。</p>
<p>以下通过一个简单的例子来演示使用render props模式实现的组件复用（一个效果是随着鼠标移动，获取鼠标的位置，另一个效果是图片随着鼠标移动而移动，这两个效果的实现都要获取x和y坐标，所以可以考虑用组件的复用来实现）</p>
</li>
</ul>
<p>Mouse组件（要复用的组件）</p>
<pre><code class="react">import React from &quot;react&quot;;
class Mouse extends React.Component &#123;
    //复用的state
    state = &#123;
        x: 0,
        y: 0
    &#125;
    //操作state的方法
    handleMouseMove = e =&gt; &#123;
        this.setState(&#123;
            x: e.clientX,
            y: e.clientY
        &#125;)
    &#125;
    //监听鼠标移动事件
    componentDidMount() &#123;
        window.addEventListener(&quot;mousemove&quot;, this.handleMouseMove)
    &#125;
    render()&#123;
        return this.props.render(this.state)   //通过函数参数暴露组件内部的状态
    &#125;
&#125;
export default Mouse;
</code></pre>
<p>Mouse_Tree组件（复用Mouse组件的组件）</p>
<pre><code class="react">import React from &quot;react&quot;;
import Mouse from &quot;./Mouse.js&quot;;
import img from &quot;./images/tree.PNG&quot;

class Mouse_Cat extends React.Component &#123;
    render()&#123;
        return(
            &lt;div&gt;
                &lt;Mouse render=&#123; mouse =&gt; &#123;
                    return(
                        &lt;p&gt;X坐标为：&#123;mouse.x&#125; Y坐标为：&#123;mouse.y&#125;&lt;/p&gt;
                    )
                &#125;&#125;/&gt;  
                &lt;Mouse render=&#123; mouse =&gt; &#123;
                    return(
                        &lt;img src=&#123;img&#125; alt=&quot;树&quot; style=&#123;&#123;
                            position: 'absolute',
                            top: mouse.y,
                            left: mouse.x
                        &#125;&#125;/&gt;
                    )
                &#125;&#125;/&gt;    
            &lt;/div&gt;
        )
    &#125;
&#125;
export default Mouse_Cat;
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎♥︎♥︎-React有哪些性能优化的手段？"><a href="#♥︎♥︎♥︎♥︎♥︎-React有哪些性能优化的手段？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ React有哪些性能优化的手段？"></a>♥︎♥︎♥︎♥︎♥︎ React有哪些性能优化的手段？</h3><p> 1、使用纯组件；</p>
<p> 2、使用 React.memo 进行组件记忆（React.memo 是一个高阶组件），对于相同的输入，不重复执行；</p>
<p> 3、如果是类组件，使用 shouldComponentUpdate（这是在重新渲染组件之前触发的其中一个生命周期事件）生命周期事件，可以利用此事件来决定何时需要重新渲染组件；</p>
<p> 4、路由懒加载；</p>
<p> 5、使用 React Fragments 避免额外标记；</p>
<p> 6、不要使用内联函数定义（如果我们使用内联函数，则每次调用“render”函数时都会创建一个新的函数实例）；</p>
<p> 7、避免在Willxxx系列的生命周期中进行异步请求，操作dom等；</p>
<p> 8、如果是类组件，事件函数在Constructor中绑定bind改变this指向；</p>
<p> 9、避免使用内联样式属性；</p>
<p> 10、优化 React 中的条件渲染；</p>
<p> 11、不要在 render 方法中导出数据；</p>
<p> 12、列表渲染的时候加key；</p>
<p> 13、在函数组件中使用useCallback和useMemo来进行组件优化，依赖没有变化的话，不重复执行；</p>
<p> 14、类组件中使用immutable对象；</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-调用this-setState之后，React都做了哪些操作？怎么拿到改变后的值？"><a href="#♥︎♥︎♥︎♥︎♥︎-调用this-setState之后，React都做了哪些操作？怎么拿到改变后的值？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 调用this.setState之后，React都做了哪些操作？怎么拿到改变后的值？"></a>♥︎♥︎♥︎♥︎♥︎ 调用this.setState之后，React都做了哪些操作？怎么拿到改变后的值？</h3><p>如果是在隶属于原生js执行的空间，比如说setTimeout里面，setState是同步的，那么每次执行setState将立即更新this.state，然后触发render方法；因为是同步执行，可以直接获取改变后的值；</p>
<p> 如果是在被react处理过的空间执行，比如说合成事件里，此时setState是异步执行的，并不会立即更新this.state的值，当执行setState的时候，会将需要更新的state放入状态队列，在这个空间最后再合并修改this.state，触发render；setState接受第二个参数，是一个回调函数，可以在这里获取改变后的state值；</p>
<p> 触发render执行后，会生成一个新的虚拟dom结构，然后触发diff运算，找到变化的地方，重新渲染； </p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-什么是-React-Fiber"><a href="#♥︎♥︎♥︎♥︎♥︎-什么是-React-Fiber" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 什么是 React Fiber?"></a>♥︎♥︎♥︎♥︎♥︎ 什么是 React Fiber?</h3><h4 id="React-Fiber-En"><a href="#React-Fiber-En" class="headerlink" title="React Fiber En"></a>React Fiber En</h4><p>Fiber是React16中新的协调引擎，它的主要目的是使Virtual DOM可以进行增量式渲染，让界面渲染更流畅一种流程控制原语，也称为协程，可以类比es6中的generator函数；React渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</p>
<p>一个执行单元，每次执行完一个“执行单元”，React就会检查现在还剩多少时间，如果没有时间就将控制权让出去。</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>把可中断的工作拆分成小任务</li>
<li>对正在做的工作调整优先次序、重做、复用上次（做了一半的）成果</li>
<li>在父子任务之间从容切换（yield back and forth），以支持React执行过程中的布局刷新</li>
<li>支持render()返回多个元素</li>
<li>更好地支持error boundary</li>
</ul>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>增量渲染（把渲染任务拆分成块，匀到多帧）</li>
<li>更新时能够暂停，终止，复用渲染任务</li>
<li>给不同类型的更新赋予优先级</li>
<li>并发方面新的基础能力</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎♥︎-简述一下-memoization"><a href="#♥︎♥︎♥︎♥︎♥︎-简述一下-memoization" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 简述一下 memoization"></a>♥︎♥︎♥︎♥︎♥︎ 简述一下 memoization</h3><p>memoization最初是用来优化计算机程序使之计算的更快的技术，是通过存储调用函数的结果并且在同样参数传进来的时候返回结果。大部分应该是在递归函数中使用。memoization 是一种优化技术，避免一些不必要的重复计算，可以提高计算速度。</p>
<p>以阶乘函数为例：</p>
<h4 id="1-不使用memoization"><a href="#1-不使用memoization" class="headerlink" title="1.不使用memoization"></a>1.不使用memoization</h4><pre><code class="javascript">const factorial = n =&gt; &#123;
  if (n === 1) &#123;
    return 1
  &#125; else &#123;
    return factorial(n - 1) * n
  &#125;
&#125;
</code></pre>
<h4 id="2-使用memoization"><a href="#2-使用memoization" class="headerlink" title="2.使用memoization"></a>2.使用memoization</h4><pre><code class="javascript">const cache = [] // 定义一个空的存放缓存的数组
const factorial = n =&gt; &#123;
  if (n === 1) &#123;
    return 1
  &#125; else if (cache[n - 1]) &#123; // 先从cache数组里查询结果，如果没找到的话再计算
    return cache[n - 1]
  &#125; else &#123;
    let result = factorial(n - 1) * n
    cache[n - 1] = result
    return result
  &#125;
&#125;
</code></pre>
<h4 id="3-搭配闭包使用memoization"><a href="#3-搭配闭包使用memoization" class="headerlink" title="3.搭配闭包使用memoization"></a>3.搭配闭包使用memoization</h4><pre><code class="javascript">const factorialMemo = () =&gt; &#123;
  const cache = []
  const factorial = n =&gt; &#123;
    if (n === 1) &#123;
      return 1
    &#125; else if (cache[n - 1]) &#123;
      console.log(`get factorial($&#123;n&#125;) from cache...`)
      return cache[n - 1]
    &#125; else &#123;
      let result = factorial(n - 1) * n
      cache[n - 1] = result
      return result
    &#125;
  &#125;
  return factorial
&#125;
const factorial = factorialMemo()
</code></pre>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>memorization 可以把函数每次的返回值存在一个数组或者对象中，在接下来的计算中可以直接读取已经计算过并且返回的数据，不用重复多次相同的计算。是一个空间换时间的方式，这种方法可用于部分递归中以提高递归的效率。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-自定义hooks（重点❗️❗️❗️）"><a href="#♥︎♥︎♥︎♥︎♥︎-自定义hooks（重点❗️❗️❗️）" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 自定义hooks（重点❗️❗️❗️）"></a>♥︎♥︎♥︎♥︎♥︎ 自定义hooks（重点❗️❗️❗️）</h3><p>[实现自定义hooks案例]: 	“<a href="https://juejin.cn/post/6844904074433789959">https://juejin.cn/post/6844904074433789959</a> “</p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试大全javaScript</title>
    <url>/2022/10/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8javaScript/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端面试题大全（JavaScript）"><a href="#前端面试题大全（JavaScript）" class="headerlink" title="前端面试题大全（JavaScript）"></a>前端面试题大全（JavaScript）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="♥︎-a-标签中，如何禁用-href-跳转页面或定位链接"><a href="#♥︎-a-标签中，如何禁用-href-跳转页面或定位链接" class="headerlink" title="♥︎ a 标签中，如何禁用 href 跳转页面或定位链接?"></a>♥︎ a 标签中，如何禁用 href 跳转页面或定位链接?</h3><p>在做页面时，如果想做一个链接点击后不做任何事情，或者响应点击而完成其他事情，可以设置其属性 href &#x3D; “#”，但是，这样会有一个问题，就是当页面有滚动条时，点击后会返回到页面顶端，用户体验不好。</p>
<h4 id="一、阻止默认事件"><a href="#一、阻止默认事件" class="headerlink" title="一、阻止默认事件"></a>一、阻止默认事件</h4><p>阻止默认事件的发生有两个方法：</p>
<pre><code class="javascript">return false
e.preventDefault()
</code></pre>
<p>通过阻止a标签默认事件就可以禁止a标签跳转！</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;http://www.baidu.com/&quot;&gt;去百度&lt;/a&gt;
    &lt;!-- 阻止默认事件两种方法 --&gt;
    &lt;a href=&quot;http://www.baidu.com/&quot; onclick=&quot;return false&quot;&gt;百度1&lt;/a&gt;
    &lt;a href=&quot;http://www.baidu.com/&quot; id=&quot;go&quot;&gt;百度1&lt;/a&gt;
    &lt;script&gt;
        //获取元素节点
        let go = document.querySelector(&quot;#go&quot;)
        //点击事件
        go.onclick = function(e)&#123;
            //阻止默认事件
            e.preventDefault();
        &#125;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="二、javascript：void（0）少用"><a href="#二、javascript：void（0）少用" class="headerlink" title="二、javascript：void（0）少用"></a>二、javascript：void（0）少用</h4><p>javascript:void(0)这是一种伪协议，void(0)在IE中可能会引起一些问题，比如：造成gif动画停止播放等。</p>
<p>void是javascipt自身的操作符，它表示的是只执行表达式，但没有返回值。</p>
<pre><code class="html">//这两种写法都可以，都表示一个死链接，点击无效果
&lt;a href=&quot;javascript:void(0)&quot;&gt;点击无法跳转(javascript:void(0))&lt;/a&gt;
&lt;a href=&quot;javascript:void(null)&quot;&gt;点击无法跳转(javascript:void(null))&lt;/a&gt;
</code></pre>
<h4 id="三、javascript：；"><a href="#三、javascript：；" class="headerlink" title="三、javascript：；"></a>三、javascript：；</h4><p>javascript:; 执行一段空白的javascript语句，返回空或者false值，从而防止链接跳转</p>
<p>javascript:; 写法比 javascript:void(0) 好，后者存在浏览器兼容bug</p>
<pre><code class="html">&lt;a href=&quot;javascript:;&quot;&gt;点击无法跳转（javascript:;）&lt;/a&gt;
</code></pre>
<h3 id="四、href"><a href="#四、href" class="headerlink" title="四、href(####)"></a>四、href(####)</h3><blockquote>
<p>使用2个到4个#，见的大多是”####”，也有使用”#all”等其他的。一个无意义的标签指定，不做任何处理。（这种方法会在浏览器地址栏上出现“####”）</p>
</blockquote>
<pre><code class="html">&lt;a href=&quot;####&quot;&gt;点击无法跳转&lt;/a&gt;
</code></pre>
<p>‼️注：制是用一个“#”是不行的，会默认刷新页面回到页面顶部</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><pre><code class="html">&lt;a href=&quot;javascript:void(0)&quot;&gt;点击无法跳转(javascript:void(0))&lt;/a&gt;
&lt;a href=&quot;javascript:void(null)&quot;&gt;点击无法跳转(javascript:void(null))&lt;/a&gt;
&lt;a href=&quot;javascript:;&quot;&gt;点击无法跳转（javascript:;）&lt;/a&gt;
&lt;a href=&quot;####&quot;&gt;点击无法跳转&lt;/a&gt;
&lt;a href=&quot;http://www.baidu.com/&quot; onclick=&quot;return false&quot;&gt;百度1&lt;/a&gt;
&lt;a href=&quot;http://www.baidu.com/&quot; id=&quot;go&quot;&gt;百度1&lt;/a&gt;
</code></pre>
<pre><code class="javascript">&lt;script&gt;
        //获取元素节点
        let go = document.querySelector(&quot;#go&quot;)
        //点击事件
        go.onclick = function(e)&#123;
            //阻止默认事件
            e.preventDefault();
        &#125;
&lt;/script&gt;
</code></pre>
<hr>
<h3 id="♥︎♥︎-介绍一下JS的内置类型有哪些？"><a href="#♥︎♥︎-介绍一下JS的内置类型有哪些？" class="headerlink" title="♥︎♥︎ 介绍一下JS的内置类型有哪些？"></a>♥︎♥︎ 介绍一下JS的内置类型有哪些？</h3><p>JS中共有七种内置数据类型</p>
<pre><code class="css">基本数据类型：null、undefined、boolean、string、number、symbol
引用数据类型：object(function、regexp、array、date)
</code></pre>
<p>‼️注：<br>1.Js中的数字类型是浮点型，不是整型<br>2.NaN属于数字类型</p>
<p>主要区别：存储位置不同。<br>1.基本数据类型存储在栈中，占据空间小，大小固定，可以被频繁使用；<br>2.引用数据类型存储在堆中，栈中存放指针，指针指向堆中该实体的起始地址，占据空间大，大小不固定，不适合被频繁使用。</p>
<h3 id="♥︎♥︎-解释下-let-和-const-的块级作用域"><a href="#♥︎♥︎-解释下-let-和-const-的块级作用域" class="headerlink" title="♥︎♥︎ 解释下 let 和 const 的块级作用域?"></a>♥︎♥︎ 解释下 let 和 const 的块级作用域?</h3><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>ES6中新增let关键字，用于声明变量。其用法类似var，但是所声明的变量只在let命令所在的块内有效。（块级作用域文章后面会进行讲解）</p>
<pre><code class="css">//let的特点
1.只作用于块级作用域。
2.不存在变量提升。
3.不允许重复声明。
4.暂时性死区（TDZ）。
</code></pre>
<h4 id="1-只作用于块级作用域。"><a href="#1-只作用于块级作用域。" class="headerlink" title="1.只作用于块级作用域。"></a>1.只作用于块级作用域。</h4><pre><code class="javascript">&#123;
    let a=10;
    var b=5;
    console.log(a,b) //输出a=10 b=5;
&#125;
console.log(b); //输出 b=5;
console.log(a); //报错 a is not defined
</code></pre>
<p>上述代码let声明的变量在块级作用域{ }中是有效的，但是在最后一行的输出就会直接报错，因为没有在块作用域{}中，a就没有被定义。</p>
<p>let命令更适合for循环</p>
<pre><code class="javascript">&#123;
    for(let i=0;i&lt;5;i++)&#123;
        console.log(i); //输出  0，1，2，3，4
    &#125;
    console.log(i);//报错 i is not defined
&#125;
&#123;
    for(var i=0;i&lt;5;i++)&#123;
        console.log(i);  //输出  0，1，2，3，4
    &#125;
    console.log(i);  //输出 5
&#125;
</code></pre>
<p>变量i是let声明的 当前i只在本轮循环有效，且只在本块级作用域有效，所以每一次循环的i其实都是一个新的变量。</p>
<p>你可能会问：如果每一轮循环的变量都是重新声明的 那它怎么知道上一轮循环的值，从而计算出本轮的值呢？</p>
<p>这是因为javascript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算</p>
<p>另外，for循环还有一个特别之处，for一个整体算一个块级作用域，那么设置循环变量那部分是一个父级作用域，而循环体内部是一个单独的子作用域</p>
<h4 id="2-不存在变量提升"><a href="#2-不存在变量提升" class="headerlink" title="2.不存在变量提升"></a>2.不存在变量提升</h4><p>let与var的区别，var存在变量提升，但是let不存在变量提升。<br>那么什么是变量提升呢？<br>变量提升：就是变量在声明前可以使用，而且不会报错，但是值为undefined。<br>意思是var声明的变量在其声明前使用是可以的不会报错，<br>但是let声明的变量一定要在其声明之后使用，否则就会报错。</p>
<pre><code class="javascript">&#123;
    console.log(a);//输出 undefined
    var a=2;
&#125;
&#123;
    console.log(b) //报错 Cannot access &#39;b&#39; before initialization
    let b=5;
&#125;
</code></pre>
<p>上诉代码用var声明的a会发生变量提升，那么值为undefined。<br>而有let声明的b就不发生变量提升，在声明前使用，b就是一个不存在的，那么就直接报错。</p>
<h4 id="3-不允许重复声明"><a href="#3-不允许重复声明" class="headerlink" title="3.不允许重复声明"></a>3.不允许重复声明</h4><p>let不允许在相同的作用域内重复声明同一个变量</p>
<pre><code class="javascript">&#123;
    var a=10;
    let a=5;//直接报错 Identifier &#39;a&#39; has already been declared
&#125;
&#123;
    let b=10;
    let b=5; //直接报错 Identifier &#39;b&#39; has already been declared
&#125;
&#123;
    const c=10;
    let c=5; //直接报错 Identifier &#39;c&#39; has already been declared
&#125;
&#123;
    function f1(foo)&#123;
    let foo; //报错  同时也不能在函数内部重新声明参数
    &#125;
&#125;
</code></pre>
<h4 id="4-暂时性死区"><a href="#4-暂时性死区" class="headerlink" title="4.暂时性死区"></a>4.暂时性死区</h4><p>只要用let声明的变量，那么这个变量就绑定这个块级作用域，不再受外部的影响;</p>
<pre><code class="javascript">&#123;
    var tmp=123;
    if(true)&#123;
        tmp=&quot;abc&quot;;//这里将会报错
        let tmp;
    &#125;
&#125;
</code></pre>
<p>因为let存在暂时性死区，只要区块中存在let与const命令，就算在最开始用var定义了tmp，但是在if里又是一个块级作用域，在if这个区域就形成一个封闭作用域，然后在let声明前对tmp的使用就会报错。</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const声明一个只读常量，一旦声明，常量的值就不能被改变。<br>const的与let的特点基本相同，同样不存在变量提升，存在暂时性死区，只能在声明后使用.</p>
<pre><code class="javascript">&#123;
    const p=8.12;
    p=10;//报错 Assignment to constant variable.
&#125;
</code></pre>
<p>const实际并不是变量的值不能改动，而是指向的那个内存地址所保存的数据不得改动；数据一半存储在堆中，<br>对于简单的基本数据类型（string number boolean null undefined）值保存在指向的那个内存地址，因此等同于常量。<br>但对于引用数据类型(object array ),变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的(即指向另一个固定的地址)，至于它指向的数据结构是不是可变的，就完全不能够控制了。</p>
<pre><code class="javascript">&#123;
    const foo=&#123;&#125;;
    foo.num=123;//这里就会成功不会报错，可以添加新的属性。
&#125;
</code></pre>
<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>ES5中只有全局作用域和函数作用域，没有块级作用域，ES6新增了块级作用域。</p>
<pre><code class="javascript">&#123;
    function f1()&#123;
    let a=5;
    if(true)&#123;
        let a=10;
        &#125;
    console.log(a);//输出 a=5。
&#125;
</code></pre>
<p>上述代码有2个代码块，f1是以个大的块作用域，里面嵌套了一个if小的块作用域，在if之外输出a是不会被影响的，从而输出a&#x3D;5。</p>
<p>块级作用域是可以嵌套的。</p>
<p>嵌套的作用域中外层的作用域不能访问内层作用域的变量，但是内层可以访问外层的.</p>
<pre><code class="javascript">//例子1
&#123;
    function f1()&#123;
        let a=10;
        if(true)&#123;
            console.log(a);
        &#125;
    &#125;
    f1();//输出a=10;
&#125;
//例子2
&#123;
    function f1()&#123;
        let b=0;
        console.log(b);//输出b=0;
        function f2()&#123;
            let c=10;
        &#125;
        console.log(c);
    &#125;
    f1();//报错  c没有定义
&#125;
</code></pre>
<h3 id="♥︎♥︎-将-1-2-与-3-4-合并为-1-2-3-4"><a href="#♥︎♥︎-将-1-2-与-3-4-合并为-1-2-3-4" class="headerlink" title="♥︎♥︎  将 [1,2] 与 [3,[4]] 合并为 [1,2,3,[4]]"></a>♥︎♥︎  将 [1,2] 与 [3,[4]] 合并为 [1,2,3,[4]]</h3><p>JS数组合并方法:</p>
<pre><code class="javascript">let arr3 = [1,2].concat([3,[4]]); //[1,2,3,[4]]
</code></pre>
<h3 id="♥︎♥︎-Array-forEach-与-Array-map-的区别，Array-slice-与-Array-splice-的区别？"><a href="#♥︎♥︎-Array-forEach-与-Array-map-的区别，Array-slice-与-Array-splice-的区别？" class="headerlink" title="♥︎♥︎ Array.forEach() 与 Array.map() 的区别，Array.slice() 与 Array.splice() 的区别？"></a>♥︎♥︎ Array.forEach() 与 Array.map() 的区别，Array.slice() 与 Array.splice() 的区别？</h3><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>forEach不支持return (没有返回值),对原来的数组也没有影响。但是我们可以自己通过数组的索引来修改原来的数组</p>
<pre><code class="javascript">var ary = [12,23,24,42,1];
var res = ary.forEach(function (item,index,input) &#123;
 input[index] = item10;
&#125;)
console.log(res); //--&gt;undefined;
console.log(ary); //--&gt;会对原来的数组产生改变；
</code></pre>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map支持return返回值，也不影响原数组，但是会返回一个新的数组</p>
<pre><code class="javascript">var ary = [12,23,24,42,1];
var res = ary.map(function (item,index,input) &#123;
 return item*10;
&#125;)
console.log(res);//--&gt;[120,230,240,420,10];
console.log(ary);//--&gt;[12,23,24,42,1]；
</code></pre>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><pre><code class="css">array.slice(start,end)函数是取array数组中指定的一些元素：
根据数组下标start和end，两个参数为取值的开始和结束下标，取出的值不包括end位置的值，生成一个新数组作为返回值；
这里end可以为空，为空则取从start位置到数组结尾的元素，生成新数组。
</code></pre>
<h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><pre><code class="css">array.splice(start,length,insert_one......)函数则是直接在原数组进行删除、添加、替换元素的操作：
start为数组删除元素的开始下标，
length为从start位置开始array删除元素的个数，
后面参数为删除之后array重新插入的数据内容，插入位置为删除位置，而非数组开头或末尾，
返回值为array删除的元素组成的数组。
显而易见，splice函数可以用来对数组元素进行替换。由splice操作后的数组array，数组中内容如果已
经改变，就再也找不回array在splice之前的模样。
</code></pre>
<h3 id="♥︎♥︎-将-1234567-转换为-1-234-567"><a href="#♥︎♥︎-将-1234567-转换为-1-234-567" class="headerlink" title="♥︎♥︎  将 1234567 转换为 1,234,567"></a>♥︎♥︎  将 1234567 转换为 1,234,567</h3><p>千位分割符方法有以下几种</p>
<p>只适用整数</p>
<pre><code class="javascript">function format (num) &#123;
    var reg=/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g; 
    return (num + &#39;&#39;).replace(reg, &#39;$&amp;,&#39;);
&#125;
console.log(format(1233453464)) //1,233,453,464
</code></pre>
<pre><code class="javascript">function format (num) &#123;
    num=num+&#39;&#39;;//数字转字符串
     var str=&quot;&quot;;//字符串累加
     for(var i=num.length- 1,j=1;i&gt;=0;i--,j++)&#123;
         if(j%3==0 &amp;&amp; i!=0)&#123;//每隔三位加逗号，过滤正好在第一个数字的情况
             str+=num[i]+&quot;,&quot;;//加千分位逗号
             continue;
         &#125;
         str+=num[i];//倒着累加数字
     &#125;
     return str.split(&#39;&#39;).reverse().join(&quot;&quot;);//字符串=&gt;数组=&gt;反转=&gt;字符串
   &#125;
console.log(format(12312432343543)) //12,312,432,343,543
</code></pre>
<p>整数部分加小数部分不动</p>
<pre><code class="javascript">var format = (str) =&gt; str.replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, &#39;,&#39;)
console.log(format(&#39;12313453.63&#39;)) //12,313,453.63
</code></pre>
<p>一整套千分位转换</p>
<pre><code class="javascript">    // 将金额类型转为数字类型
    function toNum(str) &#123;
        return str.replace(/\,|\￥/g, &quot;&quot;);
    &#125;

    // 保留两位小数（四舍五入）
    function toPrice(num) &#123;
        num = parseFloat(toNum(num)).toFixed(2).toString().split(&quot;.&quot;);
        num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
        return &quot;￥&quot; + num.join(&quot;.&quot;);
    &#125;
    
    // 保留两位小数（不四舍五入）
    function toPrice1(num) &#123;
        num = parseFloat(toNum(num).replace(/(\.\d&#123;2&#125;)\d+$/,&quot;$1&quot;)).toFixed(2).toString().split(&quot;.&quot;);
        num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
        return &quot;￥&quot; + num.join(&quot;.&quot;);;
    &#125;
    
    // 不处理小数部分
    function toPrice2(num) &#123;
        var source = toNum(num).split(&quot;.&quot;);
        source[0] = source[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
        return &quot;￥&quot; + source.join(&quot;.&quot;);
    &#125;
    console.log(toNum(&#39;1,234,345.4&#39;)) //1234345.4
    console.log(toPrice(&#39;12123213.43545&#39;)) //￥12,123,213.44
    console.log(toPrice1(&#39;12312312.43645&#39;)) //￥12,312,312.43
    console.log(toPrice2(&#39;12312345.324&#39;)) //￥12,312,345.324
</code></pre>
<h3 id="♥︎♥︎-Promise-resolve-Promise-resolve-1-then-console-log-输出？"><a href="#♥︎♥︎-Promise-resolve-Promise-resolve-1-then-console-log-输出？" class="headerlink" title="♥︎♥︎ Promise.resolve(Promise.resolve(1)).then(console.log) 输出？"></a>♥︎♥︎ Promise.resolve(Promise.resolve(1)).then(console.log) 输出？</h3><pre><code class="javascript">Promise.resolve(Promise.resolve(1)).then(console.log) //1
</code></pre>
<h3 id="♥︎♥︎-使用-setTimeout-模拟-setInterval-的功能做一个60秒的倒数计时"><a href="#♥︎♥︎-使用-setTimeout-模拟-setInterval-的功能做一个60秒的倒数计时" class="headerlink" title="♥︎♥︎ 使用 setTimeout 模拟 setInterval 的功能做一个60秒的倒数计时"></a>♥︎♥︎ 使用 setTimeout 模拟 setInterval 的功能做一个60秒的倒数计时</h3><pre><code class="javascript">var num=60;
var max=0;
function incrementNumber()&#123;
  num--;
  if(num&gt;max)&#123;
      setTimeout(incrementNumber,1000);
      console.log(num);
  &#125;
  else&#123;
    console.log(&#39;Done&#39;);
  &#125;
&#125;
setTimeout(incrementNumber,1000);
</code></pre>
<h3 id="♥︎♥︎-写一个-function，清除字符串前后的空格。（兼容所有的浏览器）"><a href="#♥︎♥︎-写一个-function，清除字符串前后的空格。（兼容所有的浏览器）" class="headerlink" title="♥︎♥︎ 写一个 function，清除字符串前后的空格。（兼容所有的浏览器）"></a>♥︎♥︎ 写一个 function，清除字符串前后的空格。（兼容所有的浏览器）</h3><pre><code class="javascript">function trim(str) &#123;
    if (str &amp;&amp; typeof str === &quot;string&quot;) &#123;
    return str.replace(/(^\s)|(\s)$/g,&quot;&quot;); //去除前后空白符
    &#125;
   &#125;
console.log(&#39;  2342.4  &#39;)//  2342.4
console.log(trim(&#39;  2342.4  &#39;))//2342.4
</code></pre>
<h3 id="♥︎♥︎-使用正则表达式验证邮箱格式。"><a href="#♥︎♥︎-使用正则表达式验证邮箱格式。" class="headerlink" title="♥︎♥︎  使用正则表达式验证邮箱格式。"></a>♥︎♥︎  使用正则表达式验证邮箱格式。</h3><pre><code class="javascript">var reg = /^(\w)+(\.\w+)*@(\w)+((\.\w&#123;2,3&#125;)&#123;1,3&#125;)$/;
var email = &quot;1246815351@qq.com&quot;;
console.log(reg.test(email)); //true
</code></pre>
<h3 id="♥︎♥︎-JavaScript-中-callee-和-caller-的作用"><a href="#♥︎♥︎-JavaScript-中-callee-和-caller-的作用" class="headerlink" title="♥︎♥︎ JavaScript 中 callee 和 caller 的作用"></a>♥︎♥︎ JavaScript 中 callee 和 caller 的作用</h3><h4 id="1-callee"><a href="#1-callee" class="headerlink" title="1.callee"></a>1.callee</h4><p>callee是对象的一个属性，该属性是一个指针，指向参数arguments对象的函数</p>
<p>作用：就是用来指向当前对象</p>
<p>返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文. </p>
<p>callee是arguments 的一个属性成员，它表示对函数对象本身的引用，这有利于匿名</p>
<p>函数的递归或者保证函数的封装性</p>
<h4 id="2-caller"><a href="#2-caller" class="headerlink" title="2.caller"></a>2.caller</h4><p>caller是函数对象的一个属性，该属性保存着调用当前函数的函数的引用（指向当前函数的直接父函数）</p>
<p>返回一个对函数的引用，该函数调用了当前函数。</p>
<p>functionName.caller</p>
<p>functionName 对象是所执行函数的名称。</p>
<p>‼️注意：</p>
<p>对于函数来说，caller 属性只有在函数执行时才有定义。 如果函数是由 Javascript 程序的顶层调用的，</p>
<p>那么 caller 包含的就是 null 。</p>
<h3 id="♥︎♥︎-统计字符串中字母个数或统计最多的字母数。"><a href="#♥︎♥︎-统计字符串中字母个数或统计最多的字母数。" class="headerlink" title="♥︎♥︎ 统计字符串中字母个数或统计最多的字母数。"></a>♥︎♥︎ 统计字符串中字母个数或统计最多的字母数。</h3><pre><code class="javascript">function count()&#123;
    var str=&quot;aaaabbbbsssseeeeqqaaasss&quot;;
    var obj=&#123;&#125;;
    for(var i=0;i&lt;str.length; i++)&#123;
        if(obj[str.charAt(i)]==undefined)&#123;  
        //对象初始化；如果key在对象中找不到，那么会返回undefined,反向思维
            obj[str.charAt(i)]= 1;
        &#125; else&#123;
            obj[str.charAt(i)]++;
        &#125;
    &#125;
    return obj;  //&#123; a: 7, b: 4, s: 7, e: 4, q: 2 &#125;
    //取出各个字母和它的个数，作为一个新对象保存在obj对象;
&#125;

function numberCount(obj)&#123;
    var mm=&quot;&quot;;
    for(var m in obj)&#123;
        if(mm==&quot;&quot;)&#123;
            mm=new Object();
            mm[m]=obj[m];
        &#125;else&#123;
            for(var j in mm)&#123;
               if(mm[j]&lt;obj[m])&#123;
                   //清空原来的内容
                   mm=new Object();
                   //放入新的内容
                   mm[m]=obj[m];
               &#125;
            &#125;
        &#125;
    &#125;
    console.log(mm); //&#123; a: 7 &#125;
&#125;
numberCount(count());
</code></pre>
<h3 id="♥︎♥︎-简述一下面象对象的六法则"><a href="#♥︎♥︎-简述一下面象对象的六法则" class="headerlink" title="♥︎♥︎ 简述一下面象对象的六法则"></a>♥︎♥︎ 简述一下面象对象的六法则</h3><ol>
<li><p>单一职责原则：一个类只做它该做的事情</p>
</li>
<li><p>开闭原则：软件实体应当对扩展开放，对修改关闭</p>
</li>
<li><p>依赖倒转原则：面向接口编程</p>
</li>
<li><p>接口隔离原则：接口要小而专，绝不能大而全</p>
</li>
<li><p>合成聚合复用原则：优先使用聚合或合成关系复用代码</p>
</li>
<li><p>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解(低耦合)</p>
</li>
</ol>
<h3 id="♥︎♥︎-jQuery-优点和缺点"><a href="#♥︎♥︎-jQuery-优点和缺点" class="headerlink" title="♥︎♥︎  jQuery 优点和缺点"></a>♥︎♥︎  jQuery 优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><pre><code class="css">1.出色的浏览器兼容性
2、出色的DOM操作的封装，使他具备强大的选择器，可以进行快速的DOM元素操作
3、可靠的事件处理机制、jq在处理事件绑定的时候是相当的可靠
4、完善的ajax（对ajax的封装非常好，不需要考虑复杂的浏览器的兼容和XMLhttprequest对象的创建
和使用）
5、支持链式操作（什么是链式操作？通过‘.’来操作）和隐士迭代
6、减少服务器的压力和带宽并且加快了加载速度（为什么这么说？原因就是：当你打开网页之前打开了
其他的网页，并且该网页也用了cdn的方式来
// 调用父类原型push方法 return super.push(...args)
加载相同版本的jq文件，那么，浏览器就不会加载第二次，为啥舍近求远呢，和生活中的道理一样一样
的！）
7、支持丰富的插件，当然你也可以自定义插件，再加上jq的文档也很丰富，对于程序员来说，是一件非常美好的事情
</code></pre>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><pre><code class="css">1.不能向后兼容。
每一个新版本不能兼容早期的版本。举例来说，有些新版本不再支持某些selector，新版jQuery却没有保留对它们的支持，而只是简单的将其移除。这可能会影响到开发者已经编写好的代码或插件。
2.插件兼容性。
与上一点类似，当新版jQuery推出后，如果开发者想升级的话，要看插件作者是否支持。通常情况下，在最新版jQuery版本下，现有插件可能无法正常使用。开发者使用的插件越多，这种情况发生的几率也越高。我有一次为了升级到jQuery 1.3，不得不自己动手修改了一个第三方插件。
3.多个插件冲突。
在同一页面上使用多个插件时，很容易碰到冲突现象，尤其是这些插件依赖相同事件或selector时最为明显。这虽然不是jQuery自身的问题，但却又确实是一个难于调试和解决的问题。
4.jQuery的稳定性。
jQuery没有让浏览器崩溃，这里指的是其版本发布策略。jQuery 1.3版发布后仅过数天，就发布了一个漏洞修正版1.3.1。他们还移除了对某些功能的支持，可能会影响许多代码的正常运行。我希望类似修改不要再出现。
5.对动画和特效的支持差。
在大型框架中，jQuery核心代码库对动画和特效的支持相对较差。但是实际上这不是一个问题。目前在这方面有一个单独的jQuery UI项目和众多插件来弥补此点。
</code></pre>
<h3 id="♥︎♥︎-AMD-怎么加载文件的"><a href="#♥︎♥︎-AMD-怎么加载文件的" class="headerlink" title="♥︎♥︎ AMD 怎么加载文件的?"></a>♥︎♥︎ AMD 怎么加载文件的?</h3><p>AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范</p>
<p>由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</p>
<p>requireJS主要解决两个问题</p>
<p>1.多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</p>
<p>2.js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</p>
<p>require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<h3 id="♥︎♥︎-jQuery-怎么找到事件源元素"><a href="#♥︎♥︎-jQuery-怎么找到事件源元素" class="headerlink" title="♥︎♥︎ jQuery 怎么找到事件源元素"></a>♥︎♥︎ jQuery 怎么找到事件源元素</h3><pre><code class="javascript">$(&quot;.btn&quot;).click(function(e)&#123;
 // e 就是事件对象
 e.target; // 事件的目标 dom
 e.currentTarget; // 事件处理程序正在处理事件的那个元素
 e.srcElement; // 事件的目标 ie
&#125;);
</code></pre>
<h3 id="♥︎♥︎-2018-x2F-01-x2F-01-转换成-2018年-x2F-1月-x2F-1日"><a href="#♥︎♥︎-2018-x2F-01-x2F-01-转换成-2018年-x2F-1月-x2F-1日" class="headerlink" title="♥︎♥︎ 2018&#x2F;01&#x2F;01 转换成 2018年&#x2F;1月&#x2F;1日"></a>♥︎♥︎ 2018&#x2F;01&#x2F;01 转换成 2018年&#x2F;1月&#x2F;1日</h3><pre><code class="javascript">function fun(str)&#123;
    var date = new Date(str)
    return date.getFullYear()+&#39;年/&#39;+ date.getMonth()+&#39;月/&#39;+date.getDate()+&#39;日&#39; 
&#125;
console.log(fun(&#39;2018/03/01&#39;))//2018年/2月/1日
</code></pre>
<h3 id="♥︎♥︎-for-in-循环会遍历出原型上的属性吗？怎么避免遍历到原型上的属性"><a href="#♥︎♥︎-for-in-循环会遍历出原型上的属性吗？怎么避免遍历到原型上的属性" class="headerlink" title="♥︎♥︎ for-in 循环会遍历出原型上的属性吗？怎么避免遍历到原型上的属性"></a>♥︎♥︎ for-in 循环会遍历出原型上的属性吗？怎么避免遍历到原型上的属性</h3><p>使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问</p>
<p>只遍历对象自身的属性，而不遍历继承于原型链上的属性，需要使用hasOwnProperty 方法过滤一下。</p>
<pre><code class="javascript">Object.prototype.say=&quot;cgl&quot;;
 var person =&#123;
 age: 18
 &#125;;
 for (var key in person) &#123;
 if(person.hasOwnProperty(key))&#123;
 console.log(key, eval(&quot;person.&quot;+key));//age 18
 &#125;
 &#125;
</code></pre>
<h3 id="♥︎♥︎-ES6-箭头函数和普通函数有什么差异？"><a href="#♥︎♥︎-ES6-箭头函数和普通函数有什么差异？" class="headerlink" title="♥︎♥︎  ES6 箭头函数和普通函数有什么差异？"></a>♥︎♥︎  ES6 箭头函数和普通函数有什么差异？</h3><ol>
<li><p>相比普通函数更简洁的语法</p>
</li>
<li><p>没有this,捕获其所在上下文的 this 值，作为自己的 this 值 </p>
</li>
<li><p>不能使用new,箭头函数作为匿名函数,是不能作为构造函数的,不能使用new</p>
</li>
<li><p>不绑定arguments，用rest参数…解决</p>
</li>
<li><p>使用call()和apply()调用:由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并没有什么影响：</p>
</li>
<li><p>箭头函数没有原型属性</p>
</li>
<li><p>不能简单返回对象字面量</p>
</li>
</ol>
<p>let fun5 &#x3D; ()&#x3D;&gt;({ foo: x }) &#x2F;&#x2F;如果x &#x3D;&gt; { foo: x } &#x2F;&#x2F;则语法出错</p>
<ol start="8">
<li><p>箭头函数不能当做Generator函数,不能使用yield关键字</p>
</li>
<li><p>箭头函数不能换行</p>
</li>
</ol>
<h3 id="♥︎♥︎-import-export-commonJS-对比区别"><a href="#♥︎♥︎-import-export-commonJS-对比区别" class="headerlink" title="♥︎♥︎  import export commonJS 对比区别"></a>♥︎♥︎  import export commonJS 对比区别</h3><p>ES6和commonJS的一些区别</p>
<p>从语法的角度上看，ES6模块化的import 和 export 是一个内置的标识，而commonJS的</p>
<p>module.exports 和 require 分别是js对象和方法。其ES6模块化和commonJS的实现方式不同。</p>
<p>1.ES6是在编译的时候导入文件，而commonJS是编译完成后，在通过require方法导入，并读取文件导出的文件，并返回一个module.exports对象</p>
<p>2.在ES6模块的内部this是问undefined，而commonJS的this为一个空对象</p>
<p>3.ES6模块输出的是一个引用，而commonJS模块输出的是一个值的引用</p>
<h3 id="♥︎♥︎-为什么-JavaScript-是单线程"><a href="#♥︎♥︎-为什么-JavaScript-是单线程" class="headerlink" title="♥︎♥︎ 为什么 JavaScript 是单线程"></a>♥︎♥︎ 为什么 JavaScript 是单线程</h3><p>js作为主要运行在浏览器的脚本语言，js主要用途之一是操作DOM。</p>
<p>举一个栗子，如果js同时有两个线程，同时对同一个dom进行操作，这时浏览器应该听哪个线程的，如何判断优先级？</p>
<p>为了避免这种问题，js必须是一门单线程语言</p>
<h3 id="♥︎♥︎-JS的基本数据类型判断有什么方法？"><a href="#♥︎♥︎-JS的基本数据类型判断有什么方法？" class="headerlink" title="♥︎♥︎ JS的基本数据类型判断有什么方法？"></a>♥︎♥︎ JS的基本数据类型判断有什么方法？</h3><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h4><pre><code class="css">typeof&#39;&#39;;// string 有效
 typeof 1;// number 有效
 typeof Symbol();// symbol 有效
 typeof true;//boolean 有效
 typeof undefined;//undefined 有效
 typeof new Function();// function 有效
 typeof null;//object 无效
 typeof [] ;//object 无效
 typeof new Date();//object 无效
 typeof new RegExp();//object 无效
</code></pre>
<h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h4><pre><code class="css">instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型
</code></pre>
<h4 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3.constructor"></a>3.constructor</h4><pre><code class="css">当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个constructor 属性
</code></pre>
<h4 id="4-toString"><a href="#4-toString" class="headerlink" title="4.toString"></a>4.toString</h4><pre><code class="css">toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。
对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。
 Object.prototype.toString.call(&#39;&#39;) ; // [object String]
 Object.prototype.toString.call(1) ; // [object Number]
 Object.prototype.toString.call(true) ;// [object Boolean]
 Object.prototype.toString.call(Symbol());//[object Symbol]
 Object.prototype.toString.call(undefined) ;// [object Undefined]
 Object.prototype.toString.call(null) ;// [object Null]
 Object.prototype.toString.call(newFunction()) ;// [object Function]
 Object.prototype.toString.call(newDate()) ;// [object Date]
 Object.prototype.toString.call([]) ;// [object Array]
 Object.prototype.toString.call(newRegExp()) ;// [object RegExp]
 Object.prototype.toString.call(newError()) ;// [object Error]
 Object.prototype.toString.call(document) ;// [object HTMLDocument]
 Object.prototype.toString.call(window) ;//[object global] window 是全局对象 global 的引用
</code></pre>
<h3 id="♥︎♥︎-介绍下事件代理，主要解决什么问题"><a href="#♥︎♥︎-介绍下事件代理，主要解决什么问题" class="headerlink" title="♥︎♥︎ 介绍下事件代理，主要解决什么问题"></a>♥︎♥︎ 介绍下事件代理，主要解决什么问题</h3><ol>
<li><p>绑定事件太多，浏览器占用内存变大，严重影响性能</p>
</li>
<li><p>Ajax出现，局部刷新盛行，每次加载完，都要重新绑定事件</p>
</li>
<li><p>部分浏览器移除元素时，绑定的事件没有被及时移除，导致内存泄漏，严重影响性能</p>
</li>
<li><p>Ajax中重复绑定，导致代码耦合性过大，影响后期维护</p>
</li>
</ol>
<h3 id="♥︎♥︎-new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？"><a href="#♥︎♥︎-new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？" class="headerlink" title="♥︎♥︎ new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？"></a>♥︎♥︎ new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？</h3><p>new操作符的作用如下：</p>
<p>1.创建一个空对象</p>
<p>2.由this变量引用该对象</p>
<p>3.该对象继承该函数的原型</p>
<p>4.把属性和方法加入到this引用的对象中</p>
<p>5.新创建的对象由this引用，最后隐式地返回this。</p>
<p>区别:</p>
<p>字面量创建不会调用 Object构造函数, 简洁且性能更好;</p>
<h3 id="♥︎♥︎-数组去重的方法"><a href="#♥︎♥︎-数组去重的方法" class="headerlink" title="♥︎♥︎ 数组去重的方法"></a>♥︎♥︎ 数组去重的方法</h3><h4 id="方法一：双层循环，外层循环元素，内层循环时比较值"><a href="#方法一：双层循环，外层循环元素，内层循环时比较值" class="headerlink" title="方法一：双层循环，外层循环元素，内层循环时比较值"></a>方法一：双层循环，外层循环元素，内层循环时比较值</h4><p>如果有相同的值则跳过，不相同则push进数组</p>
<pre><code class="javascript">Array.prototype.distinct = function()&#123;
 var arr = this,
 result = [],
 i,
 j,
 len = arr.length;
 for(i = 0; i &lt; len; i++)&#123;
 for(j = i + 1; j &lt; len; j++)&#123;
 if(arr[i] === arr[j])&#123;
 j = ++i;
 &#125;
 &#125;
 result.push(arr[i]);
 &#125;
 return result;
&#125;
var arra = [1,2,3,4,4,1,1,2,1,1,1];
arra.distinct(); //返回[3,4,2,1]
</code></pre>
<h4 id="方法二：利用splice直接在原数组进行操作"><a href="#方法二：利用splice直接在原数组进行操作" class="headerlink" title="方法二：利用splice直接在原数组进行操作"></a>方法二：利用splice直接在原数组进行操作</h4><p>双层循环，外层循环元素，内层循环时比较值 值相同时，则删去这个值</p>
<p>注意点:删除元素之后，需要将数组的长度也减1.</p>
<p>优点：简单易懂</p>
<p>缺点：占用内存高，速度慢</p>
<pre><code class="javascript">Array.prototype.distinct = function ()&#123;
 var arr = this,
 i,
 j,
 len = arr.length;
 for(i = 0; i &lt; len; i++)&#123;
 for(j = i + 1; j &lt; len; j++)&#123;
 if(arr[i] == arr[j])&#123;
 arr.splice(j,1);
 len--;
 j--;
 &#125;
 &#125;
 &#125;
 return arr;
&#125;;
var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,];
var b = a.distinct();
console.log(b.toString()); //1,2,3,4,5,6,56
</code></pre>
<h4 id="方法三：利用对象的属性不能相同的特点进行去重"><a href="#方法三：利用对象的属性不能相同的特点进行去重" class="headerlink" title="方法三：利用对象的属性不能相同的特点进行去重"></a>方法三：利用对象的属性不能相同的特点进行去重</h4><pre><code class="javascript">Array.prototype.distinct = function ()&#123;
 var arr = this,
 i,
 obj = &#123;&#125;,
 result = [],
 len = arr.length;
 for(i = 0; i&lt; arr.length; i++)&#123;
 if(!obj[arr[i]])&#123; //如果能查找到，证明数组元素重复了
 obj[arr[i]] = 1;
 result.push(arr[i]);
 &#125;
 &#125;
 return result;
&#125;;
var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,];
var b = a.distinct();
console.log(b.toString()); //1,2,3,4,5,6,56
</code></pre>
<h4 id="方法四：数组递归去重"><a href="#方法四：数组递归去重" class="headerlink" title="方法四：数组递归去重"></a>方法四：数组递归去重</h4><p>运用递归的思想</p>
<p>先排序，然后从最后开始比较，遇到相同，则删除</p>
<pre><code class="javascript">Array.prototype.distinct = function ()&#123;
 var arr = this,
 len = arr.length;
 arr.sort(function(a,b)&#123; //对数组进行排序才能方便比较
 return a - b;
 &#125;)
 function loop(index)&#123;
 if(index &gt;= 1)&#123;
 if(arr[index] === arr[index-1])&#123;
 arr.splice(index,1);
 &#125;
 loop(index - 1); //递归loop函数进行去重
 &#125;
 &#125;
 loop(len-1);
 return arr;
&#125;;
var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,56,45,56];
var b = a.distinct();
console.log(b.toString()); //1,2,3,4,5,6,45,56
</code></pre>
<h4 id="方法五：利用indexOf以及forEach"><a href="#方法五：利用indexOf以及forEach" class="headerlink" title="方法五：利用indexOf以及forEach"></a>方法五：利用indexOf以及forEach</h4><pre><code class="javascript">Array.prototype.distinct = function ()&#123;
 var arr = this,
 result = [],
 len = arr.length;
 arr.forEach(function(v, i ,arr)&#123; //这里利用map，filter方法也可以实现
 var bool = arr.indexOf(v,i+1); //从传入参数的下一个索引值开始寻找是否存在重复
 if(bool === -1)&#123;
 result.push(v);
 &#125;
 &#125;)
 return result;
&#125;;
var a = [1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,3,2,3,3,2,2,1,23,1,23,2,3,2,3,2,3];
var b = a.distinct();
console.log(b.toString()); //1,23,2,3
</code></pre>
<h3 id="方法六：利用ES6的set"><a href="#方法六：利用ES6的set" class="headerlink" title="方法六：利用ES6的set"></a>方法六：利用ES6的set</h3><p>Set数据结构，它类似于数组，其成员的值都是唯一的。</p>
<p>利用Array.from将Set结构转换成数组</p>
<pre><code class="javascript">function dedupe(array)&#123;
 return Array.from(new Set(array));
&#125;
dedupe([1,1,2,3]) //[1,2,3]
//拓展运算符(...)内部使用for...of循环
//123
let arr = [1,2,3,3];
let resultarr = [...new Set(arr)]; 
console.log(resultarr); //[1,2,3]
</code></pre>
<h3 id="♥︎♥︎-并行和并发的区别是什么？"><a href="#♥︎♥︎-并行和并发的区别是什么？" class="headerlink" title="♥︎♥︎ 并行和并发的区别是什么？"></a>♥︎♥︎ 并行和并发的区别是什么？</h3><p>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度</p>
<p>并发表示多个任务同时都要执行</p>
<h3 id="♥︎♥︎-是否所有函数都有-prototype-一说？"><a href="#♥︎♥︎-是否所有函数都有-prototype-一说？" class="headerlink" title="♥︎♥︎ 是否所有函数都有 prototype 一说？"></a>♥︎♥︎ 是否所有函数都有 prototype 一说？</h3><pre><code class="css">1. 使用Function.prototype.bind创建的函数对象
function abc()&#123;console.log(&#39;abc&#39;)&#125;
var binded = abc.bind(null)
binded() //abc
console.log(binded.prototype) //undefined

2. 箭头函数也没有
var abc = ()=&gt;&#123;console.log(&#39;abc&#39;)&#125;
abc() //abc
console.log(abc.prototype) //undefined
</code></pre>
<h3 id="♥︎♥︎-为什么-await-在-forEach-中不生效？如何解决？"><a href="#♥︎♥︎-为什么-await-在-forEach-中不生效？如何解决？" class="headerlink" title="♥︎♥︎ 为什么 await 在 forEach 中不生效？如何解决？"></a>♥︎♥︎ 为什么 await 在 forEach 中不生效？如何解决？</h3><p>lodash的forEach和[].forEach不支持await, forEach 只支持同步代码。 </p>
<p>解决方法1：使用 for…of</p>
<p>解决方法2：使用 for循环</p>
<p>解决方法3：让forEach支持async await</p>
<p>forEach 在正常情况像下面这么写肯定是做不到同步的，程序不会等一个循环中的异步完成再进行下一个循环。原因很明显，在下面的模拟中，while 循环只是简单执行了 callback，所以尽管 callback 内使用了 await ，也只是影响到 callback 内部。</p>
<pre><code class="javascript">arr.myforeach(async v =&gt; &#123;
 await fetch(v);
&#125;);
</code></pre>
<p>要支持上面这种写法，只要稍微改一下就好</p>
<pre><code class="javascript">Array.prototype.myforeach = async function (fn, context = null) &#123;
 let index = 0;
 let arr = this;
 if (typeof fn !== &#39;function&#39;) &#123;
 throw new TypeError(fn + &#39; is not a function&#39;);
 &#125;
 while (index &lt; arr.length) &#123;
 if (index in arr) &#123;
 try &#123;
 await fn.call(context, arr[index], index, arr);
 &#125; catch (e) &#123;
 console.log(e);
 &#125;
 &#125;
 index ++;
 &#125;
&#125;;
</code></pre>
<h3 id="♥︎♥︎-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#♥︎♥︎-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="♥︎♥︎ 请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>♥︎♥︎ 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><p>1.存储大小</p>
<pre><code class="css">cookie数据大小不能超过4k。

sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
</code></pre>
<p>2.有效时间</p>
<pre><code class="css">localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；

sessionStorage 数据在当前浏览器窗口关闭后自动删除。

cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
</code></pre>
<ol start="3">
<li>数据与服务器之间的交互方式</li>
</ol>
<pre><code class="css">cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端

sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎-介绍一下类型转换"><a href="#♥︎♥︎♥︎-介绍一下类型转换" class="headerlink" title="♥︎♥︎♥︎ 介绍一下类型转换"></a>♥︎♥︎♥︎ 介绍一下类型转换</h3><p>&#x2F;<em>——————-<em>显式转换</em>———————</em>&#x2F; </p>
<pre><code class="css">1. toString() // 转化为字符串，不可以转null和underfined
2. Number() // 转换为数字，字符串中有一个不是数值的字符，返回NaN
3. parseInt() // 转换为数字，第一个字符不是数字或者符号就返回NaN
4. String() // 转换为字符串，
5. Boolean() // 转换为布尔值
</code></pre>
<p>&#x2F;<em>——————-<em>隐式转换</em>(+-)———————</em>&#x2F; </p>
<p>当 JavaScript 尝试操作一个 “错误” 的数据类型时，会自动转换为 “正确” 的数据类型</p>
<pre><code class="css">1. num + &quot;&quot; -&gt; String
2. num + bool -&gt; num
// 当加号运算符时，String和其他类型时，其他类型都会转为 String；其他情况，都转化为Number类型
3. string - num -&gt; num
// 其他运算符时， 基本类型都转换为 Number，String类型的带有字符的比如：
4. &#39;a1&#39; - num -&gt; NaN
// 与undefined 一样。
</code></pre>
<p>&#x2F;<em>——————-<em>隐式转换</em>(<em>逻辑表达式</em>)———————</em>&#x2F; </p>
<pre><code class="css">1. 对象和布尔值比较
对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字
[] == true; //false []转换为字符串&#39;&#39;,然后转换为数字0,true转换为数字1，所以为false
2. 对象和字符串比较
对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。
[1,2,3] == &#39;1,2,3&#39; // true [1,2,3]转化为&#39;1,2,3&#39;，然后和&#39;1,2,3&#39;， so结果为true;
3. 对象和数字比较
对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。
[1] == 1; // true `对象先转换为字符串再转换为数字，二者再比较 [1] =&gt; &#39;1&#39; =&gt; 1 所以结果为true
4. 字符串和数字比较
字符串和数字进行比较时，字符串转换成数字，二者再比较。
&#39;1&#39; == 1 // true
5. 字符串和布尔值比较
字符串和布尔值进行比较时，二者全部转换成数值再比较。
&#39;1&#39; == true; // true
6. 布尔值和数字比较
布尔值和数字进行比较时，布尔转换为数字，二者比较。
true == 1 // true###
</code></pre>
<h3 id="♥︎♥︎♥︎-对闭包的看法，为什么要用闭包？说一下闭包的原理以及应用场景？闭包的-this-指向问题？"><a href="#♥︎♥︎♥︎-对闭包的看法，为什么要用闭包？说一下闭包的原理以及应用场景？闭包的-this-指向问题？" class="headerlink" title="♥︎♥︎♥︎ 对闭包的看法，为什么要用闭包？说一下闭包的原理以及应用场景？闭包的 this 指向问题？"></a>♥︎♥︎♥︎ 对闭包的看法，为什么要用闭包？说一下闭包的原理以及应用场景？闭包的 this 指向问题？</h3><p>闭包的作用：</p>
<ol>
<li><p>在外部访问函数内部的变量</p>
</li>
<li><p>让函数内的局部变量可以一直保存下去</p>
</li>
<li><p>模块化私有属性和公共属性</p>
</li>
</ol>
<p>闭包的原理：</p>
<p>全局变量生存周期是永久，局部变量生存周期随着函数的调用介绍而销毁。</p>
<p>闭包就是 在函数中定义且成为该函数内部返回的函数的自由变量 的变量，该变量不会随着外部函数调用</p>
<p>结束而销毁。</p>
<p>（注：不光是变量，函数内声明的函数也可以形成闭包）</p>
<p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭</p>
<p>包。</p>
<h3 id="♥︎♥︎♥︎-简述闭包的问题以及优化"><a href="#♥︎♥︎♥︎-简述闭包的问题以及优化" class="headerlink" title="♥︎♥︎♥︎ 简述闭包的问题以及优化"></a>♥︎♥︎♥︎ 简述闭包的问题以及优化</h3><p>闭包的缺点：占用内层空间 大量使用闭包会造成 栈溢出</p>
<p>由于闭包会一直占用内存空间，直到页面销毁，我们可以主动将已使用的闭包销毁：</p>
<p>将闭包函数赋值为null 可以销毁闭包。</p>
<h3 id="♥︎♥︎♥︎-如何确定-this-指向？改变-this-指向的方式有哪些？"><a href="#♥︎♥︎♥︎-如何确定-this-指向？改变-this-指向的方式有哪些？" class="headerlink" title="♥︎♥︎♥︎ 如何确定 this 指向？改变 this 指向的方式有哪些？"></a>♥︎♥︎♥︎ 如何确定 this 指向？改变 this 指向的方式有哪些？</h3><h4 id="this-指向："><a href="#this-指向：" class="headerlink" title="this 指向："></a>this 指向：</h4><pre><code class="css">1. 全局上下文（函数外）
无论是否为严格模式，均指向全局对象。注意:严格模式下全局对象为undifined

2. 函数上下文（函数内）
默认的，指向函数的调用对象，且是最直接的调用对象：
简单调用，指向全局对象注意:严格模式下全局对象为undifined，某些浏览器未实现此标准也可能会是window
</code></pre>
<h4 id="改变this指向的方式："><a href="#改变this指向的方式：" class="headerlink" title="改变this指向的方式："></a>改变this指向的方式：</h4><pre><code class="javascript">1. 第一种： new关键字改变this指向
//构造函数版this
function Fn()&#123;
 this.user = &quot;李某&quot;;
&#125;
var a = new Fn();
console.log(a.user); //李某
/----------------------------------------/ 

2. 第二种： call()
// 把b添加到第一个参数的环境中，简单来说，this就会指向那个对象
var a = &#123;
 user:&quot;李某&quot;,
 fn:function()&#123;
 console.log(this.user); //李某
 &#125;
&#125;
var b = a.fn;
b.call(a); //若不用call，则b()执行后this指的是Window对象
/----------------------------------------/ 

3. 第三种：apply()
// apply方法和call方法有些相似，它也可以改变this的指向，也可以有多个参数，但是不同的是，第二个参数必须是一个数组
var a = &#123;
 user:&quot;李某&quot;,
 fn:function()&#123;
 console.log(this.user); //李某
 &#125;
&#125;
var b = a.fn;
b.apply(a);
/----------------------------------------/ 

4. 第四种：bind()
// bind方法返回的是一个修改过后的函数,
// bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。
var a = &#123;
 user:&quot;李某&quot;,
 fn:function()&#123;
 console.log(this.user); //李某
 &#125;
&#125;
var b = a.fn;
var c = b.bind(a);
c();
</code></pre>
<h3 id="♥︎♥︎♥︎-介绍箭头函数的-this"><a href="#♥︎♥︎♥︎-介绍箭头函数的-this" class="headerlink" title="♥︎♥︎♥︎ 介绍箭头函数的 this"></a>♥︎♥︎♥︎ 介绍箭头函数的 this</h3><p>由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值</p>
<pre><code class="javascript">1. 所以 call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。
2. 考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略
</code></pre>
<p>作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象</p>
<h3 id="♥︎♥︎♥︎-谈一下你对原型链的理解，画一个经典的原型链图示"><a href="#♥︎♥︎♥︎-谈一下你对原型链的理解，画一个经典的原型链图示" class="headerlink" title="♥︎♥︎♥︎  谈一下你对原型链的理解，画一个经典的原型链图示"></a>♥︎♥︎♥︎  谈一下你对原型链的理解，画一个经典的原型链图示</h3><p>[原型及原型链]: 	“<a href="https://segmentfault.com/a/1190000021232132">https://segmentfault.com/a/1190000021232132</a> “</p>
<h3 id="♥︎♥︎♥︎-ES5-x2F-ES6-的继承除写法以外还有什么区别？"><a href="#♥︎♥︎♥︎-ES5-x2F-ES6-的继承除写法以外还有什么区别？" class="headerlink" title="♥︎♥︎♥︎  ES5&#x2F;ES6 的继承除写法以外还有什么区别？"></a>♥︎♥︎♥︎  ES5&#x2F;ES6 的继承除写法以外还有什么区别？</h3><pre><code class="css">1. ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加 到 this 上
(Parent.apply(this)).
2. ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this(所以必 须先调用父类的super()方 法)，然后再用子类的构造函数修改 this。 
3. ES5 的继承时通过原型或构造函数机制来实现。
4. ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关 键字实现继承。
5. 子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因 为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。 如果不调用 super 方法，子类得不到this 对象。
6. 注意 super 关键字指代父类的实例，即父类的 this 对象。 注意:在子类构造函数中，调用 super 后，才可使用 this关键字，否则报错
</code></pre>
<h3 id="♥︎♥︎♥︎-异步解决方案有哪些？"><a href="#♥︎♥︎♥︎-异步解决方案有哪些？" class="headerlink" title="♥︎♥︎♥︎ 异步解决方案有哪些？"></a>♥︎♥︎♥︎ 异步解决方案有哪些？</h3><pre><code class="javascript">//---------1.回调函数callback：----------//
被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数。如setTimeOut，ajax请求，readFile等。
例：
function greeting(name) &#123;
 alert(&#39;Hello &#39; + name);
&#125;
function processUserInput(callback) &#123;
 var name = prompt(&#39;请输入你的名字。&#39;);
 callback(name);
&#125;
processUserInput(greeting);
优点：
解决了异步的问题。
缺点：
回调地狱：多个回调函数嵌套的情况，使代码看起来很混乱，不易于维护。

//---------2.事件发布订阅：---------//
当一个任务执行完成后，会发布一个事件，当这个事件有一个或多个‘订阅者’的时候，会接收到这个事件的发布，执行相应的任务，这种模式叫发布订阅模式。如node的events,dom的事件绑定
例：
document.body.addEventListener(&#39;click&#39;,function()&#123;
 alert(&#39;订阅了&#39;);
&#125;,false);
document.body.click(); 
优点：
时间对象上的解耦。
缺点：
消耗内存，过度使用会使代码难以维护和理解

//---------3.Promise：---------//
Promise是es6提出的异步编程的一种解决方案。
Promise 对象有三种状态：
pending: 初始状态，既不是成功，也不是失败状态。
fulfilled: 意味着操作成功完成。
rejected: 意味着操作失败。
promise的状态只能从pending变成fulfilled，和pending变成rejected，状态一旦改变，就不会再改变，且只有异步操作的结果才能改变promise的状态。
例：
let promise = new Promise(function (resolve, reject) &#123;
 fs.readFile(&#39;./1.txt&#39;, &#39;utf8&#39;, function (err, data) &#123;
 resolve(data)
 &#125;)
&#125;)
promise
 .then(function (data) &#123;
 console.log(data)
 &#125;)
优点：
解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。
缺点：
无法取消promise。如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。当执行多个Promise时，一堆then看起来也很不友好。

//---------4.Generator：---------//
Generator是es6提出的另一种异步编程解决方案，需要在函数名之前加一个*号，函数内部使用yield语句。Generaotr函数会返回一个遍历器，可以进行遍历操作执行每个中断点yield。
例：
function * count() &#123;
 yield 1
 yield 2
 return 3
&#125;
var c = count()
console.log(c.next()) // &#123; value: 1, done: false &#125;
console.log(c.next()) // &#123; value: 2, done: false &#125;
console.log(c.next()) // &#123; value: 3, done: true &#125;
console.log(c.next()) // &#123; value: undefined, done: true &#125;
优点：
没有了Promise的一堆then(),异步操作更像同步操作，代码更加清晰。
缺点：
不能自动执行异步操作，需要写多个next()方法，需要配合使用Thunk函数和Co模块才能做到自动执
行。

//---------5.async/await：---------//
async是es2017引入的异步操作解决方案，可以理解为Generator的语法糖，async等同于Generator和co模块的封装，async 函数返回一个 Promise。
例：
async function read() &#123;
 let readA = await readFile(&#39;data/a.txt&#39;)
 let readB = await readFile(&#39;data/b.txt&#39;)
 let readC = await readFile(&#39;data/c.txt&#39;)
 console.log(readA)
 console.log(readB)
 console.log(readC)
&#125;
read()
优点：
内置执行器，比Generator操作更简单。async/await比*yield语义更清晰。返回值是Promise对象，可以用then指定下一步操作。代码更整洁。可以捕获同步和异步的错误。
</code></pre>
<h3 id="♥︎♥︎♥︎-async-和-await-、promise的区别-和-这两个的本质"><a href="#♥︎♥︎♥︎-async-和-await-、promise的区别-和-这两个的本质" class="headerlink" title="♥︎♥︎♥︎ async 和 await 、promise的区别 和 这两个的本质"></a>♥︎♥︎♥︎ async 和 await 、promise的区别 和 这两个的本质</h3><h4 id="Promise概念："><a href="#Promise概念：" class="headerlink" title="Promise概念："></a>Promise概念：</h4><pre><code class="css">Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的
</code></pre>
<h4 id="async-await概念："><a href="#async-await概念：" class="headerlink" title="async await概念："></a>async await概念：</h4><pre><code class="css">async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象。

两者的区别：
Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。
async await与Promise一样，是非阻塞的。
async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。
</code></pre>
<h3 id="♥︎♥︎♥︎-移动端点击事件-300ms-延迟如何去掉？原因是什么？"><a href="#♥︎♥︎♥︎-移动端点击事件-300ms-延迟如何去掉？原因是什么？" class="headerlink" title="♥︎♥︎♥︎ 移动端点击事件 300ms 延迟如何去掉？原因是什么？"></a>♥︎♥︎♥︎ 移动端点击事件 300ms 延迟如何去掉？原因是什么？</h3><p>300毫秒原因：</p>
<p>当用户第一次点击屏幕后，需要判断用户是否要进行双击操作，于是手机会等待300毫秒。</p>
<p>解决方法：FastClick.js</p>
<p>FastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。</p>
<p>FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click</p>
<p>事件，并把浏览器在300ms之后的click事件阻止掉。</p>
<h3 id="♥︎♥︎♥︎-Cookie-有哪些属性？其中HttpOnly，Secure，Expire分别有什么作用？"><a href="#♥︎♥︎♥︎-Cookie-有哪些属性？其中HttpOnly，Secure，Expire分别有什么作用？" class="headerlink" title="♥︎♥︎♥︎ Cookie 有哪些属性？其中HttpOnly，Secure，Expire分别有什么作用？"></a>♥︎♥︎♥︎ Cookie 有哪些属性？其中HttpOnly，Secure，Expire分别有什么作用？</h3><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">属性作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">字段为一个cookie的名称。</td>
</tr>
<tr>
<td align="center">value</td>
<td align="center">字段为一个cookie的值。</td>
</tr>
<tr>
<td align="center">domain</td>
<td align="center">字段为可以访问此cookie的域名。</td>
</tr>
<tr>
<td align="center">path</td>
<td align="center">字段为可以访问此cookie的页面路径。 比如domain是abc.com,path是&#x2F;test，那么只有&#x2F;test路径下的页面可以读取此cookie。</td>
</tr>
<tr>
<td align="center">expires&#x2F;Max-Age</td>
<td align="center">字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</td>
</tr>
<tr>
<td align="center">Size</td>
<td align="center">字段 此cookie大小。</td>
</tr>
<tr>
<td align="center">http</td>
<td align="center">字段 cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。</td>
</tr>
<tr>
<td align="center">secure</td>
<td align="center">字段 设置是否只能通过https来传递此条cookie</td>
</tr>
</tbody></table>
<pre><code class="css">1、secure属性
当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie
的具体内容。
2、HttpOnly属性
如果在Cookie中设置了&quot;HttpOnly&quot;属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，
这样能有效的防止XSS攻击。
3、Expire属性
设置Cookie的失效时间：
</code></pre>
<h3 id="♥︎♥︎♥︎-var-let-const的区别"><a href="#♥︎♥︎♥︎-var-let-const的区别" class="headerlink" title="♥︎♥︎♥︎ var let const的区别"></a>♥︎♥︎♥︎ var let const的区别</h3><ol>
<li><p>var声明的变量会挂载在window上，而let和const声明的变量不会</p>
</li>
<li><p>var声明变量存在变量提升，let和const不存在变量提升</p>
</li>
<li><p>let和const声明形成块作用域</p>
</li>
<li><p>同一作用域下let和const不能声明同名变量，而var可以</p>
</li>
<li><p>使用let&#x2F;const声明的变量在当前作用域存在暂存死区</p>
</li>
<li><p>const一旦声明必须赋值,不能使用null占位,声明后不能再修改,如果声明的是复合类型数据，可以修改其属性</p>
</li>
</ol>
<h3 id="♥︎♥︎♥︎-document-load-和-documen-ready的区别"><a href="#♥︎♥︎♥︎-document-load-和-documen-ready的区别" class="headerlink" title="♥︎♥︎♥︎ document load 和 documen ready的区别"></a>♥︎♥︎♥︎ document load 和 documen ready的区别</h3><p>DOM文档解析：</p>
<pre><code class="css">解析html结构
加载脚本和样式文件
解析并执行脚本
构造html的DOM模型 //ready
加载图片等外部资源文件
页面加载完毕 //load
</code></pre>
<p>document load:</p>
<pre><code class="css">load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数，load方法就是onload事件。
</code></pre>
<p>documen ready:</p>
<pre><code class="css">构造html的DOM模型加载完毕后触发
</code></pre>
<h3 id="♥︎♥︎♥︎-如何用-setTImeout-来实现-setInterval？"><a href="#♥︎♥︎♥︎-如何用-setTImeout-来实现-setInterval？" class="headerlink" title="♥︎♥︎♥︎ 如何用 setTImeout 来实现 setInterval？"></a>♥︎♥︎♥︎ 如何用 setTImeout 来实现 setInterval？</h3><h4 id="为什么要使用setTImeout-来实现-setInterval？"><a href="#为什么要使用setTImeout-来实现-setInterval？" class="headerlink" title="为什么要使用setTImeout 来实现 setInterval？"></a>为什么要使用setTImeout 来实现 setInterval？</h4><p>1.不去关心回调函数是否还在运行</p>
<p>在某些情况下，函数可能需要比间隔时间更长的时间去完成执行。比如说是用setInterval每隔5秒对远端</p>
<p>服务器进行轮询，网络延迟，服务器无响应以及其他因素将会阻止请求按时按成。结果会导致返回一串</p>
<p>无必要的排成队列请求。</p>
<p>2.忽视错误</p>
<p>因为某些原因，setInterval调用的代码中会出现一个错误，但是代码并不会中止执行而是继续执行错误</p>
<p>的代码。</p>
<p>3.缺乏灵活性</p>
<p>除了前面提到的缺点之外，我非常希望setInterval方法能有一个表明执行次数的参数而不是无休止的执</p>
<p>行下去。</p>
<pre><code class="javascript">function interval(func, w, t)&#123;
 var interv = function()&#123;
 if(typeof t === &quot;undefined&quot; || t-- &gt; 0)&#123;
 setTimeout(interv, w);
 try&#123;
 func.call(null);
 &#125;
 catch(e)&#123;
 t = 0;
 throw e.toString();
 &#125;
 &#125;
 &#125;;
 setTimeout(interv, w);
&#125;;
</code></pre>
<h3 id="♥︎♥︎♥︎-如何判断-user-对象里有没有-a-这个属性？如果把user对象中所有的属性都输出出来？-var-user-x3D-‘a’-‘19’-‘b’-‘18’-‘c’-‘16’"><a href="#♥︎♥︎♥︎-如何判断-user-对象里有没有-a-这个属性？如果把user对象中所有的属性都输出出来？-var-user-x3D-‘a’-‘19’-‘b’-‘18’-‘c’-‘16’" class="headerlink" title="♥︎♥︎♥︎ 如何判断 user 对象里有没有 a 这个属性？如果把user对象中所有的属性都输出出来？(var user &#x3D;{‘a’: ‘19’, ‘b’: ‘18’, ‘c’: ‘16’})"></a>♥︎♥︎♥︎ 如何判断 user 对象里有没有 a 这个属性？如果把user对象中所有的属性都输出出来？(var user &#x3D;{‘a’: ‘19’, ‘b’: ‘18’, ‘c’: ‘16’})</h3><pre><code class="css">(var user = &#123;&#39;a&#39;: &#39;19&#39;, &#39;b&#39;: &#39;18&#39;, &#39;c&#39;: &#39;16&#39;&#125;)
如何判断 user 对象里有没有 a 这个属性？

1.js对象的Object.hasOwnProperty()方法
返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。
let obj = new Object();
obj.a = &quot;123&quot;;
console.log(obj.hasOwnProperty(&#39;a&#39;)) // true
console.log(obj.hasOwnProperty(&#39;b&#39;)) // false

2.把user对象中所有的属性都输出出来
for(item for user)&#123;
 console.log(item)
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-实现一个函数-add"><a href="#♥︎♥︎♥︎-实现一个函数-add" class="headerlink" title="♥︎♥︎♥︎ 实现一个函数 add()"></a>♥︎♥︎♥︎ 实现一个函数 add()</h3><pre><code class="javascript">function curry(func) &#123;

    return function curried(...args) &#123;
      if (args.length &gt;= func.length) &#123;
        return func.apply(this, args);
      &#125; else &#123;
        return function(...args2) &#123;
          return curried.apply(this, args.concat(args2));
        &#125;
      &#125;
    &#125;;
  
  &#125;

  function sum(a, b, c) &#123;
    return a + b + c;
  &#125;
  
  let curriedSum = curry(sum);
  
  console.log(curriedSum(1, 2, 3)); // 6，仍然可以被正常调用
  console.log( curriedSum(1)(2,3) ); // 6，对第一个参数的柯里化
  console.log( curriedSum(1)(2)(3) ); // 6，全柯里化
</code></pre>
<h3 id="♥︎♥︎♥︎-如何避免回调地狱？"><a href="#♥︎♥︎♥︎-如何避免回调地狱？" class="headerlink" title="♥︎♥︎♥︎ 如何避免回调地狱？"></a>♥︎♥︎♥︎ 如何避免回调地狱？</h3><pre><code class="css">1. Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将
回调函数的嵌套，改成链式调用。
promise只有两个状态resolve和reject，当它触发任何一个状态后，它会将当前的值缓存起来，并在有
回调函数添加进来的时候尝试调用回调函数，如果这个时候还没有触发resolve或者reject，那么回调函
数会被缓存，等待调用，如果已经有了状态(resolve或者reject)，则立刻调用回调函数。并且所有回调函
数在执行后都立即被销毁。

2. ES6 co/yield方案
yield: Generator 函数是协程在 ES6 的实现，而yield是 Generator关键字， 异步操作需要暂停的
地方，都用yield语句注明。
co: co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函
数的自动执行。

3. ES7 async/await 方案
async/await是es7的新标准，并且在node7.0中已经得到支持。
它就是 Generator 函数的语法糖，async函数就是将 Generator 函数的星号（*）替换成async， 将yield替换成await，仅此而已。可以理解官方对co和Generator 封装方案。
</code></pre>
<h3 id="♥︎♥︎♥︎-简述同步和异步的区别"><a href="#♥︎♥︎♥︎-简述同步和异步的区别" class="headerlink" title="♥︎♥︎♥︎ 简述同步和异步的区别"></a>♥︎♥︎♥︎ 简述同步和异步的区别</h3><h4 id="同步："><a href="#同步：" class="headerlink" title="同步："></a>同步：</h4><p>同步的思想是：所有的操作都做完，才返回给用户。这样用户在线等待的时间太长，给用户一种卡死了</p>
<p>的感觉（就是系统迁移中，点击了迁移，界面就不动了，但是程序还在执行，卡死了的感觉）。这种情</p>
<p>况下，用户不能关闭界面，如果关闭了，即迁移程序就中断了。</p>
<h4 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h4><p>将用户请求放入消息队列，并反馈给用户，系统迁移程序已经启动，你可以关闭浏览器了。然后程序再</p>
<p>慢慢地去写入数据库去。这就是异步。但是用户没有卡死的感觉，会告诉你，你的请求系统已经响应</p>
<p>了。你可以关闭界面了。</p>
<h4 id="同步和异步本身是相对的"><a href="#同步和异步本身是相对的" class="headerlink" title="同步和异步本身是相对的:"></a>同步和异步本身是相对的:</h4><p>同步就相当于是 当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不做其他的事情。当</p>
<p>服务端做完了才返回到客户端。这样的话客户端需要一直等待。用户使用起来会有不友好。</p>
<p>异步就是，当客户端发送给服务端请求时，在等待服务端响应的时候，客户端可以做其他的事情，这样</p>
<p>节约了时间，提高了效率。</p>
<p>存在就有其道理 异步虽然好 但是有些问题是要用同步用来解决，比如有些东西我们需要的是拿到返回的</p>
<p>数据在进行操作的。这些是异步所无法解决的。</p>
<h3 id="♥︎♥︎♥︎-jQuery-的事件委托方法-on，live，delegate之间有区别？"><a href="#♥︎♥︎♥︎-jQuery-的事件委托方法-on，live，delegate之间有区别？" class="headerlink" title="♥︎♥︎♥︎ jQuery 的事件委托方法 on，live，delegate之间有区别？"></a>♥︎♥︎♥︎ jQuery 的事件委托方法 on，live，delegate之间有区别？</h3><pre><code class="css">live 把事件委托交给了document（根节点），document 向下去寻找符合条件的元素（）， 不用等待
document加载结束也可以生效。
delegate可指定事件委托对象，相比于live性能更优，直接锁定指定选择器；
on事件委托对象选填，如果不填，即给对象自身注册事件，填了作用和delegate一致。
</code></pre>
<h3 id="♥︎♥︎♥︎-简述下-Promise-对象"><a href="#♥︎♥︎♥︎-简述下-Promise-对象" class="headerlink" title="♥︎♥︎♥︎ 简述下 Promise 对象"></a>♥︎♥︎♥︎ 简述下 Promise 对象</h3><pre><code class="css">Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理更强大。
所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件 (通常是一个异步操作)的结
果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。
Promise对象有以下2个特点：
1.对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending(进行中)、
Resolved(已完成)和Rejected(已失败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操
作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法
改变。
2.一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可
能：从Pending变为Resolved；从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会
再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象田静回调函数，也会立即得
到这个结果。这与事件(Event)完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果
的。
有了Promise对象，就可以把异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此
外，Promise对象提供了统一的接口，使得控制异步操作更加容易。
</code></pre>
<h3 id="♥︎♥︎♥︎-数组扁平化，不用-api"><a href="#♥︎♥︎♥︎-数组扁平化，不用-api" class="headerlink" title="♥︎♥︎♥︎ 数组扁平化，不用 api"></a>♥︎♥︎♥︎ 数组扁平化，不用 api</h3><pre><code class="javascript">function myFlat(arr)&#123;
    let res = [];
    for(let i=0; i&lt;arr.length; i++)&#123; 
    if(arr[i] instanceof Array)&#123;
    res = res.concat(myFlat(arr[i]));
    &#125;else &#123;
    res.push(arr[i]);
    &#125;
    &#125;
    return res;
   &#125;
   let arr = [1,[2,3,[4,5]]];
   console.log(myFlat(arr)) //[ 1, 2, 3, 4, 5 ]
</code></pre>
<h3 id="♥︎♥︎♥︎-用-JavaScript-实现观察者模式"><a href="#♥︎♥︎♥︎-用-JavaScript-实现观察者模式" class="headerlink" title="♥︎♥︎♥︎ 用 JavaScript 实现观察者模式"></a>♥︎♥︎♥︎ 用 JavaScript 实现观察者模式</h3><pre><code class="javascript">function BusinessOne(name)&#123;
 this.name = name;
 //订阅者的集合
 this.subscribers = new Array();
&#125;
//订阅者的发送消息的方法(推模式)
BusinessOne.prototype.delive = function(news)&#123;
 var self = this;
 //给每一个订阅者发送消息
 this.subscribers.forEach(
 function(fn)&#123;
 //调用接受者处理信息的函数
 fn(news,self);
 &#125;
 )
&#125;
//扩展公共订阅的函数,和取消订阅的函数
Function.prototype.subscribe = function(publisher)&#123;
 var that = this;
 //some 访问数组度i型并且以参数的形式传回回调函数中
 //只要至少有一次返回是true那么some就是true
 var alreadyExists = publisher.subscribers.some(
 function(el)&#123;
 //处理不能重复订阅的功能
 if(el == that)&#123;
 return;
 &#125;
 &#125;
 );
 //没用订阅你就可以订阅
 if(!alreadyExists)&#123;
 publisher.subscribers.push(that);
 &#125;
 return this;
&#125;
//取消
Function.prototype.unsubscribe = function(publisher)&#123;
 var that = this;
 publisher.subscribers = publisher.subscribers.filter(
 function(el)&#123;
 if(el !== that)&#123;
 return el;
 &#125;
 &#125;
 );
 return this;
&#125;;
</code></pre>
<h3 id="♥︎♥︎♥︎-谈谈垃圾回收机制方法以及内存管理"><a href="#♥︎♥︎♥︎-谈谈垃圾回收机制方法以及内存管理" class="headerlink" title="♥︎♥︎♥︎ 谈谈垃圾回收机制方法以及内存管理"></a>♥︎♥︎♥︎ 谈谈垃圾回收机制方法以及内存管理</h3><h4 id="垃圾回收方式"><a href="#垃圾回收方式" class="headerlink" title="垃圾回收方式"></a>垃圾回收方式</h4><pre><code>① 标记清除
工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离
开环境”。标记“离开环境”的就回收内存。

② 引用计数
工作原理：跟踪记录每个值被引用的次数。一旦没有引用，内存就直接释放了。
</code></pre>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>什么时候触发垃圾回收？</p>
<p>垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就</p>
<p>变成了一个值得思考的问题。</p>
<pre><code class="css">1、合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。

2、GC缺陷： (1)、停止响应其他操作；

3、GC优化策略： (1)、分代回收（Generation GC）;(2)、增量GC
</code></pre>
<h3 id="♥︎♥︎♥︎-开发过程中遇到内存泄漏的问题都有哪些？"><a href="#♥︎♥︎♥︎-开发过程中遇到内存泄漏的问题都有哪些？" class="headerlink" title="♥︎♥︎♥︎ 开发过程中遇到内存泄漏的问题都有哪些？"></a>♥︎♥︎♥︎ 开发过程中遇到内存泄漏的问题都有哪些？</h3><ol>
<li>当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要</li>
</ol>
<p>先手工移除事件，不然会存在内存泄露。</p>
<ol start="2">
<li>由于是函数内定义函数，并且内部函数–事件回调的引用外暴了，形成了闭包。闭包可以维持函数</li>
</ol>
<p>内局部变量，使其得不到释放。</p>
<h3 id="♥︎♥︎♥︎-请编写获取当前窗口地址中查询参数name的值，当前窗口地址为：https-foo-com-id-1-amp-name-tom"><a href="#♥︎♥︎♥︎-请编写获取当前窗口地址中查询参数name的值，当前窗口地址为：https-foo-com-id-1-amp-name-tom" class="headerlink" title="♥︎♥︎♥︎ 请编写获取当前窗口地址中查询参数name的值，当前窗口地址为：https://foo.com/?id=1&amp;name=tom"></a>♥︎♥︎♥︎ 请编写获取当前窗口地址中查询参数name的值，当前窗口地址为：<a href="https://foo.com/?id=1&amp;name=tom">https://foo.com/?id=1&amp;name=tom</a></h3><pre><code class="javascript">function GetQueryString(name)&#123;
 var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);
 var r = window.location.search.substr(1).match(reg);
 if(r!=null)
 return unescape(r[2]); 
 return null;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-已知a，b两个构造函数，现在-let-c-x3D-new-a-，如何在c的存储地址不变的情况下，改变c的继承（c-gt-a-转为-c-gt-b）"><a href="#♥︎♥︎♥︎-已知a，b两个构造函数，现在-let-c-x3D-new-a-，如何在c的存储地址不变的情况下，改变c的继承（c-gt-a-转为-c-gt-b）" class="headerlink" title="♥︎♥︎♥︎ 已知a，b两个构造函数，现在 let c &#x3D; new a()，如何在c的存储地址不变的情况下，改变c的继承（c-&gt;a 转为 c-&gt;b）"></a>♥︎♥︎♥︎ 已知a，b两个构造函数，现在 let c &#x3D; new a()，如何在c的存储地址不变的情况下，改变c的继承（c-&gt;a 转为 c-&gt;b）</h3><p>改变原型链：通过改变C的prototype为b,实现内存地址不动，改变继承</p>
<h3 id="♥︎♥︎♥︎-浏览器有哪些兼容问题，你封装过什么插件"><a href="#♥︎♥︎♥︎-浏览器有哪些兼容问题，你封装过什么插件" class="headerlink" title="♥︎♥︎♥︎ 浏览器有哪些兼容问题，你封装过什么插件"></a>♥︎♥︎♥︎ 浏览器有哪些兼容问题，你封装过什么插件</h3><pre><code class="javascript">//1.滚动条到顶端的距离（滚动高度）
var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;

//2.滚动条到左端的距离
var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;

//3. IE9以下byClassName
function byClassName(obj,className)&#123;
 //判断是否支持byClassName
 if(obj.getElementsByClassName)&#123;
 //支持
 return obj.getElementsByClassName(className);
 &#125;else&#123;
 //不支持
 var eles = obj.getElementsByTagName(&#39;*&#39;); //获取所有的标签
 var arr = []; //空数组，准备放置找到的对象
 //遍历所有的标签
 for(var i = 0,len = eles.length;i &lt; len;i ++)&#123;
 //找出与我指定class名相同的对象
 if(eles[i].className === className)&#123;
 arr.push(eles[i]); //存入数组
 &#125;
 &#125;
 return arr; //返回
 &#125;
&#125;

//4. 获取非行内样式兼容 IE:currentStyle 标准：getComputedStyle
function getStyle(obj,attr)&#123;
 return window.getComputedStyle ? getComputedStyle(obj,true)[attr] : obj.currentStyle[attr];
&#125;
//div.style.width = &#39;&#39;;设置样式
//obj[&#39;属性&#39;]： 对象是变量时，必须用对象[&#39;属性&#39;]获取。

//5. 获取事件对象的兼容
evt = evt || window.event

//6. 获取鼠标编码值的兼容
function getButton(evt)&#123;
 var e = evt || window.event;
 if(evt)&#123;
 return e.button;
 &#125;else if(window.event)&#123;
 switch(e.button)&#123;
 case 1 : return 0;
 case 4 : return 1;
 case 2 : return 2;
 &#125;
 &#125;
&#125;

//7. 获取键盘按键编码值的兼容
var key = evt.keyCode || evt.charCode || evt.which;

//8. 阻止事件冒泡的兼容
e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;

//9. 阻止超链接的默认行为的兼容
evt.preventDefault ? evt.preventDefault() : evt.returnValue = false;

//10. 添加事件监听器的兼容
function addEventListener(obj,event,fn,boo)&#123;
 if(obj.addEventListener)&#123;
 obj.addEventListener(event,fn,boo);
 &#125;else if(obj.attachEvent)&#123;
 obj.attachEvent(&#39;on&#39; + event,fn);
 &#125;
&#125;

//11. 移除事件监听器的兼容
function removeEventListener(obj,event,fn,boo)&#123;
 if(obj.removeEventListener)&#123;
 obj.removeEventListener(event,fn,boo);
 &#125;else if(obj.detachEvent)&#123;
 obj.detachEvent(&#39;on&#39; + event,fn);
 &#125;
&#125;

//12. 获取事件源的兼容
var target = event.target || event.srcElement;
</code></pre>
<h3 id="♥︎♥︎♥︎-如何判断一个对象是否为数组，函数"><a href="#♥︎♥︎♥︎-如何判断一个对象是否为数组，函数" class="headerlink" title="♥︎♥︎♥︎ 如何判断一个对象是否为数组，函数"></a>♥︎♥︎♥︎ 如何判断一个对象是否为数组，函数</h3><pre><code class="css">方法一： instanceof:
var arr=[];
console.log(arr instanceof Array) //返回true

方法二： constructor:
console.log(arr.constructor == Array); //返回true

方法三： Array.isArray()
console.log(Array.isArray(arr)); //返回true
</code></pre>
<h3 id="♥︎♥︎♥︎-写一个函数，接受可变个数参数，且每个参数均为数字，返回参数的最大值。"><a href="#♥︎♥︎♥︎-写一个函数，接受可变个数参数，且每个参数均为数字，返回参数的最大值。" class="headerlink" title="♥︎♥︎♥︎ 写一个函数，接受可变个数参数，且每个参数均为数字，返回参数的最大值。"></a>♥︎♥︎♥︎ 写一个函数，接受可变个数参数，且每个参数均为数字，返回参数的最大值。</h3><pre><code class="javascript">function myMax()&#123;
 return Math.max(arguments)
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-请写出-ES6-Array-isArray"><a href="#♥︎♥︎♥︎-请写出-ES6-Array-isArray" class="headerlink" title="♥︎♥︎♥︎ 请写出 ES6 Array.isArray()"></a>♥︎♥︎♥︎ 请写出 ES6 Array.isArray()</h3><pre><code class="javascript">if (!Array.isArray)&#123;
 Array.isArray = function(arg)&#123;
 return Object.prototype.toString.call(arg) === &#39;[object Array]&#39;;
 &#125;;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-实现一个函数-clone，可以对-JavaScript-中的5种主要数据类型进行值复制。"><a href="#♥︎♥︎♥︎-实现一个函数-clone，可以对-JavaScript-中的5种主要数据类型进行值复制。" class="headerlink" title="♥︎♥︎♥︎ 实现一个函数 clone，可以对 JavaScript 中的5种主要数据类型进行值复制。"></a>♥︎♥︎♥︎ 实现一个函数 clone，可以对 JavaScript 中的5种主要数据类型进行值复制。</h3><pre><code class="javascript">// 方法一：
Object.prototype.clone = function() &#123;
 var o = this.constructor === Array ? [] : &#123;&#125;;
 for (var e in this) &#123;
 o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e];
 &#125;
 return o;
&#125;;

//方法二：
/**
 * 克隆一个对象
 * @param Obj
 * @returns
 */
function clone(Obj) &#123;
 var buf;
 if (Obj instanceof Array) &#123;
 buf = []; //创建一个空的数组
 var i = Obj.length;
 while (i--) &#123;
 buf[i] = clone(Obj[i]);
 &#125;
 return buf;
 &#125; else if (Obj instanceof Object) &#123;
 buf = &#123;&#125;; //创建一个空对象
 for (var k in Obj) &#123;
 //为这个对象添加新的属性
 buf[k] = clone(Obj[k]);
 &#125;
 return buf;
 &#125; else &#123;
 //普通变量直接赋值
 return Obj;
 &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-假如A页面我定义了一个定时器，然后跳到B页面如果让A页面的定时器暂停"><a href="#♥︎♥︎♥︎-假如A页面我定义了一个定时器，然后跳到B页面如果让A页面的定时器暂停" class="headerlink" title="♥︎♥︎♥︎ 假如A页面我定义了一个定时器，然后跳到B页面如果让A页面的定时器暂停"></a>♥︎♥︎♥︎ 假如A页面我定义了一个定时器，然后跳到B页面如果让A页面的定时器暂停</h3><pre><code class="javascript">方法1：在beforeDestroy()等生命周期结束阶段内清除定时器：
beforeDestroy() &#123;
 clearInterval(this.timer);
 this.timer = null;
&#125;

方法2：通过$once这个事件侦听器器在定义完定时器之后的位置来清除定时器。
const timer = setInterval(() =&gt;&#123;
 // 某些定时器操作
&#125;, 500);
// 通过$once来监听定时器，在beforeDestroy钩子可以被清除。
this.$once(&#39;hook:beforeDestroy&#39;, () =&gt; &#123;
 clearInterval(timer);
&#125;)
</code></pre>
<h3 id="♥︎♥︎♥︎-promise的实现原理，如果我现在向服务器发送一个请求，但是我后悔了，不想让服务器返回数据，去实现一个delay"><a href="#♥︎♥︎♥︎-promise的实现原理，如果我现在向服务器发送一个请求，但是我后悔了，不想让服务器返回数据，去实现一个delay" class="headerlink" title="♥︎♥︎♥︎ promise的实现原理，如果我现在向服务器发送一个请求，但是我后悔了，不想让服务器返回数据，去实现一个delay"></a>♥︎♥︎♥︎ promise的实现原理，如果我现在向服务器发送一个请求，但是我后悔了，不想让服务器返回数据，去实现一个delay</h3><h4 id="取消结束Promise的方法？"><a href="#取消结束Promise的方法？" class="headerlink" title="取消结束Promise的方法？"></a>取消结束Promise的方法？</h4><pre><code class="javascript">1. 返回一个pending状态的Promise，原Promise链会终止
Promise.resolve().then(() =&gt; &#123;
 console.log(&#39;ok1&#39;)
 return new Promise(()=&gt;&#123;&#125;) // 返回“pending”状态的Promise对象
&#125;).then(() =&gt; &#123;
 // 后续的函数不会被调用
 console.log(&#39;ok2&#39;)
&#125;).catch(err =&gt; &#123;
 console.log(&#39;err-&gt;&#39;, err)
&#125;)

2. Promise.race竞速方法
let p1 = new Promise((resolve, reject) =&gt; &#123;
 resolve(&#39;ok1&#39;)
&#125;)
let p2 = new Promise((resolve, reject) =&gt; &#123;
 setTimeout(() =&gt; &#123;resolve(&#39;ok2&#39;)&#125;, 10)
&#125;)
Promise.race([p2, p1]).then((result) =&gt; &#123;
 console.log(result) //ok1
&#125;).catch((error) =&gt; &#123;
 console.log(error)
&#125;)

3. 当Promise链中抛出错误时，错误信息沿着链路向后传递，直至捕获
Promise.resolve().then(() =&gt; &#123;
 console.log(&#39;ok1&#39;)
 throw &#39;throw error1&#39;
&#125;).then(() =&gt; &#123;
 console.log(&#39;ok2&#39;)
&#125;, err =&gt; &#123; 
 // 捕获错误
 console.log(&#39;err-&gt;&#39;, err)
&#125;).then(() =&gt; &#123; 
 // 该函数将被调用
 console.log(&#39;ok3&#39;)
 throw &#39;throw error3&#39;
&#125;).then(() =&gt; &#123;
 // 错误捕获前的函数不会被调用
 console.log(&#39;ok4&#39;)
&#125;).catch(err =&gt; &#123;
 console.log(&#39;err-&gt;&#39;, err)
</code></pre>
<h4 id="Axios如何取消请求？"><a href="#Axios如何取消请求？" class="headerlink" title="Axios如何取消请求？"></a>Axios如何取消请求？</h4><pre><code class="javascript">//1.第一种通过CancelToken.source工厂方法创建cancel token
var CancelToken = axios.CancelToken;
var source = CancelToken.source();
axios.get(&#39;/user/12345&#39;, &#123;
 cancelToken: source.token
&#125;).catch(function(thrown) &#123;
 if (axios.isCancel(thrown)) &#123;
 console.log(&#39;Request canceled&#39;, thrown.message);
 &#125; else &#123;
 // 处理错误
 &#125;
&#125;);
// 取消请求（message 参数是可选的）
source.cancel(&#39;Operation canceled by the user.&#39;);

//2.第二种通过传递executor函数到CancelToken的构造函数来创建cancel token
var CancelToken = axios.CancelToken;
var cancel;
axios.get(&#39;/user/12345&#39;, &#123;
 cancelToken: new CancelToken(function executor(c) &#123;
 // executor 函数接收一个 cancel 函数作为参数
 cancel = c;
 &#125;)
&#125;);
// 取消请求
cancel();
</code></pre>
<h3 id="♥︎♥︎♥︎-CommonJS-和-RequireJS-的实现原理"><a href="#♥︎♥︎♥︎-CommonJS-和-RequireJS-的实现原理" class="headerlink" title="♥︎♥︎♥︎ CommonJS 和 RequireJS 的实现原理"></a>♥︎♥︎♥︎ CommonJS 和 RequireJS 的实现原理</h3><p>commonjs是通过module.exports导出模块,用require引入一个模块，原理：闭包</p>
<p>requirejs是通过define定义导出模块，用require引入模块。</p>
<h3 id="♥︎♥︎♥︎-面向对象编程与面向过程编程的区别？"><a href="#♥︎♥︎♥︎-面向对象编程与面向过程编程的区别？" class="headerlink" title="♥︎♥︎♥︎ 面向对象编程与面向过程编程的区别？"></a>♥︎♥︎♥︎ 面向对象编程与面向过程编程的区别？</h3><p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设</p>
<p>计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消</p>
<p>息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<h3 id="♥︎♥︎♥︎-eval-是做什么的？性能怎么样？安全如何？"><a href="#♥︎♥︎♥︎-eval-是做什么的？性能怎么样？安全如何？" class="headerlink" title="♥︎♥︎♥︎ eval 是做什么的？性能怎么样？安全如何？"></a>♥︎♥︎♥︎ eval 是做什么的？性能怎么样？安全如何？</h3><p>它的功能是把对应的字符串解析成js代码并运行，</p>
<p>应该避免使用eval,因为不安全，非常耗性能（2次，一次解析成js语句，一次执行）</p>
<p>‼️注意：在项目里写js代码的时候，禁止使用的，因为有安全因素。</p>
<h3 id="♥︎♥︎♥︎-数据类型（判断，-x3D-x3D-和-x3D-x3D-x3D-）堆栈、内存泄漏及垃圾回收机制"><a href="#♥︎♥︎♥︎-数据类型（判断，-x3D-x3D-和-x3D-x3D-x3D-）堆栈、内存泄漏及垃圾回收机制" class="headerlink" title="♥︎♥︎♥︎ 数据类型（判断，&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;）堆栈、内存泄漏及垃圾回收机制"></a>♥︎♥︎♥︎ 数据类型（判断，&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;）堆栈、内存泄漏及垃圾回收机制</h3><p>1，&#x3D;&#x3D; 判断值是否相等； &#x3D;&#x3D;&#x3D; 判断值和数据类型是否严格相等</p>
<p>2，Javascript堆栈和垃圾回收机制</p>
<pre><code class="javascript">//堆栈溢出

当储存的数据导到某一限制时就会造成堆栈溢出

//内存泄漏

当不断向堆中存储数据，而不进行清理，这就是内存泄漏

//垃圾回收机制（清除孤儿机制）

语言当中一般分两种，一种是自动清理，一种是手动清理（GC），js中只有自动清理

垃圾回收机制就是将引用对中的地址的对象设置为null，并且将所有引用该地址的对象都设置为null，并且移除事件侦听,不会即时清除,垃圾回收车会根据内存的情况在适当的时候进行清除堆中的对象 内存到达一定程度了才会进行回收
</code></pre>
<h3 id="♥︎♥︎♥︎-swiper-插件从后台获取数据没问题，css-代码啥的也没问题，但是图片不动，应该怎么解决？"><a href="#♥︎♥︎♥︎-swiper-插件从后台获取数据没问题，css-代码啥的也没问题，但是图片不动，应该怎么解决？" class="headerlink" title="♥︎♥︎♥︎ swiper 插件从后台获取数据没问题，css 代码啥的也没问题，但是图片不动，应该怎么解决？"></a>♥︎♥︎♥︎ swiper 插件从后台获取数据没问题，css 代码啥的也没问题，但是图片不动，应该怎么解决？</h3><p>主要原因：</p>
<p>swiper提前初始化了，而这个时候，数据还没有完全出来。</p>
<p>解决方法</p>
<p>从swiper 入手，在swiper中写 observer:true&#x2F;observeParents:true</p>
<pre><code class="javascript"> let myswiper = new Swiper(&quot;.swiper-container&quot; , &#123;
 autoplay: true,
 loop: true,
 // observer 修改swiper子元素时自动初始化swiper
 observer:true,
 // observeParents 包括当前父元素的swiper发生变更时也会初始化swiper
 observeParents:true,
 &#125;)
</code></pre>
<p>从 Vue 入手，vue中专门提供了提供了一个方法nextTick() 用于解决dom的先后执行问题。</p>
<pre><code class="javascript"> mounted()&#123;
 this.$nextTick(function()&#123;
 // ...操作
 let myswiper = new Swiper(&quot;.swiper-container&quot; , &#123;
 autoplay: true,
 loop: true
 &#125;)
 &#125;)
 &#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-ES6-class-关键字原理跟-function-什么区别？"><a href="#♥︎♥︎♥︎-ES6-class-关键字原理跟-function-什么区别？" class="headerlink" title="♥︎♥︎♥︎ ES6 class 关键字原理跟 function 什么区别？"></a>♥︎♥︎♥︎ ES6 class 关键字原理跟 function 什么区别？</h3><pre><code class="css">function 可以用call apply bind 的方式 来改变他的执行上下文
但是class 却不可以 class 虽然本质上也是一个函数 但是 其内（babel）部做了一层代理 来禁止了这种
行为

关于构造器constructor
 在function定义的构造函数中，其prototype.constructor属性指向构造器自身
 在class定义的类中，constructor其实也相当于定义在prototype属性上

重复定义
 function会覆盖之前定义的方法
 class会报错

原型或者类中方法的枚举
 class中定义的方法不可用Object.keys(Point.prototype)枚举到
 function构造器原型方法可被Object.keys(Point.prototype)枚举到，除过constructor
 所有原型方法属性都可用Object.getOwnPropertyNames(Point.prototype)访问到
</code></pre>
<h3 id="♥︎♥︎♥︎-iframe-跨域问题，页面之间怎么传值？"><a href="#♥︎♥︎♥︎-iframe-跨域问题，页面之间怎么传值？" class="headerlink" title="♥︎♥︎♥︎ iframe 跨域问题，页面之间怎么传值？"></a>♥︎♥︎♥︎ iframe 跨域问题，页面之间怎么传值？</h3><p>一般有两个解决方案，一个是建立一个代理页面，通过代理页面传值，</p>
<p>另一个方法是通过H5的postMessage方法传值，今天用的是第二种。</p>
<p>首先，在父页面A中建立一个iframe，其中src要写好子页面B的地址，然后在A页面中写如下方法：</p>
<pre><code class="javascript">var iframe = document.getElementById(&quot;onemap&quot;); var msg = &#123;loginName:&#39;arcgis&#39;,loginPassword:&#39;Esri1234&#39;&#125;; var childDomain = &quot;https://geoplat.training.com&quot;; iframe.contentWindow.postMessage(msg,childDomain);
</code></pre>
<p>记住，childDomain与A的iframe的src地址不一样，childDomain是域，而src是域中的一个页面,msg是传输的信息，可以是字符串，也可以是对象。</p>
<p>上面的方法一定要写在一个函数中，并通过点击事件调用，如果希望iframe开始为空，点击后在设置src，可以在设置src之后，通过setTimeout设置一定时间后在传输信息。</p>
<p>在子页面B中，通过对window添加事件获取传输过来的信息：</p>
<pre><code class="javascript">window.addEventListener(&quot;message&quot;,function(obj)&#123; 
  var name = obj.data.loginName; 
  var password = obj.data.loginPassword; login.iframeChildLogin(name,password); &#125;,false);
</code></pre>
<p>这样就完成了从不同域的父页面向子页面传值的过程</p>
<h3 id="♥︎♥︎♥︎-简述-commonJS、AMD-和-CMD"><a href="#♥︎♥︎♥︎-简述-commonJS、AMD-和-CMD" class="headerlink" title="♥︎♥︎♥︎ 简述 commonJS、AMD 和 CMD"></a>♥︎♥︎♥︎ 简述 commonJS、AMD 和 CMD</h3><pre><code class="css">CommonJS导出模块的方法是exports，导入模块的是require，具体规范如下
1）如果一个JS文件中存在exports或require，该JS文件是一个模块
2）模块内的所有代码均为隐藏代码，包括全局变量、全局函数，这些全局的内容均不应该对全局变量造成任何污染
3）如果一个模块需要暴露一些API提供给外部使用，需要通过exports导出，exports是一个空的对象，你可以为该对象添加任何需要导出的内容
4）如果一个模块需要导入其他模块，通过require实现，require是一个函数，传入模块的路径即可返回该模块导出的整个内容

【注】CommonJS只是一个规范，相当于告诉你按什么标准制造汽车，但是具体怎么制造还是得看生产商。因此，有了规范以后，nodejs就去实现模块化了

AMD
AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
AMD 推崇依赖前置。

CMD
CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
CMD 推崇依赖就近
</code></pre>
<h3 id="♥︎♥︎♥︎-require-js-源码看过吗？怎么做到异步加载的"><a href="#♥︎♥︎♥︎-require-js-源码看过吗？怎么做到异步加载的" class="headerlink" title="♥︎♥︎♥︎ require.js 源码看过吗？怎么做到异步加载的"></a>♥︎♥︎♥︎ require.js 源码看过吗？怎么做到异步加载的</h3><pre><code class="javascript">/*
Creates the node for the load command. Only used in browser envs.
*/
req.createNode = function (config, moduleName, url) &#123;
var node = config.xhtml ?
 document.createElementNS(&#39;http://www.w3.org/1999/xhtml&#39;, &#39;html:script&#39;) :
document.createElement(&#39;script&#39;);
node.type = config.scriptType || &#39;text/javascript&#39;;
node.charset = &#39;utf-8&#39;;
node.async = true;
return node;
&#125;;
</code></pre>
<p>　requirejs 导入模块的方式实际就是创建脚本标签，一切的模块都需要经过这个方法创建。requirejs使用 onload 事件来处理回调函数：</p>
<h3 id="♥︎♥︎♥︎-0-1-0-2-等不等于-0-3？自己封装一个让他们相等的方法"><a href="#♥︎♥︎♥︎-0-1-0-2-等不等于-0-3？自己封装一个让他们相等的方法" class="headerlink" title="♥︎♥︎♥︎ 0.1+0.2 等不等于 0.3？自己封装一个让他们相等的方法"></a>♥︎♥︎♥︎ 0.1+0.2 等不等于 0.3？自己封装一个让他们相等的方法</h3><p>在正常的数学逻辑思维中，0.1+0.2&#x3D;0.3这个逻辑是正确的，但是在JavaScript中0.1+0.2！&#x3D;&#x3D;0.3，这是</p>
<p>为什么呢？这个问题也会偶尔被用来当做面试题来考查面试者对JavaScript的数值的理解程度。</p>
<p>在JavaScript中的二进制的浮点数0.1和0.2并不是十分精确，在他们相加的结果并非正好等于0.3，</p>
<p>而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为false。</p>
<pre><code class="css">方法1：设置一个误差范围值，通常称为”机器精度“，而对于Javascript来说，这个值通常是2^-52,而在
ES6中，已经为我们提供了这样一个属性：Number.EPSILON，而这个值正等于2^-52。这个值非常非常
小，在底层计算机已经帮我们运算好，并且无限接近0，但不等于0,。这个时候我们只要判断
(0.1+0.2)-0.3小于Number.EPSILON，在这个误差的范围内就可以判定0.1+0.2===0.3为true。
function numbersequal(a,b)&#123; 
 return Math.abs(a-b)&lt;Number.EPSILON;
&#125;

方法2：转为整数运算
</code></pre>
<h3 id="♥︎♥︎♥︎-跨域是什么？有哪些解决跨域的方法和方案？"><a href="#♥︎♥︎♥︎-跨域是什么？有哪些解决跨域的方法和方案？" class="headerlink" title="♥︎♥︎♥︎ 跨域是什么？有哪些解决跨域的方法和方案？"></a>♥︎♥︎♥︎ 跨域是什么？有哪些解决跨域的方法和方案？</h3><h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域?"></a>什么是跨域?</h4><p>所谓的同源是指，域名、协议、端口均为相同。<br>所谓的跨域，不同的域名、协议、端口皆为不同域<br>一个域与另一个域名、协议或者端口不同的域的之间访问都叫跨域</p>
<h4 id="解决跨域的方法和方案："><a href="#解决跨域的方法和方案：" class="headerlink" title="解决跨域的方法和方案："></a>解决跨域的方法和方案：</h4><pre><code class="css">1：通过服务端代理请求。如PHP，服务端语言php是没有跨域限制的，让服务器去别的网站获取内容然
后返回给页面。

2：第二种：jsonp跨域
 1. jsonp跨域就是利用script标签的跨域能力请求资源
 2. jsonp与ajax没有半毛钱关系！！
 3. 浏览器的同源策略限制了js的跨域能力，但没有限制link img iframe script 的跨域行为
 实现方式：
 1. 利用js创建一个script标签，把json的url赋给script的scr属性，
 2. 把这个script插入到页面里，让浏览器去跨域获取资源
 3. JS先声明好回调函数，插入页面后会代为执行该函数，并且传入json对象为其参数。
 注意：
 1. jsonp只针对get请求
 2. script标签加载回来的资源会被当成js在全局执行

3：CORS 跨域资源共享(xhr2)
 CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）
 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制
 整个CORS通信过程，都是浏览器自动完成，不需要用户参与
 对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样
 实现CORS通信的关键是服务器，只要服务器实现了CORS接口，就可以跨源通信

4：nginx代理跨域
 通过nginx服务器转发跨域请求，达到跨域的目的
</code></pre>
<h3 id="♥︎♥︎♥︎-什么是函数式编程？什么的声明式编程？"><a href="#♥︎♥︎♥︎-什么是函数式编程？什么的声明式编程？" class="headerlink" title="♥︎♥︎♥︎ 什么是函数式编程？什么的声明式编程？"></a>♥︎♥︎♥︎ 什么是函数式编程？什么的声明式编程？</h3><h4 id="函数式编程："><a href="#函数式编程：" class="headerlink" title="函数式编程："></a>函数式编程：</h4><p>函数式编程和声明式编程是有所关联的，因为他们思想是一致的：即只关注做什么而不是怎么做。但函数式编程不仅仅局限于声明式编程。</p>
<p>函数式编程最重要的特点是“函数第一位”，即函数可以出现在任何地方，比如你可以把函数作为参数传递给另一个函数，不仅如此你还可以将函数作为返回值。</p>
<h4 id="声明式编程："><a href="#声明式编程：" class="headerlink" title="声明式编程："></a>声明式编程：</h4><p>声明式编程是以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。</p>
<p>SQL 语句就是最明显的一种声明式编程的例子，例如：</p>
<p>SELECT * FROM collection WHERE num &gt; 5</p>
<p>除了 SQL，网页编程中用到的 HTML 和 CSS 也都属于声明式编程。</p>
<p>特点：</p>
<p>1：是它不需要创建变量用来存储数据。</p>
<p>2：不包含循环控制的代码如 for， while。</p>
<h3 id="♥︎♥︎♥︎-super-是否必须执行？不执行怎么让它不报错？"><a href="#♥︎♥︎♥︎-super-是否必须执行？不执行怎么让它不报错？" class="headerlink" title="♥︎♥︎♥︎ super() 是否必须执行？不执行怎么让它不报错？"></a>♥︎♥︎♥︎ super() 是否必须执行？不执行怎么让它不报错？</h3><p>非必须，</p>
<p>在 JavaScript 中，super 指的是父类的构造函数</p>
<p>如果想在构造函数中使用this，你必须首先调用super。 先让父类做完自己的事不执行无法使用this.</p>
<p> 不报错的方法：</p>
<p> 1：不使用this</p>
<p> 2：手动修正this</p>
<h3 id="♥︎♥︎♥︎-eventloop-渲染在哪一步？"><a href="#♥︎♥︎♥︎-eventloop-渲染在哪一步？" class="headerlink" title="♥︎♥︎♥︎ eventloop 渲染在哪一步？"></a>♥︎♥︎♥︎ eventloop 渲染在哪一步？</h3><pre><code class="css">任务队列
所有的任务可以分为同步任务和异步任务，同步任务，顾名思义，就是立即执行的任务，同步任务一般会直接进入到主线程中执行；而异步任务，就是异步执行的任务，比如ajax网络请求，setTimeout 定时函数等都属于异步任务，异步任务会通过任务队列( Event Queue )的机制来进行协调。

同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入 Event Queue。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。

在事件循环中，每进行一次循环操作称为tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：
在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue更新 render
主线程重复执行上述步骤
</code></pre>
<p>那么，什么是 microtasks ?规范中规定，task分为两大类, 分别是 Macro Task （宏任务）和 Micro Task</p>
<p>（微任务）, 并且每个宏任务结束后, 都要清空所有的微任务,这里的 Macro Task也是我们常说的 task 。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(macro)task</td>
<td align="center">script( 整体代码)、setTimeout、setInterval、I&#x2F;O、UI 交互事件、setImmediate(Node.js 环境)</td>
</tr>
<tr>
<td align="center">microtask</td>
<td align="center">Promise、MutaionObserver、process.nextTick(Node.js 环境)</td>
</tr>
</tbody></table>
<pre><code class="css">整体 script 作为第一个宏任务进入主线程，遇到 console.log，输出 script start
遇到 setTimeout，其回调函数被分发到宏任务 Event Queue 中
遇到 Promise，其 then函数被分到到微任务 Event Queue 中,记为 then1，之后又遇到了 then 函数，
将其分到微任务 Event Queue 中，记为 then2
遇到 console.log，输出 script end
至此，Event Queue 中存在三个任务，如下表：
宏任务 微任务
setTimeout then1
then2
执行微任务，首先执行then1，输出 promise1, 然后执行 then2，输出 promise2，这样就清空了
所有微任务
此时，所有的mircotask执行完毕，本轮事件循环结束，UI 开始 render，当 UI render 完毕，开始
下一轮事件循环.
执行 setTimeout 任务，输出 setTimeout, 至此，输出的顺序是：script start, script end,
promise1, promise2, setTimeout
</code></pre>
<p>UI渲染</p>
<p>根据HTML Standard，一轮事件循环执行结束之后，下轮事件循环执行之前开始进行 UI render。即：macro-task任务执行完毕，接着执行完所有的micro-task任务后，此时本轮循环结束，开始执行UIrender。UI render完毕之后接着下一轮循环。</p>
<h3 id="♥︎♥︎♥︎-简述call、apply、bind，call-和-apply哪个性能更好？"><a href="#♥︎♥︎♥︎-简述call、apply、bind，call-和-apply哪个性能更好？" class="headerlink" title="♥︎♥︎♥︎ 简述call、apply、bind，call 和 apply哪个性能更好？"></a>♥︎♥︎♥︎ 简述call、apply、bind，call 和 apply哪个性能更好？</h3><h4 id="1、call"><a href="#1、call" class="headerlink" title="1、call()"></a>1、call()</h4><pre><code class="css">call() 方法调用一个函数, 其具有一个指定的 this值和分别地提供的参数(参数的列表)。 第一个参数：在
fun 函数运行时指定的 this 值;如果指定了 null 或者 undefined 则内部 this 指向 window，后面的参
数：指定的参数列表
var fn = function(arg1, arg2) &#123; 
&#125;;
fn.call(this, arg1, arg2);
var numbers = [5, 458 , 120 , -215 ]; 
var maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //获取数组中的最大值458
</code></pre>
<h4 id="2、apply"><a href="#2、apply" class="headerlink" title="2、apply()"></a>2、apply()</h4><pre><code class="css">apply()方法调用一个函数, 其具有一个指定的 this 值，以及作为一个数组（或类似数组的对象）提供的
参数。apply() 与 call() 非常相似，不同之处在于提供参数的方式。apply() 使用参数数组而不是一组参数
列表。
var fn = function(arg1, arg2) &#123; 
&#125;;
fn.apply(this, [arg1, arg2])
var numbers = [5, 458 , 120 , -215 ]; 
//umber 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。
var maxInNumbers = Math.max.apply(Math, numbers), //获取数组中的最大值458
</code></pre>
<h4 id="3、bind"><a href="#3、bind" class="headerlink" title="3、bind()"></a>3、bind()</h4><pre><code class="css">bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相的函数体（在 ECMAScript 5 规范中内置的call属性）。
当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。
一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数
</code></pre>
<p>&#x2F;* ——call 和 apply哪个性能更好？—— *&#x2F;</p>
<p>call的性能要比apply好一些，尤其是传递给函数的参数超过3个时所以后期开发的时候，可以使用call多一些</p>
<p>（传参数3个以内的话，call和apply性能差不多，超过3个以上call更好一些）</p>
<h3 id="♥︎♥︎♥︎-Promise-避免回调地狱的语法糖–实现链式调用的核心点是什么？"><a href="#♥︎♥︎♥︎-Promise-避免回调地狱的语法糖–实现链式调用的核心点是什么？" class="headerlink" title="♥︎♥︎♥︎ Promise 避免回调地狱的语法糖–实现链式调用的核心点是什么？"></a>♥︎♥︎♥︎ Promise 避免回调地狱的语法糖–实现链式调用的核心点是什么？</h3><pre><code class="css">解决回调地狱的终极方法 async/await ES7的语法，可以通过 async/await让代码看起来像同步的async异步 await等待
await 等待 就是当后面跟的是promise对象，就让他停止 ，先让里面的异步事情做完，在把结果返回给
前面的新变量，在继续向后执行
他只生效当前作用域内部，也就是async函数内部。

实现链式调用的核心点: 在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled 之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是then 中产生的 Promise)，同时下一个 Promise的状态也会
被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去…
</code></pre>
<h3 id="♥︎♥︎♥︎-进程线程区别是什么？"><a href="#♥︎♥︎♥︎-进程线程区别是什么？" class="headerlink" title="♥︎♥︎♥︎ 进程线程区别是什么？"></a>♥︎♥︎♥︎ 进程线程区别是什么？</h3><h4 id="什么是进程？什么是线程？"><a href="#什么是进程？什么是线程？" class="headerlink" title="什么是进程？什么是线程？"></a>什么是进程？什么是线程？</h4><p>进程是系统中正在运行的一个程序，程序一旦运行就是进程。</p>
<p>进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空</p>
<p>间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要</p>
<p>使用进程间通信，比如管道，文件，套接字等。</p>
<p>一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间。线程与进程的一个主要区别是，统一</p>
<p>进程内的一个主要区别是，同一进程内的多个线程会共享部分状态，多个线程可以读写同一块内存（一</p>
<p>个进程无法直接访问另一进程的内存）。同时，每个线程还拥有自己的寄存器和栈，其他线程可以读写</p>
<p>这些栈内存。</p>
<p>线程是进程的一个实体，是进程的一条执行路径。</p>
<p>线程是进程的一个特定执行路径。当一个线程修改了进程的资源，它的兄弟线程可以立即看到这种变</p>
<p>化。</p>
<h4 id="进程和线程的区别体现在以下几个方面："><a href="#进程和线程的区别体现在以下几个方面：" class="headerlink" title="进程和线程的区别体现在以下几个方面："></a>进程和线程的区别体现在以下几个方面：</h4><p>1.地址空间和其他资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程</p>
<p>在其他进程内不可见。</p>
<p>2.通信：进程间通信IPC（管道，信号量，共享内存，消息队列），线程间可以直接独写进程数据段（如</p>
<p>全局变量）来进程通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</p>
<p>3.调度和切换：线程上下文切换比进程上下文切换快得多。</p>
<p>4.在多线程OS中，进程不是一个可执行的实体。</p>
<h3 id="♥︎♥︎♥︎-禁止事件冒泡，禁止默认事件"><a href="#♥︎♥︎♥︎-禁止事件冒泡，禁止默认事件" class="headerlink" title="♥︎♥︎♥︎ 禁止事件冒泡，禁止默认事件"></a>♥︎♥︎♥︎ 禁止事件冒泡，禁止默认事件</h3><pre><code class="css">/-----禁止事件冒泡:-----/
function stopBubble(e) &#123;
//如果提供了事件对象，则这是一个非IE浏览器
if ( e &amp;&amp; e.stopPropagation )
 //因此它支持W3C的stopPropagation()方法
 e.stopPropagation();
else
 //否则，我们需要使用IE的方式来取消事件冒泡
 window.event.cancelBubble = true;
&#125;

/-----阻止浏览器的默认行为-----/
function stopDefault( e ) &#123;
 //阻止默认浏览器动作(W3C)
 if ( e &amp;&amp; e.preventDefault )
 e.preventDefault();
 //IE中阻止函数器默认动作的方式
 else
 window.event.returnValue = false;
 return false;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-使用箭头函数应该注意什么？"><a href="#♥︎♥︎♥︎-使用箭头函数应该注意什么？" class="headerlink" title="♥︎♥︎♥︎ 使用箭头函数应该注意什么？"></a>♥︎♥︎♥︎ 使用箭头函数应该注意什么？</h3><ol>
<li><p>不要在对象里面定义函数，对象里面的行数应该用传统的函数方法</p>
</li>
<li><p>不要在对原型对象上定义函数，在对象原型上定义函数也是遵循着一样的规则</p>
</li>
<li><p>不要用箭头定义构造函数</p>
</li>
<li><p>不要用箭头定义事件回调函数</p>
</li>
</ol>
<h3 id="♥︎♥︎♥︎-你知道-ES6-中的-Generator-和-yiled-吗？在实际开发中使用过吗？"><a href="#♥︎♥︎♥︎-你知道-ES6-中的-Generator-和-yiled-吗？在实际开发中使用过吗？" class="headerlink" title="♥︎♥︎♥︎ 你知道 ES6 中的 Generator 和 yiled 吗？在实际开发中使用过吗？"></a>♥︎♥︎♥︎ 你知道 ES6 中的 Generator 和 yiled 吗？在实际开发中使用过吗？</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案</p>
<p>执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态</p>
<p>形式上，Generator函数是一个普通函数，但是有两个特征：</p>
<pre><code class="javascript">1. function关键字与函数名之间有一个星号
2. 函数体内部使用yield表达式，定义不同的内部状态
//-----利用Generator函数，在对象上实现Iterator接口-----//
function* iterEntries(obj) &#123;
 let keys = Object.keys(obj);
 for (let i=0; i &lt; keys.length; i++) &#123;
 let key = keys[i];
 yield [key, obj[key]];
 &#125;
&#125;
let myObj = &#123; foo: 3, bar: 7 &#125;;
for (let [key, value] of iterEntries(myObj)) &#123;
 console.log(key, value);
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-Cookie、storage-的区别？什么时候使用？"><a href="#♥︎♥︎♥︎-Cookie、storage-的区别？什么时候使用？" class="headerlink" title="♥︎♥︎♥︎ Cookie、storage 的区别？什么时候使用？"></a>♥︎♥︎♥︎ Cookie、storage 的区别？什么时候使用？</h3><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><pre><code class="css">1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。localStorage不会自动把数据发给服务器，仅在本地保存。
2. cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。
3. 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
4. 数据有效期不同，
localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；
cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。
5. WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。
6. WebStorage 的 api 接口使用更方便。
</code></pre>
<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><p>localStorage可以用来统计页面访问次数。</p>
<p>cookie一般存储用户名密码相关信息，一般使用escape转义编码后存储。</p>
<h3 id="♥︎♥︎♥︎-map、fillter、reduce-各自有什么作用？"><a href="#♥︎♥︎♥︎-map、fillter、reduce-各自有什么作用？" class="headerlink" title="♥︎♥︎♥︎ map、fillter、reduce 各自有什么作用？"></a>♥︎♥︎♥︎ map、fillter、reduce 各自有什么作用？</h3><pre><code class="css">1：map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。
另外 map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组
2：filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以
利用这个函数删除一些不需要的元素,和 map 一样，filter 的回调函数也接受三个参数，用处也相同。
3：reduce 可以将数组中的元素通过回调函数最终转换为一个值。
它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 reduce 的过程
首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入
回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作
用，这里着重分析第一个参数
</code></pre>
<h3 id="♥︎♥︎♥︎-promise-常见方法和-all-和-race的应用场景"><a href="#♥︎♥︎♥︎-promise-常见方法和-all-和-race的应用场景" class="headerlink" title="♥︎♥︎♥︎ promise 常见方法和 all 和 race的应用场景"></a>♥︎♥︎♥︎ promise 常见方法和 all 和 race的应用场景</h3><h4 id="Promise-race（）："><a href="#Promise-race（）：" class="headerlink" title="Promise.race（）："></a>Promise.race（）：</h4><p>race的用法：谁跑的快，以谁为准执行回调。</p>
<p>race的使用场景：比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all():"></a>Promise.all():</h4><p>all的用法：谁跑的慢，以谁为准执行回调。</p>
<p>在前端的开发实践中，我们有时会遇到需要发送多个请求并根据请求顺序返回数据的需求</p>
<h3 id="♥︎♥︎♥︎-介绍一下-ES6-中-Set-Map的区别？"><a href="#♥︎♥︎♥︎-介绍一下-ES6-中-Set-Map的区别？" class="headerlink" title="♥︎♥︎♥︎ 介绍一下 ES6 中 Set, Map的区别？"></a>♥︎♥︎♥︎ 介绍一下 ES6 中 Set, Map的区别？</h3><pre><code class="css">Map
在JS中的默认对象的表示方式为&#123;&#125;，即一组键值对，但是键必须是字符串。
为了使用Number或者其他数据类型作为键，ES6规范引入了新的数据类型Map。
Map是一组键值对的结构，具有极快的查找速度。初始化Map需要一个二维数组，或者直接初始化一个
空Map。
Map 对象是键值对集合，和 JSON 对象类似，但是 key 不仅可以是字符串还可以是其他各种类型的值包
括对象都可以成为Map的键


Set
Set也是一组key的集合，与Map类似。但是区别是Set不存储value，并且它的key不能重复。
创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：
重复元素会在Set中自动被过滤
Set 对象类似于数组，且成员的值都是唯一的
</code></pre>
<h3 id="♥︎♥︎♥︎-为什么操作-dom-慢？"><a href="#♥︎♥︎♥︎-为什么操作-dom-慢？" class="headerlink" title="♥︎♥︎♥︎ 为什么操作 dom 慢？"></a>♥︎♥︎♥︎ 为什么操作 dom 慢？</h3><p>DOM对象本身也是一个js对象，所以严格来说，并不是操作这个对象慢，而是说操作了这个对象后，需</p>
<p>要经过跨流程通信和渲染线程触发的重新渲染，导致DOM操作慢</p>
<p>JS引擎和和渲染引擎的模块化设计，使得它们可以独立优化，运行速度更快，但是这种设计带来的后果</p>
<p>就是DOM操作会越来越慢</p>
<h3 id="♥︎♥︎♥︎-js中的常用事件绑定方法"><a href="#♥︎♥︎♥︎-js中的常用事件绑定方法" class="headerlink" title="♥︎♥︎♥︎ js中的常用事件绑定方法"></a>♥︎♥︎♥︎ js中的常用事件绑定方法</h3><ol>
<li><p>在DOM元素中直接绑定</p>
</li>
<li><p>在JavaScript代码中绑定</p>
</li>
<li><p>绑定事件监听函数</p>
</li>
</ol>
<h3 id="♥︎♥︎♥︎-ts-和-js-的区别"><a href="#♥︎♥︎♥︎-ts-和-js-的区别" class="headerlink" title="♥︎♥︎♥︎ ts 和 js 的区别"></a>♥︎♥︎♥︎ ts 和 js 的区别</h3><pre><code class="css">1.ts是静态类语言，可以做到声明即文档，js是动态类语言相对更灵活。
2.如用ts写一个button组件可以清晰的知道，ButtonProps如是否必传，可选，style是什么类型，
disabled是什么类型，较js，ts更易于维护和拓展，可以做到代码即注释，避免一个月不见3，代码自己
都忘记自己写了什么的尴尬，
4.ts对比js基础类型上，增加了 void/never/any/元组/枚举/以及一些高级类型
5.js没有重载概念，ts有可以重载
6.vscode/ide对ts有很友好的提示
7.ts更利于重构
</code></pre>
<h3 id="♥︎♥︎♥︎-简述原生-js-发-ajax-的步骤"><a href="#♥︎♥︎♥︎-简述原生-js-发-ajax-的步骤" class="headerlink" title="♥︎♥︎♥︎ 简述原生 js 发 ajax 的步骤"></a>♥︎♥︎♥︎ 简述原生 js 发 ajax 的步骤</h3><p>1.创建XMLHTTPRequest对象</p>
<p>2.使用open方法设置和服务器的交互信息</p>
<p>3.设置发送的数据，开始和服务器端交互</p>
<p>4.注册事件</p>
<p>5.更新界面</p>
<h3 id="♥︎♥︎♥︎-instanceof的原理是什么？"><a href="#♥︎♥︎♥︎-instanceof的原理是什么？" class="headerlink" title="♥︎♥︎♥︎  instanceof的原理是什么？"></a>♥︎♥︎♥︎  instanceof的原理是什么？</h3><pre><code class="javascript">// instanceof 可以正确的判断对象的类型，是通过判断对象的原型链中是不是能找到类型的prototype。
function fn(left, right) &#123;
 let prototype = right.prototype;
 left = left.proto;
 while (true) &#123;
 if (left === undefined || left === null) &#123;
 return false;
 &#125;
 if (left === prototype) &#123;
 return true;
 &#125;
 left = left.proto;
 &#125;
&#125;
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎♥︎-介绍一下-typeof-区分类型的原理"><a href="#♥︎♥︎♥︎♥︎-介绍一下-typeof-区分类型的原理" class="headerlink" title="♥︎♥︎♥︎♥︎ 介绍一下 typeof 区分类型的原理"></a>♥︎♥︎♥︎♥︎ 介绍一下 typeof 区分类型的原理</h3><pre><code class="javascript">typeof原理： 不同的对象在底层都表示为二进制，在Javascript中二进制前（低）三位存储其类型信
息。
000: 对象
010: 浮点数
100:字符串
110: 布尔
1: 整数
/----------------------------------------------/
typeof null 为&quot;object&quot;, 原因是因为 不同的对象在底层都表示为二进制，在Javascript中二进制前（低）
三位都为0的话会被判断为Object类型，null的二进制表示全为0，自然前三位也是0，所以执行typeof时
会返回&quot;object&quot;###
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-说说你对-JavaScript-的作用域的理解。什么是作用域链？"><a href="#♥︎♥︎♥︎♥︎-说说你对-JavaScript-的作用域的理解。什么是作用域链？" class="headerlink" title="♥︎♥︎♥︎♥︎ 说说你对 JavaScript 的作用域的理解。什么是作用域链？"></a>♥︎♥︎♥︎♥︎ 说说你对 JavaScript 的作用域的理解。什么是作用域链？</h3><p>在 JavaScript 中有两种作用域类型：</p>
<ol>
<li><p>局部作用域:只能在函数内部访问它们</p>
</li>
<li><p>全局作用域:网页的所有脚本和函数都能够访问它</p>
</li>
</ol>
<p>JavaScript 拥有函数作用域：每个函数创建一个新的作用域。</p>
<p>作用域决定了这些变量的可访问性（可见性）。</p>
<p>函数内部定义的变量从函数外部是不可访问的（不可见的）。</p>
<p>作用域链：</p>
<p>当查找变量的时候，会先从当前上下文的变量对象中查找，</p>
<p>如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变</p>
<p>量对象，也就是全局对象。</p>
<p>这样由多个执行上下文的变量对象构成的链表就叫做作用域链</p>
<h3 id="♥︎♥︎♥︎♥︎-说说你对执行上下文的理解"><a href="#♥︎♥︎♥︎♥︎-说说你对执行上下文的理解" class="headerlink" title="♥︎♥︎♥︎♥︎ 说说你对执行上下文的理解"></a>♥︎♥︎♥︎♥︎ 说说你对执行上下文的理解</h3><pre><code class="css">执行上下文有且只有三类，全局执行上下文，函数上下文，与eval上下文(eval一般不会使用) 
1. 全局执行上下文：
全局执行上下文只有一个，也就是我们熟知的window对象，我们能在全局作用域中通过this直接访问到它
2. 函数执行上下文
函数执行上下文可存在无数个，每当一个函数被调用时都会创建一个函数上下文；
需要注意的是，同一个函数被多次调用，都会创建一个新的上下文。
3. 执行上下文栈(下文简称执行栈)也叫调用栈，
执行栈用于存储代码执行期间创建的所有上下文，具有LIFO（Last In First Out后进先出，也就是
先进后出）的特性。

JS代码首次运行，都会先创建一个全局执行上下文并压入到执行栈中，之后每当有函数被调用，都会创
建一个新的函数执行上下文并压入栈内；由于执行栈LIFO的特性，所以可以理解为，JS代码执行完毕前
在执行栈底部永远有个全局执行上下文。###
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-你对事件循环有了解吗？说说看！"><a href="#♥︎♥︎♥︎♥︎-你对事件循环有了解吗？说说看！" class="headerlink" title="♥︎♥︎♥︎♥︎ 你对事件循环有了解吗？说说看！"></a>♥︎♥︎♥︎♥︎ 你对事件循环有了解吗？说说看！</h3><p>Event Loop(事件循环)中，每一次循环称为 tick, 每一次tick的任务如下：</p>
<p>执行栈选择最先进入队列的宏任务(通常是script整体代码)，如果有则执行</p>
<p>检查是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列</p>
<p>更新render(每一次事件循环，浏览器都可能会去更新渲染)</p>
<p>重复以上步骤</p>
<p>宏任务 &gt; 所有微任务 &gt; 宏任务</p>
<ol>
<li><p>将所有任务看成两个队列：执行队列与事件队列。</p>
</li>
<li><p>执行队列是同步的，事件队列是异步的，宏任务放入事件列表，微任务放入执行队列之后，事件队</p>
</li>
</ol>
<p>列之前。</p>
<ol start="3">
<li>当执行完同步代码之后，就会执行位于执行列表之后的微任务，然后再执行事件列表中的宏任务</li>
</ol>
<h3 id="♥︎♥︎♥︎♥︎-微任务和宏任务有什么区别？"><a href="#♥︎♥︎♥︎♥︎-微任务和宏任务有什么区别？" class="headerlink" title="♥︎♥︎♥︎♥︎ 微任务和宏任务有什么区别？"></a>♥︎♥︎♥︎♥︎ 微任务和宏任务有什么区别？</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">宏任务（macrotask）</th>
<th align="center">微任务（microtask）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">谁发起的宿主</td>
<td align="center">（Node、浏览器）</td>
<td align="center">JS引擎</td>
</tr>
<tr>
<td align="center">具体事件</td>
<td align="center">1. script (可以理解为外层同步代码) 2. setTimeout&#x2F;setInterval 3. UI rendering&#x2F;UI事件 4.postMessage，MessageChannel 5. setImmediate，I&#x2F;O（Node.js）</td>
<td align="center">1. Promise 2.MutaionObserver 3. Object.observe（已废弃；Proxy 对象替代） 4. process.nextTick（Node.js）</td>
</tr>
<tr>
<td align="center">谁先运行</td>
<td align="center">后运行</td>
<td align="center">先运行</td>
</tr>
<tr>
<td align="center">会触发新一轮Tick吗</td>
<td align="center">会</td>
<td align="center">不会</td>
</tr>
</tbody></table>
<h3 id="♥︎♥︎♥︎♥︎-如何实现函数的柯里化？比如-add-1-2-3"><a href="#♥︎♥︎♥︎♥︎-如何实现函数的柯里化？比如-add-1-2-3" class="headerlink" title="♥︎♥︎♥︎♥︎ 如何实现函数的柯里化？比如 add(1)(2)(3)"></a>♥︎♥︎♥︎♥︎ 如何实现函数的柯里化？比如 add(1)(2)(3)</h3><pre><code class="javascript">/-----解决方法1：-----/
function add () &#123;
 var args = Array.prototype.slice.call(arguments);
 var fn = function () &#123;
 var sub_arg = Array.prototype.slice.call(arguments);
　　 // 把全部的参数聚集到参数的入口为一个参数： args.concat(sub_arg)
 return add.apply(null, args.concat(sub_arg));
 &#125;
 fn.valueOf = function () &#123;
 return args.reduce(function(a, b) &#123;
 return a + b;
 &#125;)
 &#125;
 return fn;
&#125;
console.log(add(1,2)) // 3
console.log(add(1)(2)) // 3
console.log(add(1)(2)(3)) // 6
console.log(add(1,2,3)(4)) // 10
</code></pre>
<pre><code class="javascript">/-----解决方法2：-----/
function add () &#123;
 var args = Array.prototype.slice.call(arguments);
  var fn = function () &#123; 
    // 把参数都放在一个相当于全局变量的 args 里面 args.push(...arguments) 
    return fn; &#125;
  fn.valueOf = function () &#123; 
    return args.reduce(function(a, b) &#123; 
      return a + b; &#125;) 
  &#125;return fn;
&#125;
console.log(add(1,2)) // 3
console.log(add(1)(2)) // 3
console.log(add(1)(2)(3)) // 6
console.log(add(1,2,3)(4)) // 10
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-什么是反柯里化"><a href="#♥︎♥︎♥︎♥︎-什么是反柯里化" class="headerlink" title="♥︎♥︎♥︎♥︎ 什么是反柯里化"></a>♥︎♥︎♥︎♥︎ 什么是反柯里化</h3><p>在JavaScript中，当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点。可以通过反柯里化(uncurrying)函数实现，让一个对象去借用一个原本不属于他的方法。</p>
<h3 id="♥︎♥︎♥︎♥︎-了解-ES6-的-Proxy-吗？"><a href="#♥︎♥︎♥︎♥︎-了解-ES6-的-Proxy-吗？" class="headerlink" title="♥︎♥︎♥︎♥︎ 了解 ES6 的 Proxy 吗？"></a>♥︎♥︎♥︎♥︎ 了解 ES6 的 Proxy 吗？</h3><pre><code class="css">Proxy，代理，是ES6新增的功能，可以理解为代理器（即由它代理某些操作）。
Proxy 对象用于定义或修改某些操作的自定义行为，可以在外界对目标对象进行访问前，对外界的访问
进行改写。
new Proxy()表示生成一个 Proxy 实例
 -target：目标对象
 -handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。
注意：要实现拦截操作，必须是对 Proxy 实例进行操作，而不是针对目标对象 target 进行操作
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-深拷贝是什么？项目哪里是用到了深拷贝？"><a href="#♥︎♥︎♥︎♥︎-深拷贝是什么？项目哪里是用到了深拷贝？" class="headerlink" title="♥︎♥︎♥︎♥︎ 深拷贝是什么？项目哪里是用到了深拷贝？"></a>♥︎♥︎♥︎♥︎ 深拷贝是什么？项目哪里是用到了深拷贝？</h3><p>1，在拷贝构造函数中假如只完成了数据成员本身的赋值则称为“浅拷贝”；编译器提供的默认拷贝构造函</p>
<p>数就已经可以完成这个任务。</p>
<p>而假如要复制的数据除了属性值本身以外，还要复制附加在数据属性值上的额外内容，那就要自己来写</p>
<p>拷贝构造函数了，来完成所谓的“深拷贝”。</p>
<p>举个例子：</p>
<p>若在构造函数中new了一个新的空间存放数据，并且用指针记录了首地址；若是浅拷贝，则在拷贝构造</p>
<p>函数中指针值将复制给另一个数据成员，这样就会有两个指针指向同一个空间；这样的话在析构函数里</p>
<p>将会对指针所指向的空间进行释放，由于两个指针指向的是同一个空间，在释放第一个指针指向的空间</p>
<p>时不会出现什么问题，而释放第二个指针指向的空间时就会因为空间已经被解析过而导致解析的空间不</p>
<p>存在的情况，就会造成程序无法终止。</p>
<p>而解决上面这种情况的办法就是使用“深拷贝”，深拷贝是在拷贝构造函数里再new一个新的空间。将数</p>
<p>据复制在新空间里，并将拷贝的指针记录这个新空间的首地址，这样在析构函数里就不会有问题了。</p>
<p>2，在某些引用类型值不更新的情况下用深拷贝</p>
<h3 id="♥︎♥︎♥︎♥︎-ES6-中，数组监测怎么实现的（代理）"><a href="#♥︎♥︎♥︎♥︎-ES6-中，数组监测怎么实现的（代理）" class="headerlink" title="♥︎♥︎♥︎♥︎ ES6 中，数组监测怎么实现的（代理）"></a>♥︎♥︎♥︎♥︎ ES6 中，数组监测怎么实现的（代理）</h3><pre><code class="javascript">// 通过ES6的关键字extends实现继承完成Array原型方法的重写
class NewArray extends Array &#123;
 constructor(...args) &#123;
 // 调用父类Array的constructor()
 super(...args)
 &#125;
 push (...args) &#123;
 console.log(&#39;监听到数组的变化啦！&#39;);
   // 调用父类原型push方法 
   return super.push(...args)
 &#125;
 // ...
&#125;
let list3 = [1, 2];
let arr = new NewArray(...list3);
console.log(arr)
// (2) [1, 2]
arr.push(3);
// 监听到数组的变化啦！
console.log(arr)
// (3) [1, 2, 3]
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-模板引擎原理"><a href="#♥︎♥︎♥︎♥︎-模板引擎原理" class="headerlink" title="♥︎♥︎♥︎♥︎ 模板引擎原理"></a>♥︎♥︎♥︎♥︎ 模板引擎原理</h3><pre><code class="javascript">//模板引擎是通过字符串拼接得到的
let template = &#39;hello &lt;% name %&gt;!&#39;
let template = &#39;hello &#39; + name + &#39;!&#39;
字符串是通过new Function执行的
let name = &#39;world&#39;
let template = let str = &#39;hello &#39; + name + &#39;!&#39; return str
let fn = new Function(&#39;name&#39;, template)
console.log(fn(name)) // hello world!

//将模板转换为字符串并通过函数执行返回
let template = &#39;hello &lt;% name %&gt;!&#39;
let name = &#39;world&#39;
function compile (template) &#123;
 let html = template.replace(/&lt;%([\s\S]+?)%&gt;/g, (match, code) =&gt; &#123;
 return &#39; + $&#123;code&#125; + &#39;
 &#125;)
 html = let str = &#39;$&#123;html&#125;&#39;; return str
 return new Function(&#39;name&#39;, html)
&#125;
let str = compile(template)
console.log(str(name)) // hello world!

//函数只能接收一个name变量作为参数，功能太单一了，一般会通过对象来传参，with来减少变量访
问。
with功能
let params = &#123;
 name: &#39;张三&#39;,
 age: 18
&#125;
let str = &#39;&#39;
with (params) &#123;
 str = 用户$&#123;name&#125;的年龄是$&#123;age&#125;岁 &#125;
console.log(str) // 用户张三的年龄是18岁

//实现简单的模板引擎
let template = &#39;hello &lt;% name %&gt;!&#39;
let name = &#39;world&#39;
function compile (template) &#123;
 let html = template.replace(/&lt;%([\s\S]+?)%&gt;/g, (match, code) =&gt; &#123;
 return &#39; + $&#123;code.trim()&#125; + &#39;
 &#125;)
 html = &#39;$&#123;html&#125;&#39;
 html = let str = &#39;&#39;; with (params) &#123; str = $&#123;html&#125;; &#125; return str
 return new Function(&#39;params&#39;, html)
&#125;
let str = compile(template)
console.log(str(&#123; name &#125;)) // hello world!
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-ES6-的新特性"><a href="#♥︎♥︎♥︎♥︎-ES6-的新特性" class="headerlink" title="♥︎♥︎♥︎♥︎ ES6 的新特性"></a>♥︎♥︎♥︎♥︎ ES6 的新特性</h3><ol>
<li><p>const与let</p>
</li>
<li><p>模板字符串</p>
</li>
<li><p>解构赋值</p>
</li>
<li><p>对象简写法</p>
</li>
<li><p>for…of循环</p>
</li>
<li><p>展开运算符</p>
</li>
<li><p>剩余参数(可变参数) </p>
</li>
<li><p>ES6箭头函数</p>
</li>
<li><p>参数默认值</p>
</li>
<li><p>类和继承</p>
</li>
<li><p>模块化规范</p>
</li>
</ol>
<h3 id="♥︎♥︎♥︎♥︎-图片懒加载怎么实现？"><a href="#♥︎♥︎♥︎♥︎-图片懒加载怎么实现？" class="headerlink" title="♥︎♥︎♥︎♥︎ 图片懒加载怎么实现？"></a>♥︎♥︎♥︎♥︎ 图片懒加载怎么实现？</h3><p>原理：随着滚轮滚动，底部的图片会被不断地加载，从而显示在页面上，按需加载，当页面需要显示图片的时候才进行加载，否则不加载</p>
<ol>
<li><p>页面加载完成时记录每个img标签的src值的字符串，</p>
</li>
<li><p>用鼠标滚轮判断图片是否出现在屏幕，如果是，则把记录的src值赋值给src属性</p>
</li>
<li><p>然后让image的src来发起请求，获取对应的图片放置到DOM树的这个位置上，从而实现图片的页面渲染！</p>
</li>
</ol>
<p>于是就可以知道，当进入页面的时候，其实我们已经把所有的图片的这个地址信息拿到了，图片懒加载的作用就是让这个图片的src按需发起请求，获取图片。</p>
<h3 id="♥︎♥︎♥︎♥︎-异步的解决方案有哪些？"><a href="#♥︎♥︎♥︎♥︎-异步的解决方案有哪些？" class="headerlink" title="♥︎♥︎♥︎♥︎ 异步的解决方案有哪些？"></a>♥︎♥︎♥︎♥︎ 异步的解决方案有哪些？</h3><p>1.回调函数callback</p>
<p>2.事件发布订阅</p>
<p>3.Promise</p>
<p>4.Generator</p>
<p>5.async&#x2F;await</p>
<h3 id="♥︎♥︎♥︎♥︎-常见内存泄漏"><a href="#♥︎♥︎♥︎♥︎-常见内存泄漏" class="headerlink" title="♥︎♥︎♥︎♥︎ 常见内存泄漏"></a>♥︎♥︎♥︎♥︎ 常见内存泄漏</h3><p>1、静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<p>2、各种连接，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<p>3、变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</p>
<p>4、内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p>
<p>5、改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露</p>
<p>6、缓存泄漏</p>
<p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值</p>
<p>7、监听器和回调</p>
<p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存他的若引用，例如将他们保存成为WeakHashMap中的键。</p>
<h3 id="♥︎♥︎♥︎♥︎-插入几万个-dom-，如何实现页面不卡顿？"><a href="#♥︎♥︎♥︎♥︎-插入几万个-dom-，如何实现页面不卡顿？" class="headerlink" title="♥︎♥︎♥︎♥︎ 插入几万个 dom ，如何实现页面不卡顿？"></a>♥︎♥︎♥︎♥︎ 插入几万个 dom ，如何实现页面不卡顿？</h3><pre><code class="javascript">让创建插入节点的工作分批进行：
setTimeout(() =&gt; &#123;
 // 插入十万条数据
 const total = 100000;
 // 一次插入 20 条，如果觉得性能不好就减少
 const once = 20;
 // 渲染数据总共需要几次
 const loopCount = total / once;
 let countOfRender = 0
 let ul = document.querySelector(&quot;ul&quot;);
 function add() &#123;
 // 优化性能，插入不会造成回流
 const fragment = document.createDocumentFragment();
 for (let i = 0; i &lt; once; i++) &#123;
 const li = document.createElement(&quot;li&quot;);
 li.innerText = Math.floor(Math.random() * total);
 fragment.appendChild(li);
 &#125;
 ul.appendChild(fragment);
 countOfRender += 1;
 loop();
 &#125;
 function loop() &#123;
 if (countOfRender &lt; loopCount) &#123;
 window.requestAnimationFrame(add);
 &#125;
 &#125;
 loop();
&#125;, 0);
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-你知道什么是原型吗？我们为什么要用原型呢？或者说原型为我们提供了什么？"><a href="#♥︎♥︎♥︎♥︎-你知道什么是原型吗？我们为什么要用原型呢？或者说原型为我们提供了什么？" class="headerlink" title="♥︎♥︎♥︎♥︎ 你知道什么是原型吗？我们为什么要用原型呢？或者说原型为我们提供了什么？"></a>♥︎♥︎♥︎♥︎ 你知道什么是原型吗？我们为什么要用原型呢？或者说原型为我们提供了什么？</h3><p>什么是原型：</p>
<p>Javascript规定，每一个函数都有一个prototype对象属性，指向另一个对象（原型链上面的）。</p>
<p>prototype(对象属性)的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变(公用)的属性和方法，直接定义在prototype对象属性上。</p>
<p>prototype就是调用构造函数所创建的那个实例对象的原型（proto）。</p>
<p>prototype可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。</p>
<p>为什么要用原型：使用原型对象解决浪费内存</p>
<hr>
<h3 id="♥︎♥︎♥︎♥︎♥︎-浏览器和-Node-事件循环的区别？"><a href="#♥︎♥︎♥︎♥︎♥︎-浏览器和-Node-事件循环的区别？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 浏览器和 Node 事件循环的区别？"></a>♥︎♥︎♥︎♥︎♥︎ 浏览器和 Node 事件循环的区别？</h3><h4 id="Node中的事件循环："><a href="#Node中的事件循环：" class="headerlink" title="Node中的事件循环："></a>Node中的事件循环：</h4><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js 采用 V8 作为 js 的解析引擎，而</p>
<p>I&#x2F;O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系</p>
<p>统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现（下文会详细介绍）。</p>
<h4 id="Node-js-的运行机制如下"><a href="#Node-js-的运行机制如下" class="headerlink" title="Node.js 的运行机制如下:"></a>Node.js 的运行机制如下:</h4><p>V8 引擎解析 JavaScript 脚本。</p>
<p>解析后的代码，调用 Node API。</p>
<p>libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循</p>
<p>环），以异步的方式将任务的执行结果返回给 V8 引擎。</p>
<p>V8 引擎再将结果返回给用户。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-函数节流、防抖。scroll-resize-使用函数节流实现不要频繁触发事件的需求。"><a href="#♥︎♥︎♥︎♥︎♥︎-函数节流、防抖。scroll-resize-使用函数节流实现不要频繁触发事件的需求。" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 函数节流、防抖。scroll resize 使用函数节流实现不要频繁触发事件的需求。"></a>♥︎♥︎♥︎♥︎♥︎ 函数节流、防抖。scroll resize 使用函数节流实现不要频繁触发事件的需求。</h3><pre><code class="javascript">防抖：
//scroll方法中的do somthing至少间隔500毫秒执行一次
 window.addEventListener(&#39;scroll&#39;,function()&#123;
 var timer;//使用闭包，缓存变量
 return function()&#123;
 if(timer) clearTimeout(timer);
 timer = setTimeout(function()&#123;
 console.log(&#39;do somthing&#39;)
 &#125;,500)
 &#125;
 &#125;());//此处()作用 - 立即调用return后面函数，形成闭包
</code></pre>
<pre><code class="javascript">节流：
//scroll方法中当间隔时间大于2s，do somthing执行一次
 window.addEventListener(&#39;scroll&#39;,function()&#123;
 var timer ;//使用闭包，缓存变量
 var startTime = new Date();
 return function()&#123;
 var curTime = new Date();
 if(curTime - startTime &gt;= 2000)&#123;
 timer = setTimeout(function()&#123;
 console.log(&#39;do somthing&#39;)
 &#125;,500);
 startTime = curTime;
 &#125;
   &#125; &#125;());//此处()作用 - 立即调用return后面函数，形成闭包
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎♥︎-JS中的常见设计模式以及应用场景？"><a href="#♥︎♥︎♥︎♥︎♥︎-JS中的常见设计模式以及应用场景？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ JS中的常见设计模式以及应用场景？"></a>♥︎♥︎♥︎♥︎♥︎ JS中的常见设计模式以及应用场景？</h3><p>1、单例模式</p>
<p>单例模式就是一个实例在整个网页的生命周期里只创建一次，后续再调用实例创建函数的时候，返回的</p>
<p>仍是之前创建的实例。在实际开发中应用十分广泛，例如页面中的登录框，显示消息的提示窗</p>
<p>2、策略模式</p>
<p>策略模式是指将策略（算法）封装起来，策略的目的是将算法和使用分离开。</p>
<p>3、代理模式</p>
<p>代理模式很好理解，我们不能直接使用目标函数，而是通过调用代理函数来实现对目标函数的使用。</p>
<p>4、发布订阅模式</p>
<p>发布订阅模式在实际应用中非常常见，例如，我们在微信App上关注了某个公众号，当该公众号有新文</p>
<p>章发布时，就会通知我们。</p>
<p>发布订阅模式定义了一种一对多的依赖关系，当“一”发生变化，通知多个依赖。</p>
<p>5、命令模式</p>
<p>所谓命令模式就是将下要执行的业务逻辑封装到一个函数或类中，不需要具体谁来执行该命令的</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-用多种方法实现JavaScript继承"><a href="#♥︎♥︎♥︎♥︎♥︎-用多种方法实现JavaScript继承" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 用多种方法实现JavaScript继承"></a>♥︎♥︎♥︎♥︎♥︎ 用多种方法实现JavaScript继承</h3><h4 id="1-借用构造函数-经典继承"><a href="#1-借用构造函数-经典继承" class="headerlink" title="1.借用构造函数(经典继承)"></a>1.借用构造函数(经典继承)</h4><pre><code class="css">function Cat(name,age)&#123;
    Animal.call(this,name)
    this.age=age
&#125;
let cat=new Cat(&quot;妙妙&quot;,1)
cat.sayname()
console.log(cat instanceof Animal)  //false
console.log(cat instanceof Cat)    //true

核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。
优点：
1.构造函数，优点是可以多重继承。
2.创建子类实例时，可以向父类传递参数。
缺点：
1.实例并不是父类的实例，只是子类的实例。
2.只能继承构造函数内的，原型上的东西不能继承。
3.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能。
</code></pre>
<h4 id="2-原型链继承"><a href="#2-原型链继承" class="headerlink" title="2.原型链继承"></a>2.原型链继承</h4><pre><code class="css">function Dog(name)&#123;
    this.name=name
&#125;
Dog.prototype=new Animal()
let dog =new Dog(&#39;旺财&#39;)
dog.sayname();dog.eat(&#39;bone&#39;)
console.log(dog instanceof Animal)  //true
console.log(dog instanceof Dog)    //true

核心：将父类的实例作为子类的原型。
优点：
1.非常纯粹的继承关系，实例是子类的实例，也是父类的实例。
2.简单，父类上新增的方法属性子类都能访问的到。
3.简单，易于实现。
缺点：
1.要想为子类新增属性和方法，必须在 new Animal这样语句后，不能放到构造器内。
2.无法多重继承。
3.创建子类实例的时候，无法向父类构造函数传参。
</code></pre>
<h4 id="3-实例继承"><a href="#3-实例继承" class="headerlink" title="3.实例继承"></a>3.实例继承</h4><pre><code class="css">function Bird(name)&#123;
    let instance= new Animal()
    instance.name= name || &#39;bird&#39;
    return instance
&#125;
let bird =new Bird(&quot;飞飞&quot;)
bird.sayname();bird.eat(&quot;虫子&quot;)
console.log(bird instanceof Animal)  //true
console.log(bird instanceof Bird)    //false

核心：为父类实例添加新特性，作为子类实例返回。
优点：不限制调用方式，不管是new子类（）还是子类（），返回的对象具有相同的效果。
缺点：就是实例是父类的实例，不是子类的实例，不支持多继承。
</code></pre>
<h4 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4.拷贝继承"></a>4.拷贝继承</h4><pre><code class="css">function Cow(name)&#123;
    let animal=new Animal()
    for (let key in animal)&#123;
        console.log(&quot;key&quot;,key)
        Cow.prototype[key]=animal[key]
    &#125;
    Cow.prototype.name=name || &#39;cow&#39;
&#125;
let cow =new Cow(&quot;哞～&quot;)
cow.sayname();cow.eat(&quot;草&quot;)
console.log(cow instanceof Animal)  //false
console.log(cow instanceof Cow)    //true 

优点：支持多继承
缺点：
1.效率较低，内存占用高（因为要拷贝父亲的属性）
2.无法获取父亲不可枚举的方法（不可枚举方法，不能用for in 访问到）
</code></pre>
<h4 id="5-组合继承（原型链和构造函数）"><a href="#5-组合继承（原型链和构造函数）" class="headerlink" title="5.组合继承（原型链和构造函数）"></a>5.组合继承（原型链和构造函数）</h4><pre><code class="css">function Sheep(name)&#123;
    Animal.call(this)
    this.name=name || &quot;羊&quot;
&#125;
Sheep.prototype=new Animal()
let sheep=new Sheep(&quot;喜洋洋&quot;)
sheep.sayname();sheep.eat(&quot;草&quot;)
console.log(sheep instanceof Animal)  //true
console.log(sheep instanceof Sheep)    //true 

核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例做为子类原型，实现函数复用。
优点：
1.弥补了构造继承的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法。
2.即是子类的实例，也是父类的实例。
3.不存在引用属性共享问题。
4.可传参。
5.函数可复用。
缺点：调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）
</code></pre>
<h4 id="6-寄生式组合继承"><a href="#6-寄生式组合继承" class="headerlink" title="6.寄生式组合继承"></a>6.寄生式组合继承</h4><pre><code class="css">function Horse(name)&#123;
    Animal.call(this)
    this.name = name || &#39;马&#39;
&#125;
(function()&#123;
    var Super = function()&#123;&#125; //创建一个没有实例的方法类
    Super.prototype =Animal.prototype
    Horse.prototype=new Super() //将实例作为子类的原型
&#125;)()
let horse = new Horse(&#39;白龙马&#39;)
horse.sayname()
console.log(horse instanceof Animal)  //true
console.log(horse instanceof Horse)    //true 

核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点。
优点：堪称完美
缺点：实现较为复杂
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎♥︎-SSR和CSR优势劣势"><a href="#♥︎♥︎♥︎♥︎♥︎-SSR和CSR优势劣势" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ SSR和CSR优势劣势"></a>♥︎♥︎♥︎♥︎♥︎ SSR和CSR优势劣势</h3><ul>
<li><p>SSR更有利于首屏渲染，CSR更有利于页面交互</p>
</li>
<li><p>SSR：</p>
<p>优势：</p>
<ul>
<li>搜索引擎可以抓取网站以获取更好的SEO</li>
<li>初始页面加载速度更快</li>
<li>非常适合静态网站</li>
</ul>
<p>劣势：</p>
<ul>
<li>频繁的服务器请求</li>
<li>整体缓慢的页面渲染</li>
<li>整页重新加载</li>
<li>不擅长于网站交互</li>
</ul>
</li>
<li><p>CSR：</p>
<p>优势：</p>
<ul>
<li>擅于网站交互</li>
<li>初始加载网站渲染速度快</li>
<li>非常适合Web应用程序</li>
<li>强大的JS选择</li>
</ul>
<p>劣势：</p>
<ul>
<li>不利于SEO</li>
<li>初始加载可能需要更多时间</li>
</ul>
</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎♥︎-for…in-和-for-of"><a href="#♥︎♥︎♥︎♥︎♥︎-for…in-和-for-of" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ for…in 和 for of"></a>♥︎♥︎♥︎♥︎♥︎ for…in 和 for of</h3><ul>
<li>for…in 循环：只能获得对象的key，不能获得value，主要是为了遍历对象而生，不适用于遍历数组。for…in 循环不仅遍历数字键名，还会遍历手动添加的其它键，包括原型链上的键。for…of 则不会这样。</li>
</ul>
<p>​	    for…of 循环：允许遍历获得键值，可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象</p>
<ul>
<li>对于普通对象，没有部署原生的 iterator 接口，直接使用 for…of 会报错</li>
</ul>
<p>​		可以使用 for…in 循环遍历键名</p>
<ul>
<li>forEach 循环无法中途跳出，break 命令或 return 命令都不能奏效</li>
</ul>
<p>​		for…of 循环可以与break、continue 和 return 配合使用，跳出循环</p>
<ul>
<li>无论是 for…in 还是 for…of 都不能遍历出 Symbol 类型的值，遍历 Symbol 类型的值需要用 Object.getOwnPropertySymbols() 方法</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎♥︎-获取对象的所有key值"><a href="#♥︎♥︎♥︎♥︎♥︎-获取对象的所有key值" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 获取对象的所有key值"></a>♥︎♥︎♥︎♥︎♥︎ 获取对象的所有key值</h3><ul>
<li>object.keys ：</li>
</ul>
<p>​		排序方式：index 、字符串的key创建事件、symbol</p>
<ul>
<li><p>for … in ：它能够额外遍历继承来的可枚举的属性</p>
</li>
<li><p>object.getOwnPropertyName   &#x3D;&gt;  获取key值</p>
</li>
<li><p>Object.getOwnPropertySymbols  &#x3D;&gt;  获取 symbol key，获取在对象上定义的符号数组</p>
</li>
<li><p>reflect.ownkeys：返回一个由目标对象自身的属性键组成的数组。</p>
</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎♥︎-null和undefined的区别"><a href="#♥︎♥︎♥︎♥︎♥︎-null和undefined的区别" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ null和undefined的区别"></a>♥︎♥︎♥︎♥︎♥︎ null和undefined的区别</h3><p>（1）Number转换的值不同，Number(null)输出为0, Number(undefined)输出为NaN</p>
<p>（2）null表示一个值被定义了，但是这个值是空值</p>
<ul>
<li><p>作为函数的参数，表示函数的参数不是对象</p>
</li>
<li><p>作为对象原型链的终点 （Object.getPrototypeOf(Object.prototype)）</p>
</li>
<li><p>定义一个值为null是合理的，但定义为undefined不合理（var name &#x3D; null）</p>
</li>
</ul>
<p>　　</p>
<p>（3）undefined表示缺少值，即此处应该有值，但是还没有定义</p>
<ul>
<li><p>变量被声明了还没有赋值，就为undefined</p>
</li>
<li><p>调用函数时应该提供的参数还没有提供，该参数就等于undefined</p>
</li>
<li><p>对象没有赋值的属性，该属性的值就等于undefined</p>
</li>
<li><p>函数没有返回值，默认返回undefined</p>
</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎♥︎-判断对象为空"><a href="#♥︎♥︎♥︎♥︎♥︎-判断对象为空" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 判断对象为空"></a>♥︎♥︎♥︎♥︎♥︎ 判断对象为空</h3><pre><code class="javascript">Object.keys(obj).length = = = 0  // true 则为空对象(有缺陷)
Object.keys(obj).length = = = 0 &amp;&amp; obj.constructor = = = Object
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎♥︎-对象的可冻结性"><a href="#♥︎♥︎♥︎♥︎♥︎-对象的可冻结性" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 对象的可冻结性"></a>♥︎♥︎♥︎♥︎♥︎ 对象的可冻结性</h3><p>本质都是Object.defineProperty去配置对象（去看看第三个参数那几个配置的参数）</p>
<p>初级冰冻：对key值进行只读，不可更改</p>
<p>中级冰冻：对key值进行不可读，不可枚举</p>
<p>高级冰冻：对key值不可配置</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-对象冻结"><a href="#♥︎♥︎♥︎♥︎♥︎-对象冻结" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 对象冻结"></a>♥︎♥︎♥︎♥︎♥︎ 对象冻结</h3><h4 id="Object-Seal"><a href="#Object-Seal" class="headerlink" title="Object.Seal"></a>Object.Seal</h4><p>当你听到 “seal” 这个词时，你会想到什么？ “seal” 的第一个意思是印章或者蜜蜡之类封信件的东西。在 JavaScript 中 <code>Object.seal</code> 的作用与 “密封” 相同。</p>
<p><code>Object.seal</code> 使传入对象的所有属性都不可配置。来举个例子。</p>
<pre><code class="js">const obj = &#123; a: 100 &#125;;
Object.getOwnPropertyDescriptors(obj);

/* &#123;
 *   a: &#123;
 *        configurable: true,
 *        enumerable: true,
 *        value: 100,
 *        writable: true
 *      &#125;
 * &#125;
 *
 */

Object.seal(obj);
Object.getOwnPropertyDescriptors(obj);

/* &#123;
 *   a: &#123;
 *        configurable: false,
 *        enumerable: true,
 *        value: 100,
 *        writable: true
 *      &#125;
 * &#125;
 *
 */

obj.a = 200;
console.log(obj.a);
// 输出：200

delete obj.a;
console.log(obj.a);
// 输出：200

obj.b = 500;
console.log(obj.b);
// 输出：undefined
</code></pre>
<p>对象 <code>obj</code> 只有一个值为 100 的属性。<code>obj</code> 的基本属性就像上面一样，<code>configurable</code>, <code>enumerable</code> 和 <code>writable</code> 都是 <code>true</code>。然后我用 <code>Object.seal</code> 把它封起来，想要看看哪些基本属性被修改了，哪些没有。结果是，只有 <code>configurable</code> 被改成了 <code>false</code>。</p>
<pre><code class="js">obj.a = 200;
</code></pre>
<p>即使被密封对象的基本属性 <code>configurable</code> 现在为 false，但属性值也被更改为 200。如前所述，将 <code>configurable</code>设置为 <code>false</code> 将使属性不可写，但如果 <code>writable</code> 已经写明为 <code>true</code> 时，<code>configurable</code>设置为 <code>false</code> 将不会生效。当你创建一个对象并添加一个新属性时，默认情况下它是 <code>writable: true</code> 。</p>
<pre><code class="js">delete obj.a;
</code></pre>
<p>封装对象使每个属性变为不可配置，从而使属性不可删除。</p>
<pre><code class="js">obj.b = 500;
</code></pre>
<p>Object.seal 后删除属性失败了是为什么呢？因为当调用 <code>Object.seal</code> 或 <code>Object.freeze</code> 时，传递给这些方法的对象变成不可扩展的对象，这意味着不能删除其中的任何属性或向其中添加任何属性。</p>
<h4 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze"></a>Object.freeze</h4><p><code>Object.freeze</code> 对传递的对象的限制比 <code>Object.seal</code> 更多。让我们再举一个例子。</p>
<pre><code class="js">const obj = &#123; a: 100 &#125;;
Object.getOwnPropertyDescriptors(obj);

/* &#123;
 *   a: &#123;
 *        configurable: true,
 *        enumerable: true,
 *        value: 100,
 *        writable: true
 *      &#125;
 * &#125;
 *
 */

Object.freeze(obj);
Object.getOwnPropertyDescriptors(obj);

/* &#123;
 *   a: &#123;
 *        configurable: false,
 *        enumerable: true,
 *        value: 100,
 *        writable: false
 *      &#125;
 * &#125;
 *
 */

obj.a = 200;
console.log(obj.a);
// 输出：100

delete obj.a;
console.log(obj.a);
// 输出：100

obj.b = 500;
console.log(obj.b);
// 输出：undefined
</code></pre>
<p>所以， <code>Object.freeze</code> 和 <code>Object.seal</code> 的区别是在使用后，<code>Object.freeze</code> 的 <code>writable</code> 会被设置为 <code>false</code> 而 <code>Object.seal</code> 仍然为 <code>true</code> 。</p>
<pre><code class="js">obj.a = 200;
</code></pre>
<p>因此，修改现有属性总是失败。</p>
<pre><code class="js">delete obj.a;
</code></pre>
<p>就像 <code>Object.seal</code> 一样， <code>Object.freeze</code> 也使得传递的对象不可配置，这使得其中的每个属性都不可删除。</p>
<pre><code class="js">obj.b = 500;
</code></pre>
<p>冻结对象也会使对象不可扩展。</p>
<h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ol>
<li>作用的对象变得不可扩展，这意味着不能再添加新属性。</li>
<li>作用的对象中的每个元素都变得不可配置，这意味着不能删除属性。</li>
<li>如果在 ‘use strict’ 模式下使用，这两个方法都可能抛出错误，例如在严格模式下修改 <code>obj.a = 500</code>。</li>
</ol>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p><code>Object.seal</code> 能让你修改属性的值，但 <code>Object.freeze</code> 不能.</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p><code>Object.freeze</code> 和 <code>Object.seal</code> 在 “实用性” 方面都有 “缺陷”，他们只冻结&#x2F;封印对象的第一深度。</p>
<p>这里有一个简单的比较。</p>
<pre><code class="js">const obj = &#123;
  foo: &#123;
    bar: 10
  &#125;
&#125;;
</code></pre>
<p>现在 <code>obj</code> 内部嵌套了一个对象 <code>foo</code>。 它内部有一个 <code>bar</code> 属性.</p>
<pre><code class="js">Object.getOwnPropertyDescriptors(obj);
/* &#123;
 *   foo: &#123;
 *        configurable: true,
 *        enumerable: true,
 *        value: &#123;bar: 10&#125;,
 *        writable: true
 *      &#125;
 * &#125;
 */

Object.getOwnPropertyDescriptors(obj.foo);
/* &#123;
 *   bar: &#123;
 *        configurable: true,
 *        enumerable: true,
 *        value: 10,
 *        writable: true
 *      &#125;
 * &#125;
 */
</code></pre>
<p>使用 <code>Object.freeze</code> 和 <code>Object.seal</code> 之后，</p>
<pre><code class="js">Object.seal(obj);
Object.freeze(obj);

// 这两种方法都会导致相同结果
</code></pre>
<p>让我们看看基础属性是如何变化的。</p>
<pre><code class="js">Object.getOwnPropertyDescriptors(obj);
/* &#123;
 *   foo: &#123;
 *        configurable: false,
 *        enumerable: true,
 *        value: &#123;bar: 10&#125;,
 *        writable: false
 *      &#125;
 * &#125;
 */

Object.getOwnPropertyDescriptors(obj.foo);
/* &#123;
 *   bar: &#123;
 *        configurable: true,
 *        enumerable: true,
 *        value: 10,
 *        writable: true
 *      &#125;
 * &#125;
 */
</code></pre>
<p><code>foo</code> 的基础属性已经改变但嵌套的 <code>obj.foo</code> 基础属性并没有变。这意味着嵌套的第二层仍然是可修改的。</p>
<pre><code class="js">obj.foo = &#123; bar: 50 &#125;;
// 没有生效
</code></pre>
<p>Since <code>obj.foo</code> doesn’t let you change its value because it’s frozen, 因为 <code>obj</code> 被冻结了，所以 <code>obj.foo</code> 不允许改变它的值，</p>
<pre><code class="js">obj.foo.bar = 50;
// 生效了
</code></pre>
<p>但 <code>obj.foo.bar</code> 仍然允许你改变它的值，因为它没有被冻结。</p>
<p>那么如何将对象冻结&#x2F;密封到最深层的嵌套对象呢？在 MDN 上可以查看到解决方案</p>
<pre><code class="js">function deepFreeze(object) &#123;

  // 检索在对象上定义的属性名
  var propNames = Object.getOwnPropertyNames(object);

  // 在冻结自己之前先冻结属性

  for (let name of propNames) &#123;
    let value = object[name];

    if(value &amp;&amp; typeof value === &quot;object&quot;) &#123; 
      deepFreeze(value);
    &#125;
  &#125;

  return Object.freeze(object);
&#125;
</code></pre>
<p>测试结果如下。</p>
<pre><code class="js">const obj = &#123; foo: &#123; bar: 10 &#125; &#125;;
deepFreeze(obj);

obj.foo = &#123; bar: 50 &#125;;
// 不会生效

obj.foo.bar = 50;
// 不会生效
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Object.freeze</code> 和 <code>Object.seal</code> 肯定是有用的方法。但是你应该考虑使用 <code>deepFreeze</code> 来冻结嵌套对象。</p>
]]></content>
      <categories>
        <category>技术面试</category>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
