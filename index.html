<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-渲染优化（页面布局与重绘的优化）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/13/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E9%87%8D%E7%BB%98%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%89/"
    >渲染优化（页面布局与重绘的优化）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/13/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E9%87%8D%E7%BB%98%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%89/" class="article-date">
  <time datetime="2023-03-13T03:17:26.000Z" itemprop="datePublished">2023-03-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E9%87%8D%E7%BB%98%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%89/">渲染优化（页面布局与重绘的优化）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="页面布局与重绘的优化"><a href="#页面布局与重绘的优化" class="headerlink" title="页面布局与重绘的优化"></a>页面布局与重绘的优化</h1><blockquote>
<p>页面布局也叫作重排和回流，指的是浏览器对页面元素的几何属性进行计算并将最终结果绘制出来的过程。凡是元素的宽高尺寸、在页面中的位置及隐藏或显示等信息发生改变时，都会触发页面的重新布局。</p>
<p>通常页面布局的作用范围会涉及整个文档，所以这个环节会带来大量的性能开销，我们在开发过程中，应当从代码层面出发，尽量避免页面布局或最小化其处理次数。如果仅修改了DOM元素的样式，而未影响其几何属性时，则浏览器会跳过页面布局的计算环节，直接进入重绘阶段。</p>
<p>虽然重绘的性能开销不及页面布局高，但为了更高的性能体验，也应当降低重绘发生的频率和复杂度。本节接下来便针对这两个环节的性能优化给出一些实用性的建议。</p>
</blockquote>
<h3 id="一、触发页面布局与重绘的操作"><a href="#一、触发页面布局与重绘的操作" class="headerlink" title="一、触发页面布局与重绘的操作"></a>一、触发页面布局与重绘的操作</h3><p>​		要想避免或减少页面布局与重绘的发生，首先就是需要知道有哪些操作能够触发浏览器的页面布局与重绘的操作，然后在开发过程中尽量去避免。</p>
<p>​		这些操作大致可以分为三类:首先就是对DOM元素几何属性的修改，这些属性包括width、height、 padding、 margin、 left、 top 等，某元素的这些属性发生变化时，便会波及与它相关的所有节点元素进行几何属性的重新计算，这会带来巨大的计算量;其次是更改DOM树的结构，浏览器进行页面布局时的计算顺序，可类比树的前序遍历，即从上向下、从左向右。</p>
<p>​		这里对DOM树节点的增、删、移动等操作，只会影响当前节点后的所有节点元素，而不会再次影响前面已经遍历过的元素；最后一类是获取某些特定的属性值操作，比如页面可见区域宽高offsetWidth offsetHeight， 页面视窗中元素与视窗边界的距离offsetTop,offsetLeft,类似的属性值还有scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientWidth、clientHeight及调用window.getComputedStyle方法。</p>
<p>​		这些属性和方法有一个共性，就是需要通过即时计算得到，所以浏览器就需要重新进行页面布局计算。</p>
<h3 id="二、避免对样式的频繁改动"><a href="#二、避免对样式的频繁改动" class="headerlink" title="二、避免对样式的频繁改动"></a>二、避免对样式的频繁改动</h3><p>​		在通常情况下，页面的一帧内容被渲染到屏幕上会按照如下顺序依次进行,首先执行JavaScript代码，然后依次是样式计算、页面布局、绘制与合成。如果在JavaScript运行阶段涉及上述三类操作，浏览器就会强制提前页面布局的执行，为了尽量降低页面布局计算带来的性能损耗，我们应当避免使用JavaScript对样式进行频繁的修改，如果一定要修改样式，则可通过以下几种方式来降低触发重排或回流的频次。</p>
<h4 id="1-使用类名对样式逐条修改"><a href="#1-使用类名对样式逐条修改" class="headerlink" title="1.使用类名对样式逐条修改"></a>1.使用类名对样式逐条修改</h4><p>​		在JavaScript代码中逐行执行对元素样式的修改，是种糟糕的编码方式，对未形成编码规范的前端初学者来说经常会出现这类的问题。错误代码示范如下:</p>
<pre><code class="css">//获取DOM元素逐行修改样式
const div = document .getElementById(&#39;mydiv&#39;);
div.style.height = &#39;100px&#39;;
div.style.width = &#39;100px&#39;;
div.style.border = &#39;2px solid blue&#39;
</code></pre>
<p>​		上述代码对样式逐行修改，每行都会触发一次对渲染树的更改， 于是会导致页面布局重新计算而带来巨大的性能开销。合理的做法是，将多行的样式修改合并到一个类名中，仅在JavaScript脚本中添加或更改类名即可。CSS 类名可预先定义:</p>
<pre><code class="css">.my-div&#123;
    height: 100px;
    border: 2px solid blue;
    width: 100px; 
&#125;
</code></pre>
<p>然后统一在JavaScript中通过给指定元素添加类的方式一次完成，这样便可避免触发多次对页面布局的重新计算:</p>
<pre><code class="css">const div = document.getElementById(&#39;mydiv&#39;);
mydiv.classList.add(&#39;my-div&#39;);
</code></pre>
<h4 id="2-缓存对敏感属性值的计算"><a href="#2-缓存对敏感属性值的计算" class="headerlink" title="2.缓存对敏感属性值的计算"></a>2.缓存对敏感属性值的计算</h4><p>​		有些场景我们想要通过多次计算来获得某个元素在页面中的布局位置，比如:</p>
<pre><code class="js">const list = document.getElementById(&#39;list&#39;);
for (let i =0; i&lt;10; i++) &#123;
list.style.top = &#39;$&#123;list.offsetTop + 10&#125;px&#39;;
list.style.left = &#39;$&#123;list.offsetLeft + 10&#125;px&#39;;
&#125;
</code></pre>
<p>​		这不但在赋值环节会触发页面布局的重新计算，而且取值涉及即时敏感属性的获取，如offsetTop和offsetLeft,也会触发页面布局的重新计算。这样的性能是非常糟糕的，作为优化我们可以将敏感属性通过变量的形式缓存起来，等计算完成后再统一进行赋值触发布局重排。</p>
<pre><code class="js">const list = document.getElementById(&#39;list&#39;);
//将敏感属性缓存起来
let offsetTop = list.offsetTop, offsetLeft = list.offsetLeft;
for(let i=0;i&lt;10;i++)&#123;
offsetTop += 10;
offsetLeft += 10;
&#125;
//计算完成后统一赋值触发重排
list.sty1e.left = offsetLeft;
list.sty1e.top = offsetTop;
</code></pre>
<h4 id="3-使用requestAnimationFrame方法控制渲染帧"><a href="#3-使用requestAnimationFrame方法控制渲染帧" class="headerlink" title="3.使用requestAnimationFrame方法控制渲染帧"></a>3.使用requestAnimationFrame方法控制渲染帧</h4><p>前面讲JavaScript动画时，提到了requestAnimationFrame方法可以控制回调在两个植染帧之间仅触发一次， 如果在其回调函数中一开始就取值 到即时敏感属性，其实获取的是上一帧旧布局的值，并不会触发页面布局的重新计算。</p>
<pre><code class="js">//在帧开始时触发回调
requestAnimationFrame (queryDivHeight);
function queryDivHeight() &#123;
const div = document.getElementById(&#39;div&#39;)
//获取并在命令行中打印出指定div元素的高
console.log (div.offsetHeight)
&#125;
</code></pre>
<p>如果在请求此元素高度之前更改其样式，浏览器就无法直接使用上一帧的旧有属性值，而需要先应用更改的样式，再运行页面布局计算后，才能返回所需的正确高度值。这样多余的开销显然是没有必要的。因此考虑到性能因素，在requestAnimationFrame方法的回调函数中，应始终优先样式的读取，然后再执行相应的写操作:</p>
<pre><code class="js">//requestAnimationFrame方法的回调函数
function queryDivHeight () &#123;
const div = document .getElementById(&#39;div&#39;)
//获取并在命令行中打印出指定div元素的高
console.log (div.offsetHeight)
//样式的写操作应放在读取操作后进行
div.classList.add(&#39;my-div&#39;)
&#125;
</code></pre>
<h3 id="三、通过工具对绘制进行评估"><a href="#三、通过工具对绘制进行评估" class="headerlink" title="三、通过工具对绘制进行评估"></a>三、通过工具对绘制进行评估</h3><p>除了通过经验去绕过一些明显的性能缺陷，使用工具对网站页面性能进行评估和实时分析也是发现问题的有效手段。这里介绍一 些基于Chrome开发者工具的分析方法，来辅助我们发现渲染阶段可能存在的性能问题。</p>
<h4 id="1-监控渲染信息"><a href="#1-监控渲染信息" class="headerlink" title="1.监控渲染信息"></a>1.监控渲染信息</h4><p>打开Chrome的开发者工具，可以在“设置”→“更多工具”中，发现许多很实用的性能辅助小工具，比如监控渲染的Rendering工具，如图所示。</p>
<p><img src="/2023/03/13/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E9%87%8D%E7%BB%98%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%89/image-20230313105005172.png"></p>
<p>​		打开Rendering 的工具面板后，会发现许多功能开关与选择器，下面举例介绍其中若干常用功能项。首先是Paint flashing, 当我们开启该功能后，操作页面发生重新渲染，Chrome会让重绘区域进行一次绿色闪动。</p>
<p>​		这样就可以通过观察闪动区域来判断是否存在多余的绘制开销，比如若仅单击Select组件弹出下拉列表框，却发现整个屏幕区域都发生了闪动，或与此操作组件的无关区域发生了闪动，这都意味着有多余的绘制开销存在，需要进一步研究和优化。</p>
<p>​		Layer borders功能开启后，会在页面上显示出绘制的图层边界。</p>
<p>​		FPS meter功能开启后，会在当前页面的左上角显示实时的帧率情况，GPU 功能是否开启及GPU内存占用情况，如图所示。</p>
<p><img src="/2023/03/13/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E9%87%8D%E7%BB%98%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%89/image-20230313105326423.png"></p>
<h4 id="2-查看图层详情"><a href="#2-查看图层详情" class="headerlink" title="2.查看图层详情"></a>2.查看图层详情</h4><p>​		当我们通过Rendering工具发现存在有多余的图层渲染时，由于闪动是难于捕捉的，所以还需要工具辅助显示出各个图层的详细信息，这便需要用到Layers图层工具，如图所示。</p>
<p><img src="/2023/03/13/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%8E%E9%87%8D%E7%BB%98%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%89/image-20230313110038852.png"></p>
<p>​		如图所示工具界面大体分为三部分，①号矩形框区域为当前页面的图层列表:②号矩形框区域为页面带有图层边框的视图:③号矩形框区域为选中图层的详细信息，包括页面尺寸、内存占用、绘制次数等。</p>
<p>​		通过这些信息能够帮助我们快速定位到所要查看的图层信息。当我们使用Rendering工具监控页面交互过程中有不恰当的图层存在时，便可使用Layers 工具进行问题复现:首先打开目标页面，然后从左 侧图层列表中依次查找出问题图层，接着分析引起该图层发生重绘的原因。</p>
<h3 id="四、降低绘制复杂度"><a href="#四、降低绘制复杂度" class="headerlink" title="四、降低绘制复杂度"></a>四、降低绘制复杂度</h3><p>​		如前所述，绘制是在页面布局确定后，将元素的可视内容绘制到屏幕上的过程。虽然不同的CSS绘制样式看不出性能上明显的不同，但并非所有属性都有同样的性能开销。例如，绘制带有阴影效果的元素内容，就会比仅绘制单色边框所耗费的时间要长，因为涉及模糊就意味着更高的复杂度。CSS属性如下:</p>
<pre><code class="css">// 绘制时间相对较短的边枢颜色
border-color: red;
//绘制时间更长的阴影内容
box-shadow: 0, 8px, rgba(255,0,0,0.5);
</code></pre>
<p>​		当我们使用之前介绍过的渲染性能分析工具，发现了有明显性能瓶颈需要优化时，需要确认是否存在高复杂度的绘制内容，可以使用其他实现方式来替换以降低绘制的复杂度。比如位图的阴影效果，可以考虑使用Photoshop 等图像处理工具直接为图片本身添加阴影效果，而非全交给CSS样式去处理。</p>
<p>​		除此之外，还要注意对绘制区域的控制，对不需要重新绘制的区域应尽量避免重绘。例如，页面的顶部有一个固定区域的header标头，若它与页面其他位置的某个区域位于同一图层，当后者发生重绘时，就有可能触发包括固定标头区域在内的整个页面的重绘。对于固定不变不期望发生重绘的区域，建议可将其提升为独立的绘图层，避免被其他区域的重绘连带着触发重绘。</p>
<h3 id="五、合成处理"><a href="#五、合成处理" class="headerlink" title="五、合成处理"></a>五、合成处理</h3><p>​		合成处理是将已绘制的不同图层放在一起， 最终在屏幕上渲染出来的过程。在这个环节中，有两个因素可能会影响页面性能:一个是所需合成的图层数量，另一个是实现动画的相关属性。</p>
<h4 id="1-新增图层"><a href="#1-新增图层" class="headerlink" title="1.新增图层"></a>1.新增图层</h4><p>在降低绘制复杂度小节中讲到，可通过将固定区域和动画区域拆分到不同图层上进行绘制，来达到绘制区域最小化的目的。接下来我们就来探讨如何创建新的图层，最佳方式便是使用CSS属性will-change来创建:</p>
<pre><code class="css">.new-layer&#123;
 will-change: transform; 
&#125;
</code></pre>
<p>该方法在Chrome、Firefox 及Opera上均有效，而对于Safari等不支持will-change属性的浏览器，则可以使用3D变换来强制创建:</p>
<pre><code class="css">.new-layer&#123;
 transform: translate(0); 
&#125;
</code></pre>
<p>​		虽然创建新的图层能够在定程度 上减少绘制区域，但也应 当注意不能创建太多的图层，因为每个图层都需要浏览器为其分配内存及管理开销。如果已经将个一元素提升到所创建的新图层上，也最好使用Chrome开发者工具中的Layers对图层详情进行评估，确定是否真的带来了性能提升，切忌在未经分析评估前就盲目地进行图层创建。</p>
<h4 id="2-仅与合成相关的动画属性"><a href="#2-仅与合成相关的动画属性" class="headerlink" title="2.仅与合成相关的动画属性"></a>2.仅与合成相关的动画属性</h4><p>在了解了谊染过程各部分的功能和作用后，我们知道如果个动画的实现不经过页面布局和重绘环节，仅在合成处理阶段就能完成，则将会节省大量的性能开销。目前能够符合这一要求的动画属性只有两个:透明度opacity 和图层变换transform. 它们所能实现的动画效果如表所示，其中用n来表示数字。</p>
<table>
<thead>
<tr>
<th align="center">动画效果</th>
<th align="center">实现方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">位移</td>
<td align="center">transform:translate(npx,npx);</td>
</tr>
<tr>
<td align="center">缩放</td>
<td align="center">transform:scale(n);</td>
</tr>
<tr>
<td align="center">旋转</td>
<td align="center">transform:rotate(ndeg)</td>
</tr>
<tr>
<td align="center">倾斜</td>
<td align="center">transform:skew(X|Y)(ndeg);</td>
</tr>
<tr>
<td align="center">矩阵变换</td>
<td align="center">transform:matrix(3d)(&#x2F;<em>矩阵变换</em>&#x2F;)</td>
</tr>
<tr>
<td align="center">透明度</td>
<td align="center">opacity:0…1</td>
</tr>
</tbody></table>
<p>​		在使用opacity和transform实现相应的动画效果时，需要注意动画元素应当位于独立的绘图层上，以避免影响其他绘制区域。这就需要将动画元素提升至一个新的绘图层。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/" rel="tag">渲染优化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-渲染优化（计算样式优化）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/09/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E8%AE%A1%E7%AE%97%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%8C%96%EF%BC%89/"
    >渲染优化（计算样式优化）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/09/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E8%AE%A1%E7%AE%97%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%8C%96%EF%BC%89/" class="article-date">
  <time datetime="2023-03-09T01:41:38.000Z" itemprop="datePublished">2023-03-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E8%AE%A1%E7%AE%97%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%8C%96%EF%BC%89/">渲染优化（计算样式优化）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="计算样式优化"><a href="#计算样式优化" class="headerlink" title="计算样式优化"></a>计算样式优化</h1><blockquote>
<p>在JavaScript处理过后，若发生了添加和删除元素，对样式属性和类进行了修改，就都会导致浏览器重新计算所涉及元素的样式，某些修改还可能会引起页面布局的更改和浏览器的重新绘制，本节就着眼于样式相关的优化点，来看看如何提升前端渲染性能。</p>
</blockquote>
<h3 id="一、减少要计算样式的元素数量"><a href="#一、减少要计算样式的元素数量" class="headerlink" title="一、减少要计算样式的元素数量"></a>一、减少要计算样式的元素数量</h3><p>​		首先我们需要知道与计算样式相关的一条重要机制: CSS 引擎在查找样式表时，对每条规则的匹配顺序是从右向左的，这与我们通常从左向右的书写习惯相反。举个例子，如下CSS规则:</p>
<pre><code class="css">.product-list li &#123;&#125;
</code></pre>
<p>​		如果不知道样式规则查找顺序，则推测这个选择器规则应该不会太费力，首先类选择器product-list的数量有限应该很快就能查找到，然后缩小范围再查找其下的 li 标签就顺理成章。</p>
<p>​		但CSS选择器的匹配规则实际上是从右向左的，这样再回看上面的规则匹配，其实开销相当高，因为CSS引擎需要首先遍历页面上的所有 li 标签元素，然后确认每个 li 标签有包含类名为product-list的父元素才是目标元素，所以为了提高页面的渲染性能，计算样式阶段应当尽量减少参与样式计算的元素数量，这里总结了如下几点实战建议:</p>
<p>​		使用类选择器替代标签选择器，对于上面 li 标签的错误示范，如果想对类名为product-list下的 li 标签添加样式规则，可直接为相应的 li 标签定义名为product-list_li的类选择器规则，这样做的好处是在计算样式时，减少了从整个页面中查找标签元素的范围，毕竟在CSS选择器中，标签选择器的区分度是最低的。</p>
<p>​		避免使用通配符做选择器，对于刚入门前端的小伙伴，通常在编写CsS样式之前都会有使用通配符去清楚默认样式的习惯，如下所示:</p>
<pre><code class="css">* &#123;
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
&#125;
</code></pre>
<p>​		这种操作在标签规模较小的demo项目中，几乎看不出有任何性能差异。但对实际的工程项目来说，使用通配符就意味着在计算样式时，浏览器需要去遍历页面中的每一个元素，这样的性能开销很大，应当避免使用。</p>
<h3 id="二、降低选择器的复杂性"><a href="#二、降低选择器的复杂性" class="headerlink" title="二、降低选择器的复杂性"></a>二、降低选择器的复杂性</h3><p>​		随着项目不断迭代，复杂性会越来越高，或许刚开始仅有一个名为content的类选择元素，但慢慢地单个元素可能会并列出列表，列表又会包裹在某个容容元素下，甚至该列表中的部分元素的样式又写其他兄弟元素有所差异，这样原本的个类选择器就会被扩展成如下形式:</p>
<pre><code class="css">.container:nth-child(-n+1) .content&#123;/*样式属性*/&#125;
</code></pre>
<p>​		浏览器在计算上述样式时，首先就需要查询有哪些应用了content 类的元素，并且其父元素怡好带有container类的倒数第n+1个元素，这个计算过程可能就会花费许多时间，如果仅对确定的元素使用单一的类名选择器，那么浏览器的计算开销就会大幅度降低。</p>
<p>​		比如使用名为final-container-content 的类选择替代上述的复杂样式计算，直接漆加到目标元素上。而且复杂的匹配规则，可能也会存在考虑不周从而导致画蛇添足的情况，例如，通过id选择器已经可以唯一确定 目标元素了，就无须再附加其他多余的选择器:</p>
<pre><code class="css">/*错误示范*/
.content #my-content
/*正确方式*/
#my-content
</code></pre>
<p>​		由于id选择器本身就是唯一存在的， 定位到目标元素数后再去查找名为content的类选择器元素就多此一举。当然在实际项目中的情况会复杂得多，但若能做故到尽量降低选择器的复杂性，则类似的问题也会容易避免。</p>
<h3 id="三、使用BEM规范"><a href="#三、使用BEM规范" class="headerlink" title="三、使用BEM规范"></a>三、使用BEM规范</h3><p>​		BEM是一种CSS的书写规范，它的名称是由三个单词的首字母组成的，分别是块(Block)、元素(Element)和修饰符(Modifier)。理论上它希望每行CSS代码只有一个选择器，这就是为了降低选择器的复杂性，对对选择器的命名要求通过以下三个符号的组合来实现。</p>
<ul>
<li>中画线( - ): 仅作为连字符使用，表示某个块或子元素的多个单词之间的连接行。</li>
<li>单下画线( _ ):作为描述一个块或其子元素的种状态。</li>
<li>双下画线( _ _ );作为连接块与块的子元素。</li>
</ul>
<p>接下来首先给出一个基于BEM的选择器命名形式，然后再分别看块、元素与修饰符的含义和使用示例:</p>
<pre><code class="css">/* BEM命名示例*/
type-block__element_modifier
</code></pre>
<h4 id="1-块"><a href="#1-块" class="headerlink" title="1.块"></a>1.块</h4><p>通常来说，凡是独立的页面元素，无论简单或是复杂都可以被视作一个块，在HTML文档中会用一个唯一的类名来表示这个块。具体的命名规则包括三个:只能使用类选择器，而不使用ID选择器;每个块应定义一个前缀用来表示命名空间;每条样式规则必须属于一个块。比如一个自定义列表就可视作为一个块， 其类名匹配规则可写为:</p>
<pre><code class="css">.mylist&#123;&#125;
</code></pre>
<h4 id="2-元素"><a href="#2-元素" class="headerlink" title="2.元素"></a>2.元素</h4><p>元素即指块中的子元素，且子元素也被视作块的直接子元素，其类名需要使用块的名称作为前缀。以上面自定义列表中的子元素类名写法为例，与常规写法对比如下:</p>
<pre><code class="css">//常规写法
.mylist &#123;&#125;
.mylist .item &#123;&#125;
//BEM写法
.mylist &#123;&#125;
.mylist__item &#123;&#125;
</code></pre>
<h4 id="3-修饰符"><a href="#3-修饰符" class="headerlink" title="3.修饰符"></a>3.修饰符</h4><p>修饰符可以看作是块或元素的某个特定状态，以按钮为例，它可能包含大、中、小三种默认尺寸及自定义尺寸，对此可使用small、normal、 big 或size-N来修饰具体按钮的选择器类名，示例如下:</p>
<pre><code class="css">//自定又列表下子元素大、中、小三种尺寸的类选择器
.mylist__item_big &#123;&#125;
.mylist__item_normal &#123;&#125;
.mylist__item_small &#123;&#125;
//带自定义尺寸修饰符的类选择器
.mylist__item_size-10
</code></pre>
<p>​		BEM样式编码规范建议所有元素都被单一的类选择器修饰，从CSS代码结构角度来说这样不但更加清晰，而且由于样式查找得到了简化，谊染阶段的样式计算性能也会得到提升。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/" rel="tag">渲染优化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-渲染优化（JavaScript执行优化）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/05/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88JavaScript%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%89/"
    >渲染优化（JavaScript执行优化）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/05/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88JavaScript%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%89/" class="article-date">
  <time datetime="2023-03-05T04:04:51.000Z" itemprop="datePublished">2023-03-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88JavaScript%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%89/">渲染优化（JavaScript执行优化）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="JavaScript-执行优化"><a href="#JavaScript-执行优化" class="headerlink" title="JavaScript 执行优化"></a>JavaScript 执行优化</h1><blockquote>
<p>本节侧重优化JavaScript 的执行来改善用户在渲染方面的性能体验。</p>
</blockquote>
<h3 id="一、实现动画效果"><a href="#一、实现动画效果" class="headerlink" title="一、实现动画效果"></a>一、实现动画效果</h3><p>​		前端实现动画效果的方法有很多，比如在CSS中可以通过transition和animation来实现，在HTML中可以通过canvas 来实现，而利用JavaScript 通常最容易想到的方式是利用定时器seTimeout或setInterval来实现，即通过设置个间隔时间来不断地改变目标图像的位置来达到视觉变化的效果。</p>
<p>​		实践经验告诉我们，使用定时器实现的动画会在一些低端 机器上出现抖动或者卡顿的现象，这主要是因为浏览器无法确定定时器的回调函数的执行时机。以setInterval为例，其创建后回调任务会被放入异步队列，只有当主线程上的任务执行完成后，浏览器才会去检查队列中是否有等待需要执行的任务，如果有就从任务队列中取出执行，这样会使任务的实际执行时机比所设定的延迟时间要晚一些。</p>
<p>其改屏幕分辨率和尺寸也会影响刷新频率，不同设备的屏幕绘制频率可能会有所不同，而setInterval只能设置某个固定的时间间隔，这个间隔时间不一定与所有屏幕的刷新时间同步，那么导致动画出现随机丢帧也在所难免，如图所示。</p>
<p><img src="/2023/03/05/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88JavaScript%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%89/image-20230305105053986.png" alt="定时器触发阻塞渲染帧"></p>
<p>​		为了避免这种动画实现方案中因丢帧而造成的卡顿现象，我们推荐使用window中的requestAnimationFrame方法。与setInterval方法相比，其最大的优势是将回调函数的执行时机交由系统来决定，即如果屏幕刷新频率是60Hz,则它的回调函数大约会每16.7ms执行一次， 如果屏幕的刷新频率是75Hz,则它回调函数大约会每13.3ms执行一次，就是说requestAnimationFrame方法的执行时机会与系统的刷新频率同步。这样就能保证回调函数在屏幕的每次刷新间隔中只被执行一次，从而避免因随机丢帧而造成的卡顿现象。</p>
<p>​		其使用方法也十分简单，仅接受一个回调函数作为入参，即下次重绘之前更新动画帧所调用的函数。返回值为一个long型整数，作为回调任务队列中的唯标识， 可将该值传给window.cancelAnimationFrame来取消回调，以某个目标元素的平移动画为例:</p>
<pre><code class="js">let start;
//定义目标动画元素
const element = document.getElementById(&#39;MyAnimate&#39;);
element.style.position = &#39;absolute&#39;
//定义动画回调函数
function updatedScreen(timestamp) &#123;
    if(!start) start = timestamp;
    //根据时间戳计算每次动画位移
    const progress = timestamp - start;
    element.style.left = `$&#123;Math.min(progress / 10,200)&#125;px`
    if(progress &lt; 2000) window.requestAnimationFrame(updatedScreen)
&#125;
//启动动画回调函数
window.requestAnimationFrame(updatedScreen)
</code></pre>
<p>​		除了通过让回调函数的触发时机与系统刷新频率同步来消除动画的丢帧卡顿，requestAnimationFrame方法还能通过节流不必要的函数执行，来帮助CPU的节能。</p>
<p>​		具体而言，对于CPU节能方面，考虑当浏览器页面最小化或者被隐藏起来时，动画对用户来说是不可见的，那么刷新动画所带来的页面渲染就是对CPU资源的浪费，完全没有意义。</p>
<p>​		当创建setInterval定时器后，除非显式地调用clearInterval去销毁该定时器，不然在后台的动画任务会被不断执行，而requestAnimationFrame方法则完全不同，当页面未被激活时，屏幕刷新任务会被系统暂停，只有当页面被激活时，动画任务才会被激活并从上次暂停的地方继续执行，所以能有效地节省CPU开销。</p>
<p>​		在页面的一些高频事件中，比如页面滚动的scroll、页面尺寸更改的resize,需要防止在一个刷新时间间隔内发生多次函数执行，也就是所谓的函数节流。对60Hz的显示器来说，差不多每16.7ms 刷新一次， 多次绘制并不会在屏幕上体现出来，所以requestAnimationFrame方法仅在每个刷新周期中执行一次函数调用， 既能保证动画的流畅性又能很好地节省函数执行的冗余开销 。</p>
<h3 id="二、恰当使用Web-Worker"><a href="#二、恰当使用Web-Worker" class="headerlink" title="二、恰当使用Web Worker"></a>二、恰当使用Web Worker</h3><p>​		众所周知JavaScript 是单线程执行的，所有任务放在一个线程上执行，只有当前一个任务执行完才能处理后 一个任务，不然后面的任务只能等待，这就限制了多核计算机充分发挥它的计算能力。同时在浏览器上, JavaScript 的执行通常位于主线程，这恰好与样式计算、页面布局及绘制一起，如果JavaScript运行时间过长，必然就会导致其他工作任务的阻塞而造成丢帧。</p>
<p>​		为此可将一些纯计算 的工作迁移到Web Worker上处理，它为JavaScript的执行提供了多线程环境，主线程通过创建出Worker子线程，可以分担一部分 自己的任务执行压力。在Worker子线程上执行的任务不会干扰主线程，待其上的任务执行完成后，会把结果返回给主线程，这样的好处是让主线程可以更专注地处理UI交互保证页面的使用体验流程。需要注意的是，Worker 子线程一旦创建成功就会始终执行，不会被主线程上的事件所打断，这就意味着Worker会比较耗费资源，所以不应当过度使用，一旦任务执行完毕就应及时关闭。 除此之外，在使用中还有以下几点应当注意。</p>
<ul>
<li>DOM限制: Worker 无法读取主线程所处理网页的DOM对象，也就无法使用document、window和parent等对象，只能访问navigator和location对象。</li>
<li>文件读取限制: Worker 子线程无法访问本地文件系统，这就要求所加载的脚本来自网络。</li>
<li>通信限制:主线程和Worker子线程不在同一个上下文内，所以它们无法直接进行通信，只能通过消息来完成。</li>
<li>脚本执行限制:虽然Worker可以通过XMLHTTPRequest对象发起ajax请求，但不能使用alert()方法和confirm()方法在页面弹出提示。</li>
<li>同源限制: Worker子线程执行的代码文件需要与主线程的代码文件同源。</li>
</ul>
<p>​		Web Worker的使用方法非常简单，在主线程中通过new Worker()万方法来创建一个Worker子线程，构造函数的入参是子线程执行的脚本路径，由于代码文件必须来自网络，所以如果代码文件没能下载成功，Worker 就会失败。代码示例如下:</p>
<pre><code class="js">//创建子线程
const worker = new Worker(&#39;demo_worker.js&#39;);
//主线程向子线程发送消息
const dataToWorker = &#123;/* 要传给子线程的数据 */&#125;;
worker.postMessage(dataToWorker);
//接下来主线程就可以继续其他工作，只需通过监听子线程返回的消息再进行相应处理
worker.addEventListener(&#39;message&#39;,(event) =&gt; &#123;
    //子线程处理后的数据
    const workerData = event.data;
    //数据更新到屏幕上
&#125;)
</code></pre>
<p>​		在子线程处理完相关任务后，需要及时关闭Worker子线程以节省系统资源，关闭的方式有两种:在主线程中通过调用worker.terminate()方法来关闭; 在子线程中通过调用自身全局对象中的self.close()方法来关闭。</p>
<p>​		考虑到上述关于Web Worker使用中的限制，并非所有任务都适合采用这种方式来提升性能。如果所要处理的任务必须要放在主线程上完成，则应当考虑将一个大型任务拆分为多个微任务，每个微任务处理的耗时最好在几毫秒之内，能在每帧的requestAnimationFrame更新方法中处理完成，代码示例如下:</p>
<pre><code class="js">//将一个大型任务拆成分为多个微任务
const taskList = splitTask(BigTask);
//微任务处理逻辑，入参为每次任务的起始戳
function processTaskList(taskStartTime)&#123;
    let taskFinishTime;
    do &#123;
        //从任务堆栈中推出下一个任务
        const nextTask = taskList.pop();
        //处理下一个任务
        processTask(nextTask);
        //获取任务执行完成的时间，如果时间够 3ms 就继续执行
        taskFinishTime = window.performance.now();
    &#125; while(taskFinishTime - taskStartTime &lt; 3);
    //如果任务堆栈不为空则继续
    if(taskList.length &gt; 0)&#123;
        requestAnimationFrame(processTaskList);
    &#125;
&#125;
requestAnimationFrame(processTaskList);
</code></pre>
<h3 id="三、事件节流和事件防抖"><a href="#三、事件节流和事件防抖" class="headerlink" title="三、事件节流和事件防抖"></a>三、事件节流和事件防抖</h3><p>​		本章所介绍的动画触发方式就用到了事件节流的思想，即当用户在与Web应用发生交互的过程中，势必有一些操作会 被频繁触发，如滚动页面触发的scroll事件，页面缩放触发的resize事件，鼠标涉及的mousemove、mouscover等事件，以及键盘涉及的keyup、keydown 等事件。</p>
<p>​		频繁地触发这些事件会 导致相应回调函数的大量计算，进而引发页面抖动甚至卡顿，为了控制相关事件的触发频率，就有了接下来要介绍的事件节流与事件防抖操作。所谓事件节流，简单来说就是在某段时间内，无论触发多少次回调，在计时结束后都只响应第一次的触发。 以scroll事件为例，当用户滚动页面触发了一次scroll 事件后，就为这个触发操作开启一个固定时间的计时器。在这个计时器持续时间内，限制后续发生的所有scroll 事件对回调函数的触发，当计时器计时结束后，响应执行第一次触发scroll 事件的回调函数。代码示例如下:</p>
<pre><code class="js">/**
* 事件节流回调函数
* @params: time事件节流时间间隔
* @params: callback事件回调函数
**/
function throttle(time,callback)&#123;
    //上次触发回调的时间
    let last = 0;
    //事件节流操作的闭包返回
    return (params) =&gt; &#123;
        //记录本次回调触发的时间
        let now = Number(new Date())
        //判断事件触发事件是否超出节流时间间隔
        if(now - last &gt;= time)&#123;
            //如果超出节流时间间隔，则触发响应回调函数
            callback(params)
        &#125;
    &#125;
&#125;
//通过事件节流优化的事件回调函数
const throttle_scroll = throttle(1000,() =&gt; console.log(&#39;页面滚动&#39;));
//绑定事件
document.addEventListener(&#39;scroll&#39;,throttle_scroll);
</code></pre>
<p>​		事件防抖的实现方式与事件节流类似，只是所响应的触发事件是最后一次事件。具体来说，首先设定一个事件防抖的时间间隔， 当事件触发开始后启动计时器，若在定时器结束计时之前又有相同的事件被触发，则更新计时器但不响应回调函数的执行，只有当计时器完整计时结束后，才去响应执行最后一次事件触发的回调函数。 代码示例如下：</p>
<pre><code class="js">/**
* 事件防抖回调函数
* @params: time事件防抖时间延迟
* @params: callback事件回调函数
**/
function debounce(time,callback)&#123;
    //设置定时器
    let timer = null;
    //事件防抖操作的闭包返回
    return (params) =&gt; &#123;
        //每当事件被触发时，清除旧定时器
        if(timer) clearTimeout(timer);
        //设置新的定时器
        timer = setTimeout(() =&gt; callback(params),time);
    &#125;
&#125;
//通过事件防抖优化事件回调函数
const debounce_scroll = debounce(1000,() =&gt; console.log(&#39;页面滚动&#39;));
//绑定事件
document.addEventListener(&#39;scroll&#39;,debounce_scroll);
</code></pre>
<p>​		虽然通过上述事件防抖操作，可以有效地避免在规定的时间间隔内频繁地触发事件回调函数，但是由于防抖机制颇具“耐心”，如果用户操作过于频繁，每次在防抖定时器计时结束之前就进行了下一次操作，那么同一事件所要触发的回调函数将会被无限延迟。频繁延迟会让用户操作迟迟得不到响应，同样也会造成页面卡顿的使用体验，这样的优化就属于弄巧成拙。</p>
<p>​		因此我们需要为事件防抖设置一条 延迟等待的时间底线，即在延迟时间内可以重新生成定时器，但只要延迟时间到了就必须对用户之前的操作做出响应。这样便可结合事件节流的思想提供一个升级版的实现方式，代码示例如下:</p>
<pre><code class="js">function throttle_pro(time,callback)&#123;
    let last = 0,timer = null;
    return (params) =&gt; &#123;
        //记录本次回调触发的时间
        let now = Number(new Date());
        //判断事件触发事件是否超出节流时间间隔
        if(now - last &lt; time)&#123;
            //若在设置的延迟时间间隔内，则重新设置防抖定时器
            clearTimeout(timer);
            timer = setTimeout(() =&gt; &#123;
                last = now;
                callback(params);
            &#125;,time)
        &#125;else&#123;
            //若超出延迟时间，则直接响应用户操作，不用等待
            last  = now;
            callback(params);
        &#125;
    &#125;
&#125;
//结合节流和防抖优化后的事件回调函数
const scroll_pro = throttle_pro(1000,() =&gt; console.log(&#39;页面滚动&#39;));
//绑定事件
document.addEventListener(&#39;scroll&#39;,scroll_pro);
</code></pre>
<p>​		事件节流与事件防抖的实质都是以闭包的形式包裹回调函数的，通过自由变量缓存计时器信息，最后用setTimeout控制事件触发的频率来实现。通过在项目中恰当地运用节流与防抖机制，能够带来投入产出比很高的性能提升。</p>
<h3 id="四、恰当的JavaScript优化"><a href="#四、恰当的JavaScript优化" class="headerlink" title="四、恰当的JavaScript优化"></a>四、恰当的JavaScript优化</h3><p>​		通过优化执行JavaScript能够带来的性能优化，除上述几点之外，通常是有限的。很少能优化出一个函数的执行时间比之前的版本快几百倍的情况，除非是原有代码中存在明显的BUG.即使像计算当前无素的offsetTop值会比执行getBoundingClientRect()方法要快，但每帧对该属性或方 法的调用次数也非常有限。</p>
<p>​		若花费大量精力进行这类微优化，可能只会带来零点几毫秒的性能提升，当然如果基于游戏或大量计算的前端应用，则另当别论。所以对于渲染层面的JavaScript优化，我们首先应当定位出导致性能问题的瓶颈点，然后有针对性地去优化具体的执行函数，而避免投入产出比过低的微优化。</p>
<p>那么如何进行JavaScript 脚本执行过程中的性能定位呢?这里推荐使用Chrome浏览器开发者工具中的Performance页签，使用它可让我们逐帧评估JavaScript代码的运行开销，可通过Settings&gt;更多工具&gt;开发者工具&gt;Performance 打开其工具界面，如图所示。</p>
<p>​		在工具的顶部有控制JavaScript 采样的分析器复选框Disable JavaScriptsamples,由于这种分析方式会产生许多开销，建议仅在发现有较长时间运行的JavaScript脚本时，以及需要深入了解其运行特性时才去使用。除此之外，在可开发者工具的Setting &gt; More tools中单独调出JavaScript 分析器针对每个方法的运行时间及嵌套调用关系进行分析，并可将分析结果导出为.cpuprofile文件保存分享，工具界面如图所示。</p>
<p><img src="/2023/03/05/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88JavaScript%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%89/image-20230305120212053.png"></p>
<p><img src="/2023/03/05/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88JavaScript%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%89/image-20230305120336924.png"></p>
<p>​		该功能将帮助我们获得更多有关JavaScript 调用执行的相关信息，据此可进一步评估出JavaScript 对应用性能的具体影响，并找出哪些函数的运行时间过长。然后使用优化手段进行精准优化。比如尽量移除或拆分长时间运行的JavaScript 脚本，如果无法拆分或移除，则尝试将其迁移到Web Worker中进行处理，让浏览器的主线程继续执行其他任务。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/" rel="tag">渲染优化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-渲染优化（页面渲染性能）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/01/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%EF%BC%89/"
    >渲染优化（页面渲染性能）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/01/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%EF%BC%89/" class="article-date">
  <time datetime="2023-03-01T02:31:12.000Z" itemprop="datePublished">2023-03-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%EF%BC%89/">渲染优化（页面渲染性能）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="页面渲染性能"><a href="#页面渲染性能" class="headerlink" title="页面渲染性能"></a>页面渲染性能</h1><blockquote>
<p>​		如果把浏览器呈现页面的整个过程一分为二，前面所讨论的诸如图像资源优化、加载优化，以及构建中如何压缩资源大小等，都可视为浏览器为呈现页面请求所需资源的部分:本篇将主要关注浏览器获取到资源后，进行渲染部分的相关优化内容。在前面前端页面的生命周期中，介绍过关键渲染路径的概念，浏览器通过这个过程对HTML、CSS、JavaScript 等资源文件进行解析，然后组织渲染出最终的页面。本篇将以此为基础，对渲染过程进行更深入的讨论，不仅包括打开一个网站的首次渲染，还有用户与页面进行交互后导致页面更改的渲染，即所谓的重绘与重排。其中除了对渲染过程的充分介绍，更重要的是对提升渲染过程性能的优化手段的探讨。</p>
<p>​		本节我们需要明白，页面渲染阶段对性能体验的影响与资源加载阶段同样重要，而对于涉及高交互频次的应用来说可能更加重要。为了方便后文对渲染优化进行深入分析，本节稍后会将整个渲染过程划分为五个串行阶段进行概述。其实优化渲染的实质，就是尽量压缩每个阶段的执行时间或跳过某些阶段的执行。</p>
</blockquote>
<h3 id="一、流畅的使用体验"><a href="#一、流畅的使用体验" class="headerlink" title="一、流畅的使用体验"></a>一、流畅的使用体验</h3><p>​		随着网站承载的业务种类越来越多，业务复杂性越来越高，用户的使用要求也跟着升高。不但网站页面要快速加载出来，而且运行过程也应更顺畅，在响应用户操作时也要更加及时，比如我们通常使用手机浏览网上商城时，指尖滑动屏幕与页面滚动应很流畅，拒绝卡顿。那么要达到怎样的性能指标，才能满足用户流畅的使用体验呢?</p>
<p>​		目前大部分设备的屏幕分辨率都在60fps左右，也就是每秒屏幕会刷新60次，所以要满足用户的体验期望，就需要浏览器在渲染页面动画或响应用户操作时，每一帧的生成速率尽量接近屏幕的刷新率。若按照60fps来算，则留给每一帧画面的时间不到17ms再除去浏览器对资源的一些整理工作，帧画面的渲染应尽 量在10ms内完成，如果达不到要求而导致帧率下降，则屏幕上的内容会发生抖动或卡顿。</p>
<h3 id="二、渲染过程"><a href="#二、渲染过程" class="headerlink" title="二、渲染过程"></a>二、渲染过程</h3><p>​		为了使每一帧页面渲染的开销都能在期望的时间范围内完成，就需要开发者了解谊染过程的每个阶段，以及各阶段中有哪些优化空间是我们力所能及的。经过分析根据开发者对优化渲染过程的控制力度，可以大体将其划分为五个部分: JavaScript 处里计算样式、页面布局、绘制与合成，下面先简要介绍各部分的功能与作用。</p>
<ul>
<li>JavaScript处理:	前端项目中经常会需要响应用户操作，通过JavaScript对数据集进行计算、操作DOM元素，并展示动画等视觉效果。当然对于动画的实现，除了JavaScript,也可以考虑使用如CSS Animations、Transitions 等技术。</li>
<li>计算样式:    在解析CSS文件后，浏览器需要根据各种选择器去匹配所要应用CSS规则的元素节点，然后计算出每个元素的最终样式。</li>
<li>页面布局:   指的是浏览器在计算完成样式后，会对每个元素尺寸大小和屏幕位置进行计算。由于每个元素都可能会受到其他元素的影响，并且位于DOM树形结构中的子节点元素，总会受到父级元素修改的影响，所以页面布局的计算会经常发生。</li>
<li>绘制:   在页面布局确定后，接下来便可以绘制元素的可视内容，包括颜色、边框、阴影及文本和图像。</li>
<li>合成:   通常由于页面中的不同部分可能被绘制在多个图层上，所以在绘制完成后需要将多个图层按照正确的顺序在屏幕上合成，以便最终正确地渲染出来，如图所示。</li>
</ul>
<p><img src="/2023/03/01/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%EF%BC%89/image-20230301101322559.png" alt="渲染过程"></p>
<p>​		这个过程中的每一阶段都有可能产生卡顿，本章后续章节将会对各阶段所涉及的性能优化进行详细介绍。这里值得说明的是，并非对于每一帧画面都会经历这五个部分。比如仅修改与绘制相关的属性(文字颜色、背景图片或边缘阴影等)，而未对页面布局产生任何修改，那么在计算样式阶段完成后，便会跳过页面布局直接执行绘制。如果所更改的属性既不影响页面布局又不需要重新绘制，便可直接跳到合成阶段执行。具体修改哪些属性会触发页面布局、绘制或合成阶段的执行，这与浏览器的内核类型存在一定关系， 如表所示列出了一些常见属性分别在Blink.Gecko和Webkit等不同内核的浏览器上的表现。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">Blink</th>
<th align="center">Gecko</th>
<th align="center">Webkit</th>
</tr>
</thead>
<tbody><tr>
<td align="center">z-index</td>
<td align="center">绘制&#x2F;合成</td>
<td align="center">绘制&#x2F;合成</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
</tr>
<tr>
<td align="center">transform</td>
<td align="center">合成</td>
<td align="center">合成</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
</tr>
<tr>
<td align="center">opacity</td>
<td align="center">绘制&#x2F;合成</td>
<td align="center">合成</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
</tr>
<tr>
<td align="center">min-width</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
<td align="center">布局&#x2F;合成</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
</tr>
<tr>
<td align="center">color</td>
<td align="center">布局&#x2F;绘制</td>
<td align="center">布局&#x2F;绘制</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
</tr>
<tr>
<td align="center">background</td>
<td align="center">布局&#x2F;绘制</td>
<td align="center">布局&#x2F;绘制</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
</tr>
<tr>
<td align="center">border-radius</td>
<td align="center">布局&#x2F;绘制</td>
<td align="center">布局&#x2F;绘制</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
</tr>
<tr>
<td align="center">border-style</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
</tr>
<tr>
<td align="center">border-width</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
<td align="center">布局&#x2F;绘制&#x2F;合成</td>
</tr>
</tbody></table>
<p>Google的Chrome实验室在网站上列出了更多有关CSS属性的详细表现，如有需要可自行去查看。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/" rel="tag">渲染优化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全之vue权限控制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E4%B9%8Bvue%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"
    >前端面试大全之vue权限控制</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/02/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E4%B9%8Bvue%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" class="article-date">
  <time datetime="2023-02-27T05:10:53.000Z" itemprop="datePublished">2023-02-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/vue%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">vue权限控制</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源</p>
<p>而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发</p>
<ul>
<li>页面加载触发</li>
<li>页面上的按钮点击触发</li>
</ul>
<p>总的来说，所有的请求发起都触发自前端路由或视图</p>
<p>所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：</p>
<ul>
<li>路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 <code>4xx</code> 提示页</li>
<li>视图方面，用户只能看到自己有权浏览的内容和有权操作的控件</li>
<li>最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截</li>
</ul>
<h2 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h2><p>前端权限控制可以分为四个方面：</p>
<ul>
<li>接口权限</li>
<li>按钮权限</li>
<li>菜单权限</li>
<li>路由权限</li>
</ul>
<h3 id="接口权限"><a href="#接口权限" class="headerlink" title="接口权限"></a>接口权限</h3><p>接口权限目前一般采用<code>jwt</code>的形式来验证，没有通过的话一般返回<code>401</code>，跳转到登录页面重新进行登录</p>
<p>登录完拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，每次请求的时候头部携带<code>token</code></p>
<pre><code class="js">axios.interceptors.request.use(config =&gt; &#123;
    config.headers[&#39;token&#39;] = cookie.get(&#39;token&#39;)
    return config
&#125;)
axios.interceptors.response.use(res=&gt;&#123;&#125;,&#123;response&#125;=&gt;&#123;
    if (response.data.code === 40099 || response.data.code === 40098) &#123; //token过期或者错误
        router.push(&#39;/login&#39;)
    &#125;
&#125;)
</code></pre>
<h3 id="路由权限控制"><a href="#路由权限控制" class="headerlink" title="路由权限控制"></a>路由权限控制</h3><p><strong>方案一</strong></p>
<p>初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验</p>
<pre><code class="js">const routerMap = [
  &#123;
    path: &#39;/permission&#39;,
    component: Layout,
    redirect: &#39;/permission/index&#39;,
    alwaysShow: true, //将始终显示根菜单
    meta: &#123;
      title: &#39;permission&#39;,
      icon: &#39;lock&#39;,
      roles: [&#39;admin&#39;, &#39;editor&#39;] // 你可以在根导航中设置角色
    &#125;,
    children: [&#123;
      path: &#39;page&#39;,
      component: () =&gt; import(&#39;@/views/permission/page&#39;),
      name: &#39;pagePermission&#39;,
      meta: &#123;
        title: &#39;pagePermission&#39;,
        roles: [&#39;admin&#39;] //或者你只能在子导航中设置角色
      &#125;
    &#125;, &#123;
      path: &#39;directive&#39;,
      component: () =&gt; import(&#39;@/views/permission/directive&#39;),
      name: &#39;directivePermission&#39;,
      meta: &#123;
        title: &#39;directivePermission&#39;
        // 如果不设置角色，则表示：此页不需要权限
      &#125;
    &#125;]
  &#125;]
</code></pre>
<p>这种方式存在以下四种缺点：</p>
<ul>
<li>加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。</li>
<li>全局路由守卫里，每次路由跳转都要做权限判断。</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<p><strong>方案二</strong></p>
<p>初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制</p>
<p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用<code>addRoutes</code>添加路由</p>
<pre><code class="js">import router from &#39;./router&#39;
import store from &#39;./store&#39;
import &#123; Message &#125; from &#39;element-ui&#39;
import NProgress from &#39;nprogress&#39; // 进度条
import &#39;nprogress/nprogress.css&#39;// 进度条样式
import &#123; getToken &#125; from &#39;@/utils/auth&#39; // 从cookie获取令牌

NProgress.configure(&#123; showSpinner: false &#125;)// NProgress配置

// 许可判断功能
function hasPermission(roles, permissionRoles) &#123;
  if (roles.indexOf(&#39;admin&#39;) &gt;= 0) return true //直接传递管理员权限
  if (!permissionRoles) return true
  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)
&#125;

const whiteList = [&#39;/login&#39;, &#39;/authredirect&#39;]// 无重定向白名单

router.beforeEach((to, from, next) =&gt; &#123;
  NProgress.start() // 启动进度条
  if (getToken()) &#123; // 确定是否有令牌
    /* has token*/
    if (to.path === &#39;/login&#39;) &#123;
      next(&#123; path: &#39;/&#39; &#125;)
      NProgress.done() // 如果当前页面是仪表板，则在每个钩子之后都不会触发，所以手动处理它
    &#125; else &#123;
      if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息
        store.dispatch(&#39;GetUserInfo&#39;).then(res =&gt; &#123; // 拉取user_info
          const roles = res.data.roles // 注意：角色必须是数组！ such as: [&#39;editor&#39;,&#39;develop&#39;]
          store.dispatch(&#39;GenerateRoutes&#39;, &#123; roles &#125;).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表
            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表
            next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成 ,将replace:true设置为true，这样导航将不会留下历史记录
          &#125;)
        &#125;).catch((err) =&gt; &#123;
          store.dispatch(&#39;FedLogOut&#39;).then(() =&gt; &#123;
            Message.error(err || &#39;Verification failed, please login again&#39;)
            next(&#123; path: &#39;/&#39; &#125;)
          &#125;)
        &#125;)
      &#125; else &#123;
        // 没有动态改变权限的需求可直接next() 删除下方权限判断 
        if (hasPermission(store.getters.roles, to.meta.roles)) &#123;
          next()//
        &#125; else &#123;
          next(&#123; path: &#39;/401&#39;, replace: true, query: &#123; noGoBack: true &#125;&#125;)
        &#125;
        // 可删 
      &#125;
    &#125;
  &#125; else &#123;
    /* has no token*/
    if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入
      next()
    &#125; else &#123;
      next(&#39;/login&#39;) // 否则全部重定向到登录页
      NProgress.done() // 如果当前页面为“登录”，则在每个钩子之后都不会触发，因此请手动处理
    &#125;
  &#125;
&#125;)

router.afterEach(() =&gt; &#123;
  NProgress.done() // 完成进度条
&#125;)
</code></pre>
<p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p>
<p>这种方式也存在了以下的缺点：</p>
<ul>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<h3 id="菜单权限"><a href="#菜单权限" class="headerlink" title="菜单权限"></a>菜单权限</h3><p>菜单权限可以理解成将页面与理由进行解耦</p>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>菜单与路由分离，菜单由后端返回</p>
<p>前端定义路由信息</p>
<pre><code class="js">&#123;
    name: &quot;login&quot;,
    path: &quot;/login&quot;,
    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)
&#125;
</code></pre>
<p><code>name</code>字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有<code>name</code>对应的字段，并且做唯一性校验</p>
<p>全局路由守卫里做判断</p>
<pre><code class="js">function hasPermission(router, accessMenu) &#123;
  if (whiteList.indexOf(router.path) !== -1) &#123;
    return true;
  &#125;
  let menu = Util.getMenuByName(router.name, accessMenu);
  if (menu.name) &#123;
    return true;
  &#125;
  return false;

&#125;

Router.beforeEach(async (to, from, next) =&gt; &#123;
  if (getToken()) &#123;
    let userInfo = store.state.user.userInfo;
    if (!userInfo.name) &#123;
      try &#123;
        await store.dispatch(&quot;GetUserInfo&quot;)
        await store.dispatch(&#39;updateAccessMenu&#39;)
        if (to.path === &#39;/login&#39;) &#123;
          next(&#123; name: &#39;home_index&#39; &#125;)
        &#125; else &#123;
          //Util.toDefaultPage([...routers], to.name, router, next);
          next(&#123; ...to, replace: true &#125;)//菜单权限更新完成,重新进一次当前路由
        &#125;
      &#125;  
      catch (e) &#123;
        if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入
          next()
        &#125; else &#123;
          next(&#39;/login&#39;)
        &#125;
      &#125;
    &#125; else &#123;
      if (to.path === &#39;/login&#39;) &#123;
        next(&#123; name: &#39;home_index&#39; &#125;)
      &#125; else &#123;
        if (hasPermission(to, store.getters.accessMenu)) &#123;
          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);
        &#125; else &#123;
          next(&#123; path: &#39;/403&#39;,replace:true &#125;)
        &#125;
      &#125;
    &#125;
  &#125; else &#123;
    if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入
      next()
    &#125; else &#123;
      next(&#39;/login&#39;)
    &#125;
  &#125;
  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);
  Util.title(menu.title);
&#125;);

Router.afterEach((to) =&gt; &#123;
  window.scrollTo(0, 0);
&#125;);
</code></pre>
<p>每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的<code>name</code>与路由的<code>name</code>是一一对应的，而后端返回的菜单就已经是经过权限过滤的</p>
<p>如果根据路由<code>name</code>找不到对应的菜单，就表示用户有没权限访问</p>
<p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过<code>addRoutes</code>动态挂载</p>
<p>这种方式的缺点：</p>
<ul>
<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</li>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
</ul>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>菜单和路由都由后端返回</p>
<p>前端统一定义路由组件</p>
<pre><code class="js">const Home = () =&gt; import(&quot;../pages/Home.vue&quot;);
const UserInfo = () =&gt; import(&quot;../pages/UserInfo.vue&quot;);
export default &#123;
    home: Home,
    userInfo: UserInfo
&#125;;
</code></pre>
<p>后端路由组件返回以下格式</p>
<pre><code class="js">[
    &#123;
        name: &quot;home&quot;,
        path: &quot;/&quot;,
        component: &quot;home&quot;
    &#125;,
    &#123;
        name: &quot;home&quot;,
        path: &quot;/userinfo&quot;,
        component: &quot;userInfo&quot;
    &#125;
]
</code></pre>
<p>在将后端返回路由通过<code>addRoutes</code>动态挂载之间，需要将数据处理一下，将<code>component</code>字段换为真正的组件</p>
<p>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理</p>
<p>这种方法也会存在缺点：</p>
<ul>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>前后端的配合要求更高</li>
</ul>
<h3 id="按钮权限"><a href="#按钮权限" class="headerlink" title="按钮权限"></a>按钮权限</h3><h4 id="方案一-1"><a href="#方案一-1" class="headerlink" title="方案一"></a>方案一</h4><p>按钮权限也可以用<code>v-if</code>判断</p>
<p>但是如果页面过多，每个页面页面都要获取用户权限<code>role</code>和路由表里的<code>meta.btnPermissions</code>，然后再做判断</p>
<p>这种方式就不展开举例了</p>
<h4 id="方案二-1"><a href="#方案二-1" class="headerlink" title="方案二"></a>方案二</h4><p>通过自定义指令进行按钮权限的判断</p>
<p>首先配置路由</p>
<pre><code class="js">&#123;
    path: &#39;/permission&#39;,
    component: Layout,
    name: &#39;权限测试&#39;,
    meta: &#123;
        btnPermissions: [&#39;admin&#39;, &#39;supper&#39;, &#39;normal&#39;]
    &#125;,
    //页面需要的权限
    children: [&#123;
        path: &#39;supper&#39;,
        component: _import(&#39;system/supper&#39;),
        name: &#39;权限测试页&#39;,
        meta: &#123;
            btnPermissions: [&#39;admin&#39;, &#39;supper&#39;]
        &#125; //页面需要的权限
    &#125;,
    &#123;
        path: &#39;normal&#39;,
        component: _import(&#39;system/normal&#39;),
        name: &#39;权限测试页&#39;,
        meta: &#123;
            btnPermissions: [&#39;admin&#39;]
        &#125; //页面需要的权限
    &#125;]
&#125;
</code></pre>
<p>自定义权限鉴定指令</p>
<pre><code class="js">import Vue from &#39;vue&#39;
/**权限指令**/
const has = Vue.directive(&#39;has&#39;, &#123;
    bind: function (el, binding, vnode) &#123;
        // 获取页面按钮权限
        let btnPermissionsArr = [];
        if(binding.value)&#123;
            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。
            btnPermissionsArr = Array.of(binding.value);
        &#125;else&#123;
            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。
            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;
        &#125;
        if (!Vue.prototype.$_has(btnPermissionsArr)) &#123;
            el.parentNode.removeChild(el);
        &#125;
    &#125;
&#125;);
// 权限检查方法
Vue.prototype.$_has = function (value) &#123;
    let isExist = false;
    // 获取用户按钮权限
    let btnPermissionsStr = sessionStorage.getItem(&quot;btnPermissions&quot;);
    if (btnPermissionsStr == undefined || btnPermissionsStr == null) &#123;
        return false;
    &#125;
    if (value.indexOf(btnPermissionsStr) &gt; -1) &#123;
        isExist = true;
    &#125;
    return isExist;
&#125;;
export &#123;has&#125;
</code></pre>
<p>在使用的按钮中只需要引用<code>v-has</code>指令</p>
<pre><code class="js">&lt;el-button @click=&#39;editClick&#39; type=&quot;primary&quot; v-has&gt;编辑&lt;/el-button&gt;
</code></pre>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离</p>
<p>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" rel="tag">权限控制</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-加载优化（资源优先级）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/20/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%B5%84%E6%BA%90%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%89/"
    >加载优化（资源优先级）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/02/20/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%B5%84%E6%BA%90%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%89/" class="article-date">
  <time datetime="2023-02-20T03:54:50.000Z" itemprop="datePublished">2023-02-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%B5%84%E6%BA%90%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%89/">加载优化（资源优先级）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="资源优先级"><a href="#资源优先级" class="headerlink" title="资源优先级"></a>资源优先级</h2><blockquote>
<p>浏览器向网络请求到的所有数据，并非每个字节都具有相同的优先级或重要性。所以浏览器通常都会采取启发式算法，对所要加载的内容先进行推测，将相对重要的信息优先呈现给用户，比如浏览器一般会先加载 CSS文件，然后再去加载JavaScript脚本和图像文件。</p>
<p>但即便如此，也无法保证启发式算法在任何情况下都是准确有效的，可能会因为获取的信息不完备，而做出错误的判断。本节就来探讨如何影响浏览器对资源加载的优先级。</p>
</blockquote>
<h3 id="一、优先级"><a href="#一、优先级" class="headerlink" title="一、优先级"></a>一、优先级</h3><p>​		浏览器基于自身的启发式算法，会对资源的重要性进行判断来划分优先级，通常从低到高分为: Lowest、 Low、 High、Highest 等。</p>
<p>​		比如，在&lt;head标签中，CSS文件通常具有最高的优先级Highest,其次是 script 标签所请求的脚本文件，但当&lt;script标签带有defer或async的异步属性时，其优元级又会降为Low.我们可以通过Chrome的开发者工具，在network页签下找到浏览器对资源进行的优先级划分，如图所示。</p>
<p><img src="/2023/02/20/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%B5%84%E6%BA%90%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%89/image-20230220113248217.png" alt="浏览器的资源优先级"></p>
<p>​		我们可以通过该工具，去了解浏览器为不同资源分配的优先级情况，细微的差别都可能导致类似的资源具有不同的优先级，比如首屏渲染中图像的优先级会高于屏幕视窗外的图像的优先级。本书不会详细探讨Chrome 如何为当前资源分配优先级，如有兴趣可通过搜索“浏览器加载优先级”等关键字自行了解。对性能优化实战而言，会更加关注:当发现资源默认被分配的优先级个不是我们想要的情况时，该如何更改优先级。</p>
<p>​		接下来介绍三种不同的解决方案:首先是前面章节提到过的预加载，当资源对用户来说至关重要却又被分配了过低的优先级时，就可以尝试让其进行预加载或预连接;如果仅需要浏览器处理完一些任务后， 再去提取某些资源，可尝试使用预提取。</p>
<h3 id="二、预加载"><a href="#二、预加载" class="headerlink" title="二、预加载"></a>二、预加载</h3><p>使用<link rel="preload">标签告诉浏览器当前所指定的资源，应该拥有更高的优先级，例如:</p>
<pre><code class="html">&lt;link rel=&quot;preload&quot; as=&quot;script&quot; href=&quot; important.js&quot;&gt;
&lt;link rel=&quot;preload&quot; as=&quot;style&quot; href=&quot;critical.css&quot;&gt;
</code></pre>
<p>​		这里通过as属性告知浏览器所要加载的资源类型，该属性值所指定的资源类型应当与要加载的资源相匹配，否则浏览器是不会预加载该资源的。在这里需要注意的是，<link rel="preload">会强制浏览器进行预加载，它与其他对资源的提示不同，浏览器对此是必须执行而非可选的。因此，在使用时应尽量仔细测试，以确保使用该指令时不会提取不需要的内容或重复提取内容。</p>
<p>​		如果预加载指定的资源在3s内未被当前页面使用，则浏览器会在开发者工具的控制台中进行警告提示，该警告务必要处理。</p>
<p>​		接下来看两个使用实例，字体的使用和关键路径渲染。通常字体文件都位于页面加载的若干CSS文件的末尾，但考虑为了减少用户等待文本内容的加载时间，以及避免系统字体与偏好字体发生冲突，就必须提前获取字体。因此我们可以使用<link rel="preload">来让浏览器立即获取所需的字体文件:</p>
<pre><code class="html">&lt;link rel=&quot;preload&quot; as=&quot;font&quot; crossorigin=&quot;crossorigin&quot; type=&quot;font/woff2&quot; href=&quot;myfont.woff2&quot;&gt;
</code></pre>
<p>这里的crossorigin属性非常重要，如果缺失该属性，浏览器将不会对指定的字体进行预加载。</p>
<p>​		在前面讲页面渲染生命周期时，提到过关键渲染路径，其中涉及首次渲染之前必须加载的资源(比如Css和JavaScript等)，这些资源对首屏页面渲染来说是非常重要的。以前通常建议的做法是把这些资源内联到HTML中，但对服务器端渲染或对页面而言，这样做很容易导致带宽浪费，而且若代码更改使内联页面无效，无疑会增加版本控制的难度。</p>
<p>​		所以使用<link rel="preload">对单个文件进行预加载，除了能很快地请求资源，还能尽量利用缓存。其唯一的缺点是可能会在浏览器和服务器之间发生额外的往返请求，因为浏览器需要加载解析HTML后，才会知道后续的资源请求情况。其解决方式可以利用HTTP 2的推送，即在发送HTML的相同连接请求上附加一些资源请求， 如此便可取消浏览器解析HTML到开始下载资源之间的间歇时间。但对于HTTP2推送的使用需要谨慎，因为控制了带宽使用量，留给浏览器自我决策的空间便会很小，可能不会检索已经缓存了的资源文件。关于HTTP2的更多内容，将会在浏览器缓存详细展开介绍。</p>
<h3 id="三、预连接"><a href="#三、预连接" class="headerlink" title="三、预连接"></a>三、预连接</h3><p>​		通常在速度较慢的网络环境中建立连接会非常耗时，如果建立安全连接将更加耗时。其原因是整个过程会涉及DNS查询、重定向和与目标服务器之间建立连接的多次握手，所以若能提前完成上述这些功能，则会给用户带来更加流畅的浏览体验，同时由于建立连接的大部分时间消耗是等待而非数据交换，这样也能有效地优化带宽的使用情况。解决方案就是所谓的预连接:</p>
<pre><code class="html">&lt;link rel=&quot;preconnect&quot; href=&quot;https://example. com&quot;&gt;
</code></pre>
<p>​		通过<link rel="preconnect">标签指令，告知浏览器当前页面将与站点建立连接，希望尽快启动该过程。虽然这么做的成本较低，但会消耗宝贵的CPU时间，特别是在建立HTTPS安全连接时。如果建立好连接后的10s内，未能及时使用连接，那么浏览器关闭该连接后，之前为建立连接所消耗的资源就相当于完全被浪费掉了。</p>
<p>​		另外，还有一种与预连接相关的类型<link rel="dns-prefetch">,也就是常说的DNS预解析，它仅用来处理DNS查询，但由于其受到浏览器的广泛支持，且缩短了DNS的查询时间的效果显著，所以使用场景十分普遍。</p>
<h3 id="四、预提取"><a href="#四、预提取" class="headerlink" title="四、预提取"></a>四、预提取</h3><p>​		前面介绍的预加载和预连接，都是试图使所需的关键资源或关键操作更快地获取或发生，这里介绍的预提取，则是利用机会让某些非关键操作能够更早发生。</p>
<p>​		这个过程的实现方式是根据用户已发生的行为来判断其接下来的预期行为，告知浏览器稍后可能需要的某些资源。也就是在当前页面加载完成后，且在带宽可用的情况下，这些资源将以Lowest的优先级进行提起。</p>
<p>​		显而易见，预提取最适合的场景是为用户下一步可能进行的操作做好必要的准备，如在电商平台的搜索框中查询某商品，可预提取查询结果列表中的首个商品详情页:或者使用搜索查询时，预提取查询结果的分页内容的下一页:</p>
<pre><code class="html">&lt;1ink rel=&quot;prefetch&quot; href=&quot;page-2.html&quot;&gt;
</code></pre>
<p>​		需要注意的是，预提取不能递归使用，比如在搜索查询的首页page-1.html时，可以预提取当前页面的下一页page-2.html的HTML内容，但对其中所包含的任何额外资源不会提前下载，除非有额外明确指定的预提取。</p>
<p>另外，预提取不会降低现有资源的优先级，比如在如下HTML中:</p>
<pre><code class="html">&lt;html&gt;
&lt;head&gt;
&lt;link rel=&quot;prefetch&quot;href=&quot;style.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot;href=&quot;style.css&quot;&gt;
&lt;/head&gt;

&lt;body&gt;
Hello World!
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​		可能你会觉得对style.css 的预提取声明，会降低接下来<link rel="stylesheet" href="style.css">的优先级，但其真实的情况是，该文件会被提取两次，第二次可能会使用缓存，如图所示。</p>
<p><img src="/2023/02/20/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%B5%84%E6%BA%90%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%89/image-20230220115326792.png"></p>
<p>​		显然两次提取对用户体验来说非常糟糕，因为这样不但需要等待阻塞渲染的CSS,而且如果第二次提取没有命中缓存，必然会产生带宽的浪费，所以在使用时应充分考虑。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B5%84%E6%BA%90%E4%BC%98%E5%85%88%E7%BA%A7/" rel="tag">资源优先级</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-加载优化（加载注意事项）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/17/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%8A%A0%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%89/"
    >加载优化（加载注意事项）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/02/17/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%8A%A0%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%89/" class="article-date">
  <time datetime="2023-02-17T01:45:34.000Z" itemprop="datePublished">2023-02-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%8A%A0%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%89/">加载优化（加载注意事项）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="加载注意事项"><a href="#加载注意事项" class="headerlink" title="加载注意事项"></a>加载注意事项</h2><blockquote>
<p>对图像与视频的延迟加载，从理论上看必然会对性能产生重要的影响，但在实现过程中有许多细节需需要注意，稍有差池都可能就会产生意想不到的结果。因此，总结以下几点注意事项。</p>
</blockquote>
<h3 id="一、首屏加载"><a href="#一、首屏加载" class="headerlink" title="一、首屏加载"></a>一、首屏加载</h3><p>​		当我们了解了延迟加载的诸多优点之后，读者是否有使用JavaScript对页面上所有的图像和视频资源都进行延迟加我的冲动?在采取该优化措施前，要想提醒的是，对性能优化工作来说，不存在一蹴而就的解决方案， 而是需要根据具体场景采用恰当的方式。比如对于首屏上的内容就不应当进行延迟加载，而应使用正常加载的方式，这样处理的原因是，延迟加载会将图像或视频等媒体资源延迟到DOM可交互之后，即脚本完成加载并开始执行时才会进行。所以对首屏视窗之外的媒体资源采用延迟加载，而对首屏内的媒体资源采用正常的方式加载，会带来更好的整体性能体验。</p>
<p>​		由于网站页面所呈现的设备屏幕尺寸多种多样，因此如何判断首屏视窗的边界，就会因设备的不同而有所不同。台式机电脑首屏视窗中的内容，可能换到移动设备上就会位于首屏视窗之外。目前也没有完全行之有效的方法来完美地处理每种设备的情况。</p>
<p>​		此外，若将首屏视窗边界线作为延迟加载触发的阈值，其实井非最佳的性能考虑。更理想的做法是，在延迟加载的媒体资源到达首屏边界之前设置一个缓冲区，以便媒体资源在进入视窗之前就开始进行加载。</p>
<p>​		例如在使用lntersection Observer方式实现延迟加载判断时，可以通过配置options对象中的rootMargin属性来建立缓冲区:</p>
<pre><code class="js">const lazyImageObserver = new IntersectionObserver((entries, observer) =&gt; &#123;
//此处省略延迟加载的具体处理流程
  ...&#125;,&#123;
rootMargin:”0 0 256px 0&quot;
&#125;:
</code></pre>
<p>​		观察可知rootMargin的值与CSS中margin属性值类似，上述代码中 在屏幕视窗下设置了一个宽度为256px的缓冲区，这意味着当媒体元素距离视窗下边界小于256px时，回调函数就会执行开始资源的请求加载。而对于使用滚动事件处理来实现延迟加载的传统实现方式，也只需要更改getBoundingClientRect的设置，包括进入一个缓冲区即可实现类似的效果。</p>
<h3 id="二、资源占位"><a href="#二、资源占位" class="headerlink" title="二、资源占位"></a>二、资源占位</h3><p>​		当延迟加载的媒体资源未渲染出来之前，应当在页面中使用相同尺寸的占位图像。如果不使用占位符，图像延迟显示出来后，尺寸更改可能会使页面布局出现移位。这种现象不仅会对用户体验带来困感，更严重的还会触发浏览器成本高昂的回流机制，进而增加系统资源开销造成卡顿。而用来占位的图像解决方案也有多种，十分简单的方式是使用一个与目标媒体资源长宽相同的纯色占位符，或者像之前使用的Base64图片，当然也可以采用LQIP或SQIP等方法。</p>
<p>​		其中LQIP的全称是低质量图片占位符，即使用原图的较低分辨率版本来占位，SQIP则是一种基于 SVG的LIQP技术，我们可以通过对比来感知它们和原图之间的差别，如图所示。</p>
<p><img src="/2023/02/17/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%8A%A0%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%89/image-20230216120651723.png" alt="各种LQIP的效果"></p>
<p>​		其实就是以最小的带宽消耗，告知用户此处将要展示一个媒体资源，可能由于资源尺寸较大还在加载。对于使用&lt;img标记的图像资源，应将用于占位的初始图像指给src属性，直到更新为所需的最终图像为止。而对于使用&lt;video标记的视频资源，则应将占位图像指给poster属性，除此之外，最好可以在&lt;img和&lt;video标签上添加表示宽width和高height的属性，如此便可确保不会在占位符转化为最终媒体资源时，发生元素渲染大小的改变。</p>
<h3 id="三、内容加载失败"><a href="#三、内容加载失败" class="headerlink" title="三、内容加载失败"></a>三、内容加载失败</h3><p>​		在进行延迟加载过程中，可能会因为某种原因而造成媒体资源加载失败，进而导致错误的情况。比如用户访问某个网站后，保持浏览器该选项卡打开后长时间离开，等再返回继续浏览网页内容时，可能在此过程中网站已经进行了重新部署，原先访问的页面中包含的部分媒体资源由于哈希的版本控制发生更改，或者已被移除。那么用户滚动浏览页面，遇到延迟加载的媒体资源，可能就已经不可使用了。</p>
<p>​	虽然类似情况发生的概率不高，但考虑网站对用户的可用性，开发者也应当考虑好后备方案，以防止类似延迟加载可能遇到的失败。例如，图像资源可以采取如下方案进行规避:</p>
<pre><code class="js">const newImage = new Image();
newImage.src = &quot;photo.jpg&quot;;
//当发生故障时的处理措施
newImage.onerror = (err) =&gt; &#123;
&#125;;
//图像加载后的回调
newImage.onload = ()= &gt; &#123;
&#125;;
</code></pre>
<p>​		当图片资源未能按预期成功加载时，所采取的具体处理措施应当依据应用场景而定。比如，当请求的媒体资源无法加载时，可将使用的图像占位符替换为按钮。让用户单击以尝试重新加载所需的媒体资源，或者在占位符区域显示错误的提示信息。总之，在发生任何资源加载故障时，给予用户必要的通知提示，总好过直接让用户无奈地面对故障。</p>
<h3 id="四、图像解码延迟"><a href="#四、图像解码延迟" class="headerlink" title="四、图像解码延迟"></a>四、图像解码延迟</h3><p>​		在前面章节介绍JPEG图像的编解码时，我们知道渐进式的JPEG会先呈现出个低像素的图像版本，随后会慢慢呈现出原图的样貌。这是因为图像从被浏览器请求获取，再到最终完整呈现在屏幕上，需要经历一个解码的过程，图像的尺寸越大，所需要的解码时间就越长。如果在JavaScript 中请求加载较大的图像文件，并把它直接放入DOM结构中后，那么将有可能占用浏览器的主进程，进而导致解码期间用户界面出现短暂的无响应。</p>
<p>​		为减少此类卡顿现象，可以采用decode方法进行异步图像解码后，再将其插入DOM结构中。但目前这种方式在跨浏览器场景下并不通用，同时也会复杂化原本对于媒体资源延迟加载的处理逻辑，所以在使用中应进行必要的可用性检查。下面是一个使用Image.decode()函数来实现异步解码的示例:</p>
<pre><code class="js">&lt;button id=&quot;load-image&quot;&gt;加载图像&lt;/button&gt;
&lt;div id=&quot;image-container&quot;&gt;&lt;/div&gt;
//对应的JavaScript事件处理代码如下:
document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123;
  const loadButton = document.getElementById(&quot;load-image&quot;);
  const imageContainer = document.getElementById(&quot;image-container&quot;);
  const newImage = new Image();
  newImage.src = &quot;https://xx. cdn/very-big-photo.jpg&quot;;
  loadButton.addEventListener(
    &quot;click&quot;,
    function () &#123;
      if (&quot;decode&quot; in newImage) &#123;
        //异步解码方式
        newImage.decode().then(function () &#123;
          imageContainer.appendChild(newImage);
        &#125;);
      &#125; else &#123;
        //正常图像加载方式
        imageContainer.appendChild(newImage);
      &#125;
    &#125;,
    &#123;
      once: true,
    &#125;
  );
&#125;);
</code></pre>
<p>​		需要说明的是，如果网站所包含的大部分图像尺寸都很小，那么使用这种方式的帮助并不会很大，同时还会增加代码的复杂性。但可以肯定的是这么做会减少延迟加载大型图像文件所带来的卡顿。</p>
<h3 id="五、JavaScript-是否可用"><a href="#五、JavaScript-是否可用" class="headerlink" title="五、JavaScript 是否可用"></a>五、JavaScript 是否可用</h3><p>​		在通常情况下，我们都会假定JavaScript始终可用，但在一些异常不可用的物可用的情况下，开发者应当做好适配，不能始终在延迟加载的图像位置上展示占位符。可以考虑使用&lt;noscript标记，在JavaScript不可用时提供图像的真实展示:</p>
<pre><code class="html">&lt;!-使用延迟加载的图像文件标签--&gt;
&lt; img class=&quot;lazy&quot; src=&quot;placeholder-image.jpg&quot; data-src=&quot;image-to-lazy-load.jpg&quot; alt=&quot;I&#39;m an image!&quot;&gt;
&lt;!一当JavaScript不可用时，原生展示目标團像--&gt;
&lt;noscript&gt;
&lt; img src=&quot;image-to-lazy-load.jpg&quot; alt=&quot;I&#39;m an image!&quot;&gt;
&lt;/noscript&gt;
</code></pre>
<p>如果上述代码同时存在，当JavaScript不可用时，页面中会同时展示图像占位符和&lt;noscript中包含的图像，为此我们可以给&lt;html标签添加一个 no-js类:</p>
<pre><code class="html">&lt;html class=&quot;no-js&quot;&gt;
</code></pre>
<p>在由&lt;link标签请求CSS文件之前，在&lt;head标签结构中放置一段内联脚本， 当JavaScript可用时，用于移除no-js类:</p>
<pre><code class="js">&lt;script&gt;
  document. documentElement.classList. remove (&quot;no-js&quot;);
&lt;/script&gt;
</code></pre>
<p>以及添加必要的CSS样式，使得在JavaScript不可用时屏蔽包含 .lazy类元素的显示:</p>
<pre><code class="css">.no-js .1azy &#123;
display: none;
&#125;
</code></pre>
<p>​		当然这样并不会阻止占位符图像的加载，只是让占位符图像在JavaScript不可用时不可见，但其体验效果会比让用户只看到占位符图像和没有意义的图像内容要好许多。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A0%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" rel="tag">加载注意事项</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-加载优化（视频加载）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/16/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%A7%86%E9%A2%91%E5%8A%A0%E8%BD%BD%EF%BC%89/"
    >加载优化（视频加载）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/02/16/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%A7%86%E9%A2%91%E5%8A%A0%E8%BD%BD%EF%BC%89/" class="article-date">
  <time datetime="2023-02-16T03:09:10.000Z" itemprop="datePublished">2023-02-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%A7%86%E9%A2%91%E5%8A%A0%E8%BD%BD%EF%BC%89/">加载优化（视频加载）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="视频加载"><a href="#视频加载" class="headerlink" title="视频加载"></a>视频加载</h2><blockquote>
<p>与延迟加载图像资源类似，通过视频标签引入的视频资源也可进行延迟加载，但通常都会根据需求场景进行具体的处理，下面就来探讨一 些关于 视频加载的优化内容。</p>
</blockquote>
<h3 id="一、不需要自动播放"><a href="#一、不需要自动播放" class="headerlink" title="一、不需要自动播放"></a>一、不需要自动播放</h3><p>​		由于Chrome等一些浏览器会对视频资源进行预加载，即在HTML完成加载和解析时触发DOMContentLoaded 事件开始请求视频资源，当请求完成后触发window. onload事件开始页面渲染，过程如图所示。</p>
<p><img src="/2023/02/16/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E8%A7%86%E9%A2%91%E5%8A%A0%E8%BD%BD%EF%BC%89/image-20230216103841965.png" alt="视频资源的加载"></p>
<p>为了使页面更快地加载并渲染出来，可以阻止不需要自动播放的视频的预加载:其方法是通过视频标签的preload进行控制:</p>
<pre><code class="html">&lt;video controls preload-&quot;none&quot; poster=&quot;default.1po9&quot;&gt;
        &lt;source src=&quot;simply.webm&quot; type-&quot;video/webm&quot;&gt;
        &lt;source src=&quot;simply.mp4&quot; tye-&quot;video/mp4&quot;&gt;
&lt;/video&gt;
</code></pre>
<p>标签的preload属性通常的默认值为auto，表示无论用户是否希望，所有视频文件都会被自动下载，这里将其设置为none，来阻止视频的自动加载。同时这里还通过poster属性为视频提供占位符图片，它的作用是当视频未加载出来时，不至于在页面中呈现一块让用户未知的空白。考虑类似边缘异常场最是必要的，因为浏览器对视烦的加载行为可能存在较大差别。</p>
<ul>
<li>Chrome之前的版本中，preload的默认值是auto,从64版本以后其默人值改为了metadata, 表示仅加载视频的元数据，Firefox、 IE11和Edge等浏览器的行为类似。</li>
<li>Safari 11.0的Mac版会默认进行部分视频资源预加载，11.2的Mac版后仅可预加载元数据，但ios的Safari不会对视频预加载。</li>
<li>若浏览器开启了流量节省模式后，preload 将默认设置为none.</li>
</ul>
<p>​		当浏览器支持preload的metadata属性值后，这将会是一种兼顾了 性能与体验后更优的方式，因为从体验上讲，对于不自动播放的视频场景，在单击播放之前，若能提前告知视频的播放时长、播放列表等元数据，便能带给用户更好的可控感，同时又不至于提前加载了过多资源而阻塞页面渲染。</p>
<p>另外， 如果你的站点中包含了同一域名下的多个视频资源，那么推荐最好将preload属性设置为metadata,或者定义poster属性值时将preload设置为none,这样能很好地避免HTTP的最大连接数，因为通常HTTP 1.1协议规定同一城名下的最大连接数为6,如果同时有超过此数量的资源请求连接，那么多余的连接便会被挂起，这无疑也会对性能造成负面影响。</p>
<h3 id="二、视频代替GIF动画"><a href="#二、视频代替GIF动画" class="headerlink" title="二、视频代替GIF动画"></a>二、视频代替GIF动画</h3><p>​		另一种视频的使用场最是在前面章节讲到的:应当尽量用视频代替尺寸过大的GIF动画，虽然GIF动画的应用历史和范围都很广泛，但其在输出文件大小、图像色彩质量等许多方面的表现均不如视频。GIF动画相对于视频具有三个附加的特性:没有音轨、连续循环播放、加载完自动播放，替换成视频后类似于:</p>
<pre><code class="html">&lt;video autoplay muted loop playsinline&gt;
        &lt;source src-&quot;video.webm&quot; type-&quot;video/webm&quot;&gt;
        &lt;source srC-&quot;video .mp4&quot;type-&quot;video/mp4&quot;&gt;
&lt;/video&gt;
</code></pre>
<p>​		其中在视频标签中附加的属性含义分别为:autoplay自动播放、muted 静音播放及loop循环播放，而playsinline属性则是用于在ios中指定自动播放的。虽然有了GIF图像的替代方案，但并非所有浏览器都像Chrome一样， 能自动进行延迟加载。接下来就需要进行一些配置开发， 使该场最的视频也能延迟加载。首先修改HTML标签如下:</p>
<pre><code class="html">&lt;video autoplay muted loop playsinline width=&quot;610&quot; height=&quot;254&quot; poster=&quot;video-poster.jpg&quot;&gt;
        &lt;source data-src=&quot;video. webm&quot; type=&quot;video/webm&quot;&gt;
        &lt;source data-src=&quot;video .mp4&quot; type=&quot;video/mp4&quot;&gt;
&lt;/video&gt;
</code></pre>
<p>​		这里进行了两处修改:首先是为视频标签添加了poster 属性，意为使用poster中指定的图片作为视频延迟加载出现前的占位;其次是使用了类似应对图像延迟加载的方式，将真实视频资源的URL放在data-src属性中，然后基于Intersection Observer用JavaScript实现对延迟加载的控制:</p>
<pre><code class="js">Document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123;
  const lazyVideos = [].slice.call(document.querySelectorAll(&quot;video.lazy&quot;));
  if (&quot;IntersectionObserver&quot; in window) &#123;
    const lazyVideoObserver = new IntersectionObserver((entries, observer) =&gt; &#123;
      entries.forEach((video) =&gt; &#123;
        if (video.isIntersecting) &#123;
          for (const source in video.target.children) &#123;
            const videoSrc = video.target.children[source];
            if (
              typeof videoSrc.tagName === &quot;string&quot; &amp;&amp;
              videoSrc.tagName === &quot;source&quot;
            ) &#123;
              videoSrc.src = videoSrc.dataset.src;
            &#125;
          &#125;
          video.target.load();
          video.target.classList.remove(&quot;lazy&quot;);
          lazyVideoObserver.unobserve(video.target);
        &#125;
      &#125;);
    &#125;);

    lazyVideos.forEach((lazyVideo) =&gt; &#123;
      lazyVideoObserver.observe(lazyVideo);
    &#125;);
  &#125;
&#125;);
</code></pre>
<p>​		对视频标签的延迟加载有点类似<picture>,需要对所有<source> 子元素进行选代解析，将data-src上的属性值迁移到src属性上。不同的是，需要额外显示调用元素的load方法来触发加载，然后视频才会根据autoplay属性开始进行自动播放。如此便可使用低于GIF动画的流量消耗，进行资源的延迟加载。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A7%86%E9%A2%91%E5%8A%A0%E8%BD%BD/" rel="tag">视频加载</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-加载优化（图像延迟加载）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/09/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%BE%E5%83%8F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89/"
    >加载优化（图像延迟加载）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/02/09/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%BE%E5%83%8F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89/" class="article-date">
  <time datetime="2023-02-09T09:50:24.000Z" itemprop="datePublished">2023-02-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%BE%E5%83%8F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/">加载优化（图像延迟加载)</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="图像延迟加载"><a href="#图像延迟加载" class="headerlink" title="图像延迟加载"></a>图像延迟加载</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​		相要得到更好的性能体验，只靠资源压缩与恰当的文件格式选型，是很难满足期望的。我们还需要针对资源加载过程进行优化，该环节所要做的内容可概括为分清资源加载的优先级顺序，仅加载当前所必需的资源，并利用系统空闲提前加载可能会用利的资源。这便是本章将要探讨的内容:资源的优先级、延迟加载和预加载。</p>
<p>​		什么是图像的延迟加载，如何高效地实现延迟加载。随着近些年视频资源越来越多的使用，也会捎带介绍视频资源的延迟加载。然后谈谈浏览器对于资源优先级的划分和控制，既然可以通过将非关键资源延迟加载来提升性能，那么是否可以利用系统使用的空闲，预先去加载可能会使用到的资源。</p>
<p>​		本节介绍什么是延迟加载，以及这种优化策略产生的逻辑和实现原理。笔者认为只有先理解了一种原理或方法的缘起流变，才能知道怎样的实现方式是更高效的、更贴近业务场景的。</p>
<h3 id="一、什么是延迟加载"><a href="#一、什么是延迟加载" class="headerlink" title="一、什么是延迟加载"></a>一、什么是延迟加载</h3><p>​		首先来想象一个场景，当浏览一个内容丰富的网站时，比如电商的商品列表页、主流视频网站的节目列表等，由于屏幕尺寸的限制，每次只能查看到视窗中的那部分内容，而要浏览完页面所包含的全部信息，就需要滚动页面，让屏幕视窗依次展示出个页面的所有局部内容。</p>
<p>​		显而易见，对于首屏之外的内容，特别是图片和视频，一方面 由于资源文件很大，若是全部加载完，既费时又费力，还容易阻塞渲染引起卡顿:另一方面，就算加载完成，用户也不一定会滚动屏幕浏览到全部页面内容，如果首屏内容没能吸引住用户，那么很可能整个页面就将遭到关闭。</p>
<p>​		既然如此，本着节约不浪费的原则，在首次打开网站时，应尽量只加载首屏内容所包含的资源，而首屏之外涉及的图片或视频，可以等到用户滚动视窗浏览时再去加载。</p>
<p>​		以上就是延迟加载优化策略的产生逻辑，通过延迟加载“非关键”的图片及视频资源，使得页面内容更快地呈现在用户面前。这里的“非关键”资源指的就是首屏之外的图片或视频资源，相较于文本、脚本等其他资源来说，图片的资源大小不容小觑。这个优化策略在业界已经被广泛使用，接下来笔者就以天猫购物网站的商品列表页为例，具体看看延迟加载是如何实现的，如图所示。</p>
<p><img src="/2023/02/09/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%BE%E5%83%8F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89/image-20230209161519677.png"></p>
<p>​		图左侧是手机端常见的电商购物平台的商品列表页，右侧是其对应的DOM树结构。其中在区域上方，整齐如排比句般的<div>结构，所对应的正是列表页中一行行的商品项。以其中一件商品为例， 展开它的DOM树，直到找到展示该商品图片的<img>标签。为了方便说明，笔者将这个<img>标签的相关细节摘录如下:</p>
<pre><code class="html">&lt;img class=&quot;boom-item-item&quot; autowebp=&quot;false&quot; autopixelratio=&quot;true&quot; forceupdate=&quot;true&quot; data-bindkey=&quot;pic&quot; data-itemid=&quot;700023719087&quot; data-size=&quot;348x348&quot; data-rewrite=&quot;&#123;size:&#39;348x348&#39;&#125;&quot; data-lazy-type=&quot;img&quot; data-lazy-id=&quot;lazyId-11&quot; data-lazy-manager-id=&quot;gLazyM-1&quot; data-in-view-range=&quot;1&quot; src=&quot;//gw.alicdn.com/bao/uploaded/i3/3058655500/O1CN01CyNBBW1qV3AjEusqC_!!0-item_pic.jpg_360x360q75.jpg_.webp&quot;&gt;
</code></pre>
<p>​		这里主要关注其中的src属性，src 属性代表了一个CDN上的图片资源。要知道当<img>标签的src属性被赋予了一一个URL后，它就会立刻向该URL发起资源请求。所以这个商品的<img>标签代表的就是一个商品图片的占位符。</p>
<p>​		接下来我们找到一个位于屏幕视窗外，还未加载的商品图片和已加载的图片，相比较看看二者标签上的属性值有何不同。首先保持左侧页面显示窗口不发生滚动，在DevTools工具的Elements页签下，寻找还未呈现在左侧视窗中的商品项，容易找到它的DOM结构。</p>
<p>​		首先，我们依然关注<img>标签的src属性，这里并不是图片资源的外链URL,取而代之的是一个在图像优化章节中介绍过的Base64图片，与外链URL不同的是，Base64图片已经包含了图片的完全编码，可以直接拿来渲染，而无须发起任何网络请求。</p>
<p>​		这意味着该Base64图片仅仅是在真实图片显示出来前用以占位的，同时注意到所有未展示在页面视窗中的商品，其图片占位src属性值均使用了相同的Base64的值.当页面发生滚动时，之前未出现在视窗中的商品出现在视窗中后，其商品图片的真实URL会被替换到<img>标签的src属性上，进而发起资源请求。</p>
<p>​		我们知道了什么是延迟加载。以及为什么要使用延迟加载，并通过观察一个商品列表页的案例，基本清楚了延迟加载的处理过程，接下来将通过三种方法来具体实现延迟加载。</p>
<h3 id="二、实现图片的延迟加载：传统方式"><a href="#二、实现图片的延迟加载：传统方式" class="headerlink" title="二、实现图片的延迟加载：传统方式"></a>二、实现图片的延迟加载：传统方式</h3><p>​		就是事件监听的方式，通过监听scroll事件与resize 事件，并在事件的回调函费中去判断，需要进行延迟加载的图片是否进入视窗区域。</p>
<p>​		首先根据前面的例子，定义出将要实现延迟加载的<img>标签结构:</p>
<p>我们只需要关注三个属性。</p>
<ul>
<li>class 属性，稍后会在JavaScript中使用类选择器选取需要延迟加载处理的<img>标签。</li>
<li>src属性，加载前的占位符图片，可用Base64图片或低分辨率的图片。</li>
<li>data-src属性，通过该自定义属性保存图片真实的URL外链。</li>
</ul>
<p>假设以三张图片为例进行延迟加载的<img>标签列表如下:</p>
<pre><code class="html">&lt;img class=&quot;lazy&quot; src-&quot;data: image/gif;base64, iVBORwOKGg.. .BJRUErkJgqs-.data-src=&quot;https://res.cloudinary.com/ .../tacos-2x.jpg&quot;width=&quot;385&quot; height=&quot;108&quot; alt=&quot;Some tacos. &quot;&gt;

&lt;img class=&quot;lazy&quot; src=&quot;data:image/gif;base64, iVBORw0KGg. . . BJRU5ErkJggg==&quot; data-src=&quot;https:// res.cloudinary.com/d. . ./modem-2x . png&quot; width=&quot;320&quot; height=&quot;176&quot; alt=&quot;A 56k modem. &quot;&gt;

&lt;img class=&quot;lazy&quot; src=&quot;data:image/gif;base64, iVBORw0KGg.. . BJRU5ErkJggg==&quot; data-src=&quot;https ://res. cloudinary. com/ ../st-paul-2x. jpg&quot; width=&quot;400&quot; height=&quot;267&quot; alt=&quot;A city skyline. &quot;&gt;
</code></pre>
<p>​		具体的JvsSerpr实现逻辑如下，在文档的DOMContentLoaded事件中，添加延迟加载处理逻辑，首先获取class属性名为lazy的所有<img>标签，将这些标签看存在一个名为lazylmages 的数组中，表示需要进行延迟加载但还未加载的图片集合。当一个图片被加载后，便将其从lazylmages数组中移除，直到lazyImages数组为空时，表示所有待延迟加载的图片均已经加载完成，此时便可将页面滚动事件移除。</p>
<p>​		接下来的关键就是判断图片是否出现在视窗中，这里使用了getBoundingClientRect()函数获取元素的相对位置，如图所示。它会返回图片元素的宽width和高height,及其与视窗的相对位置:元素上边缘与屏幕视窗顶部之间的距离top,元素左边缘和屏幕视窗左侧之间的距离left,元素下边缘和屏幕视窗顶部之间的距离bottom 以及元素右边缘和屏幕视窗左侧之间的距离right, 其具体含义可参考示意图，window.innerHeight 表示整个视窗的高度。</p>
<p><img src="/2023/02/09/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%BE%E5%83%8F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89/image-20230209164625464.png" alt="getBoundingClientRect()函数获取元素的相对位置"></p>
<p>​		对于只可上下滚动的页面，判断一个图片 元素是否出现在屏幕视窗中的方法其实显而易见，即当元素上边缘距屏幕视窗顶部的top 值小于整个视窗的高度window.innerHeight时，预加载的事件处理代码如下:</p>
<pre><code class="js">document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;
  //获取所有需要延迟加载的图片
  let lazyImages = [].sllce.call(document.querySelectorAll(&quot;img.1azy&quot;));
  //限制函数频繁被调用
  let active = false;
  const lazyLoad = function () &#123;
    if (active === false) &#123;
      active = true;
      setTimeout(function () &#123;
        lazyImages.forEach(function (lazyImage) &#123;
          //判断图片是否出现在视窗中
          if (
            lazyImage.getBoundingClientRect().top &lt;= window.innerHeight &amp;&amp;
            lazyImage.getBoundingClientRect().bottom &gt;= 0 &amp;&amp;
            getComputedstyle(lazyImage).display !== &quot;none&quot;
          ) &#123;
            // 将真实的图片URL赋值给src属性，发起请求加载资源

            lazyImage.src = lazyImage.dataset.src;

            //图片加载完成后，取消监控以防止重复加载

            lazyImage.classList.remove(&quot;1azy&quot;);

            lazyImages = lazyImages.filter(function (image) &#123;
              return image !== lazyImage;
            &#125;);

            //所有延迟加载图片加载完成后，移除事件触发处理函数

            if (lazyImages.length === 0) &#123;
              document.removeEventListener(&quot;scroll&quot;, lazyLoad);
              window.removeEventListener(&quot;resize&quot;, lazyload);
              window.removeEventListener(&quot;orientationchange&quot;, lazyLoad);
            &#125;
          &#125;
        &#125;);

        active = false;
      &#125;, 200);
    &#125;
  &#125;;

  document.addEventListener(&quot;scroll&quot;, lazyLoad);
  window.addEventListener(&quot;resize&quot;, lazyLoad);
  window.addEventListener(&quot;orientationchange&quot;, lazyLoad);
&#125;);
</code></pre>
<p>​	由于无法控制用户随心所欲地滑动鼠标滚轮，从而造成scroll 事件被触发地过于频繁，导致过多的冗余计算影响性能。所以此处笔者将延迟加载的处理过程置于一个200ms的异步定时器中，并在每次处理完成后，通过修改标志位active 的方式来对方法的执行进行限流。</p>
<p>​		即便如此也有潜在的性能问题，因为重复的setTimeout调用是浪费的，虽然进行了触发限制，但当文档滚动或窗口大小调整时，不论图片是否出现在视窗中，每200ms都会运行一次检查，并且跟踪尚未加载的图片数量，以及完全加载完后，取消绑定滚动事件的处理函数等操作都需要开发者来考虑。</p>
<p>​		如此来看，虽然传统的延迟加载实现方式具有更好的浏览器兼容性，但也存在如上所述不可逾越的性能问题与编码的烦琐性，这便有了下面一种新的实现方式。</p>
<h3 id="三、实现图片的延迟加载-Intersection-Observer方式"><a href="#三、实现图片的延迟加载-Intersection-Observer方式" class="headerlink" title="三、实现图片的延迟加载: Intersection Observer方式"></a>三、实现图片的延迟加载: Intersection Observer方式</h3><p>​		现代浏览器已大多支持了Intersection Observer API,可以通过它来检查目标元素的可见性，这种方式的性能和效率都比较好。</p>
<p>​		关于Intersection Observer的概念和用法，可以参考阅读相关文档，这里用一句话简述:每当因页面滚动或窗口尺寸发生变化，使得目标元素(target) 与设备视窗或其他指定元素产生交集时，便会触发通过Intersection Observer API配置的回调函数，在该回调函数中进行延迟加载的逻辑处理，会比传统方式显得更加简洁而高效。</p>
<p>​		以下便是Intersection Observer 方式的具体实现，此方式仅需创建一个新的Observer,并在类名为lazy的<img>标签进入视窗后触发回调。</p>
<pre><code class="js">document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;
  var lazyImages = [].slice.call(document.querySelectorAll(&quot;img.lazy&quot;));
  //判断浏览器兼容性
  if (
    &quot;Intersectionobserver&quot; in window &amp;&amp;
    &quot;IntersectionObserverEntry&quot; in window &amp;&amp;
    &quot;intersectionRatio&quot; in window.Intersection0bserverEntry.prototype
  ) &#123;
    //新建Intersectionobserver对象，并在其回调函数中实现关键加载逻辑
    let lazyImageObserver = new IntersectionObserver(function (
      entries,observer
    ) &#123;
      entries.forEach(function (entry) &#123;
        //判断图片是否出现在视窗中
        if (entry.isIntersecting) &#123;
          let lazyImage = entry.target;

          lazyImage.src = lazyImage.dataset.src;
          //图片加载完成后，取消监控防止重复加载
          lazyImage.classList.remove(&quot;lazy&quot;);
          lazyImageObserver.unobserve(lazyImage);
        &#125;
      &#125;);
    &#125;);
    lazyImages.forEach(function (lazyImage) &#123;
      lazyImageObserver.observe(lazyImage);
    &#125;);
  &#125;
&#125;);
</code></pre>
<p>​		这种方式判断元素是否出现在视窗中更为简单直观，应在实际开发中尽量使用，但其问题是并非所有浏览器都能兼容。具其体的浏览器兼容情况可在站点上进行查看，根据网站用户的硬件分布情况来权衡是否使用，以及使用后是否需要进行兼容处理。在将这种方式引入项目之前，应当确保已做到以下两点。</p>
<p>（1）做好尽量完备浏览器兼容性检查，对于兼容Intersection Observer API的浏览器，采用这种方式进行处理，而对于不兼容的浏览器，则切换回传统的实现方式进行处理。</p>
<p>（2）使用相应兼容的polyfill插件，在W3C官方Git账号下就有提供。除此之外，还有第三种通过Css属性的实现方案。</p>
<h3 id="四、实现图片的延迟加载：CSS类名方式"><a href="#四、实现图片的延迟加载：CSS类名方式" class="headerlink" title="四、实现图片的延迟加载：CSS类名方式"></a>四、实现图片的延迟加载：CSS类名方式</h3><p>​		这种实现方式通过css的 backgound-image 属性来加载图片，与判断<img>标签src属性是否有要请求图片的URL不同，Css中图片加载的行为建立在浏览器对文档分析基础之上。</p>
<p>​		具体来说，当DOM树、CSSOM树及渲染树生成后，浏览器会去检查CSS以何种方式应用于文档，再决定是否请求外部资源。如果浏览器确定涉及外部资源请求的CSS规则在当前文档中不存在时，便不会去请求该资源。图片列表如下所示:</p>
<pre><code class="html">&lt;div class=&quot;wrapper&quot;&gt;
&lt;div class=&quot;lazy-background one&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;lazy-background two&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;lazy-background three&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>​		具体的实现方式是通过javascript来判断元素是否出现在视窗中的，当在视窗中出现的时候，为其class属性添加visible类名，而在css文件中，为同一类名元素定义出带 .visible和不带.visible的两种包含 background-image规则。</p>
<p>​		不带 .visible的图片规则中的background-image属性可以是低分辨辨率的图片或Base64图片，而带.visible的图片规则中的background-image属性为为希望展示的真实图片URL.</p>
<p>​		具体JavaScript的实现过程如下所示，判断图片元素是否出现在视窗内的逻辑，与上面的Intersection Observer 方式相同。同样为了确保浏览器的兼容性，在实际应用中应确保提供回退方案或polyfill。</p>
<h3 id="五、原生的延迟加载支持"><a href="#五、原生的延迟加载支持" class="headerlink" title="五、原生的延迟加载支持"></a>五、原生的延迟加载支持</h3><p>​		除了上述通过开发者手动实现延迟加载逻辑的方式，从Chrome 75版本开始，已经可以通过 img 和 ifram e标签的loading属性原生支持延迟加载了，loading 属性包含以下三种取值。</p>
<ul>
<li>lazy: 进行延迟加载。</li>
<li>eager: 立即加载。</li>
<li>auto:浏览器自行决定是否进行延迟加载。</li>
</ul>
<p>若不指定任何属性值，loading 默认取值auto。</p>
<p>​		之前讲到延迟加载的独发触发机，都是当目标图像文件经页面滚动出现在屏幕视窗中时，能发对图像资源的请求。但从体验上考虑，这样处理并不完美，因为当图像标签出现在屏幕视窗中时，还只是占位符图像。</p>
<p>​		如果网络存在延迟或图像资源过大，那么它的请求加载过程是可以被用户感知的。更好的做法是在图像即将滚动出现在屏幕视窗之前一段距离， 就开始请求加载图像或iframe中的内容，这样能很好地缩短用户的等待加载时长。</p>
<p>​		兼容性处理:通过使用新技术优化了延迟加载的实现方式，同时也应当注意新技本在不同览器之间的兼容性，在使用前需要对浏览器特性进行检查，如下所示:</p>
<pre><code class="js">&lt;script&gt;
if (&#39;loading&#39; in HTMLImageElement . prototype)&#123;
//浏览器支持loading=&quot;lazy&quot;的延迟加载方式
&#125; else &#123;
//获取其他JavaScript库来实现延迟加载
&#125;
&lt;/script&gt;
</code></pre>
<p>​	当判断浏览器支持通过属性loading&#x3D;”lazy”来进行延迟加载时，我们就在JavaScript处理程序中，将真实图像资源的URL赋值在其src属性上。而对于不支持该属性配置的延迟加载方式，就需要默认将真实图像资源的URL挂在data-src 属性上，仅当延迟加载的滚动事件触发时，才将data-src属性上的值换到src属性上。</p>
<p>​		这也正是我们在传统方式中实现的加载策略，其原因是如果浏览器不支持<img>标签的loading属性，便会立刻发起对src 属性上URL资源的网络请求。当然我们也可以使用CSS类名的方式触发对资源的加载。</p>
<p>&lt; img data-src&#x3D; “photo.jpg” loading&#x3D;”lazy” class&#x3D;”lazyload” alt&#x3D;”photo” &#x2F;&gt;不过对于这种方式，笔者建议等到loading属性在浏览器的稳定版本中被引入后，再在项目的生产环境中使用。</p>
<h3 id="参考书籍：前端性能优化"><a href="#参考书籍：前端性能优化" class="headerlink" title="参考书籍：前端性能优化"></a>参考书籍：前端性能优化</h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/" rel="tag">加载优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-图像优化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/"
    >图像优化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2023-01-09T03:23:30.000Z" itemprop="datePublished">2023-01-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/">图像优化</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="图像优化"><a href="#图像优化" class="headerlink" title="图像优化"></a>图像优化</h1><blockquote>
<p>前端大部分的工作都围绕在JavaScript和CSS上，考虑如何更快地下载文件，如何提供给用户复杂而优雅的交互，如何高效合理地应用有限的处理和传输资源等，这些是用户感知的全部吗?</p>
<p>当然，他们在前端开发和性能优化中的地位举足轻重，但JavaScript和CSS对用户感知而言，并不是最重要的部分，图像才是。我们在公众号发布文章或用PPT进行演讲时，都知道一条高效传递信息的原则:字不如表，表不如图。</p>
<p>网站作为一种信息传递的媒介，且如今各类Web项目中，图像资源的使用占比也越来越大，更应当注重图像资源的使用方式。如果网站中的图像资源未进行恰当的优化，那么势必会导致许多问题，诸如巨量的访问请求引发传输带宽的挑战，请求大尺寸图片需要过久的等待时间等。</p>
<p>图像优化问题主要可以分为两方面:图像的选取和使用，图像的加载和显示。对于加载方面的策略将放在 加载优化 中深入讨论,本章将聚焦图像的选取和使用。本章内容包括:什么是图像文件，都有哪些格式的图像文件，不同格式的图像文件适用于怎样的业务场景，以及通过怎样的优化方法能够有效提升用户对图像的体验感知等。</p>
</blockquote>
<h3 id="一、图像基础"><a href="#一、图像基础" class="headerlink" title="一、图像基础"></a>一、图像基础</h3><p>​	HTTP Archive上的数据显示，网站传输的数据中，60%的资源都是由各种图像文件组成的，当然这个数据是将各种类型网站平均之后的结果，要是单独看电商类面向消费者端页面的数据，这个比例可能会更大。如此之大的资源占比，也同样意味着存在很大的优化空间。</p>
<h4 id="1-图像是否必需"><a href="#1-图像是否必需" class="headerlink" title="1.图像是否必需"></a>1.图像是否必需</h4><p>​		图像资源优化的根本思想，可以归结为两个字: 压缩。无论是选取何种图像的文件格式，还是针对同一种格式压缩至更小的尺寸，其本质都是用更小的资源开销来完成图像的传输和展示。</p>
<p>​		在深入探讨之前，我们首先思考一下要达到期望的信息传递效果，是否真的需要图像?这不仅是因为图像资源与网页上的其他资源(HTML&#x2F;CSS&#x2F;JavaScript等)相比有更大的字节开销，出于对节省资源的考虑，对用户注意力的珍惜也很重要，如果一个页面打开后有很多图像，那么用户其实很难快速梳理出有效的信息，即便获取到了也会让用户觉得很累。</p>
<p>​		一个低感官体验的网站，它的价值转化率不会很高。当然这个问题的答案不是通过自己简单想想就能得到的，我们可能需要在日常的开发中与产品经理及体验设计师不断沟通，不断思考，来趋近更优的方案。</p>
<p>​		当确定了图像的展示效果必须存在时，在前端实现上也并非一定就要用图像文件，还存在一些场景可以使用更高效的方式来实现所需的效果。</p>
<ul>
<li>网站中一个图像在不同的页面或不同的交互状态下，需要呈现出不同的效果(边角的裁切、阴影或渐变)，其实没有必要为不同场景准备不同效果的多份图像文件，只需用CSS将一-张图像处理为所需的不同效果即可。相对于一个图像文件的大小来讲，修改其所增加的CSS代码量可以忽略不计。</li>
<li>如果一个图像上面需要显示文字，建议使用网页字体的形式通过前端代码进行添加，而不是使用带文字的图像，其原因一方面是包含了更多信息的图像文件一般会更大， 另一方面是图像中的文本信息带来的用户体验一般较差 (不可选择、搜索及缩放)，并且在高分辨率设备上的显示效果也会打折扣。</li>
</ul>
<p>这里列举的两个例子，为了说明当我们在选择使用某种资源之前，如果期望达到更优的性能效果，则需要先去思考这种选择是否必需。</p>
<h4 id="2-矢量图和位图"><a href="#2-矢量图和位图" class="headerlink" title="2.矢量图和位图"></a>2.矢量图和位图</h4><p>​		当确定了图像是实现展示效果的最佳方式时，接下来就是选择合适的图像格式。图像文件可以分为两类:矢量图和位图。每种类型都有其各自的优缺点和适用场景。</p>
<p>1.矢量图</p>
<p>​		矢量图中的图形元素被定义为一个对象，包括颜色、大小、形状及屏幕位置等属性。它适合如文本、品牌logo、控件图标及二维码等构图形状较简单的几何图形。矢量图的 优点 是能够在任何缩放比例下呈现出细节同样清晰的展示效果。其缺点是对细节的展示效果不够丰富，对足够复杂的图像来说，比如要达到照片的效果，若通过SVG进行矢量图绘制，则所得文件会大得离谱，但即便如此也很难达到照片的真实效果。</p>
<p>​		SVG也是一种基于XML的图像格式，其全称是Scalable Vector Graphics (可缩放的矢量图形)，目前几乎所有浏览器都支持SVG.我们可以在Iconfont.上找到许多矢量图，或者上传自己绘制的矢量图，在上面构建自己的矢量图标库并引入项目进行使用，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230108155047156.png" alt="矢量图标"></p>
<p>标识照片的矢量图标的SVG标签格式，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230108155303100.png"></p>
<p>​		SVG标签所包括的部分就是该矢量图的全部内容，除了必要的绘制信息，可能还包括一些元数据，比如XML命名空间、图层及注释信息。但这些信息对浏览器绘制一个 SVG来说并不是必要的，所以在使用前可通过工县去除这些元数据来达到压缩的目的。</p>
<p>2.位图</p>
<p>​		位图是通过对一个矩阵中的栅格进行编码来表示图像的，每个栅格只能编码表示一个特定的颜色，如果组成图像的栅格像素点越多且每个像素点所能表示的颜色范围越广，则位图图像整体的显示效果就会越逼真。虽然位图没有像矢量图那种不受分辨率影响的优秀特性，但对于复杂的照片却能提供较为真实的细节体验，如图中一幅海边的位图对于云朵及波浪的细节表现，如果用矢量图来实现是不可想象的。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230108160504567.png" alt="海边的位图"></p>
<p>​		当把图像不断放大后，就会看到许多栅格像素色块，如图所示。每个像素存储的是图像局部的RGBA信息，即红绿蓝三色通道及透明度。通常浏览器会为每个颜色通道分配一个字节的存储空间，即2^8&#x3D;256个色阶值。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230108160613742.png" alt="放大后的位图局部"></p>
<p>​		一个像素点4个通道就是4字节，一张图像整体的大小与其包含的像素数成正比，图像包含的像素越多，所能展示的细节就越丰富，同时图像就越大。</p>
<p>​		如表所示，当图像尺寸为100像素 x 100像素时，文件大小为39KB.随着图像尺寸在长和宽两个维度上同时增大，所产生像素数量的增加就不是简单的线性关系了，而是平方的抛物线增加，也就是说文件大小会迅速增加，在网络带宽一 定的前提下，下载完张图像会更慢。</p>
<table>
<thead>
<tr>
<th>图像尺寸</th>
<th>像素数量</th>
<th>文件大小</th>
</tr>
</thead>
<tbody><tr>
<td>100像素 x 100像素</td>
<td>10,000</td>
<td>39KB</td>
</tr>
<tr>
<td>200像素 x 200像素</td>
<td>40,000</td>
<td>156KB</td>
</tr>
<tr>
<td>500像素 x 500像素</td>
<td>250,000</td>
<td>977KB</td>
</tr>
<tr>
<td>800像素 x 800像素</td>
<td>640,000</td>
<td>2.5MB</td>
</tr>
</tbody></table>
<p>​		出于对性能的考虑，在使用图像时必须考虑对图像进行压缩，采用什么样的图像格式，使用什么样的压缩算法及压缩到何种程度，这将是本章接下来详细讨论的内容，但在此之前先说明关于分辨率的两个容易混淆的概念。</p>
<h4 id="3-分辨率"><a href="#3-分辨率" class="headerlink" title="3.分辨率"></a>3.分辨率</h4><p>​		在前端开发过程中书写CSS时，经常会为图像设置显示所需的长宽像素值，但在不同的设备屏幕上，有时候相同的图像及相同的设置，其渲染出来的图像会让人明显察觉出清晰度有差别。产生这个现象的原因涉及两种不同的分辨率:屏幕分辨率和图像分辨率。</p>
<p>​		图像分辨率表示的就是该图像文件所包含的真实像素值信息，比如一个 200像素X200像素的分辨率的图像文件，它就定义了长宽各200个像素点的信息。设备分辨率则是显示器屏幕所能显示的最大像素值，比如一台13英寸的Mac Pro 笔记本电脑的显示器分辨率为2560像素 x 1600像素。这两种分辨率都用到了像素，那么它们有什么区别呢?</p>
<p>​		更高的设备分辨率有助于显示更绚丽多彩的图像，这其实很话合矢量图的发挥，因为它不会因放大而失真。而对位图来说，只有图像文件包含更多的像素信息时，才能更充分地利用屏幕分辨率。为了能在不同的分辨率下使项目中所包含的图像都能得到恰当的展示效果，可以利用picture标签和srcset 属性提供图像的多个变体。</p>
<p>​		用于插入图像的ing标签，有一个 srcset属性可以用来针对不同设备，提供不同分辨率的图像文件:</p>
<pre><code class="html">&lt; img src=&quot;photo.jpg&quot; srcset=&quot;photo@2x.jpg 2x,photo@3x.jpg 3x, photo@4x.jpg 4x&quot; alt=&quot;photo&quot;&gt;
</code></pre>
<p>​		除了IE和其他较低版本的浏览器不支持，目前主流的大部分浏览器都已支持img标签的srcset 属性。在srcset属性中设置多种分辨率的图像文件及使用条件，浏览器在请求之前便会先对此进行解析，只选择最合适的图像文件进行下载，如果浏览器不支持，请务必在src属性中包含必要的默认图片。</p>
<p>​		使用picture标签则会在多图像文件选择时，获得更多的控制维度，比如屏幕方向、设备大小、屏幕分辨率等。</p>
<pre><code class="html">&lt;picture&gt;
  &lt;source media=&quot; (min-width:800px)&quot; srcset=&quot;photo.ipg, photo-2x.jpg 2x&quot;&gt;
  &lt;source media=&quot; (min-width:450px)&quot; srcset=&quot;photo-s.jpg photo-s-2x.jpg 2x&quot;&gt;
  &lt; img src=&quot;photo.jpg&quot;&gt;
&lt;/picture&gt;
</code></pre>
<p>​		由于picture标签也是加入标准不久的元素标签，所以在使用过程中，同样应当考虑兼容性问题。</p>
<h4 id="4-压缩的有损和无损"><a href="#4-压缩的有损和无损" class="headerlink" title="4.压缩的有损和无损"></a>4.压缩的有损和无损</h4><p>​		压缩是降低源文件大小的有效方式，对JavaScript代码或网页的一些脚本文件而言，压缩掉的内容是一些多余的空格及不影响执行的注释，其目的是在不损坏正常执行的情况下，尽量缩小源文件的大小。对图像文件而言，由于人眼对不同颜色的敏感度存在差异，所以便可通过减少对某种颜色的编码位数来减小文件大小，甚至还可以损失部分源文件信息，以达到近似的效果，使得压缩后的文件尺寸更小。</p>
<p>​		对于图像压缩，应该采用有损压缩还是无损压缩?如果都采用又该如何搭配设置呢?当结合了具体的业务需求再考虑后，关于压缩的技术选型就可以简单分成两步进行。</p>
<p>（1）首先确定业务所要展示图像的颜色阶数、图像显示的分率及清晰程度，当锚定了这几个参数的基准后，如果获取的图像源文件的相应参数指标过高，便可适当进行有损压缩，通过降低源文件图像质量的方法来降低图像文件大小。</p>
<p>​		如果业务所要求的图像质量较高，便可跳过有损压缩，直接进入第二步无损压缩。所以是否要进行有损压缩，其实是在理解了业务需求后的一个可选选项，而非必要的。</p>
<p>（2）当确定了展示图像的质量后，便可利用无损压缩技术尽可能降低图像大小。和第(1)步要通过业务决策来判断是否需要所不同的是，无损压缩是应当完成的工作环节。那么最好能通过一套完善的工程方案，自动化执行来避免烦琐的人工重复工作。</p>
<h3 id="二、图像格式"><a href="#二、图像格式" class="headerlink" title="二、图像格式"></a>二、图像格式</h3><p>​		实际上，不同的图像文件格式(JPG、PNG、GIF 等)之间的区别，在于它们进行有损压缩和无损压缩过程中采用了不同的算法组合，接下来我们将从不同的图像文件格式入手，看看它们的特点和使用场景，以及在具体业务中应该如何选取。</p>
<h4 id="1-JPEG"><a href="#1-JPEG" class="headerlink" title="1.JPEG"></a>1.JPEG</h4><p>​		JPEG可能是目前所有图像格式中出现最早，同时也是使用范围最广的一种格式。它也是一种有损压缩算法，它通过去除相关冗余图像和色彩数据等方式来获得较高的压缩率，同时还能展现出相当丰富的图像内容。</p>
<p>​		JPEG在网站开发中经常被用作背景图、轮播图或者一些商品的banner图，以呈现色彩丰富的内容。但由于是有损压缩，当处理Logo或图标时，需要较强线条感和强烈颜色对比，JPEG图像可能会出现一些边 界模糊的不佳体验，另外JPEG图像并不支持透明度。</p>
<p>​		接下来介绍有关JPEG常用的压缩编码方式，以及在工程实践中如何自动批量处理。</p>
<p>1.压缩模式</p>
<p>​		JPEG包含了多种压缩模式，其中常见的有基于基线的、渐进式的。简单来说基线模式的JPEG加载顺序是自上而下的，当网络连接缓慢或不稳定时，其是从上往下逐渐加载完成的，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230108163309301.png" alt="基线JPEG"></p>
<pre><code>     渐进式模式是将图像文件分为多次扫描，首先展示一个低质量模糊的图像，随着扫描到的图像信息不断增多，每次扫描过后所展示的图像清晰度也会不断提升，如图所示。
</code></pre>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109080817397.png" alt="渐进式JPEG"></p>
<p>2.渐进式JPEG的优缺点</p>
<p>​		渐进式JPEG的优点是显而易见的，在网络连接缓慢的情况下，首先能快速加载出一个图像质量比较模糊的预览版本。这样用户便可据此了解图像的大致内容，来决定是否继续花费时间等待完整图像的加载。这样做可以很好地提高对用户的感知性能，用户不仅知道所访问图像的大致内容，还会感知完整的图像就快加载好了。如果读者平时留心观察，应该能注意到渐进式JPEG已经在渐渐取代基线JPEG了。</p>
<p>​		通过了解两种压缩的原理不难发现，渐进式JPEG的解码速度会比基线的要慢一些，因为它增加了重复的检索开销。另外，通过渐进式JPEG压缩模式得到的图像文件也不一定是最小的，比如特别小的图像。所以是否要采用渐进式JPEG,需要综合考虑文件大小、大部分用户的设备类型与网络延迟。</p>
<p>3.创建渐进式JPEG</p>
<p>​		如果所得到的图像不是渐进式JPEG,那么我们可以通过许多第三方工具来进行处理，例如imagemin、libjpeg、 imageMagick 等。值得注意的是，这个步骤应当尽量交给构建工具来自动化完成，通过如下代码可以将该工作加入gulp处理管道:</p>
<pre><code class="javascript">const gulp = require(&#39;gulp&#39;);
const imagemin = require(&#39;gulp-imagemin&#39;);
gulp.task(&#39;images&#39;,()=&gt; 
    gulp.src(&#39;images/*.jpg&#39;)
    .pipe(imagemin(&#123;
        progressive:true
    &#125;))
    .pipe(gulp.dest(&#39;dist&#39;))
);
</code></pre>
<p>在执行构建流程后，gulp 会调用imagemin的方法把images 文件夹下的所有jpg后缀图像全部进行渐进式编码处理。</p>
<p>4.其他JPEG编码方式</p>
<p>​		除了常见的基线与渐进式压缩编码方式，最近还出现了几种现代的JPEG编码器，它们尝试以更高的保真度及压缩后更小的文件大小为目标，同时还兼容当前主流的浏览器。其中比较出色的有Mozilla基金会推出的MozJPEG和Google提出的Guetzli。</p>
<p>​		MozJPEG和Guetzli也都已经有了可靠的imagemin插件支持，其使用方式与渐进式JPEG处理方式类似，这里仅列出示例代码，具体工程化构建请读者结合项目实践进行改写。</p>
<pre><code class="javascript"> const gulp = require(&#39;gulp&#39;);
const imagemin = require (&#39;gulp-imagemin&#39;);
const imageminMozJPEG = require (&#39;imagemin-mozjpeg&#39;); //引入MozJPEG依赖包
const imageminGuetzli = require (&#39;imagemin-guetzli&#39;); //引入Guetzli依赖包
//MozJPEG压缩编码
gulp. task(&#39;mozjpeg&#39;, () =&gt;
    gulp.src(&#39;image/*. jpg&#39;)
    .pipe (imagemin([
        imageminMozJPEG(&#123;quality: 85 &#125;)
    ]))
    .pipe(gulp.dest(&#39;dist&#39;))
)
//Guetzli压缩编码
gulp.task(&#39;guetzli&#39;, () =&gt;
    gulp.src(&#39;image/* . jpg&#39;)
    .pipe (imagemin([
        imageminGuetzli (&#123;quality: 85 &#125;)
    ]))
    .pipe (gulp.dest(&#39;dist&#39;))
)
</code></pre>
<p>​		MozJPEG引入了对逐行扫描的优化及一些栅 格量化的功能，最多能将图像文件压缩10%，而Guetzli则是找到人眼感知上无法区分的最小体积的JPEG,那么两者的优化效果具体如何，又如何评价呢?</p>
<p>​		这里需要借助两个指标来进行衡量，首先是用来计算两个图像相似度的结构相似性分数(Structural Similarity index),简称SSIM,具体的计算过程可以借助第三方工具jpeg-compress 来进行，这个指标分数以原图为标准来判断测试图片与原图的相似度，数值越接近1表示和原图越相似。</p>
<p>​		Butteraugli则是一种基 于人类感知测量图像的差异模型，它能在人眼几乎看不出明显差异的地方，给出可靠的差别分数。如果SSIM是对图像差别的汇总，那么Butteraugli则可以帮助找出非常糟糕的部分。表列出了MozJPEG编码压缩后的数据比较。</p>
<table>
<thead>
<tr>
<th>原图大小 982 KB</th>
<th>Q&#x3D;90 &#x2F; 841KB</th>
<th>Q&#x3D;85 &#x2F; 562KB</th>
<th>Q&#x3D;75 &#x2F;324KB</th>
</tr>
</thead>
<tbody><tr>
<td>SSIM</td>
<td>0.999936</td>
<td>0.999698</td>
<td>0.999478</td>
</tr>
<tr>
<td>Butteraugli</td>
<td>1.576957</td>
<td>2.483837</td>
<td>3.66127</td>
</tr>
</tbody></table>
<p>​																	MozJPEG编码压缩后的数据比较</p>
<table>
<thead>
<tr>
<th>原图大小 982 KB</th>
<th>Q&#x3D;100 &#x2F; 945KB</th>
<th>Q&#x3D;90 &#x2F; 687KB</th>
<th>Q&#x3D;85 &#x2F; 542KB</th>
</tr>
</thead>
<tbody><tr>
<td>SSIM</td>
<td>0.999998</td>
<td>0.99971</td>
<td>0.999508</td>
</tr>
<tr>
<td>Butteraugli</td>
<td>0.40884</td>
<td>1.580555</td>
<td>2.0996</td>
</tr>
</tbody></table>
<p>​																	Guetzli编码压缩后的数据比较</p>
<p>不仅要考虑图像压缩的质量和保真度，还要关注压缩后的大小，没有哪种压缩编码方式在各种条件下都是最优的，需要结合实际业务进行选择。这里可以给读者一些使用建议:</p>
<ul>
<li>使用一些外部工具找到图像的最佳表现质量后，再用MozJPEG进行编码压缩。</li>
<li>Guetzli会获得更高质量的图像，压缩速度相对较慢。</li>
</ul>
<p>​		虽然本节介绍了关于JPEG的若干编码器，也对它们之间的差别进行了比较，但需要明确的一点是，最终压缩后的图像文件大小差异更多地取决于设置的压缩质量，而非所选择的编码器。所以在对JPEG进行编码优化时，应主要关注业务可接受的最低图像质量。</p>
<h4 id="2-GIF"><a href="#2-GIF" class="headerlink" title="2.GIF"></a>2.GIF</h4><p>​		GIF是Graphics Interchange Format的缩写，也是一种比较早的图像文件格式。 由于对支持颜色数量的限制，256色远小于展示照片所需颜色的数量级，所以GIF并不适合用来呈现照片，可能用来呈现图标或Logo会更适合些， 但后来推出的PNG格式对于图形的展示效果更佳，所以当下只有在需要使用到动画时才会使用GIF。</p>
<p>接下来探讨一些关于GIF的优化点。</p>
<ol>
<li>单帧的GIF转化为PNG</li>
</ol>
<p>​		首先可以使用npm引入ImageMagick工具来检查GIF图像文件，看其中是否包含多帧动画。如果GIF图像文件中不包含多帧动画，则会返回一个GIF字符串，如果GIF图像文件中包含动画内容，则会返回多帧信息。</p>
<p>​		对于单帧图像的情况，同样可使用ImageMagick工具将其转化为更适合展示图形的PNG文件格式。对于动画的处理稍后会进一步介绍， 这里先列出代码示例:</p>
<pre><code class="javascript">const im = require(&#39;imagemagick&#39;);
//检查是否为动画
im.identify([&#39;-format&#39;,&#39;%m&#39;,&#39;my.gif&#39;],(err,output)=&gt;&#123;
    if (err) throw err;
    //通过output处理判断流程
&#125;)
//将gif转化为png
im.convert([&#39;my.gif&#39;,&#39;my.png&#39;],(err,stdout)=&gt;&#123;
    if (err) throw err;
    console.log(&#39;转化完成&#39;,stdout)
&#125;)
</code></pre>
<ol start="2">
<li>GIF 动画优化</li>
</ol>
<p>​		由于动画包含了许多静态帧，并且每个静态帧图像上的内容在相邻的不同帧上通常不会有太多的差异，所以可通过工具来移除动画里连续帧中重复的像素信息。这里可借助gifsicle来实现:</p>
<pre><code class="javascript">const &#123; execFile &#125; = require(&#39;child_process&#39;);
const gifsicle = require(&#39;gifsicle&#39;);
execFile(gifsicle,[&#39;-o&#39;,&#39;output.gif&#39;,&#39;input.gif&#39;],err =&gt; &#123;
    console.log(&#39;动画压缩完成&#39;)
&#125;)
</code></pre>
<ol start="3">
<li>用视频替换动画</li>
</ol>
<p>​		当了解过GIF的相关特性后，不难发现如果单纯以展示动面这个目的来看，那么GIF可能并不是最好的呈现方式，因为动画的内容将会受到诸如图像质量、播放帧率及播放长度等因素的限制。</p>
<p>​		GIF展示的动画没有声音，最高支持256色的图像质量，如果动画长度较长， 即便压缩过后文件也会较大。综合考虑，建议将内容较长的GIF动画转化为视频后进行插入，因为动画也是视频的一种， 成熟的视频编码格式可以让传输的动画内容节省网络带宽开销。</p>
<p>​		可以利用ffmpeg将原本的GIF文件转化为MPEG-4或WebM的视频文件格式，将一个14MB的GIF动画通过转化后得到的视频文件格式大小分别是: MPEG-4格式下867KB, WebM 格式下611KB.另外，要知道通过压缩后的动画或视频文件，在播放前都需要进行解码，可以通过Chrome的跟踪工具(chrome:&#x2F;&#x2F;tracing)查看不同格式的文件，在解码阶段的CPU占用时，文件格式与CPU耗时如表所示。</p>
<table>
<thead>
<tr>
<th>文件格式</th>
<th>CPU耗时（ms）</th>
</tr>
</thead>
<tbody><tr>
<td>GIF</td>
<td>2,668</td>
</tr>
<tr>
<td>MPEG-4</td>
<td>1,995</td>
</tr>
<tr>
<td>WebM</td>
<td>2,354</td>
</tr>
</tbody></table>
<p>​		从表中可以看出，相比视频文件，GIF 在解码阶段也是十分耗时的，所以出于对性能的考虑，在使用GIF前应尽量谨慎选择。</p>
<h4 id="3-PNG"><a href="#3-PNG" class="headerlink" title="3.PNG"></a>3.PNG</h4><p>​		PNG是一种无损压缩的高保真图片格式，它的出现弥补了GIF图像格式的一些缺点，同时规避了当时GIF中还处在专利保护期的压缩算法，所以也有人将PNG文件后缀的缩写表示成“PNG is Not GIF”。</p>
<p>​		相比于JPEG, PNG支持透明度，对线条的处理更加细腻，并增强了色彩的表现力，不过唯一的不足就是文件体积太大。如果说GIF是专门为图标图形设计的图像文件格式，JPEG是专门为照片设计的图像文件格式，那么PNG对这两种类型的图像都能支持。通常在使用中会碰到PNG的几种子类型，有PNG-8、PNG-24、 PNG-32等。</p>
<p>1.对比GIF</p>
<p>​		其中PNG-8也称为调色板PNG,除了不支持动画，其他所有GIF拥有的功能它都拥有，同时还支持完全的alpha通道透明。只要不是颜色数特别少的图像，PNG-8的压缩比表现都会更高一筹。</p>
<p>​		对于颜色数少的单帧图形图像来说，更好的做法也并不是将其存为一个GIF文件，相比雪碧图都会更好一些，因为能够大大降低HTTP请求的开销，这一点后面章节会接着介绍，此处给出个优化建议: 在使用单帧图形图像时，应当尽量用 PNG-8格式来替换GIF格式。</p>
<p>2.对比JPEG</p>
<p>​		当所处理图像中的颜色超过256种时，就需要用到JPEG或者真彩PNG,真彩PNG包括PNG-24和PNG-32二者的区别是真彩PNG-24不包括alpha透明通道，而加上8位的alpha透明通道就是真彩PNG-32。</p>
<p>​		JPEG是有损的。它拥有更高的压缩比，也是照片存储的实际标准，如果还是要用PNG,那么很可能是在清晰的颜色过度周围出现了不可接受的“大色块”。</p>
<p>3.优化PNG</p>
<p>​		PNG图像格式还有一个优点，就是便于扩展，它将图像的信息保存在“块”中，开发者便可以通过添加一些自定义的“块”来实现额外的功能，但所添加的自定义功能并非所有软件都能读取识别，大部分可能只是特定的作图软件在读取时使用而已。对Web显示而言，浏览器可能直接将这些多余的块自动忽略掉了，如果对显示没有作用，那么又何必要存储和传输这些信息呢?因此我们可以使用pngcrush对这些多余的块进行删除压缩，通过npm引入imagemin-pngcrush,代码如下:</p>
<pre><code class="javascript">const imagemin = require(&#39;imagemin&#39;);
const imageminPngcrush = require(&#39;imagemin-pngcrush&#39;);
imagemin([&#39;images/*.png&#39;],&#39;build/images&#39;,&#123;
    plugins:[imageminPngcrush()]
&#125;)
.then(()=&gt; console.log(&#39;完成图像优化&#39;))
</code></pre>
<p>其中，imageminPngcrush()中可以带入如下一些 参数进行压缩控制。</p>
<ul>
<li>-rem alla: 删除所有块，保留控制alpha透明通道的块。</li>
<li>-brute: 采用多种方法进行压缩会得到较好的压缩效果，由于执行的方法较多，所以执行压缩的速度会变慢，建议在离线操作下可以添加，但有时改进效果并不明显，如果对构建流程有要求可不加。</li>
<li>-reduce: 会尝试减少调色板使用的颜色数量。</li>
</ul>
<h4 id="4-WebP"><a href="#4-WebP" class="headerlink" title="4.WebP"></a>4.WebP</h4><p>​		前面介绍的三种图像文件格式，在呈现位图方面各有优劣势: GIF虽然包含的颜色阶数少，但能呈现动画: JPEG虽然不支持透明度，但图像文件的压缩比高:PNG虽然文件尺寸较大，但支持透明且色彩表现力强。</p>
<p>​		开发者在使用位图时对于这样的现状就需要先考虑选型。假如有一个统的图像文件格式，具有之前格式的所有优点，WebP 就在这样的期待中诞生了。</p>
<ol>
<li>WebP的优缺点</li>
</ol>
<p>​		WebP是Google在2010年推出的一种图像文件格式， 它的目标是以较高的视觉体验为前提的，尽可能地降低有损压缩和无损压缩后的文件尺寸，同时还要支持透明度与动画。根据WebP官方给出的实验数据，当使用WebP有损文件时，文件尺寸会比JPEG小25%~ 34%，而使用WebP无损文件时，文件尺寸会比PNG小26%。就像所有新技术一样， 具有如此多优异特性的WebP, 同样也不可避免兼容性的问题，CanlUse. com网站数据统计情况，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109091411793.png"></p>
<p>​	从图中可以发现，除了IE不支持，其他主流浏览器的最新版本都已支持WebP, 考虑到浏览器的市场占有率，这样的兼容性程度可以说是非常乐观的了。虽然还需要做一 些兼容性处理，但我们也有足够的理由在项目中积极地使用WebP.此外，由于有损压缩WebP使用了VP8视频关键帧编码,可能对较高质量(80~ 99)的图像编码来说，会比JPEG占用更多的计算资源，但在较低质量(0~50)时，依然有很大的优势。</p>
<p>2.如何使用WebP</p>
<p>​		可以使用图像编辑软件直接导出WebP格式的图像文件，或者将原有的JPEG或PNG图像转化为WebP格式。这样的转化最好使用构建工具辅助完成，比如通过npm安装webp-loader后，在webpack中进行如下配置:</p>
<pre><code class="javascript">loader:[&#123;
    test:/\.(jpe?g|png)$/I,
    loaders:[
        &#39;file-loader&#39;,
        &#39;webp-loader?&#123;quality:13&#125;&#39;
    ],
&#125;]
</code></pre>
<p>​		这里值得注意的是，尽量不要使用低质量的JPEG格式进行WebP转化，因为低质量的JPEG中可能包含压缩的伪像，这样WebP不仅要保存图像信息，还要保存JPEG添加的失真，从而影响最终的转化效果。所以在选择转化的源图像文件时，建议使用质量最佳的。</p>
<p>3.兼容性处理</p>
<p>​		目前WebP格式的图像并不适用于所有浏览器，所以在使用时，应当注意兼容处理好不支持的浏览器场景。</p>
<p>​		通常的处理思路分为两种:一种是在前端处理浏览器兼容性的判断，可以通过浏览器的全局属性window.navigator. userAgent获取版本信息，再根据兼容支持情况，选择是否请求WebP图像格式的资源;也可以使用<picture>标签来选择显示的图像格式，在<picture> 标签中添加多个<source>标签元素，以及一个包含旧图像格式的<img>标签，当浏览器在解析DOM时便会对<picture>标签中包含的多个图片源依次进行检测。</p>
<p>​		倘若浏览器不支持WebP格式而未能检测获取到，最后也能够通过<img>标记兼容显示出旧图像格式，例如:</p>
<pre><code class="html">&lt;picture&gt;
   &lt;source srcset=&quot;/path/image.webp&quot; type=&quot;image/webp&quot;&gt;
   &lt;img src=&quot;/path/image.jpg&quot; alt=&quot;&quot;&gt;
&lt;/picture&gt;
</code></pre>
<p>这见需要注意的<source>标签的顺序位置，应当将包含image&#x2F;webp的图像源写在旧图像格式的前面。</p>
<p>​		另一种是将判断浏览器是否支持的工作放在后端处理，让服务器根据HTTP请求头的Accept字段来决定返回图像的文件格式。如果Accept 字段中包含image&#x2F;webp，就返回WebP图像格式，否则就使用旧图像格式(JPEG、PNG等)返回。这样做的好处是让系统的维护性更强，无论浏览器对WebP图像格式的兼容支持发生怎样的改变，只需要服务器检查Accept字段即可，无须前端跟进相应的修改。</p>
<h4 id="5-SVG"><a href="#5-SVG" class="headerlink" title="5.SVG"></a>5.SVG</h4><p>​		前面介绍的几种图像文件格式呈现的都是位图，而SVG呈现的是矢量图。正如我们在介绍位图和矢量图时讲到的，SVG对图像的处理不是基于像素栅格的，而是通过图像的形状轮廓、屏幕位置等信息进行描述的。</p>
<p>1.优缺点</p>
<p>​		SVG这种基于XML语法描述图像形状的文件格式，就适合用来表示Logo等图标图像，它可以无限放大并且不会失真，无论分辨率多高的屏幕，个文件就可以统一适配:另外，作为文本文件，除了可以将SVG标签像写代码样写在HTML中，还可以把对图标图像的描述信息写在以.svg为后缀的文件中进行存储和引用。</p>
<p>​		由于文本文件的高压缩比，最后得到的图像文件体积也会更小。要说缺点与不足，除了仅能表示矢量图，还有就是使用的学习成本和渲染成本比较高。</p>
<p>2.优化建议</p>
<p>即便SVG图像文件拥有诸多优点，但依然有可优化的空间。下面介绍一些优化建议。</p>
<p>（1）应保持SVG尽量精简，去除编辑器创建SVG时可能携带的一些冗余信息，比如注释、隐藏图层及元数据等。</p>
<p>（2）由于显示器的本质依然是元素点构成位图，所以在渲染绘制矢量图时，就会比位图的显示多一步光栅化的过程。为了使浏览器解析渲染的过程更快，建议使用预定义的SVG形状来代替自定义路径，这样会减少最终生成图像所包含标记的数量，预定义形状有<circle>、<recD>、 <line>、 <polygon>等。</p>
<p>（3）如果必须使用自定义路径，那么也尽量少用曲线。</p>
<p>（4）不要在SVG中嵌入位图。</p>
<p>（5）使用工具优化SVG,这里介绍一款基于node.js 的优化工具svgo;它可以通过降低定义中的数字精度来缩小文件的尺寸。通过npm install -g svgo 可直接安装命令方式使用，若想用webpack进行工程化集成，可加入svgo-loader的相关配置:</p>
<pre><code class="javascript">module.exports = &#123;
    rules:[
        test: /\.svg$/,
        use: [
            &#123;loader:&#39;file-loader&#39;&#125;,
            &#123;loader:&#39;svgo-loader&#39;,options:&#123;externalConfig:&#39;svgo-config.yml&#39;&#125;,
        &#125;]
    ]
&#125;
</code></pre>
<p>其中，可在 svgo-config.yml 的配置文件中定义相关优化选项：</p>
<pre><code class="java">plugins:
 - removeTitle: true
 - convertPathData: false
 - convertColors:
    shorthex: false
</code></pre>
<p>（6）优化过后，使用gzip压缩和（或）brotli压缩。</p>
<h4 id="6-Base64"><a href="#6-Base64" class="headerlink" title="6.Base64"></a>6.Base64</h4><p>​		准确地说，Base64 并不是一种图像文件格式， 而是种用于传输 8位字节码的编码方式，它通过将代表图像的编码直接写入HTML或CSS中来实现图像的展示，一般展示图像的方法都是通过将图像文件的URL值传给img标签的src属性，当HTML解析到img标签时，便会发起对该图像URL的网络请求:</p>
<p>&lt; img src&#x3D;”<a target="_blank" rel="noopener" href="https://xx.cdn.com/photo.jpg&quot;&gt;">https://xx.cdn.com/photo.jpg&quot;&gt;</a></p>
<p>​		当采用Base64编码图像时，写入src的属性值不是URL值，而是类似下面的编码:data: image&#x2F;png;base64, iVBORwOKGgOAAAANSUhEUgAABYAAAWCAYAADEtGw7AA.</p>
<p>​		浏览器会自动解析该编码并展示出图像，而无须发起任何关于该图像的URL，这是Base64的优点，同时也隐含了对于使用的限制。由于Base64编码原理的特点，一般经过Base64编码后的图像大小，会膨胀四分之三。</p>
<p>​		这对想尝试通过Base64方式尽可能减少HTTP请求次数来说是得不偿失的，较复杂的大图经过编码后，所节省的几次HTTP请求，与图像文件大小增加所带来的带宽消耗相比简直是杯水车薪。所以也只有对小图而言，Base64 才能体现出真正的性能优势。</p>
<p>​		作为使用指导建议，笔者希望在考虑是否使用Base64编码时，比对如下几个条件:</p>
<ul>
<li>图像文件的实际尺寸是否很小。</li>
<li>图像文件是否真的无法以雪碧图的形式进行引入。</li>
<li>图像文件的更新频率是否很低，以避免在使用Base64时，增加不心必要的维护成本。</li>
</ul>
<h4 id="7-格式选择建议"><a href="#7-格式选择建议" class="headerlink" title="7.格式选择建议"></a>7.格式选择建议</h4><p>​		在了解了不同图像文件格式的特性后，显而易见的是不存在适用于任何场景且性能最优的图像使用方式。所以作为开发者，想要网站性能在图像方面达到最优，如何根据业务场景选择合适的文件格式也至关重要，图像文件使用策略如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109101114259.png" alt="图像文件使用策略"></p>
<p>​		这里根据使用场景的不同，以及图像文件的特性给出了一个可参考的选择策略:考虑到矢量图具有缩放不失真且表示图标时较小的文件尺寸，凡用到图标的场景应尽量使用矢量图:而对于位图的使用场景，由于在相同图像质量下其具有更高的压缩比且支持动画，所以WebP格式应该是我们的首选。</p>
<p>​		考虑到新技术的兼容性问题，也需要采用传统的方式进行适配;包含动画时使用GIF,对图像要求有更高分辨率来展示细节且需要透明度时，建议使用PNG;而在其他场景下追求更高的图像压缩比时，可使用JPEG.除此之外，位图对于不同缩放比的响应式场景，建议提供多张不同尺寸的图像，让浏览器根据具体场景进行请求调用。</p>
<h3 id="三、使用建议"><a href="#三、使用建议" class="headerlink" title="三、使用建议"></a>三、使用建议</h3><p>​		本节额外给出些使用建议来优化图像 资源的体验性能， 包括合并多张小图资源请求次数的雪碧图方案，使用Web字体的方式来替代图标文件及display:none使用的注意事项。</p>
<h4 id="1-CSS-Sprite"><a href="#1-CSS-Sprite" class="headerlink" title="1.CSS Sprite"></a>1.CSS Sprite</h4><p>​		CSS Sprite技术就是我们常说的雪碧图，通过将多张小图标拼接成一张大图， 有效地减少HTTP请求数量以达到加速显示内容的技术。</p>
<p>​		通常对于雪碧图的使用场景应当满足以下条件:首先这些图标不会随用户信息的变化而变化，它们属于网站通用的静态图标;同时单张图标体积要尽量小，这样经过拼接后其性能的提升才会比较乐观;若加载量比较大则效果会更好。</p>
<p>​		不建议将较大的图片拼接成雪碧图，因为大图拼接后的单个文件体积会非常大，这样占用网络带宽的增加与请求完成所耗费时间的延长，会完全淹没通过减少HTTP请求次数所带来的性能提升。下面来看一个雪碧图实际案例，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109102349521.png"></p>
<p>​		图中截取了淘宝网一处图标导航栏及请求的相应资源，通过案例还可以看出所拼接的雪碧图是一张PNG格式的图像文件，其中的图标不只含有一种颜色， 同时也可支持颜色渐变，这通常是单色Web字体很难具备的表现力。</p>
<p>雪碧图的使用方式也很简单，通过CSS 的background-image 属性引入雪碧图的UrL后，再使用background-position定位所需要的单个图标在雪碧图上的起始位置，配合width和height属性来锁定具体图标的尺寸，示例代码如下:</p>
<pre><code class="css">.sprite-sheet&#123;
    background-image: url(https://img.xxxx.com/xxx/sprite-sheet.png);
    background-size: 24px 600px;
&#125;
.icon-1 .sprite-sheet&#123;
    background-position: 0 0;
    height: 24px;
    width: 24px;
&#125;
.icon-2 .sprite-sheet&#123;
    background-position: 0 -24px;
    height: 24px;
    width: 24px;
&#125;
</code></pre>
<p>​		其中，background-position属性关于横纵偏移的设置规则指的是如何通过设置背景图的偏移，将雪碧图上所需图标的左上角起始位置移至坐标(0,0)位置。与通常数学上的直角坐标系不同，浏览器中的坐标系Y轴正方向是垂直向下的。当引入雪碧图后，整个图片的左上角起始位置在(0,0)，所以要得到其中的某个图标，我们就需要将雪碧图向负轴方向进行偏移，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109105436897.png" alt="雪碧图与坐标系"></p>
<p>​		如果使用第一行左边第一 个图标，则可通过设置background-position: 0 0来让雪碧图不偏移(两个0之间有空格，分别表示在X轴、Y轴的位置)，倘若要使用第二行中间的图标，就需要将雪碧图向左上方偏移，将属性backgound-position的值设置为-24px -24px，注意是负值，如图所示。</p>
<p><img src="/2023/01/09/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/image-20230109105529239.png" alt="偏移后的雪碧图"></p>
<p>​		使用雪碧图来提升小图标加载性能的历史由来已久。在HTTP 1.x环境下，它确实能够减少相应的HTTP请求，但需要注意当部分图标变更时，会导致已经加载的雪碧图缓存失效。同时在HTTP2中，最好的方式应该是加载单张图像文件，因为可以在一个HTTP连接上发起多次请求，所以对于是否使用此方法，需要考虑具体的使用环境和网络设置。</p>
<h4 id="2-Web-字体"><a href="#2-Web-字体" class="headerlink" title="2.Web 字体"></a>2.Web 字体</h4><p>​		使用Web字体有多种优点:增强网站的设计感、可读性，同时还能搜索和选取所表示的文本内容，且不受屏幕尺寸与分辨率的影响，能提供一致的视觉体验。 除此之外，由于每个字型都是特定的矢量图标，所以可以将项目中用到的矢量图标打包到一个Web字体文件中使用，以节省对图标资源的HTTP请求次数，这样做类似雪碧图优化目的。</p>
<p>1.字体的使用</p>
<p>​		目前网络上常用的字体格式有: EOT、TTF、WOFF与WOFF2,由于存在兼容性的问题，并没有哪一种字体能够适用所有浏览器，所以在实际使用中，网站开发者会声明提供字体的多种文件格式，来达到一致性的体验效果。</p>
<p>在Web项目中，一般 会先通过@font-face声明使用的字体系列:</p>
<pre><code class="css">@font-face &#123;
font-family: &#39;tianfont&#39;;
src: url(&#39;//at.alicdn.com/t/font_ 1307911 xxxx.eot&#39;);
src: url(&#39;//at.alicdn.com/t/fot 1307911 xxx.eot?#iefix&#39;) format(&#39;enmbederopentype&#39;),
url(&#39;//at.alicdn.com/t/font_ 1307911 xxxx.woff2&#39;) format(&#39;woff2&#39;),
url(&#39;//at.alicdn.com/t/font_ 1307911 xxxx.woff&#39;) format(&#39;woff&#39;),
url(&#39;//at.alicdn.com/t/font_ 1307911_ xxxx.ttf&#39;) format (&#39;truetype&#39;),
url(&#39;//at.alicdn.com/t/font_ 1307911 xxxx.svg#tianfont&#39;) format(&#39;svg&#39;),
&#125;
</code></pre>
<p>​		在上述代码中通过src字段的属性值，可以指定字体资源的位置，并且该属性值还可以提供一个用逗 号分隔的列表，列表中不同字体文件格式的资源顺序同样重要，浏览器将选取其所支持的第一个格式资源。 如果希望较新的WOFF2格式被使用，则应当将WOFF2声明在WOFF之上。</p>
<p>2.子集内嵌</p>
<p>​		对于同一个字符，Web字体可以根据样式、粗细及拉伸等属性的不同，拥有多种变种的字型展示。如果将所有字型都打包成一个文件来请求使用， 不免就会存在许多根本用不到的字型信息浪费带宽。相较于拉丁文字体而言，包含中文字符的字体文件的大小会格外突出。字体文件是否能够按需加载，就成为一个显而易见的优化项，这便是子集内嵌。</p>
<p>​		通过@font- face和unicode-range属性就可以定义所使用的字体子集，属性unicode-range用来指定所需字体在@font-face声明字体集中的子集范围，它支持三种形式:单一取值(如U+233)、范围取值(如U+233-2ff)、通配符范围( 如U+2??),取值的含义是字体集文件中的代码索引点，具体使用示例如下:</p>
<pre><code class="css">@font-face &#123;
font-family: &#39;Awesome Font&#39; ;
font-style: normal;
font-weight: 500;
src: 
  url(&#39;/fonts/awesome.woff2&#39;) format(&#39;woff2&#39;),
  url(&#39;/fonts/awesome.woff&#39;) format(&#39;woff&#39;),
  url(&#39;/fonts/awesome.ttf&#39;) format(&#39;ttf&#39;),
  url(&#39;/fonts/awesome.eot&#39;) format(&#39;eot&#39;),
  unicode-range: U+100-3ff, U+f??
&#125;
</code></pre>
<p>​		通过使用子集内嵌，以及为字体的不同样式变体采用单独的文件，用户可以仅根据需要下载字体的子集，而不必强制他们下载可能永远都不会用到的字体子集，这样对字体下载优化来说会更快速高效。不过属性unicode-range也存在兼容性的问题，对于不支持的浏览器，若想提供必要的子集字体支持，则可能需要手动处理字体文件。</p>
<p>3.字体文件预加载</p>
<p>在默认情况下，构建谊染树之前会阻塞字体文件的请求，这将可能导致部分文本谊染延迟，对此我们可使用-link re-reloao”&gt;对字体资源进行预加载。关于预加载的详细内容，会在加载优化章节进一步 介绍。</p>
<pre><code class="html">&lt;head&gt;
&lt;link rel=&quot;preload&quot; href=&quot;/ fonts/ awesome .woff2&quot; as=&quot; font&quot;&gt;
&lt;/head&gt;
</code></pre>
<link rel="preload">需要和@font-face对字体的定义一同使用，它只负责提示浏览器需要预加载给定的资源，而不指明如何使用。但同时需要注意的是，这样做将会无条件向网络发出字体请求，如果项目迭代将原本使用的字体文件修改或删除，也需同步删除对字体预加载的设置。

<h4 id="3-注意display-none的使用"><a href="#3-注意display-none的使用" class="headerlink" title="3.注意display:none的使用"></a>3.注意display:none的使用</h4><p>​	在使用位图时，经常会根据屏幕尺寸、权限控制等不同条件，响应式地处理资源的展示与隐藏。出于对性能的考虑，希望对于不展示的图像:尽量避免在首展时进行资源请求加载。但根据一些直觉性的编程习惯， 读者们真的确定所控制隐藏的图像，是否有发起资源请求吗?来看下面两个例子。</p>
<p>下面img1.jpg的图像文件是否有被浏览器发起请求?即使父级的div 设置为不显示。</p>
<pre><code class="html">&lt;div style=&quot;display:none&quot;&gt;
  &lt; img src=&quot;img1.jpg&quot;&gt;
&lt;/div&gt;
</code></pre>
<p>根据HTML的解析顺序，答案是肯定的，img1.jpg 的图像文件会被请求。那么下面img2.jpg的图像文件会发起请求吗?</p>
<pre><code class="html">&lt;div style=&quot;display:none&quot;&gt;
  &lt;div style=&quot;background: url(img2. jpg) &quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>CSS解析后发现父级使用了display:none, 再去计算子级的样式就没有多大意义了，所以就不会去下载子级div的背景图像。</p>
<p>如果不清楚不同浏览器对display:none 关于图像加载的控制，则可以通过开发者工具进行验证。这里推荐的做法是使用<picture>或&lt; img srcset&gt;的方式进行响应式显示。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​		本章首先从图像基础开始，在普及了包括图像的构成表示、分类压缩等知识之后对前端项目中常用的图像文件格式GIF、JPEG、PNG、 SVG、 WebP 及Base64进行了细致的分析介绍，包括它们之间优缺点的比较，具体场景下的技术选型，以及优化使用建议和工程实践。给出了三点与图像相关的优化技术与建议，希望同学能够明白Web项目中的图像优化是一项技术也是一门艺术， 技术指的是对于每一种图像文件的压缩和使用都有一套工程化的手段，艺术指的是当面对具体的项目实践时，如何技术选型与压缩以达到对用户最佳的体验效果，则需要在多个维度上进行权衡与取舍，并不存在明确的最佳方案。</p>
<p>本章最后给出一些希望同学能够记住的方法与技巧:</p>
<ul>
<li>适合用矢量图的地方首选矢量图。</li>
<li>使用位图时首选WebP,对不支持的浏览器场景进行兼容处理。</li>
<li>尽量为位图图像格式找到最佳质量设置。</li>
<li>删除图像文件中多余的元数据。</li>
<li>对图像文件进行必要的压缩。</li>
<li>为图像提供多种缩放尺寸的响应式资源。</li>
<li>对工程化通用图像处理流程尽量自动化。</li>
</ul>
<h3 id="参考书籍：web前端性能优化"><a href="#参考书籍：web前端性能优化" class="headerlink" title="参考书籍：web前端性能优化"></a>参考书籍：web前端性能优化</h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>