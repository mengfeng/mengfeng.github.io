<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>docker入门 |  艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-docker入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  docker入门
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/11/docker%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2022-11-11T04:17:53.000Z" itemprop="datePublished">2022-11-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a> / <a class="article-category-link" href="/categories/Docker/docker%E5%85%A5%E9%97%A8/">docker入门</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">6.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">24 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="docker入门"><a href="#docker入门" class="headerlink" title="docker入门"></a>docker入门</h1><h3 id="一、docker安装"><a href="#一、docker安装" class="headerlink" title="一、docker安装"></a>一、docker安装</h3><p>目前我们只是基于macos环境下的安装和学习</p>
<p>（很多平台都是windows的）</p>
<h4 id="1-docker下载"><a href="#1-docker下载" class="headerlink" title="1.docker下载"></a>1.docker下载</h4><p>直接去Docker官网去下载对应的版本就可以了（官网地址：<a target="_blank" rel="noopener" href="https://dockerdocs.cn/%EF%BC%89">https://dockerdocs.cn/）</a></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109091347433.png"></p>
<p>选择对应inter芯片或者m1和m2芯片的docker版本就可以</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109091446299.png"></p>
<h4 id="2-设置国内镜像源"><a href="#2-设置国内镜像源" class="headerlink" title="2.设置国内镜像源"></a>2.设置国内镜像源</h4><p>在国内使用docker拉取镜像会非常的慢，所以一定得设置国内镜像源。</p>
<p>设置镜像源在设置里的Docker Engine</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109094123087.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器：点击管理控制台-&gt;登陆账号（淘宝账号）-&gt;右侧镜像工具-&gt;镜像加速器-&gt;拷贝镜像链接</a></p>
<p>网易云加速器：<a target="_blank" rel="noopener" href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></p>
<p>百度云加速器：<a target="_blank" rel="noopener" href="https://mirror.baidubce.com/">https://mirror.baidubce.com</a></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109095852276.png"></p>
<p>配置完成后，查看是否配置成功</p>
<pre><code class="ini">docker info 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109100105080.png"></p>
<p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 Nginx 服务器</p>
<pre><code class="ini">docker run -d -p 80:80 --name webserver nginx
</code></pre>
<p>服务运行后，可以访问 <a target="_blank" rel="noopener" href="http://localhost,如果看到了/">http://localhost，如果看到了</a> “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109101903810.png"></p>
<pre><code class="ini">docker ps -a //查看所有的容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102114729.png"></p>
<pre><code class="ini">docker stop webserver //停止容器服务
docker rm webserver //删除容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102355610.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102417586.png"></p>
<h3 id="二、docker镜像"><a href="#二、docker镜像" class="headerlink" title="二、docker镜像"></a>二、docker镜像</h3><h4 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1.获取镜像"></a>1.获取镜像</h4><p><a target="_blank" rel="noopener" href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p>
<pre><code class="ini">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] //获取镜像命令格式
docker pull ubuntu:18.04 //具体一点
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103151217.png"></p>
<p>查看下载镜像</p>
<pre><code class="ini">docker images -a //查看所有镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103328637.png"></p>
<p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p>
<pre><code class="ini">docker run -it --rm ubuntu:18.04 bash
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103803885.png"></p>
<p><code>docker run</code> 就是运行容器的命令，具体格式我们会在容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p>
<p>最后我们通过 <code>exit</code> 退出了这个容器。</p>
<h4 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2.列出镜像"></a>2.列出镜像</h4><pre><code class="ini">docker image ls //列出所有下载的镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109104611497.png"></p>
<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<p><code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<pre><code class="ini">docker system df //便捷的查看镜像、容器、数据卷所占用的空间
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109104851278.png" alt="image-20221109104851278"></p>
<pre><code class="ini">docker image ls ubuntu //列出部分镜像
docker image ls ubuntu:18.04 //列出特定的某个镜像，也就是说指定仓库名和标签
</code></pre>
<p>docker image ls<code>还支持强大的过滤器参数</code>–filter<code>，或者简写 </code>-f，之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>nginx</code> 之后建立的镜像，可以用下面的命令：</p>
<pre><code class="ini">docker image ls -f since=nginx
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105424883.png"></p>
<p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可</p>
<pre><code class="ini">docker image ls -q //以特定格式显示
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105634317.png"></p>
<pre><code class="ini">docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot; //直接列出镜像结果，并且只包含镜像ID和仓库名
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105755189.png"></p>
<pre><code class="ini">docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot; //以表格等距显示，并且有标题行，和默认一样，不过自己定义列
</code></pre>
<h4 id="3-删除镜像"><a href="#3-删除镜像" class="headerlink" title="3.删除镜像"></a>3.删除镜像</h4><pre><code class="ini">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] //删除镜像命令格式
</code></pre>
<p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code></p>
<p>我们先列出我们下载的所有镜像</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109110129824.png"></p>
<pre><code class="ini">docker image rm afb //删除redis镜像
docker image ls //查看所有镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109110407331.png"></p>
<p>发现已经删除了指定镜像</p>
<pre><code class="ini">docker image rm $(docker image ls -q redis) //组合命令使用
</code></pre>
<p>充分利用你的想象力和 Linux 命令行的强大</p>
<h3 id="三、docker容器"><a href="#三、docker容器" class="headerlink" title="三、docker容器"></a>三、docker容器</h3><h4 id="1-启动容器"><a href="#1-启动容器" class="headerlink" title="1.启动容器"></a>1.启动容器</h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<pre><code class="ini">docker run ubuntu:18.04 /bin/echo &#39;Hello world&#39; //执行后命令后终止容器
</code></pre>
<pre><code class="ini">docker run -t -i ubuntu:18.04 /bin/bash //保持交互
</code></pre>
<p><code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110081411097.png"></p>
<p>Docker run创建容器时，docker的标准操作</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 registry下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<pre><code class="ini">docker start 9a115164bf87//启动一个终止（exited）的容器
</code></pre>
<pre><code class="ini">docker ps -a//查看所有容器信息
docker logs 9a115164bf87//获取容器输出信息
</code></pre>
<h4 id="2-终止容器"><a href="#2-终止容器" class="headerlink" title="2.终止容器"></a>2.终止容器</h4><pre><code class="ini">docker stop (ID) //终止容器
docker ps //查看启动容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110083759963.png"></p>
<h4 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3.进入容器"></a>3.进入容器</h4><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台</p>
<p><code>docker attach</code> 命令或 <code>docker exec</code> 命令都可以进入容器，推荐大家使用 <code>docker exec</code> 命令</p>
<pre><code class="ini">docker attach (ID) //会导致容器的终止
</code></pre>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符</p>
<pre><code class="ini">docker exec -i 4e56f70383c9 /bin/bash 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110084917152.png"></p>
<pre><code class="ini">docker exec -it 4e56f70383c9 /bin/bash //不会导致容器的终止
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110085014483.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110085250397.png"></p>
<pre><code class="ini">docker exec --help //查看更多参数
</code></pre>
<h4 id="4-导入和导出"><a href="#4-导入和导出" class="headerlink" title="4.导入和导出"></a>4.导入和导出</h4><pre><code class="ini">docker export 4e56f70383c9 &gt; ubuntu.tar //导出容器快照到本地文件
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110090757653.png"></p>
<pre><code class="ini">cat nginx.tar | docker import - test/nginx //从容器快照文件中再导入为镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110092840790.png"></p>
<p>用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<h4 id="5-删除容器"><a href="#5-删除容器" class="headerlink" title="5.删除容器"></a>5.删除容器</h4><pre><code class="ini">docker rm (ID or Name) //删除一个处于终止状态的容器
</code></pre>
<p>删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器</p>
<pre><code class="ini">sudo docker rm $(sudo docker ps -a -q) //删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了）
</code></pre>
<h3 id="四、访问仓库"><a href="#四、访问仓库" class="headerlink" title="四、访问仓库"></a>四、访问仓库</h3><h4 id="1-Docker-Hub"><a href="#1-Docker-Hub" class="headerlink" title="1.Docker Hub"></a>1.Docker Hub</h4><p>Docker 官方维护了一个公共仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 <a target="_blank" rel="noopener" href="https://hub.docker.com/search/?type=image">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<p>注册一个docker账号</p>
<blockquote>
<p>在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号</p>
</blockquote>
<p>登陆</p>
<blockquote>
<p>1.可以在docker App上登陆dockr账号（会跳转到 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> ）</p>
<p>2.通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <code>docker logout</code> 退出登录。</p>
</blockquote>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110094750263.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110094815601.png"></p>
<p>拉取镜像</p>
<blockquote>
<p>可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地</p>
</blockquote>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110095756575.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110095822481.png"></p>
<p>推送镜像</p>
<blockquote>
<p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub</p>
</blockquote>
<pre><code class="ini">docker tag ubuntu:18.04 username/ubuntu:18.04 //username 请替换为你的 Docker 账号用户名
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110100404351.png"></p>
<p>自动化构建</p>
<p>自动构建（<code>Automated Builds</code>）可以自动触发构建镜像，方便升级镜像。</p>
<p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p>
<p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a target="_blank" rel="noopener" href="https://github.com/">GitHub</a> 或 <a target="_blank" rel="noopener" href="https://bitbucket.org/">BitBucket</a>）上的项目，一旦项目发生新的提交 （<code>commit</code>）或者创建了新的标签（<code>tag</code>），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动构建，包括如下的步骤：</p>
<p>- </p>
<p>  登录 Docker Hub；</p>
<p>- </p>
<p>  在 Docker Hub 点击右上角头像，在账号设置（<code>Account Settings</code>）中关联（<code>Linked Accounts</code>）目标网站；</p>
<p>- </p>
<p>  在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</p>
<p>- </p>
<p>  选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</p>
<p>- </p>
<p>  指定 <code>Dockerfile</code> 的位置，并保存。</p>
<p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p>
<p>（‼️这个需要付钱）</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110101243394.png"></p>
<h4 id="2-私有仓库"><a href="#2-私有仓库" class="headerlink" title="2.私有仓库"></a>2.私有仓库</h4><p>安装运行 docker-registry</p>
<pre><code class="ini">docker run -d -p 5000:5000 --restart=always --name registry registry //使用官方 registry 镜像来运行
</code></pre>
<p>如果报错端口不可用</p>
<pre><code class="ini">docker run -d -p 8080:8080 --restart=always --name registry registry //删除原来容器，重新创建
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110104412354.png"></p>
<p>在私有仓库上传、搜索、下载镜像</p>
<pre><code class="ini">docker tag ubuntu:latest alan0924/ubuntu:latest //将 ubuntu:latest 这个镜像标记为 alan0924/ubuntu:latest
docker image ls //查看所有镜像
docker push alan0924/ubuntu:latest //上传私有仓库
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110105039054.png"></p>
<p>删除已有镜像，再尝试从私有仓库中下载这个镜像</p>
<pre><code class="ini">docker image rm alan0924/ubuntu:latest
docker image ls
docker pull  alan0924/ubuntu:latest
docker image ls 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110110006213.png"></p>
<p>这是我们docker的私有仓库</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110111655879.png"></p>
<h3 id="五、数据管理"><a href="#五、数据管理" class="headerlink" title="五、数据管理"></a>五、数据管理</h3><h4 id="1-数据卷"><a href="#1-数据卷" class="headerlink" title="1.数据卷"></a>1.数据卷</h4><pre><code class="ini">docker volume create my-vol //创建一个数据卷
docker volume ls //查看所有的数据卷
docker volume inspect my-vol //主机里使用以下命令可以查看指定 数据卷 的信息
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110163653187.png"></p>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<pre><code class="ini">//启动一个挂载数据卷的容器
docker run -d -P \
    --name web \
    --mount source=my-vol,target=/usr/share/nginx/html \
    nginx:alpine
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164146345.png"></p>
<pre><code class="ini">docker inspect web //查看数据卷的具体信息
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164302235.png"></p>
<pre><code class="ini">docker volume rm my-vol //删除数据卷
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164601907.png"></p>
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令</p>
<p>无主的数据卷可能会占据很多空间,要清理请使用以下命令</p>
<pre><code class="ini">docker volume prune
</code></pre>
<h3 id="六、访问网络"><a href="#六、访问网络" class="headerlink" title="六、访问网络"></a>六、访问网络</h3><h4 id="1-外部访问容器"><a href="#1-外部访问容器" class="headerlink" title="1.外部访问容器"></a>1.外部访问容器</h4><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker ps</code> 可以看到，本地主机的 55000 被映射到了容器的 80 端口。此时访问本机的 55000 端口即可访问容器内 NGINX 默认页面。</p>
<pre><code class="ini">docker run -d -P nginx:alpine // 
docker logs 75bbd0b01745 //查看日志
</code></pre>
<p>-p<code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。</code> </p>
<p> <code>支持的格式有 </code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111102609943.png"></p>
<p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p>
<pre><code class="ini">docker run -d -p 80:80 nginx:alpine //映射所有接口地址,此时默认会绑定本地所有接口上的所有地址。
</code></pre>
<p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<pre><code class="ini">docker run -d -p 127.0.0.1:80:80 nginx:alpine //映射到指定地址的指定端口,
</code></pre>
<p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<pre><code class="ini">docker run -d -p 127.0.0.1::80 nginx:alpine //映射到指定地址的任意端口
</code></pre>
<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<pre><code class="ini">docker run -d -p 127.0.0.1:80:80/udp nginx:alpine 
</code></pre>
<p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<pre><code class="ini">docker port 75b 80 //查看映射端口配置
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111103203892.png"></p>
<ul>
<li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li>
<li><code>-p</code> 标记可以多次使用来绑定多个端口</li>
</ul>
<pre><code class="ini">docker run -d \
    -p 80:80 \
    -p 443:443 \
    nginx:alpine
</code></pre>
<h4 id="2-容器互联"><a href="#2-容器互联" class="headerlink" title="2.容器互联"></a>2.容器互联</h4><p>新建网络</p>
<pre><code class="ini">docker network create -d bridge my-net //创建一个新的 Docker 网络
</code></pre>
<p>连接容器</p>
<pre><code class="ini">docker run -it --rm --name busybox1 --network my-net busybox sh //运行一个容器并连接到新建的 my-net 网络
</code></pre>
<pre><code class="ini">docker run -it --rm --name busybox2 --network my-net busybox sh //打开新的终端，再运行一个容器并加入到 my-net 网络
</code></pre>
<pre><code class="ini">docker ps //再打开一个新的终端查看容器信息
</code></pre>
<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<pre><code class="ini">/ # ping busybox2
PING busybox2 (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms
64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms
</code></pre>
<p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code></p>
<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到</p>
<pre><code class="ini">/ # ping busybox1
PING busybox1 (172.19.0.2): 56 data bytes
64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms
64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111104242497.png"></p>
<p><code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<h3 id="七、Docker-Compose"><a href="#七、Docker-Compose" class="headerlink" title="七、Docker Compose"></a>七、Docker Compose</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p><code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用</p>
<pre><code class="ini">docker-compose --version
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111110532499.png"></p>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><ul>
<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</li>
</ul>
<p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>
<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p>
<pre><code class="python">//app.py
from flask import Flask
from redis import Redis

app = Flask(__name__)
redis = Redis(host=&#39;redis&#39;, port=6379)

@app.route(&#39;/&#39;)
def hello():
    count = redis.incr(&#39;hits&#39;)
    return &#39;Hello World! 该页面已被访问 &#123;&#125; 次。\n&#39;.format(count)

if __name__ == &quot;__main__&quot;:
    app.run(host=&quot;0.0.0.0&quot;, debug=True)
</code></pre>
<pre><code class="javascript">//docker-compose.yml
version: &#39;3&#39;
services:

  web:
    build: .
    ports:
     - &quot;5500:5500&quot;

  redis:
    image: &quot;redis:alpine&quot;
</code></pre>
<pre><code class="javascript">//Dockerfile
FROM python:3.6-alpine
ADD . /code
WORKDIR /code
RUN pip install redis flask
CMD [&quot;python&quot;, &quot;app.py&quot;]
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111112418983.png"></p>
<pre><code class="ini">docker-compose up //运行 compose 项目
</code></pre>
<p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>
<h4 id="3-命令说明"><a href="#3-命令说明" class="headerlink" title="3.命令说明"></a>3.命令说明</h4><p>命令对象与格式</p>
<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<p>docker-compose [-f&#x3D;<arg>…] [options] [COMMAND] [ARGS…]</p>
<p>命令选项</p>
<p>- </p>
<p>  <code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</p>
<p>- </p>
<p>  <code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</p>
<p>- </p>
<p>  <code>--verbose</code> 输出更多调试信息。</p>
<p>- </p>
<p>  <code>-v, --version</code> 打印版本并退出。</p>
<p>命令使用说明</p>
<p><code>build</code></p>
<p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>
<p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p>
<p>选项包括：</p>
<ul>
<li><code>--force-rm</code> 删除构建过程中的临时容器。</li>
<li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li>
<li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li>
</ul>
<p><code>config</code></p>
<p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<p><code>down</code></p>
<p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<p><code>exec</code></p>
<p>进入指定的容器。</p>
<p><code>help</code></p>
<p>获得一个命令的帮助。</p>
<p><code>images</code></p>
<p>列出 Compose 文件中包含的镜像。</p>
<p><code>kill</code></p>
<p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p>
<p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p>
<pre><code class="ini">docker-compose kill -s SIGINT
</code></pre>
<p><code>logs</code></p>
<p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p>
<p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p>
<p>该命令在调试问题的时候十分有用。</p>
<p><code>pause</code></p>
<p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p>
<p>暂停一个服务容器。</p>
<p><code>port</code></p>
<p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p>
<p>打印某个容器端口所映射的公共端口。</p>
<p>选项：</p>
<ul>
<li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li>
<li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li>
</ul>
<p><code>ps</code></p>
<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<p><code>pull</code></p>
<p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p>
<p>拉取服务依赖的镜像。</p>
<p>选项：</p>
<ul>
<li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li>
</ul>
<p><code>push</code></p>
<p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<p><code>restart</code></p>
<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<p><code>rm</code></p>
<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<p><code>run</code></p>
<p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p>
<p>在指定服务上执行一个命令。</p>
<p>例如：</p>
<pre><code class="ini">docker-compose run ubuntu ping docker.com
</code></pre>
<p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<ul>
<li>给定命令将会覆盖原有的自动运行命令；</li>
<li>不会自动创建端口，以避免冲突。</li>
</ul>
<p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p>
<pre><code class="ini">docker-compose run --no-deps web python manage.py shell
</code></pre>
<p>将不会启动 web 容器所关联的其它容器。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 后台运行容器。</li>
<li><code>--name NAME</code> 为容器指定一个名字。</li>
<li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li>
<li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li>
<li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li>
<li><code>--no-deps</code> 不自动启动关联的服务容器。</li>
<li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li>
<li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li>
<li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li>
<li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li>
</ul>
<p><code>scale</code></p>
<p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p>
<p>设置指定服务运行的容器个数。</p>
<p>通过 <code>service=num</code> 的参数来设置数量。例如：</p>
<pre><code class="ini">docker-compose scale web=3 db=2
</code></pre>
<p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p>
<p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>start</code></p>
<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<p><code>stop</code></p>
<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>top</code></p>
<p>查看各个服务容器内运行的进程。</p>
<p><code>unpause</code></p>
<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<p><code>up</code></p>
<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 在后台运行服务容器。</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像。</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>version</code></p>
<p>格式为 <code>docker-compose version</code>。</p>
<p>打印版本信息。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mengfeng.github.io/2022/11/11/docker%E5%85%A5%E9%97%A8/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/11/12/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            什么是CI/CD
          
        </div>
      </a>
    
    
      <a href="/2022/11/11/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">表白爱心biu</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '6887374e7666a97fd4dc',
    clientSecret: '09a8e143dd4a3f5d11311e1435842321e063157d',
    repo: 'mengfeng.github.io',
    owner: 'mengfeng',
    admin: ['mengfeng'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>