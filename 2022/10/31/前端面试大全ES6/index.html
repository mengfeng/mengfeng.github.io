<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>前端面试大全ES6 |  艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-前端面试大全ES6"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  前端面试大全ES6
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/" class="article-date">
  <time datetime="2022-10-31T02:09:48.000Z" itemprop="datePublished">2022-10-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/ES6/">ES6</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">16.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">74 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（ES6）"><a href="#前端面试题大全（ES6）" class="headerlink" title="前端面试题大全（ES6）"></a>前端面试题大全（ES6）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-var、let、const之间的区别"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-var、let、const之间的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ var、let、const之间的区别"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ var、let、const之间的区别</h3><h4 id="一、var"><a href="#一、var" class="headerlink" title="一、var"></a>一、var</h4><p>在ES5中，顶层对象的属性和全局变量是等价的，用<code>var</code>声明的变量既是全局变量，也是顶层变量</p>
<p>注意：顶层对象，在浏览器环境指的是<code>window</code>对象，在 <code>Node</code> 指的是<code>global</code>对象</p>
<pre><code class="javascript">var a = 10;
console.log(window.a) // 10
</code></pre>
<p>使用<code>var</code>声明的变量存在变量提升的情况</p>
<pre><code class="javascript">console.log(a) // undefined
var a = 20
</code></pre>
<p>在编译阶段，编译器会将其变成以下执行</p>
<pre><code class="javascript">var a
console.log(a)
a = 20
</code></pre>
<p>使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明</p>
<pre><code class="javascript">var a = 20 
var a = 30
console.log(a) // 30
</code></pre>
<p>在函数中使用使用<code>var</code>声明变量时候，该变量是局部的</p>
<pre><code class="javascript">var a = 20
function change()&#123;
    var a = 30
&#125;
change()
console.log(a) // 20 
</code></pre>
<p>而如果在函数内不使用<code>var</code>，该变量是全局的</p>
<pre><code class="javascript">var a = 20
function change()&#123;
   a = 30
&#125;
change()
console.log(a) // 30 
</code></pre>
<h4 id="二、let"><a href="#二、let" class="headerlink" title="二、let"></a>二、let</h4><p><code>let</code>是<code>ES6</code>新增的命令，用来声明变量</p>
<p>用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效</p>
<pre><code class="javascript">&#123;
    let a = 20
&#125;
console.log(a) // ReferenceError: a is not defined.
</code></pre>
<p>不存在变量提升</p>
<pre><code class="javascript">console.log(a) // 报错ReferenceError
let a = 2
</code></pre>
<p>这表示在声明它之前，变量<code>a</code>是不存在的，这时如果用到它，就会抛出一个错误</p>
<p>只要块级作用域内存在<code>let</code>命令，这个区域就不再受外部影响</p>
<pre><code class="javascript">var a = 123
if (true) &#123;
    a = &#39;abc&#39; // ReferenceError
    let a;
&#125;
</code></pre>
<p>使用<code>let</code>声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”</p>
<p>最后，<code>let</code>不允许在相同作用域中重复声明</p>
<pre><code class="javascript">let a = 20
let a = 30
// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared
</code></pre>
<p>注意的是相同作用域，下面这种情况是不会报错的</p>
<pre><code class="javascript">let a = 20
&#123;
    let a = 30
&#125;
</code></pre>
<p>因此，我们不能在函数内部重新声明参数</p>
<pre><code class="javascript">function func(arg) &#123;
  let arg;
&#125;
func()
// Uncaught SyntaxError: Identifier &#39;arg&#39; has already been declared
</code></pre>
<h4 id="三、const"><a href="#三、const" class="headerlink" title="三、const"></a>三、const</h4><p><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变</p>
<pre><code class="javascript">const a = 1
a = 3
// TypeError: Assignment to constant variable.
</code></pre>
<p>这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值</p>
<pre><code class="javascript">const a;
// SyntaxError: Missing initializer in const declaration
</code></pre>
<p>如果之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错</p>
<pre><code class="javascript">var a = 20
let b = 20
const a = 30
const b = 30
// 都会报错
</code></pre>
<p><code>const</code>实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</p>
<p>对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量</p>
<p>对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的，并不能确保改变量的结构不变</p>
<pre><code class="javascript">const foo = &#123;&#125;;

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only
</code></pre>
<p>其它情况，<code>const</code>与<code>let</code>一致</p>
<h4 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h4><p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p>
<ul>
<li>变量提升</li>
<li>暂时性死区</li>
<li>块级作用域</li>
<li>重复声明</li>
<li>修改声明的变量</li>
<li>使用</li>
</ul>
<h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><pre><code class="css">var `声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined
</code></pre>
<p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p>
<pre><code class="javascript">// var
console.log(a)  // undefined
var a = 10

// let 
console.log(b)  // Cannot access &#39;b&#39; before initialization
let b = 10

// const
console.log(c)  // Cannot access &#39;c&#39; before initialization
const c = 10
</code></pre>
<h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><p><code>var</code>不存在暂时性死区</p>
<p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<pre><code class="javascript">// var
console.log(a)  // undefined
var a = 10

// let
console.log(b)  // Cannot access &#39;b&#39; before initialization
let b = 10

// const
console.log(c)  // Cannot access &#39;c&#39; before initialization
const c = 10
</code></pre>
<h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p><code>var</code>不存在块级作用域</p>
<p><code>let</code>和<code>const</code>存在块级作用域</p>
<pre><code class="javascript">// var
&#123;
    var a = 20
&#125;
console.log(a)  // 20

// let
&#123;
    let b = 20
&#125;
console.log(b)  // Uncaught ReferenceError: b is not defined

// const
&#123;
    const c = 20
&#125;
console.log(c)  // Uncaught ReferenceError: c is not defined
</code></pre>
<h5 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h5><p><code>var</code>允许重复声明变量</p>
<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p>
<pre><code class="javascript">// var
var a = 10
var a = 20 // 20

// let
let b = 10
let b = 20 // Identifier &#39;b&#39; has already been declared

// const
const c = 10
const c = 20 // Identifier &#39;c&#39; has already been declared
</code></pre>
<h5 id="修改声明的变量"><a href="#修改声明的变量" class="headerlink" title="修改声明的变量"></a>修改声明的变量</h5><p><code>var</code>和<code>let</code>可以</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p>
<pre><code class="javascript">// var
var a = 10
a = 20
console.log(a)  // 20

//let
let b = 10
b = 20
console.log(b)  // 20

// const
const c = 10
c = 20
console.log(c) // Uncaught TypeError: Assignment to constant variable
</code></pre>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>能用<code>const</code>的情况尽量使用<code>const</code>，其他情况下大多数使用<code>let</code>，避免使用<code>var</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中数组新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中数组新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中数组新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中数组新增了哪些扩展?</h3><h4 id="一、扩展运算符的应用"><a href="#一、扩展运算符的应用" class="headerlink" title="一、扩展运算符的应用"></a>一、扩展运算符的应用</h4><p>ES6通过扩展元素符<code>...</code>，好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<pre><code class="javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre>
<p>主要用于函数调用的时候，将一个数组变为参数序列</p>
<pre><code class="javascript">function push(array, ...items) &#123;
  array.push(...items);
&#125;

function add(x, y) &#123;
  return x + y;
&#125;

const numbers = [4, 38];
add(...numbers) // 42
</code></pre>
<p>可以将某些数据结构转为数组</p>
<pre><code class="javascript">[...document.querySelectorAll(&#39;div&#39;)]
</code></pre>
<p>能够更简单实现数组复制</p>
<pre><code class="javascript">const a1 = [1, 2];
const [...a2] = a1;
// [1,2]
</code></pre>
<p>数组的合并也更为简洁了</p>
<pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;];
const arr2 = [&#39;c&#39;];
const arr3 = [&#39;d&#39;, &#39;e&#39;];
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</code></pre>
<p>注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组</p>
<p>下面看个例子就清楚多了</p>
<pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;,[1,2]];
const arr2 = [&#39;c&#39;];
const arr3  = [...arr1,...arr2]
arr1[2][0] = 9999 // 修改arr1里面数组成员值
console.log(arr3) // 影响到arr3,[&#39;a&#39;,&#39;b&#39;,[9999,2],&#39;c&#39;]
</code></pre>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组</p>
<pre><code class="javascript">const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = [&quot;foo&quot;];
first  // &quot;foo&quot;
rest   // []
</code></pre>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p>
<pre><code class="javascript">const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</code></pre>
<p>可以将字符串转为真正的数组</p>
<pre><code class="javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
<p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p>
<pre><code class="javascript">let nodeList = document.querySelectorAll(&#39;div&#39;);
let array = [...nodeList];

let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]
</code></pre>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错</p>
<pre><code class="javascript">const obj = &#123;a: 1, b: 2&#125;;
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
</code></pre>
<h4 id="二、构造函数新增的方法"><a href="#二、构造函数新增的方法" class="headerlink" title="二、构造函数新增的方法"></a>二、构造函数新增的方法</h4><p>关于构造函数，数组新增的方法有如下：</p>
<ul>
<li>Array.from()</li>
<li>Array.of()</li>
</ul>
<h5 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h5><p>将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>
<pre><code class="javascript">let arrayLike = &#123;
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
&#125;;
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<pre><code class="javascript">Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]
</code></pre>
<h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h5><p>用于将一组值，转换为数组</p>
<pre><code class="javascript">Array.of(3, 11, 8) // [3,11,8]
</code></pre>
<p>没有参数的时候，返回一个空数组</p>
<p>当参数只有一个的时候，实际上是指定数组的长度</p>
<p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p>
<pre><code class="javascript">Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
</code></pre>
<h4 id="三、实例对象新增的方法"><a href="#三、实例对象新增的方法" class="headerlink" title="三、实例对象新增的方法"></a>三、实例对象新增的方法</h4><p>关于数组实例对象新增的方法有如下：</p>
<ul>
<li>copyWithin()</li>
<li>find()、findIndex()</li>
<li>fill()</li>
<li>entries()，keys()，values()</li>
<li>includes()</li>
<li>flat()，flatMap()</li>
</ul>
<h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h5><p>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p>
<p>参数如下：</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<pre><code>[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2
// [4, 5, 3, 4, 5] 
</code></pre>
<h5 id="find-、findIndex"><a href="#find-、findIndex" class="headerlink" title="find()、findIndex()"></a>find()、findIndex()</h5><p><code>find()</code>用于找出第一个符合条件的数组成员</p>
<p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p>
<pre><code class="javascript">[1, 5, 10, 15].find(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 10
findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1
[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 2
</code></pre>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>
<pre><code class="javascript">function f(v)&#123;
  return v &gt; this.age;
&#125;
let person = &#123;name: &#39;John&#39;, age: 20&#125;;
[10, 12, 26, 15].find(f, person);    // 26
</code></pre>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p>使用给定值，填充一个数组</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre>
<p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
</code></pre>
<p>注意，如果填充的类型为对象，则是浅拷贝</p>
<h5 id="entries-，keys-，values"><a href="#entries-，keys-，values" class="headerlink" title="entries()，keys()，values()"></a>entries()，keys()，values()</h5><p><code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历</p>
<pre><code class="javascript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;
  console.log(index);
&#125;
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;
  console.log(elem);
&#125;
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;
  console.log(index, elem);
&#125;
// 0 &quot;a&quot;
</code></pre>
<h5 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h5><p>用于判断数组是否包含给定的值</p>
<pre><code class="javascript">[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
</code></pre>
<p>方法的第二个参数表示搜索的起始位置，默认为<code>0</code></p>
<p>参数为负数则表示倒数的位置</p>
<pre><code class="javascript">[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</code></pre>
<h5 id="flat-，flatMap"><a href="#flat-，flatMap" class="headerlink" title="flat()，flatMap()"></a>flat()，flatMap()</h5><p>将数组扁平化处理，返回一个新数组，对原数据没有影响</p>
<pre><code class="javascript">[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
</code></pre>
<p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1</p>
<pre><code class="javascript">[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
</code></pre>
<p><code>flatMap()</code>方法对原数组的每个成员执行一个函数相当于执行<code>Array.prototype.map()</code>，然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组</p>
<pre><code class="javascript">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) =&gt; [x, x * 2])
// [2, 4, 3, 6, 4, 8]
flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this
</code></pre>
<h4 id="四、数组的空位"><a href="#四、数组的空位" class="headerlink" title="四、数组的空位"></a>四、数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值</p>
<p>ES6 则是明确将空位转为<code>undefined</code>，包括<code>Array.from</code>、扩展运算符、<code>copyWithin()</code>、<code>fill()</code>、<code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code></p>
<p>建议大家在日常书写中，避免出现空位</p>
<h4 id="五、排序稳定性"><a href="#五、排序稳定性" class="headerlink" title="五、排序稳定性"></a>五、排序稳定性</h4><p>将<code>sort()</code>默认设置为稳定的排序算法</p>
<pre><code class="javascript">const arr = [
  &#39;peach&#39;,
  &#39;straw&#39;,
  &#39;apple&#39;,
  &#39;spork&#39;
];

const stableSorting = (s1, s2) =&gt; &#123;
  if (s1[0] &lt; s2[0]) return -1;
  return 1;
&#125;;

arr.sort(stableSorting)
// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]
</code></pre>
<p>排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中对象新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中对象新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中对象新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中对象新增了哪些扩展?</h3><h4 id="一、属性的简写"><a href="#一、属性的简写" class="headerlink" title="一、属性的简写"></a>一、属性的简写</h4><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写</p>
<pre><code class="javascript">const baz = &#123;foo:foo&#125;

// 等同于
const baz = &#123;foo&#125;
</code></pre>
<p>方法也能够进行简写</p>
<pre><code class="javascript">const o = &#123;
  method() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;;

// 等同于

const o = &#123;
  method: function() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;
</code></pre>
<p>在函数内作为返回值，也会变得方便很多</p>
<pre><code class="javascript">function getPoint() &#123;
  const x = 1;
  const y = 10;
  return &#123;x, y&#125;;
&#125;

getPoint()
// &#123;x:1, y:10&#125;
</code></pre>
<p>注意：简写的对象方法不能用作构造函数，否则会报错</p>
<pre><code class="javascript">const obj = &#123;
  f() &#123;
    this.foo = &#39;bar&#39;;
  &#125;
&#125;;

new obj.f() // 报错
</code></pre>
<h4 id="二、属性名表达式"><a href="#二、属性名表达式" class="headerlink" title="二、属性名表达式"></a>二、属性名表达式</h4><p>ES6 允许字面量定义对象时，将表达式放在括号内</p>
<pre><code class="javascript">let lastWord = &#39;last word&#39;;

const a = &#123;
  &#39;first word&#39;: &#39;hello&#39;,
  [lastWord]: &#39;world&#39;
&#125;;

a[&#39;first word&#39;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&#39;last word&#39;] // &quot;world&quot;
</code></pre>
<p>表达式还可以用于定义方法名</p>
<pre><code class="javascript">let obj = &#123;
  [&#39;h&#39; + &#39;ello&#39;]() &#123;
    return &#39;hi&#39;;
  &#125;
&#125;;

obj.hello() // hi
</code></pre>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错</p>
<pre><code class="javascript">// 报错
const foo = &#39;bar&#39;;
const bar = &#39;abc&#39;;
const baz = &#123; [foo] &#125;;

// 正确
const foo = &#39;bar&#39;;
const baz = &#123; [foo]: &#39;abc&#39;&#125;;
</code></pre>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code></p>
<pre><code class="javascript">const keyA = &#123;a: 1&#125;;
const keyB = &#123;b: 2&#125;;

const myObject = &#123;
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
&#125;;

myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;
</code></pre>
<h4 id="三、super关键字"><a href="#三、super关键字" class="headerlink" title="三、super关键字"></a>三、super关键字</h4><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象</p>
<pre><code class="javascript">const proto = &#123;
  foo: &#39;hello&#39;
&#125;;

const obj = &#123;
  foo: &#39;world&#39;,
  find() &#123;
    return super.foo;
  &#125;
&#125;;

Object.setPrototypeOf(obj, proto); // 为obj设置原型对象
obj.find() // &quot;hello&quot;
</code></pre>
<h4 id="四、扩展运算符的应用"><a href="#四、扩展运算符的应用" class="headerlink" title="四、扩展运算符的应用"></a>四、扩展运算符的应用</h4><p>在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面</p>
<pre><code class="javascript">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;
x // 1
y // 2
z // &#123; a: 3, b: 4 &#125;
</code></pre>
<p>注意：解构赋值必须是最后一个参数，否则会报错</p>
<p>解构赋值是浅拷贝</p>
<pre><code class="javascript">let obj = &#123; a: &#123; b: 1 &#125; &#125;;
let &#123; ...x &#125; = obj;
obj.a.b = 2; // 修改obj里面a属性中键值
x.a.b // 2，影响到了结构出来x的值
</code></pre>
<p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法</p>
<h4 id="五、属性的遍历"><a href="#五、属性的遍历" class="headerlink" title="五、属性的遍历"></a>五、属性的遍历</h4><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<ul>
<li>for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li>
<li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li>
<li>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li>
<li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</li>
<li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li>
</ul>
<p>上述遍历，都遵守同样的属性遍历的次序规则：</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排</li>
</ul>
<pre><code class="javascript">Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)
// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]
</code></pre>
<h4 id="六、对象新增的方法"><a href="#六、对象新增的方法" class="headerlink" title="六、对象新增的方法"></a>六、对象新增的方法</h4><p>关于对象新增的方法，分别有以下：</p>
<ul>
<li>Object.is()</li>
<li>Object.assign()</li>
<li>Object.getOwnPropertyDescriptors()</li>
<li>Object.setPrototypeOf()，Object.getPrototypeOf()</li>
<li>Object.keys()，Object.values()，Object.entries()</li>
<li>Object.fromEntries()</li>
</ul>
<h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><p>严格判断两个值是否相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致，不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</p>
<pre><code class="javascript">+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><pre><code class="javascript">Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target
</code></pre>
<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象</p>
<pre><code class="javascript">const target = &#123; a: 1, b: 1 &#125;;

const source1 = &#123; b: 2, c: 2 &#125;;
const source2 = &#123; c: 3 &#125;;

Object.assign(target, source1, source2);
target // &#123;a:1, b:2, c:3&#125;
</code></pre>
<p>注意：<code>Object.assign()</code>方法是浅拷贝，遇到同名属性会进行替换</p>
<h5 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h5><p>返回指定对象所有自身属性（非继承属性）的描述对象</p>
<pre><code class="javascript">const obj = &#123;
  foo: 123,
  get bar() &#123; return &#39;abc&#39; &#125;
&#125;;

Object.getOwnPropertyDescriptors(obj)
// &#123; foo:
//    &#123; value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true &#125;,
//   bar:
//    &#123; get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true &#125; &#125;
</code></pre>
<h5 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h5><p><code>Object.setPrototypeOf</code>方法用来设置一个对象的原型对象</p>
<pre><code class="javascript">Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf(&#123;&#125;, null);
</code></pre>
<h5 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h5><p>用于读取一个对象的原型对象</p>
<pre><code class="javascript">Object.getPrototypeOf(obj);
</code></pre>
<h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组</p>
<pre><code class="javascript">var obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre>
<h5 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h5><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组</p>
<pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.values(obj)
// [&quot;bar&quot;, 42]
</code></pre>
<h5 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h5><p>返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组</p>
<pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
</code></pre>
<h5 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h5><p>用于将一个键值对数组转为对象</p>
<pre><code class="javascript">Object.fromEntries([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
])
// &#123; foo: &quot;bar&quot;, baz: 42 &#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中函数新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中函数新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中函数新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中函数新增了哪些扩展?</h3><h4 id="一、参数"><a href="#一、参数" class="headerlink" title="一、参数"></a>一、参数</h4><p><code>ES6</code>允许为函数的参数设置默认值</p>
<pre><code class="javascript">function log(x, y = &#39;World&#39;) &#123;
  console.log(x, y);
&#125;

console.log(&#39;Hello&#39;) // Hello World
console.log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
console.log(&#39;Hello&#39;, &#39;&#39;) // Hello
</code></pre>
<p>函数的形参是默认声明的，不能使用<code>let</code>或<code>const</code>再次声明</p>
<pre><code class="javascript">function foo(x = 5) &#123;
    let x = 1; // error
    const x = 2; // error
&#125;
</code></pre>
<p>参数默认值可以与解构赋值的默认值结合起来使用</p>
<pre><code class="javascript">function foo(&#123;x, y = 5&#125;) &#123;
  console.log(x, y);
&#125;

foo(&#123;&#125;) // undefined 5
foo(&#123;x: 1&#125;) // 1 5
foo(&#123;x: 1, y: 2&#125;) // 1 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined
</code></pre>
<p>上面的<code>foo</code>函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量<code>x</code>和<code>y</code>就不会生成，从而报错，这里设置默认值避免</p>
<pre><code class="javascript">function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;
  console.log(x, y);
&#125;

foo() // undefined 5
</code></pre>
<p>参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的</p>
<pre><code class="javascript">function f(x = 1, y) &#123;
  return [x, y];
&#125;

f() // [1, undefined]
f(2) // [2, undefined]
f(, 1) // 报错
f(undefined, 1) // [1, 1]
</code></pre>
<h4 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h4><h5 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h5><p><code>length</code>将返回没有指定默认值的参数个数</p>
<pre><code class="javascript">(function (a) &#123;&#125;).length // 1
(function (a = 5) &#123;&#125;).length // 0
(function (a, b, c = 5) &#123;&#125;).length // 2
</code></pre>
<p><code>rest</code> 参数也不会计入<code>length</code>属性</p>
<pre><code class="javascript">(function(...args) &#123;&#125;).length // 0
</code></pre>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</p>
<pre><code class="javascript">(function (a = 0, b, c) &#123;&#125;).length // 0
(function (a, b = 1, c) &#123;&#125;).length // 1
</code></pre>
<h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><p>返回该函数的函数名</p>
<pre><code class="javascript">var f = function () &#123;&#125;;

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;
</code></pre>
<p>如果将一个具名函数赋值给一个变量，则 <code>name</code>属性都返回这个具名函数原本的名字</p>
<pre><code class="javascript">const bar = function baz() &#123;&#125;;
bar.name // &quot;baz&quot;
Function`构造函数返回的函数实例，`name`属性的值为`anonymous
(new Function).name // &quot;anonymous&quot;
</code></pre>
<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀</p>
<pre><code class="javascript">function foo() &#123;&#125;;
foo.bind(&#123;&#125;).name // &quot;bound foo&quot;

(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;
</code></pre>
<h4 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</p>
<p>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p>
<p>下面例子中，<code>y=x</code>会形成一个单独作用域，<code>x</code>没有被定义，所以指向全局变量<code>x</code></p>
<pre><code class="javascript">let x = 1;

function f(y = x) &#123; 
  // 等同于 let y = x  
  let x = 2; 
  console.log(y);
&#125;

f() // 1
</code></pre>
<h4 id="四、严格模式"><a href="#四、严格模式" class="headerlink" title="四、严格模式"></a>四、严格模式</h4><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p>
<pre><code class="javascript">// 报错
function doSomething(a, b = a) &#123;
  &#39;use strict&#39;;
  // code
&#125;

// 报错
const doSomething = function (&#123;a, b&#125;) &#123;
  &#39;use strict&#39;;
  // code
&#125;;

// 报错
const doSomething = (...a) =&gt; &#123;
  &#39;use strict&#39;;
  // code
&#125;;

const obj = &#123;
  // 报错
  doSomething(&#123;a, b&#125;) &#123;
    &#39;use strict&#39;;
    // code
  &#125;
&#125;;
</code></pre>
<h4 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h4><p>使用“箭头”（<code>=&gt;</code>）定义函数</p>
<pre><code class="javascript">var f = v =&gt; v;

// 等同于
var f = function (v) &#123;
  return v;
&#125;;
</code></pre>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</p>
<pre><code class="javascript">var f = () =&gt; 5;
// 等同于
var f = function () &#123; return 5 &#125;;

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) &#123;
  return num1 + num2;
&#125;;
</code></pre>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回</p>
<pre><code class="javascript">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;
</code></pre>
<p>如果返回对象，需要加括号将对象包裹</p>
<pre><code class="javascript">let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);
</code></pre>
<p>注意点：</p>
<ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中新增的Set、Map两种数据结构怎么理解"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中新增的Set、Map两种数据结构怎么理解" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中新增的Set、Map两种数据结构怎么理解?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中新增的Set、Map两种数据结构怎么理解?</h3><p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p>
<p>什么是集合？什么又是字典？</p>
<ul>
<li>集合<br>是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</li>
<li>字典<br>是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</li>
</ul>
<p>区别？</p>
<ul>
<li>共同点：集合、字典都可以存储不重复的值</li>
<li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li>
</ul>
<h4 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h4><p><code>Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</p>
<pre><code>const s = new Set();
</code></pre>
<h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><p><code>Set</code>的实例关于增删改查的方法：</p>
<ul>
<li>add()</li>
<li>delete()</li>
<li>has()</li>
<li>clear()</li>
</ul>
<h6 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h6><p>添加某个值，返回 <code>Set</code> 结构本身</p>
<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>
<pre><code>s.add(1).add(2).add(2); // 2只被添加了一次
</code></pre>
<h6 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h6><p>删除某个值，返回一个布尔值，表示删除是否成功</p>
<pre><code>s.delete(1)
</code></pre>
<h6 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h6><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>
<pre><code>s.has(2)
</code></pre>
<h6 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h6><p>清除所有成员，没有返回值</p>
<pre><code>s.clear()
</code></pre>
<h6 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h6><p><code>Set</code>实例遍历的方法有如下：</p>
<p>关于遍历的方法，有如下：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<p><code>Set</code>的遍历顺序就是插入顺序</p>
<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象</p>
<pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

for (let item of set.keys()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.values()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.entries()) &#123;
  console.log(item);
&#125;
// [&quot;red&quot;, &quot;red&quot;]
// [&quot;green&quot;, &quot;green&quot;]
// [&quot;blue&quot;, &quot;blue&quot;]
forEach()`用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的`forEach`方法有第二个参数，用于绑定处理函数的`this
let set = new Set([1, 4, 9]);
set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
// 1 : 1
// 4 : 4
// 9 : 9
</code></pre>
<p>扩展运算符和<code> Set</code> 结构相结合实现数组或字符串去重</p>
<pre><code class="javascript">// 数组
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)]; // [3, 5, 2]

// 字符串
let str = &quot;352255&quot;;
let unique = [...new Set(str)].join(&quot;&quot;); // &#39;352&#39;
</code></pre>
<p>实现并集、交集、和差集</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<h4 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h4><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>
<p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p>
<pre><code class="javascript">const m = new Map()
</code></pre>
<h5 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h5><p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p>
<ul>
<li>size 属性</li>
<li>set()</li>
<li>get()</li>
<li>has()</li>
<li>delete()</li>
<li>clear()</li>
</ul>
<h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><p><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="javascript">const map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
</code></pre>
<h6 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h6><p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p>
<p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p>
<p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p>
<pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6)        // 键是字符串
m.set(262, &#39;standard&#39;)     // 键是数值
m.set(undefined, &#39;nah&#39;)    // 键是 undefined
m.set(1, &#39;a&#39;).set(2, &#39;b&#39;).set(3, &#39;c&#39;) // 链式操作
</code></pre>
<h6 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h6><pre><code class="javascript">get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined
const m = new Map();

const hello = function() &#123;console.log(&#39;hello&#39;);&#125;;
m.set(hello, &#39;Hello ES6!&#39;) // 键是函数

m.get(hello)  // Hello ES6!
</code></pre>
<h6 id="has-1"><a href="#has-1" class="headerlink" title="has()"></a>has()</h6><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p>
<pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6);
m.set(262, &#39;standard&#39;);
m.set(undefined, &#39;nah&#39;);

m.has(&#39;edition&#39;)     // true
m.has(&#39;years&#39;)       // false
m.has(262)           // true
m.has(undefined)     // true
</code></pre>
<h6 id="delete-1"><a href="#delete-1" class="headerlink" title="delete()"></a>delete()</h6><pre><code class="javascript">delete`方法删除某个键，返回`true`。如果删除失败，返回`false
const m = new Map();
m.set(undefined, &#39;nah&#39;);
m.has(undefined)     // true

m.delete(undefined)
m.has(undefined)       // false
</code></pre>
<h6 id="clear-1"><a href="#clear-1" class="headerlink" title="clear()"></a>clear()</h6><p><code>clear</code>方法清除所有成员，没有返回值</p>
<pre><code class="javascript">let map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
map.clear()
map.size // 0
</code></pre>
<h6 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h6><p><code>Map </code>结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回所有成员的遍历器</li>
<li>forEach()：遍历 Map 的所有成员</li>
</ul>
<p>遍历顺序就是插入顺序</p>
<pre><code class="javascript">const map = new Map([
  [&#39;F&#39;, &#39;no&#39;],
  [&#39;T&#39;,  &#39;yes&#39;],
]);

for (let key of map.keys()) &#123;
  console.log(key);
&#125;
// &quot;F&quot;
// &quot;T&quot;

for (let value of map.values()) &#123;
  console.log(value);
&#125;
// &quot;no&quot;
// &quot;yes&quot;

for (let item of map.entries()) &#123;
  console.log(item[0], item[1]);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 或者
for (let [key, value] of map.entries()) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 等同于使用map.entries()
for (let [key, value] of map) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

map.forEach(function(value, key, map) &#123;
  console.log(&quot;Key: %s, Value: %s&quot;, key, value);
&#125;);
</code></pre>
<h4 id="三、WeakSet-和-WeakMap"><a href="#三、WeakSet-和-WeakMap" class="headerlink" title="三、WeakSet 和 WeakMap"></a>三、WeakSet 和 WeakMap</h4><h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>创建<code>WeakSet</code>实例</p>
<pre><code class="javascript">const ws = new WeakSet();
</code></pre>
<p><code>WeakSet </code>可以接受一个具有 <code>Iterable </code>接口的对象作为参数</p>
<pre><code class="javascript">const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet &#123;[1, 2], [3, 4]&#125;
</code></pre>
<p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>size</code>属性</li>
</ul>
<p><code>WeackSet</code>只能成员只能是引用类型，而不能是其他类型的值</p>
<pre><code class="javascript">let ws=new WeakSet();

// 成员不是引用类型
let weakSet=new WeakSet([2,3]);
console.log(weakSet) // 报错

// 成员为引用类型
let obj1=&#123;name:1&#125;
let obj2=&#123;name:1&#125;
let ws=new WeakSet([obj1,obj2]); 
console.log(ws) //WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125;
</code></pre>
<p><code>WeakSet </code>里面的引用只要在外部消失，它在 <code>WeakSet </code>里面的引用就会自动消失</p>
<h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p>
<p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>clear</code>清空方法</li>
</ul>
<pre><code class="javascript">// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = &#123;foo: 1&#125;;
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]);
wm2.get(k2) // &quot;bar&quot;
</code></pre>
<p><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p>
<pre><code class="javascript">const map = new WeakMap();
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
</code></pre>
<p><code>WeakMap</code>的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p>
<p>举个场景例子：</p>
<p>在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构，当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除</p>
<pre><code class="javascript">const wm = new WeakMap();
const element = document.getElementById(&#39;example&#39;);
wm.set(element, &#39;some information&#39;);
wm.get(element) // &quot;some information&quot;
</code></pre>
<p>注意：<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用</p>
<p>下面代码中，键值<code>obj</code>会在<code>WeakMap</code>产生新的引用，当你修改<code>obj</code>不会影响到内部</p>
<pre><code class="javascript">const wm = new WeakMap();
let key = &#123;&#125;;
let obj = &#123;foo: 1&#125;;

wm.set(key, obj);
obj = null;
wm.get(key)
// Object &#123;foo: 1&#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-你是怎么理解ES6中-Promise的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-你是怎么理解ES6中-Promise的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 你是怎么理解ES6中 Promise的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 你是怎么理解ES6中 Promise的？使用场景？</h3><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p><code>Promise </code>，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p>
<p>在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码</p>
<pre><code class="javascript">doSomething(function(result) &#123;
  doSomethingElse(result, function(newResult) &#123;
    doThirdThing(newResult, function(finalResult) &#123;
      console.log(&#39;得到最终结果: &#39; + finalResult);
    &#125;, failureCallback);
  &#125;, failureCallback);
&#125;, failureCallback);
</code></pre>
<p>阅读上面代码，是不是很难受，上述形成了经典的回调地狱</p>
<p>现在通过<code>Promise</code>的改写上面的代码</p>
<pre><code class="javascript">doSomething().then(function(result) &#123;
  return doSomethingElse(result);
&#125;)
.then(function(newResult) &#123;
  return doThirdThing(newResult);
&#125;)
.then(function(finalResult) &#123;
  console.log(&#39;得到最终结果: &#39; + finalResult);
&#125;)
.catch(failureCallback);
</code></pre>
<p>瞬间感受到<code>promise</code>解决异步操作的优点：</p>
<ul>
<li>链式操作减低了编码难度</li>
<li>代码可读性明显增强</li>
</ul>
<p>下面我们正式来认识<code>promise</code>：</p>
<h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p><code>promise</code>对象仅有三种状态</p>
<ul>
<li><code>pending</code>（进行中）</li>
<li><code>fulfilled</code>（已成功）</li>
<li><code>rejected</code>（已失败）</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li>
<li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li>
</ul>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>认真阅读下图，我们能够轻松了解<code>promise</code>整个流程</p>
<p><img src="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31623032616539302d353861392d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例</p>
<pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;&#125;);
Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject
</code></pre>
<ul>
<li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li>
<li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”</li>
</ul>
<h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><p><code>Promise</code>构建出来的实例存在以下方法：</p>
<ul>
<li>then()</li>
<li>catch()</li>
<li>finally()</li>
</ul>
<h6 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h6><p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因</p>
<pre><code class="javascript">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  return json.post;
&#125;).then(function(post) &#123;
  // ...
&#125;);
</code></pre>
<h6 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h6><p><code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</p>
<pre><code class="javascript">getJSON(&#39;/posts.json&#39;).then(function(posts) &#123;
  // ...
&#125;).catch(function(error) &#123;
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&#39;发生错误！&#39;, error);
&#125;);
</code></pre>
<p><code>Promise </code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p>
<pre><code class="javascript">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;
  return getJSON(post.commentURL);
&#125;).then(function(comments) &#123;
  // some code
&#125;).catch(function(error) &#123;
  // 处理前面三个Promise产生的错误
&#125;);
</code></pre>
<p>一般来说，使用<code>catch</code>方法代替<code>then()</code>第二个参数</p>
<p><code>Promise </code>对象抛出的错误不会传递到外层代码，即不会有任何反应</p>
<pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;
</code></pre>
<p>浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程</p>
<p><code>catch()</code>方法之中，还能再抛出错误，通过后面<code>catch</code>方法捕获到</p>
<h6 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h6><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p>
<pre><code class="javascript">promise
.then(result =&gt; &#123;···&#125;)
.catch(error =&gt; &#123;···&#125;)
.finally(() =&gt; &#123;···&#125;);
</code></pre>
<h5 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h5><p><code>Promise</code>构造函数存在以下方法：</p>
<ul>
<li>all()</li>
<li>race()</li>
<li>allSettled()</li>
<li>resolve()</li>
<li>reject()</li>
<li>try()</li>
</ul>
<h6 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h6><p><code>Promise.all()</code>方法用于将多个 <code>Promise </code>实例，包装成一个新的 <code>Promise </code>实例</p>
<pre><code class="javascript">const p = Promise.all([p1, p2, p3]);
</code></pre>
<p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p>
<p>实例<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分为两种：</p>
<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li>
</ul>
<p>注意，如果作为参数的 <code>Promise</code> 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// Error: 报错了
</code></pre>
<h6 id="race"><a href="#race" class="headerlink" title="race()"></a>race()</h6><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p>
<pre><code class="javascript">const p = Promise.race([p1, p2, p3]);
</code></pre>
<p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变</p>
<p>率先改变的 Promise 实例的返回值则传递给<code>p</code>的回调函数</p>
<pre><code class="javascript">const p = Promise.race([
  fetch(&#39;/resource-that-may-take-a-while&#39;),
  new Promise(function (resolve, reject) &#123;
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)
  &#125;)
]);

p
.then(console.log)
.catch(console.error);
</code></pre>
<h6 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled()"></a>allSettled()</h6><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p>
<p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束</p>
<pre><code class="javascript">const promises = [
  fetch(&#39;/api-1&#39;),
  fetch(&#39;/api-2&#39;),
  fetch(&#39;/api-3&#39;),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
</code></pre>
<h6 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a>resolve()</h6><p>将现有对象转为 <code>Promise </code>对象</p>
<pre><code class="javascript">Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))
</code></pre>
<p>参数可以分成四种情况，分别如下：</p>
<ul>
<li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li>
<li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise </code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li>
<li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li>
<li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li>
</ul>
<h6 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h6><pre><code class="javascript">Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected
const p = Promise.reject(&#39;出错了&#39;);
// 等同于
const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))

p.then(null, function (s) &#123;
  console.log(s)
&#125;);
// 出错了
</code></pre>
<p><code>Promise.reject()</code>方法的参数，会原封不动地变成后续方法的参数</p>
<pre><code class="javascript">Promise.reject(&#39;出错了&#39;)
.catch(e =&gt; &#123;
  console.log(e === &#39;出错了&#39;)
&#125;)
// true
</code></pre>
<h4 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化</p>
<pre><code class="javascript">const preloadImage = function (path) &#123;
  return new Promise(function (resolve, reject) &#123;
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  &#125;);
&#125;;
</code></pre>
<p>通过链式操作，将多个渲染数据分别给个<code>then</code>，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题</p>
<pre><code class="javascript">// 各司其职
getInfo().then(res=&gt;&#123;
    let &#123; bannerList &#125; = res
    //渲染轮播图
    console.log(bannerList)
    return res
&#125;).then(res=&gt;&#123;
    
    let &#123; storeList &#125; = res
    //渲染店铺列表
    console.log(storeList)
    return res
&#125;).then(res=&gt;&#123;
    let &#123; categoryList &#125; = res
    console.log(categoryList)
    //渲染分类列表
    return res
&#125;)
</code></pre>
<p>通过<code>all()</code>实现多个请求合并在一起，汇总所有请求结果，只需设置一个<code>loading</code>即可</p>
<pre><code class="javascript">function initLoad()&#123;
    // loading.show() //加载loading
    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=&gt;&#123;
        console.log(res)
        loading.hide() //关闭loading
    &#125;).catch(err=&gt;&#123;
        console.log(err)
        loading.hide()//关闭loading
    &#125;)
&#125;
//数据初始化    
initLoad()
</code></pre>
<p>通过<code>race</code>可以设置图片请求超时</p>
<pre><code class="javascript">//请求某个图片资源
function requestImg()&#123;
    var p = new Promise(function(resolve, reject)&#123;
        var img = new Image();
        img.onload = function()&#123;
           resolve(img);
        &#125;
        //img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的
        img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;;
    &#125;);
    return p;
&#125;

//延时函数，用于给请求计时
function timeout()&#123;
    var p = new Promise(function(resolve, reject)&#123;
        setTimeout(function()&#123;
            reject(&#39;图片请求超时&#39;);
        &#125;, 5000);
    &#125;);
    return p;
&#125;

Promise
.race([requestImg(), timeout()])
.then(function(results)&#123;
    console.log(results);
&#125;)
.catch(function(reason)&#123;
    console.log(reason);
&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Generator的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Generator的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Generator的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Generator的？使用场景？</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p>回顾下上文提到的解决异步的手段：</p>
<ul>
<li>回调函数</li>
<li>promise</li>
</ul>
<p>那么，上文我们提到<code>promsie</code>已经是一种比较流行的解决异步方案，那么为什么还出现<code>Generator</code>？甚至<code>async/await</code>呢？</p>
<p>该问题我们留在后面再进行分析，下面先认识下<code>Generator</code></p>
<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>执行 <code>Generator</code> 函数会返回一个遍历器对象，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p>
<p>形式上，<code>Generator </code>函数是一个普通函数，但是有两个特征：</p>
<ul>
<li><code>function</code>关键字与函数名之间有一个星号</li>
<li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态</li>
</ul>
<pre><code class="javascript">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
</code></pre>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p><code>Generator</code> 函数会返回一个遍历器对象，即具有<code>Symbol.iterator</code>属性，并且返回给自己</p>
<pre><code class="javascript">function* gen()&#123;
  // some code
&#125;

var g = gen();

g[Symbol.iterator]() === g
// true
</code></pre>
<p>通过<code>yield</code>关键字可以暂停<code>generator</code>函数返回的遍历器对象的状态</p>
<pre><code class="javascript">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
var hw = helloWorldGenerator();
</code></pre>
<p>上述存在三个状态：<code>hello</code>、<code>world</code>、<code>return</code></p>
<p>通过<code>next</code>方法才会遍历到下一个内部状态，其运行逻辑如下：</p>
<ul>
<li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</li>
<li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li>
</ul>
<pre><code class="javascript">hw.next()
// &#123; value: &#39;hello&#39;, done: false &#125;

hw.next()
// &#123; value: &#39;world&#39;, done: false &#125;

hw.next()
// &#123; value: &#39;ending&#39;, done: true &#125;

hw.next()
// &#123; value: undefined, done: true &#125;
</code></pre>
<p><code>done</code>用来判断是否存在下个状态，<code>value</code>对应状态值</p>
<pre><code class="javascript">yield`表达式本身没有返回值，或者说总是返回`undefined
</code></pre>
<p>通过调用<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值</p>
<pre><code class="javascript">function* foo(x) &#123;
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
&#125;

var a = foo(5);
a.next() // Object&#123;value:6, done:false&#125;
a.next() // Object&#123;value:NaN, done:false&#125;
a.next() // Object&#123;value:NaN, done:true&#125;

var b = foo(5);
b.next() // &#123; value:6, done:false &#125;
b.next(12) // &#123; value:8, done:false &#125;
b.next(13) // &#123; value:42, done:true &#125;
</code></pre>
<p>正因为<code>Generator </code>函数返回<code>Iterator</code>对象，因此我们还可以通过<code>for...of</code>进行遍历</p>
<pre><code class="javascript">function* foo() &#123;
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
&#125;

for (let v of foo()) &#123;
  console.log(v);
&#125;
// 1 2 3 4 5
</code></pre>
<p>原生对象没有遍历接口，通过<code>Generator </code>函数为它加上这个接口，就能使用<code>for...of</code>进行遍历了</p>
<pre><code class="javascript">function* objectEntries(obj) &#123;
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) &#123;
    yield [propKey, obj[propKey]];
  &#125;
&#125;

let jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;

for (let [key, value] of objectEntries(jane)) &#123;
  console.log(`$&#123;key&#125;: $&#123;value&#125;`);
&#125;
// first: Jane
// last: Doe
</code></pre>
<h4 id="三、异步解决方案"><a href="#三、异步解决方案" class="headerlink" title="三、异步解决方案"></a>三、异步解决方案</h4><p>回顾之前展开异步解决的方案：</p>
<ul>
<li>回调函数</li>
<li>Promise 对象</li>
<li>generator 函数</li>
<li>async&#x2F;await</li>
</ul>
<p>这里通过文件读取案例，将几种解决异步的方案进行一个比较：</p>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数</p>
<pre><code class="javascript">fs.readFile(&#39;/etc/fstab&#39;, function (err, data) &#123;
  if (err) throw err;
  console.log(data);
  fs.readFile(&#39;/etc/shells&#39;, function (err, data) &#123;
    if (err) throw err;
    console.log(data);
  &#125;);
&#125;);
</code></pre>
<p><code>readFile</code>函数的第三个参数，就是回调函数，等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行</p>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p><code>Promise</code>就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;);

const readFile = function (fileName) &#123;
  return new Promise(function (resolve, reject) &#123;
    fs.readFile(fileName, function(error, data) &#123;
      if (error) return reject(error);
      resolve(data);
    &#125;);
  &#125;);
&#125;;


readFile(&#39;/etc/fstab&#39;).then(data =&gt;&#123;
    console.log(data)
    return readFile(&#39;/etc/shells&#39;)
&#125;).then(data =&gt; &#123;
    console.log(data)
&#125;)
</code></pre>
<p>这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强</p>
<h5 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h5><p><code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化</p>
<pre><code class="javascript">const gen = function* () &#123;
  const f1 = yield readFile(&#39;/etc/fstab&#39;);
  const f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<h5 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h5><p>将上面<code>Generator</code>函数改成<code>async/await</code>形式，更为简洁，语义化更强了</p>
<pre><code class="javascript">const asyncReadFile = async function () &#123;
  const f1 = await readFile(&#39;/etc/fstab&#39;);
  const f2 = await readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><p>通过上述代码进行分析，将<code>promise</code>、<code>Generator</code>、<code>async/await</code>进行比较：</p>
<ul>
<li><code>promise</code>和<code>async/await</code>是专门用于处理异步操作的</li>
<li><code>Generator</code>并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署<code>Interator</code>接口…）</li>
<li><code>promise</code>编写代码相比<code>Generator</code>、<code>async</code>更为复杂化，且可读性也稍差</li>
<li><code>Generator</code>、<code>async</code>需要与<code>promise</code>对象搭配处理异步情况</li>
<li><code>async</code>实质是<code>Generator</code>的语法糖，相当于会自动执行<code>Generator</code>函数</li>
<li><code>async</code>使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案</li>
</ul>
<h4 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h4><p><code>Generator</code>是异步解决的一种方案，最大特点则是将异步操作同步化表达出来</p>
<pre><code class="javascript">function* loadUI() &#123;
  showLoadingScreen();
  yield loadUIDataAsynchronously();
  hideLoadingScreen();
&#125;
var loader = loadUI();
// 加载UI
loader.next()

// 卸载UI
loader.next()
</code></pre>
<p>包括<code>redux-saga </code>中间件也充分利用了<code>Generator</code>特性</p>
<pre><code class="javascript">import &#123; call, put, takeEvery, takeLatest &#125; from &#39;redux-saga/effects&#39;
import Api from &#39;...&#39;

function* fetchUser(action) &#123;
   try &#123;
      const user = yield call(Api.fetchUser, action.payload.userId);
      yield put(&#123;type: &quot;USER_FETCH_SUCCEEDED&quot;, user: user&#125;);
   &#125; catch (e) &#123;
      yield put(&#123;type: &quot;USER_FETCH_FAILED&quot;, message: e.message&#125;);
   &#125;
&#125;

function* mySaga() &#123;
  yield takeEvery(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);
&#125;

function* mySaga() &#123;
  yield takeLatest(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);
&#125;

export default mySaga;
</code></pre>
<p>还能利用<code>Generator</code>函数，在对象上实现<code>Iterator</code>接口</p>
<pre><code class="javascript">function* iterEntries(obj) &#123;
  let keys = Object.keys(obj);
  for (let i=0; i &lt; keys.length; i++) &#123;
    let key = keys[i];
    yield [key, obj[key]];
  &#125;
&#125;

let myObj = &#123; foo: 3, bar: 7 &#125;;

for (let [key, value] of iterEntries(myObj)) &#123;
  console.log(key, value);
&#125;

// foo 3
// bar 7
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Proxy的？使用场景"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Proxy的？使用场景" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Proxy的？使用场景?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Proxy的？使用场景?</h3><p>定义： 用于定义基本操作的自定义行为</p>
<p>本质： 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程<code>(meta programming)</code></p>
<p>元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作</p>
<p>一段代码来理解</p>
<pre><code class="c">#!/bin/bash
# metaprogram
echo &#39;#!/bin/bash&#39; &gt;program
for ((I=1; I&lt;=1024; I++)) do
    echo &quot;echo $I&quot; &gt;&gt;program
done
chmod +x program
</code></pre>
<p>这段程序每执行一次能帮我们生成一个名为<code>program</code>的文件，文件内容为1024行<code>echo</code>，如果我们手动来写1024行代码，效率显然低效</p>
<ul>
<li>元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译</li>
</ul>
<p><code>Proxy</code> 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）</p>
<h4 id="二、用法-1"><a href="#二、用法-1" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Proxy</code>为 构造函数，用来生成 <code>Proxy </code>实例</p>
<pre><code class="javascript">var proxy = new Proxy(target, handler)
</code></pre>
<p>参数</p>
<p><code>target</code>表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））</p>
<p><code>handler</code>通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为</p>
<p>handler解析</p>
<p>关于<code>handler</code>拦截属性，有如下：</p>
<ul>
<li>get(target,propKey,receiver)：拦截对象属性的读取</li>
<li>set(target,propKey,value,receiver)：拦截对象属性的设置</li>
<li>has(target,propKey)：拦截<code>propKey in proxy</code>的操作，返回一个布尔值</li>
<li>deleteProperty(target,propKey)：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值</li>
<li>ownKeys(target)：拦截<code>Object.keys(proxy)</code>、<code>for...in</code>等循环，返回一个数组</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象</li>
<li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>，返回一个布尔值</li>
<li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值</li>
<li>getPrototypeOf(target)：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象</li>
<li>isExtensible(target)：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值</li>
<li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作</li>
</ul>
<p>Reflect</p>
<p>若需要在<code>Proxy</code>内部调用对象的默认行为，建议使用<code>Reflect</code>，其是<code>ES6</code>中操作对象而提供的新 <code>API</code></p>
<p>基本特点：</p>
<ul>
<li>只要<code>Proxy</code>对象具有的代理方法，<code>Reflect</code>对象全部具有，以静态方法的形式存在</li>
<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回<code>false</code>）</li>
<li>让<code>Object</code>操作都变成函数行为</li>
</ul>
<p>下面我们介绍<code>proxy</code>几种用法：</p>
<h5 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h5><p><code>get</code>接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身，最后一个参数可选</p>
<pre><code class="javascript">var person = &#123;
  name: &quot;张三&quot;
&#125;;

var proxy = new Proxy(person, &#123;
  get: function(target, propKey) &#123;
    return Reflect.get(target,propKey)
  &#125;
&#125;);

proxy.name // &quot;张三&quot;
</code></pre>
<p><code>get</code>能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引</p>
<pre><code class="javascript">function createArray(...elements) &#123;
  let handler = &#123;
    get(target, propKey, receiver) &#123;
      let index = Number(propKey);
      if (index &lt; 0) &#123;
        propKey = String(target.length + index);
      &#125;
      return Reflect.get(target, propKey, receiver);
    &#125;
  &#125;;

  let target = [];
  target.push(...elements);
  return new Proxy(target, handler);
&#125;

let arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
arr[-1] // c
</code></pre>
<p>注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错</p>
<pre><code class="javascript">const target = Object.defineProperties(&#123;&#125;, &#123;
  foo: &#123;
    value: 123,
    writable: false,
    configurable: false
  &#125;,
&#125;);

const handler = &#123;
  get(target, propKey) &#123;
    return &#39;abc&#39;;
  &#125;
&#125;;

const proxy = new Proxy(target, handler);

proxy.foo
// TypeError: Invariant check failed
</code></pre>
<h5 id="set-1"><a href="#set-1" class="headerlink" title="set()"></a>set()</h5><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 <code>Proxy</code> 实例本身</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求</p>
<pre><code class="javascript">let validator = &#123;
  set: function(obj, prop, value) &#123;
    if (prop === &#39;age&#39;) &#123;
      if (!Number.isInteger(value)) &#123;
        throw new TypeError(&#39;The age is not an integer&#39;);
      &#125;
      if (value &gt; 200) &#123;
        throw new RangeError(&#39;The age seems invalid&#39;);
      &#125;
    &#125;

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  &#125;
&#125;;

let person = new Proxy(&#123;&#125;, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错
</code></pre>
<p>如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用</p>
<pre><code class="javascript">const obj = &#123;&#125;;
Object.defineProperty(obj, &#39;foo&#39;, &#123;
  value: &#39;bar&#39;,
  writable: false,
&#125;);

const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = &#39;baz&#39;;
  &#125;
&#125;;

const proxy = new Proxy(obj, handler);
proxy.foo = &#39;baz&#39;;
proxy.foo // &quot;bar&quot;
</code></pre>
<p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错</p>
<pre><code class="javascript">&#39;use strict&#39;;
const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;
</code></pre>
<h5 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h5><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除</p>
<pre><code class="javascript">var handler = &#123;
  deleteProperty (target, key) &#123;
    invariant(key, &#39;delete&#39;);
    Reflect.deleteProperty(target,key)
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`无法删除私有属性`);
  &#125;
&#125;

var target = &#123; _prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: 无法删除私有属性
</code></pre>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错</p>
<h5 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h5><pre><code class="javascript">Proxy.revocable(target, handler);
</code></pre>
<h4 id="三、使用场景-1"><a href="#三、使用场景-1" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p><code>Proxy</code>其功能非常类似于设计模式中的代理模式，常用功能如下：</p>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<p>使用 <code>Proxy</code> 保障数据类型的准确性</p>
<pre><code class="javascript">let numericDataStore = &#123; count: 0, amount: 1234, total: 14 &#125;;
numericDataStore = new Proxy(numericDataStore, &#123;
    set(target, key, value, proxy) &#123;
        if (typeof value !== &#39;number&#39;) &#123;
            throw Error(&quot;属性只能是number类型&quot;);
        &#125;
        return Reflect.set(target, key, value, proxy);
    &#125;
&#125;);

numericDataStore.count = &quot;foo&quot;
// Error: 属性只能是number类型

numericDataStore.count = 333
// 赋值成功
</code></pre>
<p>声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></p>
<pre><code class="javascript">let api = &#123;
    _apiKey: &#39;123abc456def&#39;,
    getUsers: function()&#123; &#125;,
    getUser: function(userId)&#123; &#125;,
    setUser: function(userId, config)&#123; &#125;
&#125;;
const RESTRICTED = [&#39;_apiKey&#39;];
api = new Proxy(api, &#123;
    get(target, key, proxy) &#123;
        if(RESTRICTED.indexOf(key) &gt; -1) &#123;
            throw Error(`$&#123;key&#125; 不可访问.`);
        &#125; return Reflect.get(target, key, proxy);
    &#125;,
    set(target, key, value, proxy) &#123;
        if(RESTRICTED.indexOf(key) &gt; -1) &#123;
            throw Error(`$&#123;key&#125; 不可修改`);
        &#125; return Reflect.get(target, key, value, proxy);
    &#125;
&#125;);

console.log(api._apiKey)
api._apiKey = &#39;987654321&#39;
// 上述都抛出错误
</code></pre>
<p>还能通过使用<code>Proxy</code>实现观察者模式</p>
<p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行</p>
<p><code>observable</code>函数返回一个原始对象的 <code>Proxy</code> 代理，拦截赋值操作，触发充当观察者的各个函数</p>
<pre><code class="javascript">const queuedObservers = new Set();

const observe = fn =&gt; queuedObservers.add(fn);
const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);

function set(target, key, value, receiver) &#123;
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer =&gt; observer());
  return result;
&#125;
</code></pre>
<p>观察者函数都放进<code>Set</code>集合，当修改<code>obj</code>的值，在会<code>set</code>函数中拦截，自动执行<code>Set</code>所有的观察者</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Module的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Module的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Module的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Module的？使用场景？</h3><h4 id="一、介绍-1"><a href="#一、介绍-1" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>模块，（Module），是能够单独命名并独立地完成一定功能的程序语句集合（即程序代码和数据结构的集合体）。</p>
<p>两个基本的特征：外部特征和内部</p>
<ul>
<li>外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能</li>
<li>内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）</li>
</ul>
<h5 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h5><ul>
<li>代码抽象</li>
<li>代码封装</li>
<li>代码复用</li>
<li>依赖管理</li>
</ul>
<p>如果没有模块化，我们代码会怎样？</p>
<ul>
<li>变量和方法不容易维护，容易污染全局作用域</li>
<li>加载资源的方式通过script标签从上到下。</li>
<li>依赖的环境主观逻辑偏重，代码较多就会比较复杂。</li>
<li>大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃</li>
</ul>
<p>因此，需要一种将<code>JavaScript</code>程序模块化的机制，如</p>
<ul>
<li>CommonJs (典型代表：node.js早期)</li>
<li>AMD (典型代表：require.js)</li>
<li>CMD (典型代表：sea.js)</li>
</ul>
<h5 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h5><p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p>
<p>代表库为<code>require.js</code></p>
<pre><code class="javascript">/** main.js 入口文件/主模块 **/
// 首先用config()指定各模块路径和引用名
require.config(&#123;
  baseUrl: &quot;js/lib&quot;,
  paths: &#123;
    &quot;jquery&quot;: &quot;jquery.min&quot;,  //实际路径为js/lib/jquery.min.js
    &quot;underscore&quot;: &quot;underscore.min&quot;,
  &#125;
&#125;);
// 执行基本操作
require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123;
  // some code here
&#125;);
</code></pre>
<h5 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h5><p><code>CommonJS</code> 是一套 <code>Javascript</code> 模块规范，用于服务端</p>
<pre><code class="javascript">// a.js
module.exports=&#123; foo , bar&#125;

// b.js
const &#123; foo,bar &#125; = require(&#39;./a.js&#39;)
</code></pre>
<p>其有如下特点：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li>
<li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>
<li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li>
</ul>
<p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p>
<p>ES6 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以取代 <code>CommonJS </code>和 <code>AMD </code>规范，成为浏览器和服务器通用的模块解决方案</p>
<p><code>CommonJS</code> 和<code> AMD</code> 模块，都只能在运行时确定这些东西。比如，<code>CommonJS </code>模块就是对象，输入时必须查找对象属性</p>
<pre><code class="javascript">// CommonJS模块
let &#123; stat, exists, readfile &#125; = require(&#39;fs&#39;);

// 等同于
let _fs = require(&#39;fs&#39;);
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
</code></pre>
<p><code>ES6</code>设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
<pre><code class="javascript">// ES6模块
import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;
</code></pre>
<p>上述代码，只加载3个方法，其他方法不加载，即 <code>ES6</code> 可以在编译时就完成模块加载</p>
<p>由于编译加载，使得静态分析成为可能。包括现在流行的<code>typeScript</code>也是依靠静态分析实现功能</p>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p><code>ES6</code>模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是<code>ES5</code>之前就已经规定好</p>
<p>模块功能主要由两个命令构成：</p>
<ul>
<li><code>export</code>：用于规定模块的对外接口</li>
<li><code>import</code>：用于输入其他模块提供的功能</li>
</ul>
<h5 id="export"><a href="#export" class="headerlink" title="export"></a>export</h5><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p>
<pre><code class="javascript">// profile.js
export var firstName = &#39;Michael&#39;;
export var lastName = &#39;Jackson&#39;;
export var year = 1958;

或 
// 建议使用下面写法，这样能瞬间确定输出了哪些变量
var firstName = &#39;Michael&#39;;
var lastName = &#39;Jackson&#39;;
var year = 1958;

export &#123; firstName, lastName, year &#125;;
</code></pre>
<p>输出函数或类</p>
<pre><code class="javascript">export function multiply(x, y) &#123;
  return x * y;
&#125;;
</code></pre>
<p>通过<code>as</code>可以进行输出变量的重命名</p>
<pre><code class="javascript">function v1() &#123; ... &#125;
function v2() &#123; ... &#125;

export &#123;
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
&#125;;
</code></pre>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块</p>
<pre><code class="javascript">// main.js
import &#123; firstName, lastName, year &#125; from &#39;./profile.js&#39;;

function setName(element) &#123;
  element.textContent = firstName + &#39; &#39; + lastName;
&#125;
</code></pre>
<p>同样如果想要输入变量起别名，通过<code>as</code>关键字</p>
<pre><code class="javascript">import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;
</code></pre>
<p>当加载整个模块的时候，需要用到星号<code>*</code></p>
<pre><code class="javascript">// circle.js
export function area(radius) &#123;
  return Math.PI * radius * radius;
&#125;

export function circumference(radius) &#123;
  return 2 * Math.PI * radius;
&#125;

// main.js
import * as circle from &#39;./circle&#39;;
console.log(circle)   // &#123;area:area,circumference:circumference&#125;
</code></pre>
<p>输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性</p>
<pre><code class="javascript">import &#123;a&#125; from &#39;./xxx.js&#39;

a.foo = &#39;hello&#39;; // 合法操作
a = &#123;&#125;; // Syntax Error : &#39;a&#39; is read-only;
</code></pre>
<p>不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错</p>
<p><code>import</code>后面我们常接着<code>from</code>关键字，<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径</p>
<pre><code class="javascript">import &#123; a &#125; from &#39;./a&#39;;
</code></pre>
<p>如果只有一个模块名，需要有配置文件，告诉引擎模块的位置</p>
<pre><code class="javascript">import &#123; myMethod &#125; from &#39;util&#39;;
</code></pre>
<p>在编译阶段，<code>import</code>会提升到整个模块的头部，首先执行</p>
<pre><code class="javascript">foo();

import &#123; foo &#125; from &#39;my_module&#39;;
</code></pre>
<p>多次重复执行同样的导入，只会执行一次</p>
<pre><code class="javascript">import &#39;lodash&#39;;
import &#39;lodash&#39;;
</code></pre>
<p>上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载</p>
<p>如果不需要知道变量名或函数就完成加载，就要用到<code>export default</code>命令，为模块指定默认输出</p>
<pre><code class="javascript">// export-default.js
export default function () &#123;
    console.log(&#39;foo&#39;);
&#125;
</code></pre>
<p>加载该模块的时候，<code>import</code>命令可以为该函数指定任意名字</p>
<pre><code class="javascript">// import-default.js
import customName from &#39;./export-default&#39;;
customName(); // &#39;foo&#39;
</code></pre>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p>
<p>这个新功能允许您将<code>import()</code>作为函数调用，将其作为参数传递给模块的路径。 它返回一个 <code>promise</code>，它用一个模块对象来实现，让你可以访问该对象的导出</p>
<pre><code class="javascript">import(&#39;/modules/myModule.mjs&#39;)
  .then((module) =&gt; &#123;
    // Do something with the module.
  &#125;);
</code></pre>
<h4 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h4><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起</p>
<pre><code class="javascript">export &#123; foo, bar &#125; from &#39;my_module&#39;;

// 可以简单理解为
import &#123; foo, bar &#125; from &#39;my_module&#39;;
export &#123; foo, bar &#125;;
</code></pre>
<p>同理能够搭配<code>as</code>、<code>*</code>搭配使用</p>
<h4 id="三、使用场景-2"><a href="#三、使用场景-2" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>如今，<code>ES6</code>模块化已经深入我们日常项目开发中，像<code>vue</code>、<code>react</code>项目搭建项目，组件化开发处处可见，其也是依赖模块化实现</p>
<p><code>vue</code>组件</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;App&quot;&gt;
      组件化开发 ---- 模块化
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;HelloWorld&#39;,
  props: &#123;
    msg: String
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p><code>react</code>组件</p>
<pre><code class="javascript">function App() &#123;
  return (
    &lt;div className=&quot;App&quot;&gt;
        组件化开发 ---- 模块化
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>包括完成一些复杂应用的时候，我们也可以拆分成各个模块</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Decorator-的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Decorator-的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Decorator 的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Decorator 的？使用场景？</h3><h4 id="一、介绍-2"><a href="#一、介绍-2" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>Decorator，即装饰器，从名字上很容易让我们联想到装饰者模式</p>
<p>简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。</p>
<p><code>ES6</code>中<code>Decorator</code>功能亦如此，其本质也不是什么高大上的结构，就是一个普通的函数，用于扩展类属性和类方法</p>
<p>这里定义一个士兵，这时候他什么装备都没有</p>
<pre><code class="javascript">class soldier&#123; 
&#125;
</code></pre>
<p>定义一个得到 AK 装备的函数，即装饰器</p>
<pre><code class="javascript">function strong(target)&#123;
    target.AK = true
&#125;
</code></pre>
<p>使用该装饰器对士兵进行增强</p>
<pre><code class="javascript">@strong
class soldier&#123;
&#125;
</code></pre>
<p>这时候士兵就有武器了</p>
<pre><code class="javascript">soldier.AK // true
</code></pre>
<p>上述代码虽然简单，但也能够清晰看到了使用<code>Decorator</code>两大优点：</p>
<ul>
<li>代码可读性变强了，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原来功能进行扩展</li>
</ul>
<h4 id="二、用法-2"><a href="#二、用法-2" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Docorator</code>修饰对象为下面两种：</p>
<ul>
<li>类的装饰</li>
<li>类属性的装饰</li>
</ul>
<h5 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h5><p>当对类本身进行装饰的时候，能够接受一个参数，即类本身</p>
<p>将装饰器行为进行分解，大家能够有个更深入的了解</p>
<pre><code class="javascript">@decorator
class A &#123;&#125;

// 等同于

class A &#123;&#125;
A = decorator(A) || A;
</code></pre>
<p>下面<code>@testable</code>就是一个装饰器，<code>target</code>就是传入的类，即<code>MyTestableClass</code>，实现了为类添加静态属性</p>
<pre><code class="javascript">@testable
class MyTestableClass &#123;
  // ...
&#125;

function testable(target) &#123;
  target.isTestable = true;
&#125;

MyTestableClass.isTestable // true
</code></pre>
<p>如果想要传递参数，可以在装饰器外层再封装一层函数</p>
<pre><code class="javascript">function testable(isTestable) &#123;
  return function(target) &#123;
    target.isTestable = isTestable;
  &#125;
&#125;

@testable(true)
class MyTestableClass &#123;&#125;
MyTestableClass.isTestable // true

@testable(false)
class MyClass &#123;&#125;
MyClass.isTestable // false
</code></pre>
<h5 id="类属性的装饰"><a href="#类属性的装饰" class="headerlink" title="类属性的装饰"></a>类属性的装饰</h5><p>当对类属性进行装饰的时候，能够接受三个参数：</p>
<ul>
<li>类的原型对象</li>
<li>需要装饰的属性名</li>
<li>装饰属性名的描述对象</li>
</ul>
<p>首先定义一个<code>readonly</code>装饰器</p>
<pre><code class="javascript">function readonly(target, name, descriptor)&#123;
  descriptor.writable = false; // 将可写属性设为false
  return descriptor;
&#125;
</code></pre>
<p>使用<code>readonly</code>装饰类的<code>name</code>方法</p>
<pre><code class="javascript">class Person &#123;
  @readonly
  name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;
&#125;
</code></pre>
<p>相当于以下调用</p>
<pre><code class="javascript">readonly(Person.prototype, &#39;name&#39;, descriptor);
</code></pre>
<p>如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行</p>
<pre><code class="javascript">function dec(id)&#123;
    console.log(&#39;evaluated&#39;, id);
    return (target, property, descriptor) =&gt;console.log(&#39;executed&#39;, id);
&#125;

class Example &#123;
    @dec(1)
    @dec(2)
    method()&#123;&#125;
&#125;
// evaluated 1
// evaluated 2
// executed 2
// executed 1
</code></pre>
<p>外层装饰器<code>@dec(1)</code>先进入，但是内层装饰器<code>@dec(2)</code>先执行</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>装饰器不能用于修饰函数，因为函数存在变量声明情况</p>
<pre><code class="javascript">var counter = 0;

var add = function () &#123;
  counter++;
&#125;;

@add
function foo() &#123;
&#125;
</code></pre>
<p>编译阶段，变成下面</p>
<pre><code class="javascript">var counter;
var add;

@add
function foo() &#123;
&#125;

counter = 0;

add = function () &#123;
  counter++;
&#125;;
</code></pre>
<p>意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0</p>
<h4 id="三、使用场景-3"><a href="#三、使用场景-3" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>基于<code>Decorator</code>强大的作用，我们能够完成各种场景的需求，下面简单列举几种：</p>
<p>使用<code>react-redux</code>的时候，如果写成下面这种形式，既不雅观也很麻烦</p>
<pre><code class="javascript">class MyReactComponent extends React.Component &#123;&#125;

export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);
</code></pre>
<p>通过装饰器就变得简洁多了</p>
<pre><code class="javascript">@connect(mapStateToProps, mapDispatchToProps)
export default class MyReactComponent extends React.Component &#123;&#125;
</code></pre>
<p>将<code>mixins</code>，也可以写成装饰器，让使用更为简洁了</p>
<pre><code class="javascript">function mixins(...list) &#123;
  return function (target) &#123;
    Object.assign(target.prototype, ...list);
  &#125;;
&#125;

// 使用
const Foo = &#123;
  foo() &#123; console.log(&#39;foo&#39;) &#125;
&#125;;

@mixins(Foo)
class MyClass &#123;&#125;

let obj = new MyClass();
obj.foo() // &quot;foo&quot;
</code></pre>
<p>下面再讲讲<code>core-decorators.js</code>几个常见的装饰器</p>
<h5 id="antobind"><a href="#antobind" class="headerlink" title="@antobind"></a>@antobind</h5><p><code>autobind</code>装饰器使得方法中的<code>this</code>对象，绑定原始对象</p>
<pre><code class="javascript">import &#123; autobind &#125; from &#39;core-decorators&#39;;

class Person &#123;
  @autobind
  getPerson() &#123;
    return this;
  &#125;
&#125;

let person = new Person();
let getPerson = person.getPerson;

getPerson() === person;
// true
</code></pre>
<h5 id="readonly"><a href="#readonly" class="headerlink" title="@readonly"></a>@readonly</h5><p><code>readonly</code>装饰器使得属性或方法不可写</p>
<pre><code class="javascript">import &#123; readonly &#125; from &#39;core-decorators&#39;;

class Meal &#123;
  @readonly
  entree = &#39;steak&#39;;
&#125;

var dinner = new Meal();
dinner.entree = &#39;salmon&#39;;
// Cannot assign to read only property &#39;entree&#39; of [object Object]
</code></pre>
<h4 id="deprecate"><a href="#deprecate" class="headerlink" title="@deprecate"></a>@deprecate</h4><p><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除</p>
<pre><code class="javascript">import &#123; deprecate &#125; from &#39;core-decorators&#39;;

class Person &#123;
  @deprecate
  facepalm() &#123;&#125;

  @deprecate(&#39;功能废除了&#39;)
  facepalmHard() &#123;&#125;
&#125;

let person = new Person();

person.facepalm();
// DEPRECATION Person#facepalm: This function will be removed in future versions.

person.facepalmHard();
// DEPRECATION Person#facepalmHard: 功能废除了
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-Symbol数据类型"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-Symbol数据类型" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Symbol数据类型"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Symbol数据类型</h3><p>ES6引入一种新的原始数据类型为 Symbol ，表示为 独一无二 的值，用来定义独一无二的对象属性名。</p>
<h4 id="Symbol的讲解"><a href="#Symbol的讲解" class="headerlink" title="Symbol的讲解"></a>Symbol的讲解</h4><p>4个方面说说Symbol数据类型：</p>
<ol>
<li>Symbol的定义；</li>
<li>Symbol作为对象属性名；</li>
<li>Symbol使用场景；</li>
<li>Symbol获取。</li>
</ol>
<h4 id="Symbol的定义"><a href="#Symbol的定义" class="headerlink" title="Symbol的定义"></a>Symbol的定义</h4><ul>
<li>一种Symbol类型可以通过使用Symbol()函数来生成；</li>
<li>Symbol()函数可以接收一个字符串作为参数</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let s1 = Symbol(&#39;web&#39;);
let s2 = Symbol(&#39;web&#39;);
console.log(s1 === s2);
console.log(typeof s1);
console.log(typeof s2);
复制代码
</code></pre>
<p>chrome截图：</p>
<p><img src="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/170563012a3ecec6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p>由图可知：Symbol()函数接收的参数相同，其变量的值也不同，s1和s2是Symbol类型的变量，因为变量的值不同，所以打印的结果为false。使用typeof来获取相应的类型，所以打印的结果都为symbol。</p>
<h4 id="Symbol作为对象属性名"><a href="#Symbol作为对象属性名" class="headerlink" title="Symbol作为对象属性名"></a>Symbol作为对象属性名</h4><p>Symbol可以通过三种方式作为对象属性名。</p>
<ul>
<li>第一种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;&#125;;
a[symbol] = &#39;web&#39;;
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，一个空的对象为a，通过a[symbol]给a对象赋值一个web的字符串。表示symbol作为对象属性名，web作为它的属性值。</p>
<ul>
<li>第二种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;
    [symbol]:&#39;web&#39;
&#125;;
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，接着在声明对象a的同时通过[symbol]给a对象性赋值为web的字符串。</p>
<ul>
<li>第三种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;&#125;;
Object.defineProperty(a, symbol, &#123;value: &#39;web&#39;&#125;);
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，一个空对象为a，通过Object.defineProperty()方法给a对象赋值为web的字符串。</p>
<blockquote>
<p>Symbol的值作为对象属性名，是不能用点运算符的。</p>
</blockquote>
<h4 id="Symbol使用场景"><a href="#Symbol使用场景" class="headerlink" title="Symbol使用场景"></a>Symbol使用场景</h4><p>一种有两种使用场景：</p>
<ol>
<li>因为Symbol的值是均不相等的，所以Symbol类型的值作为对象属性名，不会出现重复。</li>
<li>代码形成强耦合的某一个具体的字符串。</li>
</ol>
<h4 id="Symbol获取"><a href="#Symbol获取" class="headerlink" title="Symbol获取"></a>Symbol获取</h4><p>通过Object.getOwnPropertySymbols()方法，可以获取指定对象的所有Symbols属性名。:</p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mengfeng.github.io/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/10/31/%E7%A7%8B%E5%A4%A9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%83%A4%E7%BA%A2%E8%96%AF/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            秋天的第一个烤红薯
          
        </div>
      </a>
    
    
      <a href="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">前端面试大全服务端</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '6887374e7666a97fd4dc',
    clientSecret: '09a8e143dd4a3f5d11311e1435842321e063157d',
    repo: 'mengfeng.github.io',
    owner: 'mengfeng',
    admin: ['mengfeng'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>