<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Apifox和Leancloud"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/25/Apifox%E5%92%8CLeancloud/"
    >Apifox和Leancloud</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/25/Apifox%E5%92%8CLeancloud/" class="article-date">
  <time datetime="2022-12-25T02:17:56.000Z" itemprop="datePublished">2022-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/uniapp/">uniapp</a> / <a class="article-category-link" href="/categories/uniapp/Apifox%E5%92%8CLeancloud/">Apifox和Leancloud</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Apifox和Leancloud"><a href="#Apifox和Leancloud" class="headerlink" title="Apifox和Leancloud"></a>Apifox和Leancloud</h1><blockquote>
<p>我们为什么选择Apifox和Leancloud的组合呢</p>
<p>Apifox也是一款可以模拟接口的一款工具，当然也不只可以模拟接口</p>
<p>Leancloud选择是当我们去开发一些小的应用的时候，我们降低开发成本的时候，我们就可以去选择Leancloud去当我们的平台进行数据存储，还是比较方便的。</p>
</blockquote>
<h3 id="一、Apifox下载"><a href="#一、Apifox下载" class="headerlink" title="一、Apifox下载"></a>一、Apifox下载</h3><p>访问<a target="_blank" rel="noopener" href="https://www.apifox.cn/">官网</a>进行下载</p>
<p>有付费和免费的，根据需求下载</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225090853860.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225091357277.png"></p>
<p>我们可以去新建我们的项目和接口</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225092715766.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225093542358.png"></p>
<p>下面会讲如何设置和填写参数以便于和Leancloud去交互请求</p>
<h3 id="二、Leancloud注册登陆"><a href="#二、Leancloud注册登陆" class="headerlink" title="二、Leancloud注册登陆"></a>二、Leancloud注册登陆</h3><p>我们访问<a target="_blank" rel="noopener" href="https://www.leancloud.cn/">官网</a>注册登陆</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225093702335.png"></p>
<p>然后来到我们的控制台创建我们的应用</p>
<p>我们可以对我们每个应用分开管理</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225093850074.png"></p>
<p>我们每个应用都有自己的信息</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094016973.png"></p>
<p>大家测试的时候可以使用自己的应用信息配置</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094046589.png"></p>
<h3 id="三、配置Apifox"><a href="#三、配置Apifox" class="headerlink" title="三、配置Apifox"></a>三、配置Apifox</h3><blockquote>
<p>当我们应用和Apifox环境准备完毕，那么我们就可以根据文档来配置了</p>
</blockquote>
<p>文档-&gt;REST API-&gt;数据存储</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094258347.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094449937.png"></p>
<h4 id="1-新建接口"><a href="#1-新建接口" class="headerlink" title="1.新建接口"></a>1.新建接口</h4><p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094537626.png"></p>
<p>在配置我们的接口的前提是要选好我们接口运行的环境</p>
<p>让我们先配置一下环境</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094638510.png"></p>
<p>我们可以将我们的服务改成我们Leancloud平台的开放服务地址（后续我们可以改成我们的域名）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094725724.png"></p>
<p>根据文档来配置</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095251514.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095213854.png"></p>
<p>Header-&gt;批量编辑-&gt;冒号模式（然后将负责的配置修改成下面这种格式就可以了）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095423023.png"></p>
<p>下一步我们来携带参数body</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095604642.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095717122.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095746960.png"></p>
<p>修改状态码并添加响应示例</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095819827.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095940926.png"></p>
<p>保存运行</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225100023787.png"></p>
<p>出error了，修复它（给body添加示例值就可以了）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225100109578.png"></p>
<h4 id="2-发起请求"><a href="#2-发起请求" class="headerlink" title="2.发起请求"></a>2.发起请求</h4><p>我们发送（响应成功）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225101014178.png"></p>
<h3 id="四、Leancloud"><a href="#四、Leancloud" class="headerlink" title="四、Leancloud"></a>四、Leancloud</h3><p>当我们查看Leancloud应用的时候，发现我们多了一张表和数据，表示我们的请求已经成功</p>
<blockquote>
<p>我们还可以根据文档来修改，查找，删除我们的数据表，代码中的配置也是一样的，这样我们就可以利用LeanCloud来搭建我们一个小应用的数据表了。</p>
</blockquote>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225101228952.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225101502303.png"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leancloud/" rel="tag">leancloud</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vue-eventBus"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/23/Vue-eventBus/"
    >Vue-eventBus</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/23/Vue-eventBus/" class="article-date">
  <time datetime="2022-12-23T01:13:58.000Z" itemprop="datePublished">2022-12-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/uniapp/">uniapp</a> / <a class="article-category-link" href="/categories/uniapp/Vue-eventBus/">Vue-eventBus</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Vue-eventBus"><a href="#Vue-eventBus" class="headerlink" title="Vue-eventBus"></a>Vue-eventBus</h1><p>父子组件通信与兄弟组件通信</p>
<p>vue组件非常常见的有父子组件通信，兄弟组件通信。</p>
<pre><code>父子组件通信：方法有很多，比如：父组件通过 props 向下传数据给子组件，子组件通过 $emit 告诉父组件。
兄弟组件通信：如果两个页面没有任何引入和被引入关系，需要额外的组件来通信，如：事件总线、Vuex。
</code></pre>
<h3 id="一、事件总线是什么"><a href="#一、事件总线是什么" class="headerlink" title="一、事件总线是什么"></a>一、事件总线是什么</h3><p>EventBus 又称为事件总线。在Vue中可以使用 EventBus 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件。</p>
<pre><code>EventBus若使用不慎，就会造成难以维护的“灾难”，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。 
</code></pre>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>解决了多层组件之间繁琐的事件传播。<br>使用原理十分简单，代码量少</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的EventBus会被移除，这样就导致业务走不下去。<br>如果业务有反复操作的页面，EventBus在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理EventBus在项目中的关系。通常在vue页面销毁时，同时移除EventBus事件监听。</p>
<p>由于是都使用一个Vue实例，所以容易出现重复触发的情景：两个页面都定义了同一个事件名，并且没有用$off销毁（常出现在路由切换时）。</p>
<h3 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h3><h4 id="1-创建事件"><a href="#1-创建事件" class="headerlink" title="1.创建事件"></a>1.创建事件</h4><p>首先需要创建事件总线并将其导出，以便其它模块可以使用或者监听它。</p>
<p>方法1、非全局事件组件</p>
<p> 新建EventBus.js</p>
<pre><code class="javascript">import Vue from &#39;vue&#39;
export const EventBus = new Vue()
</code></pre>
<p>法2、全局事件组件</p>
<p>在项目中的 main.js 初始化 EventBus。在main.js添加如下一行：</p>
<pre><code class="javascript">Vue.prototype.$EventBus = new Vue()
</code></pre>
<p>示例：</p>
<pre><code class="vue">import Vue from &#39;vue&#39;
import App from &#39;./App&#39;
import router from &#39;./router&#39;

Vue.config.productionTip = false

Vue.prototype.$EventBus = new Vue();

/* eslint-disable no-new */
new Vue(&#123;
  el: &#39;#app&#39;,
  router,
  components: &#123; App &#125;,
  template: &#39;&lt;App/&gt;&#39;
&#125;)
</code></pre>
<p>组件发送事件：this.$EventBus.$emit(…)</p>
<p>组件接收事件：this.$EventBus.$on(…)</p>
<p>移除事件</p>
<p>一般在销毁组件（也就是离开组件）时移除事件。</p>
<pre><code class="javascript">beforeDestroy()&#123;
  EventBus.$off(&quot;eventName&quot;)
&#125;
</code></pre>
<p>EventBus.$off()                           &#x2F;&#x2F;移除EventBus所有事件监听器</p>
<p>EventBus.$off(‘eventName’)       &#x2F;&#x2F;移除’eventName’事件所有监听器</p>
<p>EventBus.$off(‘eventName’, callback)    &#x2F;&#x2F;只移除这个回调的监听器。</p>
<h4 id="2-事件运用"><a href="#2-事件运用" class="headerlink" title="2.事件运用"></a>2.事件运用</h4><p>本文父组件：CompA.vue，子组件1：ChildOne.vue，子组件2：ChildTwo.vue。子组件1发送事件给父组件和子组件2。</p>
<pre><code class="javascript">router/index.js

import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import CompA from &quot;@/components/CompA&quot;;

Vue.use(Router)

export default new Router(&#123;
  routes: [
    &#123;
      path: &#39;/compA&#39;,
      name: &#39;compA&#39;,
      component: CompA,
    &#125;
  ],
&#125;)
</code></pre>
<p>1.创建EventBus</p>
<p> 新建EventBus.js</p>
<pre><code class="javascript">import Vue from &#39;vue&#39;
export const EventBus = new Vue()
</code></pre>
<p>2.发送事件</p>
<p> components&#x2F;ChildOne.vue</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;childOne&quot;&gt;
    &lt;h1&gt;childOne&lt;/h1&gt;
    &lt;button @click=&quot;sendEvent2CompA&quot;&gt;发送事件给父组件（CompA）&lt;/button&gt;
    &lt;button @click=&quot;sendEvent2ChildTwo&quot;&gt;发送事件给兄弟组件（ChildTwo）&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;EventBus&#125; from &quot;./EventBus&quot;

export default &#123;
  data() &#123;
    return &#123;
      count1: 0,
      count2: 0,
    &#125;
  &#125;,
  methods:&#123;
    sendEvent2CompA() &#123;
      this.count1++;
      EventBus.$emit(&quot;compA&quot;, &quot;compA事件触发次数：&quot; + this.count1)
    &#125;,
    sendEvent2ChildTwo() &#123;
      this.count2++;
      EventBus.$emit(&quot;childTwo&quot;, &quot;childTwo事件触发次数：&quot; + this.count2)
    &#125;
  &#125;
&#125;
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<p>3.接收事件</p>
<p>父组件：components&#x2F;CompA.vue</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;compA&quot;&gt;
    &lt;h1&gt;compA&lt;/h1&gt;
    compA收到的事件内容：&#123;&#123;msg&#125;&#125;&lt;hr&gt;
    &lt;child-one&gt;&lt;/child-one&gt;&lt;hr&gt;
    &lt;child-two&gt;&lt;/child-two&gt;

  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;EventBus&#125; from &quot;./EventBus&quot;
import ChildOne from &quot;@/components/ChildOne&quot;;
import ChildTwo from &quot;@/components/ChildTwo&quot;;

export default &#123;
  components: &#123;ChildOne, ChildTwo&#125;,
  data() &#123;
    return &#123;
      msg: &quot;&quot;,
    &#125;
  &#125;,
  mounted() &#123;
    EventBus.$on(&quot;compA&quot;, (payload1)=&gt; &#123;
      this.msg = payload1;
    &#125;)
  &#125;
&#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>子组件2：components&#x2F;ChildTwo.vue</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;childTwo&quot;&gt;
    &lt;h1&gt;childTwo&lt;/h1&gt;
    childTwo收到的事件内容：&#123;&#123;msg&#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;EventBus&#125; from &quot;./EventBus&quot;

export default &#123;
  data() &#123;
    return &#123;
      msg: &quot;&quot;,
    &#125;
  &#125;,
  mounted() &#123;
    EventBus.$on(&quot;childTwo&quot;, (payload1)=&gt; &#123;
      this.msg = payload1;
    &#125;)
  &#125;
&#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>事物都有两面性，没有好坏之分，且全在于使用者，好钢用在刀刃上，不滥用即可。有其他更好的方式则优先使用。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/eventBus/" rel="tag">eventBus</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-uniapp生命周期"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/20/uniapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
    >uniapp生命周期</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/20/uniapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time datetime="2022-12-20T01:59:16.000Z" itemprop="datePublished">2022-12-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/uniapp/">uniapp</a> / <a class="article-category-link" href="/categories/uniapp/uniapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">uniapp生命周期</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="uniapp生命周期"><a href="#uniapp生命周期" class="headerlink" title="uniapp生命周期"></a>uniapp生命周期</h1><h3 id="一、应用生命周期"><a href="#一、应用生命周期" class="headerlink" title="一、应用生命周期"></a>一、应用生命周期</h3><p>uni-app 支持如下应用生命周期函数：</p>
<p><img src="/2022/12/20/uniapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20221220094520002.png"></p>
<p>这几个函数主要还是在App.vue这个文件进行定义，注意：</p>
<p>应用生命周期仅可在App.vue中监听，在其它页面监听无效。<br>onlaunch里进行页面跳转</p>
<p>onPageNotFound 页面实际上已经打开了（比如通过分享卡片、小程序码）且发现页面不存在，才会触发，api 跳转不存在的页面不会触发（如 uni.navigateTo）</p>
<h3 id="二、页面生命周期"><a href="#二、页面生命周期" class="headerlink" title="二、页面生命周期"></a>二、页面生命周期</h3><p><code>uni-app</code> 支持如下页面生命周期函数：</p>
<table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">说明</th>
<th align="left">平台差异说明</th>
<th align="left">最低版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onInit</td>
<td align="left">监听页面初始化，其参数同 onLoad 参数，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad</td>
<td align="left">百度小程序</td>
<td align="left">3.1.0+</td>
</tr>
<tr>
<td align="left">onLoad</td>
<td align="left">监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考<a target="_blank" rel="noopener" href="https://zh.uniapp.dcloud.io/api/router#navigateto">示例</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onShow</td>
<td align="left">监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onReady</td>
<td align="left">监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onHide</td>
<td align="left">监听页面隐藏</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onUnload</td>
<td align="left">监听页面卸载</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onResize</td>
<td align="left">监听窗口尺寸变化</td>
<td align="left">App、微信小程序、快手小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onPullDownRefresh</td>
<td align="left">监听用户下拉动作，一般用于下拉刷新，参考<a target="_blank" rel="noopener" href="https://zh.uniapp.dcloud.io/api/ui/pulldown">示例</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onReachBottom</td>
<td align="left">页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。具体见下方注意事项</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onTabItemTap</td>
<td align="left">点击 tab 时触发，参数为Object，具体见下方注意事项</td>
<td align="left">微信小程序、QQ小程序、支付宝小程序、百度小程序、H5、App、快手小程序、京东小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onShareAppMessage</td>
<td align="left">用户点击右上角分享</td>
<td align="left">微信小程序、QQ小程序、支付宝小程序、字节小程序、飞书小程序、快手小程序、京东小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onPageScroll</td>
<td align="left">监听页面滚动，参数为Object</td>
<td align="left">nvue暂不支持</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onNavigationBarButtonTap</td>
<td align="left">监听原生标题栏按钮点击事件，参数为Object</td>
<td align="left">App、H5</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onBackPress</td>
<td align="left">监听页面返回，返回 event &#x3D; {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：<a target="_blank" rel="noopener" href="http://ask.dcloud.net.cn/article/35120">onBackPress 详解</a>。支付宝小程序只有真机能触发，只能监听非navigateBack引起的返回，不可阻止默认行为。</td>
<td align="left">app、H5、支付宝小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onNavigationBarSearchInputChanged</td>
<td align="left">监听原生标题栏搜索输入框输入内容变化事件</td>
<td align="left">App、H5</td>
<td align="left">1.6.0</td>
</tr>
<tr>
<td align="left">onNavigationBarSearchInputConfirmed</td>
<td align="left">监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。</td>
<td align="left">App、H5</td>
<td align="left">1.6.0</td>
</tr>
<tr>
<td align="left">onNavigationBarSearchInputClicked</td>
<td align="left">监听原生标题栏搜索输入框点击事件（pages.json 中的 searchInput 配置 disabled 为 true 时才会触发）</td>
<td align="left">App、H5</td>
<td align="left">1.6.0</td>
</tr>
<tr>
<td align="left">onShareTimeline</td>
<td align="left">监听用户点击右上角转发到朋友圈</td>
<td align="left">微信小程序</td>
<td align="left">2.8.1+</td>
</tr>
<tr>
<td align="left">onAddToFavorites</td>
<td align="left">监听用户点击右上角收藏</td>
<td align="left">微信小程序、QQ小程序</td>
<td align="left">2.8.1+</td>
</tr>
</tbody></table>
<p><code>onInit</code>使用注意</p>
<ul>
<li>仅百度小程序基础库 3.260 以上支持 onInit 生命周期</li>
<li>其他版本或平台可以同时使用 onLoad 生命周期进行兼容，注意避免重复执行相同逻辑</li>
<li>不依赖页面传参的逻辑可以直接使用 created 生命周期替代</li>
</ul>
<p><code>onReachBottom</code>使用注意 可在pages.json里定义具体页面底部的触发距离<a target="_blank" rel="noopener" href="https://zh.uniapp.dcloud.io/collocation/pages#globalstyle">onReachBottomDistance</a>，比如设为50，那么滚动页面到距离底部50px时，就会触发onReachBottom事件。</p>
<p>如使用scroll-view导致页面没有滚动，则触底事件不会被触发。scroll-view滚动到底部的事件请参考scroll-view的文档</p>
<p><code>onPageScroll</code> （监听滚动、滚动监听、滚动事件）参数说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scrollTop</td>
<td>Number</td>
<td>页面在垂直方向已滚动的距离（单位px）</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li><code>onPageScroll</code>里不要写交互复杂的js，比如频繁修改页面。因为这个生命周期是在渲染层触发的，在非h5端，js是在逻辑层执行的，两层之间通信是有损耗的。如果在滚动过程中，频发触发两层之间的数据交换，可能会造成卡顿。</li>
<li>如果想实现滚动时标题栏透明渐变，在App和H5下，可在pages.json中配置titleNView下的type为transparent，<a target="_blank" rel="noopener" href="https://uniapp.dcloud.io/collocation/pages?id=app-titlenview">参考</a>。</li>
<li>如果需要滚动吸顶固定某些元素，推荐使用css的粘性布局，参考<a target="_blank" rel="noopener" href="https://ext.dcloud.net.cn/plugin?id=715">插件市场</a>。插件市场也有其他js实现的吸顶插件，但性能不佳，需要时可自行搜索。</li>
<li>在App、微信小程序、H5中，也可以使用wxs监听滚动，<a target="_blank" rel="noopener" href="https://uniapp.dcloud.io/tutorial/miniprogram-subject#wxs">参考</a>；在app-nvue中，可以使用bindingx监听滚动，<a target="_blank" rel="noopener" href="https://uniapp.dcloud.io/tutorial/nvue-api#nvue-%E9%87%8C%E4%BD%BF%E7%94%A8-bindingx">参考</a>。</li>
<li><code>onBackPress</code>上不可使用<code>async</code>，会导致无法阻止默认返回</li>
</ul>
<pre><code class="js">onPageScroll : function(e) &#123; //nvue暂不支持滚动监听，可用bindingx代替
    console.log(&quot;滚动距离为：&quot; + e.scrollTop);
&#125;,
</code></pre>
<p><code>onTabItemTap</code> 返回的json对象说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>Number</td>
<td>被点击tabItem的序号，从0开始</td>
</tr>
<tr>
<td>pagePath</td>
<td>String</td>
<td>被点击tabItem的页面路径</td>
</tr>
<tr>
<td>text</td>
<td>String</td>
<td>被点击tabItem的按钮文字</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li>onTabItemTap常用于点击当前tabitem，滚动或刷新当前页面。如果是点击不同的tabitem，一定会触发页面切换。</li>
<li>如果想在App端实现点击某个tabitem不跳转页面，不能使用onTabItemTap，可以使用<a target="_blank" rel="noopener" href="http://www.html5plus.org/doc/zh_cn/nativeobj.html">plus.nativeObj.view</a>放一个区块盖住原先的tabitem，并拦截点击事件。</li>
<li>支付宝小程序平台onTabItemTap表现为点击非当前tabitem后触发，因此不能用于实现点击返回顶部这种操作</li>
</ul>
<pre><code class="js">onTabItemTap : function(e) &#123;
    console.log(e);
    // e的返回格式为json对象： &#123;&quot;index&quot;:0,&quot;text&quot;:&quot;首页&quot;,&quot;pagePath&quot;:&quot;pages/index/index&quot;&#125;
&#125;,
</code></pre>
<p><code>onNavigationBarButtonTap</code> 参数说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>Number</td>
<td>原生标题栏按钮数组的下标</td>
</tr>
</tbody></table>
<pre><code class="js">onNavigationBarButtonTap : function (e) &#123;
    console.log(e);
    // e的返回格式为json对象：&#123;&quot;text&quot;:&quot;测试&quot;,&quot;index&quot;:0&#125;
&#125;
</code></pre>
<p><code>onBackPress</code> 回调参数对象说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>from</td>
<td>String</td>
<td>触发返回行为的来源：’backbutton’——左上角导航栏按钮及安卓返回键；’navigateBack’——uni.navigateBack() 方法。<strong>支付宝小程序端不支持返回此字段</strong></td>
</tr>
</tbody></table>
<pre><code class="javascript">export default &#123;
    data() &#123;
        return &#123;&#125;;
    &#125;,
    onBackPress(options) &#123;
        console.log(&#39;from:&#39; + options.from)
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong></p>
<ul>
<li>nvue 页面weex编译模式支持的生命周期同weex，具体参考：<a target="_blank" rel="noopener" href="https://uniapp.dcloud.io/tutorial/nvue-outline?id=%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F">weex生命周期介绍</a>。</li>
<li>支付宝小程序真机可以监听到非<code>navigateBack</code>引发的返回事件（使用小程序开发工具时不会触发<code>onBackPress</code>），不可以阻止默认返回行为</li>
</ul>
<h3 id="三、组件生命周期"><a href="#三、组件生命周期" class="headerlink" title="三、组件生命周期"></a>三、组件生命周期</h3><p><code>uni-app</code> 组件支持的生命周期，与vue标准组件的生命周期相同。这里没有页面级的onLoad等生命周期：</p>
<table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">说明</th>
<th align="left">平台差异说明</th>
<th align="left">最低版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">在实例初始化之前被调用。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#beforeCreate">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">在实例创建完成后被立即调用。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#created">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">在挂载开始之前被调用。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#beforeMount">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">挂载到实例上去之后调用。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#mounted">详见</a> 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用<code>$nextTick</code><a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#vm-nextTick">Vue官方文档</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">数据更新时调用，发生在虚拟 DOM 打补丁之前。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#beforeUpdate">详见</a></td>
<td align="left">仅H5平台支持</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">updated</td>
<td align="left">由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#updated">详见</a></td>
<td align="left">仅H5平台支持</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td align="left">实例销毁之前调用。在这一步，实例仍然完全可用。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#beforeDestroy">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">destroyed</td>
<td align="left">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#destroyed">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[uniapp]: 	“<a target="_blank" rel="noopener" href="https://zh.uniapp.dcloud.io/tutorial/page.html#lifecycle">https://zh.uniapp.dcloud.io/tutorial/page.html#lifecycle</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/uniapp/" rel="tag">uniapp</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-uniapp安装及调试"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/"
    >uniapp安装及调试</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/" class="article-date">
  <time datetime="2022-12-18T02:50:45.000Z" itemprop="datePublished">2022-12-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/uniapp/">uniapp</a> / <a class="article-category-link" href="/categories/uniapp/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/">uniapp安装及调试</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="uniapp安装及调试"><a href="#uniapp安装及调试" class="headerlink" title="uniapp安装及调试"></a>uniapp安装及调试</h1><blockquote>
<p>我们本篇文章主要讲解uniapp的项目创建</p>
<p>真机调试、ios模拟器调试、微信小程序调试</p>
</blockquote>
<h3 id="一、下载HBuilder-X"><a href="#一、下载HBuilder-X" class="headerlink" title="一、下载HBuilder X"></a>一、下载HBuilder X</h3><p>[HBuilder X]: 	“<a target="_blank" rel="noopener" href="https://www.dcloud.io/hbuilderx.html">https://www.dcloud.io/hbuilderx.html</a> “</p>
<p>我们可以下载我们需要的版本</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218095304650.png"></p>
<h3 id="二、安装运行并创建项目"><a href="#二、安装运行并创建项目" class="headerlink" title="二、安装运行并创建项目"></a>二、安装运行并创建项目</h3><p>第一次打开HBuilder X，我们可以去定义一下我们的配置，macos是去偏好设置，windows的在工具-&gt;设置</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218095514743.png"></p>
<p>我们可以去新建项目弹出窗口配置我们项目信息，项目名称和vue版本，这里我现在的是vue3，vue3的绑定预设是vite。</p>
<p>我们也可以去选择不一样的模板。</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218095735225.png"></p>
<h3 id="三、运行项目"><a href="#三、运行项目" class="headerlink" title="三、运行项目"></a>三、运行项目</h3><p>当我们打开项目的时候，准备运行的时候，我们可以选择将我们的项目运行到哪里，它会提示你安装相对应的插件，如果安装完插件，我们的软件没有识别到我们的插件，那我们可以选择重启我们的软件。</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218100111748.png"></p>
<p>这里先演示一下运行到内置浏览器（第一次运行我们可能要稍等一下）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218100428208.png"></p>
<h3 id="四、调试"><a href="#四、调试" class="headerlink" title="四、调试"></a>四、调试</h3><h4 id="1-ios模拟器调试"><a href="#1-ios模拟器调试" class="headerlink" title="1.ios模拟器调试"></a>1.ios模拟器调试</h4><blockquote>
<p>当然，在ios模拟器调试的前提是要是macos环境，并且下载了xcode（提前准备一下哦）因为我没有ios手机🫠</p>
</blockquote>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218100850001.png"></p>
<p>我们选择运行到ios模拟器 App基座（loading…）</p>
<p>选择我们的模拟器手机型号</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218101003209.png"></p>
<p>现在我就可以看到程序运行到了我们的iPhone 14 Pro Max（香得嘞）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218101115311.png"></p>
<p>当我们修改我们的程序代码并保存，就可以看见我们的视图更新了</p>
<h4 id="2-Android手机真机调试"><a href="#2-Android手机真机调试" class="headerlink" title="2.Android手机真机调试"></a>2.Android手机真机调试</h4><blockquote>
<p>当然，没有Android手机的也可以借其他同学的（Android模拟器配置有点麻烦，就先不配置了，想配置的同学先自行打开搜索🔍）</p>
</blockquote>
<p>手机真机调试的前提是要打开你的手机的开发者模式，不同的手机开启的方式也是不一样的，我的手机是红米K20 pro</p>
<p>具体打开流程为设置-&gt;我的设备-&gt;全部参数-&gt;点击MIUI版本3下（连击）系统提示进入开发者模式-&gt;返回到更多设置-&gt;开发者选项-&gt;打开usb调试</p>
<p>当我们选择运行到Android App基座，就会识别你的手机（记得用数据线将手机连接到电脑），点击运行</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218102154748.png"></p>
<p>第一次运行，手机会让你安装，点击安装就可以了</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/WechatIMG125.jpeg"></p>
<h4 id="3-微信小程序开发者工具调试"><a href="#3-微信小程序开发者工具调试" class="headerlink" title="3.微信小程序开发者工具调试"></a>3.微信小程序开发者工具调试</h4><blockquote>
<p>这个调试的方式的前提是要有一个开发者账号，没有的同学要先去注册一个</p>
<p>[注册]: 	“<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN">https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN</a> “</p>
<p>然后利用注册绑定的微信登陆我们的微信公众平台</p>
<p>没有下载微信开发者工具的同学也要下载一个</p>
</blockquote>
<p>然后在我们的开发-&gt;开发管理-&gt;开发设置下面有我们的开发者ID（等会要用）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218102931643.png"></p>
<p>当我们点击发行-&gt;小程序-微信的时候，会让你配置你的开发者ID，然后项目就会自动打包</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218103403063.png"></p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218103530235.png"></p>
<p>第一次编译的时候，我们可以根据编译完成的项目路径去手动导入我们的微信开发者工具去调试</p>
<p>注意：不要在微信开发者工具去修改我们的代码，因为下一次发行编译会覆盖掉我们的修改</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218103710649.png"></p>
<p>当然，我们还有另一种导入方法，那就是自动导入</p>
<p>首先我们要将微信开发者工具的安全设置的服务端口打开</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218104049483.png"></p>
<p>再到HBuilder X去配置微信开发者工具的路径（这里的路径可以查看自己的安装路径）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218104502864.png"></p>
<p>到这我们的配置就完成了</p>
<p>接下来我们再发行微信小程序</p>
<p>我们就可以看见微信开发者工具自动打开并运行我们的项目了</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218104719407.png"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>到目前为止，我们开发时候的调试就可以轻松掌握了</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/uniapp/" rel="tag">uniapp</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vue3api变化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/16/Vue3api%E5%8F%98%E5%8C%96/"
    >Vue3api变化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/16/Vue3api%E5%8F%98%E5%8C%96/" class="article-date">
  <time datetime="2022-12-16T01:20:02.000Z" itemprop="datePublished">2022-12-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue3/">Vue3</a> / <a class="article-category-link" href="/categories/Vue3/Vue3api%E5%8F%98%E5%8C%96/">Vue3api变化</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><blockquote>
<p>官网地址：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/">https://cn.vuejs.org/</a><br>vue最新版分为两个版本： Vue3.0（20年9月18日） Vue 3.2 （21年8月10日）</p>
</blockquote>
<h3 id="Vue-3-2-Vite-volar"><a href="#Vue-3-2-Vite-volar" class="headerlink" title="Vue 3.2 +Vite+volar"></a><strong>Vue 3.2 +Vite+volar</strong></h3><ul>
<li>Vue3 框架做了大量的性能优化，包括虚拟 DOM，编译模板、代理的新数据监听，体积更小的打包文件等。</li>
<li>新的组合式 API （composition-api），更适合大型项目的构建，去除繁琐的 this 操作；</li>
<li>由于是基于 TypeScript 编写，对 TypeScript 原生支持更好，更强大的智能类型推导功能；</li>
<li>生命周期的一些改变，vue2 中的 beforeCreate 和 created 被一个新增的 setup 生命周期函数代替；</li>
<li>一些常见 API 如 v-model 的变化，支持对一个组件同时进行多个 v-model 的数据绑定。</li>
</ul>
<p>vscode 的插件 vetur 对vue3 的composition API语法支持度非常弱，所以开发vue3项目需要将vetur禁用 更换另一个插件</p>
<p>开发vue3安装并使用： volar 插件</p>
<h3 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h3><p>Vite 官网：<a target="_blank" rel="noopener" href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a></p>
<pre><code class="json">yarn create vite my-vue-app --template vue     
</code></pre>
<h3 id="2-SFC-单文件组件"><a href="#2-SFC-单文件组件" class="headerlink" title="2.SFC 单文件组件"></a>2.SFC 单文件组件</h3><blockquote>
<p>html 部分变化不大<br>vue2的 template 中只能有一个子节点，vue3的 template 中可以写多个子节点<br>js 部分内置ts，但是vite创建的项目没有开启 ， <code>&lt;script lang=&quot;ts&quot; setup&gt;</code> 这样写即可支持ts<br>新增setup 语法糖，js代码大量简化<br>代码中不再出现 <code>this</code><br>css 代码中 可以使用v-bind 指令</p>
</blockquote>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
       let color = &#39;#f60&#39;;
&lt;/script&gt;

&lt;style scoped&gt;
.box&#123;
  width: 100px;
  height: 100px;
  background: v-bind(color);
&#125;
&lt;/style&gt;
</code></pre>
<h3 id="2-setup语法糖"><a href="#2-setup语法糖" class="headerlink" title="2. setup语法糖"></a>2. setup语法糖</h3><p>起初 Vue3.0 暴露变量必须 return 出来，template中才能使用； 这样会导致在页面上变量会出现很多次。</p>
<p>vue3.2只需在script标签中添加setup,可以帮助我们解决这个问题。</p>
<p>1.组件只需引入不用注册，属性和方法也不用返回， 也不用写setup函数，也不用写export default ， 甚至是自定义指令也可以在我们的template中自动获得。</p>
<h2 id="3-data-定义"><a href="#3-data-定义" class="headerlink" title="3.data 定义"></a>3.data 定义</h2><h3 id="3-1-直接定义-无响应式"><a href="#3-1-直接定义-无响应式" class="headerlink" title="3.1 直接定义 无响应式"></a>3.1 直接定义 无响应式</h3><pre><code class="html">&lt;template&gt;
  &lt;div&gt;
      &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;
      &lt;!-- 这里双向绑定失效，直接定义变量没有响应式特性 --&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  let name = &#39;张麻子&#39;;

&lt;/script&gt;
</code></pre>
<h3 id="3-2-ref-定义基本数据类型-有响应式"><a href="#3-2-ref-定义基本数据类型-有响应式" class="headerlink" title="3.2 ref 定义基本数据类型 有响应式"></a>3.2 ref 定义基本数据类型 有响应式</h3><pre><code class="html">&lt;template&gt;
  &lt;div&gt;
      &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;
       &lt;!-- 修改数据 有响应式 --&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;
      &lt;button @click=&quot;setData&quot;&gt;修改数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
 import &#123;ref&#125; from &#39;vue&#39;;   
    
 let name = ref(&#39;张麻子&#39;);
   //js中修改数据有响应式
 const setData = ()=&gt;&#123;
     name.value = &#39;黄四郎&#39;
 &#125;
     
&lt;/script&gt;
</code></pre>
<h3 id="3-3-reactvie-定义引用数据类型-有响应式"><a href="#3-3-reactvie-定义引用数据类型-有响应式" class="headerlink" title="3.3 reactvie 定义引用数据类型 有响应式"></a>3.3 reactvie 定义引用数据类型 有响应式</h3><pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
      &lt;h2&gt;&#123;&#123;user.name&#125;&#125;&lt;/h2&gt;
      &lt;!-- 修改数据 有响应式 --&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt;
      &lt;!-- 新增属性 --&gt;
      &lt;button @click=&quot;addItem&quot;&gt;新增属性&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import &#123;ref,reactive&#125; from &#39;vue&#39;
let user = reactive(&#123;
  name:&#39;张麻子&#39;,
  age:40
&#125;)
// js中新增对象属性-可以直接赋值和修改（有响应式），在ts环境下，vscode会提示错误，但在页面中可以正常渲染
const addItem = ()=&gt;&#123;
  user.like=&#39;打豆豆&#39;
&#125;

&lt;/script&gt;
</code></pre>
<h2 id="4-methods-方法定义"><a href="#4-methods-方法定义" class="headerlink" title="4.methods 方法定义"></a>4.methods 方法定义</h2><pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 年龄 + --&gt;
    &lt;h1&gt;&#123;&#123;user.age&#125;&#125;&lt;/h1&gt;
    &lt;!-- 调用方法 --&gt;
    &lt;button @click=&quot;addAge&quot;&gt;年龄+&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import &#123; ref, reactive &#125; from &quot;vue&quot;;

let user = reactive(&#123;
  name: &quot;张麻子&quot;,
  age: 40,
&#125;);
//方法
const addAge=()=&gt;&#123;
    user.age++;
&#125;
//方法调用方法
const getUserInfo=()=&gt;&#123;
  addAge()
  console.log(user.age)
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="5-computed-计算属性"><a href="#5-computed-计算属性" class="headerlink" title="5.computed 计算属性"></a>5.computed 计算属性</h2><pre><code class="java">&lt;script setup&gt;
import &#123; ref, reactive, computed &#125; from &quot;vue&quot;;

let user = reactive(&#123;
  name: &quot;张麻子&quot;,
  age: 40,
&#125;);
//计算属性
const getAge = computed(()=&gt;&#123;
  return &#39;我的年龄&#39;+user.age
&#125;)
&lt;/script&gt;
</code></pre>
<h2 id="6-watch-使用"><a href="#6-watch-使用" class="headerlink" title="6.watch 使用"></a>6.watch 使用</h2><pre><code class="json">watch(监听数据源,执行函数,[配置参数])    
//配置参数： 立即执行 深度监听
&#123;immediate: true, deep: true &#125;
</code></pre>
<h3 id="6-1-监听基本数据类型单一数据源"><a href="#6-1-监听基本数据类型单一数据源" class="headerlink" title="6.1 监听基本数据类型单一数据源"></a>6.1 监听基本数据类型单一数据源</h3><pre><code class="javascript">&lt;script setup&gt;
import &#123;ref, watch&#125; from &#39;vue&#39;
 let name = ref(&#39;张麻子&#39;)

 //监听器
watch(name,(newVal,oldVal)=&gt;&#123;
    console.log(&#39;变量发生了改变...&#39;,newVal);
&#125;)
&lt;/script&gt;
</code></pre>
<h3 id="6-2-监听引用数据类型单一数据源"><a href="#6-2-监听引用数据类型单一数据源" class="headerlink" title="6.2 监听引用数据类型单一数据源"></a>6.2 监听引用数据类型单一数据源</h3><pre><code class="java">&lt;script setup&gt;
import &#123;reactive, ref, watch&#125; from &#39;vue&#39;
let user = reactive(&#123;name:&#39;张三&#39;,age:14&#125;)
 //监听器
watch(()=&gt;user.name,(newVal,oldVal)=&gt;&#123;
  console.log(&#39;对象user中的name属性发生了变化..&#39;,newVal);
&#125;)
&lt;/script&gt;
</code></pre>
<h3 id="6-3-监听引用数据类型-多数据源-深度监听"><a href="#6-3-监听引用数据类型-多数据源-深度监听" class="headerlink" title="6.3 监听引用数据类型 多数据源[深度监听]"></a>6.3 监听引用数据类型 多数据源[深度监听]</h3><pre><code class="java">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;addNum()&quot;&gt; 添加随机数&lt;/button&gt;
    &lt;div v-for=&quot;item in nums&quot; :key=&quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import &#123; reactive, ref, watch &#125; from &#39;vue&#39;
let nums = reactive([]);

//添加随机数
const addNum = () =&gt; &#123;
  let num = Math.ceil(Math.random() * 100);
  nums.push(num);
&#125;
//监听数组变化-深度监听
watch(()=&gt;nums,(newVal,oldVal)=&gt;&#123;
    console.log(&#39;nums数组发生了变化..&#39;,newVal);
&#125;,&#123;deep:true&#125;)

&lt;/script&gt;
</code></pre>
<h2 id="7-生命周期"><a href="#7-生命周期" class="headerlink" title="7.生命周期"></a>7.生命周期</h2><table>
<thead>
<tr>
<th>vue2</th>
<th>vue3.0</th>
<th>vue3.2</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td></td>
<td>setup</td>
<td>组件创建之前 可以获取顶级实例对象</td>
</tr>
<tr>
<td>created</td>
<td></td>
<td>setup</td>
<td>组件创建完成，可以获取变量</td>
</tr>
<tr>
<td>beforeMount</td>
<td></td>
<td>onBeforeMount</td>
<td>挂载前，VNdom创建完成，真实dom未渲染</td>
</tr>
<tr>
<td>mounted</td>
<td></td>
<td>onMounted</td>
<td>挂载完成，真实dom创建完成，可以获取dom</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td></td>
<td>onBeforeUpdate</td>
<td>dom更新前触发</td>
</tr>
<tr>
<td>updated</td>
<td></td>
<td>onUpdated</td>
<td>dom更新完成触发</td>
</tr>
<tr>
<td>beforedestroy，destroyed</td>
<td>beforeUnmount</td>
<td>onBeforeUnmount</td>
<td>组件卸载后触发 所有的挂载的数据 子组件全部卸载后触发</td>
</tr>
<tr>
<td></td>
<td>errorCaptured</td>
<td>onErrorCaptured</td>
<td>在捕获一个来自后代组件的错误时被调用</td>
</tr>
<tr>
<td></td>
<td>renderTracked</td>
<td>onRenderTracked</td>
<td>跟踪虚拟 DOM 重新渲染时调用</td>
</tr>
<tr>
<td></td>
<td>renderTriggered</td>
<td>onRenderTriggered</td>
<td>当虚拟 DOM 重新渲染被触发时调用</td>
</tr>
<tr>
<td>activated</td>
<td>activated</td>
<td>onActivated</td>
<td>缓存组件激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>deactivated</td>
<td>onDeactivated</td>
<td>缓存组件失活时调用</td>
</tr>
</tbody></table>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
      &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import &#123; onMounted &#125; from &#39;vue&#39;;
  //生命周期钩子监听
  onMounted(()=&gt;&#123;
    console.log(document.querySelector(&#39;.box&#39;)); //可以获取dom
  &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="8-组件使用"><a href="#8-组件使用" class="headerlink" title="8.组件使用"></a>8.组件使用</h2><ul>
<li>创建 src&#x2F;components&#x2F;Son.vue</li>
<li>App.vue中导入并使用该组件</li>
</ul>
<p>vue3.2 中当我们导入子组件时，setup语法糖会自动去注册该组件，所以注册语句不用写了。</p>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
    &lt;son&gt;&lt;/son&gt;
  &lt;/div&gt;
&lt;script setup&gt;
import Son from &#39;./components/Son.vue&#39;
&lt;/script&gt;
</code></pre>
<h2 id="9-组件通信"><a href="#9-组件通信" class="headerlink" title="9.组件通信"></a>9.组件通信</h2><h3 id="9-1-父传子-defineProps"><a href="#9-1-父传子-defineProps" class="headerlink" title="9.1 父传子 defineProps"></a>9.1 父传子 defineProps</h3><ul>
<li>父组件</li>
</ul>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
      &lt;Son class=&quot;box&quot; title=&quot;我是父组件传递的标题&quot; :likes=&quot;likes&quot;&gt;&lt;/Son&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  import Son from &#39;./components/Son.vue&#39;
  let likes = [&#39;张三&#39;,&#39;李四&#39;]
&lt;/script&gt;
</code></pre>
<ul>
<li>子组件</li>
</ul>
<pre><code class="java">&lt;script setup&gt;
const props=defineProps(&#123;
    title:&#123;
        type:String,
        default:&#39;&#39;
    &#125;,
    likes:&#123;
        type:Array,
        default:()=&gt;[]
    &#125;
&#125;)
&lt;/script&gt;
</code></pre>
<h3 id="9-2-子传父-defineEmits"><a href="#9-2-子传父-defineEmits" class="headerlink" title="9.2 子传父 defineEmits"></a>9.2 子传父 defineEmits</h3><ul>
<li>子组件</li>
</ul>
<pre><code class="java">&lt;template&gt;
    &lt;div&gt;
        &lt;button @click=&quot;sendData&quot;&gt;传递数据&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
//定义自定义事件
const emit = defineEmits([&#39;send&#39;])
//自己的事件执行函数
const sendData = () =&gt; &#123;
    //执行自定义事件
    emit(&#39;send&#39;, &#39;我是儿子组件传递的数据&#39;)
&#125;
&lt;/script&gt;
</code></pre>
<ul>
<li>父组件</li>
</ul>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
      &lt;Son class=&quot;box&quot;  @send=&quot;getData&quot; &gt;&lt;/Son&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  import Son from &#39;./components/Son.vue&#39;
  //触发自定义事件-接收数据
  const getData = (data)=&gt;&#123;
    console.log(data);
  &#125;
&lt;/script&gt;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue3/" rel="tag">vue3</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-chatGPT是什么"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/chatGPT%E6%98%AF%E4%BB%80%E4%B9%88/"
    >chatGPT是什么</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/chatGPT%E6%98%AF%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2022-12-14T01:04:08.000Z" itemprop="datePublished">2022-12-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/">趣味技术</a> / <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/chatGPT%E6%98%AF%E4%BB%80%E4%B9%88/">chatGPT是什么</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="chatGPT是什么"><a href="#chatGPT是什么" class="headerlink" title="chatGPT是什么"></a>chatGPT是什么</h1><blockquote>
<p>我们都知道目前火出圈的AI绘画和chatGPT</p>
<p>那么它们是什么呢？</p>
</blockquote>
<h3 id="一、chatGPT是什么"><a href="#一、chatGPT是什么" class="headerlink" title="一、chatGPT是什么"></a>一、chatGPT是什么</h3><p><strong>ChatGPT</strong>是由<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/OpenAI">OpenAI</a>开发的一个<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%81%8A%E5%A4%A9%E6%A9%9F%E5%99%A8%E4%BA%BA">聊天机器人</a>程序，于2022年11月推出。该程序使用基于<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/GPT-3">GPT-3.5</a>架构的<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%AA%9E%E8%A8%80%E6%A8%A1%E5%9E%8B">大型语言模型</a>并通过<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0">强化学习</a>进行训练。它以对话方式进行交互。在推广的期间中，所有人可以免费注册，并在登入后后免费使用 ChatGPT 实现与 AI 机器人对话</p>
<p>有世界首富——电动汽车巨头特斯拉掌门人马斯克（ Elon Musk）入股的研发公司OpenAI表示，最新推出的聊天机器人ChatGPT在不到一周时间里就拥有百万用户。</p>
<p>ChatGPT是OpenAI发布的聊天机器人模型，它的交互界面简洁，只有一个输入框，AI将根据输入内容进行回复，并允许在一个语境下持续聊天。</p>
<p><img src="/2022/12/14/chatGPT%E6%98%AF%E4%BB%80%E4%B9%88/image-20221214085330016.png"></p>
<h3 id="二、如何强大"><a href="#二、如何强大" class="headerlink" title="二、如何强大"></a>二、如何强大</h3><p>据浙商和国盛证券研报，ChatGPT相比以往的主要提升点在于记忆能力，ChatGPT可以储存对话信息，延续上下文，从而实现连续对话，这在对话场景中至关重要，极大地提升了对话交互模式下的用户体验。</p>
<p>具体而言，此次新加入的训练方式被称为“从人类反馈中强化学习”（ReinforcementLearning from Human Feedback，RLHF）。这一训练方法增加了人类对模型输出结果的演示，并且对结果进行了排序。具体操作上，人工智能训练者扮演对话的双方，即用户和人工智能助手，提供对话样本。在人类扮演聊天机器人的时候，会让模型生成一些建议辅助训练师撰写回复，训练师会对回复选项打分排名，将更好的结果输回到模型中，通过以上奖励策略对模型进行微调并持续迭代。</p>
<p><strong>此外，ChatGPT的背后离不开大模型、大数据、大算力。</strong></p>
<p>ChatGPT成为AIGC里程碑的背后，是算力发展和数字时代形成的大数据所共同支持的大模型训练，才能实现目前的效果。由OpenAI研发的ChatGPT是微调后的GPT-3.5系列模型，有着多达1750亿个模型参数，并在今年年初训练完成。模型训练的背后离不开大数据的支持，OpenAI主要使用的公共爬虫数据集有着超过万亿单词的人类语言数据集。在算力方面，GPT-3.5在Azure AI超算基础设施（由V100GPU组成的高带宽集群）上进行训练，总算力消耗约3640PF-days（即每秒一千万亿次计算，运行3640个整日）。</p>
<p><strong>AIGC里程碑级应用</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.8btc.com/article/6787780">AIGC</a> 将是 Web3 时代的生产力工具。当我们迈入 Web3.0 时代，人工智能、关联数据和语义网络构建，形成人与网络的全新链接，内容消费需求飞速增长。UGC\PGC 这样的内容生成方式将难以匹配扩张的需求。AIGC 将是新的元宇宙内容生成解决方案。AIGC 的生成利用人工智能学习知识图谱、自动生成，在内容的创作为人类提供协助或是完全由 AI 产生内容。不仅能帮助提高内容生成的效率，还能提高内容的多样性。随着 NLP（Natural Language Processing，自然语言处理）技术和扩散模型（Diffusion Model）的发展，AI 不再仅作为内容创造的辅助工具，创造生成内容成为了可能。由此，将来文字生成、图片绘制、视频剪辑、游戏内容生成皆可由 AI 替代。</p>
<p>国盛证券表示，AIGC不仅改变创作，还将改变获取信息的主要方式。而在此之上，ChatGPT所展示了作为生产力的存在，ChatGPT在寻找答案、解决问题的效率上已经部分的超越了如今的搜索引擎，ChatGPT或许在未来会改变我们获取信息、输出内容的方式，AIGC有望成为数字经济时代驱动需求爆发的杀手级应用。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[维基百科]: 	“<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/ChatGPT">https://zh.m.wikipedia.org/zh-hans/ChatGPT</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/chatGPT/" rel="tag">chatGPT</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-chatGPT注册"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/"
    >chatGPT注册</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/" class="article-date">
  <time datetime="2022-12-14T00:37:52.000Z" itemprop="datePublished">2022-12-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/">趣味技术</a> / <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/chatGPT%E6%B3%A8%E5%86%8C/">chatGPT注册</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="chatGPT注册、登陆具体流程"><a href="#chatGPT注册、登陆具体流程" class="headerlink" title="chatGPT注册、登陆具体流程"></a>chatGPT注册、登陆具体流程</h1><blockquote>
<p>需要科学上网</p>
<p>由于目前推广期间，chatGPT只要注册openai就可以免费使用chatGPT</p>
</blockquote>
<h3 id="一、进入chatGPT的注册页面"><a href="#一、进入chatGPT的注册页面" class="headerlink" title="一、进入chatGPT的注册页面"></a>一、进入chatGPT的注册页面</h3><p>[chatGPT]: 	“<a target="_blank" rel="noopener" href="https://chat.openai.com/auth/login">https://chat.openai.com/auth/login</a> “</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081000882.png"></p>
<h3 id="二、点击Sign-up注册"><a href="#二、点击Sign-up注册" class="headerlink" title="二、点击Sign up注册"></a>二、点击Sign up注册</h3><p>我注册的时候用的谷歌邮箱</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081235003.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081250319.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081403723.png"></p>
<h3 id="三、进入了电话号码验证环节"><a href="#三、进入了电话号码验证环节" class="headerlink" title="三、进入了电话号码验证环节"></a>三、进入了电话号码验证环节</h3><p>一个号码模拟平台 <a target="_blank" rel="noopener" href="https://sms-activate.org/cn?ref=2780512">https://sms-activate.org/cn?ref=2780512</a></p>
<p>第一步去注册登陆（这一步没什么问题）</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081608840.png"></p>
<p>第二步需要存钱了哈哈哈</p>
<p>当然，充多少一般都可以，如果只用这一次的话可以充少一点，0.2-0.5美元</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081921982.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081825615.png"></p>
<p>我们可以选择支付宝来充值，很方便</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082059408.png"></p>
<p>等到充值到账（大概几分钟）</p>
<p>我们就可以购买服务了，点击购物车（这个便宜）</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082407157.png"></p>
<p>然后，可以在激活区看到待使用的临时号码，将此号码复制到 OpenAI 的验证码接收区里面。</p>
<p>先选择对应国家，再填号码，然后发送电话号码，激活区就可以看见验证码了。</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214083118069.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082913264.png"></p>
<p>电话验证完，注册完毕</p>
<h3 id="四、登陆chatGPT"><a href="#四、登陆chatGPT" class="headerlink" title="四、登陆chatGPT"></a>四、登陆chatGPT</h3><p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214083525980.png"></p>
<p>这时候我们就可以开始和它愉快的聊天了</p>
<p>我们下一篇会介绍它是什么？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/chatGPT/" rel="tag">chatGPT</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-响应式设计"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/"
    >响应式设计</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2022-12-13T06:45:26.000Z" itemprop="datePublished">2022-12-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/">响应式设计</a> / <a class="article-category-link" href="/categories/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/">响应式设计</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h1><blockquote>
<p>自适应、响应式、弹性布局、屏幕适配，这是四个独立不同的概念。</p>
</blockquote>
<h3 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h3><p>自适应：多端请求时返回不同的页面，服务端需要准备多套程序或者多套模板。</p>
<p>响应式：主要是利用css媒体查询使得在不同屏幕大小下，页面有不同表现，主要是元素布局等变化。</p>
<p>弹性布局：主要是利用百分比设置元素宽度，浮动还有flex设置元素布局等等。</p>
<p>屏幕适配：主要是应用于对完美还原设计稿尺寸有要求的页面，主要是利用 rem、vm等技术。（类似于750px的设计稿是一张图片，这张图片无论怎么缩放，都能显示很好的效果，现在我们的网页也需要图片这种等比缩放的效果，这么说你应该能体会到了。当然了，这里还需要顺便解决高清屏显示的问题。）</p>
<h3 id="二、技术方案怎么选"><a href="#二、技术方案怎么选" class="headerlink" title="二、技术方案怎么选"></a>二、技术方案怎么选</h3><ol>
<li>简单 &amp; 对速度不敏感和对代码精简没要求 &amp; 预算紧张</li>
</ol>
<p>​      响应式，一套代码解决多端</p>
<p>​     展示阅读类 交互逻辑简单且少，且移动端与pc端内容差异不大，如新闻站，企业官网</p>
<ol start="2">
<li>复杂 &amp; 对精简代码和速度有要求 预算充足</li>
</ol>
<p>​      做两套 根据请求头自适应返回 web端 手机端 （后端可共用，也可不共用，如不同模块或者部署不同应用）</p>
<p>​     功能类，交互逻辑复杂且多，如电商，社交类</p>
<ol start="3">
<li>复杂 &amp; 有多终端适配要求 &amp; 对细节有一定要求 追求用户体验 &amp; 预算豪华</li>
</ol>
<p>​       做两套 移动端用适配做以满足不同移动终端</p>
<ol start="4">
<li>复杂 &amp; 细节要求和技术追求极高 &amp; 追求极致完美的用户体验 &amp; 不差钱 （艺术家、哲学家）</li>
</ol>
<p>​      多端 多套 响应式 适配 多技术相结合</p>
<h3 id="三、各种方案的详细讲解"><a href="#三、各种方案的详细讲解" class="headerlink" title="三、各种方案的详细讲解"></a>三、各种方案的详细讲解</h3><h4 id="1-媒体查询"><a href="#1-媒体查询" class="headerlink" title="1.媒体查询"></a>1.媒体查询</h4><p>要想实现css屏幕大小自适应，首先得引入 CSS3 @media 媒体查询器：</p>
<p>media的使用和规则：</p>
<p>　　①被链接文档将显示在什么设备上。</p>
<p>　　②用于为不同的媒介类型规定不同的样式。</p>
<p>语法： </p>
<pre><code class="css">@media 设备名 only （选取条件） not （选取条件） and（设备选取条件），设备二&#123;sRules&#125;
</code></pre>
<p>实例：</p>
<pre><code class="css">/* 这是匹配横屏的状态，横屏时的css代码 */

@media all and (orientation :landscape)&#123;&#125;

/* 这是匹配竖屏的状态，竖屏时的css代码 */

@media all and (orientation :portrait)&#123;&#125;

@media X and (min-width:200px)&#123;&#125;
/*X为媒体类型---&gt;比如print/screen/TV等等*/

/* 宽度大于600px小于960之间时，隐藏footer结构 */

@media all and (min-height:640px) and (max-height:960px)&#123;
   　　　footer&#123;display:none;&#125;
&#125;
</code></pre>
<p>在实际应用的时候，首先得在HTML的头文件<head>里上加入以下代码：</p>
<pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;
</code></pre>
<p>解释：　　　</p>
<p>width &#x3D; device-width：宽度等于当前设备的宽度</p>
<p>initial-scale：初始的缩放比例（默认设置为1.0） </p>
<p>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）  </p>
<p>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） </p>
<p>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）</p>
<p>因为media的类型很多，这里就发MDN的对应链接了：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media</a></p>
<p>下面是media类型的screen（用于电脑屏幕，平板电脑，智能手机等）：</p>
<p><strong>css自适应屏幕大小大方法：</strong></p>
<pre><code class="css">@media screen and (min-width: 320px) and (max-width: 1156px)&#123;

              .site-bg-dl &#123;
              position: fixed;
              height: 100%;
              width: 100%;
              z-index: 0;
              background-image: url(bjxzfwzx/images/bj1.png);
              background-size: cover;
              background-repeat: no-repeat;
              background-attachment: fixed;
              background-size:100% 100%;
              -moz-background-size:100% 100%;
            &#125;
&#125;
</code></pre>
<p>解释：</p>
<p>告诉浏览器当屏幕大于320px，并小于1156px下执行此代码；</p>
<p>在css中添加如下内容 可以分别定制不同屏幕的显示样式：</p>
<pre><code class="css">/* 大屏幕 ：大于等于1200px*/
@media (min-width: 1200px) &#123; ... &#125;

/*默认*/
@media (min-width: 980px)&#123;...&#125;

/* 平板电脑和小屏电脑之间的分辨率 */
@media (min-width: 768px) and (max-width: 979px) &#123; ... &#125;

/* 横向放置的手机和竖向放置的平板之间的分辨率 */
@media (max-width: 767px) &#123; ... &#125;

/* 横向放置的手机及分辨率更小的设备 */
@media (max-width: 480px) &#123; ... &#125;
</code></pre>
<p>Media Queries Level 4 引入了一种新的范围语法，在测试接受范围的任何特性时允许更简洁的媒体查询，如下面的示例所示：</p>
<pre><code class="css">@media (height &gt; 600px) &#123;
  body &#123;
    line-height: 1.4;
  &#125;
&#125;

@media (400px &lt;= width &lt;= 700px) &#123;
  body &#123;
    line-height: 1.4;
  &#125;
&#125;
</code></pre>
<h4 id="2-如何选择屏幕大小分割点"><a href="#2-如何选择屏幕大小分割点" class="headerlink" title="2.如何选择屏幕大小分割点"></a>2.如何选择屏幕大小分割点</h4><p>如何确定媒体查询的分割点也是一个开发中会遇到的问题，下面是市场上的移动设备和电脑屏幕分辨率的分布情况，可以发现不同品牌和型号的设备屏幕分辨率一般都不一样</p>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213140505623.png"></p>
<p>如果我们选择<code>600px</code>,<code>900px</code>,<code>1200px</code>,<code>1800px</code>作为分割点，可以适配到常见的14个机型：</p>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213140556282.png"></p>
<p>而作为曾经典型的响应式布局框架，<code>Bootstrap</code>是怎么进行断点的呢？</p>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213140637166.png"></p>
<p>上面的分割方案不一定满足项目中的实际需求，我们可以先用跨度大的分割点进行分割，如果出现不适配的情况可以再根据实际情况增加新的分割点。</p>
<h4 id="3-移动优先-or-PC优先"><a href="#3-移动优先-or-PC优先" class="headerlink" title="3.移动优先 or PC优先"></a>3.移动优先 or PC优先</h4><p>不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是<code>min-width</code>，PC端优先使用的<code>max-width</code>。</p>
<p>移动优先：</p>
<pre><code class="css">/* iphone6 7 8 */
body &#123;
    background-color: yellow;
&#125;
/* iphone 5 */
@media screen and (max-width: 320px) &#123;
    body &#123;
      background-color: red;
    &#125;
&#125;
/* iphoneX */
@media screen and (min-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    body &#123;
      background-color: #0FF000;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (min-width: 414px) &#123;
    body &#123;
      background-color: blue;
    &#125;
&#125;
/* ipad */
@media screen and (min-width: 768px) &#123;
    body &#123;
      background-color: green;
    &#125;
&#125;
/* ipad pro */
@media screen and (min-width: 1024px) &#123;
    body &#123;
      background-color: #FF00FF;
    &#125;
&#125;
/* pc */
@media screen and (min-width: 1100px) &#123;
    body &#123;
      background-color: black;
    &#125;
&#125;
</code></pre>
<p>pc优先：</p>
<pre><code class="css">/* pc width &gt; 1024px */
    body &#123;
        background-color: yellow;
    &#125;
/* ipad pro */
@media screen and (max-width: 1024px) &#123;
    body &#123;
        background-color: #FF00FF;
    &#125;
&#125;
/* ipad */
@media screen and (max-width: 768px) &#123;
    body &#123;
        background-color: green;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (max-width: 414px) &#123;
    body &#123;
        background-color: blue;
    &#125;
&#125;
/* iphoneX */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    body &#123;
        background-color: #0FF000;
    &#125;
&#125;
/* iphone6 7 8 */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123;
    body &#123;
        background-color: #0FF000;
    &#125;
&#125;
/* iphone5 */
@media screen and (max-width: 320px) &#123;
    body &#123;
        background-color: #0FF000;
    &#125;
&#125;
</code></pre>
<h4 id="4-百分比布局"><a href="#4-百分比布局" class="headerlink" title="4.百分比布局"></a>4.百分比布局</h4><p>通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap里面的栅格系统就是利用百分比来定义元素的宽高，<code>CSS3</code>支持最大最小高，可以将百分比和<code>max(min)</code>一起结合使用来定义元素在不同设备下的宽高。</p>
<pre><code class="css">/* pc width &gt; 1100px */
html, body &#123; margin: 0;padding: 0;width: 100%;height: 100%;&#125;
aside &#123;
    width: 10%;
    height: 100%;
    background-color: red;
    float: left;
&#125;
main &#123;
    height: 100%;
    background-color: blue;
    overflow: hidden;
&#125;
/* ipad pro */
@media screen and (max-width: 1024px) &#123;
    aside &#123;
      width: 8%;
      background-color: yellow;
    &#125;
&#125;
/* ipad */
@media screen and (max-width: 768px) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 10%;
      background-color: green;
    &#125;
    main &#123;
      height: calc(100vh - 10%);
      background-color: red;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (max-width: 414px) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 5%;
      background-color: yellow;
    &#125;
    main &#123;
      height: calc(100vh - 5%);
      background-color: red;
    &#125;
&#125;
/* iphoneX */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 10%;
      background-color: blue;
    &#125;
    main &#123;
      height: calc(100vh - 10%);
      background-color: red;
    &#125;
&#125;
/* iphone6 7 8 */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 3%;
      background-color: black;
    &#125;
    main &#123;
      height: calc(100vh - 3%);
      background-color: red;
    &#125;
&#125;
/* iphone5 */
@media screen and (max-width: 320px) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 7%;
      background-color: green;
    &#125;
    main &#123;
      height: calc(100vh - 7%);
      background-color: red;
    &#125;
&#125;
</code></pre>
<p>但是我们必须要弄清楚css中子元素的百分比到底是相对谁的百分比。</p>
<p>子元素的<code>height</code>或<code>width</code>中使用百分比，是相对于子元素的直接父元素，<code>width</code>相对于父元素的<code>width</code>，<code>height</code>相对于父元素的<code>height</code>；子元素的<code>top</code>和<code>bottom</code>如果设置百分比，则相对于直接非<code>static</code>定位(默认定位)的父元素的高度，同样子元素的<code>left</code>和<code>right</code>如果设置百分比，则相对于直接非<code>static</code>定位(默认定位的)父元素的宽度；子元素的<code>padding</code>如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的<code>width</code>，而与父元素的<code>height</code>无关。跟<code>padding</code>一样，<code>margin</code>也是如此，子元素的<code>margin</code>如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的<code>width</code>；<code>border-radius</code>不一样，如果设置<code>border-radius</code>为百分比，则是相对于自身的宽度，除了<code>border-radius</code>外，还有比如<code>translate</code>、<code>background-size</code>等都是相对于自身的；</p>
<p>从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：</p>
<ul>
<li>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。</li>
<li>可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如<code>width</code>和<code>height</code>相对于父元素的<code>width</code>和<code>height</code>，而<code>margin</code>、<code>padding</code>不管垂直还是水平方向都相对比父元素的宽度、<code>border-radius</code>则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。</li>
</ul>
<h4 id="5-rem布局"><a href="#5-rem布局" class="headerlink" title="5.rem布局"></a>5.rem布局</h4><p><code>REM</code>是<code>CSS3</code>新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。<code>rem</code>单位都是相对于根元素html的<code>font-size</code>来决定大小的,根元素的<code>font-size</code>相当于提供了一个基准，当页面的size发生变化时，只需要改变<code>font-size</code>的值，那么以<code>rem</code>为固定单位的元素的大小也会发生响应的变化。 因此，如果通过<code>rem</code>来实现响应式的布局，只需要根据视图容器的大小，动态的改变<code>font-size</code>即可（而<code>em</code>是相对于父元素的）。</p>
<p><strong>rem响应式的布局思想：</strong></p>
<ul>
<li>一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值</li>
<li>高度值可以设置固定值，设计稿有多大，我们就严格有多大</li>
<li>所有设置的固定值都用<code>rem</code>做单位（首先在HTML总设置一个基准值：<code>px</code>和<code>rem</code>的对应比例，然后在效果图上获取<code>px</code>值，布局的时候转化为<code>rem</code>值)</li>
<li>js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了。</li>
</ul>
<p><strong>rem布局的缺点：</strong></p>
<p>在响应式布局中，必须通过js来动态控制根元素<code>font-size</code>的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变<code>font-size</code>的代码放在<code>css</code>样式之前</p>
<pre><code class="javascript">/*上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/
function refreshRem() &#123;
    var docEl = doc.documentElement;
    var width = docEl.getBoundingClientRect().width;
    var rem = width / 10;
    docEl.style.fontSize = rem + &#39;px&#39;;
    flexible.rem = win.rem = rem;
&#125;
win.addEventListener(&#39;resize&#39;, refreshRem);
</code></pre>
<p><code>REM</code>布局也是目前多屏幕适配的最佳方式。默认情况下我们html标签的<code>font-size</code>为16px,我们利用媒体查询，设置在不同设备下的字体大小。</p>
<pre><code class="css">/* pc width &gt; 1100px */
html&#123; font-size: 100%;&#125;
body &#123;
    background-color: yellow;
    font-size: 1.5rem;
&#125;
/* ipad pro */
@media screen and (max-width: 1024px) &#123;
    body &#123;
      background-color: #FF00FF;
      font-size: 1.4rem;
    &#125;
&#125;
/* ipad */
@media screen and (max-width: 768px) &#123;
    body &#123;
      background-color: green;
      font-size: 1.3rem;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (max-width: 414px) &#123;
    body &#123;
      background-color: blue;
      font-size: 1.25rem;
    &#125;
&#125;
/* iphoneX */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    body &#123;
      background-color: #0FF000;
      font-size: 1.125rem;
    &#125;
&#125;
/* iphone6 7 8 */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123;
    body &#123;
      background-color: #0FF000;
      font-size: 1rem;
    &#125;
&#125;
/* iphone5 */
@media screen and (max-width: 320px) &#123;
    body &#123;
      background-color: #0FF000;
      font-size: 0.75rem;
    &#125;
&#125;
</code></pre>
<h4 id="6-视口单位"><a href="#6-视口单位" class="headerlink" title="6.视口单位"></a>6.视口单位</h4><p><code>css3</code>中引入了一个新的单位<code>vw/vh</code>，与视图窗口有关，<code>vw</code>表示相对于视图窗口的宽度，<code>vh</code>表示相对于视图窗口高度，除了<code>vw</code>和<code>vh</code>外，还有<code>vmin</code>和<code>vmax</code>两个相关的单位。各个单位具体的含义如下：</p>
<table>
<thead>
<tr>
<th align="center">单位</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vw</td>
<td align="center">相对于视窗的宽度，1vw 等于视口宽度的1%，即视窗宽度是100vw</td>
</tr>
<tr>
<td align="center">vh</td>
<td align="center">相对于视窗的高度，1vh 等于视口高度的1%，即视窗高度是100vh</td>
</tr>
<tr>
<td align="center">vmin</td>
<td align="center">vw和vh中的较小值</td>
</tr>
<tr>
<td align="center">vmax</td>
<td align="center">vw和vh中的较大值</td>
</tr>
</tbody></table>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213142123454.png"></p>
<p>用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况）。例如，在桌面端浏览器视口尺寸为650px，那么 1vw &#x3D; 650 * 1% &#x3D; 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。</p>
<p>那么vw或者vh很类似百分比单位。vw和%的区别为：</p>
<table>
<thead>
<tr>
<th align="center">单位</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%</td>
<td align="center">大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</td>
</tr>
<tr>
<td align="center">vw&#x2F;vh</td>
<td align="center">相对于视窗的尺寸</td>
</tr>
</tbody></table>
<p>从对比中我们可以发现，<code>vw</code>单位与百分比类似，单确有区别，前面我们介绍了百分比单位的换算困难，这里的<code>vw</code>更像”理想的百分比单位”。任意层级元素，在使用<code>vw</code>单位的情况下，1vw都等于视图宽度的百分之一。</p>
<p>使用视口单位来实现响应式有两种做法：</p>
<h5 id="1-仅使用vw作为CSS单位"><a href="#1-仅使用vw作为CSS单位" class="headerlink" title="1.仅使用vw作为CSS单位"></a>1.仅使用vw作为CSS单位</h5><ul>
<li><p>对于设计稿的尺寸转换为为单位，我们使用<code>Sass</code>函数编译</p>
<pre><code class="css">//iPhone 6尺寸作为设计稿基准
$vm_base: 375; 
@function vw($px) &#123;
    @return ($px / 375) * 100vw;
&#125;
</code></pre>
</li>
<li><p>无论是文本还是布局宽度、间距等都使用<code>vw</code>作为单位</p>
<pre><code class="css">.mod_nav &#123;
    background-color: #fff;
    &amp;_list &#123;
        display: flex;
        padding: vm(15) vm(10) vm(10); // 内间距
        &amp;_item &#123;
            flex: 1;
            text-align: center;
            font-size: vm(10); // 字体大小
            &amp;_logo &#123;
                display: block;
                margin: 0 auto;
                width: vm(40); // 宽度
                height: vm(40); // 高度
                img &#123;
                    display: block;
                    margin: 0 auto;
                    max-width: 100%;
                &#125;
            &#125;
            &amp;_name &#123;
                margin-top: vm(2);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>1物理像素线（也就是普通屏幕下1px,高清屏幕下0.5px的情况）采用<code>transform</code>属性<code>scale</code>实现</p>
<pre><code class="css">.mod_grid &#123;
    position: relative;
    &amp;::after &#123;
        // 实现1物理像素的下边框线
        content: &#39;&#39;;
        position: absolute;
        z-index: 1;
        pointer-events: none;
        background-color: #ddd;
        height: 1px;
        left: 0;
        right: 0;
        top: 0;
        @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123;
            -webkit-transform: scaleY(0.5);
            -webkit-transform-origin: 50% 0%;
        &#125;
    &#125;
    ...
&#125;
</code></pre>
</li>
<li><p>对于需要保持宽高比的图，应该用<code>padding-top</code>实现</p>
<pre><code class="css">.mod_banner &#123;
    position: relative;
    padding-top: percentage(100/700); // 使用padding-top
    height: 0;
    overflow: hidden;
    img &#123;
        width: 100%;
        height: auto;
        position: absolute;
        left: 0;
        top: 0; 
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h5 id="2-搭配vw和rem"><a href="#2-搭配vw和rem" class="headerlink" title="2.搭配vw和rem"></a>2.搭配vw和rem</h5><p>虽然采用<code>vw</code>适配后的页面效果很好，但是它是利用视口单位实现的布局，依赖视口大小而自动缩放，无论视口过大还是过小，它也随着时候过大或者过小，失去了最大最小宽度的限制，此时我们可以结合<code>rem</code>来实现布局</p>
<ul>
<li><p>给根元素大小设置随着视口变化而变化的<code>vw</code>单位，这样就可以实现动态改变其大小</p>
</li>
<li><p>限制根元素字体大小的最大最小值，配合<code>body</code>加上最大宽度和最小宽度</p>
<pre><code class="scss">// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推
$vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值
@function rem($px) &#123;
     @return ($px / $vm_fontsize ) * 1rem;
&#125;
// 根元素大小使用 vw 单位
$vm_design: 750;
html &#123;
    font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; 
    // 同时，通过Media Queries 限制根元素最大最小值
    @media screen and (max-width: 320px) &#123;
        font-size: 64px;
    &#125;
    @media screen and (min-width: 540px) &#123;
        font-size: 108px;
    &#125;
&#125;
// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小
body &#123;
    max-width: 540px;
    min-width: 320px;
&#125;
</code></pre>
</li>
</ul>
<h4 id="7-图片响应式"><a href="#7-图片响应式" class="headerlink" title="7.图片响应式"></a>7.图片响应式</h4><p>这里的图片响应式包括两个方面，一个就是大小自适应，这样能够保证图片在不同的屏幕分辨率下出现压缩、拉伸的情况；一个就是根据不同的屏幕分辨率和设备像素比来尽可能选择高分辨率的图片，也就是当在小屏幕上不需要高清图或大图，这样我们用小图代替，就可以减少网络带宽了。</p>
<h5 id="1-使用max-width（图片自适应）"><a href="#1-使用max-width（图片自适应）" class="headerlink" title="1.使用max-width（图片自适应）:"></a>1.使用max-width（图片自适应）:</h5><p>图片自适应意思就是图片能随着容器的大小进行缩放，可以采用如下代码：</p>
<pre><code class="css">img &#123;
    display: inline-block;
    max-width: 100%;
    height: auto;
&#125;
</code></pre>
<p><code>inline-block</code> 元素相对于它周围的内容以内联形式呈现，但与内联不同的是，这种情况下我们可以设置宽度和高度。 <code>max-width</code>保证了图片能够随着容器的进行等宽扩充（即保证所有图片最大显示为其自身的 100%。此时，如果包含图片的元素比图片固有宽度小，图片会缩放占满最大可用空间），而<code>height</code>为<code>auto</code>可以保证图片进行等比缩放而不至于失真。如果是背景图片的话要灵活运用<code>background-size</code>属性。</p>
<p>那么为什么不能用<code>width：100%</code>呢？因为这条规则会导致它显示得跟它的容器一样宽。在容器比图片宽得多的情况下，图片会被无谓地拉伸。</p>
<h5 id="2-使用srcset"><a href="#2-使用srcset" class="headerlink" title="2.使用srcset"></a>2.使用srcset</h5><pre><code class="ini">&lt;img srcset=&quot;photo_w350.jpg 1x, photo_w640.jpg 2x&quot; src=&quot;photo_w350.jpg&quot; alt=&quot;&quot;&gt;
</code></pre>
<p>如果屏幕的dpi &#x3D; 1的话则加载1倍图，而dpi &#x3D; 2则加载2倍图，手机和mac基本上dpi都达到了2以上，这样子对于普通屏幕来说不会浪费流量，而对于视网膜屏来说又有高清的体验。</p>
<p>如果浏览器不支持<code>srcset</code>，则默认加载src里面的图片。</p>
<p>但是你会发现实际情况并不是如此，在Mac上的Chrome它会同时加载<code>srcset</code>里面的那张2x的，还会再去加载src里面的那张，加载两张图片。顺序是先把所有<code>srcset</code>里面的加载完了，再去加载src的。这个策略比较奇怪，它居然会加载两张图片，如果不写src，则不会加载两张，但是兼容性就没那么好。这个可能是因为浏览器认为，既然有<code>srcset</code>就不用写src了，如果写了src，用户可能是有用的。而使用<code>picture</code>就不会加载两张</p>
<h5 id="3-使用background-image"><a href="#3-使用background-image" class="headerlink" title="3.使用background-image"></a>3.使用background-image</h5><pre><code class="css">.banner&#123;
  background-image: url(/static/large.jpg);
&#125;

@media screen and (max-width: 767px)&#123;
  background-image: url(/static/small.jpg);
&#125;
</code></pre>
<h5 id="4-使用picture标签"><a href="#4-使用picture标签" class="headerlink" title="4.使用picture标签"></a>4.使用picture标签</h5><p><a href="https://link.juejin.im/?target=https://scottjehl.github.io/picturefill/">picturefill.min.js</a> ：解决IE等浏览器不支持 的问题</p>
<pre><code class="xml">&lt;picture&gt;
    &lt;source srcset=&quot;banner_w1000.jpg&quot; media=&quot;(min-width: 801px)&quot;&gt;
    &lt;source srcset=&quot;banner_w800.jpg&quot; media=&quot;(max-width: 800px)&quot;&gt;
    &lt;img src=&quot;banner_w800.jpg&quot; alt=&quot;&quot;&gt;
&lt;/picture&gt;

&lt;!-- picturefill.min.js 解决IE等浏览器不支持 &lt;picture&gt; 的问题 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/vendor/picturefill.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><code>picture</code>必须要写img标签，否则无法显示，对<code>pictur</code>e的操作最后都是在img上面，例如onload事件是在img标签触发的，<code>picture</code>和<code>source</code>是不会进行layout的，它们的宽和高都是0。</p>
<p>另外使用<code>source</code>，还可以对图片格式做一些兼容处理：</p>
<pre><code class="ini">&lt;picture&gt;
    &lt;source type=&quot;image/webp&quot; srcset=&quot;banner.webp&quot;&gt;
    &lt;img src=&quot;banner.jpg&quot; alt=&quot;&quot;&gt;
&lt;/picture&gt;
</code></pre>
<p><strong>总结</strong>：响应式布局的实现可以通过媒体查询+<code>px</code>,媒体查询+百分比，媒体查询+<code>rem</code>+<code>js</code>,<code>vm/vh</code>,<code>vm/vh</code> +<code>rem</code>这几种方式来实现。但每一种方式都是有缺点的，媒体查询需要选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配，另外用户体验也不友好，布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。通过百分比来适配首先是计算麻烦，第二各个属性中如果使用百分比，其相对的元素的属性并不是唯一的，这样就造成我们使用百分比单位容易使布局问题变得复杂。通过采用<code>rem</code>单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得<code>CSS</code>与<code>JS</code> 耦合了在一起。通过利用纯<code>css</code>视口单位实现适配的页面，是既能解决响应式断层问题，又能解决脚本依赖的问题的，但是兼容性还没有完全能结构接受。</p>
<h3 id="四、响应式布局的成型方案"><a href="#四、响应式布局的成型方案" class="headerlink" title="四、响应式布局的成型方案"></a>四、响应式布局的成型方案</h3><p>现在的css，UI框架等都已经考虑到了适配不同屏幕分辨率的问题，实际项目中我们可以直接使用这些新特性和框架来实现响应式布局。可以有以下选择方案：</p>
<ul>
<li>利用上面的方法自己来实现，比如CSS3 Media Query,rem，vw等</li>
<li>Flex弹性布局，兼容性较差</li>
<li>Grid网格布局，兼容性较差</li>
<li>Columns栅格系统，往往需要依赖某个UI库，如Bootstrap</li>
</ul>
<h3 id="五、响应式布局的要点"><a href="#五、响应式布局的要点" class="headerlink" title="五、响应式布局的要点"></a>五、响应式布局的要点</h3><p>在实际项目中，我们可能需要综合上面的方案，比如用<code>rem</code>来做字体的适配，用<code>srcset</code>来做图片的响应式，宽度可以用<code>rem</code>，<code>flex</code>，栅格系统等来实现响应式，然后可能还需要利用媒体查询来作为响应式布局的基础，因此综合上面的实现方案，项目中实现响应式布局需要注意下面几点：</p>
<ul>
<li>设置viewport</li>
<li>媒体查询</li>
<li>字体的适配（字体单位）</li>
<li>百分比布局</li>
<li>图片的适配（图片的响应式）</li>
<li>结合flex，grid，BFC，栅格系统等已经成型的方案</li>
</ul>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[响应式设计]: 	“<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903814332432397">https://juejin.cn/post/6844903814332432397</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/" rel="tag">响应式</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何设计一个组件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/09/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/"
    >如何设计一个组件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/09/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/" class="article-date">
  <time datetime="2022-12-09T02:06:22.000Z" itemprop="datePublished">2022-12-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/">如何设计一个组件</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="如何设计一个组件"><a href="#如何设计一个组件" class="headerlink" title="如何设计一个组件"></a>如何设计一个组件</h1><blockquote>
<p>在开发过程中，我们经常会遇到现有组件库无法满足需求，需要自己设计和实现组件的情况。那么，如何才能设计一个既满足产品需求，又易于开发人员使用的组件呢？本文就以一个级联组件的设计为例，探讨一下如何设计一个优质组件。</p>
</blockquote>
<h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>开发这个组件的原因是来自工作中遇到的一个需求。</p>
<p>产品提出的业务需求是实现一个地区的级联选择，并且应设计师要求，不能使用 Ant Design 的Cascader 级联选择，因此需要自己实现一个级联选择。</p>
<p>通常需要从 4 个角度对需求进行分析：</p>
<ol>
<li>业务需求角度</li>
<li>UI 设计角度</li>
<li>开发人员角度</li>
<li>与其他组件配合角度</li>
</ol>
<h4 id="业务需求角度"><a href="#业务需求角度" class="headerlink" title="业务需求角度"></a>业务需求角度</h4><p>在拿到一个需求之后，我们不应当直接考虑如何实现，而要先思考一下，这个需求是不是真正的需求。或者说，这个需求背后，是否还有更加基础和核心的需求。</p>
<p>现在，我们拿到了一个<strong>地区级联选择</strong>的需求，那么我们应该<strong>仅仅实现</strong>地区级联选择吗？我认为不是的，今天我们拿到的是地区选择的需求，明天就可能变成职业选择。</p>
<p>因此，我们实际需要实现的，应该是一个支持<strong>N 级</strong>的级联选择框。</p>
<h4 id="UI-设计角度"><a href="#UI-设计角度" class="headerlink" title="UI 设计角度"></a>UI 设计角度</h4><p>既然已经确定了要实现 N 级级联选择框，就需要考虑其在各个屏幕尺寸的兼容情况，于是我在组件中引入了 Grid 栅格 。并默认设置了 3 级级联的样式，同时为使用者提供了相应的配置选项，如下：</p>
<pre><code class="yaml">&lt;Cascade
  rowProps=&#123;&#123;
    gutter: 10,
  &#125;&#125;
  colProps=&#123;&#123;
    xs: 24,
    sm: 24,
    md: 8,
    lg: 8,
    xl: 8,
  &#125;&#125;
/&gt;
</code></pre>
<h4 id="开发人员角度"><a href="#开发人员角度" class="headerlink" title="开发人员角度"></a>开发人员角度</h4><p>我们开发的组件，不止会被我们的团队成员使用，甚至会开源给其他开发者使用。那么，提供给开发者更好的体验就尤为重要。</p>
<p>为了节省开发人员的学习成本，我们可以按照以下思路考虑：</p>
<ol>
<li>在满足基本需求的前提下，提供尽量少的 API。</li>
<li>为 API 选项提供尽量少的配置项。</li>
<li>为代码，特别是 API 提供尽量好的文档或注释。</li>
</ol>
<p>定义的 <code>Cascade</code> 组件 <code>Props</code> 示例如下：</p>
<pre><code class="less">interface Props&lt;T&gt; &#123;
  cascadeKeys?: CascadeKeys; // 自定义 dataSource 中 value label children 的字段
  value?: T[]; // 指定当前选中的条目
  onChange?: (value: T[], level: number) =&gt; void; // 选中选项时，调用此函数
  rowProps?: RowProps; // 行排列方式，可参考https://ant.design/components/grid-cn/
  colProps?: ColProps; // 列排列方式
  loading?: boolean[]; // 选择框loading装填
  dataSource?: T[] | CascadeData&lt;T&gt; | T[][]; // 可选项数据源
&#125;
</code></pre>
<p>可以看到， <code>Props</code> 中只有 <code>dataSource</code> 是必须的。也就是说，如果你对配置项并不了解，组件也只需要最简单的配置，就可以正常工作了，例如：</p>
<pre><code class="ini">&lt;Cascade
  dataSource=&#123;pcaCascadeData&#125;
/&gt;
</code></pre>
<ol>
<li><p>在使用 TypeScript 时，还需要特别考虑类型匹配的问题。例如可以在使用组件时，传入一个类型，并且在 <code>onChange</code> 事件中如果使用了其他类型， TypeScript 检查就会提示错误，如下面例子中的 <code>PCAItem</code> 。</p>
<pre><code class="ini">&lt;Cascade&lt;PCAItem&gt;
  dataSource=&#123;pcaCascadeData&#125;
  cascadeKeys=&#123;pcaCascadeKeys&#125;
  onChange=&#123;async (value: PCAItem[], level: number) =&gt; &#123;
    setPCAData(value);
    setPCAIndex(level);
  &#125;&#125;
/&gt;
</code></pre>
</li>
<li><p>对于级联组件，我们还需要考虑 dataSource 的数据来源可能有两种。</p>
<ul>
<li>组件初始化时，就传入了所有的级联数据，例如 省&#x2F;地&#x2F;县&#x2F;乡层级数据 。对应 Demo 中的“同步级联数据”，以及 <code>Props</code> 中 <code>dataSource</code> 类型定义的 <code>CascadeData&lt;T&gt; | T[][]</code> 。<ul>
<li>在某些场景下，虽然没有级联选择框存在，但也需要处理树形数据，包括数据的查询和校验等功能，因此将该方法封装到 <code>CascadeData</code> 类中。</li>
<li>考虑到树的数据量可能非常庞大，如果在每次选择时都在树中搜索效率较低。因此设计成在组件创建时，直接遍历树中的所有节点，然后将每个层级所有节点的数据都存储在相应的 <code>Map</code> 中，之后就能很方便地查询数据。</li>
<li>虽然在组件初始化时遍历所有节点比较耗时，但考虑到用户从进入页面到操作组件有一定时间差，因此我认为这个问题可以忽略。</li>
<li>基于以上考虑，你在 <code>Props</code> 中 <code>dataSource</code> 类型中看到的 <code>CascadeData&lt;T&gt;</code> ，就表示直接传入了一个 <code>new CascadeData(treeData)</code> 。而<code>T[][]</code>就表示直接传入树形数据，由组件内部进行 <code>new CascadeData(treeData) </code> 。</li>
</ul>
</li>
<li>组件初始化时，只传入了第一级的选项，之后每级的选项通过前一级所选择的参数，从服务端获取。对应 Demo 中的“异步级联数据”，对应 <code>dataSource</code> 类型中的 <code>T[]</code> 。<ul>
<li>组件初始化时，只传入第一级的数据，其他级别传入空数组，如：<code>[[&#123;&quot;code&quot;:110000,&quot;name&quot;:&quot;北京市&quot;&#125;],[],[]]</code>，组件会渲染出 3 层级联选项。</li>
<li>当进行选择时，需要使用者通过 <code>onChange</code> 事件自行更新下一级的数据。也就是说，组件完全放弃了对数据的控制。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="与其他组件配合角度"><a href="#与其他组件配合角度" class="headerlink" title="与其他组件配合角度"></a>与其他组件配合角度</h4><p>由于该组件需要与 Ant Design 其他组件配合使用，如前面讨论过的 UI 部分，该组件就结合了 Grid 栅格 组件。既保证了该组件在各屏幕宽度下正常显示，又保证了与其他组件的显示一致。</p>
<p>除此之外，还需要考虑与 Form 表单 组件的配合，特别是兼容表单校验功能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过一个级联组件的设计案例，探讨了如何从四个角度分析，进而设计一个优秀的组件。这 4 个角度分别是：</p>
<ol>
<li>业务需求角度</li>
<li>UI 设计角度</li>
<li>开发人员角度</li>
<li>与其他组件配合角度</li>
</ol>
<p>我认为很多时候组件的设计并没有最优解，总是需要根据需求在各种方案中取舍。但只要按照本文提到的 4 个角度进行分析，就能设计出优秀的组件。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/" rel="tag">组件设计</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-react-native环境搭建"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"
    >react-native环境搭建</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="article-date">
  <time datetime="2022-12-08T00:29:43.000Z" itemprop="datePublished">2022-12-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">react-native环境搭建</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="react-native环境搭建（Mac-M1）"><a href="#react-native环境搭建（Mac-M1）" class="headerlink" title="react-native环境搭建（Mac M1）"></a>react-native环境搭建（Mac M1）</h1><h3 id="一、本机安装环境"><a href="#一、本机安装环境" class="headerlink" title="一、本机安装环境"></a>一、本机安装环境</h3><p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221207175048319.png"></p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221207175217956.png"></p>
<p>安装官方的说法，需要具备的环境条件</p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221207175323650.png"></p>
<p>node和npm的安装就不说了</p>
<p>下载yarn：</p>
<pre><code class="ini">npm install -g yarn
</code></pre>
<p>react-native：</p>
<pre><code class="ini">yarn add react-native --exact
</code></pre>
<pre><code class="ini">//Mac m1 安装 Homebrew
/bin/bash -c &quot;$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)&quot;

环境变量：
 echo &#39;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#39; &gt;&gt; /Users/mengfeng/.zprofile
   eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;
</code></pre>
<blockquote>
<p>建议同学们早上去下载（网好），当然，不可避免的还是要出现一系列的问题，我们根据错误提示去查询相应的解决方案就行（因为每个同学的问题都不太一样）</p>
</blockquote>
<p>下载watchman：</p>
<pre><code class="ini">brew install watchman
</code></pre>
<p>下载pod（cocoapods）：</p>
<pre><code class="ini">brew install cocoapods
</code></pre>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208082020782.png"></p>
<p>到目前为止，我们已经安装了 Node、Homebrew、watchman、cocoapods</p>
<p>下面我们来安装xcode</p>
<h3 id="二、xcode安装模拟器"><a href="#二、xcode安装模拟器" class="headerlink" title="二、xcode安装模拟器"></a>二、xcode安装模拟器</h3><p>我们在app store下载就可以，当然版本历史记录可以查看以前的xcode版本</p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208082606954.png"></p>
<p>当我们创建了一个项目，点击小三角，模拟器完美运行</p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208083302861.png"></p>
<h3 id="三、react-native创建项目"><a href="#三、react-native创建项目" class="headerlink" title="三、react-native创建项目"></a>三、react-native创建项目</h3><p>创建项目</p>
<pre><code class="ini">npx react-native init testapp
</code></pre>
<blockquote>
<p>出现报错</p>
</blockquote>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208084024802.png"></p>
<blockquote>
<p>解决以上问题的第一个error</p>
<p>报了一个警告，大概意思是不安全的写权限，目录是 &#x2F;opt&#x2F;homebrew&#x2F;bin<br>于是我们把这个目录的写权限去掉</p>
<pre><code class="ini">sudo chmod -R go-w /opt/homebrew/bin
sudo chmod -R go-w /opt/homebrew
</code></pre>
</blockquote>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208085035978.png"></p>
<blockquote>
<p>解决第一个问题</p>
<p>我们需要下载ruby 2.7.5并将ruby版本指向2.7.5</p>
</blockquote>
<p>如果你有条件的话请试试<a target="_blank" rel="noopener" href="https://www.rubyonmac.dev/?utm_campaign=install-ruby-guide">macruby</a>109美元终身，ruby不太友好</p>
<p>下篇文章继续</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Mac下的环境搭建]: 	“<a target="_blank" rel="noopener" href="https://juejin.cn/post/7119039164074426375">https://juejin.cn/post/7119039164074426375</a> “<br>[rbenv下载缓慢解决]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/shine_a/article/details/103927374">https://blog.csdn.net/shine_a/article/details/103927374</a> “<br>[mac下载rbenv]: 	“<a target="_blank" rel="noopener" href="https://juejin.cn/post/6899650892313100302">https://juejin.cn/post/6899650892313100302</a> “<br>[CocoaPods安装方法]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/Wulitc/article/details/115682720&quot;">https://blog.csdn.net/Wulitc/article/details/115682720&quot;</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>