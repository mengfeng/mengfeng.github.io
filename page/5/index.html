<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端面试大全git"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/"
    >前端面试大全git</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/" class="article-date">
  <time datetime="2022-11-03T02:29:52.000Z" itemprop="datePublished">2022-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/git%E6%93%8D%E4%BD%9C/">git操作</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（git命令）"><a href="#前端面试题大全（git命令）" class="headerlink" title="前端面试题大全（git命令）"></a>前端面试题大全（git命令）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git是什么？"><a href="#git是什么？" class="headerlink" title="git是什么？"></a>git是什么？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>git，是一个分布式版本控制软件，最初目的是为更好地管理<code>Linux</code>内核开发而设计</p>
<p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32393234306634302d663739632d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>项目开始，只有一个原始版仓库，别的机器可以<code>clone</code>这个原始版本库，那么所有<code>clone</code>的机器，它们的版本库其实都是一样的，并没有主次之分</p>
<p>所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库<code>clone</code>一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交</p>
<p><code>github</code>实际就可以充当这个服务器角色，其是一个开源协作社区，提供<code>Git</code>仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目</p>
<h4 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h4><p>当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的</p>
<p><code>Git</code> 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，<code>git</code>能够知道</p>
<p><code>Git </code>用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来，如下：</p>
<pre><code class="ini">24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre>
<p>当我们修改文件的时候，<code>git</code>就会修改文件的状态，可以通过<code>git status</code>进行查询，状态情况如下：</p>
<ul>
<li>已修改（modified）：表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交（committed）：表示数据已经安全的保存在本地数据库中。</li>
</ul>
<p>文件状态对应的，不同状态的文件在<code>Git</code>中处于不同的工作区域，主要分成了四部分：</p>
<ul>
<li>工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本</li>
<li>暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中</li>
<li>本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库</li>
<li>远程仓库：远程的仓库，如 github</li>
</ul>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33323733633961302d663739632d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="三、命令"><a href="#三、命令" class="headerlink" title="三、命令"></a>三、命令</h4><p>从上图可以看到，<code>git</code>日常简单的使用就只有上图6个命令：</p>
<ul>
<li>add</li>
<li>commit</li>
<li>push</li>
<li>pull</li>
<li>clone</li>
<li>checkout</li>
</ul>
<p>但实际上还有很多命令，如果想要熟练使用，还有60个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力</p>
<h3 id="Git中-fork-clone-branch这三个概念，有什么区别"><a href="#Git中-fork-clone-branch这三个概念，有什么区别" class="headerlink" title="Git中 fork, clone,branch这三个概念，有什么区别?"></a>Git中 fork, clone,branch这三个概念，有什么区别?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p><code>fork</code>，英语翻译过来就是叉子，动词形式则是分叉，如下图，从左到右，一条直线变成多条直线</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61643034616465302d663761642d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>转到<code>git</code>仓库中，<code>fork</code>则可以代表分叉、克隆 出一个（仓库的）新拷贝</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62346233313435302d663761642d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>包含了原来的仓库（即upstream repository，上游仓库）所有内容，如分支、Tag、提交</p>
<p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p>
<h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p>
<p>执行<code>clone</code>命令后，会在当前目录下创建一个名为<code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p>
<p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p>
<h5 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h5><p><code>branch</code>，译为分支，其作用简单而言就是开启另一个分支， 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线</p>
<p><code>Git</code> 处理分支的方式十分轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷</p>
<p>在我们开发中，默认只有一条<code>master</code>分支，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37666138653963302d663932332d313165622d393931642d3333346664333166303230312e706e67.png">]</p>
<p>通过<code>git branch </code>可以创建一个分支，但并不会自动切换到新分支中去</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38396566643536302d663932332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>通过<code>git checkout</code>可以切换到另一个<code>testing</code>分支</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39316431636566302d663932332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h4><h5 id="fork-1"><a href="#fork-1" class="headerlink" title="fork"></a>fork</h5><p>当你在<code>github</code>发现感兴趣开源项目的时候，可以通过点击<code>github</code>仓库中右上角<code>fork</code>标识的按钮，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095419097.png"></p>
<p>点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的<code>github</code>仓库中，而你本地仓库是不会存在任何更改</p>
<p>然后你就可以通过<code>git clone</code>对你这个复制的远程仓库进行克隆</p>
<p>后续更改任何东西都可以在本地完成，如<code>git add</code>、<code>git commit</code>一系列的操作，然后通过<code>push</code>命令推到自己的远程仓库</p>
<p>如果希望对方接受你的修改，可以通过发送<code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095452040.png"></p>
<p>整体流程如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63656438636531302d663761642d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="clone-1"><a href="#clone-1" class="headerlink" title="clone"></a>clone</h5><p>在<code>github</code>中，开源项目右侧存在<code>code</code>按钮，点击后则会显示开源项目<code>url</code>信息，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095540516.png"></p>
<p>通过<code>git clone xxx</code>则能完成远程项目的下载</p>
<h5 id="branch-1"><a href="#branch-1" class="headerlink" title="branch"></a>branch</h5><p>可通过<code>git branch</code>进行查看当前的分支状态，</p>
<p>如果给了<code>--list</code>，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号</p>
<p>以及通过<code>git branch</code>创建一个新的分支出来</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>其三者区别如下：</p>
<ul>
<li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li>
<li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li>
<li>branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支</li>
</ul>
<h3 id="Git常用的命令有哪些？"><a href="#Git常用的命令有哪些？" class="headerlink" title="Git常用的命令有哪些？"></a>Git常用的命令有哪些？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p><code>git </code>的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66653135303532302d663761662d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的<code>git </code>命令</p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p><code>Git </code>自带一个 <code>git config</code> 的工具来帮助设置控制 <code>Git </code>外观和行为的配置变量，在我们安装完<code>git</code>之后，第一件事就是设置你的用户名和邮件地址</p>
<p>后续每一个提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改</p>
<p>设置提交代码时的用户信息命令如下：</p>
<ul>
<li>git config [–global] user.name “[name]”</li>
<li>git config [–global] user.email “[email address]”</li>
</ul>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>一个<code>git</code>项目的初始有两个途径，分别是：</p>
<ul>
<li>git init [project-name]：创建或在当前目录初始化一个git代码库</li>
<li>git clone url：下载一个项目和它的整个代码历史</li>
</ul>
<h5 id="日常基本操作"><a href="#日常基本操作" class="headerlink" title="日常基本操作"></a>日常基本操作</h5><p>在日常工作中，代码常用的基本操作如下：</p>
<ul>
<li>git init 初始化仓库，默认为 master 分支</li>
<li>git add . 提交全部文件修改到缓存区</li>
<li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li>
<li>git diff 查看当前代码 add后，会 add 哪些内容</li>
<li>git diff –staged查看现在 commit 提交后，会提交哪些内容</li>
<li>git status 查看当前分支状态</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li>
<li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li>
<li>git commit -v 提交时显示所有diff信息</li>
<li>git commit –amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</li>
</ul>
<p>关于提交信息的格式，可以遵循以下的规则：</p>
<ul>
<li>feat: 新特性，添加功能</li>
<li>fix: 修改 bug</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>style: 代码格式修改, 注意不是 css 修改</li>
<li>test: 测试用例修改</li>
<li>chore: 其他修改, 比如构建流程, 依赖管理</li>
</ul>
<h5 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h5><ul>
<li>git branch 查看本地所有分支</li>
<li>git branch -r 查看远程所有分支</li>
<li>git branch -a 查看本地和远程所有分支</li>
<li>git merge &lt;分支名&gt; 合并分支</li>
<li>git merge –abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li>
<li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li>
<li>git checkout –orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li>
<li>git branch -D &lt;分支名&gt; 删除本地某个分支</li>
<li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li>
<li>git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</li>
<li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li>
<li>git checkout &lt;分支名&gt; 切换到本地某个分支</li>
<li>git checkout &lt;远程库名&gt;&#x2F;&lt;分支名&gt; 切换到线上某个分支</li>
<li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li>
</ul>
<h5 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h5><p>远程操作常见的命令：</p>
<ul>
<li>git fetch [remote] 下载远程仓库的所有变动</li>
<li>git remote -v 显示所有远程仓库</li>
<li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li>
<li>git fetch 获取线上最新版信息记录，不合并</li>
<li>git push [remote] [branch] 上传本地指定分支到远程仓库</li>
<li>git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突</li>
<li>git push [remote] –all 推送所有分支到远程仓库</li>
</ul>
<h5 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h5><ul>
<li>git checkout [file] 恢复暂存区的指定文件到工作区</li>
<li>git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</li>
<li>git checkout . 恢复暂存区的所有文件到工作区</li>
<li>git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</li>
<li>git reset –hard 重置暂存区与工作区，与上一次commit保持一致</li>
<li>git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</li>
<li>git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</li>
</ul>
<blockquote>
<p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p>
<p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p>
</blockquote>
<h5 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h5><p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p>
<ul>
<li>git stash 暂时将未提交的变化移除</li>
<li>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</li>
<li>git stash list 查看所有储藏中的工作</li>
<li>git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</li>
<li>git stash clear 清空所有储藏中的工作</li>
<li>git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</li>
</ul>
<h5 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h5><p><code>git</code>常用命令速查表如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613130663363302d663762302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<h3 id="对git-pull-和-git-fetch-的理解？有什么区别？"><a href="#对git-pull-和-git-fetch-的理解？有什么区别？" class="headerlink" title="对git pull 和 git fetch 的理解？有什么区别？"></a>对git pull 和 git fetch 的理解？有什么区别？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>先回顾两个命令的定义</p>
<ul>
<li>git fetch 命令用于从另一个存储库下载对象和引用</li>
<li>git pull 命令用于从另一个存储库或本地分支获取并集成(整合)</li>
</ul>
<p>再来看一次<code>git</code>的工作流程图，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64353233626136302d666163322d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>可以看到，<code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p>
<p>而<code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p>
<p>在我们本地的<code>git</code>文件中对应也存储了<code>git</code>本地仓库分支的<code>commit ID </code>和 跟踪的远程分支的<code>commit ID</code>，对应文件如下：</p>
<ul>
<li>.git&#x2F;refs&#x2F;head&#x2F;[本地分支]</li>
<li>.git&#x2F;refs&#x2F;remotes&#x2F;[正在跟踪的分支]</li>
</ul>
<p>使用 <code>git fetch</code>更新代码，本地的库中<code>master</code>的<code>commitID</code>不变</p>
<p>但是与<code>git</code>上面关联的那个<code>orign/master</code>的<code>commit ID</code>发生改变</p>
<p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过<code>merge</code>去合并这两个不同的代码版本</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66643233666637302d666231322d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>也就是<code>fetch</code>的时候本地的<code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地<code>merge</code>合并这两个版本号的代码</p>
<p>相比之下，使用<code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30393162383134302d666231332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h4><p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到<code>git pull</code>或者<code>git fetch</code>命令</p>
<h5 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h5><p>用法如下：</p>
<pre><code class="ini">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>例如从远程的<code>origin</code>仓库的<code>master</code>分支下载代码到本地并新建一个<code>temp</code>分支</p>
<pre><code class="ini">git fetch origin master:temp
</code></pre>
<p>如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来到本地当前分支</p>
<p>这里<code>git fetch</code>不会进行合并，执行后需要手动执行<code>git merge</code>合并，如下：</p>
<pre><code class="ini">git merge temp
</code></pre>
<h5 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h5><p>两者的用法十分相似，<code>pull</code>用法如下：</p>
<pre><code class="ini">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>例如将远程主机<code>origin</code>的<code>master</code>分支拉取过来，与本地的<code>branchtest</code>分支合并，命令如下：</p>
<pre><code class="ini">git pull origin master:branchtest
</code></pre>
<p>同样如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来与本地当前分支合并</p>
<h4 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h4><p>相同点：</p>
<ul>
<li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li>
</ul>
<p>不同点：</p>
<ul>
<li>git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull &#x3D; git fetch + git merge</li>
<li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li>
</ul>
<h3 id="Git-中-HEAD、工作树和索引之间的区别？"><a href="#Git-中-HEAD、工作树和索引之间的区别？" class="headerlink" title="Git 中 HEAD、工作树和索引之间的区别？"></a>Git 中 HEAD、工作树和索引之间的区别？</h3><h4 id="一、HEAD"><a href="#一、HEAD" class="headerlink" title="一、HEAD"></a>一、HEAD</h4><p>在<code>git</code>中，可以存在很多分支，其本质上是一个指向<code>commit</code>对象的可变指针，而<code>Head</code>是一个特别的指针，是一个指向你正在工作中的本地分支的指针</p>
<p>简单来讲，就是你现在在哪儿，HEAD 就指向哪儿</p>
<p>例如当前我们处于<code>master</code>分支，所以<code>HEAD</code>这个指针指向了<code>master</code>分支指针</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33366362306461302d666134302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>然后通过调用<code>git checkout test</code>切换到<code>test</code>分支，那么<code>HEAD</code>则指向<code>test</code>分支，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33653836626138302d666134302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>但我们在<code>test</code>分支再一次<code>commit</code>信息的时候，<code>HEAD</code>指针仍然指向了<code>test</code>分支指针，而<code>test</code>分支指针已经指向了最新创建的提交，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34333938333962302d666136362d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这个<code>HEAD</code>存储的位置就在<code>.git/HEAD</code>目录中，查看信息可以看到<code>HEAD</code>指向了另一个文件</p>
<pre><code class="ini">$ cat .git/HEAD
ref: refs/heads/master

$ cat .git/refs/heads/master
7406a10efcc169bbab17827aeda189aa20376f7f
</code></pre>
<p>这个文件的内容是一串哈希码，而这个哈希码正是<code>master</code>分支上最新的提交所对应的哈希码</p>
<p>所以，当我们切换分支的时候，<code>HEAD</code>指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p>
<p>所以，HEAD指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p>
<h4 id="二、工作树和索引"><a href="#二、工作树和索引" class="headerlink" title="二、工作树和索引"></a>二、工作树和索引</h4><p>在<code>Git</code>管理下，大家实际操作的目录被称为工作树，也就是工作区域</p>
<p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34366535616334302d666134302d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>Git</code>在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库</p>
<p>因此，要提交文件，首先需要把文件加入到索引区域中。</p>
<p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交</p>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><p>从所在的位置来看：</p>
<ul>
<li>HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</li>
<li>工作树是查看和编辑的（源）文件的实际内容</li>
<li>索引是放置你想要提交给 git仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过git commit 则将索引区域的文件提交到 git 仓库中</li>
</ul>
<h3 id="对git-stash-的理解？应用场景？"><a href="#对git-stash-的理解？应用场景？" class="headerlink" title="对git stash 的理解？应用场景？"></a>对git stash 的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上</p>
<p>后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码</p>
<p>默认情况下，<code>git stash</code>会缓存下列状态的文件：</p>
<ul>
<li>添加到暂存区的修改（staged changes）</li>
<li>Git跟踪的但并未添加到暂存区的修改（unstaged changes）</li>
</ul>
<p>但以下状态的文件不会缓存：</p>
<ul>
<li>在工作目录中新的文件（untracked files）</li>
<li>被忽略的文件（ignored files）</li>
</ul>
<p>如果想要上述的文件都被缓存，可以使用<code>-u</code>或者<code>--include-untracked</code>可以工作目录新的文件，使用<code>-a</code>或者<code>--all</code>命令可以当前目录下的所有修改</p>
<h4 id="二、如何使用-1"><a href="#二、如何使用-1" class="headerlink" title="二、如何使用"></a>二、如何使用</h4><p>关于<code>git stash</code>常见的命令如下：</p>
<ul>
<li>git stash</li>
<li>git stash save</li>
<li>git stash list</li>
<li>git stash pop</li>
<li>git stash apply</li>
<li>git stash show</li>
<li>git stash drop</li>
<li>git stash clear</li>
</ul>
<h5 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h5><p>保存当前工作进度，会把暂存区和工作区的改动保存起来</p>
<h5 id="git-stash-save"><a href="#git-stash-save" class="headerlink" title="git stash save"></a>git stash save</h5><p><code>git stash save</code>可以用于存储修改.并且将<code>git</code>的工作状态切回到<code>HEAD</code>也就是上一次合法提交上</p>
<p>如果给定具体的文件路径,<code>git stash</code>只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：</p>
<ul>
<li>–keep-index 或者 -k 只会存储为加入 git 管理的文件</li>
<li>–include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态</li>
<li>-a 或者 –all 命令可以当前目录下的所有修改，包括被 git 忽略的文件</li>
</ul>
<h5 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h5><p>显示保存进度的列表。也就意味着，<code>git stash</code>命令可以多次执行，当多次使用<code>git stash</code>命令后，栈里会充满未提交的代码，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35303231366464302d666363662d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>其中，<code>stash@&#123;0&#125;</code>、<code>stash@&#123;1&#125;</code>就是当前<code>stash</code>的名称</p>
<h5 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h5><p><code>git stash pop</code> 从栈中读取最近一次保存的内容，也就是栈顶的<code>stash</code>会恢复到工作区</p>
<p>也可以通过 <code>git stash pop</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>
<p>如果从<code>stash</code>中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突</p>
<h5 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h5><p>将堆栈中的内容应用到当前目录，不同于<code>git stash pop</code>，该命令不会将内容从堆栈中删除</p>
<p>也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况</p>
<p>同样，可以通过<code>git stash apply</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>
<h5 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h5><p>查看堆栈中最新保存的<code>stash</code>和当前目录的差异</p>
<p>通过使用<code>git stash show -p</code>查看详细的不同</p>
<p>通过使用<code>git stash show stash@&#123;1&#125;</code>查看指定的<code>stash</code>和当前目录差异</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/bfc073fa538b45c4d6de871da070f364638cdd751a8c08426794c5dba2230514/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34353836323061302d666363662d313165622d626336662d3366303665313439313636342e706e67"><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34353836323061302d666363662d313165622d626336662d3366303665313439313636342e706e67.png" alt="img"></a></p>
<h5 id="git-stash-drop"><a href="#git-stash-drop" class="headerlink" title="git stash drop"></a>git stash drop</h5><p><code>git stash drop</code> + <code>stash</code>名称表示从堆栈中移除某个指定的stash</p>
<h5 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h5><p>删除所有存储的进度</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情</p>
<p>但是你创建一次未完成的代码的<code>commit</code>提交，这时候就可以使用<code>git stash</code></p>
<p>例如以下场景：</p>
<p>当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过<code>git pull</code>解决</p>
<p>但是如果可能发生冲突怎么办.直接<code>git pull</code>会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：</p>
<ul>
<li>git stash</li>
<li>git pull</li>
<li>git stash pop</li>
</ul>
<p>或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用<code>git stash</code>缓存当前区域的代码</p>
<ul>
<li>git stash：保存开发到一半的代码</li>
<li>git commit -m ‘修改问题’</li>
<li>git stash pop：将代码追加到最新的提交之后</li>
</ul>
<h3 id="对git-rebase-和-git-merge的理解？区别？"><a href="#对git-rebase-和-git-merge的理解？区别？" class="headerlink" title="对git rebase 和 git merge的理解？区别？"></a>对git rebase 和 git merge的理解？区别？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p>
<ul>
<li>git merge</li>
<li>git rebase</li>
</ul>
<p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p>
<p>用法上两者也十分的简单：</p>
<h5 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h5><p>将当前分支合并到指定分支，命令用法如下：</p>
<pre><code class="ini">git merge xxx
</code></pre>
<h5 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h5><p>将当前分支移植到指定分支或指定<code>commit</code>之上，用法如下：</p>
<pre><code class="ini">git rebase -i &lt;commit&gt;
</code></pre>
<p>常见的参数有<code>--continue</code>，用于解决冲突之后，继续执行<code>rebase</code></p>
<pre><code class="ini">git rebase --continue
</code></pre>
<h4 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h4><h5 id="git-merge-1"><a href="#git-merge-1" class="headerlink" title="git merge"></a>git merge</h5><p>通过<code>git merge</code>将当前分支与<code>xxx</code>分支合并，产生的新的<code>commit</code>对象有两个父节点</p>
<p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p>
<p>举个例子，<code>bugfix</code>分支是从<code>maste</code>r分支分叉出来的，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38383431306133302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>合并<code> bugfix</code>分支到<code>master</code>分支时，如果<code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含<code>master</code>分支所有的历史记录</p>
<p>所以通过把<code>master</code>分支的位置移动到<code>bugfix</code>的最新分支上，就完成合并</p>
<p>如果<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39323965623232302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这时候使用<code>git merge</code>的时候，会生成一个新的提交，并且<code>master</code>分支的<code>HEAD</code>会移动到新的分支上，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39666466613365302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p>
<h5 id="git-rebase-1"><a href="#git-rebase-1" class="headerlink" title="git rebase"></a>git rebase</h5><p>同样，<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61623264353132302d666464342d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>通过<code>git rebase</code>，会变成如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62373261656437302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63396261306538302d666464342d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>rebase</code>之后，<code>master</code>的<code>HEAD</code>位置不变。因此，要合并<code>master</code>分支和<code>bugfix</code>分支</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64633636303636302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的<code>B</code></p>
<p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交<code>X</code>和<code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p>
<p>然后将当前分支指向目标最新位置<code>D</code>, 然后将之前另存为临时文件的修改依序应用</p>
<h4 id="三、区别-3"><a href="#三、区别-3" class="headerlink" title="三、区别"></a>三、区别</h4><p>从上面可以看到，<code>merge</code>和<code>rebasea</code>都是合并历史记录，但是各自特性不同：</p>
<h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>通过<code>merge</code>合并分支会新增一个<code>merge commit</code>，然后将两个分支的历史联系起来</p>
<p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p>
<h5 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h5><p><code>rebase </code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p>
<p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p>
<h3 id="git-发生冲突的场景？如何解决？"><a href="#git-发生冲突的场景？如何解决？" class="headerlink" title="git 发生冲突的场景？如何解决？"></a>git 发生冲突的场景？如何解决？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>一般情况下，出现分支的场景有如下：</p>
<ul>
<li>多个分支代码合并到一个分支时</li>
<li>多个分支向同一个远端分支推送</li>
</ul>
<p>具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称</p>
<p>如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可</p>
<p>应用在命令中，就是<code>push</code>、<code>pull</code>、<code>stash</code>、<code>rebase</code>等命令下都有可能产生冲突情况，从本质上来讲，都是<code>merge</code>和<code>patch</code>（应用补丁）时产生冲突</p>
<h4 id="二、分析-1"><a href="#二、分析-1" class="headerlink" title="二、分析"></a>二、分析</h4><p>在本地主分值<code>master</code>创建一个<code>a.txt</code>文件，文件起始位置写上<code>master commit</code>，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39353961646532302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>然后提交到仓库：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m ‘master first commit’</li>
</ul>
<p>创建一个新的分支<code>featurel1</code>分支，并进行切换，如下：</p>
<pre><code class="ini">git checkout -b featurel1
</code></pre>
<p>然后修改<code>a.txt</code>文件首行文字为 <code>featurel commit</code>，然后添加到暂存区，并开始进行提交到仓库：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m ‘featurel first change’</li>
</ul>
<p>然后通过<code>git checkout master</code>切换到主分支，通过<code>git merge</code>进行合并，发现不会冲突</p>
<p>此时<code>a.txt</code>文件的内容变成<code>featurel commit</code>，没有出现冲突情况，这是因为<code>git</code>在内部发生了快速合并</p>
<blockquote>
<p>如果当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作</p>
<p>git 不创建任何新的提交(commit)，只是将当前分支指向合并进来的分支</p>
</blockquote>
<p>如果此时切换到<code>featurel</code>分支，将文件的内容修改成<code>featrue second commit</code>，然后提交到本地仓库</p>
<p>然后切换到主分支，如果此时在<code>a.txt</code>文件再次修改，修改成<code>mastet second commit</code>，然后再次提交到本地仓库</p>
<p>此时，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61303534383863302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这种情况下，无法执行快速合并，只能试图把各自的修改合并起来，但这种合并就可能会有冲突</p>
<p>现在通过<code>git merge featurel</code>进行分支合并，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62303939316439302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>从冲突信息可以看到，<code>a.txt</code>发生冲突，必须手动解决冲突之后再提交</p>
<p>而<code>git status</code>同样可以告知我们冲突的文件：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63353832333433302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>打开<code>a.txt</code>文件，可以看到如下内容：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63653761306139302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容：</p>
<ul>
<li>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 和 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 之间的区域就是当前更改的内容</li>
<li>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 之间的区域就是传入进来更改的内容</li>
</ul>
<p>现在要做的事情就是将冲突的内容进行更改，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，<code>Git </code>就会将它们标记为冲突已解决然后再提交：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m “conflict fixed”</li>
</ul>
<p>此时<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64373432316536302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>使用<code>git log</code>命令可以看到合并的信息：</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65306466643162302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></h4><h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>当<code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p>
<p>解决冲突就是把<code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p>
<h3 id="对git-reset-和-git-revert-的理解？区别？"><a href="#对git-reset-和-git-revert-的理解？区别？" class="headerlink" title="对git reset 和 git revert 的理解？区别？"></a>对git reset 和 git revert 的理解？区别？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><h5 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h5><p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p>
<p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61623464306330302d666637322d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h5><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e14636346aeadfa4f5766d89196355a3ff8fd0edadd8b74bd5803cdab3312e60/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643132633239302d666637322d313165622d393931642d3333346664333166303230312e706e67"><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643132633239302d666637322d313165622d393931642d3333346664333166303230312e706e67.png" alt="img"></a></p>
<h4 id="二、如何用"><a href="#二、如何用" class="headerlink" title="二、如何用"></a>二、如何用</h4><h5 id="git-reset-1"><a href="#git-reset-1" class="headerlink" title="git reset"></a>git reset</h5><p>当没有指定<code>ID</code>的时候，默认使用<code>HEAD</code>，如果指定<code>ID</code>，那么就是基于指向<code>ID</code>去变动暂存区或工作区的内容</p>
<pre><code class="ini">// 没有指定ID, 暂存区的内容会被当前ID版本号的内容覆盖，工作区不变
git reset

// 指定ID，暂存区的内容会被指定ID版本号的内容覆盖，工作区不变
git reset &lt;ID&gt; 
</code></pre>
<p>日志<code>ID</code>可以通过查询，可以<code>git log</code>进行查询，如下：</p>
<pre><code class="ini">commit a7700083ace1204ccdff9f71631fb34c9913f7c5 (HEAD -&gt; master)
Author: linguanghui &lt;linguanghui@baidu.com&gt;
Date:   Tue Aug 17 22:34:40 2021 +0800

    second commit

commit e31118663ce66717edd8a179688a7f3dde5a9393
Author: linguanghui &lt;linguanghui@baidu.com&gt;
Date:   Tue Aug 17 22:20:01 2021 +0800

    first commit
</code></pre>
<p>常见命令如下：</p>
<ul>
<li>–mixed（默认）：默认的时候，只有暂存区变化</li>
<li>–hard参数：如果使用 –hard 参数，那么工作区也会变化</li>
<li>–soft：如果使用 –soft 参数，那么暂存区和工作区都不会变化</li>
</ul>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32323562343165302d666637332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="git-revert-1"><a href="#git-revert-1" class="headerlink" title="git revert"></a>git revert</h5><p>跟<code>git reset</code>用法基本一致，<code>git revert</code> 撤销某次操作，此次操作之前和之后的 <code>commit</code>和<code>history</code>都会保留，并且把这次撤销，作为一次最新的提交，如下：</p>
<pre><code class="ini">git revert &lt;commit_id&gt; 
</code></pre>
<p>如果撤销前一个版本，可以通过如下命令：</p>
<pre><code class="ini">git revert HEAD
</code></pre>
<p>撤销前前一次，如下：</p>
<pre><code class="ini">git revert HEAD^
</code></pre>
<h4 id="三、区别-4"><a href="#三、区别-4" class="headerlink" title="三、区别"></a>三、区别</h4><p>撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，<code>git reset</code>被设计为重设本地更改</p>
<p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p>
<p>两者主要区别如下：</p>
<ul>
<li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li>
<li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容</li>
<li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li>
</ul>
<blockquote>
<p>git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并</p>
<p>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</p>
</blockquote>
<ul>
<li>如果回退分支的代码以后还需要的情况则使用<code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用<code>git reset</code></li>
</ul>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mians/" rel="tag">mians</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" rel="tag">代码版本控制</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全设计模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
    >前端面试大全设计模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-11-03T01:26:38.000Z" itemprop="datePublished">2022-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">常用设计模式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（设计模式）"><a href="#前端面试题大全（设计模式）" class="headerlink" title="前端面试题大全（设计模式）"></a>前端面试题大全（设计模式）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ul>
<li>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</li>
</ul>
<h3 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h3><ul>
<li>看懂源代码：如果你不懂设计模式去看Jdk、Spring、SpringMVC、IO等等等等的源码，你会很迷茫，你会寸步难行</li>
<li>看看前辈的代码：你去个公司难道都是新项目让你接手？很有可能是接盘的，前辈的开发难道不用设计模式？</li>
<li>编写自己的理想中的好代码：我个人反正是这样的，对于我自己开发的项目我会很认真，我对他比对我女朋友还好，把项目当成自己的儿子一样</li>
</ul>
<h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17172acfe20b2d2d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png"></p>
<ul>
<li>创建型模式，共五种：工厂方法模式、抽象工厂模式<strong>、</strong>单例模式、建造者模式、原型模式。</li>
<li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17172acff10be430~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.jpeg"></p>
<h4 id="开放封闭原则（Open-Close-Principle）"><a href="#开放封闭原则（Open-Close-Principle）" class="headerlink" title="开放封闭原则（Open Close Principle）"></a>开放封闭原则（Open Close Principle）</h4><ul>
<li>原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</li>
<li>描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li>
<li>优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。</li>
</ul>
<h4 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h4><ul>
<li>原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。</li>
<li>大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。</li>
<li>优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。</li>
</ul>
<h4 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h4><ul>
<li>依赖倒置原则的核心思想是面向接口编程.</li>
<li>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，</li>
<li>这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。</li>
</ul>
<h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h4><ul>
<li>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</li>
<li>例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口</li>
</ul>
<h4 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h4><ul>
<li>原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦</li>
<li>大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</li>
<li>优点：低耦合，高内聚。</li>
</ul>
<h4 id="单一职责原则（Principle-of-single-responsibility）"><a href="#单一职责原则（Principle-of-single-responsibility）" class="headerlink" title="单一职责原则（Principle of single responsibility）"></a>单一职责原则（Principle of single responsibility）</h4><ul>
<li>原则思想：一个方法只负责一件事情。</li>
<li>描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。</li>
<li>优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>单例模式（Singleton Pattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建</p>
<p>在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66613738393864302d336232632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>从定义上来看，全局变量好像就是单例模式，但是一般情况我们不认为全局变量是一个单例模式，原因是：</p>
<ul>
<li>全局命名污染</li>
<li>不易维护，容易被重写覆盖</li>
</ul>
<h4 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h4><p>在<code>javascript</code>中，实现一个单例模式可以用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可，如下：</p>
<pre><code class="javascript">// 定义一个类
function Singleton(name) &#123;
  this.name = name;
  this.instance = null;
&#125;
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 获取类的实例
Singleton.getInstance = function(name) &#123;
  if(!this.instance) &#123;
      this.instance = new Singleton(name);
  &#125;
  return this.instance
&#125;;

// 获取对象1
const a = Singleton.getInstance(&#39;a&#39;);
// 获取对象2
const b = Singleton.getInstance(&#39;b&#39;);
// 进行比较
console.log(a === b);
</code></pre>
<p>使用闭包也能够实现，如下：</p>
<pre><code class="javascript">function Singleton(name) &#123;
  this.name = name;
&#125;
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 获取类的实例
Singleton.getInstance = (function() &#123;
  var instance = null;
  return function(name) &#123;
      if(!this.instance) &#123;
          this.instance = new Singleton(name);
      &#125;
      return this.instance
  &#125;        
&#125;)();

// 获取对象1
const a = Singleton.getInstance(&#39;a&#39;);
// 获取对象2
const b = Singleton.getInstance(&#39;b&#39;);
// 进行比较
console.log(a === b);
</code></pre>
<p>也可以将上述的方法稍作修改，变成构造函数的形式，如下：</p>
<pre><code class="javascript">// 单例构造函数
function CreateSingleton (name) &#123;
  this.name = name;
  this.getName();
&#125;;

// 获取实例的名字
CreateSingleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 单例对象
const Singleton = (function()&#123;
  var instance;
  return function (name) &#123;
      if(!instance) &#123;
          instance = new CreateSingleton(name);
      &#125;
      return instance;
  &#125;
&#125;)();

// 创建实例对象1
const a = new Singleton(&#39;a&#39;);
// 创建实例对象2
const b = new Singleton(&#39;b&#39;);

console.log(a===b); // true
</code></pre>
<h4 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>在前端中，很多情况都是用到单例模式，例如页面存在一个模态框的时候，只有用户点击的时候才会创建，而不是加载完成之后再创建弹窗和隐藏，并且保证弹窗全局只有一个</p>
<p>可以先创建一个通常的获取对象的方法，如下：</p>
<pre><code class="javascript">const getSingle = function( fn )&#123;
let result;
return function()&#123;
  return result || ( result = fn .apply(this, arguments ) );
&#125;
&#125;; 
</code></pre>
<p>创建弹窗的代码如下：</p>
<pre><code class="javascript">const createLoginLayer = function()&#123;
var div = document.createElement( &#39;div&#39; );
div.innerHTML = &#39;我是浮窗&#39;;
div.style.display = &#39;none&#39;;
document.body.appendChild( div );
return div;
&#125;; 

const createSingleLoginLayer = getSingle( createLoginLayer ); 

document.getElementById( &#39;loginBtn&#39; ).onclick = function()&#123;
var loginLayer = createSingleLoginLayer();
loginLayer.style.display = &#39;block&#39;;
&#125;;
</code></pre>
<p>上述这种实现称为惰性单例，意图解决需要时才创建类实例对象</p>
<p>并且<code>Vuex</code>、<code>redux</code>全局态管理库也应用单例模式的思想，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38626535306638302d336232622d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>现在很多第三方库都是单例模式，多次引用只会使用同一个对象，如<code>jquery</code>、<code>lodash</code>、<code>moment</code>…</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂</p>
<p>其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品</p>
<p>举个例子：</p>
<ul>
<li>编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联（耦合）</li>
<li>后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事；</li>
<li>这种情况下，就需要将创建实例的工作从调用方（A类）中分离，与调用方解耦，也就是使用工厂方法创建实例的工作封装起来（减少代码重复），由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，而降低调用者因为创建逻辑导致的错误；</li>
</ul>
<h4 id="二、实现-1"><a href="#二、实现-1" class="headerlink" title="二、实现"></a>二、实现</h4><p>工厂模式根据抽象程度的不同可以分为：</p>
<ul>
<li>简单工厂模式（Simple Factory）</li>
<li>工厂方法模式（Factory Method）</li>
<li>抽象工厂模式（Abstract Factory）</li>
</ul>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例</p>
<p>假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致</p>
<p>代码如下：</p>
<pre><code class="javascript">function Factory(career) &#123;
    function User(career, work) &#123;
        this.career = career 
        this.work = work
    &#125;
    let work
    switch(career) &#123;
        case &#39;coder&#39;:
            work =  [&#39;写代码&#39;, &#39;修Bug&#39;] 
            return new User(career, work)
            break
        case &#39;hr&#39;:
            work = [&#39;招聘&#39;, &#39;员工信息管理&#39;]
            return new User(career, work)
            break
        case &#39;driver&#39;:
            work = [&#39;开车&#39;]
            return new User(career, work)
            break
        case &#39;boss&#39;:
            work = [&#39;喝茶&#39;, &#39;开会&#39;, &#39;审批文件&#39;]
            return new User(career, work)
            break
    &#125;
&#125;
let coder = new Factory(&#39;coder&#39;)
console.log(coder)
let boss = new Factory(&#39;boss&#39;)
console.log(boss)
</code></pre>
<p><code>Factory</code>就是一个简单工厂。当我们调用工厂函数时，只需要传递name、age、career就可以获取到包含用户工作内容的实例对象</p>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂方法模式跟简单工厂模式差不多，但是把具体的产品放到了工厂函数的<code>prototype</code>中</p>
<p>这样一来，扩展产品种类就不必修改工厂函数了，核心类就变成抽象类，也可以随时重写某种具体的产品</p>
<p>也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产；但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产</p>
<p>如下代码：</p>
<pre><code class="javascript">// 工厂方法
function Factory(career)&#123;
    if(this instanceof Factory)&#123;
        var a = new this[career]();
        return a;
    &#125;else&#123;
        return new Factory(career);
    &#125;
&#125;
// 工厂方法函数的原型中设置所有对象的构造函数
Factory.prototype=&#123;
    &#39;coder&#39;: function()&#123;
        this.careerName = &#39;程序员&#39;
        this.work = [&#39;写代码&#39;, &#39;修Bug&#39;] 
    &#125;,
    &#39;hr&#39;: function()&#123;
        this.careerName = &#39;HR&#39;
        this.work = [&#39;招聘&#39;, &#39;员工信息管理&#39;]
    &#125;,
    &#39;driver&#39;: function () &#123;
        this.careerName = &#39;司机&#39;
        this.work = [&#39;开车&#39;]
    &#125;,
    &#39;boss&#39;: function()&#123;
        this.careerName = &#39;老板&#39;
        this.work = [&#39;喝茶&#39;, &#39;开会&#39;, &#39;审批文件&#39;]
    &#125;
&#125;
let coder = new Factory(&#39;coder&#39;)
console.log(coder)
let hr = new Factory(&#39;hr&#39;)
console.log(hr)
</code></pre>
<p>工厂方法关键核心代码是工厂里面的判断this是否属于工厂，也就是做了分支判断，这个工厂只做我能做的产品</p>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>上述简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建</p>
<p>通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的</p>
<p>由于<code>JavaScript</code>中并没有抽象类的概念，只能模拟，可以分成四部分：</p>
<ul>
<li>用于创建抽象类的函数</li>
<li>抽象类</li>
<li>具体类</li>
<li>实例化具体类</li>
</ul>
<p>上面的例子中有<code>coder</code>、<code>hr</code>、<code>boss</code>、<code>driver</code>四种岗位，其中<code>coder</code>可能使用不同的开发语言进行开发，比如<code>JavaScript</code>、<code>Java</code>等等。那么这两种语言就是对应的类簇</p>
<p>示例代码如下：</p>
<pre><code class="javascript">let CareerAbstractFactory = function(subType, superType) &#123;
  // 判断抽象工厂中是否有该抽象类
  if (typeof CareerAbstractFactory[superType] === &#39;function&#39;) &#123;
    // 缓存类
    function F() &#123;&#125;
    // 继承父类属性和方法
    F.prototype = new CareerAbstractFactory[superType]()
    // 将子类的constructor指向父类
    subType.constructor = subType;
    // 子类原型继承父类
    subType.prototype = new F()
  &#125; else &#123;
    throw new Error(&#39;抽象类不存在&#39;)
  &#125;
&#125;
</code></pre>
<p>上面代码中<code>CareerAbstractFactory</code>就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>从上面可看到，简单简单工厂的优点就是我们只要传递正确的参数，就能获得所需的对象，而不需要关心其创建的具体细节</p>
<p>应用场景也容易识别，有构造函数的地方，就应该考虑简单工厂，但是如果函数构建函数太多与复杂，会导致工厂函数变得复杂，所以不适合复杂的情况</p>
<p>抽象工厂模式一般用于严格要求以面向对象思想进行开发的超大型项目中，我们一般常规的开发的话一般就是简单工厂和工厂方法模式会用的比较多一些</p>
<p>综上，工厂模式适用场景如下：</p>
<ul>
<li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li>
<li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li>
<li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来</p>
<p>一个基于策略模式的程序至少由两部分组成：</p>
<ul>
<li>策略类，策略类封装了具体的算法，并负责具体的计算过程</li>
<li>环境类Context，Context 接受客户的请求，随后 把请求委托给某一个策略类</li>
</ul>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>举个例子，公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍</p>
<p>若使用<code>if</code>来实现，代码则如下：</p>
<pre><code class="javascript">var calculateBouns = function(salary,level) &#123;
    if(level === &#39;A&#39;) &#123;
        return salary * 4;
    &#125;
    if(level === &#39;B&#39;) &#123;
        return salary * 3;
    &#125;
    if(level === &#39;C&#39;) &#123;
        return salary * 2;
    &#125;
&#125;;
// 调用如下：
console.log(calculateBouns(4000,&#39;A&#39;)); // 16000
console.log(calculateBouns(2500,&#39;B&#39;)); // 7500
</code></pre>
<p>从上述可有看到，函数内部包含过多<code>if...else</code>，并且后续改正的时候，需要在函数内部添加逻辑，违反了开放封闭原则</p>
<p>而如果使用策略模式，就是先定义一系列算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，如下：</p>
<pre><code class="javascript">var obj = &#123;
        &quot;A&quot;: function(salary) &#123;
            return salary * 4;
        &#125;,
        &quot;B&quot; : function(salary) &#123;
            return salary * 3;
        &#125;,
        &quot;C&quot; : function(salary) &#123;
            return salary * 2;
        &#125; 
&#125;;
var calculateBouns =function(level,salary) &#123;
    return obj[level](salary);
&#125;;
console.log(calculateBouns(&#39;A&#39;,10000)); // 40000
</code></pre>
<p>上述代码中，<code>obj</code>对应的是策略类，而<code>calculateBouns</code>对应上下通信类</p>
<p>又比如实现一个表单校验的代码，常常会像如下写法：</p>
<pre><code class="javascript">var registerForm = document.getElementById(&quot;registerForm&quot;);
registerForm.onsubmit = function()&#123;
    if(registerForm.userName.value === &#39;&#39;) &#123;
        alert(&#39;用户名不能为空&#39;);
        return;
    &#125;
    if(registerForm.password.value.length &lt; 6) &#123;
        alert(&quot;密码的长度不能小于6位&quot;);
        return;
    &#125;
    if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123;
        alert(&quot;手机号码格式不正确&quot;);
        return;
    &#125;
&#125;
</code></pre>
<p>上述代码包含多处<code>if</code>语句，并且违反了开放封闭原则，如果应用中还有其他的表单，需要重复编写代码</p>
<p>此处也可以使用策略模式进行重构校验，第一步确定不变的内容，即策略规则对象，如下：</p>
<pre><code class="javascript">var strategy = &#123;
    isNotEmpty: function(value,errorMsg) &#123;
        if(value === &#39;&#39;) &#123;
            return errorMsg;
        &#125;
    &#125;,
    // 限制最小长度
    minLength: function(value,length,errorMsg) &#123;
        if(value.length &lt; length) &#123;
            return errorMsg;
        &#125;
    &#125;,
    // 手机号码格式
    mobileFormat: function(value,errorMsg) &#123;
        if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123;
            return errorMsg;
        &#125;
    &#125; 
&#125;;
</code></pre>
<p>然后找出变的地方，作为环境类<code>context</code>，负责接收用户的要求并委托给策略规则对象，如下<code>Validator</code>类：</p>
<pre><code class="javascript">var Validator = function()&#123;
        this.cache = [];  // 保存效验规则
&#125;;
Validator.prototype.add = function(dom,rule,errorMsg) &#123;
    var str = rule.split(&quot;:&quot;);
    this.cache.push(function()&#123;
        // str 返回的是 minLength:6 
        var strategy = str.shift();
        str.unshift(dom.value); // 把input的value添加进参数列表
        str.push(errorMsg);  // 把errorMsg添加进参数列表
        return strategys[strategy].apply(dom,str);
    &#125;);
&#125;;
Validator.prototype.start = function()&#123;
    for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123;
        var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息
        if(msg) &#123;
            return msg;
        &#125;
    &#125;
&#125;;
</code></pre>
<p>通过<code>validator.add</code>方法添加校验规则和错误信息提示，使用如下：</p>
<pre><code class="javascript">var validateFunc = function()&#123;
    var validator = new Validator(); // 创建一个Validator对象
    /* 添加一些效验规则 */
    validator.add(registerForm.userName,&#39;isNotEmpty&#39;,&#39;用户名不能为空&#39;);
    validator.add(registerForm.password,&#39;minLength:6&#39;,&#39;密码长度不能小于6位&#39;);
    validator.add(registerForm.userName,&#39;mobileFormat&#39;,&#39;手机号码格式不正确&#39;);

    var errorMsg = validator.start(); // 获得效验结果
    return errorMsg; // 返回效验结果
&#125;;
var registerForm = document.getElementById(&quot;registerForm&quot;);
registerForm.onsubmit = function()&#123;
    var errorMsg = validateFunc();
    if(errorMsg)&#123;
        alert(errorMsg);
        return false;
    &#125;
&#125;
</code></pre>
<p>上述通过策略模式完成表单的验证，并且可以随时调用，在修改表单验证规则的时候，也非常方便，通过传递参数即可调用</p>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>从上面可以看到，使用策略模式的优点有如下：</p>
<ul>
<li>策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句</li>
<li>策略模式提供了开放-封闭原则，使代码更容易理解和扩展</li>
<li>策略模式中的代码可以复用</li>
</ul>
<p>策略模式不仅仅用来封装算法，在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装 一系列的“业务规则”</p>
<p>只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>代理模式（Proxy Pattern）是为一个对象提供一个代用品或占位符，以便控制对它的访问</p>
<p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39353163393962302d336436612d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>在生活中，代理模式的场景是十分常见的，例如我们现在如果有租房、买房的需求，更多的是去找链家等房屋中介机构，而不是直接寻找想卖房或出租房的人谈。此时，链家起到的作用就是代理的作用</p>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p>在<code>ES6</code>中，存在<code>proxy</code>构建函数能够让我们轻松使用代理模式：</p>
<pre><code class="javascript">const proxy = new Proxy(target, handler);
</code></pre>
<p>关于<code>Proxy</code>的使用可以翻看以前的文章</p>
<p>而按照功能来划分，<code>javascript</code>代理模式常用的有：</p>
<ul>
<li>缓存代理</li>
<li>虚拟代理</li>
</ul>
<h5 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h5><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</p>
<p>如实现一个求积乘的函数，如下：</p>
<pre><code class="javascript">var muti = function () &#123;
  console.log(&quot;开始计算乘积&quot;);
  var a = 1;
  for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;
    a = a * arguments[i];
  &#125;
  return a;
&#125;;
</code></pre>
<p>现在加入缓存代理，如下：</p>
<pre><code class="javascript">var proxyMult = (function () &#123;
  var cache = &#123;&#125;;
  return function () &#123;
    var args = Array.prototype.join.call(arguments, &quot;,&quot;);
    if (args in cache) &#123;
      return cache[args];
    &#125;
    return (cache[args] = mult.apply(this, arguments));
  &#125;;
&#125;)();

proxyMult(1, 2, 3, 4); // 输出:24
proxyMult(1, 2, 3, 4); // 输出:24
</code></pre>
<p>当第二次调用 <code>proxyMult(1, 2, 3, 4)</code> 时，本体 <code>mult</code> 函数并没有被计算，<code>proxyMult</code> 直接返回了之前缓存好的计算结果</p>
<h5 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h5><p>虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建</p>
<p>常见的就是图片预加载功能：</p>
<p>未使用代理模式如下：</p>
<pre><code class="javascript">let MyImage = (function()&#123;
    let imgNode = document.createElement( &#39;img&#39; );
    document.body.appendChild( imgNode );
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;

    img.onload = function()&#123;
        // 监听到图片加载完成后，设置src为加载完成后的图片
        imgNode.src = img.src;
    &#125;;

    return &#123;
        setSrc: function( src )&#123;
            // 设置图片的时候，设置为默认的loading图
            imgNode.src = &#39;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#39;;
            // 把真正需要设置的图片传给Image对象的src属性
            img.src = src;
        &#125;
    &#125;
&#125;)();

MyImage.setSrc( &#39;https://xxx.jpg&#39; );
</code></pre>
<p><code>MyImage</code>对象除了负责给<code>img</code>节点设置<code>src</code>外，还要负责预加载图片，违反了面向对象设计的原则——单一职责原则</p>
<p>上述过程<code>loding</code>则是耦合进<code>MyImage</code>对象里的，如果以后某个时候，我们不需要预加载显示loading这个功能了，就只能在<code>MyImage</code>对象里面改动代码</p>
<p>使用代理模式，代码则如下：</p>
<pre><code class="javascript">// 图片本地对象，负责往页面中创建一个img标签，并且提供一个对外的setSrc接口
let myImage = (function()&#123;
    let imgNode = document.createElement( &#39;img&#39; );
    document.body.appendChild( imgNode );

    return &#123;
        //setSrc接口，外界调用这个接口，便可以给该img标签设置src属性
        setSrc: function( src )&#123;
            imgNode.src = src;
        &#125;
    &#125;
&#125;)();
// 代理对象，负责图片预加载功能
let proxyImage = (function()&#123;
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;
    img.onload = function()&#123;
        // 监听到图片加载完成后，给被代理的图片本地对象设置src为加载完成后的图片
        myImage.setSrc( this.src );
    &#125;
    return &#123;
        setSrc: function( src )&#123;
            // 设置图片时，在图片未被真正加载好时，以这张图作为loading，提示用户图片正在加载
            myImage.setSrc( &#39;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#39; );
            img.src = src;
        &#125;
    &#125;
&#125;)();

proxyImage.setSrc( &#39;https://xxx.jpg&#39; );
</code></pre>
<p>使用代理模式后，图片本地对象负责往页面中创建一个<code>img</code>标签，并且提供一个对外的<code>setSrc</code>接口；</p>
<p>代理对象负责在图片未加载完成之前，引入预加载的<code>loading</code>图，负责了图片预加载的功能</p>
<p>上述并没有改变或者增加<code>MyImage</code>的接口，但是通过代理对象，实际上给系统添加了新的行为</p>
<p>并且上述代理模式可以发现，代理和本体接口的一致性，如果有一天不需要预加载，那么就不需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了 <code>setSrc</code> 方法</p>
<p>‘</p>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>现在的很多前端框架或者状态管理框架都使用代理模式，用与监听变量的变化</p>
<p>使用代理模式代理对象的访问的方式，一般又被称为拦截器，比如我们在项目中经常使用 <code>Axios</code> 的实例来进行 HTTP 的请求，使用拦截器 <code>interceptor</code> 可以提前对 请求前的数据 服务器返回的数据进行一些预处理</p>
<p>以及上述应用到的缓存代理和虚拟代理</p>
<h3 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h3><h4 id="一、观察者模式"><a href="#一、观察者模式" class="headerlink" title="一、观察者模式"></a>一、观察者模式</h4><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p>
<p>观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64336138303032302d336637632d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸</p>
<p>报社和订报纸的客户就形成了一对多的依赖关系</p>
<p>实现代码如下：</p>
<p>被观察者模式</p>
<pre><code class="javascript">class Subject &#123;

  constructor() &#123;
    this.observerList = [];
  &#125;

  addObserver(observer) &#123;
    this.observerList.push(observer);
  &#125;

  removeObserver(observer) &#123;
    const index = this.observerList.findIndex(o =&gt; o.name === observer.name);
    this.observerList.splice(index, 1);
  &#125;

  notifyObservers(message) &#123;
    const observers = this.observeList;
    observers.forEach(observer =&gt; observer.notified(message));
  &#125;

&#125;
</code></pre>
<p>观察者：</p>
<pre><code class="javascript">class Observer &#123;

  constructor(name, subject) &#123;
    this.name = name;
    if (subject) &#123;
      subject.addObserver(this);
    &#125;
  &#125;

  notified(message) &#123;
    console.log(this.name, &#39;got message&#39;, message);
  &#125;
&#125;
</code></pre>
<p>使用代码如下：</p>
<pre><code class="javascript">const subject = new Subject();
const observerA = new Observer(&#39;observerA&#39;, subject);
const observerB = new Observer(&#39;observerB&#39;);
subject.addObserver(observerB);
subject.notifyObservers(&#39;Hello from subject&#39;);
subject.removeObserver(observerA);
subject.notifyObservers(&#39;Hello again&#39;);
</code></pre>
<p>上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表</p>
<h4 id="二、发布订阅模式"><a href="#二、发布订阅模式" class="headerlink" title="二、发布订阅模式"></a>二、发布订阅模式</h4><p>发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在</p>
<p>同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65323464336364302d336637632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>实现代码如下：</p>
<pre><code class="javascript">class PubSub &#123;
  constructor() &#123;
    this.messages = &#123;&#125;;
    this.listeners = &#123;&#125;;
  &#125;
  // 添加发布者
  publish(type, content) &#123;
    const existContent = this.messages[type];
    if (!existContent) &#123;
      this.messages[type] = [];
    &#125;
    this.messages[type].push(content);
  &#125;
  // 添加订阅者
  subscribe(type, cb) &#123;
    const existListener = this.listeners[type];
    if (!existListener) &#123;
      this.listeners[type] = [];
    &#125;
    this.listeners[type].push(cb);
  &#125;
  // 通知
  notify(type) &#123;
    const messages = this.messages[type];
    const subscribers = this.listeners[type] || [];
    subscribers.forEach((cb, index) =&gt; cb(messages[index]));
  &#125;
&#125;
</code></pre>
<p>发布者代码如下：</p>
<pre><code class="javascript">class Publisher &#123;
  constructor(name, context) &#123;
    this.name = name;
    this.context = context;
  &#125;
  publish(type, content) &#123;
    this.context.publish(type, content);
  &#125;
&#125;
</code></pre>
<p>订阅者代码如下：</p>
<pre><code class="javascript">class Subscriber &#123;
  constructor(name, context) &#123;
    this.name = name;
    this.context = context;
  &#125;
  subscribe(type, cb) &#123;
    this.context.subscribe(type, cb);
  &#125;
&#125;
</code></pre>
<p>使用代码如下：</p>
<pre><code class="javascript">const TYPE_A = &#39;music&#39;;
const TYPE_B = &#39;movie&#39;;
const TYPE_C = &#39;novel&#39;;

const pubsub = new PubSub();

const publisherA = new Publisher(&#39;publisherA&#39;, pubsub);
publisherA.publish(TYPE_A, &#39;we are young&#39;);
publisherA.publish(TYPE_B, &#39;the silicon valley&#39;);
const publisherB = new Publisher(&#39;publisherB&#39;, pubsub);
publisherB.publish(TYPE_A, &#39;stronger&#39;);
const publisherC = new Publisher(&#39;publisherC&#39;, pubsub);
publisherC.publish(TYPE_C, &#39;a brief history of time&#39;);

const subscriberA = new Subscriber(&#39;subscriberA&#39;, pubsub);
subscriberA.subscribe(TYPE_A, res =&gt; &#123;
  console.log(&#39;subscriberA received&#39;, res)
&#125;);
const subscriberB = new Subscriber(&#39;subscriberB&#39;, pubsub);
subscriberB.subscribe(TYPE_C, res =&gt; &#123;
  console.log(&#39;subscriberB received&#39;, res)
&#125;);
const subscriberC = new Subscriber(&#39;subscriberC&#39;, pubsub);
subscriberC.subscribe(TYPE_B, res =&gt; &#123;
  console.log(&#39;subscriberC received&#39;, res)
&#125;);

pubsub.notify(TYPE_A);
pubsub.notify(TYPE_B);
pubsub.notify(TYPE_C);
</code></pre>
<p>上述代码，发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>两种设计模式思路是一样的，举个生活例子：</p>
<ul>
<li>观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体</li>
<li>发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决</li>
</ul>
<p>上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的</p>
<p>两者区别如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f3135352f39313431363832632d373338362d346631322d383431322d6662313761316364346266362e706e67.png"></p>
<ul>
<li>在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</li>
<li>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</li>
<li>观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</li>
</ul>
<h3 id="其他完整的设计模式（感兴趣可以看看）"><a href="#其他完整的设计模式（感兴趣可以看看）" class="headerlink" title="其他完整的设计模式（感兴趣可以看看）"></a>其他完整的设计模式（感兴趣可以看看）</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904032826294286">23种设计模式</a></p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全TypeScript"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/"
    >前端面试大全TypeScript</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/" class="article-date">
  <time datetime="2022-11-02T02:27:06.000Z" itemprop="datePublished">2022-11-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/TypeScript/">TypeScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（TypeScript）"><a href="#前端面试题大全（TypeScript）" class="headerlink" title="前端面试题大全（TypeScript）"></a>前端面试题大全（TypeScript）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-typescript-的理解？与-javascript-的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-typescript-的理解？与-javascript-的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 typescript 的理解？与 javascript 的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 typescript 的理解？与 javascript 的区别？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>TypeScript</code> 是 <code>JavaScript</code> 的类型的超集，支持<code>ES6</code>语法，支持面向对象编程的概念，如类、接口、继承、泛型等</p>
<blockquote>
<p>超集，不得不说另外一个概念，子集，怎么理解这两个呢，举个例子，如果一个集合A里面的的所有元素集合B里面都存在，那么我们可以理解集合B是集合A的超集，集合A为集合B的子集</p>
</blockquote>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36316332633166302d303935302d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>其是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误</p>
<p>同时扩展了<code> JavaScript</code> 的语法，所以任何现有的<code> JavaScript</code> 程序可以不加改变的在 <code>TypeScript</code> 下工作</p>
<p>为了保证兼容性，<code>typescript</code>在编译阶段需要编译器编译成纯<code>Javascript</code>来运行，是为大型应用之开发而设计的语言，如下：</p>
<p><code>tsx</code>文件如下：</p>
<pre><code class="typescript">const hello : string = &quot;Hello World!&quot;
console.log(hello)
</code></pre>
<p>编译文件后：</p>
<pre><code class="tsx">const hello = &quot;Hello World!&quot;
console.log(hello)
</code></pre>
<h4 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h4><p><code>typescript</code>的特性主要有如下：</p>
<ul>
<li>类型批注和编译时类型检查 ：在编译时批注变量类型</li>
<li>类型推断：ts中没有批注变量类型会自动推断变量的类型</li>
<li>类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除</li>
<li>接口：ts中用接口来定义对象类型</li>
<li>枚举：用于取值被限定在一定范围内的场景</li>
<li>Mixin：可以接受任意类型的值</li>
<li>泛型编程：写代码时使用一些以后才指定的类型</li>
<li>名字空间：名字只在该区域内有效，其他区域可重复使用该名字而不冲突</li>
<li>元组：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li>
<li>…</li>
</ul>
<h5 id="类型批注"><a href="#类型批注" class="headerlink" title="类型批注"></a>类型批注</h5><p>通过类型批注提供在编译时启动类型检查的静态类型，这是可选的，而且可以忽略而使用<code>JavaScript</code>常规的动态类型</p>
<pre><code class="tsx">function Add(left: number, right: number): number &#123;
 return left + right;
&#125;
</code></pre>
<p>对于基本类型的批注是<code>number</code>、<code>bool</code>和<code>string</code>，而弱或动态类型的结构则是<code>any</code>类型</p>
<h5 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h5><p>当类型没有给出时，TypeScript编译器利用类型推断来推断类型，如下：</p>
<pre><code class="tsx">let str = &#39;string&#39;
</code></pre>
<p>变量<code>str</code>被推断为字符串类型，这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</p>
<p>如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态<code>any</code>类型</p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口简单来说就是用来描述对象的类型 数据的类型有<code>number</code>、<code> null</code>、<code> string</code>等数据格式，对象的类型就是用接口来描述的</p>
<pre><code class="tsx">interface Person &#123;
    name: string;
    age: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25
&#125;;
</code></pre>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><ul>
<li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li>
<li>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译</li>
<li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li>
<li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件</li>
</ul>
<p>更多的区别如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36623534343034302d303935302d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-typescript-的数据类型有哪些"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-typescript-的数据类型有哪些" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ typescript 的数据类型有哪些?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ typescript 的数据类型有哪些?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>typescript</code> 和 <code>javascript</code>几乎一样，拥有相同的数据类型，另外在<code>javascript</code>基础上提供了更加实用的类型供开发使用</p>
<p>在开发阶段，可以为明确的变量定义为某种类型，这样<code>typescript</code>就能在编译阶段进行类型检查，当类型不合符预期结果的时候则会出现错误提示</p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p><code>typescript</code> 的数据类型主要有如下：</p>
<ul>
<li>boolean（布尔类型）</li>
<li>number（数字类型）</li>
<li>string（字符串类型）</li>
<li>array（数组类型）</li>
<li>tuple（元组类型）</li>
<li>enum（枚举类型）</li>
<li>any（任意类型）</li>
<li>null 和 undefined 类型</li>
<li>Symbol 类型</li>
<li>bigint类型</li>
<li>void 类型</li>
<li>never 类型</li>
<li>object 对象类型</li>
<li>unknown</li>
</ul>
<h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><p>布尔类型</p>
<pre><code class="tsx">let flag:boolean = true;
// flag = 123; // 错误
flag = false;  //正确
</code></pre>
<h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><p>数字类型，和<code>javascript</code>一样，<code>typescript</code>的数值类型都是浮点数，可支持二进制、八进制、十进制和十六进制</p>
<pre><code class="tsx">let num:number = 123;
// num = &#39;456&#39;; // 错误
num = 456;  //正确
</code></pre>
<p>进制表示：</p>
<pre><code class="tsx">let decLiteral: number = 6; // 十进制
let hexLiteral: number = 0xf00d; // 十六进制
let binaryLiteral: number = 0b1010; // 二进制
let octalLiteral: number = 0o744; // 八进制
</code></pre>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>字符串类型，和<code>JavaScript</code>一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串</p>
<pre><code class="tsx">let str:string = &#39;this is ts&#39;;
str = &#39;test&#39;;
</code></pre>
<p>作为超集，当然也可以使用模版字符串&#96;&#96;进行包裹，通过 ${} 嵌入变量</p>
<pre><code class="tsx">let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is $&#123; name &#125;
</code></pre>
<h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>数组类型，跟<code>javascript</code>一致，通过<code>[]</code>进行包裹，有两种写法：</p>
<p>方式一：元素类型后面接上 <code>[]</code></p>
<pre><code class="tsx"> let arr:string[] = [&#39;12&#39;, &#39;23&#39;];
 arr = [&#39;45&#39;, &#39;56&#39;];
</code></pre>
<p>方式二：使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<pre><code class="tsx">let arr:Array&lt;number&gt; = [1, 2];
arr = [&#39;45&#39;, &#39;56&#39;];
</code></pre>
<h5 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h5><p>元祖类型，允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p>
<pre><code class="tsx">let tupleArr:[number, string, boolean];
tupleArr = [12, &#39;34&#39;, true]; //ok
typleArr = [12, &#39;34&#39;] // no ok
</code></pre>
<p>赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致</p>
<h5 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h5><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p>
<pre><code class="tsx">enum Color &#123;Red, Green, Blue&#125;
let c: Color = Color.Green;
</code></pre>
<h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><p>可以指定任何类型的值，在编程阶段还不清楚类型的变量指定一个类型，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，这时候可以使用<code>any</code>类型</p>
<p>使用<code>any</code>类型允许被赋值为任意类型，甚至可以调用其属性、方法</p>
<pre><code class="tsx">let num:any = 123;
num = &#39;str&#39;;
num = true;
</code></pre>
<p>定义存储各种类型数据的数组时，示例代码如下：</p>
<pre><code class="tsx">let arrayList: any[] = [1, false, &#39;fine&#39;];
arrayList[1] = 100;
</code></pre>
<h5 id="null-和-和-undefined"><a href="#null-和-和-undefined" class="headerlink" title="null 和 和 undefined"></a>null 和 和 undefined</h5><p>在<code> JavaScript</code> 中 <code>null </code>表示 “什么都没有”，是一个只有一个值的特殊类型，表示一个空对象引用，而<code>undefined</code>表示一个没有设置值的变量</p>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型， 就是说你可以把 <code>null </code>和 <code>undefined </code>赋值给 <code>number </code>类型的变量</p>
<pre><code class="tsx">let num:number | undefined; // 数值类型 或者 undefined
console.log(num); // 正确
num = 123;
console.log(num); // 正确
</code></pre>
<p>但是<code>ts</code>配置了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自</p>
<h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><p>用于标识方法返回值的类型，表示该方法没有返回值。</p>
<pre><code class="tsx">function hello(): void &#123;
    alert(&quot;Hello Runoob&quot;);
&#125;
</code></pre>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>symbol我们平时用的比较少，所以可能了解也不是很多，这里就详细来说说symbol。</p>
<h6 id="（1）symbol-基本使用"><a href="#（1）symbol-基本使用" class="headerlink" title="（1）symbol 基本使用"></a>（1）symbol 基本使用</h6><p>symbol 是 ES6 新增的一种基本数据类型，它用来表示独一无二的值，可以通过 Symbol 构造函数生成。</p>
<pre><code class="typescript">const s = Symbol(); 
typeof s; // symbol
</code></pre>
<p>注意：Symbol 前面不能加 new关键字，直接调用即可创建一个独一无二的 symbol 类型的值。</p>
<p>可以在使用 Symbol 方法创建 symbol 类型值的时候传入一个参数，这个参数需要是一个字符串。如果传入的参数不是字符串，会先自动调用传入参数的 toString 方法转为字符串：</p>
<pre><code class="typescript">const s1 = Symbol(&quot;TypeScript&quot;); 
const s2 = Symbol(&quot;Typescript&quot;); 
console.log(s1 === s2); // false
</code></pre>
<p>上面代码的第三行可能会报一个错误：This condition will always return ‘false’ since the types ‘unique symbol’ and ‘unique symbol’ have no overlap. 这是因为编译器检测到这里的 s1 &#x3D;&#x3D;&#x3D; s2 始终是false，所以编译器提醒这代码写的多余，建议进行优化。</p>
<p>上面使用Symbol创建了两个symbol对象，方法中都传入了相同的字符串，但是两个symbol值仍然是false，这就说明了 Symbol 方法会返回一个独一无二的值。Symbol 方法传入的这个字符串，就是方便我们区分 symbol 值的。可以调用 symbol 值的 toString 方法将它转为字符串：</p>
<pre><code class="typescript">const s1 = Symbol(&quot;Typescript&quot;); 
console.log(s1.toString());  // &#39;Symbol(Typescript)&#39;
console.log(Boolean(s));     // true 
console.log(!s);             // false
</code></pre>
<p>在TypeScript中使用symbol就是指定一个值的类型为symbol类型：</p>
<pre><code class="typescript">let a: symbol = Symbol()
</code></pre>
<p>TypeScript 中还有一个 unique symbol 类型，它是symbol的子类型，这种类型的值只能由<code>Symbol()</code>或<code>Symbol.for()</code>创建，或者通过指定类型来指定变量是这种类型。这种类型的值只能用于常量的定义和用于属性名。需要注意，定义unique symbol类型的值，必须用 const 而不能用let来声明。下面来看在TypeScript中使用Symbol值作为属性名的例子：</p>
<pre><code class="typescript">const key1: unique symbol = Symbol()
let key2: symbol = Symbol()
const obj = &#123;
    [key1]: &#39;value1&#39;,
    [key2]: &#39;value2&#39;
&#125;
console.log(obj[key1]) // value1
console.log(obj[key2]) // error 类型“symbol”不能作为索引类型使用。
</code></pre>
<h6 id="（2）symbol-作为属性名"><a href="#（2）symbol-作为属性名" class="headerlink" title="（2）symbol 作为属性名"></a>（2）symbol 作为属性名</h6><p>在ES6中，对象的属性是支持表达式的，可以使用于一个变量来作为属性名，这对于代码的简化有很多用处，表达式必须放在大括号内：</p>
<pre><code class="typescript">let prop = &quot;name&quot;; 
const obj = &#123; 
  [prop]: &quot;TypeScript&quot; 
&#125;;
console.log(obj.name); // &#39;TypeScript&#39;
</code></pre>
<p>symbol 也可以作为属性名，因为symbol的值是独一无二的，所以当它作为属性名时，不会与其他任何属性名重复。当需要访问这个属性时，只能使用这个symbol值来访问（必须使用方括号形式来访问）：</p>
<pre><code class="typescript">let name = Symbol(); 
let obj = &#123; 
  [name]: &quot;TypeScript&quot; 
&#125;;
console.log(obj); // &#123; Symbol(): &#39;TypeScript&#39; &#125;
console.log(obj[name]); // &#39;TypeScript&#39; 
console.log(obj.name);  // undefined
</code></pre>
<p>在使用obj.name访问时，实际上是字符串name，这和访问普通字符串类型的属性名是一样的，要想访问属性名为symbol类型的属性时，必须使用方括号。方括号中的name才是我们定义的symbol类型的变量name。</p>
<h6 id="（3）symbol-属性名遍历"><a href="#（3）symbol-属性名遍历" class="headerlink" title="（3）symbol 属性名遍历"></a>（3）symbol 属性名遍历</h6><p>使用 Symbol 类型值作为属性名，这个属性是不会被 for…in遍历到的，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 、 JSON.stringify() 等方法获取到：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
for (const key in obj) &#123; 
  console.log(key); 
&#125;  
// =&gt; &#39;age&#39; 
console.log(Object.keys(obj));  // [&#39;age&#39;] 
console.log(Object.getOwnPropertyNames(obj));  // [&#39;age&#39;] 
console.log(JSON.stringify(obj)); // &#39;&#123; &quot;age&quot;: 18 &#125;
</code></pre>
<p>虽然这些方法都不能访问到Symbol类型的属性名，但是Symbol类型的属性并不是私有属性，可以使用 <code>Object.getOwnPropertySymbols</code> 方法获取对象的所有symbol类型的属性名：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
const SymbolPropNames = Object.getOwnPropertySymbols(obj); 
console.log(SymbolPropNames); // [ Symbol(name) ] 
console.log(obj[SymbolPropNames[0]]); // &#39;TypeScript&#39; 
</code></pre>
<p>除了这个方法，还可以使用ES6提供的 Reflect 对象的静态方法 Reflect.ownKeys ，它可以返回所有类型的属性名，Symbol 类型的也会返回：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
console.log(Reflect.ownKeys(obj)); // [ &#39;age&#39;, Symbol(name) ]
</code></pre>
<h6 id="（4）symbol-静态方法"><a href="#（4）symbol-静态方法" class="headerlink" title="（4）symbol 静态方法"></a>（4）symbol 静态方法</h6><p>Symbol 包含两个静态方法， for 和 keyFor 。</p>
<p>1）Symbol.for()</p>
<p>用Symbol创建的symbol类型的值都是独一无二的。使用 Symbol.for 方法传入字符串，会先检查有没有使用该字符串调用 Symbol.for 方法创建的 symbol 值。如果有，返回该值；如果没有，则使用该字符串新创建一个。使用该方法创建 symbol 值后会在全局范围进行注册。</p>
<pre><code class="typescript">const iframe = document.createElement(&quot;iframe&quot;); 
iframe.src = String(window.location); 
document.body.appendChild(iframe); 

iframe.contentWindow.Symbol.for(&quot;TypeScript&quot;) === Symbol.for(&quot;TypeScript&quot;); // true // 注意：如果你在JavaScript环境中这段代码是没有问题的，但是如果在TypeScript开发环境中，可能会报错：类型“Window”上不存在属性“Symbol”。 // 因为这里编译器推断出iframe.contentWindow是Window类型，但是TypeScript的声明文件中，对Window的定义缺少Symbol这个字段，所以会报错，
</code></pre>
<p>上面代码中，创建了一个iframe节点并把它放在body中，通过这个 iframe 对象的 contentWindow 拿到这个 iframe 的 window 对象，在 iframe.contentWindow上添加一个值就相当于在当前页面定义一个全局变量一样。可以看到，在 iframe 中定义的键为 TypeScript 的 symbol 值在和在当前页面定义的键为’TypeScript’的symbol 值相等，说明它们是同一个值。</p>
<p>2）Symbol.keyFor()</p>
<p>该方法传入一个 symbol 值，返回该值在全局注册的键名：</p>
<pre><code class="typescript">const sym = Symbol.for(&quot;TypeScript&quot;); 
console.log(Symbol.keyFor(sym)); // &#39;TypeScript&#39;
</code></pre>
<h5 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h5><p>BigInt是ES6中新引入的数据类型，它是一种内置对象，它提供了一种方法来表示大于 2- 1 的整数，BigInt可以表示任意大的整数。</p>
<p>使用 <code>BigInt</code> 可以安全地存储和操作大整数，即使这个数已经超出了JavaScript构造函数 Number 能够表示的安全整数范围。</p>
<p>我们知道，在 JavaScript 中采用双精度浮点数，这导致精度有限，比如 <code>Number.MAX_SAFE_INTEGER</code> 给出了可以安全递增的最大可能整数，即<code>2- 1</code>，来看一个例子:</p>
<pre><code class="typescript">const max = Number.MAX_SAFE_INTEGER;
const max1 = max + 1
const max2 = max + 2
max1 === max2     // true
</code></pre>
<p>可以看到，最终返回了true，这就是超过精读范围造成的问题，而<code>BigInt</code>正是解决这类问题而生的:</p>
<pre><code class="typescript">const max = BigInt(Number.MAX_SAFE_INTEGER);
const max1 = max + 1n
const max2 = max + 2n
max1 === max2    // false
</code></pre>
<p>这里需要用 <code>BigInt(number)</code> 把 Number 转化为 <code>BigInt</code>，同时如果类型是 <code>BigInt</code> ，那么数字后面需要加 <code>n</code>。</p>
<p>在TypeScript中，<code>number</code> 类型虽然和 <code>BigInt</code> 都表示数字，但是实际上两者类型是完全不同的:</p>
<pre><code class="typescript">declare let foo: number;
declare let bar: bigint;
foo = bar; // error: Type &#39;bigint&#39; is not assignable to type &#39;number&#39;.
bar = foo; // error: Type &#39;number&#39; is not assignable to type &#39;bigint&#39;.
</code></pre>
<h5 id="never"><a href="#never" class="headerlink" title="never"></a>never</h5><p><code>never</code>是其他类型 （包括<code>null</code>和 <code>undefined</code>）的子类型，可以赋值给任何类型，代表从不会出现的值</p>
<p>但是没有类型是 never 的子类型，这意味着声明 <code>never</code> 的变量只能被 <code>never</code> 类型所赋值。</p>
<p><code>never</code> 类型一般用来指定那些总是会抛出异常、无限循环</p>
<pre><code class="tsx">let a:never;
a = 123; // 错误的写法

a = (() =&gt; &#123; // 正确的写法
  throw new Error(&#39;错误&#39;);
&#125;)()

// 返回never的函数必须存在无法达到的终点
function error(message: string): never &#123;
    throw new Error(message);
&#125;
</code></pre>
<h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><p>对象类型，非原始类型，常见的形式通过<code>&#123;&#125;</code>进行包裹</p>
<pre><code class="tsx">let obj:object;
obj = &#123;name: &#39;Wang&#39;, age: 25&#125;;
</code></pre>
<h5 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h5><p>unknown 是TypeScript在3.0版本新增的类型，主要用来描述类型并不确定的变量。它看起来和any很像，但是还是有区别的，unknown相对于any更安全。</p>
<p>对于any，来看一个例子：</p>
<pre><code class="typescript">let value: any
console.log(value.name)
console.log(value.toFixed())
console.log(value.length)
</code></pre>
<p>上面这些语句都不会报错，因为value是any类型，所以后面三个操作都有合法的情况，当value是一个对象时，访问name属性是没问题的；当value是数值类型的时候，调用它的toFixed方法没问题；当value是字符串或数组时获取它的length属性是没问题的。</p>
<p>当指定值为unknown类型的时候，如果没有缩小类型范围的话，是不能对它进行任何操作的。总之，unknown类型的值不能随便操作。那什么是类型范围缩小呢？下面来看一个例子：</p>
<pre><code class="typescript">function getValue(value: unknown): string &#123;
  if (value instanceof Date) &#123; 
    return value.toISOString();
  &#125;
  return String(value);
&#125;
</code></pre>
<p>这里由于把value的类型缩小为Date实例的范围内，所以进行了value.toISOString()，也就是使用ISO标准将 Date 对象转换为字符串。</p>
<p>使用以下方式也可以缩小类型范围：</p>
<pre><code class="typescript">let result: unknown;
if (typeof result === &#39;number&#39;) &#123;
  result.toFixed();
&#125;
</code></pre>
<p>关于 unknown 类型，在使用时需要注意以下几点：</p>
<ul>
<li>任何类型的值都可以赋值给 unknown 类型：</li>
</ul>
<pre><code class="typescript">let value1: unknown;
value1 = &quot;a&quot;;
value1 = 123;
</code></pre>
<ul>
<li>unknown 不可以赋值给其它类型，只能赋值给 unknown 和 any 类型：</li>
</ul>
<pre><code class="typescript">let value2: unknown;
let value3: string = value2; // error 不能将类型“unknown”分配给类型“string”
value1 = value2;
</code></pre>
<ul>
<li>unknown 类型的值不能进行任何操作：</li>
</ul>
<pre><code class="typescript">let value4: unknown;
value4 += 1; // error 对象的类型为 &quot;unknown&quot;
</code></pre>
<ul>
<li>只能对 unknown 进行等或不等操作，不能进行其它操作：</li>
</ul>
<pre><code class="typescript">value1 === value2;
value1 !== value2;
value1 += value2;  // error
</code></pre>
<ul>
<li>unknown 类型的值不能访问其属性、作为函数调用和作为类创建实例：</li>
</ul>
<pre><code class="typescript">let value5: unknown;
value5.age;   // error
value5();     // error
new value5(); // error
</code></pre>
<p>在实际使用中，如果有类型无法确定的情况，要尽量避免使用 any，因为 any 会丢失类型信息，一旦一个类型被指定为 any，那么在它上面进行任何操作都是合法的，所以会有意想不到的情况发生。因此如果遇到无法确定类型的情况，要先考虑使用 unknown。</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>和<code>javascript</code>基本一致，也分成：</p>
<ul>
<li>基本类型</li>
<li>引用类型</li>
</ul>
<p>在基础类型上，<code>typescript</code>增添了<code>void</code>、<code>any</code>、<code>emum</code>等原始类型</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-TypeScript-中枚举类型的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-TypeScript-中枚举类型的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ TypeScript 中枚举类型的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ TypeScript 中枚举类型的理解？应用场景？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型</p>
<p>通俗来说，枚举就是一个对象的所有可能取值的集合</p>
<p>在日常生活中也很常见，例如表示星期的SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY就可以看成是一个枚举</p>
<p>枚举的说明与结构和联合相似，其形式为：</p>
<pre><code class="ini">enum 枚举名&#123;
    标识符①[=整型常数],
    标识符②[=整型常数],
    ...
    标识符N[=整型常数],
&#125;枚举变量;
</code></pre>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>枚举的使用是通过<code>enum</code>关键字进行定义，形式如下：</p>
<pre><code class="tsx">enum xxx &#123; ... &#125;
</code></pre>
<p>声明关键字为枚举类型的方式如下：</p>
<pre><code class="tsx">// 声明d为枚举类型Direction
let d: Direction;
</code></pre>
<p>类型可以分成：</p>
<ul>
<li>数字枚举</li>
<li>字符串枚举</li>
<li>异构枚举</li>
</ul>
<h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><p>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加:</p>
<pre><code class="tsx">enum Direction &#123;
    Up,   // 值默认为 0
    Down, // 值默认为 1
    Left, // 值默认为 2
    Right // 值默认为 3
&#125;

console.log(Direction.Up === 0); // true
console.log(Direction.Down === 1); // true
console.log(Direction.Left === 2); // true
console.log(Direction.Right === 3); // true
</code></pre>
<p>如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加1：</p>
<pre><code class="tsx">enum Direction &#123;
    Up = 10,
    Down,
    Left,
    Right
&#125;

console.log(Direction.Up, Direction.Down, Direction.Left, Direction.Right); // 10 11 12 13
</code></pre>
<h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><pre><code class="tsx">枚举类型的值其实也可以是字符串类型：

enum Direction &#123;
    Up = &#39;Up&#39;,
    Down = &#39;Down&#39;,
    Left = &#39;Left&#39;,
    Right = &#39;Right&#39;
&#125;

console.log(Direction[&#39;Right&#39;], Direction.Up); // Right Up
</code></pre>
<p>如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：</p>
<pre><code class="tsx">enum Direction &#123;
 Up = &#39;UP&#39;,
 Down, // error TS1061: Enum member must have initializer
 Left, // error TS1061: Enum member must have initializer
 Right // error TS1061: Enum member must have initializer
&#125;
</code></pre>
<h4 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h4><p>即将数字枚举和字符串枚举结合起来混合起来使用，如下：</p>
<pre><code class="tsx">enum BooleanLikeHeterogeneousEnum &#123;
    No = 0,
    Yes = &quot;YES&quot;,
&#125;
</code></pre>
<p>通常情况下我们很少会使用异构枚举</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>现在一个枚举的案例如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up,
    Down,
    Left,
    Right
&#125;
</code></pre>
<p>通过编译后，<code>javascript</code>如下：</p>
<pre><code class="tsx">var Direction;
(function (Direction) &#123;
    Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;;
    Direction[Direction[&quot;Down&quot;] = 1] = &quot;Down&quot;;
    Direction[Direction[&quot;Left&quot;] = 2] = &quot;Left&quot;;
    Direction[Direction[&quot;Right&quot;] = 3] = &quot;Right&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
</code></pre>
<p>上述代码可以看到， <code>Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;</code>可以分成</p>
<ul>
<li>Direction[“Up”] &#x3D; 0</li>
<li>Direction[0] &#x3D; “Up”</li>
</ul>
<p>所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up,
    Down,
    Left,
    Right
&#125;

console.log(Direction.Up === 0); // true
console.log(Direction[0]); // Up
</code></pre>
<p>并且多处定义的枚举是可以进行合并操作，如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up = &#39;Up&#39;,
    Down = &#39;Down&#39;,
    Left = &#39;Left&#39;,
    Right = &#39;Right&#39;
&#125;

enum Direction &#123;
    Center = 1
&#125;
</code></pre>
<p>编译后，<code>js</code>代码如下：</p>
<pre><code class="tsx">var Direction;
(function (Direction) &#123;
    Direction[&quot;Up&quot;] = &quot;Up&quot;;
    Direction[&quot;Down&quot;] = &quot;Down&quot;;
    Direction[&quot;Left&quot;] = &quot;Left&quot;;
    Direction[&quot;Right&quot;] = &quot;Right&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
(function (Direction) &#123;
    Direction[Direction[&quot;Center&quot;] = 1] = &quot;Center&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
</code></pre>
<p>可以看到，<code>Direction</code>对象属性回叠加</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：</p>
<pre><code class="tsx">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;

console.log(Days[&quot;Sun&quot;] === 0); // true
console.log(Days[&quot;Mon&quot;] === 1); // true
console.log(Days[&quot;Tue&quot;] === 2); // true
console.log(Days[&quot;Sat&quot;] === 6); // true
</code></pre>
<p>包括后端日常返回0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中接口的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中接口的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中接口的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中接口的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法</p>
<p>简单来讲，一个接口所描述的是一个对象相关的属性和方法，但并不提供具体创建此对象实例的方法</p>
<p><code>typescript</code>的核心功能之一就是对类型做检测，虽然这种检测方式是“鸭式辨型法”，而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定</p>
<h4 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>接口定义如下：</p>
<pre><code class="tsx">interface interface_name &#123;
&#125;
</code></pre>
<p>例如有一个函数，这个函数接受一个 <code>User</code> 对象，然后返回这个 <code>User</code> 对象的 <code>name</code> 属性:</p>
<pre><code class="tsx">const getUserName = (user) =&gt; user.name
</code></pre>
<p>可以看到，参数需要有一个<code>user</code>的<code>name</code>属性，可以通过接口描述<code>user</code>参数的结构</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
&#125;

const getUserName = (user: User) =&gt; user.name
</code></pre>
<p>这些属性并不一定全部实现，上述传入的对象必须拥有<code>name</code>和<code>age</code>属性，否则<code>typescript</code>在编译阶段会报错，如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32356433613739302d306232622d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>如果不想要<code>age</code>属性的话，这时候可以采用可选属性，如下表示：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
&#125;
</code></pre>
<p>这时候<code>age</code>属性则可以是<code>number</code>类型或者<code>undefined</code>类型</p>
<p>有些时候，我们想要一个属性变成只读属性，在<code>typescript</code>只需要使用<code>readonly</code>声明，如下：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
    readonly isMale: boolean
&#125;
</code></pre>
<p>当我们修改属性的时候，就会出现警告，如下所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32663664336333302d306232622d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>这是属性中有一个函数，可以如下表示：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
    readonly isMale: boolean
    say: (words: string) =&gt; string
&#125;
</code></pre>
<p>如果传递的对象不仅仅是上述的属性，这时候可以使用：</p>
<ul>
<li>类型推断</li>
</ul>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
&#125;

const getUserName = (user: User) =&gt; user.name
getUserName(&#123;color: &#39;yellow&#39;&#125; as User)
</code></pre>
<ul>
<li>给接口添加字符串索引签名</li>
</ul>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
    [propName: string]: any;
&#125;
</code></pre>
<p>接口还能实现继承，如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33386134313736302d306232622d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>也可以继承多个，父类通过逗号隔开，如下：</p>
<pre><code class="tsx">interface Father &#123;
    color: String
&#125;

interface Mother &#123;
    height: Number
&#125;

interface Son extends Father,Mother&#123;
    name: string
    age: Number
&#125;
</code></pre>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>例如在<code>javascript</code>中定义一个函数，用来获取用户的姓名和年龄：</p>
<pre><code class="tsx">const getUserInfo = function(user) &#123;
    // ...
    return name: $&#123;user.name&#125;, age: $&#123;user.age&#125;
&#125;
</code></pre>
<p>如果多人开发的都需要用到这个函数的时候，如果没有注释，则可能出现各种运行时的错误，这时候就可以使用接口定义参数变量：</p>
<pre><code class="tsx">// 先定义一个接口
interface IUser &#123;
  name: string;
  age: number;
&#125;

const getUserInfo = (user: IUser): string =&gt; &#123;
  return `name: $&#123;user.name&#125;, age: $&#123;user.age&#125;`;
&#125;;

// 正确的调用
getUserInfo(&#123;name: &quot;koala&quot;, age: 18&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中类的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中类的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中类的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中类的理解？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>
<blockquote>
<p>类是一种用户定义的引用数据类型，也称类类型</p>
</blockquote>
<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本</p>
<p>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多</p>
<p>但是<code> JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类</p>
<p><code>TypeScript</code> 的 <code>class</code> 支持面向对象的所有特性，比如 类、接口等</p>
<h4 id="二、使用方式-1"><a href="#二、使用方式-1" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p>
<ul>
<li>字段： 字段是类里面声明的变量。字段表示对象的有关数据。</li>
<li>构造函数： 类实例化时调用，可以为类的对象分配内存。</li>
<li>方法： 方法为对象要执行的操作</li>
</ul>
<p>如下例子：</p>
<pre><code class="tsx">class Car &#123;
    // 字段
    engine:string;

    // 构造函数
    constructor(engine:string) &#123;
        this.engine = engine
    &#125;

    // 方法
    disp():void &#123;
        console.log(&quot;发动机为 :   &quot;+this.engine)
    &#125;
&#125;
</code></pre>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>类的继承使用过<code>extends</code>的关键字</p>
<pre><code class="tsx">class Animal &#123;
    move(distanceInMeters: number = 0) &#123;
        console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);
    &#125;
&#125;

class Dog extends Animal &#123;
    bark() &#123;
        console.log(&#39;Woof! Woof!&#39;);
    &#125;
&#125;

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
</code></pre>
<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 超类</p>
<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法</p>
<p>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写，通过<code>super</code>关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>
<pre><code class="tsx">class PrinterClass &#123;
   doPrint():void &#123;
      console.log(&quot;父类的 doPrint() 方法。&quot;)
   &#125;
&#125;

class StringPrinter extends PrinterClass &#123;
   doPrint():void &#123;
      super.doPrint() // 调用父类的函数
      console.log(&quot;子类的 doPrint()方法。&quot;)
   &#125;
&#125;
</code></pre>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>可以看到，上述的形式跟<code>ES6</code>十分的相似，<code>typescript</code>在此基础上添加了三种修饰符：</p>
<ul>
<li>公共 public：可以自由的访问类程序里定义的成员</li>
<li>私有 private：只能够在该类的内部进行访问</li>
<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>
</ul>
<h6 id="私有修饰符"><a href="#私有修饰符" class="headerlink" title="私有修饰符"></a>私有修饰符</h6><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66353733363566302d306362342d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>并且继承该类的子类并不能访问，如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30303732636332302d306362352d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h6 id="受保护修饰符"><a href="#受保护修饰符" class="headerlink" title="受保护修饰符"></a>受保护修饰符</h6><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30396537323538302d306362352d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31333766383161302d306362352d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>除了上述修饰符之外，还有只读修饰符</p>
<h6 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h6><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/f0885f89e9d2d9bc7aa7acd9b815cd6f447ab2ed9d3a5c4df4ccd6974599bf53/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31653834386432302d306362352d313165632d386536342d3931666465633066303561312e706e67"><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31653834386432302d306362352d313165632d386536342d3931666465633066303561312e706e67.png" alt="img"></a></p>
<p>除了实例属性之外，同样存在静态属性</p>
<h6 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h6><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示：</p>
<pre><code class="tsx">class Square &#123;
    static width = &#39;100px&#39;
&#125;

console.log(Square.width) // 100px
</code></pre>
<p>上述的类都能发现一个特点就是，都能够被实例化，在 <code>typescript</code>中，还存在一种抽象类</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节</p>
<p><code>abstract </code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>
<pre><code class="tsx">abstract class Animal &#123;
    abstract makeSound(): void;
    move(): void &#123;
        console.log(&#39;roaming the earch...&#39;);
    &#125;
&#125;
</code></pre>
<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>
<pre><code class="tsx">class Cat extends Animal &#123;

    makeSound() &#123;
        console.log(&#39;miao miao&#39;)
    &#125;
&#125;

const cat = new Cat()

cat.makeSound() // miao miao
cat.move() // roaming the earch...
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在 <code>React</code> 工程中是很常用的，如下：</p>
<pre><code class="tsx">export default class Carousel extends React.Component&lt;Props, State&gt; &#123;&#125;
</code></pre>
<p>由于组件需要传入 <code>props</code> 的类型 <code>Props</code> ，同时有需要设置默认 <code>props</code> 即 <code>defaultProps</code>，这时候更加适合使用<code>class</code>作为接口</p>
<p>先声明一个类，这个类包含组件 <code>props</code> 所需的类型和初始值：</p>
<pre><code class="tsx">// props的类型
export default class Props &#123;
  public children: Array&lt;React.ReactElement&lt;any&gt;&gt; | React.ReactElement&lt;any&gt; | never[] = []
  public speed: number = 500
  public height: number = 160
  public animation: string = &#39;easeInOutQuad&#39;
  public isAuto: boolean = true
  public autoPlayInterval: number = 4500
  public afterChange: () =&gt; &#123;&#125;
  public beforeChange: () =&gt; &#123;&#125;
  public selesctedColor: string
  public showDots: boolean = true
&#125;
</code></pre>
<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>
<pre><code class="tsx">public static defaultProps = new Props()
</code></pre>
<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class </code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中函数的理解？与-JavaScript-函数的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中函数的理解？与-JavaScript-函数的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中函数的理解？与 JavaScript 函数的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>函数是<code> JavaScript</code> 应用程序的基础，帮助我们实现抽象层、模拟类、信息隐藏和模块</p>
<p>在<code> TypeScript</code> 里，虽然已经支持类、命名空间和模块，但函数仍然是主要定义行为的方式，<code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，丰富了更多的应用场景</p>
<p>函数类型在 <code>TypeScript</code> 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块</p>
<h4 id="二、使用方式-2"><a href="#二、使用方式-2" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>跟<code>javascript</code> 定义函数十分相似，可以通过<code>funciton</code> 关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>
<pre><code class="tsx">const add = (a: number, b: number) =&gt; a + b
</code></pre>
<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上<code> TypeScript</code> 编译器是能够通过类型推断到这个函数的类型，如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34623334313562302d306434322d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>当鼠标放置在第三行<code>add</code>函数名的时候，会出现完整的函数定义类型，通过<code>:</code> 的形式来定于参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>
<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>
<pre><code class="tsx">// 方式一
type LongHand = &#123;
  (a: number): number;
&#125;;

// 方式二
type ShortHand = (a: number) =&gt; number;
</code></pre>
<p>当存在函数重载时，只能使用方式一的形式</p>
<h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>
<pre><code class="tsx">const add = (a: number, b?: number) =&gt; a + (b ? b : 0)
</code></pre>
<p>这时候参数<code>b</code>可以是<code>number</code>类型或者<code>undefined</code>类型，即可以传一个<code>number</code>类型或者不传都可以</p>
<h5 id="剩余类型"><a href="#剩余类型" class="headerlink" title="剩余类型"></a>剩余类型</h5><p>剩余参数与<code>JavaScript</code>的语法类似，需要用 <code>...</code> 来表示剩余参数</p>
<p>如果剩余参数 <code>rest</code> 是一个由<code>number</code>类型组成的数组，则如下表示：</p>
<pre><code class="tsx">const add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a)
</code></pre>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>
<p>关于<code>typescript</code>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|</code>操作符或者<code>?</code>操作符，把所有可能的输入类型全部包含进去，用于具体实现</p>
<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，<code>typescript</code>并不会真的将你的多个重名 <code>function </code>的函数体进行合并</p>
<p>例如我们有一个add函数，它可以接收 <code>string</code>类型的参数进行拼接，也可以接收 <code>number</code> 类型的参数进行相加，如下：</p>
<pre><code class="tsx">// 上边是声明
function add (arg1: string, arg2: string): string
function add (arg1: number, arg2: number): number
// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字

// 下边是实现
function add (arg1: string | number, arg2: string | number) &#123;
  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2
  if (typeof arg1 === &#39;string&#39; &amp;&amp; typeof arg2 === &#39;string&#39;) &#123;
    return arg1 + arg2
  &#125; else if (typeof arg1 === &#39;number&#39; &amp;&amp; typeof arg2 === &#39;number&#39;) &#123;
    return arg1 + arg2
  &#125;
&#125;
</code></pre>
<h4 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h4><p>从上面可以看到：</p>
<ul>
<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>
<li>typescript 在参数中，添加可选参数供使用者选择</li>
<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中泛型的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中泛型的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中泛型的理解？应用场景？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p>
<p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型<br>在<code>typescript</code>中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性</p>
<p>假设我们用一个函数，它可接受一个 <code>number</code> 参数并返回一个<code> number</code> 参数，如下写法：</p>
<pre><code class="tsx">function returnItem (para: number): number &#123;
    return para
&#125;
</code></pre>
<p>如果我们打算接受一个 <code>string</code> 类型，然后再返回 <code>string</code>类型，则如下写法：</p>
<pre><code class="tsx">function returnItem (para: string): string &#123;
    return para
&#125;
</code></pre>
<p>上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高</p>
<p>虽然可以使用 <code>any</code>类型去替代，但这也并不是很好的方案，因为我们的目的是接收什么类型的参数返回什么类型的参数，即在运行时传入参数我们才能确定类型</p>
<p>这种情况就可以使用泛型，如下所示：</p>
<pre><code class="tsx">function returnItem&lt;T&gt;(para: T): T &#123;
    return para
&#125;
</code></pre>
<p>可以看到，泛型给予开发者创造灵活、可重用代码的能力</p>
<h4 id="二、使用方式-3"><a href="#二、使用方式-3" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明：</p>
<ul>
<li>函数</li>
<li>接口</li>
<li>类</li>
</ul>
<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>声明函数的形式如下：</p>
<pre><code class="tsx">function returnItem&lt;T&gt;(para: T): T &#123;
    return para
&#125;
</code></pre>
<p>定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 <code>T</code> 和 泛型 <code>U</code>：</p>
<pre><code class="tsx">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;
    return [tuple[1], tuple[0]];
&#125;

swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]
</code></pre>
<h5 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h5><p>声明接口的形式如下：</p>
<pre><code class="tsx">interface ReturnItemFn&lt;T&gt; &#123;
    (para: T): T
&#125;
</code></pre>
<p>那么当我们想传入一个number作为参数的时候，就可以这样声明函数:</p>
<pre><code class="tsx">const returnItem: ReturnItemFn&lt;number&gt; = para =&gt; para
</code></pre>
<h5 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h5><p>使用泛型声明类的时候，既可以作用于类本身，也可以作用与类的成员函数</p>
<p>下面简单实现一个元素同类型的栈结构，如下所示：</p>
<pre><code class="tsx">class Stack&lt;T&gt; &#123;
    private arr: T[] = []
    public push(item: T) &#123;
        this.arr.push(item)
    &#125;
    public pop() &#123;
        this.arr.pop()
    &#125;
&#125;
</code></pre>
<p>使用方式如下：</p>
<pre><code class="tsx">const stack = new Stacn&lt;number&gt;()
</code></pre>
<p>如果上述只能传递 <code>string</code> 和 <code>number</code> 类型，这时候就可以使用 <code>&lt;T extends xx&gt;</code> 的方式猜实现约束泛型，如下所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36376432313261302d306531372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>除了上述的形式，泛型更高级的使用如下：</p>
<p>例如要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值</p>
<p>这时候就设计到泛型的索引类型和约束类型共同实现</p>
<h5 id="索引类型、约束类型"><a href="#索引类型、约束类型" class="headerlink" title="索引类型、约束类型"></a>索引类型、约束类型</h5><p>索引类型 <code>keyof T</code> 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，如下所示：</p>
<pre><code class="tsx">function getValue&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) &#123;
  return obj[key] // ok
&#125;
</code></pre>
<p>上述为什么需要使用泛型约束，而不是直接定义第一个参数为 <code>object</code>类型，是因为默认情况 <code>object</code> 指的是<code>&#123;&#125;</code>，而我们接收的对象是各种各样的，一个泛型来表示传入的对象类型，比如 <code>T extends object</code></p>
<p>使用如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37346663626434302d306531372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="多类型约束"><a href="#多类型约束" class="headerlink" title="多类型约束"></a>多类型约束</h5><p>例如如下需要实现两个接口的类型约束：</p>
<pre><code class="tsx">interface FirstInterface &#123;
  doSomething(): number
&#125;

interface SecondInterface &#123;
  doSomethingElse(): string
&#125;
</code></pre>
<p>可以创建一个接口继承上述两个接口，如下：</p>
<pre><code class="tsx">interface ChildInterface extends FirstInterface, SecondInterface &#123;

&#125;
</code></pre>
<p>正确使用如下：</p>
<pre><code class="tsx">class Demo&lt;T extends ChildInterface&gt; &#123;
  private genericProperty: T

  constructor(genericProperty: T) &#123;
    this.genericProperty = genericProperty
  &#125;
  useT() &#123;
    this.genericProperty.doSomething()
    this.genericProperty.doSomethingElse()
  &#125;
&#125;
</code></pre>
<p>通过泛型约束就可以达到多类型约束的目的</p>
<h4 id="三、应用场景-3"><a href="#三、应用场景-3" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>通过上面初步的了解，后述在编写 <code>typescript</code> 的时候，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性的时候，这种情况下就可以使用泛型</p>
<p>灵活的使用泛型定义类型，是掌握<code>typescript</code> 必经之路</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中高级类型的理解？有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中高级类型的理解？有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中高级类型的理解？有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中高级类型的理解？有哪些？</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>除了<code>string</code>、<code>number</code>、<code>boolean</code> 这种基础类型外，在 <code>typescript</code> 类型声明中还存在一些高级的类型应用</p>
<p>这些高级类型，是<code>typescript</code>为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景</p>
<h4 id="二、有哪些-1"><a href="#二、有哪些-1" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的高级类型有如下：</p>
<ul>
<li>交叉类型</li>
<li>联合类型</li>
<li>类型别名</li>
<li>类型索引</li>
<li>类型约束</li>
<li>映射类型</li>
<li>条件类型</li>
</ul>
<h5 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h5><p>通过 <code>&amp;</code> 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作</p>
<p>语法如下：</p>
<pre><code class="ini">T &amp; U
</code></pre>
<p>适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：</p>
<pre><code class="tsx">function extend&lt;T , U&gt;(first: T, second: U) : T &amp; U &#123;
    let result: &lt;T &amp; U&gt; = &#123;&#125;
    for (let key in first) &#123;
        result[key] = first[key]
    &#125;
    for (let key in second) &#123;
        if(!result.hasOwnProperty(key)) &#123;
            result[key] = second[key]
        &#125;
    &#125;
    return result
&#125;
</code></pre>
<h5 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h5><p>联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系</p>
<p>语法如下：</p>
<pre><code class="ini">T | U
</code></pre>
<p>例如 <code>number</code> | <code>string</code> | <code>boolean</code> 的类型只能是这三个的一种，不能共存</p>
<p>如下所示：</p>
<pre><code class="tsx">function formatCommandline(command: string[] | string) &#123;
  let line = &#39;&#39;;
  if (typeof command === &#39;string&#39;) &#123;
    line = command.trim();
  &#125; else &#123;
    line = command.join(&#39; &#39;).trim();
  &#125;
&#125;
</code></pre>
<h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型</p>
<p>可以使用 <code>type SomeName = someValidTypeAnnotation</code>的语法来创建类型别名：</p>
<pre><code class="tsx">type some = boolean | string

const b: some = true // ok
const c: some = &#39;hello&#39; // ok
const d: some = 123 // 不能将类型“123”分配给类型“some”
</code></pre>
<p>此外类型别名可以是泛型:</p>
<pre><code class="tsx">type Container&lt;T&gt; = &#123; value: T &#125;;
</code></pre>
<p>也可以使用类型别名来在属性里引用自己：</p>
<pre><code class="tsx">type Tree&lt;T&gt; = &#123;
    value: T;
    left: Tree&lt;T&gt;;
    right: Tree&lt;T&gt;;
&#125;
</code></pre>
<p>可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数</p>
<p>两者最大的区别在于，<code>interface </code>只能用于定义对象类型，而 <code>type</code> 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛</p>
<h5 id="类型索引"><a href="#类型索引" class="headerlink" title="类型索引"></a>类型索引</h5><p><code>keyof</code> 类似于 <code>Object.keys</code> ，用于获取一个接口中 Key 的联合类型。</p>
<pre><code class="tsx">interface Button &#123;
    type: string
    text: string
&#125;

type ButtonKeys = keyof Button
// 等效于
type ButtonKeys = &quot;type&quot; | &quot;text&quot;
</code></pre>
<h5 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h5><p>通过关键字 <code>extend</code> 进行约束，不同于在 <code>class</code> 后使用 <code>extends</code> 的继承作用，泛型内使用的主要作用是对泛型加以约束</p>
<pre><code class="tsx">type BaseType = string | number | boolean

// 这里表示 copy 的参数
// 只能是字符串、数字、布尔这几种基础类型
function copy&lt;T extends BaseType&gt;(arg: T): T &#123;
  return arg
&#125;
</code></pre>
<p>类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 <code>extends</code> 和 <code>keyof</code> 进行约束。</p>
<pre><code class="tsx">function getValue&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123;
  return obj[key]
&#125;

const obj = &#123; a: 1 &#125;
const a = getValue(obj, &#39;a&#39;)
</code></pre>
<h5 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h5><p>通过 <code>in</code> 关键字做类型的映射，遍历已有接口的 <code>key</code> 或者是遍历联合类型，如下例子：</p>
<pre><code class="tsx">type Readonly&lt;T&gt; = &#123;
    readonly [P in keyof T]: T[P];
&#125;;

interface Obj &#123;
  a: string
  b: string
&#125;

type ReadOnlyObj = Readonly&lt;Obj&gt;
</code></pre>
<p>上述的结构，可以分成这些步骤：</p>
<ul>
<li>keyof T：通过类型索引 keyof 的得到联合类型 ‘a’ | ‘b’</li>
<li>P in keyof T 等同于 p in ‘a’ | ‘b’，相当于执行了一次 forEach 的逻辑，遍历 ‘a’ | ‘b’</li>
</ul>
<p>所以最终<code>ReadOnlyObj</code>的接口为下述：</p>
<pre><code class="tsx">interface ReadOnlyObj &#123;
    readonly a: string;
    readonly b: string;
&#125;
</code></pre>
<h5 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h5><p>条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。</p>
<pre><code class="tsx">T extends U ? X : Y
</code></pre>
<p>上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y</p>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，如果只是掌握了 <code>typeScript</code> 的一些基础类型，可能很难游刃有余的去使用 <code>typeScript</code>，需要了解一些<code>typescript</code>的高阶用法</p>
<p>并且<code>typescript</code>在版本的迭代中新增了很多功能，需要不断学习与掌握</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-装饰器的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-装饰器的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 装饰器的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 装饰器的理解？应用场景？</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上</p>
<p>是一种在不改变原类和使用继承的情况下，动态地扩展对象功能</p>
<p>同样的，本质也不是什么高大上的结构，就是一个普通的函数，<code>@expression</code> 的形式其实是<code>Object.defineProperty</code>的语法糖</p>
<p><code>expression </code>求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p>
<h4 id="二、使用方式-4"><a href="#二、使用方式-4" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>由于<code>typescript</code>是一个实验性特性，若要使用，需要在<code>tsconfig.json</code>文件启动，如下：</p>
<pre><code class="tsx">&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;ES5&quot;,
        &quot;experimentalDecorators&quot;: true
    &#125;
&#125;
</code></pre>
<p><code>typescript</code>装饰器的使用和<code>javascript</code>基本一致</p>
<p>类的装饰器可以装饰：</p>
<ul>
<li>类</li>
<li>方法&#x2F;属性</li>
<li>参数</li>
<li>访问器</li>
</ul>
<h5 id="类装饰"><a href="#类装饰" class="headerlink" title="类装饰"></a>类装饰</h5><p>例如声明一个函数 <code>addAge</code> 去给 Class 的属性 <code>age</code> 添加年龄.</p>
<pre><code class="tsx">function addAge(constructor: Function) &#123;
  constructor.prototype.age = 18;
&#125;

@addAge
class Person&#123;
  name: string;
  age!: number;
  constructor() &#123;
    this.name = &#39;huihui&#39;;
  &#125;
&#125;

let person = new Person();

console.log(person.age); // 18
</code></pre>
<p>上述代码，实际等同于以下形式：</p>
<pre><code class="tsx">Person = addAge(function Person() &#123; ... &#125;);
</code></pre>
<p>上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 <code>constructor.prototype.age</code> 就是在每一个实例化对象上面添加一个 <code>age</code> 属性</p>
<h5 id="方法-x2F-属性装饰"><a href="#方法-x2F-属性装饰" class="headerlink" title="方法&#x2F;属性装饰"></a>方法&#x2F;属性装饰</h5><p>同样，装饰器可以用于修饰类的方法，这时候装饰器函数接收的参数变成了：</p>
<ul>
<li>target：对象的原型</li>
<li>propertyKey：方法的名称</li>
<li>descriptor：方法的属性描述符</li>
</ul>
<p>可以看到，这三个属性实际就是<code>Object.defineProperty</code>的三个参数，如果是类的属性，则没有传递第三个参数</p>
<p>如下例子：</p>
<pre><code class="tsx">// 声明装饰器修饰方法/属性
function method(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;
  console.log(target);
  console.log(&quot;prop &quot; + propertyKey);
  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);
  descriptor.writable = false;
&#125;;

function property(target: any, propertyKey: string) &#123;
  console.log(&quot;target&quot;, target)
  console.log(&quot;propertyKey&quot;, propertyKey)
&#125;

class Person&#123;
 @property
 name: string;
 constructor() &#123;
   this.name = &#39;huihui&#39;;
 &#125;

 @method
 say()&#123;
   return &#39;instance method&#39;;
 &#125;

 @method
 static run()&#123;
   return &#39;static method&#39;;
 &#125;
&#125;

const xmz = new Person();

// 修改实例方法say
xmz.say = function() &#123;
 return &#39;edit&#39;
&#125;
</code></pre>
<p>输出如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65393662633162302d313134642d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h5 id="参数装饰"><a href="#参数装饰" class="headerlink" title="参数装饰"></a>参数装饰</h5><p>接收3个参数，分别是：</p>
<ul>
<li>target ：当前对象的原型</li>
<li>propertyKey ：参数的名称</li>
<li>index：参数数组中的位置</li>
</ul>
<pre><code class="tsx">function logParameter(target: Object, propertyName: string, index: number) &#123;
  console.log(target);
  console.log(propertyName);
  console.log(index);
&#125;

class Employee &#123;
  greet(@logParameter message: string): string &#123;
      return `hello $&#123;message&#125;`;
  &#125;
&#125;
const emp = new Employee();
emp.greet(&#39;hello&#39;);
</code></pre>
<p>输入如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326633326465302d313134642d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="访问器装饰"><a href="#访问器装饰" class="headerlink" title="访问器装饰"></a>访问器装饰</h5><p>使用起来方式与方法装饰一致，如下：</p>
<pre><code class="tsx">function modification(target: Object, propertyKey: string, descriptor: PropertyDescriptor) &#123;
  console.log(target);
  console.log(&quot;prop &quot; + propertyKey);
  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);
&#125;;

class Person&#123;
 _name: string;
 constructor() &#123;
   this._name = &#39;huihui&#39;;
 &#125;

 @modification
 get name() &#123;
   return this._name
 &#125;
&#125;
</code></pre>
<h5 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h5><p>如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：</p>
<pre><code class="tsx">function addAge(age: number) &#123;
  return function(constructor: Function) &#123;
    constructor.prototype.age = age
  &#125;
&#125;

@addAge(10)
class Person&#123;
  name: string;
  age!: number;
  constructor() &#123;
    this.name = &#39;huihui&#39;;
  &#125;
&#125;

let person = new Person();
</code></pre>
<h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><p>当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用，例如如下：</p>
<pre><code class="tsx">function f() &#123;
    console.log(&quot;f(): evaluated&quot;);
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123;
        console.log(&quot;f(): called&quot;);
    &#125;
&#125;

function g() &#123;
    console.log(&quot;g(): evaluated&quot;);
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123;
        console.log(&quot;g(): called&quot;);
    &#125;
&#125;

class C &#123;
    @f()
    @g()
    method() &#123;&#125;
&#125;

// 输出
f(): evaluated
g(): evaluated
g(): called
f(): called
</code></pre>
<h4 id="三、应用场景-4"><a href="#三、应用场景-4" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>可以看到，使用装饰器存在两个显著的优点：</p>
<ul>
<li>代码可读性变强了，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原来功能进行扩展</li>
</ul>
<p>后面的使用场景中，借助装饰器的特性，除了提高可读性之后，针对已经存在的类，可以通过装饰器的特性，在不改变原有代码情况下，对原来功能进行扩展</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中命名空间与模块的理解？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中命名空间与模块的理解？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中命名空间与模块的理解？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中命名空间与模块的理解？区别？</h3><h4 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h4><p><code>TypeScript</code> 与<code> ECMAScript</code> 2015 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块</p>
<p>相反地，如果一个文件不带有顶级的<code>import</code>或者<code>export</code>声明，那么它的内容被视为全局可见的</p>
<p>例如我们在在一个 <code>TypeScript</code> 工程下建立一个文件 <code>1.ts</code>，声明一个变量<code>a</code>，如下：</p>
<pre><code class="tsx">const a = 1
</code></pre>
<p>然后在另一个文件同样声明一个变量<code>a</code>，这时候会出现错误信息</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61323339643937302d313337652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>提示重复声明<code>a</code>变量，但是所处的空间是全局的</p>
<p>如果需要解决这个问题，则通过<code>import</code>或者<code>export</code>引入模块系统即可，如下：</p>
<pre><code class="tsx">const a = 10;

export default a
</code></pre>
<p>在<code>typescript</code>中，<code>export</code>关键字可以导出变量或者类型，用法与<code>es6</code>模块一致，如下：</p>
<pre><code class="tsx">export const a = 1
export type Person = &#123;
    name: String
&#125;
</code></pre>
<p>通过<code>import</code> 引入模块，如下：</p>
<pre><code class="tsx">import &#123; a, Person &#125; from &#39;./export&#39;;
</code></pre>
<h4 id="二、命名空间"><a href="#二、命名空间" class="headerlink" title="二、命名空间"></a>二、命名空间</h4><p>命名空间一个最明确的目的就是解决重名问题</p>
<p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的</p>
<p>这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p>
<p><code>TypeScript</code> 中命名空间使用 <code>namespace</code> 来定义，语法格式如下：</p>
<pre><code class="tsx">namespace SomeNameSpaceName &#123;
   export interface ISomeInterfaceName &#123;      &#125;
   export class SomeClassName &#123;      &#125;
&#125;
</code></pre>
<p>以上定义了一个命名空间 <code>SomeNameSpaceName</code>，如果我们需要在外部可以调用 <code>SomeNameSpaceName</code> 中的类和接口，则需要在类和接口添加 <code>export</code> 关键字</p>
<p>使用方式如下：</p>
<pre><code class="ini">SomeNameSpaceName.SomeClassName
</code></pre>
<p>命名空间本质上是一个对象，作用是将一系列相关的全局变量组织到一个对象的属性，如下：</p>
<pre><code class="tsx">namespace Letter &#123;
  export let a = 1;
  export let b = 2;
  export let c = 3;
  // ...
  export let z = 26;
&#125;
</code></pre>
<p>编译成<code>js</code>如下：</p>
<pre><code class="tsx">var Letter;
(function (Letter) &#123;
    Letter.a = 1;
    Letter.b = 2;
    Letter.c = 3;
    // ...
    Letter.z = 26;
&#125;)(Letter || (Letter = &#123;&#125;));
</code></pre>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><ul>
<li>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中</li>
<li>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖</li>
<li>在正常的TS项目开发过程中并不建议用命名空间，但通常在通过 d.ts 文件标记 js 库类型的时候使用命名空间，主要作用是给编译器编写代码的时候参考使用</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在Vue项目中应用TypeScript？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在Vue项目中应用TypeScript？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Vue项目中应用TypeScript？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Vue项目中应用TypeScript？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>与link类似</p>
<p>在<code>VUE</code>项目中应用<code>typescript</code>，我们需要引入一个库<code>vue-property-decorator</code>，</p>
<p>其是基于<code>vue-class-component</code>库而来，这个库<code>vue</code>官方推出的一个支持使用<code>class</code>方式来开发<code>vue</code>单文件组件的库</p>
<p>主要的功能如下：</p>
<ul>
<li>methods 可以直接声明为类的成员方法</li>
<li>计算属性可以被声明为类的属性访问器</li>
<li>初始化的 data 可以被声明为类属性</li>
<li>data、render 以及所有的 Vue 生命周期钩子可以直接作为类的成员方法</li>
<li>所有其他属性，需要放在装饰器中</li>
</ul>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p>vue-property-decorator 主要提供了多个装饰器和一个函数:</p>
<ul>
<li>@prop</li>
<li>@ProPsync</li>
<li>@model</li>
<li>@watch</li>
<li>@provide</li>
<li>@Inject</li>
<li>@ProvideReactive</li>
<li>@InjectReactive</li>
<li>@emit</li>
<li>@ref</li>
<li>@component (由 vue-class-component 提供)</li>
<li>Mixins (由 vue-class-component 提供)</li>
</ul>
<h5 id="component"><a href="#component" class="headerlink" title="@component"></a><a target="_blank" rel="noopener" href="https://github.com/component">@component</a></h5><p><code>Component</code>装饰器它注明了此类为一个<code>Vue</code>组件，因此即使没有设置选项也不能省略</p>
<p>如果需要定义比如 <code>name</code>、<code>components</code>、<code>filters</code>、<code>directives</code>以及自定义属性，就可以在<code>Component</code>装饰器中定义，如下：</p>
<pre><code class="tsx">import &#123;Component,Vue&#125; from &#39;vue-property-decorator&#39;;
import &#123;componentA,componentB&#125; from &#39;@/components&#39;;

 @Component(&#123;
    components:&#123;
        componentA,
        componentB,
    &#125;,
    directives: &#123;
        focus: &#123;
            // 指令的定义
            inserted: function (el) &#123;
                el.focus()
            &#125;
        &#125;
    &#125;
&#125;)
export default class YourCompoent extends Vue&#123;
   
&#125;
</code></pre>
<h5 id="computed、data、methods"><a href="#computed、data、methods" class="headerlink" title="computed、data、methods"></a>computed、data、methods</h5><p>这里取消了组件的data和methods属性，以往data返回对象中的属性、methods中的方法需要直接定义在Class中，当做类的属性和方法</p>
<pre><code class="tsx">@Component
export default class HelloDecorator extends Vue &#123;
    count: number = 123 // 类属性相当于以前的 data

    add(): number &#123; // 类方法就是以前的方法
        this.count + 1
    &#125;

    // 获取计算属性
    get total(): number &#123;
      return this.count + 1
    &#125;

    // 设置计算属性
    set total(param:number): void &#123;
      this.count = param
    &#125;
&#125;
</code></pre>
<h5 id="props"><a href="#props" class="headerlink" title="@props"></a><a target="_blank" rel="noopener" href="https://github.com/props">@props</a></h5><p>组件接收属性的装饰器，如下使用：</p>
<pre><code class="tsx">import &#123;Component,Vue,Prop&#125; from vue-property-decorator;

@Component
export default class YourComponent extends Vue &#123;
    @Prop(String)
    propA:string;
    
    @Prop([String,Number])
    propB:string|number;
    
    @Prop(&#123;
     type: String, // type: [String , Number]
     default: &#39;default value&#39;, // 一般为String或Number
      //如果是对象或数组的话。默认值从一个工厂函数中返回
      // defatult: () =&gt; &#123;
      //     return [&#39;a&#39;,&#39;b&#39;]
      // &#125;
     required: true,
     validator: (value) =&gt; &#123;
        return [
          &#39;InProcess&#39;,
          &#39;Settled&#39;
        ].indexOf(value) !== -1
     &#125;
    &#125;)
    propC:string;
&#125;
</code></pre>
<h5 id="watch"><a href="#watch" class="headerlink" title="@watch"></a><a target="_blank" rel="noopener" href="https://github.com/watch">@watch</a></h5><p>实际就是<code>Vue</code>中的监听器，如下：</p>
<pre><code class="tsx">import &#123; Vue, Component, Watch &#125; from &#39;vue-property-decorator&#39;

@Component
export default class YourComponent extends Vue &#123;
  @Watch(&#39;child&#39;)
  onChildChanged(val: string, oldVal: string) &#123;&#125;

  @Watch(&#39;person&#39;, &#123; immediate: true, deep: true &#125;)
  onPersonChanged1(val: Person, oldVal: Person) &#123;&#125;

  @Watch(&#39;person&#39;)
  onPersonChanged2(val: Person, oldVal: Person) &#123;&#125;
&#125;
</code></pre>
<h5 id="emit"><a href="#emit" class="headerlink" title="@emit"></a><a target="_blank" rel="noopener" href="https://github.com/emit">@emit</a></h5><p><code>vue-property-decorator</code> 提供的 <code>@Emit</code> 装饰器就是代替<code>Vue </code>中的事件的触发<code>$emit</code>，如下：</p>
<pre><code class="tsx">import &#123;Vue, Component, Emit&#125; from &#39;vue-property-decorator&#39;;
    @Component(&#123;&#125;)
    export default class Some extends Vue&#123;
        mounted()&#123;
            this.$on(&#39;emit-todo&#39;, function(n) &#123;
                console.log(n)
            &#125;)
            this.emitTodo(&#39;world&#39;);
        &#125;
        @Emit()
        emitTodo(n: string)&#123;
            console.log(&#39;hello&#39;);
        &#125;
    &#125;
</code></pre>
<h4 id="三-、总结"><a href="#三-、总结" class="headerlink" title="三 、总结"></a>三 、总结</h4><p>可以看到上述<code>typescript</code>版本的<code>vue class</code>的语法与平时<code>javascript</code>版本使用起来还是有很大的不同，多处用到<code>class</code>与装饰器，但实际上本质是一致的，只有不断编写才会得心应手</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在React项目中应用TypeScript？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在React项目中应用TypeScript？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在React项目中应用TypeScript？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在React项目中应用TypeScript？</h3><h4 id="一、前言-1"><a href="#一、前言-1" class="headerlink" title="一、前言"></a>一、前言</h4><p>单独的使用 <code>TypeScript</code> 并不会导致学习成本很高，但是绝大部分前端开发者的项目都是依赖于框架的</p>
<p>例如与 <code>Vue</code>、<code>React</code> 这些框架结合使用的时候，会有一定的门槛</p>
<p>使用 <code>TypeScript</code> 编写 <code>React</code> 代码，除了需要 <code>TypeScript</code> 这个库之外，还需要安装 <code>@types/react</code>、<code>@types/react-dom</code></p>
<pre><code class="bash">npm i @types/react -s

npm i @types/react-dom -s
</code></pre>
<p>至于上述使用 <code>@types</code> 的库的原因在于，目前非常多的 <code>JavaScript</code> 库并没有提供自己关于 <code>TypeScript</code> 的声明文件</p>
<p>所以，<code>ts</code> 并不知道这些库的类型以及对应导出的内容，这里 <code>@types</code> 实际就是社区中的 <code>DefinitelyTyped</code> 库，定义了目前市面上绝大多数的 <code>JavaScript</code> 库的声明</p>
<p>所以下载相关的 <code>JavaScript</code> 对应的 <code>@types</code> 声明时，就能够使用使用该库对应的类型定义</p>
<h4 id="二、使用方式-5"><a href="#二、使用方式-5" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>在编写 <code>React</code> 项目的时候，最常见的使用的组件就是：</p>
<ul>
<li>无状态组件</li>
<li>有状态组件</li>
<li>受控组件</li>
</ul>
<h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><p>主要作用是用于展示 <code>UI</code>，如果使用 <code>js</code> 声明，则如下所示：</p>
<pre><code class="jsx">import * as React from &quot;React&quot;;

export const Logo = (props) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<p>但这时候 <code>ts</code> 会出现报错提示，原因在于没有定义 <code>porps</code> 类型，这时候就可以使用 <code>interface</code> 接口去定义 <code>porps</code> 即可，如下：</p>
<pre><code class="tsx">import * as React from &quot;React&quot;;

interface IProps &#123;
  logo?: string;
  className?: string;
  alt?: string;
&#125;

export const Logo = (props: IProps) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<p>但是我们都知道 <code>props</code> 里面存在 <code>children</code> 属性，我们不可能每个 <code>porps</code> 接口里面定义多一个 <code>children</code>，如下：</p>
<pre><code class="tsx">interface IProps &#123;
  logo?: string;
  className?: string;
  alt?: string;
  children?: ReactNode;
&#125;
</code></pre>
<p>更加规范的写法是使用 <code>React</code> 里面定义好的 <code>FC</code> 属性，里面已经定义好 <code>children</code> 类型，如下：</p>
<pre><code class="tsx">export const Logo: React.FC&lt;IProps&gt; = (props) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<ul>
<li>React.FC 显式地定义了返回类型，其他方式是隐式推导的</li>
<li>React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全</li>
<li>React.FC 为 children 提供了隐式的类型（ReactElement | null）</li>
</ul>
<h5 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h5><p>可以是一个类组件且存在 <code>props</code> 和 <code>state</code> 属性</p>
<p>如果使用 <code>TypeScript</code> 声明则如下所示：</p>
<pre><code class="tsx">import * as React from &quot;React&quot;;

interface IProps &#123;
  color: string;
  size?: string;
&#125;
interface IState &#123;
  count: number;
&#125;
class App extends React.Component&lt;IProps, IState&gt; &#123;
  public state = &#123;
    count: 1,
  &#125;;
  public render() &#123;
    return &lt;div&gt;Hello world&lt;/div&gt;;
  &#125;
&#125;
</code></pre>
<p>上述通过泛型对 <code>props</code>、<code>state</code> 进行类型定义，然后在使用的时候就可以在编译器中获取更好的智能提示</p>
<p>关于 <code>Component</code> 泛型类的定义，可以参考下 React 的类型定义文件 <code>node_modules/@types/React/index.d.ts</code>，如下所示：</p>
<pre><code class="ts">class Component&lt;P, S&gt; &#123;
  readonly props: Readonly&lt;&#123; children?: ReactNode &#125;&gt; &amp; Readonly&lt;P&gt;;

  state: Readonly&lt;S&gt;;
&#125;
</code></pre>
<p>从上述可以看到，<code>state</code> 属性也定义了可读类型，目的是为了防止直接调用 <code>this.state</code> 更新状态</p>
<h5 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h5><p>受控组件的特性在于元素的内容通过组件的状态 <code>state</code> 进行控制</p>
<p>由于组件内部的事件是合成事件，不等同于原生事件，</p>
<p>例如一个 <code>input</code> 组件修改内部的状态，常见的定义的时候如下所示：</p>
<pre><code class="ts">private updateValue(e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#123;
    this.setState(&#123; itemText: e.target.value &#125;)
&#125;
</code></pre>
<p>常用 <code>Event</code> 事件对象类型：</p>
<ul>
<li>ClipboardEvent&lt;T &#x3D; Element&gt; 剪贴板事件对象</li>
<li>DragEvent&lt;T &#x3D; Element&gt; 拖拽事件对象</li>
<li>ChangeEvent&lt;T &#x3D; Element&gt; Change 事件对象</li>
<li>KeyboardEvent&lt;T &#x3D; Element&gt; 键盘事件对象</li>
<li>MouseEvent&lt;T &#x3D; Element&gt; 鼠标事件对象</li>
<li>TouchEvent&lt;T &#x3D; Element&gt; 触摸事件对象</li>
<li>WheelEvent&lt;T &#x3D; Element&gt; 滚轮事件对象</li>
<li>AnimationEvent&lt;T &#x3D; Element&gt; 动画事件对象</li>
<li>TransitionEvent&lt;T &#x3D; Element&gt; 过渡事件对象</li>
</ul>
<p><code>T</code> 接收一个 <code>DOM</code> 元素类型</p>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>上述只是简单的在 <code>React</code> 项目使用 <code>TypeScript</code>，但在编写 <code>React</code> 项目的时候，还存在 <code>hooks</code>、默认参数、以及 <code>store</code> 等等……</p>
<p><code>TypeScript</code> 在框架中使用的学习成本相对会更高，需要不断编写才能熟练</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-使用-Typescript-有哪些优点和缺点"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-使用-Typescript-有哪些优点和缺点" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 使用 Typescript 有哪些优点和缺点"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 使用 Typescript 有哪些优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h5 id="提供可选的强静态类型"><a href="#提供可选的强静态类型" class="headerlink" title="提供可选的强静态类型"></a>提供可选的强静态类型</h5><p>既然叫 TypeScript，那它的最大亮点自然就是提供静态类型（type）。我们可以对变量设置类型，比如你给 count 变量设置为数字类型（number），如果你从 input 元素提取 value （string 类型）赋予给 count，如果你忘记将其转换为数字，编译是不会通过的。</p>
<p>当然类型不是强求设置的，为了兼容 JavaScript，你也可以设置为 any 类型。所谓 any 类型是一个特殊的类型，任何类型的的值都可以赋予给它。</p>
<h5 id="更早发现-BUG"><a href="#更早发现-BUG" class="headerlink" title="更早发现 BUG"></a>更早发现 BUG</h5><p>TypeScript 要编译后才能使用。所以我们的类型错误会在编译过程中被编译器发现，更早发现 BUG。如果直接用 JavaScript 开发，需要在程序运行时，吭哧吭哧点来点去各种测试来判断行为是否正常，费时费力，开发体验极差。</p>
<p>比如原本应该是两个数字相加的，写错成两个数字形式的字符串相加，结果是差得十万八千里，且不易察觉。TypeScript 在编译时就给你找到了，你不改对别想过我编译。</p>
<h5 id="代码可预测"><a href="#代码可预测" class="headerlink" title="代码可预测"></a>代码可预测</h5><p>声明的变量一旦指定类型，它的类型就再也不能修改。这样变量就具有可预测性。</p>
<p>JavaScript 的变量可以赋予任何类型的值。有时候，我们会看到一个变量在执行的过程中变成各种各样的类型，一会是字符串，一会是对象，非常不好预测，尤其是有复杂条件判断的时候。这其实是并不是好的开发习惯，但在 JavaScript 它就是可以这么干！</p>
<p>但如果你用 TypeScript，就没有这个烦恼，它直接给你一刀切了，你别想将字符串值赋予给一个数字类型变量，一旦声明就再也无法修改。</p>
<p>当然为了兼容，你也是可以将其设置 any 类型，但智能提升就没有了哦。</p>
<h5 id="丰富的-IDE-支持"><a href="#丰富的-IDE-支持" class="headerlink" title="丰富的 IDE 支持"></a>丰富的 IDE 支持</h5><p>因为使用了类型，所以检测某个变量是什么类型、可以使用哪些方法就变得容易，在开发体验上就可以进行改善了。</p>
<p>目前在绝大多数 IDE（集成开发环境）中已经支持 TypeScript 的 智能提示、自动补全、代码导航 等功能，并能在编写时实时反馈类型错误并提供准确的建议，比如可以指出传入函数的对象缺了哪些属性。</p>
<h5 id="方便重构"><a href="#方便重构" class="headerlink" title="方便重构"></a>方便重构</h5><p>重构时，如果函数的参数修改了，调用它时如果不对，TypeScript 会提示你。这对重构代码提供了坚实的后盾。有了 TypeScript，就放心做重构吧，前提你不要到处用 any。</p>
<h5 id="提供面向对象的写法"><a href="#提供面向对象的写法" class="headerlink" title="提供面向对象的写法"></a>提供面向对象的写法</h5><p>面向对象语言在实践中已经被证实是优秀的设计，拥有极高的可读性、可维护性。TypeScript 支持接口、抽象类、枚举等面向对象语言的特性，支持你更好地实现一些设计模式。TypeScript 还支持类型体操，有空多锻炼身体哈。</p>
<p>看了这么多优点，再看看 TypeScript 的缺点。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="不是真正的静态类型"><a href="#不是真正的静态类型" class="headerlink" title="不是真正的静态类型"></a>不是真正的静态类型</h5><p>因为需要兼容 JavaScript 的缘故，TypeScript 的类型是可选的。你可以用 any 类型，也可以进行类型的强制转换，所以如果你在代码中写了太多这样的东西，甚至将其变成 AnyScript。那么实际运行还是可能会出现一些类型上的问题。</p>
<h5 id="有一定的学习成本"><a href="#有一定的学习成本" class="headerlink" title="有一定的学习成本"></a>有一定的学习成本</h5><p>学 TypeScript 其实和学习一门新语言差不多了，还是有不小的学习成本的。但因为兼容 JavaScript 的缘故，对前端开发者来说难度会低一点。</p>
<h5 id="需要写更多的代码"><a href="#需要写更多的代码" class="headerlink" title="需要写更多的代码"></a>需要写更多的代码</h5><p>主要是类型和接口声明的部分，但能够抵消掉你 debug 类型问题的时间，总体看还是物超所值的。另外，编译后类型和接口声明都会被移除，相比直接写 JavaScript，体积不会明显更大。</p>
<h5 id="需要编译"><a href="#需要编译" class="headerlink" title="需要编译"></a>需要编译</h5><p>浏览器和 Nodejs 并不支持 TypeScript，所以多了一步编译操作。对于普通项目来说通常不长，其实还好。但如果你用来写脚本的话，就需要多安装 tsc 编译工具，还要配置好 tsconfig.json 文件，还是有点麻烦。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-Typescript中的内置类型有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-Typescript中的内置类型有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Typescript中的内置类型有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Typescript中的内置类型有哪些？</h3><h4 id="Partial（部分的）"><a href="#Partial（部分的）" class="headerlink" title="Partial（部分的）"></a>Partial（部分的）</h4><pre><code class="typescript">/**
 * Make all properties in T optional
 */
type Partial&lt;T&gt; = &#123;
    [P in keyof T]?: T[P];
&#125;;
</code></pre>
<p>作用是让传入类型中的所有属性变成都是可选的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;&#125;

const student2: Partial&lt;Student&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101152.jpeg"></p>
<p>变量student1的类型是Student，Student默认所有的属性都是不能为空的，所有会报错，student2就不会</p>
<h4 id="Required（必须的）"><a href="#Required（必须的）" class="headerlink" title="Required（必须的）"></a>Required（必须的）</h4><pre><code class="typescript">/**
 * Make all properties in T required
 */
type Required&lt;T&gt; = &#123;
    [P in keyof T]-?: T[P];
&#125;;
</code></pre>
<p>跟Partial的作用是相反的，是让传入类型中的所有属性变成都是必填的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name?: string;
  age?: number;
&#125;

const student1: Student = &#123;&#125;

const student2: Required&lt;Student&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101153.jpeg"></p>
<p>变量student1的类型是Student，Student默认所有的属性都是可以为空的，所有不会报错，student2会报错</p>
<h4 id="Readonly（只读的）"><a href="#Readonly（只读的）" class="headerlink" title="Readonly（只读的）"></a>Readonly（只读的）</h4><pre><code class="typescript">/**
 * Make all properties in T readonly
 */
type Readonly&lt;T&gt; = &#123;
    readonly [P in keyof T]: T[P];
&#125;;
</code></pre>
<p>作用是让传入类型中的所有属性变成都是只读的（不能修改属性）</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;
student1.age = 21

const student2: Readonly&lt;Student&gt; = &#123;
  name: &#39;李四&#39;,
  age: 20
&#125;
student2.age = 21
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101154.jpeg"></p>
<p>给student1的属性age重新赋值不会报错，给student2的属性age重新赋值就会报错，因为student2所有的属性都是只读的</p>
<h4 id="Pick（选择）"><a href="#Pick（选择）" class="headerlink" title="Pick（选择）"></a>Pick（选择）</h4><pre><code class="typescript">/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Pick&lt;T, K extends keyof T&gt; = &#123;
    [P in K]: T[P];
&#125;;
</code></pre>
<p>作用是选择传入类型中的部分属性组成新类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;

const student2: Pick&lt;Student, &#39;name&#39;&gt; = &#123;
  name: &#39;李四&#39;
&#125;

const student3: Pick&lt;Student, &#39;name&#39;&gt; = &#123;
  name: &#39;王五&#39;,
  age: 20
&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101155.jpeg"></p>
<p>变量student1可以有所有属性name和age，变量student2就只能有属性name，变量student3加上属性age就会报错</p>
<h4 id="Record（记录）"><a href="#Record（记录）" class="headerlink" title="Record（记录）"></a>Record（记录）</h4><pre><code class="typescript">/**
 * Construct a type with a set of properties K of type T
 */
type Record&lt;K extends keyof any, T&gt; = &#123;
    [P in K]: T;
&#125;;
</code></pre>
<p>作用是构建一个类型，这个类型用来描述一个对象，这个对象的属性都具有相同的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export const student1: Record&lt;string, any&gt; = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;
</code></pre>
<p>Record应该是日常使用频率较高的内置类型了，主要用来描述对象，一般建议是不用Object来描述对象，而是用Record代替，Record&lt;string, any&gt;几乎可以说是万金油了</p>
<h4 id="Exclude（排除）"><a href="#Exclude（排除）" class="headerlink" title="Exclude（排除）"></a>Exclude（排除）</h4><pre><code class="typescript">/**
 * Exclude from T those types that are assignable to U
 */
type Exclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre>
<p>针对联合类型（interface这种没用），用人话说，排除相同的，留下不同的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Exclude&lt;StudentAttr, PersonAttr&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101156.jpeg"></p>
<p>student1就只能被赋值为’class’ 或者’school’</p>
<h4 id="Extract（取出）"><a href="#Extract（取出）" class="headerlink" title="Extract（取出）"></a>Extract（取出）</h4><pre><code class="typescript">/**
 * Extract from T those types that are assignable to U
 */
type Extract&lt;T, U&gt; = T extends U ? T : never;
</code></pre>
<p>与Exclude相反，针对联合类型，排除不同的的，取出相同的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Extract&lt;StudentAttr, PersonAttr&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101157.jpeg"></p>
<p>student1就只能被赋值为’name’或者’age’</p>
<h4 id="Omit（省略）"><a href="#Omit（省略）" class="headerlink" title="Omit（省略）"></a>Omit（省略）</h4><pre><code class="typescript">/**
 * Construct a type with the properties of T except for those in type K.
 */
type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;
</code></pre>
<p>传入一个类型，和这个类型的几个属性，把传入的属性省略掉，组成一个新类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
  class: string;
  school: string;
&#125;

export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Omit&lt;Student, PersonAttr&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101158.jpeg"></p>
<p>student1报错，提示没有属性’name’、’age’</p>
<h4 id="NonNullable（不能为null）"><a href="#NonNullable（不能为null）" class="headerlink" title="NonNullable（不能为null）"></a>NonNullable（不能为null）</h4><pre><code class="typescript">/**
 * Exclude null and undefined from T
 */
type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;
</code></pre>
<p>字面意思，不能为空</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: NonNullable&lt;Student | undefined | null&gt; = null
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101159.jpeg"></p>
<p>student1赋值为null会报错（在tsconfig.json配置文件中开启类型检查，<code>&quot;skipLibCheck&quot;: false</code>）</p>
<h4 id="Parameters（参数）"><a href="#Parameters（参数）" class="headerlink" title="Parameters（参数）"></a>Parameters（参数）</h4><pre><code class="typescript">/**
 * Obtain the parameters of a function type in a tuple
 */
type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>获取传入函数的参数组成的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentFunc &#123;
  (name: string, age: number): Student
&#125;

const student1: Parameters&lt;StudentFunc&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101160.jpeg"></p>
<p>student1的类型为<code>[name: string, age: number]</code></p>
<h4 id="ConstructorParameters（构造参数）"><a href="#ConstructorParameters（构造参数）" class="headerlink" title="ConstructorParameters（构造参数）"></a>ConstructorParameters（构造参数）</h4><pre><code class="typescript">/**
 * Obtain the parameters of a constructor function type in a tuple
 */
type ConstructorParameters&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>获取传入构造函数的参数组成的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentConstructor &#123;
  new (name: string, age: number): Student
&#125;

const student1: ConstructorParameters&lt;StudentConstructor&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101161.jpeg"></p>
<p>student1的类型为<code>[name: string, age: number]</code></p>
<h4 id="ReturnType（返回类型）"><a href="#ReturnType（返回类型）" class="headerlink" title="ReturnType（返回类型）"></a>ReturnType（返回类型）</h4><pre><code class="typescript">/**
 * Obtain the return type of a function type
 */
type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;
</code></pre>
<p>获取传入函数的返回类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentFunc &#123;
  (name: string, age: number): Student
&#125;

const student1: ReturnType&lt;StudentFunc&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101162.jpeg"></p>
<p>student1的类型为<code>Student</code></p>
<h4 id="InstanceType（构造返回类型、实例类型）"><a href="#InstanceType（构造返回类型、实例类型）" class="headerlink" title="InstanceType（构造返回类型、实例类型）"></a>InstanceType（构造返回类型、实例类型）</h4><pre><code class="typescript">/**
 * Obtain the return type of a constructor function type
 */
type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any;
</code></pre>
<p>获取传入构造函数的返回类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">const Student = class &#123;
  name: string;
  age: number;
  constructor (name: string, age: number) &#123;
    this.name = name
    this.age = age
  &#125;
  showInfo () &#123;
    console.log(&#39;name: &#39;, this.name, &#39;age: &#39;, this.age);
  &#125;
&#125;

const student1: InstanceType&lt;typeof Student&gt; = new Student(&#39;张三&#39;, 20)
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101163.jpeg"></p>
<p>个人认为这是一个非常好用的内置类型，目前在前端项目中，class是用的越来越多了，在TS中，class其实也是可以用作类型声明空间的，用来描述对象类型，但是一般来说好像很少这样用的，一般用interface或者type居多</p>
<pre><code class="typescript">export class Student &#123;
  name: string;
  age: number;
&#125;
</code></pre>
<p>所以一般就是直接把class用作变量声明空间，但是对于 class new 出的实例，怎么描述它的类型呢，就如上文的，直接<code>const student1: Student</code>那是铁定会报错的，因为Student用作变量声明空间，没有用作类型声明空间（听起来好绕），这时候就可以用到InstanceType，完美解决问题</p>
<h4 id="Uppercase（大写）"><a href="#Uppercase（大写）" class="headerlink" title="Uppercase（大写）"></a>Uppercase（大写）</h4><pre><code class="typescript">/**
 * Convert string literal type to uppercase
 */
type Uppercase&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>变大写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;male&#39; | &#39;female&#39;

const studentSex: Uppercase&lt;StudentSexType&gt; = &#39;MALE&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101164.jpeg"></p>
<h4 id="Lowercase（小写）"><a href="#Lowercase（小写）" class="headerlink" title="Lowercase（小写）"></a>Lowercase（小写）</h4><pre><code class="typescript">/**
 * Convert string literal type to lowercase
 */
type Lowercase&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>变小写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;MALE&#39; | &#39;FEMALE&#39;

const studentSex: Lowercase&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101165.jpeg"></p>
<h4 id="Capitalize（首字母大写）"><a href="#Capitalize（首字母大写）" class="headerlink" title="Capitalize（首字母大写）"></a>Capitalize（首字母大写）</h4><pre><code class="typescript">/**
 * Convert first character of string literal type to uppercase
 */
type Capitalize&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>首字母变大写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;male&#39; | &#39;female&#39;

const studentSex: Capitalize&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101166.jpeg"></p>
<h4 id="Uncapitalize（首字母小写）"><a href="#Uncapitalize（首字母小写）" class="headerlink" title="Uncapitalize（首字母小写）"></a>Uncapitalize（首字母小写）</h4><pre><code class="typescript">/**
 * Convert first character of string literal type to lowercase
 */
type Uncapitalize&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>首字母变小写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;MALE&#39; | &#39;FEMALE&#39;

const studentSex: Uncapitalize&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101167.jpeg"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-能否将多个-ts-文件组合成一个-js-文件？-如果是，那么如何？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-能否将多个-ts-文件组合成一个-js-文件？-如果是，那么如何？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 能否将多个 .ts 文件组合成一个 .js 文件？ 如果是，那么如何？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 能否将多个 <code>.ts</code> 文件组合成一个 <code>.js</code> 文件？ 如果是，那么如何？</h3><p>这是可以的。需要添加 —outFILE [OutputJSFileName] 编译选项。</p>
<pre><code class="shell">$ tsc --outFile comman.js file1.ts file2.ts file3.ts
</code></pre>
<p>上述命令将编译所有三个<code>.ts</code>文件，结果将存储到单个<code>comman.js</code>文件中。在这种情况下，当没有像下面的命令那样提供输出文件名时。</p>
<pre><code class="shell">$ tsc --outFile file1.ts file2.ts file3.ts
</code></pre>
<p>然后，<code>file2.ts</code>和<code>file3.ts</code>会被编译，输出会放在<code>file1.ts</code>中。所以现在的 <code>file1.ts</code> 包含 JavaScript 代码。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-是否可以通过-ts-文件中的实时更改自动编译-ts-？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-是否可以通过-ts-文件中的实时更改自动编译-ts-？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 是否可以通过 .ts 文件中的实时更改自动编译 .ts ？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 是否可以通过 <code>.ts</code> 文件中的实时更改自动编译 <code>.ts</code> ？</h3><p>是的，可以通过 <code>.ts</code> 文件中的实时更改自动编译<code>.ts</code>。这可以通过使用 <code>--watch</code> 编译器选项来实现。</p>
<pre><code class="shell">tsc --watch file1.ts
</code></pre>
<p>上面的命令首先编译 <code>file1.js</code> 中的 <code>file1.ts</code> 并观察文件的变化。如果检测到任何更改，它将再次编译该文件。在这里，需要确保在使用 <code>--watch</code> 选项运行时不能关闭命令提示符。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-interface语句和type语句有什么区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-interface语句和type语句有什么区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ interface语句和type语句有什么区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ interface语句和type语句有什么区别？</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>都可以描述一个对象或者函数</p>
<p>interface</p>
<pre><code class="typescript">interface User &#123;
  name: string
  age: number
&#125;

interface SetUser &#123;
  (name: string, age: number): void;
&#125;
</code></pre>
<p>type</p>
<pre><code class="typescript">type User = &#123;
  name: string
  age: number
&#125;;

type SetUser = (name: string, age: number)=&gt; void;
</code></pre>
<p>都允许拓展（extends）</p>
<p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p>
<p>interface extends interface</p>
<pre><code class="typescript">interface Name &#123; 
  name: string; 
&#125;
interface User extends Name &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<p>type extends type</p>
<pre><code class="ini">type Name = &#123; 
  name: string; 
&#125;
type User = Name &amp; &#123; age: number  &#125;;
复制代码
</code></pre>
<p>interface extends type</p>
<pre><code class="typescript">type Name = &#123; 
  name: string; 
&#125;
interface User extends Name &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<p>type extends interface</p>
<pre><code class="ini">interface Name &#123; 
  name: string; 
&#125;
type User = Name &amp; &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>type 可以而 interface 不行</p>
<ul>
<li>type 可以声明基本类型别名，联合类型，元组等类型</li>
</ul>
<pre><code class="go">// 基本类型别名
type Name = string

// 联合类型
interface Dog &#123;
    wong();
&#125;
interface Cat &#123;
    miao();
&#125;

type Pet = Dog | Cat

// 具体定义数组每个位置的类型
type PetList = [Dog, Pet]

复制代码
</code></pre>
<ul>
<li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</li>
</ul>
<pre><code class="ini">// 当你想获取一个变量的类型时，使用 typeof
let div = document.createElement(&#39;div&#39;);
type B = typeof div
复制代码
</code></pre>
<ul>
<li>其他骚操作</li>
</ul>
<pre><code class="ini">type StringOrNumber = string | number;  
type Text = string | &#123; text: string &#125;;  
type NameLookup = Dictionary&lt;string, Person&gt;;  
type Callback&lt;T&gt; = (data: T) =&gt; void;  
type Pair&lt;T&gt; = [T, T];  
type Coordinates = Pair&lt;number&gt;;  
type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;
复制代码
</code></pre>
<p>interface 可以而 type 不行</p>
<p>interface 能够声明合并</p>
<pre><code class="typescript">interface User &#123;
  name: string
  age: number
&#125;

interface User &#123;
  sex: string
&#125;

/*
User 接口为 &#123;
  name: string
  age: number
  sex: string 
&#125;
*/
复制代码
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在Proxy中代理apply方法"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在Proxy中代理apply方法" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Proxy中代理apply方法"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Proxy中代理apply方法</h3><pre><code class="javascript"> &#123;
            var target = function () &#123;
                return &#39;I am the target&#39;;
            &#125;
            var handler = &#123;
                apply: function () &#123;
                    return &#39;I am the proxy&#39;;
                &#125;
            &#125;;
            var p = new Proxy(target,handler);
            console.log(&quot;p&quot;,p());
        &#125;
//上面代码中，变量p是Proxy的实例，当他作为函数调用时（p（））
//,就会被apply方法拦截，返回一个字符串
</code></pre>
<pre><code class="javascript">&#123;
    var twice = &#123;
                    //目标对象，目标对象的上下文对象，目标对象的参数数组
        apply:function (target,ctx,args) &#123;
            //return console.log(&quot;target&quot;,target,&quot;ctx&quot;,ctx,&quot;args&quot;,args);
           return Reflect.apply(...arguments)*2;
        &#125;
    &#125;;
    function sum (left,right) &#123;
         return left*right;
    &#125;;
    var proxy = new Proxy(sum,twice);
    console.log(&quot;proxy1&quot;,proxy(1,2));
    console.log(&quot;proxy.call&quot;,proxy.call(null,5,6));
    console.log(&quot;proxy,apply&quot;,proxy.apply(null,[7,8]));
    console.log(&quot;proxy,apply&quot;,Reflect.apply(proxy,null,[7,8]));

&#125;
//上面的实例执行顺序是当sum（）执行完后再执行twice中的apply()，
//上面代码中每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截
//另外，直接调用Reflect.apply方法，也会被拦截。
</code></pre>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全网络攻防"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"
    >前端面试大全网络攻防</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/" class="article-date">
  <time datetime="2022-11-01T07:16:13.000Z" itemprop="datePublished">2022-11-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/">网络攻击</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（网络攻防）"><a href="#前端面试题大全（网络攻防）" class="headerlink" title="前端面试题大全（网络攻防）"></a>前端面试题大全（网络攻防）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="网络攻防"><a href="#网络攻防" class="headerlink" title="网络攻防"></a>网络攻防</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-XSS攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-XSS攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ XSS攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ XSS攻击</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/09/27/fe-security.html">美团技术谈XSS攻防</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-CSRF攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-CSRF攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ CSRF攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ CSRF攻击</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">美团技术谈CSRF攻击</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-中间人攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-中间人攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 中间人攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 中间人攻击</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1900287">中间人攻击</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-SQL注入"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-SQL注入" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ SQL注入"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ SQL注入</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/github_36032947/article/details/78442189">理解SQL注入</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-DDoS攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-DDoS攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DDoS攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DDoS攻击</h3><p>DDoS攻击——常见的具有破坏性的安全性问题(如果是分布式攻击的话就是DDos攻击)</p>
<p>攻击方式：Ping Flood攻击即利用ping命令不停的发送的数据包到服务器。</p>
<p><a target="_blank" rel="noopener" href="https://www.cloudflare.com/zh-cn/learning/ddos/what-is-a-ddos-attack/">DDoS攻击 </a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-DNS缓存污染"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-DNS缓存污染" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DNS缓存污染"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DNS缓存污染</h3><p>DNS缓存污染——常见的网站不可访问的问题</p>
<p>攻击方式：第三方可信赖的域名服务器缓存了一些DNS解析，但被别人制造一些假域名服务器封包污染了，指向错误网址。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试题大全node"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/"
    >前端面试题大全node</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/" class="article-date">
  <time datetime="2022-11-01T02:53:32.000Z" itemprop="datePublished">2022-11-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/node-js/">node.js</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（node-js）"><a href="#前端面试题大全（node-js）" class="headerlink" title="前端面试题大全（node.js）"></a>前端面试题大全（node.js）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><h3 id="♥︎-♥︎-说说你对Node-js-的理解？优缺点？应用场景？"><a href="#♥︎-♥︎-说说你对Node-js-的理解？优缺点？应用场景？" class="headerlink" title="♥︎ ♥︎ 说说你对Node.js 的理解？优缺点？应用场景？"></a>♥︎ ♥︎ 说说你对Node.js 的理解？优缺点？应用场景？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>Node.js</code> 是一个开源与跨平台的 <code>JavaScript</code> 运行时环境</p>
<p>在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能</p>
<p>可以理解为 <code>Node.js</code> 就是一个服务器端的、非阻塞式I&#x2F;O的、事件驱动的<code>JavaScript</code>运行环境</p>
<h5 id="非阻塞异步"><a href="#非阻塞异步" class="headerlink" title="非阻塞异步"></a>非阻塞异步</h5><p><code>Nodejs</code>采用了非阻塞型<code>I/O</code>机制，在做<code>I/O</code>操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作</p>
<p>例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率</p>
<h5 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h5><p>事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数</p>
<p>比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61373732393539302d633165382d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、优缺点"><a href="#二、优缺点" class="headerlink" title="二、优缺点"></a>二、优缺点</h4><p>优点：</p>
<ul>
<li>处理高并发场景性能更佳</li>
<li>适合I&#x2F;O密集型应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I&#x2F;O硬盘内存读写操作</li>
</ul>
<p>因为<code>Nodejs</code>是单线程，带来的缺点有：</p>
<ul>
<li>不适合CPU密集型应用</li>
<li>只支持单核CPU，不能充分利用CPU</li>
<li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>
</ul>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>借助<code>Nodejs</code>的特点和弊端，其应用场景分类如下：</p>
<ul>
<li>善于<code>I/O</code>，不善于计算。因为Nodejs是一个单线程，如果计算（同步）太多，则会阻塞这个线程</li>
<li>大量并发的I&#x2F;O，应用程序内部并不需要进行非常复杂的处理</li>
<li>与 websocket 配合，开发长连接的实时交互应用程序</li>
</ul>
<p>具体场景可以表现为如下：</p>
<ul>
<li>第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序</li>
<li>第二大类：基于web、canvas等多人联网游戏</li>
<li>第三大类：基于web的多人实时聊天客户端、聊天室、图文直播</li>
<li>第四大类：单页面浏览器应用程序</li>
<li>第五大类：操作数据库、为前端和移动端提供基于<code>json</code>的API</li>
</ul>
<p>其实，<code>Nodejs</code>能实现几乎一切的应用，只考虑适不适合使用它</p>
<h3 id="♥︎-♥︎-为什么-Node-js-是单线程的？"><a href="#♥︎-♥︎-为什么-Node-js-是单线程的？" class="headerlink" title="♥︎ ♥︎ 为什么 Node.js 是单线程的？"></a>♥︎ ♥︎ 为什么 Node.js 是单线程的？</h3><p>回答一：怼：如果不幸遇到面试官问这个问题，你反问他 nodejs 为什么叫做 nodejs.</p>
<p>回答二：苟：您好，贵公司的面试题还挺有深度的，这让我越来越期待加入贵公司了。关于 ndoejs 是单线程的，刚好前段时间阅读过有关 node 的文章。node 的作者在设计之初选择语言时，评估过当时的流行语言，最终选择了存在多年在后端却一直没有市场的 js,正是 js 的不被关注，使得使用 js 没有额外阻力，而 js 在浏览器中有广泛的事件驱动方面的应用，正符合作者的喜好。于是 node 使用了 js 作为开发语言，node 的作者在开发时保持了 js 单线程的特点，所以 nodejs 是单线程的。</p>
<h3 id="♥︎-♥︎-什么是回调函数？"><a href="#♥︎-♥︎-什么是回调函数？" class="headerlink" title="♥︎ ♥︎ 什么是回调函数？"></a>♥︎ ♥︎ 什么是回调函数？</h3><p>概念：</p>
<p>回调就是一种利用函数指针进行函数调用的过程。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。</p>
<p>对普通函数的调用：</p>
<p>调用程序发出对普通函数的调用后，程序执行立即转向被调用函数执行，直到被调用函数执行完毕后，再返回调用程序继续执行。从发出调用的程序的角度看，这个过程为“调用–&gt;等待被调用函数执行完毕–&gt;继续执行”</p>
<p>对回调函数调用：</p>
<p>调用程序发出对回调函数的调用后，不等函数执行完毕，立即返回并继续执行。这样，调用程序执和被调用函数同时在执行。当被调函数执行完毕后，被调函数会反过来调用某个事先指定函数，以通知调用程序：函数调用结束。这个过程称为回调(Callback)，这正是回调函数名称的由来。<br>回调函数机制：</p>
<p>1、定义一个函数（图中的sub&#x2F;mul函数）；</p>
<p>2、将此函数的地址注册给调用者test函数；</p>
<p>3、特定的事件或条件发生时（main主函数），调用者使用函数指针调用回调函数。</p>
<p>回调函数的缺点：</p>
<p>1）回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。</p>
<p>2）回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。</p>
<h3 id="♥︎-♥︎-Node-js-和-ajax-的区别是什么"><a href="#♥︎-♥︎-Node-js-和-ajax-的区别是什么" class="headerlink" title="♥︎ ♥︎  Node.js 和 ajax 的区别是什么?"></a>♥︎ ♥︎  Node.js 和 ajax 的区别是什么?</h3><p>区别一：</p>
<p>Ajax（异步Javascript和XML的简称）是一种客户端技术，通常用于更新页面内容而不刷新它。</p>
<p>而Node.js是服务器端Javascript，是一个基于 Chrome V8 引擎的 JavaScript 运行环境，是一个让 JavaScript 运行在服务端的开发平台。</p>
<p>区别二：</p>
<p>Node.js不在浏览器中执行，而是由服务器执行。而Ajax在浏览器中执行。</p>
<p>区别三：</p>
<p>node主要是提供后台服务，而ajax主要是用来前后台数据的请求与发送数据的。</p>
<h3 id="♥︎-♥︎-请使用-Node-js-原生的-HTTP-模块创建一个-web-Server。"><a href="#♥︎-♥︎-请使用-Node-js-原生的-HTTP-模块创建一个-web-Server。" class="headerlink" title="♥︎ ♥︎ 请使用 Node.js 原生的 HTTP 模块创建一个 web Server。"></a>♥︎ ♥︎ 请使用 Node.js 原生的 HTTP 模块创建一个 web Server。</h3><pre><code class="js">const http = require(&#39;http&#39;)
const port = 3000
const server = http.createServer((req, res) =&gt; &#123;
 res.statusCode = 200
 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;)
 res.end(&#39;Hello World&#39;)
&#125;)
server.listen(port, () =&gt; &#123;
 console.log( Server is running on http://127.0.0.1:$&#123;port&#125;/ )
&#125;)
</code></pre>
<hr>
<h3 id="♥︎-♥︎-♥︎-如何使用原生-Node-js-操做-cookie？"><a href="#♥︎-♥︎-♥︎-如何使用原生-Node-js-操做-cookie？" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何使用原生 Node.js 操做 cookie？"></a>♥︎ ♥︎ ♥︎ 如何使用原生 Node.js 操做 cookie？</h3><p>获取 cookie： req.headers.cookie</p>
<p>设置 cookie： res.writeHead(200, { ‘Set-Cookie’: ‘myCookie&#x3D;test’, ‘Content-Type’: ‘text&#x2F;plain’ }) </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012732909/article/details/119107135">node操作cookie</a>参考请点击</p>
<h3 id="♥︎-♥︎-♥︎-setImmediate-和-setTimeOut-区别在哪里"><a href="#♥︎-♥︎-♥︎-setImmediate-和-setTimeOut-区别在哪里" class="headerlink" title="♥︎ ♥︎ ♥︎ setImmediate 和 setTimeOut 区别在哪里?"></a>♥︎ ♥︎ ♥︎ setImmediate 和 setTimeOut 区别在哪里?</h3><p>setImmediate 和 setTimeOut 都是延迟加载。而当这两个定时器同时运行在主模块时，运行顺序是不一定的。setTimeOut 受进程性能的约束，有可能比 setImmediate 快，也有可能慢于 setImmediate。</p>
<p>而在 I&#x2F;O 事件的回调中，setImmediate 方法的回调永远在 setTimeOut 的回调前执行。</p>
<h3 id="♥︎-♥︎-♥︎-如何更新-Node-js-的版本"><a href="#♥︎-♥︎-♥︎-如何更新-Node-js-的版本" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何更新 Node.js 的版本?"></a>♥︎ ♥︎ ♥︎ 如何更新 Node.js 的版本?</h3><pre><code class="css">npm install npm -g (在命令行中将 npm 在重新安装一遍，如需指定版本需要加上 @版本数字 )
</code></pre>
<h3 id="♥︎-♥︎-♥︎-nextTick-和-setImmediate-的区别是什么？"><a href="#♥︎-♥︎-♥︎-nextTick-和-setImmediate-的区别是什么？" class="headerlink" title="♥︎ ♥︎ ♥︎  nextTick 和 setImmediate 的区别是什么？"></a>♥︎ ♥︎ ♥︎  nextTick 和 setImmediate 的区别是什么？</h3><p>nextTick 和 setImmediate 都是延迟加载。但是 nextTick 是放在当前队列的最后一个执行，</p>
<p>setImmediate 是在下一个队列的队首执行</p>
<h3 id="♥︎-♥︎-♥︎-请使用-Node-js-编写代码实现遍历文件夹并输出所有的文件名"><a href="#♥︎-♥︎-♥︎-请使用-Node-js-编写代码实现遍历文件夹并输出所有的文件名" class="headerlink" title="♥︎ ♥︎ ♥︎ 请使用 Node.js 编写代码实现遍历文件夹并输出所有的文件名"></a>♥︎ ♥︎ ♥︎ 请使用 Node.js 编写代码实现遍历文件夹并输出所有的文件名</h3><pre><code class="js">const fs = require(&#39;fs&#39;)
const path = require(&#39;path&#39;)
const getAllFile = function (dir) &#123;
 function traverse(dir) &#123;
 fs.readdirSync(dir).forEach(file =&gt; &#123;
 const pathname = path.join(dir, file)
 if (fs.statSync(pathname).isDirectory()) &#123;
 traverse(pathname)
 &#125; else &#123;
 console.log(file)
 &#125;
 &#125;)
 &#125;
 traverse(dir)
&#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？"><a href="#♥︎-♥︎-♥︎-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？" class="headerlink" title="♥︎ ♥︎ ♥︎ token 存储在 localStorage 里，当过期时过期的 token 怎么处理？"></a>♥︎ ♥︎ ♥︎ token 存储在 localStorage 里，当过期时过期的 token 怎么处理？</h3><p>当前端进行页面跳转或者需要鉴权的操作时，会发送请求到后台，而 token 会跟随请求头一起发送，后台通过请求头接收到 token 时会进行判断，若是过期了，应该返回一个 401 的状态码给前端，前端接收到以后，应该重定向到登录页要求用户重新登陆。</p>
<h3 id="♥︎-♥︎-♥︎-MySQL-和-MongoDB-的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？"><a href="#♥︎-♥︎-♥︎-MySQL-和-MongoDB-的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？" class="headerlink" title="♥︎ ♥︎ ♥︎ MySQL 和 MongoDB 的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？"></a>♥︎ ♥︎ ♥︎ MySQL 和 MongoDB 的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>数据库模型 mysql 是关系型数据库，现在使用最多的数据存储技术 mongodb 是非关系型数据库，并且是非关系型数据库中最像关系型的数据库</p>
<p>存储方式 mongodb-以类 JSON 的文档的格式存储 mysql-不同引擎有不同的存储方式</p>
<p>数据处理方式 mongodb-基于内存，将热数据存放在物理内存中，从而达到高速读写 mysql-不同引擎有自己的特点</p>
<h4 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h4><p>mongodb 的查询语句类似于 js 使用 api 的场景，通过 . 来调用，并传递参数来进行控制查询内容 如：查询 username 为张三，age 为 27 的数据</p>
<pre><code class="ini">db.users.find(&#123; username: &#39;张三&#39;, age: 27 &#125;)
</code></pre>
<p>而 mysql 则是标准的 sql 语句，同样查询代码如下：</p>
<pre><code class="ini">select * from users where &quot;username&quot; = &quot;张三&quot; and age = 27
</code></pre>
<h3 id="♥︎-♥︎-♥︎-什么是服务端渲染，服务端渲染的优点？"><a href="#♥︎-♥︎-♥︎-什么是服务端渲染，服务端渲染的优点？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是服务端渲染，服务端渲染的优点？"></a>♥︎ ♥︎ ♥︎ 什么是服务端渲染，服务端渲染的优点？</h3><p>服务端渲染：页面渲染过程是在服务端完成，最终的 HTML 字符串，直接通过请求发送给客户端。</p>
<p>服务器端渲染的优势就是利于 SEO 优化，首屏加载快，因为客户端接收到的是完整的 HTML 页面。</p>
<h3 id="♥︎-♥︎-♥︎-如何在-Node-js-中操作-MongoDb-数据库"><a href="#♥︎-♥︎-♥︎-如何在-Node-js-中操作-MongoDb-数据库" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何在 Node.js 中操作 MongoDb 数据库"></a>♥︎ ♥︎ ♥︎ 如何在 Node.js 中操作 MongoDb 数据库</h3><h4 id="一、在-Nodejs-中使用-Mongodb"><a href="#一、在-Nodejs-中使用-Mongodb" class="headerlink" title="一、在 Nodejs 中使用 Mongodb"></a>一、在 Nodejs 中使用 Mongodb</h4><p>Nodejs 操作 mongodb 数据库官方文档：</p>
<p><a target="_blank" rel="noopener" href="http://mongodb.github.io/node-mongodb-native/">http://mongodb.github.io/node-mongodb-native/</a></p>
<pre><code class="ini">npm install mongodb --save 
或者
cnpm install mongodb --save 
或者
yarn add mongodb
</code></pre>
<h4 id="二、Nodejs-操作-MongoDb-数据库"><a href="#二、Nodejs-操作-MongoDb-数据库" class="headerlink" title="二、Nodejs 操作 MongoDb 数据库"></a>二、Nodejs 操作 MongoDb 数据库</h4><pre><code class="javascript">// 1 cnpm install mongodb --save

//2、引入mongodb
const &#123; MongoClient &#125; = require(&#39;mongodb&#39;);

//3、定义数据库连接的地址
const url = &#39;mongodb://127.0.0.1:27017&#39;;

//4、定义要操作的数据库
const dbName = &#39;itying&#39;;

//5、实例化MongoClient 传入数据库连接地址
const client = new MongoClient(url, &#123; useUnifiedTopology: true &#125;);

//6、连接数据库 操作数据

client.connect((err) =&gt; &#123;
    if (err) &#123;
        console.log(err);
        return;
    &#125;
    console.log(&quot;数据库连接成功&quot;);

    let db = client.db(dbName);

    // //1、查找数据
    db.collection(&quot;user&quot;).find(&#123;&quot;age&quot;:13&#125;).toArray((err,data)=&gt;&#123;
       if(err)&#123; 
            console.log(err);
            return;
        &#125;
        console.log(data);       
        //操作数据库完毕以后一定要 关闭数据库连接
        client.close();
    &#125;)


    //2、增加数据

    // db.collection(&quot;user&quot;).insertOne(&#123;&quot;username&quot;:&quot;nodejs操作mongodb&quot;,&quot;age&quot;:10&#125;,(err,result)=&gt;&#123;
    //     if(err)&#123; //增加失败
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;增加成功&quot;);
    //     console.log(result);
    //       //操作数据库完毕以后一定要 关闭数据库连接
    //      client.close();

    // &#125;)


    //3、修改数据

    // db.collection(&quot;user&quot;).updateOne(&#123; &quot;name&quot;: &quot;zhangsan&quot; &#125;, &#123; $set: &#123; &quot;age&quot;: 10 &#125; &#125;, (err, result) =&gt; &#123;
    //     if (err) &#123; //修改失败
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;修改成功&quot;);
    //     console.log(result);
    //     //操作数据库完毕以后一定要 关闭数据库连接
    //     client.close();
    // &#125;)


    //4、删除一条数据

    // db.collection(&quot;user&quot;).deleteOne(&#123; &quot;username&quot;: &quot;nodejs&quot; &#125;, (err)=&gt;&#123;

    //     if (err) &#123; 
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;删除一条数据成功&quot;);
    //     client.close();
    // &#125;)

     //5、删除多条数据

    // db.collection(&quot;user&quot;).deleteMany(&#123; &quot;username&quot;: &quot;nodejs&quot; &#125;, (err)=&gt;&#123;

    //     if (err) &#123; 
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;删除多条数据成功&quot;);
    //     client.close();
    // &#125;)

&#125;)
</code></pre>
<h3 id="♥︎-♥︎-♥︎-谈谈-socket-的三种常见使用方式"><a href="#♥︎-♥︎-♥︎-谈谈-socket-的三种常见使用方式" class="headerlink" title="♥︎ ♥︎ ♥︎ 谈谈 socket 的三种常见使用方式"></a>♥︎ ♥︎ ♥︎ 谈谈 socket 的三种常见使用方式</h3><p>第一种方式是 netSocket，主要使用的是 node 中的 net 模块。服务端通过 new net.createServer() 创建服务，使用 on(‘connection’) 方法建立连接，在回调函数中即可获取到客户端发送的信息。客户端通过 new net.Socket() 创建 Socket，通过 connect 连接指定端口和域名后，即可调用 write 方法发送数据</p>
<p>第二种方式是 webSocket，服务端引入第三方插件 ws 创建 socket 服务，客户端使用 H5 新增 API new WebSocket 连接服务端，通过 send 方法发送数据，onmessage 方法接收数据</p>
<p>第三种方式是 socket.io，服务端引入 socket.io’ 模块创建服务，客户端引入 socket.io.js’ 文件，建立连接后，客户端和服务端都是通过 on 方法接收数据，都是使用 emit 方法发送数据。</p>
<h3 id="♥︎-♥︎-♥︎-前后端数据交互的常见使用方式"><a href="#♥︎-♥︎-♥︎-前后端数据交互的常见使用方式" class="headerlink" title="♥︎ ♥︎ ♥︎ 前后端数据交互的常见使用方式"></a>♥︎ ♥︎ ♥︎ 前后端数据交互的常见使用方式</h3><p>cookie：前端可以直接设置或获取 cookie，后端可以使用 req.set(‘set-cookie’， ‘’)设置 cookie，在前端发送请求时通过 req 的 header 字段中获取 cookie</p>
<p>利用 AJAX，和 JQuery 中已经封装好的 $.ajax、$.post、$.getJSON 通过创建一个 XMLHttpRequest 对象，来进行前后端交互。</p>
<p>服务端渲染，浏览器请求到的内容可以通过后端加工一下，将数据直接渲染好，再返回给浏览器。</p>
<h3 id="♥︎-♥︎-♥︎-Node-js-优缺点以及适用场景"><a href="#♥︎-♥︎-♥︎-Node-js-优缺点以及适用场景" class="headerlink" title="♥︎ ♥︎ ♥︎ Node.js 优缺点以及适用场景"></a>♥︎ ♥︎ ♥︎ Node.js 优缺点以及适用场景</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Node.js 采用事件驱动、异步编程，为网络服务而设计。简单易学，可以很快上手做后端设计。</p>
<p>Node.js 非阻塞模式的 IO 处理给 Node.js 带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它 IO 资源的中间层服务。</p>
<p>Node.js 轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>单线程，可靠性低，一旦这个进程崩掉，那么整个 web 服务就崩掉了。</p>
<p>开源组件库质量参差不齐，更新快，向下不兼容</p>
<p>不适合做企业级应用开发，特别是复杂业务逻辑的，代码不好维护，事务支持不是很好。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>大量 Ajax 请求的应用，例如个性化应用，每个用户看到的页面都不一样，需要在页面加载的时候发起Ajax 请求，NodeJS 能响应大量的并发请求。</p>
<p>实时应用：如在线聊天，实时通知推送等等</p>
<p>工具类应用：海量的工具，小到前端压缩部署，大到桌面图形界面应用程序</p>
<p>总而言之，NodeJS 适合运用在高并发、I&#x2F;O 密集、少量业务逻辑的场景。</p>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-process-的理解？有哪些常用方法？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-process-的理解？有哪些常用方法？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 process 的理解？有哪些常用方法？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 process 的理解？有哪些常用方法？</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>process</code> 对象是一个全局变量，提供了有关当前 <code>Node.js </code>进程的信息并对其进行控制，作为一个全局变量</p>
<p>我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器</p>
<p>当我们启动一个<code>js</code>文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享</p>
<p>由于<code>JavaScript</code>是一个单线程语言，所以通过<code>node xxx</code>启动一个文件后，只有一条主线程</p>
<h4 id="二、属性与方法"><a href="#二、属性与方法" class="headerlink" title="二、属性与方法"></a>二、属性与方法</h4><p>关于<code>process</code>常见的属性有如下：</p>
<ul>
<li>process.env：环境变量，例如通过 &#96;process.env.NODE_ENV 获取不同环境项目配置信息</li>
<li>process.nextTick：这个在谈及 <code>EventLoop</code> 时经常为会提到</li>
<li>process.pid：获取当前进程id</li>
<li>process.ppid：当前进程对应的父进程</li>
<li>process.cwd()：获取当前进程工作目录，</li>
<li>process.platform：获取当前进程运行的操作系统平台</li>
<li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li>
<li>进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</li>
<li>三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li>
<li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li>
</ul>
<p>下面再稍微介绍下某些方法的使用：</p>
<h5 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h5><p>返回当前 <code>Node </code>进程执行的目录</p>
<p>一个<code> Node</code> 模块 <code>A</code> 通过 NPM 发布，项目 <code>B</code> 中使用了模块 <code>A</code>。在 <code>A</code> 中需要操作 <code>B</code> 项目下的文件时，就可以用 <code>process.cwd()</code> 来获取 <code>B</code> 项目的路径</p>
<h5 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h5><p>在终端通过 Node 执行命令的时候，通过 <code>process.argv</code> 可以获取传入的命令行参数，返回值是一个数组：</p>
<ul>
<li>0: Node 路径（一般用不到，直接忽略）</li>
<li>1: 被执行的 JS 文件路径（一般用不到，直接忽略）</li>
<li>2~n: 真实传入命令的参数</li>
</ul>
<p>所以，我们只要从 <code>process.argv[2]</code> 开始获取就好了</p>
<pre><code class="ini">const args = process.argv.slice(2);
</code></pre>
<h5 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h5><p>返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。</p>
<p>一般我们会在 <code>process.env</code> 上挂载一些变量标识当前的环境。比如最常见的用 <code>process.env.NODE_ENV</code> 区分 <code>development</code> 和 <code>production</code></p>
<p>在 <code>vue-cli</code> 的源码中也经常会看到 <code>process.env.VUE_CLI_DEBUG</code> 标识当前是不是 <code>DEBUG</code> 模式</p>
<h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h5><p>我们知道<code>NodeJs</code>是基于事件轮询，在这个过程中，同一时间只会处理一件事情</p>
<p>在这种处理模式下，<code>process.nextTick()</code>就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行</p>
<p>例如下面例子将一个<code>foo</code>函数在下一个时间点调用</p>
<pre><code class="js">function foo() &#123;
    console.error(&#39;foo&#39;);
&#125;

process.nextTick(foo);
console.error(&#39;bar&#39;);
</code></pre>
<p>输出结果为<code>bar</code>、<code>foo</code></p>
<p>虽然下述方式也能实现同样效果：</p>
<pre><code class="javascript">setTimeout(foo, 0);
console.log(&#39;bar&#39;);
</code></pre>
<p>两者区别在于：</p>
<ul>
<li>process.nextTick()会在这一次event loop的call stack清空后（下一次event loop开始前）再调用callback</li>
<li>setTimeout()是并不知道什么时候call stack清空的，所以何时调用callback函数是不确定的</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-fs模块的理解-有哪些常用方法"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-fs模块的理解-有哪些常用方法" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 fs模块的理解? 有哪些常用方法"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 fs模块的理解? 有哪些常用方法</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>fs（filesystem），该模块提供本地文件的读写能力，基本上是<code>POSIX</code>文件操作命令的简单包装</p>
<p>可以说，所有与文件的操作都是通过<code>fs</code>核心模块实现</p>
<p>导入模块如下：</p>
<pre><code class="ini">const fs = require(&#39;fs&#39;);
</code></pre>
<p>这个模块对所有文件系统操作提供异步（不具有<code>sync</code> 后缀）和同步（具有 <code>sync</code> 后缀）两种操作方式，而供开发者选择</p>
<h4 id="二、文件知识"><a href="#二、文件知识" class="headerlink" title="二、文件知识"></a>二、文件知识</h4><p>在计算机中有关于文件的知识：</p>
<ul>
<li>权限位 mode</li>
<li>标识位 flag</li>
<li>文件描述为 fd</li>
</ul>
<h5 id="权限位-mode"><a href="#权限位-mode" class="headerlink" title="权限位 mode"></a>权限位 mode</h5><p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34663464343161302d633436622d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位4、2、1，不具备权限为0</p>
<p>如在<code>linux</code>查看文件权限位：</p>
<pre><code class="javascript">drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core
-rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md
</code></pre>
<p>在开头前十位中，<code>d</code>为文件夹，<code>-</code>为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限</p>
<h5 id="标识位"><a href="#标识位" class="headerlink" title="标识位"></a>标识位</h5><p>标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读取文件，如果文件不存在则抛出异常。</td>
</tr>
<tr>
<td>r+</td>
<td>读取并写入文件，如果文件不存在则抛出异常。</td>
</tr>
<tr>
<td>rs</td>
<td>读取并写入文件，指示操作系统绕开本地文件系统缓存。</td>
</tr>
<tr>
<td>w</td>
<td>写入文件，文件不存在会被创建，存在则清空后写入。</td>
</tr>
<tr>
<td>wx</td>
<td>写入文件，排它方式打开。</td>
</tr>
<tr>
<td>w+</td>
<td>读取并写入文件，文件不存在则创建文件，存在则清空后写入。</td>
</tr>
<tr>
<td>wx+</td>
<td>和 w+ 类似，排他方式打开。</td>
</tr>
<tr>
<td>a</td>
<td>追加写入，文件不存在则创建文件。</td>
</tr>
<tr>
<td>ax</td>
<td>与 a 类似，排他方式打开。</td>
</tr>
<tr>
<td>a+</td>
<td>读取并追加写入，不存在则创建。</td>
</tr>
<tr>
<td>ax+</td>
<td>与 a+ 类似，排他方式打开。</td>
</tr>
</tbody></table>
<h5 id="文件描述为-fd"><a href="#文件描述为-fd" class="headerlink" title="文件描述为 fd"></a>文件描述为 fd</h5><p>操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件</p>
<p><code>Window </code>系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，<code>NodeJS </code>抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符</p>
<p>在 <code>NodeJS </code>中，每操作一个文件，文件描述符是递增的，文件描述符一般从 <code>3</code> 开始，因为前面有 <code>0</code>、<code>1</code>、<code>2</code>三个比较特殊的描述符，分别代表 <code>process.stdin</code>（标准输入）、<code>process.stdout</code>（标准输出）和 <code>process.stderr</code>（错误输出）</p>
<h4 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h4><p>下面针对<code>fs</code>模块常用的方法进行展开：</p>
<ul>
<li>文件读取</li>
<li>文件写入</li>
<li>文件追加写入</li>
<li>文件拷贝</li>
<li>创建目录</li>
</ul>
<h5 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h5><h6 id="fs-readFileSync"><a href="#fs-readFileSync" class="headerlink" title="fs.readFileSync"></a>fs.readFileSync</h6><p>同步读取，参数如下：</p>
<ul>
<li>第一个参数为读取文件的路径或文件描述符</li>
<li>第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding</li>
</ul>
<p>结果为返回文件的内容</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

let buf = fs.readFileSync(&quot;1.txt&quot;);
let data = fs.readFileSync(&quot;1.txt&quot;, &quot;utf8&quot;);

console.log(buf); // &lt;Buffer 48 65 6c 6c 6f&gt;
console.log(data); // Hello
</code></pre>
<h6 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile"></a>fs.readFile</h6><p>异步读取方法 <code>readFile</code> 与 <code>readFileSync</code> 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 <code>err</code>（错误）和 <code>data</code>（数据），该方法没有返回值，回调函数在读取文件成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.readFile(&quot;1.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
   if(!err)&#123;
       console.log(data); // Hello
   &#125;
&#125;);
</code></pre>
<h5 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h5><h6 id="writeFileSync"><a href="#writeFileSync" class="headerlink" title="writeFileSync"></a>writeFileSync</h6><p>同步写入，有三个参数：</p>
<ul>
<li>第一个参数为写入文件的路径或文件描述符</li>
<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>
<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>
</ul>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.writeFileSync(&quot;2.txt&quot;, &quot;Hello world&quot;);
let data = fs.readFileSync(&quot;2.txt&quot;, &quot;utf8&quot;);

console.log(data); // Hello world
</code></pre>
<h6 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h6><p>异步写入，<code>writeFile</code> 与 <code>writeFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件写入数据成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.writeFile(&quot;2.txt&quot;, &quot;Hello world&quot;, err =&gt; &#123;
    if (!err) &#123;
        fs.readFile(&quot;2.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
            console.log(data); // Hello world
        &#125;);
    &#125;
&#125;);
</code></pre>
<h5 id="文件追加写入"><a href="#文件追加写入" class="headerlink" title="文件追加写入"></a>文件追加写入</h5><h6 id="appendFileSync"><a href="#appendFileSync" class="headerlink" title="appendFileSync"></a>appendFileSync</h6><p>参数如下：</p>
<ul>
<li>第一个参数为写入文件的路径或文件描述符</li>
<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>
<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>
</ul>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.appendFileSync(&quot;3.txt&quot;, &quot; world&quot;);
let data = fs.readFileSync(&quot;3.txt&quot;, &quot;utf8&quot;);
</code></pre>
<h6 id="appendFile"><a href="#appendFile" class="headerlink" title="appendFile"></a>appendFile</h6><p>异步追加写入方法 <code>appendFile</code> 与 <code>appendFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件追加写入数据成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.appendFile(&quot;3.txt&quot;, &quot; world&quot;, err =&gt; &#123;
    if (!err) &#123;
        fs.readFile(&quot;3.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
            console.log(data); // Hello world
        &#125;);
    &#125;
&#125;);
</code></pre>
<h5 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h5><h6 id="copyFileSync"><a href="#copyFileSync" class="headerlink" title="copyFileSync"></a>copyFileSync</h6><p>同步拷贝</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.copyFileSync(&quot;3.txt&quot;, &quot;4.txt&quot;);
let data = fs.readFileSync(&quot;4.txt&quot;, &quot;utf8&quot;);

console.log(data); // Hello world
</code></pre>
<h6 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h6><p>异步拷贝</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.copyFile(&quot;3.txt&quot;, &quot;4.txt&quot;, () =&gt; &#123;
    fs.readFile(&quot;4.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
        console.log(data); // Hello world
    &#125;);
&#125;);
</code></pre>
<h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><h6 id="mkdirSync"><a href="#mkdirSync" class="headerlink" title="mkdirSync"></a>mkdirSync</h6><p>同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常</p>
<pre><code class="javascript">// 假设已经有了 a 文件夹和 a 下的 b 文件夹
fs.mkdirSync(&quot;a/b/c&quot;)
</code></pre>
<h6 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h6><p>异步创建，第二个参数为回调函数</p>
<pre><code class="javascript">fs.mkdir(&quot;a/b/c&quot;, err =&gt; &#123;
    if (!err) console.log(&quot;创建成功&quot;);
&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-Buffer-的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-Buffer-的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 Buffer 的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 Buffer 的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在<code>Node</code>应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而<code>Buffer</code>就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据</p>
<p>在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量</p>
<p>如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理</p>
<p>这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 <code>RAM</code> 中</p>
<p>简单来讲，<code>Nodejs</code>不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在<code>Buffer</code>中，即在<code>RAM</code>中，直至将它们发送完毕</p>
<p>上面讲到了<code>Buffer</code>是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存8位二进制：<code>00000000</code>，也就是一个字节</p>
<p>例如：</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;why&quot;)
</code></pre>
<p>其存储过程如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32303337313235302d633639632d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h4><p><code>Buffer</code> 类在全局作用域中，无须<code>require</code>导入</p>
<p>创建<code>Buffer</code>的方法有很多种，我们讲讲下面的两种常见的形式：</p>
<ul>
<li>Buffer.from()</li>
<li>Buffer.alloc()</li>
</ul>
<h5 id="Buffer-from"><a href="#Buffer-from" class="headerlink" title="Buffer.from()"></a>Buffer.from()</h5><pre><code class="javascript">const b1 = Buffer.from(&#39;10&#39;);
const b2 = Buffer.from(&#39;10&#39;, &#39;utf8&#39;);
const b3 = Buffer.from([10]);
const b4 = Buffer.from(b3);

console.log(b1, b2, b3, b4); // &lt;Buffer 31 30&gt; &lt;Buffer 31 30&gt; &lt;Buffer 0a&gt; &lt;Buffer 0a&gt;
</code></pre>
<h5 id="Buffer-alloc"><a href="#Buffer-alloc" class="headerlink" title="Buffer.alloc()"></a>Buffer.alloc()</h5><pre><code class="javascript">const bAlloc1 = Buffer.alloc(10); // 创建一个大小为 10 个字节的缓冲区
const bAlloc2 = Buffer.alloc(10, 1); // 建一个长度为 10 的 Buffer,其中全部填充了值为 `1` 的字节
console.log(bAlloc1); // &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;
console.log(bAlloc2); // &lt;Buffer 01 01 01 01 01 01 01 01 01 01&gt;
</code></pre>
<p>在上面创建<code>buffer</code>后，则能够<code>toString</code>的形式进行交互，默认情况下采取<code>utf8</code>字符编码形式，如下</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;你好&quot;);
console.log(buffer);
// &lt;Buffer e4 bd a0 e5 a5 bd&gt;
const str = buffer.toString();
console.log(str);
// 你好
</code></pre>
<p>如果编码与解码不是相同的格式则会出现乱码的情况，如下：</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;你好&quot;,&quot;utf-8 &quot;);
console.log(buffer);
// &lt;Buffer e4 bd a0 e5 a5 bd&gt;
const str = buffer.toString(&quot;ascii&quot;);
console.log(str); 
// d= e%=
</code></pre>
<p>当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下：</p>
<pre><code class="javascript">const buf = Buffer.from(&#39;Node.js 技术栈&#39;, &#39;UTF-8&#39;);

console.log(buf)          // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;
console.log(buf.length)   // 17

console.log(buf.toString(&#39;UTF-8&#39;, 0, 9))  // Node.js �
console.log(buf.toString(&#39;UTF-8&#39;, 0, 11)) // Node.js 技
</code></pre>
<p>所支持的字符集有如下：</p>
<ul>
<li>ascii：仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的</li>
<li>utf8：多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8</li>
<li>utf16le：2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000至 U+10FFFF）</li>
<li>ucs2，utf16le 的别名</li>
<li>base64：Base64 编码</li>
<li>latin：一种把 Buffer 编码成一字节编码的字符串的方式</li>
<li>binary：latin1 的别名，</li>
<li>hex：将每个字节编码为两个十六进制字符</li>
</ul>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p><code>Buffer</code>的应用场景常常与流的概念联系在一起，例如有如下：</p>
<ul>
<li>I&#x2F;O操作</li>
<li>加密解密</li>
<li>zlib.js</li>
</ul>
<h5 id="I-x2F-O操作"><a href="#I-x2F-O操作" class="headerlink" title="I&#x2F;O操作"></a>I&#x2F;O操作</h5><p>通过流的形式，将一个文件的内容读取到另外一个文件</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;);

const inputStream = fs.createReadStream(&#39;input.txt&#39;); // 创建可读流
const outputStream = fs.createWriteStream(&#39;output.txt&#39;); // 创建可写流

inputStream.pipe(outputStream); // 管道读写
</code></pre>
<h5 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h5><p>在一些加解密算法中会遇到使用 <code>Buffer</code>，例如 <code>crypto.createCipheriv</code> 的第二个参数 <code>key</code> 为 <code>string</code> 或 <code>Buffer</code> 类型</p>
<h5 id="zlib-js"><a href="#zlib-js" class="headerlink" title="zlib.js"></a>zlib.js</h5><p><code>zlib.js</code> 为 <code>Node.js</code> 的核心库之一，其利用了缓冲区（<code>Buffer</code>）的功能来操作二进制数据流，提供了压缩或解压功能</p>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-Stream-的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-Stream-的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 Stream 的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 Stream 的理解？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>流（Stream），是一个数据传输手段，是端到端信息交换的一种方式，而且是有顺序的,是逐块读取数据、处理内容，用于顺序读取输入或写入输出</p>
<p><code>Node.js</code>中很多对象都实现了流，总之它是会冒数据（以 <code>Buffer</code> 为单位）</p>
<p>它的独特之处在于，它不像传统的程序那样一次将一个文件读入内存，而是逐块读取数据、处理其内容，而不是将其全部保存在内存中</p>
<p>流可以分成三部分：<code>source</code>、<code>dest</code>、<code>pipe</code></p>
<p>在<code>source</code>和<code>dest</code>之间有一个连接的管道<code>pipe</code>,它的基本语法是<code>source.pipe(dest)</code>，<code>source</code>和<code>dest</code>就是通过pipe连接，让数据从<code>source</code>流向了<code>dest</code>，如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61656330353637302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、种类"><a href="#二、种类" class="headerlink" title="二、种类"></a>二、种类</h4><p>在<code>NodeJS</code>，几乎所有的地方都使用到了流的概念，分成四个种类：</p>
<ul>
<li>可写流：可写入数据的流。例如 fs.createWriteStream() 可以使用流将数据写入文件</li>
<li>可读流： 可读取数据的流。例如fs.createReadStream() 可以从文件读取内容</li>
<li>双工流： 既可读又可写的流。例如 net.Socket</li>
<li>转换流： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据</li>
</ul>
<p>在<code>NodeJS</code>中<code>HTTP</code>服务器模块中，<code>request</code> 是可读流，<code>response</code> 是可写流。还有<code>fs</code> 模块，能同时处理可读和可写文件流</p>
<p>可读流和可写流都是单向的，比较容易理解，而另外两个是双向的</p>
<h5 id="双工流"><a href="#双工流" class="headerlink" title="双工流"></a>双工流</h5><p>之前了解过<code>websocket</code>通信，是一个全双工通信，发送方和接受方都是各自独立的方法，发送和接收都没有任何关系</p>
<p>如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62376163366430302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>基本代码如下：</p>
<pre><code class="javascript">const &#123; Duplex &#125; = require(&#39;stream&#39;);

const myDuplex = new Duplex(&#123;
  read(size) &#123;
    // ...
  &#125;,
  write(chunk, encoding, callback) &#123;
    // ...
  &#125;
&#125;);
</code></pre>
<h5 id="双工流-1"><a href="#双工流-1" class="headerlink" title="双工流"></a>双工流</h5><p>双工流的演示图如下所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63303238383362302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>除了上述压缩包的例子，还比如一个 <code>babel</code>，把<code>es6</code>转换为，我们在左边写入 <code>es6</code>，从右边读取 <code>es5</code></p>
<p>基本代码如下所示：</p>
<pre><code class="javascript">const &#123; Transform &#125; = require(&#39;stream&#39;);

const myTransform = new Transform(&#123;
  transform(chunk, encoding, callback) &#123;
    // ...
  &#125;
&#125;);
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p><code>stream</code>的应用场景主要就是处理<code>IO</code>操作，而<code>http</code>请求和文件操作都属于<code>IO</code>操作</p>
<p>思想一下，如果一次<code>IO</code>操作过大，硬件的开销就过大，而将此次大的<code>IO</code>操作进行分段操作，让数据像水管一样流动，知道流动完成</p>
<p>常见的场景有：</p>
<ul>
<li>get请求返回文件给客户端</li>
<li>文件操作</li>
<li>一些打包工具的底层操作</li>
</ul>
<h5 id="get请求返回文件给客户端"><a href="#get请求返回文件给客户端" class="headerlink" title="get请求返回文件给客户端"></a>get请求返回文件给客户端</h5><p>使用<code>stream</code>流返回文件，<code>res</code>也是一个<code>stream</code>对象，通过<code>pipe</code>管道将文件数据返回</p>
<pre><code class="javascript">const server = http.createServer(function (req, res) &#123;
    const method = req.method; // 获取请求方法
    if (method === &#39;GET&#39;) &#123; // get 请求
        const fileName = path.resolve(__dirname, &#39;data.txt&#39;);
        let stream = fs.createReadStream(fileName);
        stream.pipe(res); // 将 res 作为 stream 的 dest
    &#125;
&#125;);
server.listen(8000);
</code></pre>
<h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><p>创建一个可读数据流<code>readStream</code>，一个可写数据流<code>writeStream</code>，通过<code>pipe</code>管道把数据流转过去</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;)
const path = require(&#39;path&#39;)

// 两个文件名
const fileName1 = path.resolve(__dirname, &#39;data.txt&#39;)
const fileName2 = path.resolve(__dirname, &#39;data-bak.txt&#39;)
// 读取文件的 stream 对象
const readStream = fs.createReadStream(fileName1)
// 写入文件的 stream 对象
const writeStream = fs.createWriteStream(fileName2)
// 通过 pipe执行拷贝，数据流转
readStream.pipe(writeStream)
// 数据读取完成监听，即拷贝完成
readStream.on(&#39;end&#39;, function () &#123;
    console.log(&#39;拷贝完成&#39;)
&#125;)
</code></pre>
<h5 id="一些打包工具的底层操作"><a href="#一些打包工具的底层操作" class="headerlink" title="一些打包工具的底层操作"></a>一些打包工具的底层操作</h5><p>目前一些比较火的前端打包构建工具，都是通过<code>node.js</code>编写的，打包和构建的过程肯定是文件频繁操作的过程，离不来<code>stream</code>，如<code>gulp</code></p>
<h3 id="♥︎-♥︎-♥︎-说说Node中的EventEmitter-如何实现一个EventEmitter"><a href="#♥︎-♥︎-♥︎-说说Node中的EventEmitter-如何实现一个EventEmitter" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说Node中的EventEmitter? 如何实现一个EventEmitter?"></a>♥︎ ♥︎ ♥︎ 说说Node中的EventEmitter? 如何实现一个EventEmitter?</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>我们了解到，<code>Node </code>采用了事件驱动机制，而<code>EventEmitter </code>就是<code>Node</code>实现事件驱动的基础</p>
<p>在<code>EventEmitter</code>的基础上，<code>Node </code>几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作</p>
<p><code>Node.js</code> 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件</p>
<p>这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上</p>
<h4 id="二、使用方法-1"><a href="#二、使用方法-1" class="headerlink" title="二、使用方法"></a>二、使用方法</h4><p><code>Node </code>的<code>events</code>模块只提供了一个<code>EventEmitter</code>类，这个类实现了<code>Node</code>异步事件驱动架构的基本模式——观察者模式</p>
<p>在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们</p>
<p>基本代码如下所示：</p>
<pre><code class="javascript">const EventEmitter = require(&#39;events&#39;)

class MyEmitter extends EventEmitter &#123;&#125;
const myEmitter = new MyEmitter()

function callback() &#123;
    console.log(&#39;触发了event事件！&#39;)
&#125;
myEmitter.on(&#39;event&#39;, callback)
myEmitter.emit(&#39;event&#39;)
myEmitter.removeListener(&#39;event&#39;, callback);
</code></pre>
<p>通过实例对象的<code>on</code>方法注册一个名为<code>event</code>的事件，通过<code>emit</code>方法触发该事件，而<code>removeListener</code>用于取消事件的监听</p>
<p>关于其常见的方法如下：</p>
<ul>
<li>emitter.addListener&#x2F;on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部</li>
<li>emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部</li>
<li>emitter.emit(eventName[, …args])：触发类型为 eventName 的监听事件</li>
<li>emitter.removeListener&#x2F;off(eventName, listener)：移除类型为 eventName 的监听事件</li>
<li>emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除</li>
<li>emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件</li>
</ul>
<h4 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h4><p>通过上面的方法了解，<code>EventEmitter</code>是一个构造函数，内部存在一个包含所有事件的对象</p>
<pre><code class="javascript">class EventEmitter &#123;
    constructor() &#123;
        this.events = &#123;&#125;;
    &#125;
&#125;
</code></pre>
<p>其中<code>events</code>存放的监听事件的函数的结构如下：</p>
<pre><code class="javascript">&#123;
  &quot;event1&quot;: [f1,f2,f3]，
  &quot;event2&quot;: [f4,f5]，
  ...
&#125;
</code></pre>
<p>然后开始一步步实现实例方法，首先是<code>emit</code>，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：</p>
<pre><code class="javascript">emit(type, ...args) &#123;
    this.events[type].forEach((item) =&gt; &#123;
        Reflect.apply(item, this, args);
    &#125;);
&#125;
</code></pre>
<p>当实现了<code>emit</code>方法之后，然后实现<code>on</code>、<code>addListener</code>、<code>prependListener</code>这三个实例方法，都是添加事件监听触发函数，实现也是大同小异</p>
<pre><code class="javascript">on(type, handler) &#123;
    if (!this.events[type]) &#123;
        this.events[type] = [];
    &#125;
    this.events[type].push(handler);
&#125;

addListener(type,handler)&#123;
    this.on(type,handler)
&#125;

prependListener(type, handler) &#123;
    if (!this.events[type]) &#123;
        this.events[type] = [];
    &#125;
    this.events[type].unshift(handler);
&#125;
</code></pre>
<p>紧接着就是实现事件监听的方法<code>removeListener/on</code></p>
<pre><code class="javascript">removeListener(type, handler) &#123;
    if (!this.events[type]) &#123;
        return;
    &#125;
    this.events[type] = this.events[type].filter(item =&gt; item !== handler);
&#125;

off(type,handler)&#123;
    this.removeListener(type,handler)
&#125;
</code></pre>
<p>最后再来实现<code>once</code>方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过<code>fired</code>属性值判断事件函数是否执行过</p>
<pre><code class="javascript">once(type, handler) &#123;
    this.on(type, this._onceWrap(type, handler, this));
  &#125;

  _onceWrap(type, handler, target) &#123;
    const state = &#123; fired: false, handler, type , target&#125;;
    const wrapFn = this._onceWrapper.bind(state);
    state.wrapFn = wrapFn;
    return wrapFn;
  &#125;

  _onceWrapper(...args) &#123;
    if (!this.fired) &#123;
      this.fired = true;
      Reflect.apply(this.handler, this.target, args);
      this.target.off(this.type, this.wrapFn);
    &#125;
 &#125;
</code></pre>
<p>完整代码如下：</p>
<pre><code class="javascript">class EventEmitter &#123;
    constructor() &#123;
        this.events = &#123;&#125;;
    &#125;

    on(type, handler) &#123;
        if (!this.events[type]) &#123;
            this.events[type] = [];
        &#125;
        this.events[type].push(handler);
    &#125;

    addListener(type,handler)&#123;
        this.on(type,handler)
    &#125;

    prependListener(type, handler) &#123;
        if (!this.events[type]) &#123;
            this.events[type] = [];
        &#125;
        this.events[type].unshift(handler);
    &#125;

    removeListener(type, handler) &#123;
        if (!this.events[type]) &#123;
            return;
        &#125;
        this.events[type] = this.events[type].filter(item =&gt; item !== handler);
    &#125;

    off(type,handler)&#123;
        this.removeListener(type,handler)
    &#125;

    emit(type, ...args) &#123;
        this.events[type].forEach((item) =&gt; &#123;
            Reflect.apply(item, this, args);
        &#125;);
    &#125;

    once(type, handler) &#123;
        this.on(type, this._onceWrap(type, handler, this));
    &#125;

    _onceWrap(type, handler, target) &#123;
        const state = &#123; fired: false, handler, type , target&#125;;
        const wrapFn = this._onceWrapper.bind(state);
        state.wrapFn = wrapFn;
        return wrapFn;
    &#125;

    _onceWrapper(...args) &#123;
        if (!this.fired) &#123;
            this.fired = true;
            Reflect.apply(this.handler, this.target, args);
            this.target.off(this.type, this.wrapFn);
        &#125;
    &#125;
&#125;
</code></pre>
<p>测试代码如下：</p>
<pre><code class="javascript">const ee = new EventEmitter();// 注册所有事件ee.once(&#39;wakeUp&#39;, (name) =&gt; &#123; console.log(`$&#123;name&#125; 1`); &#125;);ee.on(&#39;e
</code></pre>
<h3 id="♥︎-♥︎-♥︎-说说-Node-文件查找的优先级以及-Require-方法的文件查找策略"><a href="#♥︎-♥︎-♥︎-说说-Node-文件查找的优先级以及-Require-方法的文件查找策略" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?"></a>♥︎ ♥︎ ♥︎ 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?</h3><h4 id="一、模块规范"><a href="#一、模块规范" class="headerlink" title="一、模块规范"></a>一、模块规范</h4><p><code>NodeJS</code>对<code>CommonJS</code>进行了支持和实现，让我们在开发<code>node</code>的过程中可以方便的进行模块化开发：</p>
<ul>
<li>在Node中每一个js文件都是一个单独的模块</li>
<li>模块中包括CommonJS规范的核心变量：exports、module.exports、require</li>
<li>通过上述变量进行模块化开发</li>
</ul>
<p>而模块化的核心是导出与导入，在<code>Node</code>中通过<code>exports</code>与<code>module.exports</code>负责对模块中的内容进行导出，通过<code>require</code>函数导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</p>
<h4 id="二、查找策略"><a href="#二、查找策略" class="headerlink" title="二、查找策略"></a>二、查找策略</h4><p><code>require</code>方法接收一下几种参数的传递：</p>
<ul>
<li>原生模块：http、fs、path等</li>
<li>相对路径的文件模块：.&#x2F;mod或..&#x2F;mod</li>
<li>绝对路径的文件模块：&#x2F;pathtomodule&#x2F;mod</li>
<li>目录作为模块：.&#x2F;dirname</li>
<li>非原生模块的文件模块：mod</li>
</ul>
<p><code>require</code>参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33336165386566302d633962612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会优先从缓存中加载已经存在的模块</p>
<h5 id="原生模块"><a href="#原生模块" class="headerlink" title="原生模块"></a>原生模块</h5><p>而像原生模块这些，通过<code>require </code>方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载</p>
<h5 id="绝对路径、相对路径"><a href="#绝对路径、相对路径" class="headerlink" title="绝对路径、相对路径"></a>绝对路径、相对路径</h5><p>如果<code>require</code>绝对路径的文件，则直接查找对应的路径，速度最快</p>
<p>相对路径的模块则相对于当前调用<code>require</code>的文件去查找</p>
<p>如果按确切的文件名没有找到模块，则 <code>NodeJs</code> 会尝试带上 <code>.js</code>、<code>.json </code>或 <code>.node </code>拓展名再加载</p>
<h5 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h5><p>默认情况是根据根目录中<code>package.json</code>文件的<code>main</code>来指定目录模块，如：</p>
<pre><code class="javascript">&#123; &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;main.js&quot; &#125;
</code></pre>
<p>如果这是在<code>./some-library node_modules</code>目录中，则 <code>require(&#39;./some-library&#39;)</code> 会试图加载 <code>./some-library/main.js</code></p>
<p>如果目录里没有 <code>package.json</code>文件，或者 <code>main</code>入口不存在或无法解析，则会试图加载目录下的 <code>index.js</code> 或 <code>index.node</code> 文件</p>
<h5 id="非原生模块"><a href="#非原生模块" class="headerlink" title="非原生模块"></a>非原生模块</h5><p>在每个文件中都存在<code>module.paths</code>，表示模块的搜索路径，<code>require</code>就是根据其来寻找文件</p>
<p>在<code>window</code>下输出如下：</p>
<pre><code class="javascript">[ &#39;c:\\nodejs\\node_modules&#39;,
&#39;c:\\node_modules&#39; ]
</code></pre>
<p>可以看出<code>module path</code>的生成规则为：从当前文件目录开始查找<code>node_modules</code>目录；然后依次进入父目录，查找父目录下的<code>node_modules</code>目录，依次迭代，直到根目录下的<code>node_modules</code>目录</p>
<p>当都找不到的时候，则会从系统<code>NODE_PATH</code>环境变量查找</p>
<h5 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h5><p>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ul>
<li>&#x2F;home&#x2F;ry&#x2F;projects&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;home&#x2F;ry&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;home&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;node_modules&#x2F;bar.js</li>
</ul>
<p>这使得程序本地化它们的依赖，避免它们产生冲突</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面模块的文件查找策略之后，总结下文件查找的优先级：</p>
<ul>
<li>缓存的模块优先级最高</li>
<li>如果是内置模块，则直接返回，优先级仅次缓存的模块</li>
<li>如果是绝对路径 &#x2F; 开头，则从根目录找</li>
<li>如果是相对路径 .&#x2F;开头，则从当前require文件相对位置找</li>
<li>如果文件没有携带后缀，先从js、json、node按顺序查找</li>
<li>如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js</li>
<li>如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何实现jwt鉴权机制？说说你的思路"><a href="#♥︎-♥︎-♥︎-如何实现jwt鉴权机制？说说你的思路" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何实现jwt鉴权机制？说说你的思路"></a>♥︎ ♥︎ ♥︎ 如何实现jwt鉴权机制？说说你的思路</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>JWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30353239303463302d636438392d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在目前前后端分离的开发过程中，使用<code>token</code>鉴权机制用于身份验证是最常见的方案，流程如下：</p>
<ul>
<li>服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证</li>
<li>后续访问会根据这个令牌判断用户时候有权限进行访问</li>
</ul>
<p><code>Token</code>，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以<code>.</code>进行拼接。其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31313735663939302d636438392d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="header"><a href="#header" class="headerlink" title="header"></a>header</h5><p>每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为<code>alg</code>，同时还有一个<code>typ</code>的字段，默认<code>JWT</code>即可。以下示例中算法为HS256</p>
<pre><code class="javascript">&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot; &#125; 
</code></pre>
<p>因为JWT是字符串，所以我们还需要对以上内容进行Base64编码，编码后字符串如下：</p>
<pre><code class="ini">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9        
</code></pre>
<h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p>载荷即消息体，这里会存放实际的内容，也就是<code>Token</code>的数据声明，例如用户的<code>id</code>和<code>name</code>，默认情况下也会携带令牌的签发时间<code>iat</code>，通过还可以设置过期时间，如下：</p>
<pre><code class="javascript">&#123;
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;iat&quot;: 1516239022
&#125;
</code></pre>
<p>同样进行Base64编码后，字符串如下：</p>
<pre><code class="ini">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
</code></pre>
<h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>签名是对头部和载荷内容进行签名，一般情况，设置一个<code>secretKey</code>，对前两个的结果进行<code>HMACSHA25</code>算法，公式如下：</p>
<pre><code class="javascript">Signature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)
</code></pre>
<p>一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致</p>
<h4 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p><code>Token</code>的使用分成了两部分：</p>
<ul>
<li>生成token：登录成功的时候，颁发token</li>
<li>验证token：访问某些资源或者接口时，验证token</li>
</ul>
<h5 id="生成-token"><a href="#生成-token" class="headerlink" title="生成 token"></a>生成 token</h5><p>借助第三方库<code>jsonwebtoken</code>，通过<code>jsonwebtoken</code> 的 <code>sign</code> 方法生成一个 <code>token</code>：</p>
<ul>
<li>第一个参数指的是 Payload</li>
<li>第二个是秘钥，服务端特有</li>
<li>第三个参数是 option，可以定义 token 过期时间</li>
</ul>
<pre><code class="javascript">const crypto = require(&quot;crypto&quot;),
  jwt = require(&quot;jsonwebtoken&quot;);
// TODO:使用数据库
// 这里应该是用数据库存储，这里只是演示用
let userList = [];

class UserController &#123;
  // 用户登录
  static async login(ctx) &#123;
    const data = ctx.request.body;
    if (!data.name || !data.password) &#123;
      return ctx.body = &#123;
        code: &quot;000002&quot;, 
        message: &quot;参数不合法&quot;
      &#125;
    &#125;
    const result = userList.find(item =&gt; item.name === data.name &amp;&amp; item.password === crypto.createHash(&#39;md5&#39;).update(data.password).digest(&#39;hex&#39;))
    if (result) &#123;
      // 生成token
      const token = jwt.sign(  
        &#123;
          name: result.name
        &#125;,
        &quot;test_token&quot;, // secret
        &#123; expiresIn: 60 * 60 &#125; // 过期时间：60 * 60 s
      );
      return ctx.body = &#123;
        code: &quot;0&quot;,
        message: &quot;登录成功&quot;,
        data: &#123;
          token
        &#125;
      &#125;;
    &#125; else &#123;
      return ctx.body = &#123;
        code: &quot;000002&quot;,
        message: &quot;用户名或密码错误&quot;
      &#125;;
    &#125;
  &#125;
&#125;

module.exports = UserController;
</code></pre>
<p>在前端接收到<code>token</code>后，一般情况会通过<code>localStorage</code>进行缓存，然后将<code>token</code>放到<code>HTTP </code>请求头<code>Authorization</code> 中，关于<code>Authorization</code> 的设置，前面要加上 Bearer ，注意后面带有空格</p>
<pre><code class="javascript">axios.interceptors.request.use(config =&gt; &#123;
  const token = localStorage.getItem(&#39;token&#39;);
  config.headers.common[&#39;Authorization&#39;] = &#39;Bearer &#39; + token; // 留意这里的 Authorization
  return config;
&#125;)
</code></pre>
<h5 id="校验token"><a href="#校验token" class="headerlink" title="校验token"></a>校验token</h5><p>使用 <code>koa-jwt</code> 中间件进行验证，方式比较简单</p>
<pre><code class="javascript">/ 注意：放在路由前面
app.use(koajwt(&#123;
  secret: &#39;test_token&#39;
&#125;).unless(&#123; // 配置白名单
  path: [/\/api\/register/, /\/api\/login/]
&#125;))
</code></pre>
<ul>
<li>secret 必须和 sign 时候保持一致</li>
<li>可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆&#x2F;注册都可以不用校验</li>
<li>校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验</li>
</ul>
<p>获取<code>token</code>用户的信息方法如下：</p>
<pre><code class="javascript">router.get(&#39;/api/userInfo&#39;,async (ctx,next) =&gt;&#123;    const authorization =  ctx.header.authorization // 获取jwt    const token = authorization.replace(&#39;Beraer &#39;,&#39;&#39;)    const result = jwt.verify(token,&#39;test_token&#39;)    ctx.body = result
</code></pre>
<p>注意：上述的<code>HMA256</code>加密算法为单秘钥的形式，一旦泄露后果非常的危险</p>
<p>在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌</p>
<p>这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择<code>RS256</code></p>
<h4 id="三、优缺点"><a href="#三、优缺点" class="headerlink" title="三、优缺点"></a>三、优缺点</h4><p>优点：</p>
<ul>
<li>json具有通用性，所以可以跨语言</li>
<li>组成简单，字节占用小，便于传输</li>
<li>服务端无需保存会话信息，很容易进行水平扩展</li>
<li>一处生成，多处使用，可以在分布式系统中，解决单点登录问题</li>
<li>可防护CSRF攻击</li>
</ul>
<p>缺点：</p>
<ul>
<li>payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息</li>
<li>需要保护好加密密钥，一旦泄露后果不堪设想</li>
<li>为避免token被劫持，最好使用https协议</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何实现文件上传？说说你的思路"><a href="#♥︎-♥︎-♥︎-如何实现文件上传？说说你的思路" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何实现文件上传？说说你的思路"></a>♥︎ ♥︎ ♥︎ 如何实现文件上传？说说你的思路</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能</p>
<p>因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里</p>
<p>对于文件上传，我们需要设置请求头为<code>content-type:multipart/form-data</code></p>
<blockquote>
<p>multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件</p>
</blockquote>
<p>结构如下：</p>
<pre><code class="http">POST /t2/upload.do HTTP/1.1
User-Agent: SOHUWapRebot
Accept-Language: zh-cn,zh;q=0.5
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Content-Length: 60408
Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Host: w.sohu.com

--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data; name=&quot;city&quot;

Santa colo
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name=&quot;desc&quot;
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
 
...
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name=&quot;pic&quot;; filename=&quot;photo.jpg&quot;
Content-Type: application/octet-stream
Content-Transfer-Encoding: binary
 
... binary data of the jpg ...
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--
</code></pre>
<p><code>boundary</code>表示分隔符，如果要上传多个表单项，就要使用<code>boundary</code>分割，每个表单项由<code>———XXX</code>开始，以<code>———XXX</code>结尾</p>
<p>而<code>xxx</code>是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现</p>
<p>每个表单项必须包含一个 <code>Content-Disposition</code> 头，其他的头信息则为可选项， 比如 <code>Content-Type</code></p>
<p><code>Content-Disposition</code> 包含了 <code>type </code>和 一个名字为<code>name</code>的 <code>parameter</code>，<code>type</code> 是 <code>form-data</code>，<code>name </code>参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 <code>filename </code>参数，值就是文件名</p>
<pre><code class="javascript">Content-Disposition: form-data; name=&quot;user&quot;; filename=&quot;logo.png&quot;
</code></pre>
<p>至于使用<code>multipart/form-data</code>，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高</p>
<h4 id="二、如何实现-1"><a href="#二、如何实现-1" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>关于文件的上传的上传，我们可以分成两步骤：</p>
<ul>
<li>文件的上传</li>
<li>文件的解析</li>
</ul>
<h5 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h5><p>传统前端文件上传的表单结构如下：</p>
<pre><code class="html">&lt;form action=&quot;http://localhost:8080/api/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; value=&quot;&quot; multiple=&quot;multiple&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;
action` 就是我们的提交到的接口，`enctype=&quot;multipart/form-data&quot;` 就是指定上传文件格式，`input` 的 `name` 属性一定要等于`file
</code></pre>
<h5 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h5><p>在服务器中，这里采用<code>koa2</code>中间件的形式解析上传的文件数据，分别有下面两种形式：</p>
<ul>
<li>koa-body</li>
<li>koa-multer</li>
</ul>
<h5 id="koa-body"><a href="#koa-body" class="headerlink" title="koa-body"></a>koa-body</h5><p>安装依赖</p>
<pre><code class="nginx">npm install koa-body
</code></pre>
<p>引入<code>koa-body</code>中间件</p>
<pre><code class="javascript">const koaBody = require(&#39;koa-body&#39;);
app.use(koaBody(&#123;
    multipart: true,
    formidable: &#123;
        maxFileSize: 200*1024*1024    // 设置上传文件大小最大限制，默认2M
    &#125;
&#125;));
</code></pre>
<p>获取上传的文件</p>
<pre><code class="javascript">const file = ctx.request.files.file; // 获取上传文件
</code></pre>
<p>获取文件数据后，可以通过<code>fs</code>模块将文件保存到指定目录</p>
<pre><code class="javascript">router.post(&#39;/uploadfile&#39;, async (ctx, next) =&gt; &#123;
  // 上传单个文件
  const file = ctx.request.files.file; // 获取上传文件
  // 创建可读流
  const reader = fs.createReadStream(file.path);
  let filePath = path.join(__dirname, &#39;public/upload/&#39;) + `/$&#123;file.name&#125;`;
  // 创建可写流
  const upStream = fs.createWriteStream(filePath);
  // 可读流通过管道写入可写流
  reader.pipe(upStream);
  return ctx.body = &quot;上传成功！&quot;;
&#125;);
</code></pre>
<h5 id="koa-multer"><a href="#koa-multer" class="headerlink" title="koa-multer"></a>koa-multer</h5><p>安装依赖：</p>
<pre><code class="ini">npm install koa-multer
</code></pre>
<p>使用 <code>multer</code> 中间件实现文件上传</p>
<pre><code class="javascript">const storage = multer.diskStorage(&#123;  destination: (req, file, cb) =&gt; &#123;    cb(null, &quot;./upload/&quot;)  &#125;,  filename: (req, file, cb) =&gt; &#123;    cb(null, Date.now() + path.extname(file.originalname))  &#125;&#125;)
const upload = multer(&#123;  storage&#125;);
const fileRouter = new Router();
fileRouter.post(&quot;/upload&quot;, upload.single(&#39;file&#39;), (ctx, next) =&gt; &#123;  console.log(ctx.req.file); // 获取文件&#125;)app.use(fileRouter.routes());
</code></pre>
<h3 id="♥︎-♥︎-♥︎-如果让你来设计一个分页功能-你会怎么设计-前后端如何交互"><a href="#♥︎-♥︎-♥︎-如果让你来设计一个分页功能-你会怎么设计-前后端如何交互" class="headerlink" title="♥︎ ♥︎ ♥︎ 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?"></a>♥︎ ♥︎ ♥︎ 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在我们做数据查询的时候，如果数据量很大，比如几万条数据，放在一个页面显示的话显然不友好，这时候就需要采用分页显示的形式，如每次只显示10条数据</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36303730653863302d636631342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>要实现分页功能，实际上就是从结果集中显示第1<del>10条记录作为第1页,显示第11</del>20条记录作为第2页，以此类推</p>
<p>因此，分页实际上就是从结果集中截取出第M~N条记录</p>
<h4 id="二、如何实现-2"><a href="#二、如何实现-2" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>前端实现分页功能，需要后端返回必要的数据，如总的页数，总的数据量，当前页，当前的数据</p>
<pre><code class="javascript">&#123;
 &quot;totalCount&quot;: 1836,   // 总的条数
 &quot;totalPages&quot;: 92,  // 总页数
 &quot;currentPage&quot;: 1   // 当前页数
 &quot;data&quot;: [     // 当前页的数据
   &#123;
 ...
   &#125;
]
</code></pre>
<p>后端采用<code>mysql</code>作为数据的持久性存储</p>
<p>前端向后端发送目标的页码<code>page</code>以及每页显示数据的数量<code>pageSize</code>，默认情况每次取10条数据，则每一条数据的起始位置<code>start</code>为：</p>
<pre><code class="javascript">const start = (page - 1) * pageSize
</code></pre>
<p>当确定了<code>limit</code>和<code>start</code>的值后，就能够确定<code>SQL</code>语句：</p>
<pre><code class="javascript">const sql = `SELECT * FROM record limit $&#123;pageSize&#125; OFFSET $&#123;start&#125;;`
</code></pre>
<p>上诉<code>SQL</code>语句表达的意思为：截取从<code>start</code>到<code>start</code>+<code>pageSize</code>之间（左闭右开）的数据</p>
<p>关于查询数据总数的<code>SQL</code>语句为，<code>record</code>为表名：</p>
<pre><code class="javascript">SELECT COUNT(*) FROM record
</code></pre>
<p>因此后端的处理逻辑为：</p>
<ul>
<li>获取用户参数页码数page和每页显示的数目 pageSize ，其中page 是必须传递的参数，pageSize为可选参数，默认为10</li>
<li>编写 SQL 语句，利用 limit 和 OFFSET 关键字进行分页查询</li>
<li>查询数据库，返回总数据量、总页数、当前页、当前页数据给前端</li>
</ul>
<p>代码如下所示：</p>
<pre><code class="javascript">router.all(&#39;/api&#39;, function (req, res, next) &#123;
  var param = &#39;&#39;;
  // 获取参数
  if (req.method == &quot;POST&quot;) &#123;
    param = req.body;
  &#125; else &#123;
    param = req.query || req.params;
  &#125;
  if (param.page == &#39;&#39; || param.page == null || param.page == undefined) &#123;
    res.end(JSON.stringify(&#123; msg: &#39;请传入参数page&#39;, status: &#39;102&#39; &#125;));
    return;
  &#125;
  const pageSize = param.pageSize || 10;
  const start = (param.page - 1) * pageSize;
  const sql = `SELECT * FROM record limit $&#123;pageSize&#125; OFFSET $&#123;start&#125;;`
  pool.getConnection(function (err, connection) &#123;
    if (err) throw err;
    connection.query(sql, function (err, results) &#123;
      connection.release();
      if (err) &#123;
        throw err
      &#125; else &#123;
        // 计算总页数
        var allCount = results[0][0][&#39;COUNT(*)&#39;];
        var allPage = parseInt(allCount) / 20;
        var pageStr = allPage.toString();
        // 不能被整除
        if (pageStr.indexOf(&#39;.&#39;) &gt; 0) &#123;
          allPage = parseInt(pageStr.split(&#39;.&#39;)[0]) + 1;
        &#125;
        var list = results[1];
        res.end(JSON.stringify(&#123; msg: &#39;操作成功&#39;, status: &#39;200&#39;, totalPages: allPage, currentPage: param.page, totalCount: allCount, data: list &#125;));
      &#125;
    &#125;)
  &#125;)
&#125;);
</code></pre>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面的分析，可以看到分页查询的关键在于，要首先确定每页显示的数量<code>pageSize</code>，然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p>
<ul>
<li>LIMIT 总是设定为 pageSize</li>
<li>OFFSET 计算公式为 pageSize * (pageIndex - 1)</li>
</ul>
<p>确定了这两个值，就能查询出第 <code>N</code>页的数据</p>
<hr>
<h3 id="♥︎-♥︎-♥︎-♥︎-koa-中间件的实现原理"><a href="#♥︎-♥︎-♥︎-♥︎-koa-中间件的实现原理" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎  koa 中间件的实现原理"></a>♥︎ ♥︎ ♥︎ ♥︎  koa 中间件的实现原理</h3><p>每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next 函数。只要调用 next函数，就可以把执行权转交给下一个中间件。</p>
<p>如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。</p>
<p>多个中间件会形成一个栈结构，以“先进后出”的顺序执行。整个过程就像，先是入栈，然后出栈的操作。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-图片上传到服务器的过程"><a href="#♥︎-♥︎-♥︎-♥︎-图片上传到服务器的过程" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 图片上传到服务器的过程"></a>♥︎ ♥︎ ♥︎ ♥︎ 图片上传到服务器的过程</h3><h4 id="前端业务"><a href="#前端业务" class="headerlink" title="前端业务"></a>前端业务</h4><p>根据后台接口发送请求，图片作为参数，需要带上一个 name 字段</p>
<h4 id="后台业务"><a href="#后台业务" class="headerlink" title="后台业务"></a>后台业务</h4><p>后台接收图片可以使用 ndoe 的 fs、path 文件系统加上 multer 的 npm 包实现。主要思想是通过multer 创建一个临时空间用来接收并存储前端发送过来的二进制图片数据。通过 fs 模块读取临时空间的数据，并使用 pipe 方法注入到 fs 模块创建 path 模块指向的服务器文件夹下</p>
<p>后台代码试例，express 环境</p>
<pre><code class="javascript">var express = require(&#39;express&#39;)
var router = express.Router()
var fs = require(&#39;fs&#39;)
var path = require(&#39;path&#39;)
/* 用于处理非表单的文件数据流 */
var multer = require(&#39;multer&#39;)
// 配置数据流向的文件,绝对路径，相对于根目录
var upload = multer(&#123; dest: &#39;upload/&#39; &#125;)
// 创建一个接收为编码的二进制数据流的方法实例 接收 name 为 newimg 字段的上传文件，最大接收
为 1
var cpUpload = upload.fields([&#123; name: &#39;newimg&#39;, maxCount: 1 &#125;])
// 接口
router.post(&#39;/add&#39;, cpUpload, (req, res) =&gt; &#123;
 // 前端发送请求后，服务器已经接受到了前端传递过来的图片数据，保存在 files 对象下
 // 加上 cpUpload，数据就会从这个方法所设置的地址流过来，生成一个本地临时空间，类似于虚拟
DOM
 // 获取这段数据
 var img = req.files.newimg[0]
 
 // fs 模块读取临时空间的数据 
 var readStream = fs.createReadStream(img.path) 
 // 设置图片存入的路径，并给文件名前面加上一个时间轴，防止命名重复 
 var imgpath = `/cdn/$&#123;Date.now()&#125;-$&#123;img.originalname&#125;` 
 // 创建一个写入图片数据的地址 
 var writeStram = fs.createWriteStream( path.resolve(__dirname, `../public$&#123;imgpath&#125;`) )
 // 设置一个 pipe 管道，将读取的数据解析并注入到写入地址 
 readStream.pipe(writeStram) 
 // 监听注入地址的 close 事件，表示注入完毕 
 writeStram.on(&#39;close&#39;, () =&gt; &#123; 
   // 返回给前端一个图片地址 
   res.json(&#123; err: 0, msg: &#39;success&#39;, data: &#123; img: imgpath &#125; &#125;) &#125;)
   &#125;)
module.exports = router
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-koa-和-express-的区别"><a href="#♥︎-♥︎-♥︎-♥︎-koa-和-express-的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ koa 和 express 的区别"></a>♥︎ ♥︎ ♥︎ ♥︎ koa 和 express 的区别</h3><p>最大的区别在于语法，experss 的异步采用的是回调函数的形式，而 koa1 支持 generator + yeild，koa2 支持 await&#x2F;async，无疑更加优雅。</p>
<p>中间件的区别：koa 采用洋葱模型，进行顺序执行，出去反向执行，支持 context 传递数据 。express 本身无洋葱模型，需要引入插件，不支持 context express 的中间件中执行异步函数，执行顺序不会按照洋葱模型，异步的执行结果有可能被放到最后，response 之前。 这是由于，其中间件执行机制，递归回调中没有等待中间件中的异步函数执行完毕，就是没有 await 中间件异步函数</p>
<p>集成度区别：express 内置了很多中间件，集成度高，使用省心， koa 轻量简洁，容易定制</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-了解-eggjs-吗？"><a href="#♥︎-♥︎-♥︎-♥︎-了解-eggjs-吗？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 了解 eggjs 吗？"></a>♥︎ ♥︎ ♥︎ ♥︎ 了解 eggjs 吗？</h3><p>eggjs 的特性 提供基于 Egg 定制上层框架的能力 高度可扩展的插件机制 内置多进程管理 基于 Koa 开发，性能优异 框架稳定，测试覆盖率高 渐进式开发</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-说说对Nodejs中的事件循环机制理解"><a href="#♥︎-♥︎-♥︎-♥︎-说说对Nodejs中的事件循环机制理解" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说说对Nodejs中的事件循环机制理解?"></a>♥︎ ♥︎ ♥︎ ♥︎ 说说对Nodejs中的事件循环机制理解?</h3><h4 id="一、是什么-9"><a href="#一、是什么-9" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在浏览器事件循环中，我们了解到<code>javascript</code>在浏览器中的事件循环机制，其是根据<code>HTML5</code>定义的规范来实现</p>
<p>而在<code>NodeJS</code>中，事件循环是基于<code>libuv</code>实现，<code>libuv</code>是一个多平台的专注于异步IO的库，如下图最右侧所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613639306239302d633930652d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>上图<code>EVENT_QUEUE</code> 给人看起来只有一个队列，但<code>EventLoop</code>存在6个阶段，每个阶段都有对应的一个先进先出的回调队列</p>
<h4 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h4><p>上节讲到事件循环分成了六个阶段，对应如下：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326533346438302d633930652d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<ul>
<li>timers阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li>
<li>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数</li>
<li>I&#x2F;O事件回调阶段(I&#x2F;O callbacks)：执行延迟到下一个循环迭代的 I&#x2F;O 回调，即上一轮循环中未被执行的一些I&#x2F;O回调</li>
<li>闲置阶段(idle, prepare)：仅系统内部使用</li>
<li>轮询阶段(poll)：检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞</li>
<li>检查阶段(check)：setImmediate() 回调函数在这里执行</li>
<li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)</li>
</ul>
<p>每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段</p>
<p>除了上述6个阶段，还存在<code>process.nextTick</code>，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队</p>
<p>流程图如下所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66626537333164302d633930652d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在<code>Node</code>中，同样存在宏任务和微任务，与浏览器中的事件循环相似</p>
<p>微任务对应有：</p>
<ul>
<li>next tick queue：process.nextTick</li>
<li>other queue：Promise的then回调、queueMicrotask</li>
</ul>
<p>宏任务对应有：</p>
<ul>
<li>timer queue：setTimeout、setInterval</li>
<li>poll queue：IO事件</li>
<li>check queue：setImmediate</li>
<li>close queue：close事件</li>
</ul>
<p>其执行顺序为：</p>
<ul>
<li>next tick microtask queue</li>
<li>other microtask queue</li>
<li>timer queue</li>
<li>poll queue</li>
<li>check queue</li>
<li>close queue</li>
</ul>
<h4 id="三、题目"><a href="#三、题目" class="headerlink" title="三、题目"></a>三、题目</h4><p>通过上面的学习，下面开始看看题目</p>
<pre><code class="javascript">async function async1() &#123;
    console.log(&#39;async1 start&#39;)
    await async2()
    console.log(&#39;async1 end&#39;)
&#125;

async function async2() &#123;
    console.log(&#39;async2&#39;)
&#125;

console.log(&#39;script start&#39;)

setTimeout(function () &#123;
    console.log(&#39;setTimeout0&#39;)
&#125;, 0)

setTimeout(function () &#123;
    console.log(&#39;setTimeout2&#39;)
&#125;, 300)

setImmediate(() =&gt; console.log(&#39;setImmediate&#39;));

process.nextTick(() =&gt; console.log(&#39;nextTick1&#39;));

async1();

process.nextTick(() =&gt; console.log(&#39;nextTick2&#39;));

new Promise(function (resolve) &#123;
    console.log(&#39;promise1&#39;)
    resolve();
    console.log(&#39;promise2&#39;)
&#125;).then(function () &#123;
    console.log(&#39;promise3&#39;)
&#125;)

console.log(&#39;script end&#39;)
</code></pre>
<p>分析过程：</p>
<ul>
<li>先找到同步任务，输出script start</li>
<li>遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</li>
<li>遇到第二个 setTimeout，300ms后将里面的回调函数放到 timer 队列中</li>
<li>遇到第一个setImmediate，将里面的回调函数放到 check 队列中</li>
<li>遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</li>
<li>执行 async1函数，输出 async1 start</li>
<li>执行 async2 函数，输出 async2，async2 后面的输出 async1 end进入微任务，等待下一轮的事件循环</li>
<li>遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行</li>
<li>遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</li>
<li>then里面的回调函数进入微任务队列</li>
<li>遇到同步任务，输出 script end</li>
<li>执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</li>
<li>然后执行微任务队列，依次输出 async1 end、promise3</li>
<li>执行timer 队列，依次输出 setTimeout0</li>
<li>接着执行 check 队列，依次输出 setImmediate</li>
<li>300ms后，timer 队列存在任务，执行输出 setTimeout2</li>
</ul>
<p>执行结果如下：</p>
<pre><code class="javascript">script start
async1 start
async2
promise1
promise2
script end
nextTick1
nextTick2
async1 end
promise3
setTimeout0
setImmediate
setTimeout2
</code></pre>
<p>最后有一道是关于<code>setTimeout</code>与<code>setImmediate</code>的输出顺序</p>
<pre><code class="javascript">setTimeout(() =&gt; &#123;
  console.log(&quot;setTimeout&quot;);
&#125;, 0);

setImmediate(() =&gt; &#123;
  console.log(&quot;setImmediate&quot;);
&#125;);
</code></pre>
<p>输出情况如下：</p>
<pre><code class="javascript">情况一：
setTimeout
setImmediate

情况二：
setImmediate
setTimeout
</code></pre>
<p>分析下流程：</p>
<ul>
<li>外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段</li>
<li>遇到<code>setTimeout</code>，虽然设置的是0毫秒触发，但实际上会被强制改成1ms，时间到了然后塞入<code>times</code>阶段</li>
<li>遇到<code>setImmediate</code>塞入<code>check</code>阶段</li>
<li>同步代码执行完毕，进入Event Loop</li>
<li>先进入<code>times</code>阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足<code>setTimeout</code>条件，执行回调，如果没过1毫秒，跳过</li>
<li>跳过空的阶段，进入check阶段，执行<code>setImmediate</code>回调</li>
</ul>
<p>这里的关键在于这1ms，如果同步代码执行时间较长，进入<code>Event Loop</code>的时候1毫秒已经过了，<code>setTimeout</code>先执行，如果1毫秒还没到，就先执行了<code>setImmediate</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-说说对中间件概念的理解，如何封装-node-中间件？"><a href="#♥︎-♥︎-♥︎-♥︎-说说对中间件概念的理解，如何封装-node-中间件？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说说对中间件概念的理解，如何封装 node 中间件？"></a>♥︎ ♥︎ ♥︎ ♥︎ 说说对中间件概念的理解，如何封装 node 中间件？</h3><h4 id="一、是什么-10"><a href="#一、是什么-10" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的</p>
<p>在<code>NodeJS</code>中，中间件主要是指封装<code>http</code>请求细节处理的方法</p>
<p>例如在<code>express</code>、<code>koa</code>等<code>web</code>框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36613665643366302d636365342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作</p>
<h4 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h4><p><code>koa</code>是基于<code>NodeJS</code>当前比较流行的<code>web</code>框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。通过添加不同的中间件，实现不同的需求，从而构建一个 <code>Koa</code> 应用</p>
<p><code>Koa</code> 中间件采用的是洋葱圈模型，每次执行下一个中间件传入两个参数：</p>
<ul>
<li>ctx ：封装了request 和 response 的变量</li>
<li>next ：进入下一个要执行的中间件的函数</li>
</ul>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353037623032302d636365342d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>下面就针对<code>koa</code>进行中间件的封装：</p>
<p><code>Koa </code>的中间件就是函数，可以是<code> async</code> 函数，或是普通函数</p>
<pre><code class="javascript">// async 函数
app.use(async (ctx, next) =&gt; &#123;
  const start = Date.now();
  await next();
  const ms = Date.now() - start;
  console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);
&#125;);

// 普通函数
app.use((ctx, next) =&gt; &#123;
  const start = Date.now();
  return next().then(() =&gt; &#123;
    const ms = Date.now() - start;
    console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);
  &#125;);
&#125;);
</code></pre>
<p>下面则通过中间件封装<code>http</code>请求过程中几个常用的功能：</p>
<h5 id="token校验"><a href="#token校验" class="headerlink" title="token校验"></a>token校验</h5><pre><code class="javascript">module.exports = (options) =&gt; async (ctx, next) &#123;
  try &#123;
    // 获取 token
    const token = ctx.header.authorization
    if (token) &#123;
      try &#123;
          // verify 函数验证 token，并获取用户相关信息
          await verify(token)
      &#125; catch (err) &#123;
        console.log(err)
      &#125;
    &#125;
    // 进入下一个中间件
    await next()
  &#125; catch (err) &#123;
    console.log(err)
  &#125;
&#125;
</code></pre>
<h5 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h5><pre><code class="javascript">const fs = require(&#39;fs&#39;)
module.exports = (options) =&gt; async (ctx, next) =&gt; &#123;
  const startTime = Date.now()
  const requestTime = new Date()
  await next()
  const ms = Date.now() - startTime;
  let logout = `$&#123;ctx.request.ip&#125; -- $&#123;requestTime&#125; -- $&#123;ctx.method&#125; -- $&#123;ctx.url&#125; -- $&#123;ms&#125;ms`;
  // 输出日志文件
  fs.appendFileSync(&#39;./log.txt&#39;, logout + &#39;\n&#39;)
&#125;
</code></pre>
<p><code>Koa</code>存在很多第三方的中间件，如<code>koa-bodyparser</code>、<code>koa-static</code>等</p>
<p>下面再来看看它们的大体的简单实现：</p>
<h5 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h5><p><code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值</p>
<pre><code class="javascript">// 文件：my-koa-bodyparser.js
const querystring = require(&quot;querystring&quot;);

module.exports = function bodyParser() &#123;
    return async (ctx, next) =&gt; &#123;
        await new Promise((resolve, reject) =&gt; &#123;
            // 存储数据的数组
            let dataArr = [];

            // 接收数据
            ctx.req.on(&quot;data&quot;, data =&gt; dataArr.push(data));

            // 整合数据并使用 Promise 成功
            ctx.req.on(&quot;end&quot;, () =&gt; &#123;
                // 获取请求数据的类型 json 或表单
                let contentType = ctx.get(&quot;Content-Type&quot;);

                // 获取数据 Buffer 格式
                let data = Buffer.concat(dataArr).toString();

                if (contentType === &quot;application/x-www-form-urlencoded&quot;) &#123;
                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body
                    ctx.request.body = querystring.parse(data);
                &#125; else if (contentType === &quot;applaction/json&quot;) &#123;
                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body
                    ctx.request.body = JSON.parse(data);
                &#125;

                // 执行成功的回调
                resolve();
            &#125;);
        &#125;);

        // 继续向下执行
        await next();
    &#125;;
&#125;;
</code></pre>
<h5 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h5><p><code>koa-static</code> 中间件的作用是在服务器接到请求时，帮我们处理静态文件</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const mime = require(&quot;mime&quot;);
const &#123; promisify &#125; = require(&quot;util&quot;);

// 将 stat 和 access 转换成 Promise
const stat = promisify(fs.stat);
const access = promisify(fs.access)

module.exports = function (dir) &#123;
    return async (ctx, next) =&gt; &#123;
        // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /
        let realPath = path.join(dir, ctx.path);

        try &#123;
            // 获取 stat 对象
            let statObj = await stat(realPath);

            // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html
            if (statObj.isFile()) &#123;
                ctx.set(&quot;Content-Type&quot;, `$&#123;mime.getType()&#125;;charset=utf8`);
                ctx.body = fs.createReadStream(realPath);
            &#125; else &#123;
                let filename = path.join(realPath, &quot;index.html&quot;);

                // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理
                await access(filename);

                // 存在设置文件类型并响应内容
                ctx.set(&quot;Content-Type&quot;, &quot;text/html;charset=utf8&quot;);
                ctx.body = fs.createReadStream(filename);
            &#125;
        &#125; catch (e) &#123;
            await next();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据</p>
<p><code>koa</code>本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得<code>web</code>应用具备良好的可拓展性和组合性</p>
<p>通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗杂代码，过程就如装饰者模式</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-Node性能如何进行监控以及优化？"><a href="#♥︎-♥︎-♥︎-♥︎-Node性能如何进行监控以及优化？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ Node性能如何进行监控以及优化？"></a>♥︎ ♥︎ ♥︎ ♥︎ Node性能如何进行监控以及优化？</h3><h4 id="一、-是什么"><a href="#一、-是什么" class="headerlink" title="一、 是什么"></a>一、 是什么</h4><p><code>Node</code>作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下：</p>
<ul>
<li>CPU</li>
<li>内存</li>
<li>I&#x2F;O</li>
<li>网络</li>
</ul>
<h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><p>主要分成了两部分：</p>
<ul>
<li>CPU负载：在某个时间段内，占用以及等待CPU的进程总数</li>
<li>CPU使用率：CPU时间占用状况，等于 1 - 空闲CPU时间(idle time) &#x2F; CPU总时间</li>
</ul>
<p>这两个指标都是用来评估系统当前CPU的繁忙程度的量化指标</p>
<p><code>Node</code>应用一般不会消耗很多的<code>CPU</code>，如果<code>CPU</code>占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞</p>
<h5 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h5><p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标</p>
<pre><code class="javascript">// /app/lib/memory.js
const os = require(&#39;os&#39;);
// 获取当前Node内存堆栈情况
const &#123; rss, heapUsed, heapTotal &#125; = process.memoryUsage();
// 获取系统空闲内存
const sysFree = os.freemem();
// 获取系统总内存
const sysTotal = os.totalmem();

module.exports = &#123;
  memory: () =&gt; &#123;
    return &#123;
      sys: 1 - sysFree / sysTotal,  // 系统内存占用率
      heap: heapUsed / headTotal,   // Node堆内存占用率
      node: rss / sysTotal,         // Node占用系统内存的比例
    &#125;
  &#125;
&#125;
</code></pre>
<ul>
<li>rss：表示node进程占用的内存总量。</li>
<li>heapTotal：表示堆内存的总量。</li>
<li>heapUsed：实际堆内存的使用量。</li>
<li>external ：外部程序的内存使用量，包含Node核心的C++程序的内存使用量</li>
</ul>
<p>在<code>Node</code>中，一个进程的最大内存容量为1.5GB。因此我们需要减少内存泄露</p>
<h5 id="磁盘-I-x2F-O"><a href="#磁盘-I-x2F-O" class="headerlink" title="磁盘 I&#x2F;O"></a>磁盘 I&#x2F;O</h5><p>硬盘的<code> IO</code> 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍</p>
<p>内存 <code>IO </code>比磁盘<code> IO</code> 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 <code>redis</code>、<code>memcached </code>等</p>
<p>并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决</p>
<h4 id="二、如何监控"><a href="#二、如何监控" class="headerlink" title="二、如何监控"></a>二、如何监控</h4><p>关于性能方面的监控，一般情况都需要借助工具来实现</p>
<p>这里采用<code>Easy-Monitor 2.0</code>，其是轻量级的 <code>Node.js</code> 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 <code>require</code> 一次，无需改动任何业务代码即可开启内核级别的性能监控分析</p>
<p>使用方法如下：</p>
<p>在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：</p>
<pre><code class="javascript">const easyMonitor = require(&#39;easy-monitor&#39;);
easyMonitor(&#39;你的项目名称&#39;);
</code></pre>
<p>打开你的浏览器，访问 <code>http://localhost:12333</code> ，即可看到进程界面</p>
<p>关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档</p>
<h4 id="三、如何优化"><a href="#三、如何优化" class="headerlink" title="三、如何优化"></a>三、如何优化</h4><p>关于<code>Node</code>的性能优化的方式有：</p>
<ul>
<li>使用最新版本Node.js</li>
<li>正确使用流 Stream</li>
<li>代码层面优化</li>
<li>内存管理优化</li>
</ul>
<h5 id="使用最新版本Node-js"><a href="#使用最新版本Node-js" class="headerlink" title="使用最新版本Node.js"></a>使用最新版本Node.js</h5><p>每个版本的性能提升主要来自于两个方面：</p>
<ul>
<li>V8 的版本更新</li>
<li>Node.js 内部代码的更新优化</li>
</ul>
<h5 id="正确使用流-Stream"><a href="#正确使用流-Stream" class="headerlink" title="正确使用流 Stream"></a>正确使用流 Stream</h5><p>在<code>Node</code>中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存</p>
<pre><code class="javascript">const http = require(&#39;http&#39;);
const fs = require(&#39;fs&#39;);

// bad
http.createServer(function (req, res) &#123;
    fs.readFile(__dirname + &#39;/data.txt&#39;, function (err, data) &#123;
        res.end(data);
    &#125;);
&#125;);

// good
http.createServer(function (req, res) &#123;
    const stream = fs.createReadStream(__dirname + &#39;/data.txt&#39;);
    stream.pipe(res);
&#125;);
</code></pre>
<h5 id="代码层面优化"><a href="#代码层面优化" class="headerlink" title="代码层面优化"></a>代码层面优化</h5><p>合并查询，将多次查询合并一次，减少数据库的查询次数</p>
<pre><code class="javascript">// bad
for user_id in userIds 
     let account = user_account.findOne(user_id)

// good
const user_account_map = &#123;&#125;   // 注意这个对象将会消耗大量内存。
user_account.find(user_id in user_ids).forEach(account)&#123;
    user_account_map[account.user_id] =  account
&#125;
for user_id in userIds 
    var account = user_account_map[user_id]
</code></pre>
<h5 id="内存管理优化"><a href="#内存管理优化" class="headerlink" title="内存管理优化"></a>内存管理优化</h5><p>在 V8 中，主要将内存分为新生代和老生代两代：</p>
<ul>
<li>新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象</li>
<li>老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象</li>
</ul>
<p>若新生代内存空间不够，直接分配到老生代</p>
<p>通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低</p>
<p>如下面情况：</p>
<pre><code class="javascript">const buffer = fs.readFileSync(__dirname + &#39;/source/index.htm&#39;);

app.use(
    mount(&#39;/&#39;, async (ctx) =&gt; &#123;
        ctx.status = 200;
        ctx.type = &#39;html&#39;;
        ctx.body = buffer;
        leak.push(fs.readFileSync(__dirname + &#39;/source/index.htm&#39;));
    &#125;)
);

const leak = [];
</code></pre>
<p><code>leak</code>的内存非常大，造成内存泄露，应当避免这样的操作，通过减少内存使用，是提高服务性能的手段之一</p>
<p>而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作</p>
<p>例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新new这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动</p>
<p>使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中。每次用到该对象时，就取对象池空闲的对象，并对它进行初始化操作，从而提高框架的性能</p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-秋天的第一个烤红薯"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/31/%E7%A7%8B%E5%A4%A9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%83%A4%E7%BA%A2%E8%96%AF/"
    >秋天的第一个烤红薯</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/31/%E7%A7%8B%E5%A4%A9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%83%A4%E7%BA%A2%E8%96%AF/" class="article-date">
  <time datetime="2022-10-31T08:18:44.000Z" itemprop="datePublished">2022-10-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%85%E8%A1%8C/">旅行</a> / <a class="article-category-link" href="/categories/%E6%97%85%E8%A1%8C/%E7%A7%8B%E5%A4%A9/">秋天</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="秋天的第一个烤红薯"><a href="#秋天的第一个烤红薯" class="headerlink" title="秋天的第一个烤红薯"></a>秋天的第一个烤红薯</h1><h2 id="美丽的不只是风景"><a href="#美丽的不只是风景" class="headerlink" title="美丽的不只是风景"></a>美丽的不只是风景</h2><p><img src="/2022/10/31/%E7%A7%8B%E5%A4%A9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%83%A4%E7%BA%A2%E8%96%AF/IMG_20220923_174805.jpg"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A3%E8%8A%82/" rel="tag">季节</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%85%E8%A1%8C/" rel="tag">旅行</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%8B%E5%A4%A9/" rel="tag">秋天</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全ES6"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/"
    >前端面试大全ES6</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/" class="article-date">
  <time datetime="2022-10-31T02:09:48.000Z" itemprop="datePublished">2022-10-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/ES6/">ES6</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（ES6）"><a href="#前端面试题大全（ES6）" class="headerlink" title="前端面试题大全（ES6）"></a>前端面试题大全（ES6）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-var、let、const之间的区别"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-var、let、const之间的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ var、let、const之间的区别"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ var、let、const之间的区别</h3><h4 id="一、var"><a href="#一、var" class="headerlink" title="一、var"></a>一、var</h4><p>在ES5中，顶层对象的属性和全局变量是等价的，用<code>var</code>声明的变量既是全局变量，也是顶层变量</p>
<p>注意：顶层对象，在浏览器环境指的是<code>window</code>对象，在 <code>Node</code> 指的是<code>global</code>对象</p>
<pre><code class="javascript">var a = 10;
console.log(window.a) // 10
</code></pre>
<p>使用<code>var</code>声明的变量存在变量提升的情况</p>
<pre><code class="javascript">console.log(a) // undefined
var a = 20
</code></pre>
<p>在编译阶段，编译器会将其变成以下执行</p>
<pre><code class="javascript">var a
console.log(a)
a = 20
</code></pre>
<p>使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明</p>
<pre><code class="javascript">var a = 20 
var a = 30
console.log(a) // 30
</code></pre>
<p>在函数中使用使用<code>var</code>声明变量时候，该变量是局部的</p>
<pre><code class="javascript">var a = 20
function change()&#123;
    var a = 30
&#125;
change()
console.log(a) // 20 
</code></pre>
<p>而如果在函数内不使用<code>var</code>，该变量是全局的</p>
<pre><code class="javascript">var a = 20
function change()&#123;
   a = 30
&#125;
change()
console.log(a) // 30 
</code></pre>
<h4 id="二、let"><a href="#二、let" class="headerlink" title="二、let"></a>二、let</h4><p><code>let</code>是<code>ES6</code>新增的命令，用来声明变量</p>
<p>用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效</p>
<pre><code class="javascript">&#123;
    let a = 20
&#125;
console.log(a) // ReferenceError: a is not defined.
</code></pre>
<p>不存在变量提升</p>
<pre><code class="javascript">console.log(a) // 报错ReferenceError
let a = 2
</code></pre>
<p>这表示在声明它之前，变量<code>a</code>是不存在的，这时如果用到它，就会抛出一个错误</p>
<p>只要块级作用域内存在<code>let</code>命令，这个区域就不再受外部影响</p>
<pre><code class="javascript">var a = 123
if (true) &#123;
    a = &#39;abc&#39; // ReferenceError
    let a;
&#125;
</code></pre>
<p>使用<code>let</code>声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”</p>
<p>最后，<code>let</code>不允许在相同作用域中重复声明</p>
<pre><code class="javascript">let a = 20
let a = 30
// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared
</code></pre>
<p>注意的是相同作用域，下面这种情况是不会报错的</p>
<pre><code class="javascript">let a = 20
&#123;
    let a = 30
&#125;
</code></pre>
<p>因此，我们不能在函数内部重新声明参数</p>
<pre><code class="javascript">function func(arg) &#123;
  let arg;
&#125;
func()
// Uncaught SyntaxError: Identifier &#39;arg&#39; has already been declared
</code></pre>
<h4 id="三、const"><a href="#三、const" class="headerlink" title="三、const"></a>三、const</h4><p><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变</p>
<pre><code class="javascript">const a = 1
a = 3
// TypeError: Assignment to constant variable.
</code></pre>
<p>这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值</p>
<pre><code class="javascript">const a;
// SyntaxError: Missing initializer in const declaration
</code></pre>
<p>如果之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错</p>
<pre><code class="javascript">var a = 20
let b = 20
const a = 30
const b = 30
// 都会报错
</code></pre>
<p><code>const</code>实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</p>
<p>对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量</p>
<p>对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的，并不能确保改变量的结构不变</p>
<pre><code class="javascript">const foo = &#123;&#125;;

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only
</code></pre>
<p>其它情况，<code>const</code>与<code>let</code>一致</p>
<h4 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h4><p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p>
<ul>
<li>变量提升</li>
<li>暂时性死区</li>
<li>块级作用域</li>
<li>重复声明</li>
<li>修改声明的变量</li>
<li>使用</li>
</ul>
<h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><pre><code class="css">var `声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined
</code></pre>
<p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p>
<pre><code class="javascript">// var
console.log(a)  // undefined
var a = 10

// let 
console.log(b)  // Cannot access &#39;b&#39; before initialization
let b = 10

// const
console.log(c)  // Cannot access &#39;c&#39; before initialization
const c = 10
</code></pre>
<h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><p><code>var</code>不存在暂时性死区</p>
<p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<pre><code class="javascript">// var
console.log(a)  // undefined
var a = 10

// let
console.log(b)  // Cannot access &#39;b&#39; before initialization
let b = 10

// const
console.log(c)  // Cannot access &#39;c&#39; before initialization
const c = 10
</code></pre>
<h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p><code>var</code>不存在块级作用域</p>
<p><code>let</code>和<code>const</code>存在块级作用域</p>
<pre><code class="javascript">// var
&#123;
    var a = 20
&#125;
console.log(a)  // 20

// let
&#123;
    let b = 20
&#125;
console.log(b)  // Uncaught ReferenceError: b is not defined

// const
&#123;
    const c = 20
&#125;
console.log(c)  // Uncaught ReferenceError: c is not defined
</code></pre>
<h5 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h5><p><code>var</code>允许重复声明变量</p>
<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p>
<pre><code class="javascript">// var
var a = 10
var a = 20 // 20

// let
let b = 10
let b = 20 // Identifier &#39;b&#39; has already been declared

// const
const c = 10
const c = 20 // Identifier &#39;c&#39; has already been declared
</code></pre>
<h5 id="修改声明的变量"><a href="#修改声明的变量" class="headerlink" title="修改声明的变量"></a>修改声明的变量</h5><p><code>var</code>和<code>let</code>可以</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p>
<pre><code class="javascript">// var
var a = 10
a = 20
console.log(a)  // 20

//let
let b = 10
b = 20
console.log(b)  // 20

// const
const c = 10
c = 20
console.log(c) // Uncaught TypeError: Assignment to constant variable
</code></pre>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>能用<code>const</code>的情况尽量使用<code>const</code>，其他情况下大多数使用<code>let</code>，避免使用<code>var</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中数组新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中数组新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中数组新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中数组新增了哪些扩展?</h3><h4 id="一、扩展运算符的应用"><a href="#一、扩展运算符的应用" class="headerlink" title="一、扩展运算符的应用"></a>一、扩展运算符的应用</h4><p>ES6通过扩展元素符<code>...</code>，好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<pre><code class="javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre>
<p>主要用于函数调用的时候，将一个数组变为参数序列</p>
<pre><code class="javascript">function push(array, ...items) &#123;
  array.push(...items);
&#125;

function add(x, y) &#123;
  return x + y;
&#125;

const numbers = [4, 38];
add(...numbers) // 42
</code></pre>
<p>可以将某些数据结构转为数组</p>
<pre><code class="javascript">[...document.querySelectorAll(&#39;div&#39;)]
</code></pre>
<p>能够更简单实现数组复制</p>
<pre><code class="javascript">const a1 = [1, 2];
const [...a2] = a1;
// [1,2]
</code></pre>
<p>数组的合并也更为简洁了</p>
<pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;];
const arr2 = [&#39;c&#39;];
const arr3 = [&#39;d&#39;, &#39;e&#39;];
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</code></pre>
<p>注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组</p>
<p>下面看个例子就清楚多了</p>
<pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;,[1,2]];
const arr2 = [&#39;c&#39;];
const arr3  = [...arr1,...arr2]
arr1[2][0] = 9999 // 修改arr1里面数组成员值
console.log(arr3) // 影响到arr3,[&#39;a&#39;,&#39;b&#39;,[9999,2],&#39;c&#39;]
</code></pre>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组</p>
<pre><code class="javascript">const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = [&quot;foo&quot;];
first  // &quot;foo&quot;
rest   // []
</code></pre>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p>
<pre><code class="javascript">const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</code></pre>
<p>可以将字符串转为真正的数组</p>
<pre><code class="javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
<p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p>
<pre><code class="javascript">let nodeList = document.querySelectorAll(&#39;div&#39;);
let array = [...nodeList];

let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]
</code></pre>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错</p>
<pre><code class="javascript">const obj = &#123;a: 1, b: 2&#125;;
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
</code></pre>
<h4 id="二、构造函数新增的方法"><a href="#二、构造函数新增的方法" class="headerlink" title="二、构造函数新增的方法"></a>二、构造函数新增的方法</h4><p>关于构造函数，数组新增的方法有如下：</p>
<ul>
<li>Array.from()</li>
<li>Array.of()</li>
</ul>
<h5 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h5><p>将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>
<pre><code class="javascript">let arrayLike = &#123;
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
&#125;;
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<pre><code class="javascript">Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]
</code></pre>
<h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h5><p>用于将一组值，转换为数组</p>
<pre><code class="javascript">Array.of(3, 11, 8) // [3,11,8]
</code></pre>
<p>没有参数的时候，返回一个空数组</p>
<p>当参数只有一个的时候，实际上是指定数组的长度</p>
<p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p>
<pre><code class="javascript">Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
</code></pre>
<h4 id="三、实例对象新增的方法"><a href="#三、实例对象新增的方法" class="headerlink" title="三、实例对象新增的方法"></a>三、实例对象新增的方法</h4><p>关于数组实例对象新增的方法有如下：</p>
<ul>
<li>copyWithin()</li>
<li>find()、findIndex()</li>
<li>fill()</li>
<li>entries()，keys()，values()</li>
<li>includes()</li>
<li>flat()，flatMap()</li>
</ul>
<h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h5><p>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p>
<p>参数如下：</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<pre><code>[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2
// [4, 5, 3, 4, 5] 
</code></pre>
<h5 id="find-、findIndex"><a href="#find-、findIndex" class="headerlink" title="find()、findIndex()"></a>find()、findIndex()</h5><p><code>find()</code>用于找出第一个符合条件的数组成员</p>
<p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p>
<pre><code class="javascript">[1, 5, 10, 15].find(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 10
findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1
[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 2
</code></pre>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>
<pre><code class="javascript">function f(v)&#123;
  return v &gt; this.age;
&#125;
let person = &#123;name: &#39;John&#39;, age: 20&#125;;
[10, 12, 26, 15].find(f, person);    // 26
</code></pre>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p>使用给定值，填充一个数组</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre>
<p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
</code></pre>
<p>注意，如果填充的类型为对象，则是浅拷贝</p>
<h5 id="entries-，keys-，values"><a href="#entries-，keys-，values" class="headerlink" title="entries()，keys()，values()"></a>entries()，keys()，values()</h5><p><code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历</p>
<pre><code class="javascript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;
  console.log(index);
&#125;
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;
  console.log(elem);
&#125;
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;
  console.log(index, elem);
&#125;
// 0 &quot;a&quot;
</code></pre>
<h5 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h5><p>用于判断数组是否包含给定的值</p>
<pre><code class="javascript">[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
</code></pre>
<p>方法的第二个参数表示搜索的起始位置，默认为<code>0</code></p>
<p>参数为负数则表示倒数的位置</p>
<pre><code class="javascript">[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</code></pre>
<h5 id="flat-，flatMap"><a href="#flat-，flatMap" class="headerlink" title="flat()，flatMap()"></a>flat()，flatMap()</h5><p>将数组扁平化处理，返回一个新数组，对原数据没有影响</p>
<pre><code class="javascript">[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
</code></pre>
<p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1</p>
<pre><code class="javascript">[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
</code></pre>
<p><code>flatMap()</code>方法对原数组的每个成员执行一个函数相当于执行<code>Array.prototype.map()</code>，然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组</p>
<pre><code class="javascript">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) =&gt; [x, x * 2])
// [2, 4, 3, 6, 4, 8]
flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this
</code></pre>
<h4 id="四、数组的空位"><a href="#四、数组的空位" class="headerlink" title="四、数组的空位"></a>四、数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值</p>
<p>ES6 则是明确将空位转为<code>undefined</code>，包括<code>Array.from</code>、扩展运算符、<code>copyWithin()</code>、<code>fill()</code>、<code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code></p>
<p>建议大家在日常书写中，避免出现空位</p>
<h4 id="五、排序稳定性"><a href="#五、排序稳定性" class="headerlink" title="五、排序稳定性"></a>五、排序稳定性</h4><p>将<code>sort()</code>默认设置为稳定的排序算法</p>
<pre><code class="javascript">const arr = [
  &#39;peach&#39;,
  &#39;straw&#39;,
  &#39;apple&#39;,
  &#39;spork&#39;
];

const stableSorting = (s1, s2) =&gt; &#123;
  if (s1[0] &lt; s2[0]) return -1;
  return 1;
&#125;;

arr.sort(stableSorting)
// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]
</code></pre>
<p>排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中对象新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中对象新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中对象新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中对象新增了哪些扩展?</h3><h4 id="一、属性的简写"><a href="#一、属性的简写" class="headerlink" title="一、属性的简写"></a>一、属性的简写</h4><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写</p>
<pre><code class="javascript">const baz = &#123;foo:foo&#125;

// 等同于
const baz = &#123;foo&#125;
</code></pre>
<p>方法也能够进行简写</p>
<pre><code class="javascript">const o = &#123;
  method() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;;

// 等同于

const o = &#123;
  method: function() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;
</code></pre>
<p>在函数内作为返回值，也会变得方便很多</p>
<pre><code class="javascript">function getPoint() &#123;
  const x = 1;
  const y = 10;
  return &#123;x, y&#125;;
&#125;

getPoint()
// &#123;x:1, y:10&#125;
</code></pre>
<p>注意：简写的对象方法不能用作构造函数，否则会报错</p>
<pre><code class="javascript">const obj = &#123;
  f() &#123;
    this.foo = &#39;bar&#39;;
  &#125;
&#125;;

new obj.f() // 报错
</code></pre>
<h4 id="二、属性名表达式"><a href="#二、属性名表达式" class="headerlink" title="二、属性名表达式"></a>二、属性名表达式</h4><p>ES6 允许字面量定义对象时，将表达式放在括号内</p>
<pre><code class="javascript">let lastWord = &#39;last word&#39;;

const a = &#123;
  &#39;first word&#39;: &#39;hello&#39;,
  [lastWord]: &#39;world&#39;
&#125;;

a[&#39;first word&#39;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&#39;last word&#39;] // &quot;world&quot;
</code></pre>
<p>表达式还可以用于定义方法名</p>
<pre><code class="javascript">let obj = &#123;
  [&#39;h&#39; + &#39;ello&#39;]() &#123;
    return &#39;hi&#39;;
  &#125;
&#125;;

obj.hello() // hi
</code></pre>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错</p>
<pre><code class="javascript">// 报错
const foo = &#39;bar&#39;;
const bar = &#39;abc&#39;;
const baz = &#123; [foo] &#125;;

// 正确
const foo = &#39;bar&#39;;
const baz = &#123; [foo]: &#39;abc&#39;&#125;;
</code></pre>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code></p>
<pre><code class="javascript">const keyA = &#123;a: 1&#125;;
const keyB = &#123;b: 2&#125;;

const myObject = &#123;
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
&#125;;

myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;
</code></pre>
<h4 id="三、super关键字"><a href="#三、super关键字" class="headerlink" title="三、super关键字"></a>三、super关键字</h4><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象</p>
<pre><code class="javascript">const proto = &#123;
  foo: &#39;hello&#39;
&#125;;

const obj = &#123;
  foo: &#39;world&#39;,
  find() &#123;
    return super.foo;
  &#125;
&#125;;

Object.setPrototypeOf(obj, proto); // 为obj设置原型对象
obj.find() // &quot;hello&quot;
</code></pre>
<h4 id="四、扩展运算符的应用"><a href="#四、扩展运算符的应用" class="headerlink" title="四、扩展运算符的应用"></a>四、扩展运算符的应用</h4><p>在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面</p>
<pre><code class="javascript">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;
x // 1
y // 2
z // &#123; a: 3, b: 4 &#125;
</code></pre>
<p>注意：解构赋值必须是最后一个参数，否则会报错</p>
<p>解构赋值是浅拷贝</p>
<pre><code class="javascript">let obj = &#123; a: &#123; b: 1 &#125; &#125;;
let &#123; ...x &#125; = obj;
obj.a.b = 2; // 修改obj里面a属性中键值
x.a.b // 2，影响到了结构出来x的值
</code></pre>
<p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法</p>
<h4 id="五、属性的遍历"><a href="#五、属性的遍历" class="headerlink" title="五、属性的遍历"></a>五、属性的遍历</h4><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<ul>
<li>for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li>
<li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li>
<li>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li>
<li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</li>
<li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li>
</ul>
<p>上述遍历，都遵守同样的属性遍历的次序规则：</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排</li>
</ul>
<pre><code class="javascript">Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)
// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]
</code></pre>
<h4 id="六、对象新增的方法"><a href="#六、对象新增的方法" class="headerlink" title="六、对象新增的方法"></a>六、对象新增的方法</h4><p>关于对象新增的方法，分别有以下：</p>
<ul>
<li>Object.is()</li>
<li>Object.assign()</li>
<li>Object.getOwnPropertyDescriptors()</li>
<li>Object.setPrototypeOf()，Object.getPrototypeOf()</li>
<li>Object.keys()，Object.values()，Object.entries()</li>
<li>Object.fromEntries()</li>
</ul>
<h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><p>严格判断两个值是否相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致，不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</p>
<pre><code class="javascript">+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><pre><code class="javascript">Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target
</code></pre>
<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象</p>
<pre><code class="javascript">const target = &#123; a: 1, b: 1 &#125;;

const source1 = &#123; b: 2, c: 2 &#125;;
const source2 = &#123; c: 3 &#125;;

Object.assign(target, source1, source2);
target // &#123;a:1, b:2, c:3&#125;
</code></pre>
<p>注意：<code>Object.assign()</code>方法是浅拷贝，遇到同名属性会进行替换</p>
<h5 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h5><p>返回指定对象所有自身属性（非继承属性）的描述对象</p>
<pre><code class="javascript">const obj = &#123;
  foo: 123,
  get bar() &#123; return &#39;abc&#39; &#125;
&#125;;

Object.getOwnPropertyDescriptors(obj)
// &#123; foo:
//    &#123; value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true &#125;,
//   bar:
//    &#123; get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true &#125; &#125;
</code></pre>
<h5 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h5><p><code>Object.setPrototypeOf</code>方法用来设置一个对象的原型对象</p>
<pre><code class="javascript">Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf(&#123;&#125;, null);
</code></pre>
<h5 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h5><p>用于读取一个对象的原型对象</p>
<pre><code class="javascript">Object.getPrototypeOf(obj);
</code></pre>
<h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组</p>
<pre><code class="javascript">var obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre>
<h5 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h5><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组</p>
<pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.values(obj)
// [&quot;bar&quot;, 42]
</code></pre>
<h5 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h5><p>返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组</p>
<pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
</code></pre>
<h5 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h5><p>用于将一个键值对数组转为对象</p>
<pre><code class="javascript">Object.fromEntries([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
])
// &#123; foo: &quot;bar&quot;, baz: 42 &#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中函数新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中函数新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中函数新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中函数新增了哪些扩展?</h3><h4 id="一、参数"><a href="#一、参数" class="headerlink" title="一、参数"></a>一、参数</h4><p><code>ES6</code>允许为函数的参数设置默认值</p>
<pre><code class="javascript">function log(x, y = &#39;World&#39;) &#123;
  console.log(x, y);
&#125;

console.log(&#39;Hello&#39;) // Hello World
console.log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
console.log(&#39;Hello&#39;, &#39;&#39;) // Hello
</code></pre>
<p>函数的形参是默认声明的，不能使用<code>let</code>或<code>const</code>再次声明</p>
<pre><code class="javascript">function foo(x = 5) &#123;
    let x = 1; // error
    const x = 2; // error
&#125;
</code></pre>
<p>参数默认值可以与解构赋值的默认值结合起来使用</p>
<pre><code class="javascript">function foo(&#123;x, y = 5&#125;) &#123;
  console.log(x, y);
&#125;

foo(&#123;&#125;) // undefined 5
foo(&#123;x: 1&#125;) // 1 5
foo(&#123;x: 1, y: 2&#125;) // 1 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined
</code></pre>
<p>上面的<code>foo</code>函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量<code>x</code>和<code>y</code>就不会生成，从而报错，这里设置默认值避免</p>
<pre><code class="javascript">function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;
  console.log(x, y);
&#125;

foo() // undefined 5
</code></pre>
<p>参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的</p>
<pre><code class="javascript">function f(x = 1, y) &#123;
  return [x, y];
&#125;

f() // [1, undefined]
f(2) // [2, undefined]
f(, 1) // 报错
f(undefined, 1) // [1, 1]
</code></pre>
<h4 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h4><h5 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h5><p><code>length</code>将返回没有指定默认值的参数个数</p>
<pre><code class="javascript">(function (a) &#123;&#125;).length // 1
(function (a = 5) &#123;&#125;).length // 0
(function (a, b, c = 5) &#123;&#125;).length // 2
</code></pre>
<p><code>rest</code> 参数也不会计入<code>length</code>属性</p>
<pre><code class="javascript">(function(...args) &#123;&#125;).length // 0
</code></pre>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</p>
<pre><code class="javascript">(function (a = 0, b, c) &#123;&#125;).length // 0
(function (a, b = 1, c) &#123;&#125;).length // 1
</code></pre>
<h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><p>返回该函数的函数名</p>
<pre><code class="javascript">var f = function () &#123;&#125;;

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;
</code></pre>
<p>如果将一个具名函数赋值给一个变量，则 <code>name</code>属性都返回这个具名函数原本的名字</p>
<pre><code class="javascript">const bar = function baz() &#123;&#125;;
bar.name // &quot;baz&quot;
Function`构造函数返回的函数实例，`name`属性的值为`anonymous
(new Function).name // &quot;anonymous&quot;
</code></pre>
<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀</p>
<pre><code class="javascript">function foo() &#123;&#125;;
foo.bind(&#123;&#125;).name // &quot;bound foo&quot;

(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;
</code></pre>
<h4 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</p>
<p>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p>
<p>下面例子中，<code>y=x</code>会形成一个单独作用域，<code>x</code>没有被定义，所以指向全局变量<code>x</code></p>
<pre><code class="javascript">let x = 1;

function f(y = x) &#123; 
  // 等同于 let y = x  
  let x = 2; 
  console.log(y);
&#125;

f() // 1
</code></pre>
<h4 id="四、严格模式"><a href="#四、严格模式" class="headerlink" title="四、严格模式"></a>四、严格模式</h4><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p>
<pre><code class="javascript">// 报错
function doSomething(a, b = a) &#123;
  &#39;use strict&#39;;
  // code
&#125;

// 报错
const doSomething = function (&#123;a, b&#125;) &#123;
  &#39;use strict&#39;;
  // code
&#125;;

// 报错
const doSomething = (...a) =&gt; &#123;
  &#39;use strict&#39;;
  // code
&#125;;

const obj = &#123;
  // 报错
  doSomething(&#123;a, b&#125;) &#123;
    &#39;use strict&#39;;
    // code
  &#125;
&#125;;
</code></pre>
<h4 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h4><p>使用“箭头”（<code>=&gt;</code>）定义函数</p>
<pre><code class="javascript">var f = v =&gt; v;

// 等同于
var f = function (v) &#123;
  return v;
&#125;;
</code></pre>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</p>
<pre><code class="javascript">var f = () =&gt; 5;
// 等同于
var f = function () &#123; return 5 &#125;;

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) &#123;
  return num1 + num2;
&#125;;
</code></pre>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回</p>
<pre><code class="javascript">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;
</code></pre>
<p>如果返回对象，需要加括号将对象包裹</p>
<pre><code class="javascript">let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);
</code></pre>
<p>注意点：</p>
<ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中新增的Set、Map两种数据结构怎么理解"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中新增的Set、Map两种数据结构怎么理解" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中新增的Set、Map两种数据结构怎么理解?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中新增的Set、Map两种数据结构怎么理解?</h3><p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p>
<p>什么是集合？什么又是字典？</p>
<ul>
<li>集合<br>是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</li>
<li>字典<br>是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</li>
</ul>
<p>区别？</p>
<ul>
<li>共同点：集合、字典都可以存储不重复的值</li>
<li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li>
</ul>
<h4 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h4><p><code>Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</p>
<pre><code>const s = new Set();
</code></pre>
<h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><p><code>Set</code>的实例关于增删改查的方法：</p>
<ul>
<li>add()</li>
<li>delete()</li>
<li>has()</li>
<li>clear()</li>
</ul>
<h6 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h6><p>添加某个值，返回 <code>Set</code> 结构本身</p>
<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>
<pre><code>s.add(1).add(2).add(2); // 2只被添加了一次
</code></pre>
<h6 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h6><p>删除某个值，返回一个布尔值，表示删除是否成功</p>
<pre><code>s.delete(1)
</code></pre>
<h6 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h6><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>
<pre><code>s.has(2)
</code></pre>
<h6 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h6><p>清除所有成员，没有返回值</p>
<pre><code>s.clear()
</code></pre>
<h6 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h6><p><code>Set</code>实例遍历的方法有如下：</p>
<p>关于遍历的方法，有如下：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<p><code>Set</code>的遍历顺序就是插入顺序</p>
<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象</p>
<pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

for (let item of set.keys()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.values()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.entries()) &#123;
  console.log(item);
&#125;
// [&quot;red&quot;, &quot;red&quot;]
// [&quot;green&quot;, &quot;green&quot;]
// [&quot;blue&quot;, &quot;blue&quot;]
forEach()`用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的`forEach`方法有第二个参数，用于绑定处理函数的`this
let set = new Set([1, 4, 9]);
set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
// 1 : 1
// 4 : 4
// 9 : 9
</code></pre>
<p>扩展运算符和<code> Set</code> 结构相结合实现数组或字符串去重</p>
<pre><code class="javascript">// 数组
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)]; // [3, 5, 2]

// 字符串
let str = &quot;352255&quot;;
let unique = [...new Set(str)].join(&quot;&quot;); // &#39;352&#39;
</code></pre>
<p>实现并集、交集、和差集</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<h4 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h4><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>
<p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p>
<pre><code class="javascript">const m = new Map()
</code></pre>
<h5 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h5><p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p>
<ul>
<li>size 属性</li>
<li>set()</li>
<li>get()</li>
<li>has()</li>
<li>delete()</li>
<li>clear()</li>
</ul>
<h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><p><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="javascript">const map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
</code></pre>
<h6 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h6><p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p>
<p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p>
<p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p>
<pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6)        // 键是字符串
m.set(262, &#39;standard&#39;)     // 键是数值
m.set(undefined, &#39;nah&#39;)    // 键是 undefined
m.set(1, &#39;a&#39;).set(2, &#39;b&#39;).set(3, &#39;c&#39;) // 链式操作
</code></pre>
<h6 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h6><pre><code class="javascript">get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined
const m = new Map();

const hello = function() &#123;console.log(&#39;hello&#39;);&#125;;
m.set(hello, &#39;Hello ES6!&#39;) // 键是函数

m.get(hello)  // Hello ES6!
</code></pre>
<h6 id="has-1"><a href="#has-1" class="headerlink" title="has()"></a>has()</h6><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p>
<pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6);
m.set(262, &#39;standard&#39;);
m.set(undefined, &#39;nah&#39;);

m.has(&#39;edition&#39;)     // true
m.has(&#39;years&#39;)       // false
m.has(262)           // true
m.has(undefined)     // true
</code></pre>
<h6 id="delete-1"><a href="#delete-1" class="headerlink" title="delete()"></a>delete()</h6><pre><code class="javascript">delete`方法删除某个键，返回`true`。如果删除失败，返回`false
const m = new Map();
m.set(undefined, &#39;nah&#39;);
m.has(undefined)     // true

m.delete(undefined)
m.has(undefined)       // false
</code></pre>
<h6 id="clear-1"><a href="#clear-1" class="headerlink" title="clear()"></a>clear()</h6><p><code>clear</code>方法清除所有成员，没有返回值</p>
<pre><code class="javascript">let map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
map.clear()
map.size // 0
</code></pre>
<h6 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h6><p><code>Map </code>结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回所有成员的遍历器</li>
<li>forEach()：遍历 Map 的所有成员</li>
</ul>
<p>遍历顺序就是插入顺序</p>
<pre><code class="javascript">const map = new Map([
  [&#39;F&#39;, &#39;no&#39;],
  [&#39;T&#39;,  &#39;yes&#39;],
]);

for (let key of map.keys()) &#123;
  console.log(key);
&#125;
// &quot;F&quot;
// &quot;T&quot;

for (let value of map.values()) &#123;
  console.log(value);
&#125;
// &quot;no&quot;
// &quot;yes&quot;

for (let item of map.entries()) &#123;
  console.log(item[0], item[1]);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 或者
for (let [key, value] of map.entries()) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 等同于使用map.entries()
for (let [key, value] of map) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

map.forEach(function(value, key, map) &#123;
  console.log(&quot;Key: %s, Value: %s&quot;, key, value);
&#125;);
</code></pre>
<h4 id="三、WeakSet-和-WeakMap"><a href="#三、WeakSet-和-WeakMap" class="headerlink" title="三、WeakSet 和 WeakMap"></a>三、WeakSet 和 WeakMap</h4><h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>创建<code>WeakSet</code>实例</p>
<pre><code class="javascript">const ws = new WeakSet();
</code></pre>
<p><code>WeakSet </code>可以接受一个具有 <code>Iterable </code>接口的对象作为参数</p>
<pre><code class="javascript">const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet &#123;[1, 2], [3, 4]&#125;
</code></pre>
<p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>size</code>属性</li>
</ul>
<p><code>WeackSet</code>只能成员只能是引用类型，而不能是其他类型的值</p>
<pre><code class="javascript">let ws=new WeakSet();

// 成员不是引用类型
let weakSet=new WeakSet([2,3]);
console.log(weakSet) // 报错

// 成员为引用类型
let obj1=&#123;name:1&#125;
let obj2=&#123;name:1&#125;
let ws=new WeakSet([obj1,obj2]); 
console.log(ws) //WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125;
</code></pre>
<p><code>WeakSet </code>里面的引用只要在外部消失，它在 <code>WeakSet </code>里面的引用就会自动消失</p>
<h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p>
<p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>clear</code>清空方法</li>
</ul>
<pre><code class="javascript">// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = &#123;foo: 1&#125;;
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]);
wm2.get(k2) // &quot;bar&quot;
</code></pre>
<p><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p>
<pre><code class="javascript">const map = new WeakMap();
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
</code></pre>
<p><code>WeakMap</code>的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p>
<p>举个场景例子：</p>
<p>在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构，当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除</p>
<pre><code class="javascript">const wm = new WeakMap();
const element = document.getElementById(&#39;example&#39;);
wm.set(element, &#39;some information&#39;);
wm.get(element) // &quot;some information&quot;
</code></pre>
<p>注意：<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用</p>
<p>下面代码中，键值<code>obj</code>会在<code>WeakMap</code>产生新的引用，当你修改<code>obj</code>不会影响到内部</p>
<pre><code class="javascript">const wm = new WeakMap();
let key = &#123;&#125;;
let obj = &#123;foo: 1&#125;;

wm.set(key, obj);
obj = null;
wm.get(key)
// Object &#123;foo: 1&#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-你是怎么理解ES6中-Promise的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-你是怎么理解ES6中-Promise的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 你是怎么理解ES6中 Promise的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 你是怎么理解ES6中 Promise的？使用场景？</h3><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p><code>Promise </code>，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p>
<p>在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码</p>
<pre><code class="javascript">doSomething(function(result) &#123;
  doSomethingElse(result, function(newResult) &#123;
    doThirdThing(newResult, function(finalResult) &#123;
      console.log(&#39;得到最终结果: &#39; + finalResult);
    &#125;, failureCallback);
  &#125;, failureCallback);
&#125;, failureCallback);
</code></pre>
<p>阅读上面代码，是不是很难受，上述形成了经典的回调地狱</p>
<p>现在通过<code>Promise</code>的改写上面的代码</p>
<pre><code class="javascript">doSomething().then(function(result) &#123;
  return doSomethingElse(result);
&#125;)
.then(function(newResult) &#123;
  return doThirdThing(newResult);
&#125;)
.then(function(finalResult) &#123;
  console.log(&#39;得到最终结果: &#39; + finalResult);
&#125;)
.catch(failureCallback);
</code></pre>
<p>瞬间感受到<code>promise</code>解决异步操作的优点：</p>
<ul>
<li>链式操作减低了编码难度</li>
<li>代码可读性明显增强</li>
</ul>
<p>下面我们正式来认识<code>promise</code>：</p>
<h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p><code>promise</code>对象仅有三种状态</p>
<ul>
<li><code>pending</code>（进行中）</li>
<li><code>fulfilled</code>（已成功）</li>
<li><code>rejected</code>（已失败）</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li>
<li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li>
</ul>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>认真阅读下图，我们能够轻松了解<code>promise</code>整个流程</p>
<p><img src="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31623032616539302d353861392d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例</p>
<pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;&#125;);
Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject
</code></pre>
<ul>
<li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li>
<li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”</li>
</ul>
<h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><p><code>Promise</code>构建出来的实例存在以下方法：</p>
<ul>
<li>then()</li>
<li>catch()</li>
<li>finally()</li>
</ul>
<h6 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h6><p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因</p>
<pre><code class="javascript">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  return json.post;
&#125;).then(function(post) &#123;
  // ...
&#125;);
</code></pre>
<h6 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h6><p><code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</p>
<pre><code class="javascript">getJSON(&#39;/posts.json&#39;).then(function(posts) &#123;
  // ...
&#125;).catch(function(error) &#123;
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&#39;发生错误！&#39;, error);
&#125;);
</code></pre>
<p><code>Promise </code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p>
<pre><code class="javascript">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;
  return getJSON(post.commentURL);
&#125;).then(function(comments) &#123;
  // some code
&#125;).catch(function(error) &#123;
  // 处理前面三个Promise产生的错误
&#125;);
</code></pre>
<p>一般来说，使用<code>catch</code>方法代替<code>then()</code>第二个参数</p>
<p><code>Promise </code>对象抛出的错误不会传递到外层代码，即不会有任何反应</p>
<pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;
</code></pre>
<p>浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程</p>
<p><code>catch()</code>方法之中，还能再抛出错误，通过后面<code>catch</code>方法捕获到</p>
<h6 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h6><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p>
<pre><code class="javascript">promise
.then(result =&gt; &#123;···&#125;)
.catch(error =&gt; &#123;···&#125;)
.finally(() =&gt; &#123;···&#125;);
</code></pre>
<h5 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h5><p><code>Promise</code>构造函数存在以下方法：</p>
<ul>
<li>all()</li>
<li>race()</li>
<li>allSettled()</li>
<li>resolve()</li>
<li>reject()</li>
<li>try()</li>
</ul>
<h6 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h6><p><code>Promise.all()</code>方法用于将多个 <code>Promise </code>实例，包装成一个新的 <code>Promise </code>实例</p>
<pre><code class="javascript">const p = Promise.all([p1, p2, p3]);
</code></pre>
<p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p>
<p>实例<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分为两种：</p>
<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li>
</ul>
<p>注意，如果作为参数的 <code>Promise</code> 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// Error: 报错了
</code></pre>
<h6 id="race"><a href="#race" class="headerlink" title="race()"></a>race()</h6><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p>
<pre><code class="javascript">const p = Promise.race([p1, p2, p3]);
</code></pre>
<p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变</p>
<p>率先改变的 Promise 实例的返回值则传递给<code>p</code>的回调函数</p>
<pre><code class="javascript">const p = Promise.race([
  fetch(&#39;/resource-that-may-take-a-while&#39;),
  new Promise(function (resolve, reject) &#123;
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)
  &#125;)
]);

p
.then(console.log)
.catch(console.error);
</code></pre>
<h6 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled()"></a>allSettled()</h6><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p>
<p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束</p>
<pre><code class="javascript">const promises = [
  fetch(&#39;/api-1&#39;),
  fetch(&#39;/api-2&#39;),
  fetch(&#39;/api-3&#39;),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
</code></pre>
<h6 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a>resolve()</h6><p>将现有对象转为 <code>Promise </code>对象</p>
<pre><code class="javascript">Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))
</code></pre>
<p>参数可以分成四种情况，分别如下：</p>
<ul>
<li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li>
<li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise </code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li>
<li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li>
<li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li>
</ul>
<h6 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h6><pre><code class="javascript">Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected
const p = Promise.reject(&#39;出错了&#39;);
// 等同于
const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))

p.then(null, function (s) &#123;
  console.log(s)
&#125;);
// 出错了
</code></pre>
<p><code>Promise.reject()</code>方法的参数，会原封不动地变成后续方法的参数</p>
<pre><code class="javascript">Promise.reject(&#39;出错了&#39;)
.catch(e =&gt; &#123;
  console.log(e === &#39;出错了&#39;)
&#125;)
// true
</code></pre>
<h4 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化</p>
<pre><code class="javascript">const preloadImage = function (path) &#123;
  return new Promise(function (resolve, reject) &#123;
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  &#125;);
&#125;;
</code></pre>
<p>通过链式操作，将多个渲染数据分别给个<code>then</code>，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题</p>
<pre><code class="javascript">// 各司其职
getInfo().then(res=&gt;&#123;
    let &#123; bannerList &#125; = res
    //渲染轮播图
    console.log(bannerList)
    return res
&#125;).then(res=&gt;&#123;
    
    let &#123; storeList &#125; = res
    //渲染店铺列表
    console.log(storeList)
    return res
&#125;).then(res=&gt;&#123;
    let &#123; categoryList &#125; = res
    console.log(categoryList)
    //渲染分类列表
    return res
&#125;)
</code></pre>
<p>通过<code>all()</code>实现多个请求合并在一起，汇总所有请求结果，只需设置一个<code>loading</code>即可</p>
<pre><code class="javascript">function initLoad()&#123;
    // loading.show() //加载loading
    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=&gt;&#123;
        console.log(res)
        loading.hide() //关闭loading
    &#125;).catch(err=&gt;&#123;
        console.log(err)
        loading.hide()//关闭loading
    &#125;)
&#125;
//数据初始化    
initLoad()
</code></pre>
<p>通过<code>race</code>可以设置图片请求超时</p>
<pre><code class="javascript">//请求某个图片资源
function requestImg()&#123;
    var p = new Promise(function(resolve, reject)&#123;
        var img = new Image();
        img.onload = function()&#123;
           resolve(img);
        &#125;
        //img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的
        img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;;
    &#125;);
    return p;
&#125;

//延时函数，用于给请求计时
function timeout()&#123;
    var p = new Promise(function(resolve, reject)&#123;
        setTimeout(function()&#123;
            reject(&#39;图片请求超时&#39;);
        &#125;, 5000);
    &#125;);
    return p;
&#125;

Promise
.race([requestImg(), timeout()])
.then(function(results)&#123;
    console.log(results);
&#125;)
.catch(function(reason)&#123;
    console.log(reason);
&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Generator的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Generator的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Generator的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Generator的？使用场景？</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p>回顾下上文提到的解决异步的手段：</p>
<ul>
<li>回调函数</li>
<li>promise</li>
</ul>
<p>那么，上文我们提到<code>promsie</code>已经是一种比较流行的解决异步方案，那么为什么还出现<code>Generator</code>？甚至<code>async/await</code>呢？</p>
<p>该问题我们留在后面再进行分析，下面先认识下<code>Generator</code></p>
<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>执行 <code>Generator</code> 函数会返回一个遍历器对象，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p>
<p>形式上，<code>Generator </code>函数是一个普通函数，但是有两个特征：</p>
<ul>
<li><code>function</code>关键字与函数名之间有一个星号</li>
<li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态</li>
</ul>
<pre><code class="javascript">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
</code></pre>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p><code>Generator</code> 函数会返回一个遍历器对象，即具有<code>Symbol.iterator</code>属性，并且返回给自己</p>
<pre><code class="javascript">function* gen()&#123;
  // some code
&#125;

var g = gen();

g[Symbol.iterator]() === g
// true
</code></pre>
<p>通过<code>yield</code>关键字可以暂停<code>generator</code>函数返回的遍历器对象的状态</p>
<pre><code class="javascript">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
var hw = helloWorldGenerator();
</code></pre>
<p>上述存在三个状态：<code>hello</code>、<code>world</code>、<code>return</code></p>
<p>通过<code>next</code>方法才会遍历到下一个内部状态，其运行逻辑如下：</p>
<ul>
<li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</li>
<li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li>
</ul>
<pre><code class="javascript">hw.next()
// &#123; value: &#39;hello&#39;, done: false &#125;

hw.next()
// &#123; value: &#39;world&#39;, done: false &#125;

hw.next()
// &#123; value: &#39;ending&#39;, done: true &#125;

hw.next()
// &#123; value: undefined, done: true &#125;
</code></pre>
<p><code>done</code>用来判断是否存在下个状态，<code>value</code>对应状态值</p>
<pre><code class="javascript">yield`表达式本身没有返回值，或者说总是返回`undefined
</code></pre>
<p>通过调用<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值</p>
<pre><code class="javascript">function* foo(x) &#123;
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
&#125;

var a = foo(5);
a.next() // Object&#123;value:6, done:false&#125;
a.next() // Object&#123;value:NaN, done:false&#125;
a.next() // Object&#123;value:NaN, done:true&#125;

var b = foo(5);
b.next() // &#123; value:6, done:false &#125;
b.next(12) // &#123; value:8, done:false &#125;
b.next(13) // &#123; value:42, done:true &#125;
</code></pre>
<p>正因为<code>Generator </code>函数返回<code>Iterator</code>对象，因此我们还可以通过<code>for...of</code>进行遍历</p>
<pre><code class="javascript">function* foo() &#123;
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
&#125;

for (let v of foo()) &#123;
  console.log(v);
&#125;
// 1 2 3 4 5
</code></pre>
<p>原生对象没有遍历接口，通过<code>Generator </code>函数为它加上这个接口，就能使用<code>for...of</code>进行遍历了</p>
<pre><code class="javascript">function* objectEntries(obj) &#123;
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) &#123;
    yield [propKey, obj[propKey]];
  &#125;
&#125;

let jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;

for (let [key, value] of objectEntries(jane)) &#123;
  console.log(`$&#123;key&#125;: $&#123;value&#125;`);
&#125;
// first: Jane
// last: Doe
</code></pre>
<h4 id="三、异步解决方案"><a href="#三、异步解决方案" class="headerlink" title="三、异步解决方案"></a>三、异步解决方案</h4><p>回顾之前展开异步解决的方案：</p>
<ul>
<li>回调函数</li>
<li>Promise 对象</li>
<li>generator 函数</li>
<li>async&#x2F;await</li>
</ul>
<p>这里通过文件读取案例，将几种解决异步的方案进行一个比较：</p>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数</p>
<pre><code class="javascript">fs.readFile(&#39;/etc/fstab&#39;, function (err, data) &#123;
  if (err) throw err;
  console.log(data);
  fs.readFile(&#39;/etc/shells&#39;, function (err, data) &#123;
    if (err) throw err;
    console.log(data);
  &#125;);
&#125;);
</code></pre>
<p><code>readFile</code>函数的第三个参数，就是回调函数，等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行</p>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p><code>Promise</code>就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;);

const readFile = function (fileName) &#123;
  return new Promise(function (resolve, reject) &#123;
    fs.readFile(fileName, function(error, data) &#123;
      if (error) return reject(error);
      resolve(data);
    &#125;);
  &#125;);
&#125;;


readFile(&#39;/etc/fstab&#39;).then(data =&gt;&#123;
    console.log(data)
    return readFile(&#39;/etc/shells&#39;)
&#125;).then(data =&gt; &#123;
    console.log(data)
&#125;)
</code></pre>
<p>这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强</p>
<h5 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h5><p><code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化</p>
<pre><code class="javascript">const gen = function* () &#123;
  const f1 = yield readFile(&#39;/etc/fstab&#39;);
  const f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<h5 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h5><p>将上面<code>Generator</code>函数改成<code>async/await</code>形式，更为简洁，语义化更强了</p>
<pre><code class="javascript">const asyncReadFile = async function () &#123;
  const f1 = await readFile(&#39;/etc/fstab&#39;);
  const f2 = await readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><p>通过上述代码进行分析，将<code>promise</code>、<code>Generator</code>、<code>async/await</code>进行比较：</p>
<ul>
<li><code>promise</code>和<code>async/await</code>是专门用于处理异步操作的</li>
<li><code>Generator</code>并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署<code>Interator</code>接口…）</li>
<li><code>promise</code>编写代码相比<code>Generator</code>、<code>async</code>更为复杂化，且可读性也稍差</li>
<li><code>Generator</code>、<code>async</code>需要与<code>promise</code>对象搭配处理异步情况</li>
<li><code>async</code>实质是<code>Generator</code>的语法糖，相当于会自动执行<code>Generator</code>函数</li>
<li><code>async</code>使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案</li>
</ul>
<h4 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h4><p><code>Generator</code>是异步解决的一种方案，最大特点则是将异步操作同步化表达出来</p>
<pre><code class="javascript">function* loadUI() &#123;
  showLoadingScreen();
  yield loadUIDataAsynchronously();
  hideLoadingScreen();
&#125;
var loader = loadUI();
// 加载UI
loader.next()

// 卸载UI
loader.next()
</code></pre>
<p>包括<code>redux-saga </code>中间件也充分利用了<code>Generator</code>特性</p>
<pre><code class="javascript">import &#123; call, put, takeEvery, takeLatest &#125; from &#39;redux-saga/effects&#39;
import Api from &#39;...&#39;

function* fetchUser(action) &#123;
   try &#123;
      const user = yield call(Api.fetchUser, action.payload.userId);
      yield put(&#123;type: &quot;USER_FETCH_SUCCEEDED&quot;, user: user&#125;);
   &#125; catch (e) &#123;
      yield put(&#123;type: &quot;USER_FETCH_FAILED&quot;, message: e.message&#125;);
   &#125;
&#125;

function* mySaga() &#123;
  yield takeEvery(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);
&#125;

function* mySaga() &#123;
  yield takeLatest(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);
&#125;

export default mySaga;
</code></pre>
<p>还能利用<code>Generator</code>函数，在对象上实现<code>Iterator</code>接口</p>
<pre><code class="javascript">function* iterEntries(obj) &#123;
  let keys = Object.keys(obj);
  for (let i=0; i &lt; keys.length; i++) &#123;
    let key = keys[i];
    yield [key, obj[key]];
  &#125;
&#125;

let myObj = &#123; foo: 3, bar: 7 &#125;;

for (let [key, value] of iterEntries(myObj)) &#123;
  console.log(key, value);
&#125;

// foo 3
// bar 7
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Proxy的？使用场景"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Proxy的？使用场景" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Proxy的？使用场景?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Proxy的？使用场景?</h3><p>定义： 用于定义基本操作的自定义行为</p>
<p>本质： 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程<code>(meta programming)</code></p>
<p>元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作</p>
<p>一段代码来理解</p>
<pre><code class="c">#!/bin/bash
# metaprogram
echo &#39;#!/bin/bash&#39; &gt;program
for ((I=1; I&lt;=1024; I++)) do
    echo &quot;echo $I&quot; &gt;&gt;program
done
chmod +x program
</code></pre>
<p>这段程序每执行一次能帮我们生成一个名为<code>program</code>的文件，文件内容为1024行<code>echo</code>，如果我们手动来写1024行代码，效率显然低效</p>
<ul>
<li>元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译</li>
</ul>
<p><code>Proxy</code> 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）</p>
<h4 id="二、用法-1"><a href="#二、用法-1" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Proxy</code>为 构造函数，用来生成 <code>Proxy </code>实例</p>
<pre><code class="javascript">var proxy = new Proxy(target, handler)
</code></pre>
<p>参数</p>
<p><code>target</code>表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））</p>
<p><code>handler</code>通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为</p>
<p>handler解析</p>
<p>关于<code>handler</code>拦截属性，有如下：</p>
<ul>
<li>get(target,propKey,receiver)：拦截对象属性的读取</li>
<li>set(target,propKey,value,receiver)：拦截对象属性的设置</li>
<li>has(target,propKey)：拦截<code>propKey in proxy</code>的操作，返回一个布尔值</li>
<li>deleteProperty(target,propKey)：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值</li>
<li>ownKeys(target)：拦截<code>Object.keys(proxy)</code>、<code>for...in</code>等循环，返回一个数组</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象</li>
<li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>，返回一个布尔值</li>
<li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值</li>
<li>getPrototypeOf(target)：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象</li>
<li>isExtensible(target)：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值</li>
<li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作</li>
</ul>
<p>Reflect</p>
<p>若需要在<code>Proxy</code>内部调用对象的默认行为，建议使用<code>Reflect</code>，其是<code>ES6</code>中操作对象而提供的新 <code>API</code></p>
<p>基本特点：</p>
<ul>
<li>只要<code>Proxy</code>对象具有的代理方法，<code>Reflect</code>对象全部具有，以静态方法的形式存在</li>
<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回<code>false</code>）</li>
<li>让<code>Object</code>操作都变成函数行为</li>
</ul>
<p>下面我们介绍<code>proxy</code>几种用法：</p>
<h5 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h5><p><code>get</code>接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身，最后一个参数可选</p>
<pre><code class="javascript">var person = &#123;
  name: &quot;张三&quot;
&#125;;

var proxy = new Proxy(person, &#123;
  get: function(target, propKey) &#123;
    return Reflect.get(target,propKey)
  &#125;
&#125;);

proxy.name // &quot;张三&quot;
</code></pre>
<p><code>get</code>能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引</p>
<pre><code class="javascript">function createArray(...elements) &#123;
  let handler = &#123;
    get(target, propKey, receiver) &#123;
      let index = Number(propKey);
      if (index &lt; 0) &#123;
        propKey = String(target.length + index);
      &#125;
      return Reflect.get(target, propKey, receiver);
    &#125;
  &#125;;

  let target = [];
  target.push(...elements);
  return new Proxy(target, handler);
&#125;

let arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
arr[-1] // c
</code></pre>
<p>注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错</p>
<pre><code class="javascript">const target = Object.defineProperties(&#123;&#125;, &#123;
  foo: &#123;
    value: 123,
    writable: false,
    configurable: false
  &#125;,
&#125;);

const handler = &#123;
  get(target, propKey) &#123;
    return &#39;abc&#39;;
  &#125;
&#125;;

const proxy = new Proxy(target, handler);

proxy.foo
// TypeError: Invariant check failed
</code></pre>
<h5 id="set-1"><a href="#set-1" class="headerlink" title="set()"></a>set()</h5><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 <code>Proxy</code> 实例本身</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求</p>
<pre><code class="javascript">let validator = &#123;
  set: function(obj, prop, value) &#123;
    if (prop === &#39;age&#39;) &#123;
      if (!Number.isInteger(value)) &#123;
        throw new TypeError(&#39;The age is not an integer&#39;);
      &#125;
      if (value &gt; 200) &#123;
        throw new RangeError(&#39;The age seems invalid&#39;);
      &#125;
    &#125;

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  &#125;
&#125;;

let person = new Proxy(&#123;&#125;, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错
</code></pre>
<p>如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用</p>
<pre><code class="javascript">const obj = &#123;&#125;;
Object.defineProperty(obj, &#39;foo&#39;, &#123;
  value: &#39;bar&#39;,
  writable: false,
&#125;);

const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = &#39;baz&#39;;
  &#125;
&#125;;

const proxy = new Proxy(obj, handler);
proxy.foo = &#39;baz&#39;;
proxy.foo // &quot;bar&quot;
</code></pre>
<p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错</p>
<pre><code class="javascript">&#39;use strict&#39;;
const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;
</code></pre>
<h5 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h5><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除</p>
<pre><code class="javascript">var handler = &#123;
  deleteProperty (target, key) &#123;
    invariant(key, &#39;delete&#39;);
    Reflect.deleteProperty(target,key)
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`无法删除私有属性`);
  &#125;
&#125;

var target = &#123; _prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: 无法删除私有属性
</code></pre>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错</p>
<h5 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h5><pre><code class="javascript">Proxy.revocable(target, handler);
</code></pre>
<h4 id="三、使用场景-1"><a href="#三、使用场景-1" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p><code>Proxy</code>其功能非常类似于设计模式中的代理模式，常用功能如下：</p>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<p>使用 <code>Proxy</code> 保障数据类型的准确性</p>
<pre><code class="javascript">let numericDataStore = &#123; count: 0, amount: 1234, total: 14 &#125;;
numericDataStore = new Proxy(numericDataStore, &#123;
    set(target, key, value, proxy) &#123;
        if (typeof value !== &#39;number&#39;) &#123;
            throw Error(&quot;属性只能是number类型&quot;);
        &#125;
        return Reflect.set(target, key, value, proxy);
    &#125;
&#125;);

numericDataStore.count = &quot;foo&quot;
// Error: 属性只能是number类型

numericDataStore.count = 333
// 赋值成功
</code></pre>
<p>声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></p>
<pre><code class="javascript">let api = &#123;
    _apiKey: &#39;123abc456def&#39;,
    getUsers: function()&#123; &#125;,
    getUser: function(userId)&#123; &#125;,
    setUser: function(userId, config)&#123; &#125;
&#125;;
const RESTRICTED = [&#39;_apiKey&#39;];
api = new Proxy(api, &#123;
    get(target, key, proxy) &#123;
        if(RESTRICTED.indexOf(key) &gt; -1) &#123;
            throw Error(`$&#123;key&#125; 不可访问.`);
        &#125; return Reflect.get(target, key, proxy);
    &#125;,
    set(target, key, value, proxy) &#123;
        if(RESTRICTED.indexOf(key) &gt; -1) &#123;
            throw Error(`$&#123;key&#125; 不可修改`);
        &#125; return Reflect.get(target, key, value, proxy);
    &#125;
&#125;);

console.log(api._apiKey)
api._apiKey = &#39;987654321&#39;
// 上述都抛出错误
</code></pre>
<p>还能通过使用<code>Proxy</code>实现观察者模式</p>
<p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行</p>
<p><code>observable</code>函数返回一个原始对象的 <code>Proxy</code> 代理，拦截赋值操作，触发充当观察者的各个函数</p>
<pre><code class="javascript">const queuedObservers = new Set();

const observe = fn =&gt; queuedObservers.add(fn);
const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);

function set(target, key, value, receiver) &#123;
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer =&gt; observer());
  return result;
&#125;
</code></pre>
<p>观察者函数都放进<code>Set</code>集合，当修改<code>obj</code>的值，在会<code>set</code>函数中拦截，自动执行<code>Set</code>所有的观察者</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Module的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Module的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Module的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Module的？使用场景？</h3><h4 id="一、介绍-1"><a href="#一、介绍-1" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>模块，（Module），是能够单独命名并独立地完成一定功能的程序语句集合（即程序代码和数据结构的集合体）。</p>
<p>两个基本的特征：外部特征和内部</p>
<ul>
<li>外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能</li>
<li>内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）</li>
</ul>
<h5 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h5><ul>
<li>代码抽象</li>
<li>代码封装</li>
<li>代码复用</li>
<li>依赖管理</li>
</ul>
<p>如果没有模块化，我们代码会怎样？</p>
<ul>
<li>变量和方法不容易维护，容易污染全局作用域</li>
<li>加载资源的方式通过script标签从上到下。</li>
<li>依赖的环境主观逻辑偏重，代码较多就会比较复杂。</li>
<li>大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃</li>
</ul>
<p>因此，需要一种将<code>JavaScript</code>程序模块化的机制，如</p>
<ul>
<li>CommonJs (典型代表：node.js早期)</li>
<li>AMD (典型代表：require.js)</li>
<li>CMD (典型代表：sea.js)</li>
</ul>
<h5 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h5><p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p>
<p>代表库为<code>require.js</code></p>
<pre><code class="javascript">/** main.js 入口文件/主模块 **/
// 首先用config()指定各模块路径和引用名
require.config(&#123;
  baseUrl: &quot;js/lib&quot;,
  paths: &#123;
    &quot;jquery&quot;: &quot;jquery.min&quot;,  //实际路径为js/lib/jquery.min.js
    &quot;underscore&quot;: &quot;underscore.min&quot;,
  &#125;
&#125;);
// 执行基本操作
require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123;
  // some code here
&#125;);
</code></pre>
<h5 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h5><p><code>CommonJS</code> 是一套 <code>Javascript</code> 模块规范，用于服务端</p>
<pre><code class="javascript">// a.js
module.exports=&#123; foo , bar&#125;

// b.js
const &#123; foo,bar &#125; = require(&#39;./a.js&#39;)
</code></pre>
<p>其有如下特点：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li>
<li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>
<li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li>
</ul>
<p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p>
<p>ES6 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以取代 <code>CommonJS </code>和 <code>AMD </code>规范，成为浏览器和服务器通用的模块解决方案</p>
<p><code>CommonJS</code> 和<code> AMD</code> 模块，都只能在运行时确定这些东西。比如，<code>CommonJS </code>模块就是对象，输入时必须查找对象属性</p>
<pre><code class="javascript">// CommonJS模块
let &#123; stat, exists, readfile &#125; = require(&#39;fs&#39;);

// 等同于
let _fs = require(&#39;fs&#39;);
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
</code></pre>
<p><code>ES6</code>设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
<pre><code class="javascript">// ES6模块
import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;
</code></pre>
<p>上述代码，只加载3个方法，其他方法不加载，即 <code>ES6</code> 可以在编译时就完成模块加载</p>
<p>由于编译加载，使得静态分析成为可能。包括现在流行的<code>typeScript</code>也是依靠静态分析实现功能</p>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p><code>ES6</code>模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是<code>ES5</code>之前就已经规定好</p>
<p>模块功能主要由两个命令构成：</p>
<ul>
<li><code>export</code>：用于规定模块的对外接口</li>
<li><code>import</code>：用于输入其他模块提供的功能</li>
</ul>
<h5 id="export"><a href="#export" class="headerlink" title="export"></a>export</h5><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p>
<pre><code class="javascript">// profile.js
export var firstName = &#39;Michael&#39;;
export var lastName = &#39;Jackson&#39;;
export var year = 1958;

或 
// 建议使用下面写法，这样能瞬间确定输出了哪些变量
var firstName = &#39;Michael&#39;;
var lastName = &#39;Jackson&#39;;
var year = 1958;

export &#123; firstName, lastName, year &#125;;
</code></pre>
<p>输出函数或类</p>
<pre><code class="javascript">export function multiply(x, y) &#123;
  return x * y;
&#125;;
</code></pre>
<p>通过<code>as</code>可以进行输出变量的重命名</p>
<pre><code class="javascript">function v1() &#123; ... &#125;
function v2() &#123; ... &#125;

export &#123;
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
&#125;;
</code></pre>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块</p>
<pre><code class="javascript">// main.js
import &#123; firstName, lastName, year &#125; from &#39;./profile.js&#39;;

function setName(element) &#123;
  element.textContent = firstName + &#39; &#39; + lastName;
&#125;
</code></pre>
<p>同样如果想要输入变量起别名，通过<code>as</code>关键字</p>
<pre><code class="javascript">import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;
</code></pre>
<p>当加载整个模块的时候，需要用到星号<code>*</code></p>
<pre><code class="javascript">// circle.js
export function area(radius) &#123;
  return Math.PI * radius * radius;
&#125;

export function circumference(radius) &#123;
  return 2 * Math.PI * radius;
&#125;

// main.js
import * as circle from &#39;./circle&#39;;
console.log(circle)   // &#123;area:area,circumference:circumference&#125;
</code></pre>
<p>输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性</p>
<pre><code class="javascript">import &#123;a&#125; from &#39;./xxx.js&#39;

a.foo = &#39;hello&#39;; // 合法操作
a = &#123;&#125;; // Syntax Error : &#39;a&#39; is read-only;
</code></pre>
<p>不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错</p>
<p><code>import</code>后面我们常接着<code>from</code>关键字，<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径</p>
<pre><code class="javascript">import &#123; a &#125; from &#39;./a&#39;;
</code></pre>
<p>如果只有一个模块名，需要有配置文件，告诉引擎模块的位置</p>
<pre><code class="javascript">import &#123; myMethod &#125; from &#39;util&#39;;
</code></pre>
<p>在编译阶段，<code>import</code>会提升到整个模块的头部，首先执行</p>
<pre><code class="javascript">foo();

import &#123; foo &#125; from &#39;my_module&#39;;
</code></pre>
<p>多次重复执行同样的导入，只会执行一次</p>
<pre><code class="javascript">import &#39;lodash&#39;;
import &#39;lodash&#39;;
</code></pre>
<p>上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载</p>
<p>如果不需要知道变量名或函数就完成加载，就要用到<code>export default</code>命令，为模块指定默认输出</p>
<pre><code class="javascript">// export-default.js
export default function () &#123;
    console.log(&#39;foo&#39;);
&#125;
</code></pre>
<p>加载该模块的时候，<code>import</code>命令可以为该函数指定任意名字</p>
<pre><code class="javascript">// import-default.js
import customName from &#39;./export-default&#39;;
customName(); // &#39;foo&#39;
</code></pre>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p>
<p>这个新功能允许您将<code>import()</code>作为函数调用，将其作为参数传递给模块的路径。 它返回一个 <code>promise</code>，它用一个模块对象来实现，让你可以访问该对象的导出</p>
<pre><code class="javascript">import(&#39;/modules/myModule.mjs&#39;)
  .then((module) =&gt; &#123;
    // Do something with the module.
  &#125;);
</code></pre>
<h4 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h4><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起</p>
<pre><code class="javascript">export &#123; foo, bar &#125; from &#39;my_module&#39;;

// 可以简单理解为
import &#123; foo, bar &#125; from &#39;my_module&#39;;
export &#123; foo, bar &#125;;
</code></pre>
<p>同理能够搭配<code>as</code>、<code>*</code>搭配使用</p>
<h4 id="三、使用场景-2"><a href="#三、使用场景-2" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>如今，<code>ES6</code>模块化已经深入我们日常项目开发中，像<code>vue</code>、<code>react</code>项目搭建项目，组件化开发处处可见，其也是依赖模块化实现</p>
<p><code>vue</code>组件</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;App&quot;&gt;
      组件化开发 ---- 模块化
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;HelloWorld&#39;,
  props: &#123;
    msg: String
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p><code>react</code>组件</p>
<pre><code class="javascript">function App() &#123;
  return (
    &lt;div className=&quot;App&quot;&gt;
        组件化开发 ---- 模块化
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>包括完成一些复杂应用的时候，我们也可以拆分成各个模块</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Decorator-的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Decorator-的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Decorator 的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Decorator 的？使用场景？</h3><h4 id="一、介绍-2"><a href="#一、介绍-2" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>Decorator，即装饰器，从名字上很容易让我们联想到装饰者模式</p>
<p>简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。</p>
<p><code>ES6</code>中<code>Decorator</code>功能亦如此，其本质也不是什么高大上的结构，就是一个普通的函数，用于扩展类属性和类方法</p>
<p>这里定义一个士兵，这时候他什么装备都没有</p>
<pre><code class="javascript">class soldier&#123; 
&#125;
</code></pre>
<p>定义一个得到 AK 装备的函数，即装饰器</p>
<pre><code class="javascript">function strong(target)&#123;
    target.AK = true
&#125;
</code></pre>
<p>使用该装饰器对士兵进行增强</p>
<pre><code class="javascript">@strong
class soldier&#123;
&#125;
</code></pre>
<p>这时候士兵就有武器了</p>
<pre><code class="javascript">soldier.AK // true
</code></pre>
<p>上述代码虽然简单，但也能够清晰看到了使用<code>Decorator</code>两大优点：</p>
<ul>
<li>代码可读性变强了，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原来功能进行扩展</li>
</ul>
<h4 id="二、用法-2"><a href="#二、用法-2" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Docorator</code>修饰对象为下面两种：</p>
<ul>
<li>类的装饰</li>
<li>类属性的装饰</li>
</ul>
<h5 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h5><p>当对类本身进行装饰的时候，能够接受一个参数，即类本身</p>
<p>将装饰器行为进行分解，大家能够有个更深入的了解</p>
<pre><code class="javascript">@decorator
class A &#123;&#125;

// 等同于

class A &#123;&#125;
A = decorator(A) || A;
</code></pre>
<p>下面<code>@testable</code>就是一个装饰器，<code>target</code>就是传入的类，即<code>MyTestableClass</code>，实现了为类添加静态属性</p>
<pre><code class="javascript">@testable
class MyTestableClass &#123;
  // ...
&#125;

function testable(target) &#123;
  target.isTestable = true;
&#125;

MyTestableClass.isTestable // true
</code></pre>
<p>如果想要传递参数，可以在装饰器外层再封装一层函数</p>
<pre><code class="javascript">function testable(isTestable) &#123;
  return function(target) &#123;
    target.isTestable = isTestable;
  &#125;
&#125;

@testable(true)
class MyTestableClass &#123;&#125;
MyTestableClass.isTestable // true

@testable(false)
class MyClass &#123;&#125;
MyClass.isTestable // false
</code></pre>
<h5 id="类属性的装饰"><a href="#类属性的装饰" class="headerlink" title="类属性的装饰"></a>类属性的装饰</h5><p>当对类属性进行装饰的时候，能够接受三个参数：</p>
<ul>
<li>类的原型对象</li>
<li>需要装饰的属性名</li>
<li>装饰属性名的描述对象</li>
</ul>
<p>首先定义一个<code>readonly</code>装饰器</p>
<pre><code class="javascript">function readonly(target, name, descriptor)&#123;
  descriptor.writable = false; // 将可写属性设为false
  return descriptor;
&#125;
</code></pre>
<p>使用<code>readonly</code>装饰类的<code>name</code>方法</p>
<pre><code class="javascript">class Person &#123;
  @readonly
  name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;
&#125;
</code></pre>
<p>相当于以下调用</p>
<pre><code class="javascript">readonly(Person.prototype, &#39;name&#39;, descriptor);
</code></pre>
<p>如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行</p>
<pre><code class="javascript">function dec(id)&#123;
    console.log(&#39;evaluated&#39;, id);
    return (target, property, descriptor) =&gt;console.log(&#39;executed&#39;, id);
&#125;

class Example &#123;
    @dec(1)
    @dec(2)
    method()&#123;&#125;
&#125;
// evaluated 1
// evaluated 2
// executed 2
// executed 1
</code></pre>
<p>外层装饰器<code>@dec(1)</code>先进入，但是内层装饰器<code>@dec(2)</code>先执行</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>装饰器不能用于修饰函数，因为函数存在变量声明情况</p>
<pre><code class="javascript">var counter = 0;

var add = function () &#123;
  counter++;
&#125;;

@add
function foo() &#123;
&#125;
</code></pre>
<p>编译阶段，变成下面</p>
<pre><code class="javascript">var counter;
var add;

@add
function foo() &#123;
&#125;

counter = 0;

add = function () &#123;
  counter++;
&#125;;
</code></pre>
<p>意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0</p>
<h4 id="三、使用场景-3"><a href="#三、使用场景-3" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>基于<code>Decorator</code>强大的作用，我们能够完成各种场景的需求，下面简单列举几种：</p>
<p>使用<code>react-redux</code>的时候，如果写成下面这种形式，既不雅观也很麻烦</p>
<pre><code class="javascript">class MyReactComponent extends React.Component &#123;&#125;

export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);
</code></pre>
<p>通过装饰器就变得简洁多了</p>
<pre><code class="javascript">@connect(mapStateToProps, mapDispatchToProps)
export default class MyReactComponent extends React.Component &#123;&#125;
</code></pre>
<p>将<code>mixins</code>，也可以写成装饰器，让使用更为简洁了</p>
<pre><code class="javascript">function mixins(...list) &#123;
  return function (target) &#123;
    Object.assign(target.prototype, ...list);
  &#125;;
&#125;

// 使用
const Foo = &#123;
  foo() &#123; console.log(&#39;foo&#39;) &#125;
&#125;;

@mixins(Foo)
class MyClass &#123;&#125;

let obj = new MyClass();
obj.foo() // &quot;foo&quot;
</code></pre>
<p>下面再讲讲<code>core-decorators.js</code>几个常见的装饰器</p>
<h5 id="antobind"><a href="#antobind" class="headerlink" title="@antobind"></a>@antobind</h5><p><code>autobind</code>装饰器使得方法中的<code>this</code>对象，绑定原始对象</p>
<pre><code class="javascript">import &#123; autobind &#125; from &#39;core-decorators&#39;;

class Person &#123;
  @autobind
  getPerson() &#123;
    return this;
  &#125;
&#125;

let person = new Person();
let getPerson = person.getPerson;

getPerson() === person;
// true
</code></pre>
<h5 id="readonly"><a href="#readonly" class="headerlink" title="@readonly"></a>@readonly</h5><p><code>readonly</code>装饰器使得属性或方法不可写</p>
<pre><code class="javascript">import &#123; readonly &#125; from &#39;core-decorators&#39;;

class Meal &#123;
  @readonly
  entree = &#39;steak&#39;;
&#125;

var dinner = new Meal();
dinner.entree = &#39;salmon&#39;;
// Cannot assign to read only property &#39;entree&#39; of [object Object]
</code></pre>
<h4 id="deprecate"><a href="#deprecate" class="headerlink" title="@deprecate"></a>@deprecate</h4><p><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除</p>
<pre><code class="javascript">import &#123; deprecate &#125; from &#39;core-decorators&#39;;

class Person &#123;
  @deprecate
  facepalm() &#123;&#125;

  @deprecate(&#39;功能废除了&#39;)
  facepalmHard() &#123;&#125;
&#125;

let person = new Person();

person.facepalm();
// DEPRECATION Person#facepalm: This function will be removed in future versions.

person.facepalmHard();
// DEPRECATION Person#facepalmHard: 功能废除了
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-Symbol数据类型"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-Symbol数据类型" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Symbol数据类型"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Symbol数据类型</h3><p>ES6引入一种新的原始数据类型为 Symbol ，表示为 独一无二 的值，用来定义独一无二的对象属性名。</p>
<h4 id="Symbol的讲解"><a href="#Symbol的讲解" class="headerlink" title="Symbol的讲解"></a>Symbol的讲解</h4><p>4个方面说说Symbol数据类型：</p>
<ol>
<li>Symbol的定义；</li>
<li>Symbol作为对象属性名；</li>
<li>Symbol使用场景；</li>
<li>Symbol获取。</li>
</ol>
<h4 id="Symbol的定义"><a href="#Symbol的定义" class="headerlink" title="Symbol的定义"></a>Symbol的定义</h4><ul>
<li>一种Symbol类型可以通过使用Symbol()函数来生成；</li>
<li>Symbol()函数可以接收一个字符串作为参数</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let s1 = Symbol(&#39;web&#39;);
let s2 = Symbol(&#39;web&#39;);
console.log(s1 === s2);
console.log(typeof s1);
console.log(typeof s2);
复制代码
</code></pre>
<p>chrome截图：</p>
<p><img src="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/170563012a3ecec6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p>由图可知：Symbol()函数接收的参数相同，其变量的值也不同，s1和s2是Symbol类型的变量，因为变量的值不同，所以打印的结果为false。使用typeof来获取相应的类型，所以打印的结果都为symbol。</p>
<h4 id="Symbol作为对象属性名"><a href="#Symbol作为对象属性名" class="headerlink" title="Symbol作为对象属性名"></a>Symbol作为对象属性名</h4><p>Symbol可以通过三种方式作为对象属性名。</p>
<ul>
<li>第一种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;&#125;;
a[symbol] = &#39;web&#39;;
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，一个空的对象为a，通过a[symbol]给a对象赋值一个web的字符串。表示symbol作为对象属性名，web作为它的属性值。</p>
<ul>
<li>第二种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;
    [symbol]:&#39;web&#39;
&#125;;
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，接着在声明对象a的同时通过[symbol]给a对象性赋值为web的字符串。</p>
<ul>
<li>第三种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;&#125;;
Object.defineProperty(a, symbol, &#123;value: &#39;web&#39;&#125;);
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，一个空对象为a，通过Object.defineProperty()方法给a对象赋值为web的字符串。</p>
<blockquote>
<p>Symbol的值作为对象属性名，是不能用点运算符的。</p>
</blockquote>
<h4 id="Symbol使用场景"><a href="#Symbol使用场景" class="headerlink" title="Symbol使用场景"></a>Symbol使用场景</h4><p>一种有两种使用场景：</p>
<ol>
<li>因为Symbol的值是均不相等的，所以Symbol类型的值作为对象属性名，不会出现重复。</li>
<li>代码形成强耦合的某一个具体的字符串。</li>
</ol>
<h4 id="Symbol获取"><a href="#Symbol获取" class="headerlink" title="Symbol获取"></a>Symbol获取</h4><p>通过Object.getOwnPropertySymbols()方法，可以获取指定对象的所有Symbols属性名。:</p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全服务端"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/"
    >前端面试大全服务端</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/" class="article-date">
  <time datetime="2022-10-30T02:39:46.000Z" itemprop="datePublished">2022-10-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E6%9C%8D%E5%8A%A1%E7%AB%AF/">服务端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（服务端）"><a href="#前端面试题大全（服务端）" class="headerlink" title="前端面试题大全（服务端）"></a>前端面试题大全（服务端）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="♥︎-♥︎-♥︎-http状态码有哪些"><a href="#♥︎-♥︎-♥︎-http状态码有哪些" class="headerlink" title="♥︎ ♥︎ ♥︎ http状态码有哪些"></a>♥︎ ♥︎ ♥︎ http状态码有哪些</h3><p><code>http</code>状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态</p>
<p>状态码第一位数字决定了不同的响应状态，有如下：</p>
<ul>
<li>1 表示消息</li>
<li>2 表示成功</li>
<li>3 表示重定向</li>
<li>4 表示请求错误</li>
<li>5 表示服务器错误</li>
</ul>
<h4 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h4><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</p>
<p>常见的有：</p>
<ul>
<li>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li>
<li>101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级</li>
</ul>
<h4 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h4><p>代表请求已成功被服务器接收、理解、并接受</p>
<p>常见的有：</p>
<ul>
<li>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</li>
<li>201（已创建）：请求成功并且服务器创建了新的资源</li>
<li>202（已创建）：服务器已经接收请求，但尚未处理</li>
<li>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</li>
<li>204（无内容）：服务器成功处理请求，但没有返回任何内容</li>
<li>205（重置内容）：服务器成功处理请求，但没有返回任何内容</li>
<li>206（部分内容）：服务器成功处理了部分请求</li>
</ul>
<h4 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h4><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</p>
<p>常见的有：</p>
<ul>
<li>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</li>
<li>301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li>
<li>302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li>
<li>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li>
<li>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</li>
<li>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li>
</ul>
<h4 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h4><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</p>
<p>常见的有：</p>
<ul>
<li>400（错误请求）： 服务器不理解请求的语法</li>
<li>401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li>
<li>403（禁止）： 服务器拒绝请求</li>
<li>404（未找到）： 服务器找不到请求的网页</li>
<li>405（方法禁用）： 禁用请求中指定的方法</li>
<li>406（不接受）： 无法使用请求的内容特性响应请求的网页</li>
<li>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</li>
<li>408（请求超时）： 服务器等候请求时发生超时</li>
</ul>
<h4 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h4><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p>
<p>常见的有：</p>
<ul>
<li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li>
<li>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</li>
<li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li>
<li>503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）</li>
<li>504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li>
<li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li>
</ul>
<p>下面给出一些状态码的适用场景：</p>
<ul>
<li>100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输</li>
<li>206：一般用来做断点续传，或者是视频文件等大文件的加载</li>
<li>301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名</li>
<li>302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</li>
<li>304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</li>
<li>400：参数有误，请求无法被服务器识别</li>
<li>403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回</li>
<li>404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时</li>
<li>503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503</li>
<li>504：网关超时</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-你知道哪些http首部字段？"><a href="#♥︎-♥︎-♥︎-你知道哪些http首部字段？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你知道哪些http首部字段？"></a>♥︎ ♥︎ ♥︎ 你知道哪些http首部字段？</h3><p>HTTP头字段（HTTP header fields）,是指在超文本传输协议（HTTP）的请求和响应消息中的消息头部分</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>能够接受的回应内容类型（Content-Types）</td>
<td>Accept: text&#x2F;plain</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>能够接受的字符集</td>
<td>Accept-Charset: utf-8</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>能够接受的编码方式列表</td>
<td>Accept-Encoding: gzip, deflate</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>能够接受的回应内容的自然语言列表</td>
<td>Accept-Language: en-US</td>
</tr>
<tr>
<td>Authorization</td>
<td>用于超文本传输协议的认证的认证信息</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>用来指定在这次的请求&#x2F;响应链中的所有缓存机制 都必须 遵守的指令</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>该浏览器想要优先使用的连接类型</td>
<td>Connection: keep-alive Connection: Upgrade</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie</td>
<td>Cookie: $Version&#x3D;1; Skin&#x3D;new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>以 八位字节数组 （8位的字节）表示的请求体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的 多媒体类型</td>
<td>Content-Type: application&#x2F;x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>发送该消息的日期和时间</td>
<td>Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>表明客户端要求服务器做出特定的行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>Host</td>
<td>服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号</td>
<td>Host: en.wikipedia.org:80 Host: en.wikipedia.org</td>
</tr>
<tr>
<td>If-Match</td>
<td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>允许在对应的内容未被修改的情况下返回304未修改</td>
<td>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>允许在对应的内容未被修改的情况下返回304未修改</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Range</td>
<td>仅请求某个实体的一部分</td>
<td>Range: bytes&#x3D;500-999</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器的浏览器身份标识字符串</td>
<td>User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:12.0) Gecko&#x2F;20100101 Firefox&#x2F;21.0</td>
</tr>
<tr>
<td>Origin</td>
<td>发起一个针对 跨来源资源共享 的请求</td>
<td>Origin: <a target="_blank" rel="noopener" href="http://www.example-social-network.com/">http://www.example-social-network.com</a></td>
</tr>
</tbody></table>
<h3 id="♥︎-♥︎-♥︎-为什么浏览器要限制TCP的最大个数"><a href="#♥︎-♥︎-♥︎-为什么浏览器要限制TCP的最大个数" class="headerlink" title="♥︎ ♥︎ ♥︎ 为什么浏览器要限制TCP的最大个数"></a>♥︎ ♥︎ ♥︎ 为什么浏览器要限制TCP的最大个数</h3><p>建立一个tcp连接需要：1，socket文件描述符；2，IP地址；3，端口；4，内存</p>
<p>1、内存资源： 一个tcp连接最小占用内存为4096+4096 &#x3D; 8k， 那么对于一个8G内存的机器，在不考虑其他限制下， 最多支持的并发量为：810241024&#x2F;8 约等于100万， 在实际中，由于linux kernel对一些资源的限制， 加上程序的业务处理，所以，8G内存是很难达到100万连接的</p>
<p>2、CPU资源</p>
<h3 id="♥︎-♥︎-♥︎-说说-HTTP1-0-x2F-1-1-x2F-2-0-的区别"><a href="#♥︎-♥︎-♥︎-说说-HTTP1-0-x2F-1-1-x2F-2-0-的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?"></a>♥︎ ♥︎ ♥︎ 说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?</h3><h4 id="一、HTTP1-0"><a href="#一、HTTP1-0" class="headerlink" title="一、HTTP1.0"></a>一、HTTP1.0</h4><p><code>HTTP</code>协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本</p>
<p><code>HTTP 1.0</code> 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个<code>TCP</code>连接</p>
<p>服务器完成请求处理后立即断开<code>TCP</code>连接，服务器不跟踪每个客户也不记录过去的请求</p>
<p>简单来讲，每次与服务器交互，都需要新开一个连接</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65666666346461302d623933612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>例如，解析<code>html</code>文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接</p>
<p>最终导致，一个<code>html</code>文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接</p>
<p>这种形式明显造成了性能上的缺陷</p>
<p>如果需要建立长连接，需要设置一个非标准的Connection字段 <code>Connection: keep-alive</code></p>
<h4 id="二、HTTP1-1"><a href="#二、HTTP1-1" class="headerlink" title="二、HTTP1.1"></a>二、HTTP1.1</h4><p>在<code>HTTP1.1</code>中，默认支持长连接（<code>Connection: keep-alive</code>），即在一个TCP连接上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟</p>
<p>建立一次连接，多次请求均由这个连接完成</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32326462326239302d623933622d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>这样，在加载<code>html</code>文件的时候，文件中多个请求和响应就可以在一个连接中传输</p>
<p>同时，<code>HTTP 1.1</code>还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间</p>
<p>同时，<code>HTTP1.1</code>在<code>HTTP1.0</code>的基础上，增加更多的请求头和响应头来完善的功能，如下：</p>
<ul>
<li>引入了更多的缓存控制策略，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略</li>
<li>引入range，允许值请求资源某个部分</li>
<li>引入host，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点</li>
</ul>
<p>并且还添加了其他的请求方法：<code>put</code>、<code>delete</code>、<code>options</code>…</p>
<h4 id="三、HTTP2-0"><a href="#三、HTTP2-0" class="headerlink" title="三、HTTP2.0"></a>三、HTTP2.0</h4><p>而<code>HTTP2.0</code>在相比之前版本，性能上有很大的提升，如添加了一个特性：</p>
<ul>
<li>多路复用</li>
<li>二进制分帧</li>
<li>首部压缩</li>
<li>服务器推送</li>
</ul>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p><code>HTTP/2</code> 复用<code>TCP</code>连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33313366313938302d623933622d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>上图中，可以看到第四步中<code>css</code>、<code>js</code>资源是同时发送到服务端</p>
<h5 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h5><p>帧是<code>HTTP2</code>通信中最小单位信息</p>
<p><code>HTTP/2</code> 采用二进制格式传输数据，而非 <code>HTTP 1.x </code>的文本格式，解析起来更高效</p>
<p>将请求和响应数据分割为更小的帧，并且它们采用二进制编码</p>
<p><code>HTTP2 </code>中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流</p>
<p>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件</p>
<h5 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h5><p><code>HTTP/2</code>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送</p>
<p>首部表在<code>HTTP/2</code>的连接存续期内始终存在，由客户端和服务器共同渐进地更新</p>
<p>例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33633533363734302d623933622d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><p><code>HTTP2</code>引入服务器推送，允许服务端推送资源给客户端</p>
<p>服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源</p>
<p>免得客户端再次创建连接发送请求到服务器端获取</p>
<p>这种方式非常合适加载静态资源</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34373133303535302d623933622d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>HTTP1.0：</p>
<ul>
<li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接</li>
</ul>
<p>HTTP1.1：</p>
<ul>
<li>引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用</li>
<li>在同一个TCP连接里面，客户端可以同时发送多个请求</li>
<li>虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li>
<li>新增了一些请求方法</li>
<li>新增了一些请求头和响应头</li>
</ul>
<p>HTTP2.0：</p>
<ul>
<li>采用二进制格式而非文本格式</li>
<li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li>
<li>使用报头压缩，降低开销</li>
<li>服务器推送</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-HTTP2-0的特点"><a href="#♥︎-♥︎-♥︎-HTTP2-0的特点" class="headerlink" title="♥︎ ♥︎ ♥︎  HTTP2.0的特点"></a>♥︎ ♥︎ ♥︎  HTTP2.0的特点</h3><p>HTTP2.0大幅度的提高了web性能，在HTTP1.1完全语意兼容的基础上，进一步减少了网络的延迟。</p>
<ol>
<li>二进制分帧</li>
<li>多路复用</li>
<li>首部压缩</li>
<li>流量控制</li>
<li>请求优先级</li>
<li>服务器推送</li>
</ol>
<h3 id="♥︎-♥︎-♥︎-简述https原理，以及与http的区别"><a href="#♥︎-♥︎-♥︎-简述https原理，以及与http的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ 简述https原理，以及与http的区别"></a>♥︎ ♥︎ ♥︎ 简述https原理，以及与http的区别</h3><ol>
<li>HTTP协议工作在80端口，HTTPS协议工作在443端口</li>
<li>HTTPS需要申请证书（用于验证服务器身份）</li>
<li>HTTP在TCP三次握手建立连接之后即可开始传输数据；HTTPS协议则需要在建立TCP连接之后客户端与服务器在进行SSL加密，确定对话密钥，完成加密后才开始传输数据。</li>
<li>HTTPS协议传输是密文，HTTP协议传输是明文</li>
</ol>
<h3 id="♥︎-♥︎-♥︎-CDN-是什么？描述下-CDN-原理？为什么要用-CDN"><a href="#♥︎-♥︎-♥︎-CDN-是什么？描述下-CDN-原理？为什么要用-CDN" class="headerlink" title="♥︎ ♥︎ ♥︎ CDN 是什么？描述下 CDN 原理？为什么要用 CDN?"></a>♥︎ ♥︎ ♥︎ CDN 是什么？描述下 CDN 原理？为什么要用 CDN?</h3><p>CDN的全称是Content Delivery Network，即内容分发网络 共有云厂商在全世界各地都遍布不计其数都数据中心和服务器， CDN服务简单来讲就是这些厂商将你的服务器上面的文档分发到他们不同地区的服务器的当中， 每个地区可以称为一个节点，这样用户在访问你的网址时， 浏览器发送的请求就会优先绕去离客户最近的节点来获取数据， 这样方便客户更快的速度访问网站。 CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器， 通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容， 降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
<h3 id="♥︎-♥︎-♥︎-DNS-查询的过程，分为哪两种，是怎么一个过程"><a href="#♥︎-♥︎-♥︎-DNS-查询的过程，分为哪两种，是怎么一个过程" class="headerlink" title="♥︎ ♥︎ ♥︎ DNS 查询的过程，分为哪两种，是怎么一个过程"></a>♥︎ ♥︎ ♥︎ DNS 查询的过程，分为哪两种，是怎么一个过程</h3><p>1、分布域名解析：是指分在客户端上维护一个静态的文本文件，其中包含主机名和IP地址的映射。 随着网络规模的扩大，分布式分辨率的有效性越来越低。</p>
<p>2、集中式域名解析：要求网络中有多台DNS服务器，负责维护域名&#x2F;IP地址映射数据库。 客户端从指定的服务器获取域名的地址信息。一旦客户端指定的DNS服务器不包含相应的数据， DNS服务器就会在网络中进行递归查询，并获取其他服务器上的地址信息。</p>
<h3 id="♥︎-♥︎-♥︎-强缓存和协商缓存的区别"><a href="#♥︎-♥︎-♥︎-强缓存和协商缓存的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ 强缓存和协商缓存的区别"></a>♥︎ ♥︎ ♥︎ 强缓存和协商缓存的区别</h3><p>强缓存（本地缓存）:直接使用本地的缓存，不用跟服务器进行通信</p>
<p>相关header字段</p>
<p>expires：一个未来时间，代表请求有效期，没有过期之前都使用当前请求。</p>
<p>cache-control</p>
<p>no-cache：不使用本地缓存。向浏览器发送新鲜度校验请求</p>
<p>pubilc：任何情况下都缓存（即使是HTTP认证的资源）</p>
<p>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存</p>
<p>no-store：禁止浏览器缓存数据，也禁止保存至临时文件中，每次都重新请求，多次设置 cache-control，优先级最高</p>
<p>协商缓存:将资源一些相关信息返回服务器，让服务器判断浏览器是否能直接使用本地缓存，整个过程至少与服务器通信一次</p>
<p>相关header字段</p>
<p>Last-Modified&#x2F;If-Modified-Since（两个都是时间格式字符串）</p>
<p>浏览器第一次发请求，服务器在返回的 respone 的 header 加上 Last-Modified，表示资源的最后修改时间再次请求资源，在 requset 的 header 加上 If-Modified-Since ，值就是上一次请求返回的 Last-Modified 值</p>
<p>服务器根据请求传过来的值判断资源是否有变化，没有则返回 304，有变化就正常返回资源内容，更新 LastModified 的值</p>
<p>304 从缓存加载资源，否则直接从服务器加载资源</p>
<p>Etag&#x2F;If-None-Match与 Last-Modified&#x2F;If-Modified-Since 不同的是，返回 304 时，ETag 还是会重新生成返回至浏览器。</p>
<h3 id="♥︎-♥︎-♥︎-为什么from表单提交没有跨域问题，但ajax有跨域问题"><a href="#♥︎-♥︎-♥︎-为什么from表单提交没有跨域问题，但ajax有跨域问题" class="headerlink" title="♥︎ ♥︎ ♥︎ 为什么from表单提交没有跨域问题，但ajax有跨域问题"></a>♥︎ ♥︎ ♥︎ 为什么from表单提交没有跨域问题，但ajax有跨域问题</h3><p>浏览器的策略本质是：一个域名下面的JS，没有经过允许是不能读取另一个域名的内容，但是浏览器不阻止你向另外一个域名发送请求。 所以form表单提交没有跨域问题，提交form表单到另外一个域名，原来页面是无法获取新页面的内容，或者说form提交后不需要返回，但是ajax是需要返回的。 而ajax是想要读取响应内容，浏览器是不允许你这么做的。 浏览器的安全策略限制的是js脚本，并不限制src，form表单提交之类的请求， 就是说form表单提交不存在安全问题，ajax提交跨域存在安全问题。</p>
<hr>
<h3 id="♥︎-♥︎-♥︎-♥︎-url从输入到渲染页面的全过程"><a href="#♥︎-♥︎-♥︎-♥︎-url从输入到渲染页面的全过程" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ url从输入到渲染页面的全过程"></a>♥︎ ♥︎ ♥︎ ♥︎ url从输入到渲染页面的全过程</h3><p>浏览器构建HTTP Request请求， DNS解析URL地址、生成HTTP请求报文、构建TCP连接、使用IP协议选择传输路线</p>
<p>将请求通过网络传输到服务端 </p>
<p>从客户机到服务器需要通过许多网络设备，一般包括集线器、交换器、路由器等</p>
<p>服务器构建HTTP Response响应，响应客户端的请求</p>
<p>将响应体的数据通过网络传输返回给客户端</p>
<p>浏览器渲染页面 解析HTML、CSS、JS，生成RenderTree渲染页面</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-TCP为什么需要三次握手和四次挥手？"><a href="#♥︎-♥︎-♥︎-♥︎-TCP为什么需要三次握手和四次挥手？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ TCP为什么需要三次握手和四次挥手？"></a>♥︎ ♥︎ ♥︎ ♥︎ TCP为什么需要三次握手和四次挥手？</h3><h4 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h4><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包</p>
<p>主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</p>
<p>过程如下：</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接</li>
</ul>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66623438396663302d626562392d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>上述每一次握手的作用如下：</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了<br>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了<br>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常</li>
<li>第三次握手：客户端发包，服务端收到了。<br>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</li>
</ul>
<p>通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了</p>
<h4 id="为什么不是两次握手"><a href="#为什么不是两次握手" class="headerlink" title="为什么不是两次握手?"></a>为什么不是两次握手?</h4><p>如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到</p>
<p>并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源</p>
<h4 id="二、四次挥手"><a href="#二、四次挥手" class="headerlink" title="二、四次挥手"></a>二、四次挥手</h4><p><code>tcp</code>终止一个连接，需要经过四次挥手</p>
<p>过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li>
</ul>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613365626239302d626562612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="四次挥手原因"><a href="#四次挥手原因" class="headerlink" title="四次挥手原因"></a>四次挥手原因</h4><p>服务端在收到客户端断开连接<code>Fin</code>报文后，并不会立即关闭连接，而是先发送一个<code>ACK</code>包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送<code>FIN</code>报文断开连接，因此需要四次挥手</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>一个完整的三次握手四次挥手如下图所示：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36353934313439302d626562612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-说一下http缓存策略，有什么区别，分别解决了什么问题？"><a href="#♥︎-♥︎-♥︎-♥︎-说一下http缓存策略，有什么区别，分别解决了什么问题？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说一下http缓存策略，有什么区别，分别解决了什么问题？"></a>♥︎ ♥︎ ♥︎ ♥︎ 说一下http缓存策略，有什么区别，分别解决了什么问题？</h3><p>浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存, 如果缓存有效，则使用本地缓存。</p>
<p>向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求， 将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。</p>
<p>强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</p>
<p>协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率， 将缓存信息中的Etag和Last-Modified,通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p>
<p>解决问题</p>
<ol>
<li>减少了冗余的数据传输</li>
<li>减少了服务器的负担，大大提升了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<h3 id="♥︎-♥︎-♥︎-♥︎-为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？"><a href="#♥︎-♥︎-♥︎-♥︎-为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？"></a>♥︎ ♥︎ ♥︎ ♥︎ 为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？</h3><h4 id="一、安全特性"><a href="#一、安全特性" class="headerlink" title="一、安全特性"></a>一、安全特性</h4><p>在上篇文章中，我们了解到<code>HTTP</code>在通信过程中，存在以下问题：</p>
<ul>
<li>通信使用明文（不加密），内容可能被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
</ul>
<p>而<code>HTTPS</code>的出现正是解决这些问题，<code>HTTPS</code>是建立在<code>SSL</code>之上，其安全性由<code>SSL</code>来保证</p>
<p>在采用<code>SSL</code>后，<code>HTTP</code>就拥有了<code>HTTPS</code>的加密、证书和完整性保护这些功能</p>
<blockquote>
<p>SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议</p>
</blockquote>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63623535393430302d623266662d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h4><p><code>SSL </code>的实现这些功能主要依赖于三种手段：</p>
<ul>
<li>对称加密：采用协商的密钥对数据加密</li>
<li>非对称加密：实现身份认证和密钥协商</li>
<li>摘要算法：验证信息的完整性</li>
<li>数字签名：身份验证</li>
</ul>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65336630343066302d623266662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密</p>
<p>公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64393630336536302d623266662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>在<code>HTTPS</code>通信过程中，采用的是对称加密+非对称加密，也就是混合加密</p>
<p>在对称加密中讲到，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性</p>
<p>而<code>HTTPS</code>采用非对称加密解决秘钥交换的问题</p>
<p>具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66333735663239302d623266662d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</p>
<h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文</p>
<p>上述的方法解决了数据加密，在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客解决</p>
<p>因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是摘要算法</p>
<h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数</p>
<p>可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31323739386461302d623330302d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性</p>
<p>比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/16ceb478a4cdc255009ba6912fff85ef91ddf5711b279527344a12bef47619e1/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30323337393065302d623330302d313165622d616239302d6439616538313462323430642e706e67"><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30323337393065302d623330302d313165622d616239302d6439616538313462323430642e706e67.png" alt="img"></a></p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名</p>
<p>原理其实很简单，就是用私钥加密，公钥解密</p>
<p>签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32316161363838302d623330302d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥</p>
<p>这时候就需要一个第三方，就是证书验证机构</p>
<h4 id="CA验证机构"><a href="#CA验证机构" class="headerlink" title="CA验证机构"></a>CA验证机构</h4><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场</p>
<p>CA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”</p>
<p>流程如下图：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33393536343861302d623330302d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<ul>
<li><p>服务器的运营人员向数字证书认证机构提出公开密钥的申请</p>
</li>
<li><p>数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名</p>
</li>
<li><p>然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起</p>
</li>
<li><p>服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明：认证服务器的公开密钥的是真实有效的数字证书认证机构</p>
</li>
<li><p>服务器的公开密钥是值得信赖的</p>
</li>
</ul>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，<code>HTTPS</code>与<code>HTTP</code>虽然只差一个<code>SSL</code>，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：</p>
<ul>
<li>机密性：混合算法</li>
<li>完整性：摘要算法</li>
<li>身份认证：数字签名</li>
<li>不可否定：数字签名</li>
</ul>
<p>同时引入第三方证书机构，确保公开秘钥的安全性</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-如何理解UDP-和-TCP-区别-应用场景"><a href="#♥︎-♥︎-♥︎-♥︎-如何理解UDP-和-TCP-区别-应用场景" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 如何理解UDP 和 TCP? 区别? 应用场景?"></a>♥︎ ♥︎ ♥︎ ♥︎ 如何理解UDP 和 TCP? 区别? 应用场景?</h3><h4 id="一、UDP"><a href="#一、UDP" class="headerlink" title="一、UDP"></a>一、UDP</h4><p>UDP（User Datagram Protocol），用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层</p>
<p>也就是说无论应用层交给<code>UDP</code>多长的报文，它统统发送，一次发送一个报文</p>
<p>而对接收方，接到后直接去除首部，交给上面的应用层就完成任务</p>
<p><code>UDP</code>报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39323865356432302d623339332d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>特点如下：</p>
<ul>
<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务</li>
<li>传输途中出现丢包，UDP 也不负责重发</li>
<li>当包的到达顺序出现乱序时，UDP没有纠正的功能。</li>
<li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为</li>
</ul>
<h4 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h4><p>TCP（Transmission Control Protocol），传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送</p>
<p>可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小</p>
<p><code>TCP</code>报文首部有20个字节，额外开销大</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61303031306434302d623339332d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>特点如下：</p>
<ul>
<li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li>
<li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li>
<li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）</li>
</ul>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p><code>UDP</code>与<code>TCP</code>两者的都位于传输层，如下图所示：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61393262646138302d623339332d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>两者区别如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>可靠性</td>
<td>可靠</td>
<td>不可靠</td>
</tr>
<tr>
<td>连接性</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>报文</td>
<td>面向字节流</td>
<td>面向报文</td>
</tr>
<tr>
<td>效率</td>
<td>传输效率低</td>
<td>传输效率高</td>
</tr>
<tr>
<td>双共性</td>
<td>全双工</td>
<td>一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td>流量控制</td>
<td>滑动窗口</td>
<td>无</td>
</tr>
<tr>
<td>拥塞控制</td>
<td>慢开始、拥塞避免、快重传、快恢复</td>
<td>无</td>
</tr>
<tr>
<td>传输效率</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
<ul>
<li>TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取</li>
<li>TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方</li>
<li>TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</li>
<li>TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</li>
</ul>
<p>两者应用场景如下图：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62366364643830302d623339332d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>可以看到，TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-如何理解OSI七层模型"><a href="#♥︎-♥︎-♥︎-♥︎-如何理解OSI七层模型" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 如何理解OSI七层模型?"></a>♥︎ ♥︎ ♥︎ ♥︎ 如何理解OSI七层模型?</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架</p>
<p><code>OSI </code>将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰</p>
<h4 id="二、划分"><a href="#二、划分" class="headerlink" title="二、划分"></a>二、划分</h4><p><code>OSI</code>主要划分了七层，如下图所示：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65623162323137302d623631652d313165622d616239302d6439616538313462323430642e706e67.png" alt="68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65623162323137302d623631652d313165622d616239302d6439616538313462323430642e706e67"></p>
<h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用</p>
<p>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 <code>DNS</code>，支持万维网应用的 <code>HTTP</code> 协议，电子邮件系统采用的 <code>SMTP </code>协议等</p>
<p>在应用层交互的数据单元我们称之为报文</p>
<h5 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h5><p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 <code>OSI </code>参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务</p>
<p>该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异</p>
<h5 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h5><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话</p>
<p>该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法</p>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题</p>
<p>传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层</p>
<p>其中，主要的传输层协议是<code>TCP</code>和<code>UDP</code></p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网</p>
<p>网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送</p>
<p>在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层</p>
<p>在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层</p>
<h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 <code>IP </code>数据报组装成帧，在两个相邻节点间的链路上传送帧</p>
<p>每一帧的数据可以分成：报头<code>head</code>和数据<code>data</code>两部分:</p>
<ul>
<li>head 标明数据发送者、接受者、数据类型，如 MAC地址</li>
<li>data 存储了计算机之间交互的数据</li>
</ul>
<p>通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源</p>
<h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>作为<code> OSI</code> 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送</p>
<p>该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）</p>
<p>该层主要是和硬件有关，与软件关系不大</p>
<h4 id="三、传输过程"><a href="#三、传输过程" class="headerlink" title="三、传输过程"></a>三、传输过程</h4><p>数据在各层之间的传输如下图所示：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66336138396434302d623631652d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<ul>
<li>应用层报文被传送到运输层</li>
<li>在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用</li>
<li>应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变</li>
<li>运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报</li>
<li>网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧</li>
<li>在物理层数据帧被封装成比特流，之后通过传输介质传送到对端</li>
<li>对端再一步步解开封装，获取到传送的数据</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-如何理解TCP-x2F-IP协议"><a href="#♥︎-♥︎-♥︎-♥︎-如何理解TCP-x2F-IP协议" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 如何理解TCP&#x2F;IP协议?"></a>♥︎ ♥︎ ♥︎ ♥︎ 如何理解TCP&#x2F;IP协议?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>TCP&#x2F;IP，传输控制协议**&#x2F;**网际协议，是指能够在多个不同网络间实现信息传输的协议簇</p>
<ul>
<li>TCP（传输控制协议）</li>
</ul>
<p>一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<ul>
<li>IP（网际协议）</li>
</ul>
<p>用于封包交换数据网络的协议</p>
<p>TCP&#x2F;IP协议不仅仅指的是<code>TCP </code>和<code>IP</code>两个协议，而是指一个由<code>FTP</code>、<code>SMTP</code>、<code>TCP</code>、<code>UDP</code>、<code>IP</code>等协议构成的协议簇，</p>
<p>只是因为在<code>TCP/IP</code>协议中<code>TCP</code>协议和<code>IP</code>协议最具代表性，所以通称为TCP&#x2F;IP协议族（英语：TCP&#x2F;IP Protocol Suite，或TCP&#x2F;IP Protocols）</p>
<h4 id="二、划分-1"><a href="#二、划分-1" class="headerlink" title="二、划分"></a>二、划分</h4><p>TCP&#x2F;IP协议族按层次分别了五层体系或者四层体系</p>
<p>五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层</p>
<p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层</p>
<p>如下图所示：</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35626239333631302d623634372d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="五层体系"><a href="#五层体系" class="headerlink" title="五层体系"></a>五层体系</h4><h5 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h5><p><code>TCP/IP</code> 模型将 <code>OSI </code>参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务</p>
<p>如：<code>FTP</code>、<code>Telnet</code>、<code>DNS</code>、<code>SMTP</code> 等</p>
<h5 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h5><p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能</p>
<p>传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）</p>
<p>其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输</p>
<h5 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h5><p>负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机</p>
<p>在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送</p>
<h5 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧</p>
<h5 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h5><p>保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境</p>
<h4 id="四层体系"><a href="#四层体系" class="headerlink" title="四层体系"></a>四层体系</h4><p>TCP&#x2F;IP 的四层结构则如下表所示：</p>
<table>
<thead>
<tr>
<th>层次名称</th>
<th>单位</th>
<th>功 能</th>
<th>协 议</th>
</tr>
</thead>
<tbody><tr>
<td>网络接口层</td>
<td>帧</td>
<td>负责实际数据的传输，对应OSI参考模型的下两层</td>
<td>HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）</td>
</tr>
<tr>
<td>网络层</td>
<td>数据报</td>
<td>负责网络间的寻址数据传输，对应OSI参考模型的第三层</td>
<td>IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）</td>
</tr>
<tr>
<td>传输层</td>
<td>报文段</td>
<td>负责提供可靠的传输服务，对应OSI参考模型的第四层</td>
<td>TCP（控制传输协议） UDP（用户数据报协议）</td>
</tr>
<tr>
<td>应用层</td>
<td></td>
<td>负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层</td>
<td>FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）</td>
</tr>
</tbody></table>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>OSI 参考模型与 TCP&#x2F;IP 参考模型区别如下：</p>
<p>相同点：</p>
<ul>
<li>OSI 参考模型与 TCP&#x2F;IP 参考模型都采用了层次结构</li>
<li>都能够提供面向连接和无连接两种通信服务机制</li>
</ul>
<p>不同点：</p>
<ul>
<li>OSI 采用的七层模型； TCP&#x2F;IP 是四层或五层结构</li>
<li>TCP&#x2F;IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分</li>
<li>OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP&#x2F;IP 参考模型作为一种简化的分层结构是可以的</li>
<li>TCP&#x2F;IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 <code>OSI</code> 设想中的应用程序维度的分层是无法实现的</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-说一下-GET-和-POST-的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-说一下-GET-和-POST-的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说一下 GET 和 POST 的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ 说一下 GET 和 POST 的区别？</h3><p><code>GET</code>和<code>POST</code>，两者是<code>HTTP</code>协议中发送请求的方法</p>
<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p><code>GET</code>方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据</p>
<h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p><code>POST</code>方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用</p>
<p>本质上都是<code>TCP</code>链接，并无差别</p>
<p>但是由于<code>HTTP</code>的规定和浏览器&#x2F;服务器的限制，导致他们在应用过程中会体现出一些区别</p>
<h4 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h4><p>从<code>w3schools</code>得到的标准答案的区别如下：</p>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中</li>
</ul>
<h4 id="参数位置"><a href="#参数位置" class="headerlink" title="参数位置"></a>参数位置</h4><p>貌似从上面看到<code>GET</code>与<code>POST</code>请求区别非常大，但两者实质并没有区别</p>
<p>无论 <code>GET </code>还是 <code>POST</code>，用的都是同一个传输层协议，所以在传输上没有区别</p>
<p>当不携带参数的时候，两者最大的区别为第一行方法名不同</p>
<blockquote>
<p>POST &#x2F;uri HTTP&#x2F;1.1 \r\n</p>
<p>GET &#x2F;uri HTTP&#x2F;1.1 \r\n</p>
</blockquote>
<p>当携带参数的时候，我们都知道<code>GET</code>请求是放在<code>url</code>中，<code>POST</code>则放在<code>body</code>中</p>
<p><code>GET</code> 方法简约版报文是这样的</p>
<pre><code class="http">GET /index.html?name=qiming.c&amp;age=22 HTTP/1.1
Host: localhost
</code></pre>
<p><code>POST </code>方法简约版报文是这样的</p>
<pre><code class="http">POST /index.html HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded

name=qiming.c&amp;age=22
</code></pre>
<p>注意：这里只是约定，并不属于<code>HTTP</code>规范，相反的，我们可以在<code>POST</code>请求中<code>url</code>中写入参数，或者<code>GET</code>请求中的<code>body</code>携带参数</p>
<h4 id="参数长度"><a href="#参数长度" class="headerlink" title="参数长度"></a>参数长度</h4><p><code>HTTP </code>协议没有<code>Body</code>和 <code>URL</code> 的长度限制，对 <code>URL </code>限制的大多是浏览器和服务器的原因</p>
<p><code>IE</code>对<code>URL</code>长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持</p>
<p>这里限制的是整个<code>URL</code>长度，而不仅仅是参数值的长度</p>
<p>服务器处理长<code> URL</code> 要消耗比较多的资源，为了性能和安全考虑，会给 <code>URL</code> 长度加限制</p>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p><code>POST </code>比<code> GET</code> 安全，因为数据在地址栏上不可见</p>
<p>然而，从传输的角度来说，他们都是不安全的，因为<code> HTTP</code> 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文</p>
<p>只有使用<code>HTTPS</code>才能加密安全</p>
<h4 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h4><p>对于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应200（返回数据）</p>
<p>对于<code>POST</code>，浏览器先发送<code>header</code>，服务器响应100 <code>continue</code>，浏览器再发送<code>data</code>，服务器响应200 ok</p>
<p>并不是所有浏览器都会在<code>POST</code>中发送两次包，<code>Firefox</code>就只发送一次</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-对WebSocket的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-对WebSocket的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 对WebSocket的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ 对WebSocket的理解？应用场景？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>WebSocket，是一种网络传输协议，位于<code>OSI</code>模型的应用层。可在单个<code>TCP</code>连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅</p>
<p>客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</p>
<p><img src="/2022/10/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61643338366532302d633066312d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>从上图可见，<code>websocket</code>服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接受数据</p>
<p>而在<code>websocket</code>出现之前，开发实时<code>web</code>应用的方式为轮询</p>
<p>不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果</p>
<p>轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 <code>CPU </code>资源</p>
<h4 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h4><h5 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h5><p>通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合</p>
<p>例如指 A→B 的同时 B→A ，是瞬时同步的</p>
<h5 id="二进制帧"><a href="#二进制帧" class="headerlink" title="二进制帧"></a>二进制帧</h5><p>采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比<code>http/2</code>，<code>WebSocket </code>更侧重于“实时通信”，而<code>HTTP/2</code> 更侧重于提高传输效率，所以两者的帧结构也有很大的区别</p>
<p>不像 <code>HTTP/2</code> 那样定义流，也就不存在多路复用、优先级等特性</p>
<p>自身就是全双工，也不需要服务器推送</p>
<h5 id="协议名"><a href="#协议名" class="headerlink" title="协议名"></a>协议名</h5><p>引入<code>ws</code>和<code>wss</code>分别代表明文和密文的<code>websocket</code>协议，且默认端口使用80或443，几乎与<code>http</code>一致</p>
<pre><code class="http">ws://www.chrono.com
ws://www.chrono.com:8080/srv
wss://www.chrono.com:445/im?user_id=xxx
</code></pre>
<h5 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h5><p><code>WebSocket </code>也要有一个握手过程，然后才能正式收发数据</p>
<p>客户端发送数据格式如下：</p>
<pre><code class="http">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</code></pre>
<ul>
<li>Connection：必须设置Upgrade，表示客户端希望连接升级</li>
<li>Upgrade：必须设置Websocket，表示希望升级到Websocket协议</li>
<li>Sec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept应答，否则客户端会抛出错误，并关闭连接</li>
<li>Sec-WebSocket-Version ：表示支持的Websocket版本</li>
</ul>
<p>服务端返回的数据格式：</p>
<pre><code class="http">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat
</code></pre>
<ul>
<li>HTTP&#x2F;1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接</li>
<li>Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部</li>
<li>更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li>
<li>保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证</li>
<li>更好的二进制支持：定义了二进制帧，更好处理二进制内容</li>
<li>支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议</li>
<li>更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li>
</ul>
<h4 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h4><p>基于<code>websocket</code>的事实通信的特点，其存在的应用场景大概有：</p>
<ul>
<li>弹幕</li>
<li>媒体聊天</li>
<li>协同编辑</li>
<li>基于位置的应用</li>
<li>体育实况更新</li>
<li>股票基金报价实时更新</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全React"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8React/"
    >前端面试大全React</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8React/" class="article-date">
  <time datetime="2022-10-29T08:26:29.000Z" itemprop="datePublished">2022-10-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/React/">React</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（React-js）"><a href="#前端面试题大全（React-js）" class="headerlink" title="前端面试题大全（React.js）"></a>前端面试题大全（React.js）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h2><h3 id="♥︎♥︎-fetch的延时操作"><a href="#♥︎♥︎-fetch的延时操作" class="headerlink" title="♥︎♥︎  fetch的延时操作"></a>♥︎♥︎  fetch的延时操作</h3><pre><code class="javascript">// fetch语法：fetch(resource, config).then( function(response) &#123; ... &#125; )；resource为要获取的资源，
config是配置对象，包含method请求方法，headers请求头信息等
// 定义一个延时函数，返回一个promise
const delayPromise = (timeout=5000) =&gt; &#123;
 return new Promise((resolve, reject) =&gt; &#123;
 setTimeout(()=&gt;&#123;
 reject(new Error(&quot;网络错误&quot;))
 &#125;, timeout)
 &#125;)
&#125;
// 定义一个fetch网络请求，返回一个promise
const fetchPromise = (resource, config) =&gt; &#123;
 return new Promise((resolve, reject)=&gt;&#123;
 fetch(resource, config).then(res=&gt;&#123;
 resolve(res)
 &#125;)
 &#125;)
&#125;
// promise的race静态方法接受多个promise对象组成的数组，该数组中哪个promise先执行完成，race方法就返回这个promise的执行结果
const fetchRequest = (resource, config, timeout) =&gt; &#123;
 Promise.race([
 delayPromise(timeout), 
 fetchPromise(resource,config)
 ])
&#125;
</code></pre>
<h3 id="♥︎♥︎-A-组件嵌套-B-组件，生命周期执行顺序"><a href="#♥︎♥︎-A-组件嵌套-B-组件，生命周期执行顺序" class="headerlink" title="♥︎♥︎   A 组件嵌套 B 组件，生命周期执行顺序"></a>♥︎♥︎   A 组件嵌套 B 组件，生命周期执行顺序</h3><pre><code class="css">父组件创建阶段的生命周期钩子函数 constructor
父组件创建阶段的生命周期钩子函数 render
子组件创建阶段的生命周期钩子函数 constructor
子组件创建阶段的生命周期钩子函数 render
子组件创建阶段的生命周期钩子函数 componentDidMount
父组件创建阶段的生命周期钩子函数 componentDidMount

父-&gt;父-&gt;子-&gt;子-&gt;子-&gt;父
</code></pre>
<h3 id="♥︎♥︎-React-组件中-props-和-state-有什么区别？"><a href="#♥︎♥︎-React-组件中-props-和-state-有什么区别？" class="headerlink" title="♥︎♥︎  React 组件中 props 和 state 有什么区别？"></a>♥︎♥︎  React 组件中 props 和 state 有什么区别？</h3><p>1、props是从外部传入组件的参数，一般用于父组件向子组件通信，在组件之间通信使用；state一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等</p>
<p> 2、props不可以在组件内部修改，只能通过父组件进行修改；state在组件内部通过setState修改；</p>
<h3 id="♥︎♥︎-react中组件分为那两种？"><a href="#♥︎♥︎-react中组件分为那两种？" class="headerlink" title="♥︎♥︎ react中组件分为那两种？"></a>♥︎♥︎ react中组件分为那两种？</h3><p>类组件和函数组件</p>
<h3 id="♥︎♥︎-描述-Flux-与-MVC？"><a href="#♥︎♥︎-描述-Flux-与-MVC？" class="headerlink" title="♥︎♥︎ 描述 Flux 与 MVC？"></a>♥︎♥︎ 描述 Flux 与 MVC？</h3><p>传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</p>
<ol>
<li>数据流不够清晰——跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。</li>
<li>缺乏数据完整性——模型数据可以在任何地方发生突变，从而在整个UI中产生不可预测的结果。</li>
</ol>
<p>使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。</p>
<h3 id="♥︎♥︎-在-React-中使用构造函数和-getInitialState-有什么区别？"><a href="#♥︎♥︎-在-React-中使用构造函数和-getInitialState-有什么区别？" class="headerlink" title="♥︎♥︎ 在 React 中使用构造函数和 getInitialState 有什么区别？"></a>♥︎♥︎ 在 React 中使用构造函数和 getInitialState 有什么区别？</h3><pre><code class="react">// ES6
class MyComponent extends React.Component &#123;
constructor(props) &#123;
super(props);
this.state = &#123; /* initial state */ &#125;;
&#125;
&#125;
// ES5
var MyComponent = React.createClass(&#123;
getInitialState() &#123;
  return &#123; /* initial state */ &#125;;
&#125;,
&#125;);
</code></pre>
<p>本质上其实是等价的？</p>
<p>区别在于ES6和ES5本身，getInitialState 是搭配 React.createClass 使用的， constructor 是搭配React.Component 使用的,在React组件的生命周期中 constructor 先于 getInitialState</p>
<h3 id="♥︎♥︎-为什么说React是view（视图层）"><a href="#♥︎♥︎-为什么说React是view（视图层）" class="headerlink" title="♥︎♥︎ 为什么说React是view（视图层）"></a>♥︎♥︎ 为什么说React是view（视图层）</h3><p>react, 是 Facebook 推出的一个用来构建用户界面的 JavaScript 库. React 主要用于构建 UI</p>
<p>React被认为是视图层的框架是因为它是基于组件的，一切都是组件，而组件就是渲染页面的基础。不论组件中包含的jsx，methods，state，props，都是属于组件内部的</p>
<p>View（视图）是应用程序中处理数据显示的部分。视图层主要包括二个部分：</p>
<p>1.视图层显示及交互逻辑；</p>
<p>2.视图层的数据结构ViewObj， 包括React中的props和stats；</p>
<hr>
<h3 id="♥︎♥︎♥︎-React-事件绑定原理"><a href="#♥︎♥︎♥︎-React-事件绑定原理" class="headerlink" title="♥︎♥︎♥︎ React 事件绑定原理"></a>♥︎♥︎♥︎ React 事件绑定原理</h3><p>一、react并没有使用原生的浏览器事件，而是在基于Virtual DOM的基础上实现了合成事件，采用小驼峰命名法，默认的事件传播方式是冒泡，如果想改为捕获的话，直接在事件名后面加上Capture即可；事件对象event也不是原生事件对象，而是合成对象，但通过nativeEvent属性可以访问原生事件对象；</p>
<p>二、react合成事件主要分为以下三个过程：</p>
<p> 1、事件注册</p>
<p> 在该阶段主要做了两件事：document上注册、存储事件回调。所有事件都会注册到document上，</p>
<p>拥有统一的回调函数dispatchEvent来执行事件分发，类似于</p>
<pre><code class="javascript">document.addEventListener(&quot;click&quot;,dispatchEvent)。
 register:
 addEventListener-click
 addEventListener-change
listenerBank: 
&#123; 
click: &#123;key1: fn1, key2: fn2&#125;, 
change: &#123;key1: fn3, key3: fn4&#125; 
&#125; 
</code></pre>
<p>2、事件合成 </p>
<p>事件触发后，会执行一下过程： </p>
<p>（1）进入统一的事件分发函数dispatchEvent； </p>
<p>（2）找到触发事件的 ReactDOMComponent； </p>
<p>（3）开始事件的合成； </p>
<p>—— 根据当前事件类型生成指定的合成对象 </p>
<p>—— 封装原生事件和冒泡机制 </p>
<p>—— 查找当前元素以及他所有父级 </p>
<p>—— 在listenerBank根据key值查找事件回调并合成到 event(合成事件结束) </p>
<p>3、批处理</p>
<p> 批量处理合成事件内的回调函数</p>
<h3 id="♥︎♥︎♥︎-React中的-setState-缺点是什么呢"><a href="#♥︎♥︎♥︎-React中的-setState-缺点是什么呢" class="headerlink" title="♥︎♥︎♥︎ React中的 setState 缺点是什么呢"></a>♥︎♥︎♥︎ React中的 setState 缺点是什么呢</h3><p>setState执行的时候可以简单的认为，隶属于原生js执行的空间，那么就是属于同步，被react处理过的空间属于异步，这其实也是一种性能的优化，如果多次使用setState修改值，那么在异步中会先进行合并，再进行渲染，降低了操作dom的次数，具体如下：</p>
<p>（1）setState 在合成事件和钩子函数中是“异步”的，在原生事件和 <code>setTimeout</code> 中都是同步的。 </p>
<p>（2）setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更 新后的结果。 </p>
<p>（3）setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。 </p>
<p>（4）正是由于setState存在异步的机制，如果setState修改值的时候依赖于state本身的值，有时候并不可靠，这时候我们需要传入一个回调函数作为其入参，这个回调函数的第一个参数为更新前的state值。</p>
<h3 id="♥︎♥︎♥︎-React组件通信如何实现"><a href="#♥︎♥︎♥︎-React组件通信如何实现" class="headerlink" title="♥︎♥︎♥︎ React组件通信如何实现"></a>♥︎♥︎♥︎ React组件通信如何实现</h3><p>react本身:</p>
<p> (1) props ——父组件向子组件通过props传参</p>
<p> (2) 实例方法——在父组件中可以用 refs 引用子组件，之后就可以调用子组件的实例方法了</p>
<p> (3) 回调函数——用于子组件向父组件通信，子组件调用props传递过来的方法</p>
<p> (4) 状态提升——两个子组件可以通过父组件定义的参数进行传参</p>
<p> (5) Context上下文——一般用作全局主题</p>
<p> (6) Render Props——渲染的细节由父组件控制</p>
<p>状态管理: </p>
<p>(1) mobx&#x2F;redux&#x2F;dva——通过在view中触发action，改变state，进而改变其他组件的view</p>
<h3 id="♥︎♥︎♥︎-类组件和函数组件的区别"><a href="#♥︎♥︎♥︎-类组件和函数组件的区别" class="headerlink" title="♥︎♥︎♥︎ 类组件和函数组件的区别"></a>♥︎♥︎♥︎ 类组件和函数组件的区别</h3><p>（1）语法上：函数组件是一个函数，返回一个jsx元素，而类组件是用es6语法糖class定义，继承component这个类</p>
<p>（2）类组件中可以通过state进行状态管理，而在函数组件中不能使用setState()，在react16.8以后，函数组件可以通过hooks中的useState来模拟类组件中的状态管理；</p>
<p>（3）类组件中有一系列的生命周期钩子函数，在函数组件中也需要借助hooks来使用生命周期函数；</p>
<p>（4）类组件能够捕获最新的值（永远保持一致），这是因为当实例的props属性发生修改时，class组件能够直接通过this捕获到组件最新的props；而函数式组件是捕获渲染所使用的值，已经因为javascript闭包的特性，之前的props参数保存在内存之中，无法从外部进行修改。</p>
<h3 id="♥︎♥︎♥︎-请你说说React的路由是什么？"><a href="#♥︎♥︎♥︎-请你说说React的路由是什么？" class="headerlink" title="♥︎♥︎♥︎ 请你说说React的路由是什么？"></a>♥︎♥︎♥︎ 请你说说React的路由是什么？</h3><p>路由分为前端路由和后端路由，后端路由是服务器根据用户发起的请求而返回不同内容，前端路由是客户端根据不同的URL去切换组件；在web应用前端开发中，路由系统是最核心的部分，当页面的URL发生改变时，页面的显示结果可以根据URL的变化而变化，但是页面不会刷新。</p>
<p>react生态中路由通常是使用react-router来进行配置，其主要构成为：</p>
<p>（1）Router——对应路由的两种模式，包括与BrowserRouter与HashRoute； </p>
<p>（2）route matching组件——控制路径对应的显示组件，可以进行同步加载和异步加载； </p>
<p>（3）navigation组件——用做路由切换和跳转；</p>
<p>BrowserRouter与HashRouter的区别：</p>
<p>（1）底层原理不一样：BrowserRouter使用的是H5的history API，不兼容IE9及以下版本；HashRouter使用的是URL的哈希值；</p>
<p>（2）path表现形式不一样：BrowserRouter的路径中没有#,例如：localhost:3000&#x2F;demo&#x2F;test；HashRouter的路径包含#,例如：localhost:3000&#x2F;#&#x2F;demo&#x2F;test； </p>
<p>（3）刷新后对路由state参数的影响：BrowserRouter没有任何影响，因为state保存在history对象中；</p>
<p>react生态中路由通常是使用react-router来进行配置，其主要构成为： </p>
<p>BrowserRouter与HashRouter的区别：HashRouter刷新后会导致路由state参数的丢失；</p>
<h3 id="♥︎♥︎♥︎-聊聊-Redux-和-Vuex-的设计思想"><a href="#♥︎♥︎♥︎-聊聊-Redux-和-Vuex-的设计思想" class="headerlink" title="♥︎♥︎♥︎ 聊聊 Redux 和 Vuex 的设计思想"></a>♥︎♥︎♥︎ 聊聊 Redux 和 Vuex 的设计思想</h3><p>Flux的核心思想就是数据和逻辑永远单向流动，由三大部分组成 dispatcher(负责分发事件),store(负责保存数据，同时响应事件并更新数据)和 view(负责订阅store中的数据，并使用这些数据渲染相应的页面)，Redux和Vuex是flux思想的具体实现，都是用来做状态管理的工具，Redux主要在react中使用，Vuex主要在vue中使用。</p>
<pre><code class="css">Redux设计和使用的三大原则： 
（1）单一的数据源：整个应用的 state被储存在唯一一个 store中； 
（2）状态是只读的：Store.state不能直接修改（只读），必须调用dispatch(action) =&gt; store.reducer =&gt; return newState；action是一个对象，有type（操作类型）和payload（新值） 属性；
（3）状态修改均由纯函数完成：在Redux中，通过纯函数reducer来确定状态的改变，因为reducer是纯 函数，所以相同的输入，一定会得到相同的输出，同时也不支持异步；返回值是一个全新的state； 

vuex由State + Muatations(commit) + Actions(dispatch) 组成： 
（1）全局只有一个Store实例（单一数据源）；
（2）Mutations必须是同步事务，不同步修改的话，会很难调试，不知道改变什么时候发生，也很难确定 先后顺序，A、B两个mutation，调用顺序可能是A -&gt; B，但是最终改变 State的结果可能是B -&gt; A； 
（3）Actions负责处理异步事务，然后在异步回调中触发一个或多个mutations，也可以在业务代码中处 理异步事务，然后在回调中同样操作； 
（4）模块化通过module方式来处理，这个跟Redux-combineReducer类似，在应用中可以通过 namespaceHelper来简化使用；
</code></pre>
<h3 id="♥︎♥︎♥︎-React中不同组件之间如何做到数据交互？"><a href="#♥︎♥︎♥︎-React中不同组件之间如何做到数据交互？" class="headerlink" title="♥︎♥︎♥︎  React中不同组件之间如何做到数据交互？"></a>♥︎♥︎♥︎  React中不同组件之间如何做到数据交互？</h3><h4 id="正向传值–使用-props"><a href="#正向传值–使用-props" class="headerlink" title="正向传值–使用 props"></a>正向传值–使用 props</h4><p>父组件发送数据在子组件中使用 this.props.xxx 来接收数据，如果父级的某个props 改变了，React 会重渲染所有的子节点</p>
<h4 id="逆向传值—函数传值"><a href="#逆向传值—函数传值" class="headerlink" title="逆向传值—函数传值"></a>逆向传值—函数传值</h4><ul>
<li>子组件通过事件调用函数传递</li>
<li>在子组件中使用 this.props调用的函数名绑定发送数据。</li>
<li>在父组件中进行函数传递。</li>
<li>父组件中必须要有一个形参用来接收子组件发送过来的数据。</li>
</ul>
<h4 id="同级传值—pubsub-js"><a href="#同级传值—pubsub-js" class="headerlink" title="同级传值—pubsub-js"></a>同级传值—pubsub-js</h4><ul>
<li>在第一个要传值的组件中进行数据抛出 PubSub.publish(“ 事件名”,”数据”)。</li>
<li>在第二个要接收数据的组件中接收 PubSub.subscribe(“监听的事件”,(事件,数 据)&#x3D;&gt;{})。</li>
</ul>
<h4 id="跨组件传值—context"><a href="#跨组件传值—context" class="headerlink" title="跨组件传值—context"></a>跨组件传值—context</h4><p>context 上下文对象，无需为每一层组件手动添加 props，就能在组件数间进行数据传递的方法。<br>使用 createContext()方法提供了两个对象 - Provider 对象生产者—-&gt;用来生产数据 - Consumer对象消费者—-&gt;用来使用数据。</p>
<h3 id="♥︎♥︎♥︎-React中refs的作用是什么？"><a href="#♥︎♥︎♥︎-React中refs的作用是什么？" class="headerlink" title="♥︎♥︎♥︎ React中refs的作用是什么？"></a>♥︎♥︎♥︎ React中refs的作用是什么？</h3><p> ref是React提供的用来操纵React组件实例或者DOM元素的接口。主要用来做文本框的聚焦、触发强制动画等；</p>
<pre><code class="javascript">//类组件
class Foo extends React.Component &#123;
   constructor(props) &#123;
 super(props)
 this.myRef = React.createRef()
 &#125;
 render() &#123;
 return &#125;
  
&lt;input ref=&#123; this.myRef &#125; /&gt; &lt;button onClick = &#123;()=&gt;this.handle()&#125;&gt;聚焦
&#125; 
handle() &#123; 
 // 通过current属性访问到当前元素 this.myRef.current.focus() 
&#125; 
// 函数组件 function
Foo() &#123; const inputEl = useRef(null) const handle = () =&gt; &#123; inputEl.current.focus() &#125; 
return
&lt;input type=&quot;text&quot; ref=&#123; inputEl &#125;/&gt; 聚焦&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-组件绑定和js原生绑定事件哪个先执行？"><a href="#♥︎♥︎♥︎-组件绑定和js原生绑定事件哪个先执行？" class="headerlink" title="♥︎♥︎♥︎ 组件绑定和js原生绑定事件哪个先执行？"></a>♥︎♥︎♥︎ 组件绑定和js原生绑定事件哪个先执行？</h3><p> 先执行js原生绑定事件，再执行合成事件，因为合成事件是发生在冒泡阶段</p>
<h3 id="♥︎♥︎♥︎-diff-和-Key-之间的联系"><a href="#♥︎♥︎♥︎-diff-和-Key-之间的联系" class="headerlink" title="♥︎♥︎♥︎ diff 和 Key 之间的联系"></a>♥︎♥︎♥︎ diff 和 Key 之间的联系</h3><p>diff算法即差异查找算法，对于DOM结构即为tree的差异查找算法，只有在React更新阶段才会有Diff算法的运用；react的diff运算为了降低时间复杂度，是按层比较新旧两个虚拟dom树的。diff运算的主要流程见下：</p>
<pre><code class="css">1、tree diff : 新旧两棵dom树，逐层对比的过程就是 tree diff, 当整棵DOM树逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到。 
2、component diff ： 在进行tree diff的时候，每一层中，都有自己的组件，组件级别的对比， 叫做 component diff。如果对比前后，组件的类型相同，则暂时认为此组件不需要更新；如果对比前后， 组件的类型不同，则需要移除旧组件，创建新组件，并渲染到页面上。 React只会匹配类型相同的组件，也就是说如果&lt;A&gt;被&lt;B&gt;替换，那么React将直接删除A组件然后创建一 个B组件；如果某组件A转移到同层B组件上，那么这个A组件会先被销毁，然后在B组件下重新生成，以A为根节 点的树整个都被重新创建，这会比较耗费性能，但实际上我们很少跨层移动dom节点，一般都是同层横向移动； 
3、element diff ：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比， 这叫做element diff。 对于列表渲染，react会在创建时要求为每一项输入一个独一无二的key，这样就能进行高效的diff运算 了。比如我们要在b和c节点中间插入一个节点f，jquery会将f这个节点后面的每一个节点都进行更新，比如c 更新成f，d更新成c，e更新成d，这样操作的话就会特别多，而加了key的react咋不会频繁操作dom，而是优先采用移动的方式，找到正确的位置去插入新节点；所以我们不能省略key值，因为在对比两个新旧的子元素是通过key值来精确地判断两个节点是否为同一个，如果没有key的话则是见到谁就更新谁，非常耗费性能。 

当我们通过this.setState()改变数据的时候，React会将其标记为脏节点，在事件循环的最后 才会重新渲染所有的脏节点以及脏节点的子树；另外我们可以使用shouldComponentUpdate这个生命周期来 选择性的渲染子树，可以基于组件之前的状态或者下一个状态来决定它是否需要重新渲染，这样的话可以组织 重新渲染大的子树。
</code></pre>
<h3 id="♥︎♥︎♥︎-虚拟-dom-和原生-dom"><a href="#♥︎♥︎♥︎-虚拟-dom-和原生-dom" class="headerlink" title="♥︎♥︎♥︎ 虚拟 dom 和原生 dom"></a>♥︎♥︎♥︎ 虚拟 dom 和原生 dom</h3><p>（1）原生dom是浏览器通过dom树渲染的复杂对象，属性非常多；</p>
<p> （2）虚拟dom是存在于内存中的js对象，属性远少于原生的dom对象，它用来描述真实的dom，并不会直接在浏览器中显示；</p>
<p> （3）原生dom操作、频繁排版与重绘的效率是相当低的，虚拟dom则是利用了计算机内存高效的运算性能减少了性能的损耗；</p>
<p> （4）虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分，最后并在真实DOM中对修改部分进行排版与重绘，减少过多DOM节点排版与重绘损耗</p>
<h3 id="♥︎♥︎♥︎-react中如何打包上传图片文件"><a href="#♥︎♥︎♥︎-react中如何打包上传图片文件" class="headerlink" title="♥︎♥︎♥︎ react中如何打包上传图片文件"></a>♥︎♥︎♥︎ react中如何打包上传图片文件</h3><p>通过 base64 前端处理图片为 base64 的解决方案</p>
<ul>
<li>利用 FileReader 对数据进行读取，如果是图片会将图片读取为 base64 的形式</li>
<li>将得到的 base64 的字符串传给后端</li>
<li>后端直接保存该html字符串，之后调用接口查询该数据直接前端通过img标签完成自动解析即可</li>
</ul>
<p>代码实现：</p>
<pre><code class="react">function App() &#123;
  const handleFileChange = e =&gt; &#123;
    const file = e.currentTarget.files[0];
    const reader = new FileReader();

    reader.onload = function() &#123;
      // reader.results当完成onload后会将图片转为base64
      // 后端只要解析base64对应的字符串即可
      const result = this.result;
      console.log(result);
    &#125;;

    reader.readAsDataURL(file); // 得到经过base64编码的图片信息
  &#125;;

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;input type=&quot;file&quot; onChange=&#123;handleFileChange&#125; /&gt;
    &lt;/div&gt;
  );
&#125;
</code></pre>
<p>利用input,xhr,formData来实现</p>
<ul>
<li>利用input[type&#x3D;‘file’]来实现</li>
<li>点击选择文件，且选择文件完毕后，触发onChange事件</li>
<li>通过event.targer.files(react中)获取所选文件</li>
<li>通过FormData这个类，将文件添加到其实例中</li>
<li>配置xhr，通过POST的方式发送formData到后端即可</li>
</ul>
<p>代码实现：</p>
<pre><code class="react">import React, &#123; useState &#125; from &#39;react&#39;;
import &#123; ApiHost &#125; from &#39;../../constant&#39;;
import &#123; Button, FormControl, Progress &#125; from &#39;zent&#39;;

export type UploadCompletCallback&lt;T&gt; = (
  e: ProgressEvent&lt;XMLHttpRequestEventTarget&gt;,
  reponse: T
) =&gt; void;

export type UploadStartCallback = (
  e: ProgressEvent&lt;XMLHttpRequestEventTarget&gt;
) =&gt; void;

export type UploadProcessCallback = (loaded: number, total: number) =&gt; void;

interface Props &#123;
  onComplete?: UploadCompletCallback&lt;any&gt;;
  onStart?: UploadStartCallback;
  onProcess?: UploadProcessCallback;
  hasProcess?: boolean;
  title: string;
&#125;

export const UploadBtn: React.FC&lt;Props&gt; = props =&gt; &#123;
  const &#123; onComplete, onStart, onProcess, hasProcess = false, title &#125; = props;
  const [progress, setProgress] = useState&lt;number&gt;(0);
  const [uploadStatus, setStatus] = useState&lt;boolean&gt;(false);

  // 处理文件上传的核心方法
  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;
    const files = e.target.files;

    if (files) &#123;
      if (!files.length) return;

  // 将文件处理成formData
      let formData = new FormData();
      for (let k in files) &#123;
        formData.append(&#39;file&#39;, files[k], window.encodeURI(files[k].name));
      &#125;

      let xhr = new XMLHttpRequest();

      xhr.responseType = &#39;json&#39;;
      xhr.timeout = 5000;
      xhr.open(&#39;POST&#39;, `$&#123;ApiHost&#125;/user/upload`, true);

   // 事件监听
      xhr.addEventListener(&#39;loadstart&#39;, e =&gt; &#123;
        setProgress(0);
        setStatus(true);
        onStart &amp;&amp; onStart(e);
      &#125;);

      xhr.upload.onprogress = function(e) &#123;
        const &#123; total, loaded &#125; = e;
        setProgress((loaded / total) * 100);
        onProcess &amp;&amp; onProcess(loaded, total);
      &#125;;

      xhr.addEventListener(&#39;load&#39;, e =&gt; &#123;
        const result = xhr.response;
        onComplete &amp;&amp; onComplete(e, result);
      &#125;);

      xhr.send(formData);
    &#125; else &#123;
      return;
    &#125;
  &#125;;

  const selectFile = () =&gt; &#123;
    const btn = document.querySelector(&quot;input[type=&#39;file&#39;]&quot;);
    
 //@ts-ignore
    btn &amp;&amp; btn.click();
  &#125;;
  return (
    &lt;FormControl label=&#123;title&#125;&gt;
      &lt;input type=&quot;file&quot; onChange=&#123;handleChange&#125; style=&#123;&#123; display: 'none' &#125;&#125; /&gt;
      &lt;Button onClick=&#123;selectFile&#125;&gt;上传&lt;/Button&gt;
      &#123;hasProcess &amp;&amp; uploadStatus &amp;&amp; &lt;Progress percent=&#123;progress&#125;&gt;&lt;/Progress&gt;&#125;
    &lt;/FormControl&gt;
  );
&#125;;
</code></pre>
<p>后端对于该文件上传请求的处理nodejs版本</p>
<p>主要步骤：</p>
<ul>
<li>利用fs.createReadStream 来读取本地的传过去文件的地址</li>
<li>利用fs.createWriteStream来写到服务器上的某个文件地址</li>
<li>通过reader.pipe来将readFile里面的内容复制到writeFile中</li>
</ul>
<h3 id="♥︎♥︎♥︎-对单向数据流和双向数据绑定的理解，好处？"><a href="#♥︎♥︎♥︎-对单向数据流和双向数据绑定的理解，好处？" class="headerlink" title="♥︎♥︎♥︎ 对单向数据流和双向数据绑定的理解，好处？"></a>♥︎♥︎♥︎ 对单向数据流和双向数据绑定的理解，好处？</h3><p>react的单向数据流是指只允许父组件向子组件传递数据，子组件绝对不能修改父组件传的数据，如果想要修改数据，则要在子组件中执行父组件传递过来的回调函数，提醒父组件对数据进行修改。数据单向流让所有的状态改变可以追溯，有利于应用的可维护性；</p>
<p> angular中实现了双向数据绑定，代码编写方便，但是不利于维护</p>
<h3 id="♥︎♥︎♥︎-React-按需加载"><a href="#♥︎♥︎♥︎-React-按需加载" class="headerlink" title="♥︎♥︎♥︎ React 按需加载"></a>♥︎♥︎♥︎ React 按需加载</h3><p>1、使用React.lazy， 但是React.lazy技术还不支持服务端渲染</p>
<pre><code class="react">const OtherComponent = React.lazy(() =&gt; import(&#39;./OtherComponent&#39;))
</code></pre>
<p>2、使用Loadable Components这个库</p>
<pre><code class="react">import loadable from &#39;@loadable/component&#39;
const OtherComponent = loadable(() =&gt; import(&#39;./OtherComponent&#39;))
</code></pre>
<h3 id="♥︎♥︎♥︎-React-实现目录树（组件自身调用自身）"><a href="#♥︎♥︎♥︎-React-实现目录树（组件自身调用自身）" class="headerlink" title="♥︎♥︎♥︎ React 实现目录树（组件自身调用自身）"></a>♥︎♥︎♥︎ React 实现目录树（组件自身调用自身）</h3><p>需求描述：实现n级属性目录展开，该实现使用react，antd-mobile</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code class="react">import TreesMenu from &quot;./treeMenu.jsx&quot;;
&lt;TreesMenu
       datas=&#123;treesData&#125;
       onselected=&#123;item =&gt; &#123;
           console.log(&quot;选择了树形目录的数据：&quot;, item);
       &#125;&#125;
&gt;&lt;/TreesMenu&gt;
</code></pre>
<h4 id="实现数据"><a href="#实现数据" class="headerlink" title="实现数据"></a>实现数据</h4><pre><code class="react">export let treesData = [&#123;&quot;Childs&quot;:[&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;班子成员&quot;,&quot;ShortName&quot;:&quot;班子成员&quot;,&quot;DeptCode&quot;:&quot;81&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408498041056&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;调研员&quot;,&quot;ShortName&quot;:&quot;调研员&quot;,&quot;DeptCode&quot;:&quot;82&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408531598048&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;党政办公室&quot;,&quot;ShortName&quot;:&quot;党政办公室&quot;,&quot;DeptCode&quot;:&quot;83&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408548375776&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;党政办公室（财务）&quot;,&quot;ShortName&quot;:&quot;党政办公室（财务）&quot;,&quot;DeptCode&quot;:&quot;84&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408581929184&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;党建办公室&quot;,&quot;ShortName&quot;:&quot;党建办公室&quot;,&quot;DeptCode&quot;:&quot;85&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408598709728&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;平安办公室&quot;,&quot;ShortName&quot;:&quot;平安办公室&quot;,&quot;DeptCode&quot;:&quot;86&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408615482336&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;信访办公室&quot;,&quot;ShortName&quot;:&quot;信访办公室&quot;,&quot;DeptCode&quot;:&quot;87&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408632263392&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;管理办公室&quot;,&quot;ShortName&quot;:&quot;管理办公室&quot;,&quot;DeptCode&quot;:&quot;88&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408649039584&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;自治办公室&quot;,&quot;ShortName&quot;:&quot;自治办公室&quot;,&quot;DeptCode&quot;:&quot;89&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408665815776&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;综合事务办公室&quot;,&quot;ShortName&quot;:&quot;综合事务办公室&quot;,&quot;DeptCode&quot;:&quot;90&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408665819872&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;监察办公室&quot;,&quot;ShortName&quot;:&quot;监察办公室&quot;,&quot;DeptCode&quot;:&quot;91&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408682596576&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;武装部&quot;,&quot;ShortName&quot;:&quot;武装部&quot;,&quot;DeptCode&quot;:&quot;92&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408699368672&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;司法所&quot;,&quot;ShortName&quot;:&quot;司法所&quot;,&quot;DeptCode&quot;:&quot;93&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408699371232&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;城运中心&quot;,&quot;ShortName&quot;:&quot;城运中心&quot;,&quot;DeptCode&quot;:&quot;94&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408716144864&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;工会&quot;,&quot;ShortName&quot;:&quot;工会&quot;,&quot;DeptCode&quot;:&quot;95&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408749699296&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;团委&quot;,&quot;ShortName&quot;:&quot;团委&quot;,&quot;DeptCode&quot;:&quot;96&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408749700320&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;妇联&quot;,&quot;ShortName&quot;:&quot;妇联&quot;,&quot;DeptCode&quot;:&quot;97&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408749703648&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;房管办&quot;,&quot;ShortName&quot;:&quot;房管办&quot;,&quot;DeptCode&quot;:&quot;98&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408749704672&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;安监所&quot;,&quot;ShortName&quot;:&quot;安监所&quot;,&quot;DeptCode&quot;:&quot;99&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408766480352&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;党建服务中心&quot;,&quot;ShortName&quot;:&quot;党建服务中心&quot;,&quot;DeptCode&quot;:&quot;100&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408783258080&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;社区事务受理中心&quot;,&quot;ShortName&quot;:&quot;社区事务受理中心&quot;,&quot;DeptCode&quot;:&quot;101&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408816808672&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;社区文化中心&quot;,&quot;ShortName&quot;:&quot;社区文化中心&quot;,&quot;DeptCode&quot;:&quot;102&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408917476576&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;社区学校&quot;,&quot;ShortName&quot;:&quot;社区学校&quot;,&quot;DeptCode&quot;:&quot;103&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408951031264&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;绿化市容&quot;,&quot;ShortName&quot;:&quot;绿化市容&quot;,&quot;DeptCode&quot;:&quot;104&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408951033824&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;周家渡城管中队&quot;,&quot;ShortName&quot;:&quot;周家渡城管中队&quot;,&quot;DeptCode&quot;:&quot;105&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408967806688&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;商会&quot;,&quot;ShortName&quot;:&quot;商会&quot;,&quot;DeptCode&quot;:&quot;106&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408967810016&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;开发人员&quot;,&quot;ShortName&quot;:&quot;开发人员&quot;,&quot;DeptCode&quot;:&quot;107&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073408967811040&#125;,&#123;&quot;Childs&quot;:[&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南八村&quot;,&quot;ShortName&quot;:&quot;上南八村&quot;,&quot;DeptCode&quot;:&quot;109&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409034918368&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南四村&quot;,&quot;ShortName&quot;:&quot;上南四村&quot;,&quot;DeptCode&quot;:&quot;110&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409051695840&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南五村&quot;,&quot;ShortName&quot;:&quot;上南五村&quot;,&quot;DeptCode&quot;:&quot;111&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409068471776&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南六村&quot;,&quot;ShortName&quot;:&quot;上南六村&quot;,&quot;DeptCode&quot;:&quot;112&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409102022368&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南七村&quot;,&quot;ShortName&quot;:&quot;上南七村&quot;,&quot;DeptCode&quot;:&quot;113&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409118800352&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南九村&quot;,&quot;ShortName&quot;:&quot;上南九村&quot;,&quot;DeptCode&quot;:&quot;114&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409135576544&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河一&quot;,&quot;ShortName&quot;:&quot;齐河一&quot;,&quot;DeptCode&quot;:&quot;115&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409152353760&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河二&quot;,&quot;ShortName&quot;:&quot;齐河二&quot;,&quot;DeptCode&quot;:&quot;116&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409152360928&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南十村1&quot;,&quot;ShortName&quot;:&quot;上南十村1&quot;,&quot;DeptCode&quot;:&quot;117&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409169135840&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南十二村&quot;,&quot;ShortName&quot;:&quot;上南十二村&quot;,&quot;DeptCode&quot;:&quot;118&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409185911520&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南十村2&quot;,&quot;ShortName&quot;:&quot;上南十村2&quot;,&quot;DeptCode&quot;:&quot;119&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409202686432&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南十一村&quot;,&quot;ShortName&quot;:&quot;上南十一村&quot;,&quot;DeptCode&quot;:&quot;120&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409219461344&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;都市庭院&quot;,&quot;ShortName&quot;:&quot;都市庭院&quot;,&quot;DeptCode&quot;:&quot;121&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409219466976&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;川新&quot;,&quot;ShortName&quot;:&quot;川新&quot;,&quot;DeptCode&quot;:&quot;122&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409236243680&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;雪野二村&quot;,&quot;ShortName&quot;:&quot;雪野二村&quot;,&quot;DeptCode&quot;:&quot;123&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409253021152&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南花苑&quot;,&quot;ShortName&quot;:&quot;上南花苑&quot;,&quot;DeptCode&quot;:&quot;124&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409269798368&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;昌里花园&quot;,&quot;ShortName&quot;:&quot;昌里花园&quot;,&quot;DeptCode&quot;:&quot;125&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409286570976&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;恒大&quot;,&quot;ShortName&quot;:&quot;恒大&quot;,&quot;DeptCode&quot;:&quot;126&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409303348192&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南三村&quot;,&quot;ShortName&quot;:&quot;上南三村&quot;,&quot;DeptCode&quot;:&quot;127&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409303353824&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南一村&quot;,&quot;ShortName&quot;:&quot;上南一村&quot;,&quot;DeptCode&quot;:&quot;128&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409320130784&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;上南二村&quot;,&quot;ShortName&quot;:&quot;上南二村&quot;,&quot;DeptCode&quot;:&quot;129&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409336908000&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;昌里五&quot;,&quot;ShortName&quot;:&quot;昌里五&quot;,&quot;DeptCode&quot;:&quot;130&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409353685728&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;云台一&quot;,&quot;ShortName&quot;:&quot;云台一&quot;,&quot;DeptCode&quot;:&quot;131&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409370462176&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;云台二&quot;,&quot;ShortName&quot;:&quot;云台二&quot;,&quot;DeptCode&quot;:&quot;132&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409387237344&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;云莲一&quot;,&quot;ShortName&quot;:&quot;云莲一&quot;,&quot;DeptCode&quot;:&quot;133&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409404012512&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;昌里七&quot;,&quot;ShortName&quot;:&quot;昌里七&quot;,&quot;DeptCode&quot;:&quot;134&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409420789472&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;动迁联合&quot;,&quot;ShortName&quot;:&quot;动迁联合&quot;,&quot;DeptCode&quot;:&quot;135&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409437567200&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河四&quot;,&quot;ShortName&quot;:&quot;齐河四&quot;,&quot;DeptCode&quot;:&quot;146&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409487902688&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河三&quot;,&quot;ShortName&quot;:&quot;齐河三&quot;,&quot;DeptCode&quot;:&quot;147&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409504677856&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;昌里四&quot;,&quot;ShortName&quot;:&quot;昌里四&quot;,&quot;DeptCode&quot;:&quot;148&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409521452768&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河八&quot;,&quot;ShortName&quot;:&quot;齐河八&quot;,&quot;DeptCode&quot;:&quot;149&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409538229984&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河五&quot;,&quot;ShortName&quot;:&quot;齐河五&quot;,&quot;DeptCode&quot;:&quot;150&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409555007968&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;齐河七&quot;,&quot;ShortName&quot;:&quot;齐河七&quot;,&quot;DeptCode&quot;:&quot;151&quot;,&quot;ParentID&quot;:2073409034918112,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409034918112,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409555013600&#125;],&quot;DeptName&quot;:&quot;居委会&quot;,&quot;ShortName&quot;:&quot;居委会&quot;,&quot;DeptCode&quot;:&quot;108&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409034918112&#125;,&#123;&quot;Childs&quot;:[&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;办公室&quot;,&quot;ShortName&quot;:&quot;办公室&quot;,&quot;DeptCode&quot;:&quot;137&quot;,&quot;ParentID&quot;:2073409437571296,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409437571296,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409437571552&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;事务所&quot;,&quot;ShortName&quot;:&quot;事务所&quot;,&quot;DeptCode&quot;:&quot;138&quot;,&quot;ParentID&quot;:2073409437571296,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409437571296,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409454343904&#125;],&quot;DeptName&quot;:&quot;队伍建设办公室&quot;,&quot;ShortName&quot;:&quot;队伍建设办公室&quot;,&quot;DeptCode&quot;:&quot;136&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409437571296&#125;,&#123;&quot;Childs&quot;:[&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;办公室&quot;,&quot;ShortName&quot;:&quot;办公室&quot;,&quot;DeptCode&quot;:&quot;140&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409454347488&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;慈善超市&quot;,&quot;ShortName&quot;:&quot;慈善超市&quot;,&quot;DeptCode&quot;:&quot;141&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409471121632&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;残联&quot;,&quot;ShortName&quot;:&quot;残联&quot;,&quot;DeptCode&quot;:&quot;142&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409471122656&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;计生办&quot;,&quot;ShortName&quot;:&quot;计生办&quot;,&quot;DeptCode&quot;:&quot;143&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409471124448&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;爱卫办&quot;,&quot;ShortName&quot;:&quot;爱卫办&quot;,&quot;DeptCode&quot;:&quot;144&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409487897568&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;老龄办&quot;,&quot;ShortName&quot;:&quot;老龄办&quot;,&quot;DeptCode&quot;:&quot;145&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409487900896&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;居家养老服务中心&quot;,&quot;ShortName&quot;:&quot;居家养老服务中心&quot;,&quot;DeptCode&quot;:&quot;152&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2080463921349388&#125;,&#123;&quot;Childs&quot;:[],&quot;DeptName&quot;:&quot;综合为老服务中心&quot;,&quot;ShortName&quot;:&quot;综合为老服务中心&quot;,&quot;DeptCode&quot;:&quot;153&quot;,&quot;ParentID&quot;:2073409454347232,&quot;Layer&quot;:2,&quot;Path&quot;:&quot;,0,1,2073409454347232,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2080464005240076&#125;],&quot;DeptName&quot;:&quot;服务办公室&quot;,&quot;ShortName&quot;:&quot;服务办公室&quot;,&quot;DeptCode&quot;:&quot;139&quot;,&quot;ParentID&quot;:1,&quot;Layer&quot;:1,&quot;Path&quot;:&quot;,0,1,&quot;,&quot;Sequence&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:0,&quot;ID&quot;:2073409454347232&#125;],&quot;DeptName&quot;:&quot;周家渡街道办事处&quot;,&quot;ShortName&quot;:&quot;周家渡街道办事处&quot;,&quot;DeptCode&quot;:&quot;SHRGBTRJJSYXGS &quot;,&quot;ParentID&quot;:0,&quot;Layer&quot;:0,&quot;Path&quot;:&quot;,0,&quot;,&quot;Sequence&quot;:11,&quot;LeaderID&quot;:0,&quot;ManagerID&quot;:0,&quot;IsEnabled&quot;:1,&quot;IsUnit&quot;:1,&quot;ID&quot;:1,&quot;SystemID&quot;:1&#125;];
</code></pre>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="react">import React from &quot;react&quot;;
import &#123; Accordion, List &#125; from &quot;antd-mobile&quot;;

class TreesMenu extends React.Component &#123;
  render() &#123;
    let datas = this.props.datas;
    return (
      &lt;div&gt;
        &#123;datas instanceof Array ? (
          &lt;div&gt;
            &#123;datas.map((d, index) =&gt; &#123;
              return &lt;TreeNode datas=&#123;d&#125; key=&#123;index&#125; onselected=&#123;(item) =&gt; this.props.onselected(item)&#125;&gt;&lt;/TreeNode&gt;;
            &#125;)&#125;
          &lt;/div&gt;
        ) : (
          &lt;div&gt;请传入正确格式&lt;/div&gt;
        )&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;

export default TreesMenu;

class TreeNode extends React.Component &#123;
  renderItems(datas) &#123;
    return (
      &lt;List className=&quot;my-list&quot;&gt;
        &lt;List.Item&gt;content 1&lt;/List.Item&gt;
        &lt;List.Item&gt;content 2&lt;/List.Item&gt;
        &lt;List.Item&gt;content 3&lt;/List.Item&gt;
      &lt;/List&gt;
    );
  &#125;
  render() &#123;
    let data = this.props.datas;
    return data &amp;&amp; (!data.Childs || data.Childs.length === 0) ? (
      &lt;div&gt;
        &lt;List className=&quot;my-list&quot; onClick=&#123;() =&gt; &#123;
            this.props.onselected(data)
        &#125;&#125;&gt;
          &lt;List.Item&gt;&#123;data.DeptName&#125;&lt;/List.Item&gt;
        &lt;/List&gt;
      &lt;/div&gt;
    ) : (
      &lt;div&gt;
        &lt;Accordion
          onChange=&#123;this.onChange&#125;
        &gt;
          &lt;Accordion.Panel header=&#123;data.DeptName&#125; className=&quot;tree-accordion-panel&quot;&gt;
            &#123;data &amp;&amp; data.Childs &amp;&amp; data.Childs.map((item, index) =&gt; &#123;
              return &lt;TreeNode datas=&#123;item&#125; onselected=&#123;(item) =&gt; this.props.onselected(item)&#125; key=&#123;index&#125;&gt;&lt;/TreeNode&gt;;
            &#125;)&#125;
          &lt;/Accordion.Panel&gt;
        &lt;/Accordion&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-如果我进行三次setState会发生什么"><a href="#♥︎♥︎♥︎-如果我进行三次setState会发生什么" class="headerlink" title="♥︎♥︎♥︎ 如果我进行三次setState会发生什么"></a>♥︎♥︎♥︎ 如果我进行三次setState会发生什么</h3><p> 如果是在原生js空间，则会同步执行，修改三次state的值，调用三次render函数；</p>
<p>如果是在react函数空间下，则会进行合并，只修改一次state的值，调用一次render。</p>
<h3 id="♥︎♥︎♥︎-渲染一个react组件的过程"><a href="#♥︎♥︎♥︎-渲染一个react组件的过程" class="headerlink" title="♥︎♥︎♥︎ 渲染一个react组件的过程"></a>♥︎♥︎♥︎ 渲染一个react组件的过程</h3><pre><code class="css">1、babel编译
 当我们对代码进行编译的时候，babel会将我们在组件中编写的jsx代码转化为React.createElement的表达式，createElement方法有三个参数，分别为type(元素类型）、attributes(元素所有属性)、children(元素所有子节点)；2、生成element
 当render方法被触发以后，createElement方法会执行，返回一个element对象，这个对象描述了真实节点的信息，其实就是虚拟dom节点；
3、生成真实节点(初次渲染)
 这时候我们会判断element的类型，如果是null、false则实例一个ReactDOMEmptyComponent对 象; 是string、number类型的话则实例一个ReactDOMTextComponent对象； 如果element是对象的话，会进一步判断type元素类型，是原生dom元素，则实例化ReactDOMComponent； 如果是自定义组件，则实例化ReactCompositeComponentWrapper；在这些类生成实例对象的时候，在其内部会调用 mountComponent方法，这个方法里面有一系列浏览器原生dom方法，可以将element渲染成真实的dom并插入到文档中；
 4、生命周期
 componentDidMount：会在组件挂载后(插入DOM树中) 立即调用。一般可以在这里请求数据；
 componentDidUpdate：会在数据更新后立即调用，首次渲染不会执行此方法；可以在其中直接调用 setState，但必须用if语句进行判断，防止死循环；
 conponentWillUnmount：会在组件卸载及销毁之前调用，在此方法中执行必要的清理操作，如清除timer；
 static getDerivedStateFromProps(prps,state)：这个生命周期函数代替了componentWillMount和componentWillUpdate生命周期；props和state发生改变则调用，在初始化挂载及后续更新时都会被调用，返回一个对象来更新state，如果返回null则不更新任何内容；
 shouldComponentUpdate(nextProps,nextState)：这个生命周期函数的返回值用来判断React组件是否因为当前 state 或 props 更改而重新渲染，默认返回值是true；这个方法在初始化渲染或使用forceUpdate()时不会调用；当将旧的state的值原封不动赋值给新的state（即不改变state的值，但是调用了setState）和 无数据交换的父组件的重新渲染都会导致组件重新渲染，这时候都可以通过shouldComponentUpdate来优化。
</code></pre>
<h3 id="♥︎♥︎♥︎-useEffect-和-useLayoutEffect-的区别"><a href="#♥︎♥︎♥︎-useEffect-和-useLayoutEffect-的区别" class="headerlink" title="♥︎♥︎♥︎ useEffect 和 useLayoutEffect 的区别"></a>♥︎♥︎♥︎ useEffect 和 useLayoutEffect 的区别</h3><p>useEffect和useLayout都是副作用hooks，两则非常相似，同样都接收两个参数：</p>
<p> (1)第一个参数为函数，第二个参数为依赖列表，只有依赖更新时才会执行函数；返回一个函数，当页面刷新的或销毁的时候执行return后的代码；</p>
<p> (2)如果不接受第二个参数，那么在第一次渲染完成之后和每次更新渲染页面的时候，都会调用useEffect的回调函数；</p>
<blockquote>
<p>useEffect和 useLayout的主要区别就是他们的执行时机不同，在浏览器中js线程与渲染线程是互斥的，当js线程执行时，渲染线程呈挂起状态，只有当js线程空闲时渲染线程才会执行，将生成的 dom绘制。 </p>
<p>useLayoutEffect在js线程执行完毕即dom更新之后立即执行，而useEffect是在渲染结束后才执行，也就是说 useLayoutEffect比 useEffect先执行。</p>
</blockquote>
<h3 id="♥︎♥︎♥︎-hooks-的使用有什么注意事项"><a href="#♥︎♥︎♥︎-hooks-的使用有什么注意事项" class="headerlink" title="♥︎♥︎♥︎  hooks 的使用有什么注意事项"></a>♥︎♥︎♥︎  hooks 的使用有什么注意事项</h3><p>（1）只能在React函数式组件或自定义Hook中使用Hook。</p>
<p>（2）不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。</p>
<h3 id="♥︎♥︎♥︎-纯函数有什么特点，副作用函数特点"><a href="#♥︎♥︎♥︎-纯函数有什么特点，副作用函数特点" class="headerlink" title="♥︎♥︎♥︎ 纯函数有什么特点，副作用函数特点"></a>♥︎♥︎♥︎ 纯函数有什么特点，副作用函数特点</h3><p>纯函数与外界交换数据只有一个唯一渠道——参数和返回值；函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部。</p>
<p> 纯函数的优点：无状态，线程安全；纯函数相互调用组装起来的函数，还是纯函数；应用程序或者运行环境可以对纯函数的运算结果进行缓存，运算加快速度。</p>
<p> 函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。比如调接口、修改全局变量、抛出一个异常或以一个错误终止、打印到终端或读取用户输入、读取或写入一个文件等，所以说副作用是编程中最关键的部分，因为我们需要跟用户、跟数据进行交互。</p>
<h3 id="♥︎♥︎♥︎-在构造函数调用-super-并将-props-作为参数传入的作用是啥？"><a href="#♥︎♥︎♥︎-在构造函数调用-super-并将-props-作为参数传入的作用是啥？" class="headerlink" title="♥︎♥︎♥︎ 在构造函数调用 super 并将 props 作为参数传入的作用是啥？"></a>♥︎♥︎♥︎ 在构造函数调用 super 并将 props 作为参数传入的作用是啥？</h3><p>ES6 中在调用 super()方法之前，子类构造函数无法使用this引用，在react的类组件中也是如此；将props 参数传递给 super() 调用的主要原因是在子构造函数中能够通过this.props来获取传入的 props。</p>
<h3 id="♥︎♥︎♥︎-讲讲什么是-JSX-？"><a href="#♥︎♥︎♥︎-讲讲什么是-JSX-？" class="headerlink" title="♥︎♥︎♥︎ 讲讲什么是 JSX ？"></a>♥︎♥︎♥︎ 讲讲什么是 JSX ？</h3><p>JSX全称为JavaScript XML，是react中的一种语法糖，可以让我们在js代码中脱离字符串直接编写html代码；本身不能被浏览器读取，必须使用@babel&#x2F;preset-react和webpack等工具将其转换为传统的JS。</p>
<p> 主要有以下特点：</p>
<p> （1）类XML语法容易接受，结构清晰；</p>
<p> （2）增强JS语义；</p>
<p> （3）抽象程度高，屏蔽DOM操作，跨平台；</p>
<p> （4）代码模块化；</p>
<h3 id="♥︎♥︎♥︎-为什么不直接更新-state-呢？"><a href="#♥︎♥︎♥︎-为什么不直接更新-state-呢？" class="headerlink" title="♥︎♥︎♥︎ 为什么不直接更新 state 呢？"></a>♥︎♥︎♥︎ 为什么不直接更新 state 呢？</h3><p>如果试图直接更新 state ，则不会重新渲染组件；需要使用setState()方法来更新 state这样组件才会重新渲染；</p>
<h3 id="♥︎♥︎♥︎-这三个点-…-在-React-干嘛用的？"><a href="#♥︎♥︎♥︎-这三个点-…-在-React-干嘛用的？" class="headerlink" title="♥︎♥︎♥︎ 这三个点(…)在 React 干嘛用的？"></a>♥︎♥︎♥︎ 这三个点(…)在 React 干嘛用的？</h3><p> …是es6语法新出的规范，叫做展开运算符；在react中可以将对象或数组进行展开，让我们操作改变数据结构非常方便。</p>
<h3 id="♥︎♥︎♥︎-React-中的-useState-是什么？"><a href="#♥︎♥︎♥︎-React-中的-useState-是什么？" class="headerlink" title="♥︎♥︎♥︎ React 中的 useState() 是什么？"></a>♥︎♥︎♥︎ React 中的 useState() 是什么？</h3><p>useState是一个内置的React Hook，可以让我们在函数组件中像类组件一样使用state并且改变state的值。</p>
<h3 id="♥︎♥︎♥︎-React-中的StrictMode-严格模式-是什么？"><a href="#♥︎♥︎♥︎-React-中的StrictMode-严格模式-是什么？" class="headerlink" title="♥︎♥︎♥︎ React 中的StrictMode(严格模式)是什么？"></a>♥︎♥︎♥︎ React 中的StrictMode(严格模式)是什么？</h3><p>React的StrictMode是一种辅助组件，用包装组件，可以帮助我们编写更好的react组件，不会渲染出任何可见的ui；仅在开发模式下运行，它们不会影响生产构建，可以做以下检查：</p>
<p> （1）验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告；</p>
<p> （2）验证是否使用的已经废弃的方法，如果有，会在控制台给出警告；</p>
<p> （3）通过识别潜在的风险预防一些副作用。</p>
<h3 id="♥︎♥︎♥︎-为什么类方法需要绑定到类实例？"><a href="#♥︎♥︎♥︎-为什么类方法需要绑定到类实例？" class="headerlink" title="♥︎♥︎♥︎ 为什么类方法需要绑定到类实例？"></a>♥︎♥︎♥︎ 为什么类方法需要绑定到类实例？</h3><p> 在 JS 中，this 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:</p>
<h3 id="♥︎♥︎♥︎-这段代码有什么问题吗？"><a href="#♥︎♥︎♥︎-这段代码有什么问题吗？" class="headerlink" title="♥︎♥︎♥︎ 这段代码有什么问题吗？"></a>♥︎♥︎♥︎ 这段代码有什么问题吗？</h3><pre><code class="react">this.setState((prevState, props) =&gt; &#123;
 return &#123;
 streak: prevState.streak + props.count
 &#125;
&#125;)
// 没有问题
</code></pre>
<h3 id="♥︎♥︎♥︎-如何在-React-的-Props-上应用验证？"><a href="#♥︎♥︎♥︎-如何在-React-的-Props-上应用验证？" class="headerlink" title="♥︎♥︎♥︎ 如何在 React 的 Props 上应用验证？"></a>♥︎♥︎♥︎ 如何在 React 的 Props 上应用验证？</h3><p>1、使用PropTypes进行类型检查</p>
<p>PropTypes自React v15.5起，请使用这个库prop-types</p>
<p>2、What &amp; Why &amp; When</p>
<p>随着应用的不断增长，也是为了使程序设计更加严谨，我们通常需要对数据的类型（值）进行一些必要的验证。出于性能方面的考虑，propTypes仅在开发模式下进行检测,在程序运行时就能检测出错误，不能使用到用户交互提醒用户操作错误等，也可以使用Flow或者TypeScript做类型检查，后期建议用typescript进行替代更好</p>
<p>3、Where</p>
<ul>
<li>class组件</li>
<li>函数组件</li>
<li>React.memo高阶组件 可自行扩展</li>
<li>React.forwardRef组件 可自行扩展</li>
</ul>
<p>4、How</p>
<p>我们在组件类下添加一个静态属性 propTypes (属性名不能更改)，它的值也是一个对象，用来设置组件中props的验证规则，key 是要验证的属性名称，value 是验证规则。</p>
<pre><code class="react">// 类组件
import PropTypes from &#39;prop-types&#39;;
class Greeting extends React.Component &#123;
 render() &#123;
 return ()
 &#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-如何有条件地向-React-组件添加属性？"><a href="#♥︎♥︎♥︎-如何有条件地向-React-组件添加属性？" class="headerlink" title="♥︎♥︎♥︎ 如何有条件地向 React 组件添加属性？"></a>♥︎♥︎♥︎ 如何有条件地向 React 组件添加属性？</h3><p>对于某些属性，React足够智能可以忽略该属性，比如值为boolean值属性的值也可以写控制语句管理是否给组件添加属性</p>
<h3 id="♥︎♥︎♥︎-如何避免组件的重新渲染？"><a href="#♥︎♥︎♥︎-如何避免组件的重新渲染？" class="headerlink" title="♥︎♥︎♥︎ 如何避免组件的重新渲染？"></a>♥︎♥︎♥︎ 如何避免组件的重新渲染？</h3><ol>
<li>当porps&#x2F;state改变时组件会执行render函数也就是重新渲染</li>
<li>class组件中使用shouldComponentUpdate钩子函数</li>
<li>PureComponent默认有避免重新渲染的功能</li>
<li>函数组件使用高阶组件memo处理</li>
</ol>
<h3 id="♥︎♥︎♥︎-什么是纯函数？"><a href="#♥︎♥︎♥︎-什么是纯函数？" class="headerlink" title="♥︎♥︎♥︎ 什么是纯函数？"></a>♥︎♥︎♥︎ 什么是纯函数？</h3><p>一个不会更改入参，且多次调用下相同的入参始终返回相同的结果</p>
<h3 id="♥︎♥︎♥︎-如何避免在React重新绑定实例？"><a href="#♥︎♥︎♥︎-如何避免在React重新绑定实例？" class="headerlink" title="♥︎♥︎♥︎ 如何避免在React重新绑定实例？"></a>♥︎♥︎♥︎ 如何避免在React重新绑定实例？</h3><ol>
<li>将事件处理程序定义为内联箭头函数</li>
<li>使用箭头函数来定义方法</li>
<li>使用带有 Hooks 的函数组件</li>
</ol>
<h3 id="♥︎♥︎♥︎-在js原生事件中-onclick-和-jsx-里-onclick-的区别"><a href="#♥︎♥︎♥︎-在js原生事件中-onclick-和-jsx-里-onclick-的区别" class="headerlink" title="♥︎♥︎♥︎ 在js原生事件中 onclick 和 jsx 里 onclick 的区别"></a>♥︎♥︎♥︎ 在js原生事件中 onclick 和 jsx 里 onclick 的区别</h3><p>1、js原生中</p>
<p>onclick添加事件处理函数是在全局环境下执行，污染了全局环境，且给很多dom元素添加onclick事件，影响网页的性能，同时如果动态的从dom树种删除了该元素，还要手动注销事件处理器，不然就可能造成内存泄露</p>
<p>2、jsx里的onClick</p>
<p>挂载的函数都控制在组件范围内，不会污染全局空间</p>
<p>jsx中不是直接使用onclick，而是采取了事件委托的方式，挂载最顶层DOM节点，所有点击事件被这个事件捕获，然后根据具体组件分配给特定函数，性能当然比每个onClick都挂载一个事件处理函数要高，加上React控制了组件的生命周期，在unmount的时候自然能够清除相关的所有事件处理函数，内存泄露不再是一个问题</p>
<h3 id="♥︎♥︎♥︎-React组件间信息传递"><a href="#♥︎♥︎♥︎-React组件间信息传递" class="headerlink" title="♥︎♥︎♥︎ React组件间信息传递"></a>♥︎♥︎♥︎ React组件间信息传递</h3><p>1.（父组件）向（子组件）传递信息 : porps传值</p>
<p>2.（父组件）向更深层的（子组件） 进行传递信息 : context</p>
<p>3.（子组件）向（父组件）传递信息：callback</p>
<p>4.没有任何嵌套关系的组件之间传值（比如：兄弟组件之间传值）: 利用共同父组件context通信、自定义事件</p>
<p>5.利用react-redux进行组件之间的状态信息共享 : 组件间状态信息共享：redux、flux、mobx等</p>
<h3 id="♥︎♥︎♥︎-React状态管理工具有哪些？redux-actionCreator都有什么？"><a href="#♥︎♥︎♥︎-React状态管理工具有哪些？redux-actionCreator都有什么？" class="headerlink" title="♥︎♥︎♥︎ React状态管理工具有哪些？redux actionCreator都有什么？"></a>♥︎♥︎♥︎ React状态管理工具有哪些？redux actionCreator都有什么？</h3><p>简单状态管理：组件内部state、基于Context API封装</p>
<p>复杂状态管理：redux(单项数据流)、mobx(响应式数据流)、RxJS(stream)、dva</p>
<p>创建各种action，包含同步、异步，然后在组件中通过dispatch调用</p>
<h3 id="♥︎♥︎♥︎-vuex-和-redux-的区别？"><a href="#♥︎♥︎♥︎-vuex-和-redux-的区别？" class="headerlink" title="♥︎♥︎♥︎  vuex 和 redux 的区别？"></a>♥︎♥︎♥︎  vuex 和 redux 的区别？</h3><h4 id="vuex的流向："><a href="#vuex的流向：" class="headerlink" title="vuex的流向："></a>vuex的流向：</h4><p>view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作）<br>view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作）</p>
<h4 id="redux的流向："><a href="#redux的流向：" class="headerlink" title="redux的流向："></a>redux的流向：</h4><p>view——&gt;actions——&gt;reducer——&gt;state变化——&gt;view变化（同步异步一样）</p>
<h4 id="Redux相对于Flux的改进："><a href="#Redux相对于Flux的改进：" class="headerlink" title="Redux相对于Flux的改进："></a>Redux相对于Flux的改进：</h4><p>（1）把store和Dispatcher合并,结构更加简单清晰</p>
<p>新增state角色，代表每个时间点store对应的值，对状态的管理更加明确</p>
<p>Redux数据流的顺序是:</p>
<p>（2）View调用store.dispatch发起Action-&gt;store接受Action(action传入reducer函数,reducer函数返回一个新的state)-&gt;通知store.subscribe订阅的重新渲染函数</p>
<p>Vuex是专门为Vue设计的状态管理框架, 同样基于Flux架构，并吸收了Redux的优点</p>
<h4 id="Vuex相对于Redux的不同点有"><a href="#Vuex相对于Redux的不同点有" class="headerlink" title="Vuex相对于Redux的不同点有:"></a>Vuex相对于Redux的不同点有:</h4><p>（1）改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch,只需在对应的mutation函数里改变state值即可</p>
<p>（2）由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</p>
<p>（3）Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变(vue检测到数据变化自动渲染)</p>
<h3 id="♥︎♥︎♥︎-Redux遵循的三个原则是什么？"><a href="#♥︎♥︎♥︎-Redux遵循的三个原则是什么？" class="headerlink" title="♥︎♥︎♥︎  Redux遵循的三个原则是什么？"></a>♥︎♥︎♥︎  Redux遵循的三个原则是什么？</h3><p>1、单一数据源</p>
<p>整个应用的state被存储在一棵object tree中，并且整个 object tree 只存在于唯一一个 store 中</p>
<p>2、State是只读的</p>
<p>唯一改变state的方法就是触发 action，action是一个描述已发生事件的普通对象，这样确保视图和网络请求不能直接修改state</p>
<p>3、使用纯函数来执行修改</p>
<p>为了描述action如何改变state tree，你需要编写reducers</p>
<h3 id="♥︎♥︎♥︎-React中的keys的作用是什么？"><a href="#♥︎♥︎♥︎-React中的keys的作用是什么？" class="headerlink" title="♥︎♥︎♥︎  React中的keys的作用是什么？"></a>♥︎♥︎♥︎  React中的keys的作用是什么？</h3><p>key 是用来帮助 react 识别哪些内容被更改、添加或者删除。key 需要写在用数组渲染出来的元素内部，并且需要赋予其一个稳定的值。稳定在这里很重要，因为如果 key 值发生了变更，react 则会触发 UI 的重渲染。这是一个非常有用的特性。</p>
<p>1、key 的唯一性</p>
<p>在相邻的元素间，key 值必须是唯一的，如果出现了相同的 key，同样会抛出一个 Warning，告诉相邻组件间有重复的 key 值。并且只会渲染第一个重复 key 值中的元素，因为 react 会认为后续拥有相同key 的都是同一个组件。</p>
<p>2、key 值不可读</p>
<p>虽然我们在组件上定义了 key，但是在其子组件中，我们并没有办法拿到 key 的值，因为 key 仅仅是给react 内部使用的。如果我们需要使用到 key 值，可以通过其他方式传入，比如将 key 值赋给 id 等</p>
<h3 id="♥︎♥︎♥︎-redux中使用setState不能立刻获取值，怎么办"><a href="#♥︎♥︎♥︎-redux中使用setState不能立刻获取值，怎么办" class="headerlink" title="♥︎♥︎♥︎  redux中使用setState不能立刻获取值，怎么办"></a>♥︎♥︎♥︎  redux中使用setState不能立刻获取值，怎么办</h3><p>setState 只在合成事件和钩子函数中是异步的，在原生事件和 setTimeout 中都是同步</p>
<p>①addeventListener添加的事件或者dom事件中触发</p>
<p>②setState接收的参数还可以是一个函数，在这个函数中可以拿先前的状态，并通过这个函数的返回值得到下一个状态。</p>
<pre><code class="react"> this.setState((preState) =&gt; &#123;
 return &#123;
 xxx: preState.xxx + yyy
 &#125;
&#125;)
</code></pre>
<p>③async&#x2F;await 异步调用处理</p>
<h3 id="♥︎♥︎♥︎-React新老版生命周期函数"><a href="#♥︎♥︎♥︎-React新老版生命周期函数" class="headerlink" title="♥︎♥︎♥︎  React新老版生命周期函数"></a>♥︎♥︎♥︎  React新老版生命周期函数</h3><h4 id="New-Version"><a href="#New-Version" class="headerlink" title="New Version"></a>New Version</h4><p>挂载：constructor –&gt; getDerivedStateFromProps –&gt; render –&gt; componentDidMount</p>
<p>更新：</p>
<p>setState() –&gt; getDerivedStateFromProps –&gt; shouldComponentUpdate –&gt; render –&gt;getSnapshotBeforeUpdate –&gt; componentDidUpdate</p>
<p>forceUpdate() –&gt; getDerivedStateFromProps –&gt; render –&gt; getSnapshotBeforeUpdate –&gt;componentDidUpdate</p>
<p>卸载： componentWillUnmount</p>
<h4 id="Old-Version"><a href="#Old-Version" class="headerlink" title="Old Version"></a>Old Version</h4><p>挂载：constructor –&gt; getDerivedStateFromProps –&gt; render –&gt; ComponentDidMount</p>
<p>更新：</p>
<p>New props –&gt; getDerivedStateFromProps –&gt; shouldComponentUpdate –&gt; render –&gt;getSnapshotBeforeUpdate –&gt; componentDidUpdate</p>
<p>setState() –&gt; shouldComponentUpdate –&gt; render –&gt; getSnapshotBeforeUpdate –&gt;componentDidUpdate</p>
<p>forceUpdate() –&gt; render –&gt; getSnapshotBeforeUpdate –&gt; componentDidUpdate</p>
<p>卸载：componentWillUnmount</p>
<h3 id="♥︎♥︎♥︎-React中怎么让-setState-同步更新？"><a href="#♥︎♥︎♥︎-React中怎么让-setState-同步更新？" class="headerlink" title="♥︎♥︎♥︎ React中怎么让 setState 同步更新？"></a>♥︎♥︎♥︎ React中怎么让 setState 同步更新？</h3><p>setState 回调，setState,第二个参数是一个回调函数，可实现同步</p>
<p>引入 Promise 封装 setState，在调用时我们可以使用 Async&#x2F;Await 语法来优化代码风格</p>
<pre><code class="react">setStateAsync(state) &#123;
 return new Promise((resolve) =&gt; &#123;
 this.setState(state, resolve)
 &#125;);
&#125;

//传入状态计算函数， setState 的第一个参数，
this.setState((prevState, props) =&gt; (&#123; count: prevState.count + 1
&#125;));

//在 setTimeout 函数中调用 setState
</code></pre>
<h3 id="♥︎♥︎♥︎-为什么不建议在-componentWillMount-做AJAX操作"><a href="#♥︎♥︎♥︎-为什么不建议在-componentWillMount-做AJAX操作" class="headerlink" title="♥︎♥︎♥︎ 为什么不建议在 componentWillMount 做AJAX操作"></a>♥︎♥︎♥︎ 为什么不建议在 componentWillMount 做AJAX操作</h3><p>Fiber原因，React16之后，采用了Fiber架构，只有componentDidMount的生命周期函数确定会执行一次，其他像componentWillMount可能会执行多次</p>
<p>render 阶段 可能会被React暂停，中止或重启</p>
<h3 id="♥︎♥︎♥︎-怎么用useEffect模拟生命周期函数？"><a href="#♥︎♥︎♥︎-怎么用useEffect模拟生命周期函数？" class="headerlink" title="♥︎♥︎♥︎ 怎么用useEffect模拟生命周期函数？"></a>♥︎♥︎♥︎ 怎么用useEffect模拟生命周期函数？</h3><ul>
<li>默认函数组件没有生命周期</li>
<li>函数组件是一个纯函数，执行完即销毁，自己无法实现生命周期</li>
<li>通过Effect hook把生命周期“钩”到纯函数中</li>
</ul>
<pre><code class="react">    // 模拟 class 组件的 DidMount 和 DidUpdate
    useEffect(() =&gt; &#123;
      console.log(&#39;在此发送一个 ajax 请求&#39;)
    &#125;)
 
    // 模拟 class 组件的 DidMount
     useEffect(() =&gt; &#123;
        console.log(&#39;加载完了&#39;)
     &#125;, []) // 第二个参数是 [] （不依赖于任何 state）
 
     // 模拟 class 组件的 DidUpdate
     useEffect(() =&gt; &#123;
         console.log(&#39;更新了&#39;)
     &#125;, [count, name]) // 第二个参数就是依赖的 state
 
    // 模拟 class 组件的 DidMount
    useEffect(() =&gt; &#123;
        let timerId = window.setInterval(() =&gt; &#123;
            console.log(Date.now())
        &#125;, 1000)
 
        // 返回一个函数
        // 模拟 WillUnMount 组件销毁的时候 停止计时器
        return () =&gt; &#123;
            window.clearInterval(timerId)
        &#125;
    &#125;, [])
</code></pre>
<ul>
<li>模拟componentDidMount  -  useEffect 依赖 [ ]</li>
<li>模拟compenentDidUpdate - useEffect 无依赖 ，或者 依赖 [a,b,c]</li>
<li>模拟componentWillUnMount - useEffect 中返回一个函数</li>
</ul>
<h3 id="♥︎♥︎♥︎-各种useEffect使用情况？"><a href="#♥︎♥︎♥︎-各种useEffect使用情况？" class="headerlink" title="♥︎♥︎♥︎ 各种useEffect使用情况？"></a>♥︎♥︎♥︎ 各种useEffect使用情况？</h3><p>1、默认情况下，它在第一次渲染之后和每次更新之后都会执行，无需清除的effect</p>
<pre><code class="react">// 在函数式组件中 在 return之前
// Similar to componentDidMount and componentDidUpdate:
 useEffect(() =&gt; &#123;
 // Update the document title using the browser API
 document.title = You clicked $&#123;count&#125; times ;
 &#125;);
</code></pre>
<p>2、需要清除的effect：React 会在组件卸载的时候执行清除操作</p>
<pre><code class="react"> useEffect(() =&gt; &#123;
 function handleStatusChange(status) &#123;
 setIsOnline(status.isOnline);
 &#125;
 ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
 // Specify how to clean up after this effect:
 return function cleanup() &#123;
 ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
 &#125;;
 &#125;);
</code></pre>
<p>3、使用多个effect实现关注点的分离</p>
<p>把类组件中的分散在多个生命周期中的同一件事件的处理，合并到同一个effect中处理</p>
<p>4、通过跳过effect进行性能优化</p>
<pre><code class="react">useEffect(() =&gt; &#123;
 document.title = You clicked $&#123;count&#125; times ;
&#125;, [count]); // 仅在 count 更改时更新
</code></pre>
<h3 id="♥︎♥︎♥︎-useCallback是干什么的？使用useCallback有什么好处？"><a href="#♥︎♥︎♥︎-useCallback是干什么的？使用useCallback有什么好处？" class="headerlink" title="♥︎♥︎♥︎  useCallback是干什么的？使用useCallback有什么好处？"></a>♥︎♥︎♥︎  useCallback是干什么的？使用useCallback有什么好处？</h3><p>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized(缓存)版本，该回调函数仅在某个依赖项改变时才会更新 好处 当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用</p>
<h3 id="♥︎♥︎♥︎-能简单说一下redux-sage的使用流程吗？"><a href="#♥︎♥︎♥︎-能简单说一下redux-sage的使用流程吗？" class="headerlink" title="♥︎♥︎♥︎  能简单说一下redux-sage的使用流程吗？"></a>♥︎♥︎♥︎  能简单说一下redux-sage的使用流程吗？</h3><p>redux-saga 是一个用于管理 Redux 应用异步操作的中间件（又称异步 action）。 redux-saga 通过创建 Sagas 将所有的异步操作逻辑收集在一个地方集中处理，可以用来代替 redux-thunk 中间件。</p>
<p>Reducers 负责处理 action 的 state 更新</p>
<p>Sagas 负责协调那些复杂或异步的操作</p>
<p>1、connet to the store：本质是管理 Redux 应用异步操作的中间件</p>
<pre><code class="react">import &#123; createStore, applyMiddleware &#125; from &#39;redux&#39;
import createSagaMiddleware from &#39;redux-saga&#39;
import reducer from &#39;./reducers&#39;
import mySaga from &#39;./sagas&#39;
// Create the saga middleware
const sagaMiddleware = createSagaMiddleware()
// Mount it on the Store
const store = createStore(
 reducer,
 applyMiddleware(sagaMiddleware)
)
// Then run the saga
sagaMiddleware.run(mySaga)
// Render the application
</code></pre>
<p>2、initiate a side effect：初始化副作用</p>
<pre><code class="react">import &#123; call, put, takeEvery, takeLatest &#125; from &#39;redux-saga/effects&#39;
import Api from &#39;...&#39;
// Worker saga will be fired on USER_FETCH_REQUESTED actions
function* fetchUser(action) &#123;
 try &#123;
 const user = yield call(Api.fetchUser, action.payload.userId);
 yield put(&#123;type: &quot;USER_FETCH_SUCCEEDED&quot;, user: user&#125;);
 &#125; catch (e) &#123;
 yield put(&#123;type: &quot;USER_FETCH_FAILED&quot;, message: e.message&#125;);
 &#125;
&#125;
// Starts fetchUser on each dispatched USER_FETCH_REQUESTED action
// Allows concurrent fetches of user
function* mySaga() &#123;
 yield takeEvery(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);
&#125;
</code></pre>
<p>3、dispath an action：组件中使用</p>
<pre><code class="react"> ...
 onSomeButtonClicked() &#123;
 const &#123; userId, dispatch &#125; = this.props
 dispatch(&#123;type: &#39;USER_FETCH_REQUESTED&#39;, payload: &#123;userId&#125;&#125;)
 &#125;
 ...
&#125;
</code></pre>
<p>4、more：takeEvery、takeLatest、take、put、call、fork、select</p>
<h3 id="♥︎♥︎♥︎-redux-和-mobx-的区别"><a href="#♥︎♥︎♥︎-redux-和-mobx-的区别" class="headerlink" title="♥︎♥︎♥︎  redux 和 mobx 的区别"></a>♥︎♥︎♥︎  redux 和 mobx 的区别</h3><p>1、Redux的编程范式是函数式的而Mobx是面向对象的</p>
<p>2、因此数据上来说Redux理想的是immutable的，每次都返回一个新的数据，而Mobx从始至终都是一份引用。因此Redux是支持数据回溯的</p>
<p>3、然而和Redux相比，使用Mobx的组件可以做到精确更新，这一点得益于Mobx的observable；对应的，Redux是用dispatch进行广播，通过Provider和connect来比对前后差别控制更新粒度，有时需要自己写SCU；Mobx更加精细一点</p>
<p>4、Mobx-react vs React-rdux：</p>
<p>redux,采取Provider和connect方式，mobx采取Provider和inject、observer</p>
<h3 id="♥︎♥︎♥︎-react中如何实现命名插槽"><a href="#♥︎♥︎♥︎-react中如何实现命名插槽" class="headerlink" title="♥︎♥︎♥︎ react中如何实现命名插槽"></a>♥︎♥︎♥︎ react中如何实现命名插槽</h3><p>由于在React组件中写的内容会被挂载到props中，以此来实现类似vue中的插槽功能</p>
<p>这是最外层代码</p>
<pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;
import NavBar from &#39;./NavBar&#39;
import NavBar2 from &#39;./NavBar2&#39;

export default class App extends Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;NavBar&gt;
          &lt;span&gt;aaa&lt;/span&gt;
          &lt;strong&gt;bbb&lt;/strong&gt;
          &lt;a href=&quot;/#&quot;&gt;ccc&lt;/a&gt;
        &lt;/NavBar&gt;

        &lt;NavBar2 leftslot=&#123;&lt;span&gt;aaa&lt;/span&gt;&#125;
        centerslot=&#123;&lt;strong&gt;bbb&lt;/strong&gt;&#125;
        rightslot=&#123;&lt;a href=&quot;/#&quot;&gt;ccc&lt;/a&gt;&#125;/&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<p>1.用this.props.children[index]</p>
<pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;

import &#39;./style.css&#39;
export default class NavBar extends Component &#123;
  render () &#123;
    return (
      &lt;div className=&quot;nav-bar&quot;&gt;
        &lt;div className=&quot;nav-left&quot;&gt;
          &#123;this.props.children[0]&#125;
        &lt;/div&gt;
        &lt;div className=&quot;nav-center&quot;&gt;
          &#123;this.props.children[1]&#125;
        &lt;/div&gt;
        &lt;div className=&quot;nav-right&quot;&gt;
          &#123;this.props.children[2]&#125;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<p>2.用直接命名方式</p>
<pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;

import &#39;./style.css&#39;
export default class NavBar extends Component &#123;
  render () &#123;
    const &#123;leftslot, centerslot,rightslot&#125; = this.props
    return (
      &lt;div className=&quot;nav-bar&quot;&gt;
        &lt;div className=&quot;nav-left&quot;&gt;
          &#123;leftslot&#125;
        &lt;/div&gt;
        &lt;div className=&quot;nav-center&quot;&gt;
          &#123;centerslot&#125;
        &lt;/div&gt;
        &lt;div className=&quot;nav-right&quot;&gt;
          &#123;rightslot&#125;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎-简单说一下，如何在react中实现瀑布流加载？（左右两列的一个商品长列表）"><a href="#♥︎♥︎♥︎-简单说一下，如何在react中实现瀑布流加载？（左右两列的一个商品长列表）" class="headerlink" title="♥︎♥︎♥︎  简单说一下，如何在react中实现瀑布流加载？（左右两列的一个商品长列表）"></a>♥︎♥︎♥︎  简单说一下，如何在react中实现瀑布流加载？（左右两列的一个商品长列表）</h3><p>根据红线，将数据分为两部分，然后根据两边的高度（哪边少往那边加内容）去渲染两个盒子，然后达到一个瀑布流的效果</p>
<pre><code class="react">import React, &#123; Component,Fragment &#125; from &#39;react&#39;;
import &#123;connect&#125; from&#39;react-redux&#39;
import Axios from &#39;_axios@0.19.0@axios&#39;;
class Waterfall extends Component &#123;
 constructor(props) &#123;
 super(props);
 this.state = &#123; 
 data:[],//整体的数据
 leftData:[],//左边的数据
 rightData:[]//右边的数据
 &#125;
 &#125;
 getHW(data)&#123;
 let heightDate = [0,0];//接收累计高度的容器数组
 let rightData =[]//渲染右侧盒子的数组
 let leftData = []//渲染左侧盒子的数组
 data.forEach(item =&gt; &#123;
 let height = item.src.replace(&#39;http://dummyimage.com/&#39;,&#39;&#39;).substr(0,7).split(&#39;x&#39;)[1]*1;//对url地址进行一
个截取，拿到高度
 let minNum = Math.min.apply(null,heightDate)// 从heighetData筛选最小项
 let minIndex = heightDate.indexOf(minNum);// 获取 最小项的小标 准备开始进行累加
 heightDate[minIndex] = heightDate[minIndex] + height;//从 heightData 中找到最小的项后进行累加，
 if(minIndex===0)&#123;//[0]加到left [1]加到 right
 leftData.push(item)
 &#125;else&#123;
 rightData.push(item)
 &#125;
 &#125;)
 this.setState(&#123; leftData,rightData &#125;);//重新set state
 &#125;
 render() &#123; 
 let &#123;leftData,rightData&#125; = this.state;
 console.log(leftData,rightData)
 return ( 
 
 
&#123; leftData &amp;&amp; leftData.map((item,index)=&gt;&#123; return &#125;) &#125; &#123; rightData &amp;&amp; rightData.map((item,index)=&gt;&#123; return &#125;) &#125;
); &#125; componentDidMount()&#123; Axios.get(&#39;/api/data&#39;).then(res=&gt;&#123; this.props.dispatch(&#123; type:&#39;SET_DATA&#39;,
data:res.data.data &#125;) this.getHW(this.props.data) //调用 &#125;) &#125; &#125;
export default connect(
 (state)=&gt;&#123;
 return&#123;
 data:state.data,
 &#125;
 &#125;
)(Waterfall);
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎♥︎-React-hooks-用过吗，为什么要用？"><a href="#♥︎♥︎♥︎♥︎-React-hooks-用过吗，为什么要用？" class="headerlink" title="♥︎♥︎♥︎♥︎ React hooks 用过吗，为什么要用？"></a>♥︎♥︎♥︎♥︎ React hooks 用过吗，为什么要用？</h3><p>Hooks 是React在16.8版本中出的一个新功能，本质是一种函数，可以实现组件逻辑复用，让我们在函数式组件中使用类组件中的状态、生命周期等功能，hooks的名字都是以use开头。</p>
<pre><code class="css">1、useState——创建状态 接收一个参数作为初始值；返回一个数组，第一个值为状态，第二个值为改变状态的函数 
2、useEffect——副作用（数据获取、dom操作影响页面——在渲染结束之后执行)
        (1)第一个参数为函数，第二个参数为依赖列表，只有依赖更新时才会执行函数；返回一个函 数，当页面刷新的时候先执行返回函数再执行参数函数 
        (2)如果不接受第二个参数，那么在第一次渲染完成之后和每次更新渲染页面的时候，都会调 用useEffect的回调函数 
3、useRef 返回一个可变的ref对象，此索引在整个生命周期中保持不变。可以用来获取元素或组件的实例，用来做 输入框的聚焦或者动画的触发。 
4、useMemo——优化函数组件中的功能函数——在渲染期间执行 
    （1）接收一个函数作为参数，同样接收第二个参数作为依赖列表，返回值可以是任何，函数、对象等都可 以 
    （2）这种优化有助于避免在每次渲染时都进行高开销的计算，仅会在某个依赖项改变时才重新计算 
5、useContext——获取上下文注入的值 
        (1)接受一个context 对象，并返回该对象&lt;MyContext.Provider&gt; 元素的 value值； const value = useContext(MyContext)； 
6、useLayoutEffect——有DOM操作的副作用——在DOM更新之后执行 和useEffet类似，但是执行时机不同，useLayoutEffect在DOM更新之后执行， useEffect在render渲染结束后执行，也就是说useLayoutEffect比useEffect先执行，这是因为DOM更 新之后，渲染才结束或者渲染还会结束 
7、useCallback——与useMemo类似
useMemo与useCallback相同，接收一个函数作为参数，也同样接收第二个参数作为依赖列 表；useCallback是对传过来的回调函数优化，返回的是一个函数
</code></pre>
<pre><code class="css">react-router:
 被route包裹的组件，可以直接使用props进行路由相关操作，但是没有被route包裹的组件只能用withRouter高阶组件修饰或者使用hooks进行操作
 1、useHistory——跳转路由
 2、useLocation——得到url对象
 3、useParams——得到url上的参数

react-redux:
 1、useSelector——共享状态——从redux的store中提取数据
 2、useDispatch——共享状态——返回redux的store中对dispatch的引用
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-虚拟DOM的优劣如何？实现原理？"><a href="#♥︎♥︎♥︎♥︎-虚拟DOM的优劣如何？实现原理？" class="headerlink" title="♥︎♥︎♥︎♥︎ 虚拟DOM的优劣如何？实现原理？"></a>♥︎♥︎♥︎♥︎ 虚拟DOM的优劣如何？实现原理？</h3><p>虚拟dom是用js模拟一颗dom树,放在浏览器内存中，相当于在js和真实dom中加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。</p>
<p> 优点：</p>
<p> （1）虚拟DOM具有批处理和高效的Diff算法,最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染,优化性能；</p>
<p> （2）虚拟DOM不会立马进行排版与重绘操作，对虚拟DOM进行频繁修改，最后一次性比较并修改真实DOM中需要改的部分；</p>
<p> （3）虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部；</p>
<p> 缺点：</p>
<p> （1）首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢；</p>
<pre><code class="css">React组件的渲染过程： 
（1）使用JSX编写React组件后所有的JSX代码会通过Babel转化为 React.createElement执行; 
（2）createElement函数对 key和 ref等特殊的 props进行处理，并获取 defaultProps对默认 props进行赋值，并且对传入的子节点进行处理，最终构造成一个 ReactElement对象（所谓的虚拟 DOM）。
（3）ReactDOM.render将生成好的虚拟 DOM渲染到指定容器上，其中采用了批处理、事务等机制并且 对特定浏览器进行了性能优化，最终转换为真实 DOM。

虚拟DOM的组成——ReactElementelement对象结构： 
（1）type：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或class） 
（2）key：组件的唯一标识，用于Diff算法，下面会详细介绍 
（3）ref：用于访问原生dom节点 
（4）props：传入组件的props，chidren是props中的一个属性，它存储了当前组件的孩子节点，可 以是数组（多个孩子节点）或对象（只有一个孩子节点） 
（5）owner：当前正在构建的Component所属的Component 
（6）self：（非生产环境）指定当前位于哪个组件实例 
（7）_source：（非生产环境）指定调试代码来自的文件(fileName)和代码行数(lineNumber)
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-React-和-Vue-的-diff-时间复杂度从-O-n-3-优化到-O-n-，那么-O-n-3-和-O-n-是如何计算出来的？"><a href="#♥︎♥︎♥︎♥︎-React-和-Vue-的-diff-时间复杂度从-O-n-3-优化到-O-n-，那么-O-n-3-和-O-n-是如何计算出来的？" class="headerlink" title="♥︎♥︎♥︎♥︎ React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？"></a>♥︎♥︎♥︎♥︎ React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？</h3><p>react的diff算法只需要O(n)，这是因为react对树节点的比较做了一些前提假设，限定死了一些东西，不做过于复杂的计算操作，所以降低了复杂度。react和vue做了以下的假设，这样的话diff运算时只进行同层比较，每一个节点只遍历了一次。</p>
<p> （1）Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计；</p>
<p> （2）拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构；</p>
<p> （3）对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</p>
<blockquote>
<p>而传统的diff运算时间复杂度为O(n^3)，这是因为传统的树节点要做非常完整的检查，首先需要节点之 间需要两两比较，找到所有差异，这个对比过程时间复杂度为O(n^2)，找到差异后还要计算出最小的转换方式，最终复杂度为O(n^3) </p>
</blockquote>
<h3 id="♥︎♥︎♥︎♥︎-请列举react生命周期函数。"><a href="#♥︎♥︎♥︎♥︎-请列举react生命周期函数。" class="headerlink" title="♥︎♥︎♥︎♥︎ 请列举react生命周期函数。"></a>♥︎♥︎♥︎♥︎ 请列举react生命周期函数。</h3><table>
<thead>
<tr>
<th align="center">阶段</th>
<th align="center">生命周期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一阶段：装载阶段3</td>
<td align="center">constructor()    render()    componentDidMount()</td>
</tr>
<tr>
<td align="center">第二阶段：更新阶段2</td>
<td align="center">shouldComponentUpdate()     render()    componentDidUpdate()</td>
</tr>
<tr>
<td align="center">第三阶段：卸载阶段1</td>
<td align="center">componentWillUnmount()</td>
</tr>
</tbody></table>
<h4 id="constructor生命周期："><a href="#constructor生命周期：" class="headerlink" title="constructor生命周期："></a>constructor生命周期：</h4><p> (1)当react组件实例化时，是第一个运行的生命周期；</p>
<p> (2)在这个生命周期中，不能使用this.setState()；</p>
<p> (3)在这个生命周期中，不能使用副作用(调接口、dom操作、定时器、长连接等)；</p>
<p> (4)不能把props和state交叉赋值；</p>
<h4 id="componentDidMount生命周期："><a href="#componentDidMount生命周期：" class="headerlink" title="componentDidMount生命周期："></a>componentDidMount生命周期：</h4><p> (1)相当于是vue中的mounted；</p>
<p> (2)它表示DOM结构在浏览器中渲染已完成；</p>
<p> (3)在这里可以使用任何的副作用；</p>
<h4 id="shouldComponentUpdate-nextProps-nextState-生命周期："><a href="#shouldComponentUpdate-nextProps-nextState-生命周期：" class="headerlink" title="shouldComponentUpdate(nextProps,nextState)生命周期："></a>shouldComponentUpdate(nextProps,nextState)生命周期：</h4><p> (1)相当于一个开关，如果返回true则更新机制正常执行，如果为false则更新机制停止；</p>
<p> (2)在vue中是没有的；</p>
<p> (3)存在的意义：可以用于性能优化，但是不常用，最新的解决方案是使用PureComponent；</p>
<p> (4)理论上，这个生命周期的作用，用于精细地控制声明式变量的更新问题，如果变化的声明式变量参与了视图渲染则返回true，如果被变化的声明式变量没有直接或间接参与视图渲染，则返回false；</p>
<h4 id="componentDidUpdate生命周期："><a href="#componentDidUpdate生命周期：" class="headerlink" title="componentDidUpdate生命周期："></a>componentDidUpdate生命周期：</h4><p> (1)相当于vue中的updated()；</p>
<p> (2)它表示DOM结构渲染更新已完成，只发生在更新阶段；</p>
<p> (3)在这里，可以执行大多数的副作用，但是不建议；</p>
<p> (4)在这里，可以使用this.setState()，但是要有终止条件判断。</p>
<h4 id="componentWillUnmount生命周期："><a href="#componentWillUnmount生命周期：" class="headerlink" title="componentWillUnmount生命周期："></a>componentWillUnmount生命周期：</h4><p> (1)一般在这里清除定时器、长连接等其他占用内存的构造器；render生命周期：</p>
<p> (1)render是类组件中唯一必须有的生命周期，同时必须有return（return 返回的jsx默认只能是单一根节点，但是在fragment的语法支持下，可以返回多个兄弟节点）；</p>
<p> (2)Fragment碎片写法: &lt;React.Fragment&gt;&lt;&#x2F;React.Fragment&gt; 简写成&lt;&gt;&lt;&#x2F;&gt;；</p>
<p> (3)return之前，可以做任意的业务逻辑，但是不能使用this.setState()，会造成死循环；</p>
<p> (4)render()在装载阶段和更新阶段都会运行；</p>
<p> (5)当render方法返回null的时候，不会影响生命周期函数的正常执行。</p>
<h3 id="♥︎♥︎♥︎♥︎-新出来两个钩子函数？和砍掉的will系列有啥区别？"><a href="#♥︎♥︎♥︎♥︎-新出来两个钩子函数？和砍掉的will系列有啥区别？" class="headerlink" title="♥︎♥︎♥︎♥︎  新出来两个钩子函数？和砍掉的will系列有啥区别？"></a>♥︎♥︎♥︎♥︎  新出来两个钩子函数？和砍掉的will系列有啥区别？</h3><pre><code class="javascript">/ react16 中废弃了三个钩子
componentWillMount // 组件将要挂载的钩子
componentWillReceiveProps // 组件将要接收一个新的参数时的钩子
componentWillUpdate // 组件将要更新的钩子
</code></pre>
<pre><code class="javascript">/ 新增了方法
getDerivedStateFromProps // 静态方法
getSnapshotBeforeUpdate
</code></pre>
<p>在16.8版本以后，react将diff运算改进为Fiber，这样的话当我们调用setState方法进行更新的时候，在reconciler 层中js运算会按照节点为单位拆分成一个个小的工作单元，在render前可能会中断或恢复，就有可能导致在render前这些生命周期在进行一次更新时存在多次执行的情况，此时如果我们在里面使用ref操作dom的话，就会造成页面频繁重绘，影响性能。 所以废弃了这几个will系列的勾子，增加了 getDerivedStateFromProps这个静态方法，这样的话我们就不能在其中使用this.refs以及this上的方法了；getSnapshotBeforeUpdate 这个方法已经到了commit阶段，只会执行一次，给想读取 dom 的用户一些空间。</p>
<h3 id="♥︎♥︎♥︎♥︎-react中-setState-之后做了什么？"><a href="#♥︎♥︎♥︎♥︎-react中-setState-之后做了什么？" class="headerlink" title="♥︎♥︎♥︎♥︎  react中 setState 之后做了什么？"></a>♥︎♥︎♥︎♥︎  react中 setState 之后做了什么？</h3><p>如果是在隶属于原生js执行的空间，比如说setTimeout里面，setState是同步的，那么每次执行setState将立即更新this.state，然后触发render方法，渲染数据；</p>
<p> 如果是在被react处理过的空间执行，比如说合成事件里，此时setState是异步执行的，并不会立即更新this.state的值，当执行setState的时候，会将需要更新的state放入状态队列，在这个空间最后再合并修改this.state，触发render；</p>
<h3 id="♥︎♥︎♥︎♥︎-redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？"><a href="#♥︎♥︎♥︎♥︎-redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？" class="headerlink" title="♥︎♥︎♥︎♥︎  redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？"></a>♥︎♥︎♥︎♥︎  redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？</h3><p>当我们需要修改store中值的时候，我们是通过 dispatch(action)将要修改的值传到reducer中的，这个过程是同步的，如果我们要进行异步操作的时候，就需要用到中间件；中间件其实是提供了一个分类处理action的机会，在 middleware 中，我们可以检阅每一个流过的action，并挑选出特定类型的action进行相应操作，以此来改变 action；</p>
<pre><code class="css">applyMiddleware 是个三级柯里化的函数。它将陆续的获得三个参数：第一个是 middlewares 数 组，第二个是 Redux 原生的 createStore，最后一个是 reducer；然后applyMiddleware会将不同的 中间件一层一层包裹到原生的 dispatch 之上； 
redux-thunk 中间件的作用就是让我们可以异步执行redux，首先检查参数 action 的类型，如果 是函数的话，就执行这个 action这个函数，并把 dispatch, getState, extraArgument 作为参数传 递进去，否则就调用next让下一个中间件继续处理action。
</code></pre>
<pre><code class="react">// redux-thunk部分源码
function createThunkMiddleware(extraArgument) &#123;
 return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;
 if (typeof action === &#39;function&#39;) &#123;
 return action(dispatch, getState, extraArgument)
 &#125;
 return next(action)
 &#125;
&#125;
const thunk = createThunkMiddleware()
thunk.withExtraArgument = createThunkMiddleware
export default thunk
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-列举重新渲染-render-的情况"><a href="#♥︎♥︎♥︎♥︎-列举重新渲染-render-的情况" class="headerlink" title="♥︎♥︎♥︎♥︎ 列举重新渲染 render 的情况"></a>♥︎♥︎♥︎♥︎ 列举重新渲染 render 的情况</h3><ol>
<li>this.setState() </li>
<li>this.forceUpdate()</li>
<li>接受到新的props</li>
<li>通过状态管理，mobx、redux等</li>
<li>改变上下文</li>
</ol>
<h3 id="♥︎♥︎♥︎♥︎-类组件怎么做性能优化？函数组件怎么做性能优化？"><a href="#♥︎♥︎♥︎♥︎-类组件怎么做性能优化？函数组件怎么做性能优化？" class="headerlink" title="♥︎♥︎♥︎♥︎ 类组件怎么做性能优化？函数组件怎么做性能优化？"></a>♥︎♥︎♥︎♥︎ 类组件怎么做性能优化？函数组件怎么做性能优化？</h3><p>类组件：</p>
<pre><code class="css"> （1）使用shouldComponentUpdate：这个生命周期可以让我们决定当前状态或属性的改变是否重新渲染组件，默认返回ture，返回false时不会执行render，在初始化渲染或使用forceUpdate()时不会调用；如果在shouldComponentUpdate比较的值是引用类型的话，可能达不到我们想要的效果，因为引用类型指向同一个地址；当将旧的state的值原封不动赋值给新的state（即不改变state的值，但是调用了setState）和 无数据交换的父组件的重新渲染都会导致组件重新渲染，这时候都可以通过shouldComponentUpdate来优化；

 （2）React.PureComponent：基本上和Component用法一致，不同之处在于 PureComponent不需要开发者自己设置shouldComponentUpdate，因为PureComponent自带通过props和state的浅对比来实现 shouldComponentUpate；但是如果props和state对象包含复杂的数据结构，它可能会判断错误(表现为对象深层的数据已改变，视图却没有更新）；

 （4）使用Immutable：immutable是一种持久化数据，一旦被创建就不会被修改，修改immutable对象的时候返回新的immutable；也就是说在使用旧数据创建新数据的时候，会保证旧数据同时可用且不变；为了避免深度复制所有节点的带来的性能损耗，immutable使用了结构共享，即如果对象树中的一个节点发生变化，只修改这个节点和受他影响的父节点，其他节点仍然共享；

 （5）bind函数：在react中改变this的指向有三种方法，a)constructor中用bind绑定; b)使用时通过bind绑定; c)使用箭头函数；选择第一种只在组件初始化的时候执行一次，第二种组件在每次render都要重新绑定，第三种在每次render时候都会生成新的箭头函数，所以选择第一种；
</code></pre>
<p>函数组件：</p>
<pre><code class="css"> （1）useCallback：接收一个函数作为参数，接收第二个参数作为依赖列表，返回值为函数，有助于避免在每次渲染时都进行高开销的计算，仅会在某个依赖项改变时才重新计算；可以使用useCallback把要传递给子组件的函数包裹起来，这样父组件刷新的时候，传递给子组件的函数指向不会发生改变，可以减少子组件的渲染次数；

 const handleUseCallback=useCallback(handleClick,[])

 （2）useMemo：useMemo的使用和useCallback差不多，只是useCallback返回的是一个函数，useMemo返回值可以是函数、对象等都可以；
</code></pre>
<p>两者都可使用：</p>
<pre><code class="css">（1）React.memo：React.memo 功能同React.PureComponent，但React.memo是高阶组件，既可以用在类组件中也可以用在函数组件中；memo还可以接收第二个参数，是一个可定制化的比较函数，其返回值与 shouldComponentUpdate的相反；

（2）使用key：在列表渲染时使用key，这样当组件发生增删改、排序等操作时，diff运算后可以根据key值直接调整DOM顺序，避免不必要的渲染而避免性能的浪费；

（3）不要滥用props：尽量只传需要的数据，避免多余的更新，尽量避免使用&#123;…props&#125;；
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-什么是-prop-drilling，如何避免？"><a href="#♥︎♥︎♥︎♥︎-什么是-prop-drilling，如何避免？" class="headerlink" title="♥︎♥︎♥︎♥︎ 什么是 prop drilling，如何避免？"></a>♥︎♥︎♥︎♥︎ 什么是 prop drilling，如何避免？</h3><p>从一个外部组件一层层将prop传递到内部组件很不方便，这个问题就叫做 prop drilling；主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护，代码看起来也变得冗余，不优雅；</p>
<p>为了避免prop drilling，一种常用的方法是使用React Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过 Consumer组件或 useContext Hook 使用上下文数据。</p>
<h3 id="♥︎♥︎♥︎♥︎-什么是-React-Context"><a href="#♥︎♥︎♥︎♥︎-什么是-React-Context" class="headerlink" title="♥︎♥︎♥︎♥︎ 什么是 React Context?"></a>♥︎♥︎♥︎♥︎ 什么是 React Context?</h3><p>React Context源码解析</p>
<p>1、What</p>
<p>Context提供了一个无需为每层组件手动添加props，就能在组件树间进行数据传递的功能</p>
<p>2、Why</p>
<p>某些全局属性，通过父子props传递太过繁琐，Context提供了一种组件之间共享此类值的方式，而不必显式的通过组件树逐层传递props</p>
<p>3、When</p>
<p>共享那些对于一个组件树而言是全局的数据，例如当前认证的用户、主题或者首选语言等</p>
<p>4、Where</p>
<p>Context应用场景在于很多不同层级的组件访问同样的数据，这样也使得组件的复用性变差。</p>
<p>如果你只是想避免层层传递一些属性，组件组合有时候是一个比Context更好的方案，也就是直接传递组件</p>
<p>所以一个技术方案的选定需要针对不同的场景具体分析，采取合适的方案</p>
<p>5、How</p>
<pre><code class="css">// ①创建

const ThemeContext = React.createContext(&#39;xxx&#39;)

// ②注入---提供者 在入口或者你想要注入的父类中，且可以嵌套，里层覆盖外层

return (
&lt;ThemeContext.Provider value=&quot;yyy&quot;&gt;
&#123;children&#125;
&lt;ThemeContext.Provider&gt;
)

// ③使用---消费者 需要使用共享数据的子类中

// 方式一
static contextType = ThemeContext
// 方式二
Class.contextType = ThemeContext 
render() &#123;
let value = this.context
/* 基于这个值进行渲染工作 */ 
&#125;
//方式三
return(
&lt;ThemeContext.Consumer&gt;
&#123; value =&gt; /* 基于 context 值进行渲染*/ &#125;
&lt;/ThemeContext.Consumer&gt;
)
</code></pre>
<p>6、More</p>
<p>动态Context—类似父子组件</p>
<pre><code class="css">// ①创建

const ThemeContext = React.createContext(&#123;
value: &#39;xxx&#39;,
changeFunc: () =&gt; &#123;&#125; /*通过context传递这个函数，让consumers组件更新context*/
&#125;)

// ②注入
return (
&lt;ThemeContext.Provider value=&quot;yyy&quot;&gt;
&lt;ThemeContext.Provider&gt;
)

// ③消费

return(
&lt;ThemeContext.Consumer&gt;
&#123; (&#123;value, changeFunc&#125;) =&gt; /* 基于 context 值进行渲染,同时把changeFunc绑定*/ &#125;
 &lt;/ThemeContext.Consumer&gt;
)
消费多个Context、注意事项等参考React中文网
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-Hooks-会取代-render-props-和高阶组件吗"><a href="#♥︎♥︎♥︎♥︎-Hooks-会取代-render-props-和高阶组件吗" class="headerlink" title="♥︎♥︎♥︎♥︎  Hooks 会取代 render props 和高阶组件吗?"></a>♥︎♥︎♥︎♥︎  Hooks 会取代 render props 和高阶组件吗?</h3><p>可以取代，但没必要</p>
<p>在Hook的渐进策略中也有提到，没有计划从React中移除class，在新的代码中同时使用Hook和class，所以这些方案目前还是可以有勇武之地</p>
<p>1、What</p>
<p>为什么要把这3种技术拿过来对比？</p>
<p>都在处理同一个问题，逻辑复用</p>
<p>高阶组件HOC—不是 React API 的一部分，是基于 React 的组合特性形成的设计模式。</p>
<p>高阶组件是参数为组件，返回值为新组件的函数（将组件转换为另一个组件，纯函数，无副作用）</p>
<p>Render Props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的 简单技术</p>
<p>Hooks 是React16.8新增的特性，是一些可以让你在函数组件里“钩入”React state及生命周期等特性的函数</p>
<p>虽然 HOC &amp; Render Props 能处理逻辑复用的问题，但是却存在各自的问题。</p>
<p>HOC 存在的问题</p>
<ul>
<li>写法破坏了原来组件的结构，DevTools中组件会形成“嵌套地狱”</li>
<li>不要在 render 方法中使用 HOC 每次调用render函数会创建一个新的高阶组件导致该组件及其子组件的状态丢失</li>
<li>需要修复静态方法，即拷贝原组件的静态方法到高级组件中</li>
<li>如需传递Ref则需要通过React.forwardRef创建组件</li>
</ul>
<p>Render Props 存在的问题</p>
<ul>
<li>同样的写法会破坏原来组件的结构，DevTools中组件会形成“嵌套地狱” </li>
<li>与React.PureComponent组件使用有冲突</li>
<li>Hook 目前最优雅的实现，React为共享状态逻辑提供最好的原生途径</li>
<li>没有破坏性改动，完全可选，100%向后兼容</li>
<li>解决复杂组件，中逻辑状态、副作用和各种生命周期函数中逻辑代码混在一起，难以拆分，甚至形成bug的问题</li>
</ul>
<p>2、When</p>
<ul>
<li>在函数组件中意识到要向其添加一些state—useState</li>
<li>有副作用的行为时</li>
</ul>
<p>3、Where</p>
<p>只能在函数最外层调用Hook，不要在循环、条件判断或者子函数中调用</p>
<p>只能在函数组件或者自定义Hook中调用Hook</p>
<h3 id="♥︎♥︎♥︎♥︎-当调用setState时，React-render-是如何工作的？"><a href="#♥︎♥︎♥︎♥︎-当调用setState时，React-render-是如何工作的？" class="headerlink" title="♥︎♥︎♥︎♥︎ 当调用setState时，React render 是如何工作的？"></a>♥︎♥︎♥︎♥︎ 当调用setState时，React render 是如何工作的？</h3><p>调用setState()</p>
<ol>
<li>检查上下文环境生成更新时间相关参数并判定事件优先级（fiber，currenttime，expirationtime等…）</li>
<li>根据优先级相关参数判断更新模式是sync（同步更新）或是batched（批量处理）</li>
<li>加入执行更新事件的队列，生成事件队列的链表结构</li>
<li>根据链表顺序执行更新</li>
<li>setState既是同步的，也是异步的。同步异步取决于setState运行时的上下文。且setState 只在合成事件和钩子函数中是“异步”的，在原生DOM事件和 setTimeout 中都是同步的</li>
</ol>
<p>render如何工作</p>
<ol>
<li>React在props或state发生改变时，会调用React的render方法，创建一颗不同的树</li>
<li>React需要基于这两颗不同的树之间的差别来判断如何有效的更新UI diff算法，将两颗树完全比较更新的算法从O(n^3^),优化成O(n)；</li>
<li>同层节点之间相互比较，不会跨节点比较</li>
<li>不同类型的节点，产生不同的树结构</li>
<li>设置key来指定节点在不同的渲染下保持稳定</li>
</ol>
<h3 id="♥︎♥︎♥︎♥︎-diff复杂度原理及具体过程画图"><a href="#♥︎♥︎♥︎♥︎-diff复杂度原理及具体过程画图" class="headerlink" title="♥︎♥︎♥︎♥︎ diff复杂度原理及具体过程画图"></a>♥︎♥︎♥︎♥︎ diff复杂度原理及具体过程画图</h3><ul>
<li>React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；</li>
<li>React 通过分层求异的策略，对 tree diff 进行算法优化；</li>
<li>React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；</li>
<li>React 通过设置唯一 key的策略，对 element diff 进行算法优化；</li>
<li>建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；</li>
<li>建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎-shouldComponentUpdate的作用是什么？"><a href="#♥︎♥︎♥︎♥︎-shouldComponentUpdate的作用是什么？" class="headerlink" title="♥︎♥︎♥︎♥︎  shouldComponentUpdate的作用是什么？"></a>♥︎♥︎♥︎♥︎  shouldComponentUpdate的作用是什么？</h3><p>shouldComponentUpdate的作用</p>
<p>1、What</p>
<p>不常用的生命周期方法，能影响组件是否重新渲染</p>
<p>在更新阶段，当有new props 或者 调用了 setState()方法，在render方法执行前会执行到，默认返回值为true，如果返回false则不刷新组件</p>
<p>2、Why &amp; When &amp; Where</p>
<ol>
<li>如果你知道在什么情况下组件不需要更新，你可以让其返回值为false跳过整个渲染过程</li>
<li>次方法仅作为 性能优化方式 而存在，不要企图靠此方法来阻止渲染，</li>
<li>大部分情况下，使用PureComponent代替手写shouldComponentUpdate，仅浅层对比</li>
<li>不建议在shoulComponentUpdate中进行深层或者使用JSON.stringify()，这样非常影响效率和性能</li>
<li>作为React组件中不常用的生命周期函数，能影响组件是否重渲染</li>
<li>建议做浅层次的比较，来优化性能，当然这里也可以用PureComponent组件代替</li>
<li>如果有较深层次的比较则可能会导致更严重的性能问题，因此在这种情况下不要靠手动管理组件的重新渲染来优化性能，要找其他方式</li>
</ol>
<h3 id="♥︎♥︎♥︎♥︎-什么是高阶组件、受控组件及非受控组件？都有啥区别"><a href="#♥︎♥︎♥︎♥︎-什么是高阶组件、受控组件及非受控组件？都有啥区别" class="headerlink" title="♥︎♥︎♥︎♥︎ 什么是高阶组件、受控组件及非受控组件？都有啥区别"></a>♥︎♥︎♥︎♥︎ 什么是高阶组件、受控组件及非受控组件？都有啥区别</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>高阶组件HOC—不是 React API 的一部分，是基于 React 的组合特性形成的设计模式。</p>
<p>高阶组件是参数为组件，返回值为新组件的函数（将组件转换为另一个组件，纯函数，无副作用）</p>
<h4 id="2、受控组件"><a href="#2、受控组件" class="headerlink" title="2、受控组件"></a>2、受控组件</h4><p>在表单元素中，state是唯一数据源，渲染表单的React组件控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素叫做受控组件</p>
<h3 id="3、非受控组件"><a href="#3、非受控组件" class="headerlink" title="3、非受控组件"></a>3、非受控组件</h3><p>表单数据由DOM节点来处理，而不是用state来管理数据，一般可以使用ref来从DOM节点中获取表单数据</p>
<p>‼️区别</p>
<ul>
<li>受控组件和非受控组件是表单中的组件，高阶组件相当于对某个组件注入一些属性方法</li>
<li>高阶组件是解决代码复用性问题产生的技术</li>
<li>受控组件必须要有一个value，结合onChange来控制这个value，取值为event.target.value&#x2F;event.target.checked</li>
<li>非受控组件相当于操作DOM，一般有个defaultValue，通过onBlur触发响应方法</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎-vue-react都怎么检测数据变化"><a href="#♥︎♥︎♥︎♥︎-vue-react都怎么检测数据变化" class="headerlink" title="♥︎♥︎♥︎♥︎ vue react都怎么检测数据变化"></a>♥︎♥︎♥︎♥︎ vue react都怎么检测数据变化</h3><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><p>React默认是通过比较引用的方式（diff）进行的，不精确监听数据变化，如果不优化可能导致大量不必要的VDOM重新渲染</p>
<p>16之前 componentWillReveiveProps 监听 props 变化</p>
<p>16之后 getDerivedStateFromProps 监听 props</p>
<h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><p>vue监听变量变化依靠 watch Object.defineProperty，Vue通过“getter&#x2F;setter”以及一些函数的劫持，能精确知道数据变化</p>
<h3 id="♥︎♥︎♥︎♥︎-什么是-immutable？为什么要使用它？"><a href="#♥︎♥︎♥︎♥︎-什么是-immutable？为什么要使用它？" class="headerlink" title="♥︎♥︎♥︎♥︎ 什么是 immutable？为什么要使用它？"></a>♥︎♥︎♥︎♥︎ 什么是 immutable？为什么要使用它？</h3><p>immutable是一种持久化数据。一旦被创建就不会被修改。修改immutable对象的时候返回新的immutable。但是原数据不会改变。</p>
<p>在Rudux中因为深拷贝对性能的消耗太大了（用到了递归，逐层拷贝每个节点）。 但当你使用immutable数据的时候：只会拷贝你改变的节点，从而达到了节省性能。 </p>
<p>总结：immutable的不可变性</p>
<p>让纯函数更强大，每次都返回新的immutable的特性让程序员可以对其进行链式操作，用起来更方便。</p>
<p>因为在react中，react的生命周期中的setState()之后的shouldComponentUpdate()阶段默认返回true，所以会造成本组件和子组件的多余的render，重新生成virtual dom，并进行virtual dom diff，所以解决办法是我们在本组件或者子组件中的shouldComponentUpdate()函数中比较，当不需要render时，不render。 </p>
<p>当state中的值是对象时，我们必须使用深拷贝和深比较！</p>
<p>如果不进行深拷贝后再setState，会造成this.state和nextState指向同一个引用，所以shouldComponentUpdate()返回值一定是false，造成state值改了，而组件未渲染（这里不管shouldComponentUpdate中使用的是深比较还是浅比较）。所以必须深拷贝。</p>
<p>如果不在shouldComponentUpdate中进行深比较，会造成即使state中的对象值没有改变，因为是不同的对象，而在shouldComponentUpdate返回true，造成不必要的渲染。</p>
<p>所以只能是深拷贝和深比较。</p>
<h3 id="♥︎♥︎♥︎♥︎-React路由懒加载的实现"><a href="#♥︎♥︎♥︎♥︎-React路由懒加载的实现" class="headerlink" title="♥︎♥︎♥︎♥︎ React路由懒加载的实现"></a>♥︎♥︎♥︎♥︎ React路由懒加载的实现</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>webpack代码分割</p>
<p>React利用 React.lazy与import()实现了渲染时的动态加载</p>
<p>利用Suspense来处理异步加载资源时页面应该如何显示的问题</p>
<h4 id="1-React-lazy"><a href="#1-React-lazy" class="headerlink" title="1.React.lazy"></a>1.React.lazy</h4><p>通过lazy() api来动态import需要懒加载的组件</p>
<p>import的组件目前只支持export default的形式导出</p>
<p>Suspense来包裹懒加载的组件进行加载，可以设置fallback现实加载中效果</p>
<p>React.lazy可以结合Router来对模块进行懒加载。</p>
<pre><code class="react">import &#123; BrowserRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;;
import &#123; Suspense, lazy &#125; from &#39;react&#39;;
const Home = lazy(() =&gt; import(&#39;./routes/Home&#39;))
const AnyComponent = lazy(() =&gt; import(&#39;./routes/AnyComponent&#39;))
...
return (
 &lt;Suspense fallback=&#123;
Loading...
&#125;&gt; ...
</code></pre>
<h4 id="2-react-loadable"><a href="#2-react-loadable" class="headerlink" title="2.react-loadable"></a>2.react-loadable</h4><p>react-loadable是以组件级别来分割代码的，这意味着，我们不仅可以根据路由按需加载，还可以根据组件按需加载，使用方式和路由分割一样，只用修改组件的引入方式即可</p>
<pre><code class="react">// 路由懒加载（异步组件）
import Loadable from &#39;react-loadable&#39;;
//通用过场组件
const LoadingComponent = () =&gt; &#123;
 return (
loading
) &#125; ... export default (loader, loading=LoadingComponent) =&gt; &#123; return Loadable(&#123; loader, loading &#125;) &#125;
//Route中调用
import &#123; BrowserRouter, Route &#125; from &#39;react-router-dom&#39;
const loadable from &#39;./loadable&#39;;
const AnyComponent = loadable(() =&gt; import(&#39;./AnyComponent&#39;))
const Routes = () =&gt; (
);
export default Routes;
</code></pre>
<p>以下是老版中的方法</p>
<h4 id="3-webpack配置中使用lazyload-loader"><a href="#3-webpack配置中使用lazyload-loader" class="headerlink" title="3.webpack配置中使用lazyload-loader"></a>3.webpack配置中使用lazyload-loader</h4><pre><code class="react">// webpack 配置中
module: &#123;
 rules: [
 &#123;
 test: /.(js|jsx)$/,,
 use: [
 &#39;babel-loader&#39;,
 &#39;lazyload-loader&#39;
 ]
&#125;,
// 业务代码中
// 使用lazy! 前缀 代表需要懒加载的Router
 import Shop from &#39;lazy!./src/view/Shop&#39;;
 // Router 正常使用
</code></pre>
<h4 id="4-import-webpack-v2"><a href="#4-import-webpack-v2" class="headerlink" title="4.import() webpack v2+"></a>4.import() webpack v2+</h4><p>符合ECMAScript提议的import()语法，该提案与普通 import 语句或 require 函数的类似，但返回一个 Promise 对象</p>
<pre><code class="react">function component() &#123;
 return import( /* webpackChunkName: &quot;lodash&quot; / &#39;lodash&#39;).then(_ =&gt; &#123;
 var element = document.createElement(&#39;div&#39;);
 element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;);
 return element;
 &#125;).catch(error =&gt; &#39;An error occurred while loading the component&#39;);
&#125;
// 或者使用async
async function getComponent() &#123;
 var element = document.createElement(&#39;div&#39;);
 const _ = await import(/ webpackChunkName: &quot;lodash&quot; */ &#39;lodash&#39;);
 element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;);
 return element;
&#125;
</code></pre>
<h4 id="5-requre-ensure-webpack-v1-v2"><a href="#5-requre-ensure-webpack-v1-v2" class="headerlink" title="5.requre.ensure webpack v1 v2"></a>5.requre.ensure webpack v1 v2</h4><pre><code class="react">require.ensure([], function(require)&#123;
 var list = require(&#39;./list&#39;);
 list.show();
，&#39;list&#39;);
const Foo = require.ensure([], () =&gt; &#123;
 require(&quot;Foo&quot;);
&#125;, err =&gt; &#123;
 console.error(&quot;We failed to load chunk: &quot; + err);
&#125;, &quot;chunk-name&quot;);
//react-router2 or 3
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎-React-router-dom内部是怎么样实现的，怎么做路由守卫？"><a href="#♥︎♥︎♥︎♥︎-React-router-dom内部是怎么样实现的，怎么做路由守卫？" class="headerlink" title="♥︎♥︎♥︎♥︎ React-router-dom内部是怎么样实现的，怎么做路由守卫？"></a>♥︎♥︎♥︎♥︎ React-router-dom内部是怎么样实现的，怎么做路由守卫？</h3><p>1、总</p>
<p>react-router-dom利用了Context API，通过上下文对象将当前路由信息对象注入到 Router 组件中，所以 Router组件中 render() 渲染的内容就是 ContextAPI 提供的 Provider 组件，然后接收 Router 组件中的当前路由信息对象。 这样 Router 组件下的所有组件都能通过上下文拿到当前路由信息对象，即其中的Switch 、 Route 、 Link 、Redirect 等组件都可以拿到当前路由信息对象，然后通过改变当前路由信息来实现动态切换 Route 组件的渲染。</p>
<p>2、分</p>
<p>RouterContext：react-router使用context实现跨组件间数据传递，所以react-router定义了一个routerContext作为数据源，</p>
<p>Router：BrowserRouter和HashRouter将当前路由注入到上下文中，同时路由信息包含location、match、history</p>
<p>Route：路由规则，获取RouterContext的信息(location对象)，获取path和component属性，判断path和当前的location是否匹配，如果匹配，则渲染component，否则返回null，不渲染任何内容</p>
<p>Switch：遍历所有子元素(Route)，判断Route的path和location是否匹配，如果匹配，则渲染，否则不渲染</p>
<p>Redireact：未能配则重定向到指定页面</p>
<p>Link&#x2F;NavLink: Link组件本质就是a标签，它修改了a标签的默认行为，当点击Link时，会导航到对应的路由，导致locaiton对象的改变，出发组件的更新</p>
<p>withRouter：对传入的组件进行加强，功能就是获取routerContext上面的信息，然后作为props传给需要加强的组件</p>
<p>3、怎么做路由守卫</p>
<p>路由里设置meta元字符实现路由拦截</p>
<p>React Router 4.0之前也像vue中一样有个钩子函数 onEnter 可实现</p>
<p>ReactRouter 4.0开始自己实现如下</p>
<pre><code class="react">// routerMap.js中
import Index from &#39;./page/index&#39;
export default [
 &#123; path:&#39;/&#39;, name: &#39;App&#39;, component:Index, auth: true &#125;,
 ...
]
//入口文件 app.js中
import &#123; BrowserRouter as Router, Switch &#125; from &quot;react-router-dom&quot;;
import FrontendAuth from &quot;./FrontendAuth&quot;;
import routerMap from &quot;./routerMap&quot;;
...
return (
 
 
)
// 高阶组件FrontendAuth 处理路由跳转，即路由守卫功能
//FrontendAuth.js
import React, &#123; Component &#125; from &quot;react&quot;;
import &#123; Route, Redirect &#125; from &quot;react-router-dom&quot;;
class FrontendAuth extends Component &#123;
 // eslint-disable-next-line no-useless-constructor
 constructor(props) &#123;
 super(props);
 &#125;
 render() &#123;
 const &#123; routerConfig, location &#125; = this.props;
 const &#123; pathname &#125; = location;
 const isLogin = sessionStorage.getItem(&quot;username&quot;);
 console.log(pathname, isLogin);
 console.log(location);
 // 如果该路由不用进行权限校验，登录状态下登陆页除外
 // 因为登陆后，无法跳转到登陆页
 // 这部分代码，是为了在非登陆状态下，访问不需要权限校验的路由
 const targetRouterConfig = routerConfig.find(
 (item) =&gt; item.path === pathname
 );
 console.log(targetRouterConfig);
 if (targetRouterConfig &amp;&amp; !targetRouterConfig.auth &amp;&amp; !isLogin) &#123;
 const &#123; component &#125; = targetRouterConfig;
 return ;
 &#125;
 if (isLogin) &#123;
 // 如果是登陆状态，想要跳转到登陆，重定向到主页
 if (pathname === &quot;/login&quot;) &#123;
 return ;
 &#125; else &#123;
 // 如果路由合法，就跳转到相应的路由
 if (targetRouterConfig) &#123;
 return (
 
 );
 &#125; else &#123;
 // 如果路由不合法，重定向到 404 页面
 return ;
 &#125;
 &#125;
 &#125; else &#123;
 // 非登陆状态下，当路由合法时且需要权限校验时，跳转到登陆页面，要求登陆
 if (targetRouterConfig &amp;&amp; targetRouterConfig.auth) &#123;
 return ;
 &#125; else &#123;
 // 非登陆状态下，路由不合法时，重定向至 404
 return ;
 &#125;
 &#125;
 &#125;
&#125;
export default FrontendAuth;
</code></pre>
<p>总结一下，实现路由守卫需要考虑到以下的问题：</p>
<p>未登录情况下，访问不需要权限校验的合法页面：允许访问</p>
<p>未登录情况下，访问需要权限校验的页面：禁止访问，跳转至登陆页</p>
<p>未登录情况下，访问所有的非法页面：禁止访问，跳转至 404</p>
<p>登陆情况下，访问登陆页面：禁止访问，跳转至主页</p>
<p>登陆情况下，访问除登陆页以外的合法页面：允许访问</p>
<p>登陆情况下，访问所有的非法页面：禁止访问，跳转至 404</p>
<h3 id="♥︎♥︎♥︎♥︎-redux中sages和thunk中间件的区别，优缺点"><a href="#♥︎♥︎♥︎♥︎-redux中sages和thunk中间件的区别，优缺点" class="headerlink" title="♥︎♥︎♥︎♥︎ redux中sages和thunk中间件的区别，优缺点"></a>♥︎♥︎♥︎♥︎ redux中sages和thunk中间件的区别，优缺点</h3><p>1、区别</p>
<ul>
<li>redux-thunk异步采取 async&#x2F;await </li>
<li>redux-saga采取generate函数</li>
</ul>
<p>2、优缺点</p>
<p>redux-thunk</p>
<ul>
<li>优点： 库小，代码就几行 </li>
<li>缺点：代码臃肿，reducer不再是纯粹函数，直接返回对象，违背了当初的设计原则；action的形式不统一，异步操作太为分散，分散在了各个action中</li>
</ul>
<p>redux-saga</p>
<ul>
<li>优点： 将异步与reducer区分开了，更加优雅，适合大量APi请求，而且每个请求之间存在复杂的依赖关系</li>
<li>缺点：学习曲线比较陡，理解async await；而且库也比较大，即使发布的最小也有25kb,gzip压缩后也有7KB,React压缩后才45kb</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎-React复用组件的状态和增强功能的方法"><a href="#♥︎♥︎♥︎♥︎-React复用组件的状态和增强功能的方法" class="headerlink" title="♥︎♥︎♥︎♥︎  React复用组件的状态和增强功能的方法"></a>♥︎♥︎♥︎♥︎  React复用组件的状态和增强功能的方法</h3><ul>
<li>render props模式</li>
<li>高阶组件（HOC）</li>
</ul>
<p>注意：以上两种方式不是新的API，而是演化而成的一种固定模式（写法)</p>
<ul>
<li><p>思路：将要复用的state和操作state的方法封装在一个组件里面（在组件中提供复用的状态逻辑代码，即状态和操作状态的方法）</p>
</li>
<li><p>这时，我们就要思考两个问题：（1）状态是组件内部私有的，那么如何在复用组件的时候拿到组件内部的state呢？—-&gt; 可以在使用组件的时候，添加一个值为函数的props，那么就可以通过函数参数来获取组件内部的state。（2）复用组件时，需要渲染的UI结构会不一样，那么怎么在复用组件时实现渲染任意的UI呢？—–&gt;将函数的返回值作为要渲染的UI</p>
</li>
<li><p>注意：复用的组件并没有渲染任何的UI结构，而且通过函数的返回值来渲染的。</p>
<p>以下通过一个简单的例子来演示使用render props模式实现的组件复用（一个效果是随着鼠标移动，获取鼠标的位置，另一个效果是图片随着鼠标移动而移动，这两个效果的实现都要获取x和y坐标，所以可以考虑用组件的复用来实现）</p>
</li>
</ul>
<p>Mouse组件（要复用的组件）</p>
<pre><code class="react">import React from &quot;react&quot;;
class Mouse extends React.Component &#123;
    //复用的state
    state = &#123;
        x: 0,
        y: 0
    &#125;
    //操作state的方法
    handleMouseMove = e =&gt; &#123;
        this.setState(&#123;
            x: e.clientX,
            y: e.clientY
        &#125;)
    &#125;
    //监听鼠标移动事件
    componentDidMount() &#123;
        window.addEventListener(&quot;mousemove&quot;, this.handleMouseMove)
    &#125;
    render()&#123;
        return this.props.render(this.state)   //通过函数参数暴露组件内部的状态
    &#125;
&#125;
export default Mouse;
</code></pre>
<p>Mouse_Tree组件（复用Mouse组件的组件）</p>
<pre><code class="react">import React from &quot;react&quot;;
import Mouse from &quot;./Mouse.js&quot;;
import img from &quot;./images/tree.PNG&quot;

class Mouse_Cat extends React.Component &#123;
    render()&#123;
        return(
            &lt;div&gt;
                &lt;Mouse render=&#123; mouse =&gt; &#123;
                    return(
                        &lt;p&gt;X坐标为：&#123;mouse.x&#125; Y坐标为：&#123;mouse.y&#125;&lt;/p&gt;
                    )
                &#125;&#125;/&gt;  
                &lt;Mouse render=&#123; mouse =&gt; &#123;
                    return(
                        &lt;img src=&#123;img&#125; alt=&quot;树&quot; style=&#123;&#123;
                            position: 'absolute',
                            top: mouse.y,
                            left: mouse.x
                        &#125;&#125;/&gt;
                    )
                &#125;&#125;/&gt;    
            &lt;/div&gt;
        )
    &#125;
&#125;
export default Mouse_Cat;
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎♥︎♥︎-React有哪些性能优化的手段？"><a href="#♥︎♥︎♥︎♥︎♥︎-React有哪些性能优化的手段？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ React有哪些性能优化的手段？"></a>♥︎♥︎♥︎♥︎♥︎ React有哪些性能优化的手段？</h3><p> 1、使用纯组件；</p>
<p> 2、使用 React.memo 进行组件记忆（React.memo 是一个高阶组件），对于相同的输入，不重复执行；</p>
<p> 3、如果是类组件，使用 shouldComponentUpdate（这是在重新渲染组件之前触发的其中一个生命周期事件）生命周期事件，可以利用此事件来决定何时需要重新渲染组件；</p>
<p> 4、路由懒加载；</p>
<p> 5、使用 React Fragments 避免额外标记；</p>
<p> 6、不要使用内联函数定义（如果我们使用内联函数，则每次调用“render”函数时都会创建一个新的函数实例）；</p>
<p> 7、避免在Willxxx系列的生命周期中进行异步请求，操作dom等；</p>
<p> 8、如果是类组件，事件函数在Constructor中绑定bind改变this指向；</p>
<p> 9、避免使用内联样式属性；</p>
<p> 10、优化 React 中的条件渲染；</p>
<p> 11、不要在 render 方法中导出数据；</p>
<p> 12、列表渲染的时候加key；</p>
<p> 13、在函数组件中使用useCallback和useMemo来进行组件优化，依赖没有变化的话，不重复执行；</p>
<p> 14、类组件中使用immutable对象；</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-调用this-setState之后，React都做了哪些操作？怎么拿到改变后的值？"><a href="#♥︎♥︎♥︎♥︎♥︎-调用this-setState之后，React都做了哪些操作？怎么拿到改变后的值？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 调用this.setState之后，React都做了哪些操作？怎么拿到改变后的值？"></a>♥︎♥︎♥︎♥︎♥︎ 调用this.setState之后，React都做了哪些操作？怎么拿到改变后的值？</h3><p>如果是在隶属于原生js执行的空间，比如说setTimeout里面，setState是同步的，那么每次执行setState将立即更新this.state，然后触发render方法；因为是同步执行，可以直接获取改变后的值；</p>
<p> 如果是在被react处理过的空间执行，比如说合成事件里，此时setState是异步执行的，并不会立即更新this.state的值，当执行setState的时候，会将需要更新的state放入状态队列，在这个空间最后再合并修改this.state，触发render；setState接受第二个参数，是一个回调函数，可以在这里获取改变后的state值；</p>
<p> 触发render执行后，会生成一个新的虚拟dom结构，然后触发diff运算，找到变化的地方，重新渲染； </p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-什么是-React-Fiber"><a href="#♥︎♥︎♥︎♥︎♥︎-什么是-React-Fiber" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 什么是 React Fiber?"></a>♥︎♥︎♥︎♥︎♥︎ 什么是 React Fiber?</h3><h4 id="React-Fiber-En"><a href="#React-Fiber-En" class="headerlink" title="React Fiber En"></a>React Fiber En</h4><p>Fiber是React16中新的协调引擎，它的主要目的是使Virtual DOM可以进行增量式渲染，让界面渲染更流畅一种流程控制原语，也称为协程，可以类比es6中的generator函数；React渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</p>
<p>一个执行单元，每次执行完一个“执行单元”，React就会检查现在还剩多少时间，如果没有时间就将控制权让出去。</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>把可中断的工作拆分成小任务</li>
<li>对正在做的工作调整优先次序、重做、复用上次（做了一半的）成果</li>
<li>在父子任务之间从容切换（yield back and forth），以支持React执行过程中的布局刷新</li>
<li>支持render()返回多个元素</li>
<li>更好地支持error boundary</li>
</ul>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>增量渲染（把渲染任务拆分成块，匀到多帧）</li>
<li>更新时能够暂停，终止，复用渲染任务</li>
<li>给不同类型的更新赋予优先级</li>
<li>并发方面新的基础能力</li>
</ul>
<h3 id="♥︎♥︎♥︎♥︎♥︎-简述一下-memoization"><a href="#♥︎♥︎♥︎♥︎♥︎-简述一下-memoization" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 简述一下 memoization"></a>♥︎♥︎♥︎♥︎♥︎ 简述一下 memoization</h3><p>memoization最初是用来优化计算机程序使之计算的更快的技术，是通过存储调用函数的结果并且在同样参数传进来的时候返回结果。大部分应该是在递归函数中使用。memoization 是一种优化技术，避免一些不必要的重复计算，可以提高计算速度。</p>
<p>以阶乘函数为例：</p>
<h4 id="1-不使用memoization"><a href="#1-不使用memoization" class="headerlink" title="1.不使用memoization"></a>1.不使用memoization</h4><pre><code class="javascript">const factorial = n =&gt; &#123;
  if (n === 1) &#123;
    return 1
  &#125; else &#123;
    return factorial(n - 1) * n
  &#125;
&#125;
</code></pre>
<h4 id="2-使用memoization"><a href="#2-使用memoization" class="headerlink" title="2.使用memoization"></a>2.使用memoization</h4><pre><code class="javascript">const cache = [] // 定义一个空的存放缓存的数组
const factorial = n =&gt; &#123;
  if (n === 1) &#123;
    return 1
  &#125; else if (cache[n - 1]) &#123; // 先从cache数组里查询结果，如果没找到的话再计算
    return cache[n - 1]
  &#125; else &#123;
    let result = factorial(n - 1) * n
    cache[n - 1] = result
    return result
  &#125;
&#125;
</code></pre>
<h4 id="3-搭配闭包使用memoization"><a href="#3-搭配闭包使用memoization" class="headerlink" title="3.搭配闭包使用memoization"></a>3.搭配闭包使用memoization</h4><pre><code class="javascript">const factorialMemo = () =&gt; &#123;
  const cache = []
  const factorial = n =&gt; &#123;
    if (n === 1) &#123;
      return 1
    &#125; else if (cache[n - 1]) &#123;
      console.log(`get factorial($&#123;n&#125;) from cache...`)
      return cache[n - 1]
    &#125; else &#123;
      let result = factorial(n - 1) * n
      cache[n - 1] = result
      return result
    &#125;
  &#125;
  return factorial
&#125;
const factorial = factorialMemo()
</code></pre>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>memorization 可以把函数每次的返回值存在一个数组或者对象中，在接下来的计算中可以直接读取已经计算过并且返回的数据，不用重复多次相同的计算。是一个空间换时间的方式，这种方法可用于部分递归中以提高递归的效率。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-自定义hooks（重点❗️❗️❗️）"><a href="#♥︎♥︎♥︎♥︎♥︎-自定义hooks（重点❗️❗️❗️）" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ 自定义hooks（重点❗️❗️❗️）"></a>♥︎♥︎♥︎♥︎♥︎ 自定义hooks（重点❗️❗️❗️）</h3><p>[实现自定义hooks案例]: 	“<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904074433789959">https://juejin.cn/post/6844904074433789959</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全Vue-Vue3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8Vue-Vue3/"
    >前端面试大全Vue-Vue3</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8Vue-Vue3/" class="article-date">
  <time datetime="2022-10-28T03:50:56.000Z" itemprop="datePublished">2022-10-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/Vue-Vue3/">Vue-Vue3</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（Vue-Vue3）"><a href="#前端面试题大全（Vue-Vue3）" class="headerlink" title="前端面试题大全（Vue + Vue3）"></a>前端面试题大全（Vue + Vue3）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="Vue-Vue3"><a href="#Vue-Vue3" class="headerlink" title="Vue + Vue3"></a>Vue + Vue3</h2><h3 id="♥︎♥︎vue-router-3-1-0新增的v-slot属性怎么用？"><a href="#♥︎♥︎vue-router-3-1-0新增的v-slot属性怎么用？" class="headerlink" title="♥︎♥︎vue-router 3.1.0新增的v-slot属性怎么用？"></a>♥︎♥︎vue-router 3.1.0新增的v-slot属性怎么用？</h3><p>router-link 通过一个作用域插槽暴露底层的定制能力。这是一个更高阶的 API，主要面向库作者，但也可以为开发者提供便利，多数情况用在一个类似 NavLink 这样的自定义组件里。</p>
<p>在使用 v-slot API 时，需要向 router-link 传入一个单独的子元素。否则 router-link 将会把子元素包裹在一个 span 元素内。</p>
<h3 id="♥︎♥︎说一下-root，-parent，-refs"><a href="#♥︎♥︎说一下-root，-parent，-refs" class="headerlink" title="♥︎♥︎说一下$root，$parent，$refs"></a>♥︎♥︎说一下$root，$parent，$refs</h3><p>$root，和$parent都能访问父组件的属性和方法，区别在于如果存在多级子组件，通过parent 访问得到的是它最近一级的父组件，通过root 访问得到的是根父组件。</p>
<p>通过在子组件标签定义 ref 属性，在父组件中可以使用$refs 访问子组件实例。</p>
<h3 id="♥︎♥︎对比-jQuery，Vue-有什么不同"><a href="#♥︎♥︎对比-jQuery，Vue-有什么不同" class="headerlink" title="♥︎♥︎对比 jQuery，Vue 有什么不同"></a>♥︎♥︎对比 jQuery，Vue 有什么不同</h3><p>jQuery 专注视图层，通过直接操作 DOM 去实现页面的一些逻辑渲染；</p>
<p>Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作。</p>
<p>Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发</p>
<h3 id="♥︎♥︎-Vue中如何实现子组件内的css样式名在项目中绝对唯一性"><a href="#♥︎♥︎-Vue中如何实现子组件内的css样式名在项目中绝对唯一性" class="headerlink" title="♥︎♥︎ Vue中如何实现子组件内的css样式名在项目中绝对唯一性"></a>♥︎♥︎ Vue中如何实现子组件内的css样式名在项目中绝对唯一性</h3><p>在style标签上加上scoped属性</p>
<h3 id="♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？"><a href="#♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？" class="headerlink" title="♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？"></a>♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？</h3><p>v-model是一个语法糖，这一个指令可以分为几个指令，它内部已经帮我们处理整合了。对于普通的文本框来说，v-model &#x3D; v-bind:value + @input。对单选框和复选框来说，v-model &#x3D; v-bind:checked +@change，并且它还有一个非常重要的功能，就是解决父子组件之间的通讯问题，可以提升我们的开发效率。在vue中通过使用&lt;v-on:事件名 &#x3D; 函数名&gt;的方式来绑定事件。</p>
<h3 id="♥︎♥︎Vue生命周期通常使用哪些"><a href="#♥︎♥︎Vue生命周期通常使用哪些" class="headerlink" title="♥︎♥︎Vue生命周期通常使用哪些"></a>♥︎♥︎Vue生命周期通常使用哪些</h3><p>常用的生命周期有，beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed</p>
<h3 id="♥︎♥︎Vue深层次的组件怎么和父组件通讯"><a href="#♥︎♥︎Vue深层次的组件怎么和父组件通讯" class="headerlink" title="♥︎♥︎Vue深层次的组件怎么和父组件通讯"></a>♥︎♥︎Vue深层次的组件怎么和父组件通讯</h3><p>使用$attrs和$listeners</p>
<pre><code class="vue">//C
Vue.component(&#39;C&#39;, &#123;
 template: &lt;div&gt; &lt;p&gt;我是C组件&lt;/p&gt; &lt;input type=&#39;text&#39; v-model=&#39;$attrs.msgc&#39; @input=&#39;$emit(&quot;getC&quot;, $attrs.msgc)&#39; /&gt; &lt;/div&gt;
&#125;)

//B
Vue.component(&#39;B&#39;, &#123;
 /**
 给C组件绑定$attrs属性和$listeners事件，C组件可以直接获取到A组件中传递下来的props（除了B组
件中props声明的）
 */
 template: &lt;div&gt; &lt;p&gt;我是B组件&lt;/p&gt; &lt;input type=&#39;text&#39; v-model=&#39;mymsg1&#39; @input=&quot;$emit(&#39;getChild&#39;, mymsg1)&quot; /&gt;&lt;C v-bind=&#39;$attrs&#39; v-on=&#39;$listeners&#39;/&gt; &lt;/div&gt; ,
 props: [&#39;msg1&#39;],
 data () &#123;
 return &#123;
 mymsg1: this.msg1
 &#125;
 &#125;
&#125;)

Vue.component(&#39;A&#39;, &#123;
 template: &lt;div id=&#39;app&#39;&gt; &lt;p&gt;我是A组件&lt;/p&gt; &lt;B:msg1=&#39;msg1&#39; :msgc=&#39;msgc&#39; @getChild=&#39;getChild&#39; @getC=&#39;getC&#39; /&gt; &lt;/div&gt; ,
 data () &#123;
 return &#123;
 msg1: &#39;A&#39;,
 msgc: &#39;hello c!&#39;
 &#125;
 &#125;,
 methods: &#123;
 getChild (val) &#123;
 console.log( val )
 &#125;,
 getC (val) &#123;
 console.log( val )
 &#125;
 &#125;
&#125;)
const app = new Vue(&#123;
 el: &#39;#app&#39;,
 template: &lt;A /&gt;
&#125;)
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？"><a href="#♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？" class="headerlink" title="♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？"></a>♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？</h3><p>在style标签上不加上scoped的属性，默认为全局css样式</p>
<h3 id="♥︎♥︎♥︎如何实现一个路径渲染多个组件？"><a href="#♥︎♥︎♥︎如何实现一个路径渲染多个组件？" class="headerlink" title="♥︎♥︎♥︎如何实现一个路径渲染多个组件？"></a>♥︎♥︎♥︎如何实现一个路径渲染多个组件？</h3><p>可以通过命名视图(router-view)，它容许同一界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。通过设置components即可同时渲染多个组件。</p>
<h3 id="♥︎♥︎♥︎-如何实现多个路径共享一个组件？"><a href="#♥︎♥︎♥︎-如何实现多个路径共享一个组件？" class="headerlink" title="♥︎♥︎♥︎ 如何实现多个路径共享一个组件？"></a>♥︎♥︎♥︎ 如何实现多个路径共享一个组件？</h3><p>只需将多个路径的component字段的值设置为同一个组件即可。</p>
<h3 id="♥︎♥︎♥︎如何监测动态路由的变化"><a href="#♥︎♥︎♥︎如何监测动态路由的变化" class="headerlink" title="♥︎♥︎♥︎如何监测动态路由的变化"></a>♥︎♥︎♥︎如何监测动态路由的变化</h3><p>可以通过watch方法来对$route进行监听，或者通过导航守卫的钩子函数beforeRouteUpdate来监听它的变化。</p>
<h3 id="♥︎♥︎♥︎对MVC，MVP，MVVM的理解"><a href="#♥︎♥︎♥︎对MVC，MVP，MVVM的理解" class="headerlink" title="♥︎♥︎♥︎对MVC，MVP，MVVM的理解"></a>♥︎♥︎♥︎对MVC，MVP，MVVM的理解</h3><p>mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。</p>
<p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。</p>
<p>1：Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>
<p>2：在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>
<p>3：ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<p>MVP与MVC很接近，P指的是Presenter，presenter可以理解为一个中间人，它负责着View和Model之间的数据流动，防止View和Model之间直接交流。</p>
<p><img src="/2022/10/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8Vue-Vue3/2021022520492697.png" alt="MVP"></p>
<p>presenter负责和Model进行双向交互，还和View进行双向交互。这种交互方式，相对于MVC来说少了一些灵活，Vlew变成了被动视图，并且本身变得很小。虽然它分离了View和Model。但是presenter除了要做事件监听，还要更新DOM等各种事情，应用逐渐变大之后，导致presenter的体积增大，难以维护。</p>
<h3 id="♥︎♥︎♥︎什么情况下使用-Vuex"><a href="#♥︎♥︎♥︎什么情况下使用-Vuex" class="headerlink" title="♥︎♥︎♥︎什么情况下使用 Vuex"></a>♥︎♥︎♥︎<strong>什么情况下使用</strong> Vuex</h3><p>如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可，需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态</p>
<h3 id="♥︎♥︎♥︎Vuex可以直接修改state的值吗？"><a href="#♥︎♥︎♥︎Vuex可以直接修改state的值吗？" class="headerlink" title="♥︎♥︎♥︎Vuex可以直接修改state的值吗？"></a>♥︎♥︎♥︎Vuex可以直接修改state的值吗？</h3><p>可以直接修改，但是极其不推荐，state的修改必须在mutation来修改，否则无法被devtool所监测，无法监测数据的来源，无法保存状态快照，也就无法实现时间漫游&#x2F;回滚之类的操作。</p>
<h3 id="♥︎♥︎♥︎v-model和vuex有冲突吗？"><a href="#♥︎♥︎♥︎v-model和vuex有冲突吗？" class="headerlink" title="♥︎♥︎♥︎v-model和vuex有冲突吗？"></a>♥︎♥︎♥︎v-model和vuex有冲突吗？</h3><p>当我们v-model的数据是存储在vuex中时写法如下时会报错</p>
<pre><code class="javascript">computed:&#123;
  editableTabsValue2:&#123;
     return this.$store.state.activeName
  &#125;
&#125;
</code></pre>
<p>报错：Computed property  “editableTabsValue2”  was assigned  to but  it has no  setter</p>
<p>原因：v-model是双向数据绑定 vue实例的data改变或者用户输入的改变都会触发视图更新。vuex是一个状态的存储，对于里面的状态的改变都是通过commit mutation 所以当用户输入直接修改editableTabsValue2,又不是通过commit更改状态时会报错</p>
<p>解决方法:</p>
<pre><code class="javascript">computed:&#123;
  editableTabsValue2:&#123;
    get:function () &#123;
      return this.$store.state.activeName
    &#125;,
    set:function () &#123;
    &#125;
  &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎解释单向数据流和双向数据绑定"><a href="#♥︎♥︎♥︎解释单向数据流和双向数据绑定" class="headerlink" title="♥︎♥︎♥︎解释单向数据流和双向数据绑定"></a>♥︎♥︎♥︎解释单向数据流和双向数据绑定</h3><p>对于 Vue 来说，组件之间的数据传递具有单向数据流这样的特性称为单向数据流，单向数据流（Unidirectional data flow）方式使用一个上传数据流和一个下传数据流进行双向数据通信，两个数据流之间相互独立，单向数据流指只能从一个方向来修改状态。</p>
<p>而双向数据绑定即为当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化，两个数据流之间互为影响。</p>
<h3 id="♥︎♥︎♥︎-route和-router的区别"><a href="#♥︎♥︎♥︎-route和-router的区别" class="headerlink" title="♥︎♥︎♥︎$route和 $router的区别"></a>♥︎♥︎♥︎$route和 $router的区别</h3><p>$route用来获取路由的信息的，它是路由信息的一个对象，里面包含路由的一些基本信息，包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom等。</p>
<p>而$router主要是用来操作路由的，它是VueRouter的实例，包含了一些路由的跳转方法，钩子函数等</p>
<h3 id="♥︎♥︎♥︎Vue-中怎么自定义指令"><a href="#♥︎♥︎♥︎Vue-中怎么自定义指令" class="headerlink" title="♥︎♥︎♥︎Vue 中怎么自定义指令"></a>♥︎♥︎♥︎Vue <strong>中怎么自定义指令</strong></h3><p>通过directive来自定义指令，自定义指令分为全局指令和局部指令，自定义指令也有几个的钩子函数，常用的有bind和update，当 bind 和 update 时触发相同行为，而不关心其它的钩子时可以简写。一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右。</p>
<h3 id="♥︎♥︎♥︎Vue中怎么自定义过滤器"><a href="#♥︎♥︎♥︎Vue中怎么自定义过滤器" class="headerlink" title="♥︎♥︎♥︎Vue中怎么自定义过滤器"></a>♥︎♥︎♥︎Vue中怎么自定义过滤器</h3><p>通过filter来定义过滤器，过滤器分为全局和局部过滤器，过滤器的主体为一个普通的函数，来对数据进行处理，可以传递参数。当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用。</p>
<h3 id="♥︎♥︎♥︎Vue等单页面应用的优缺点"><a href="#♥︎♥︎♥︎Vue等单页面应用的优缺点" class="headerlink" title="♥︎♥︎♥︎Vue等单页面应用的优缺点"></a>♥︎♥︎♥︎Vue等单页面应用的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、单页应用的内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。</p>
<p>2、单页应用没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象</p>
<p>3、单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提</p>
<p>高几倍。</p>
<p>4、良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代</p>
<p>码，不用修改就可以用于Web界面、手机、平板等多种客户端。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1、首次加载耗时比较多。</p>
<p>2、SEO问题，不利于百度，360等搜索引擎收录。</p>
<p>3、容易造成Css命名冲突。</p>
<p>4、前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开</p>
<p>发成本高。</p>
<h3 id="♥︎♥︎♥︎Vue-router使用params与query传参有什么区别"><a href="#♥︎♥︎♥︎Vue-router使用params与query传参有什么区别" class="headerlink" title="♥︎♥︎♥︎Vue-router使用params与query传参有什么区别"></a>♥︎♥︎♥︎Vue-router使用params与query传参有什么区别</h3><p>&#x2F;&#x2F; 用法上</p>
<p>query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和this.$route.params.name。</p>
<p>&#x2F;&#x2F; 展示上</p>
<p>1：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p>
<p>2：params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。</p>
<p>3：params、query不设置也可以传参，params不设置的时候，刷新页面或者返回参数会丢失</p>
<h3 id="♥︎♥︎♥︎Vue中keep-alive的作用"><a href="#♥︎♥︎♥︎Vue中keep-alive的作用" class="headerlink" title="♥︎♥︎♥︎Vue中keep-alive的作用"></a>♥︎♥︎♥︎Vue中keep-alive的作用</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。一旦使用keepalive包裹组件，此时mouted，created等钩子函数只会在第一次进入组件时调用，当再次切换回来时将不会调用。此时如果我们还想在每次切换时做一些事情，就需要用到另外的周期函数，actived和deactived，这两个钩子函数只有被keepalive包裹后才会调用。</p>
<h3 id="♥︎♥︎♥︎Vue如何实现单页面应用"><a href="#♥︎♥︎♥︎Vue如何实现单页面应用" class="headerlink" title="♥︎♥︎♥︎Vue如何实现单页面应用"></a>♥︎♥︎♥︎Vue如何实现单页面应用</h3><p>通常的url 地址由以下内容构成：协议名 域名 端口号 路径 参数 哈希值，当哈希值改变，页面不会发生跳转，单页面应用就是利用了这一点，给window注册onhashchange事件，当哈希值改变时通过location.hash就能获得相应的哈希值，然后就能跳到相应的页面。</p>
<h3 id="♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？"><a href="#♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？" class="headerlink" title="♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？"></a>♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？</h3><pre><code class="css">v-if(判断是否隐藏，用来判断元素是否创建)
v-show(元素的显示隐藏，类似css中的display的block和hidden)
v-for(把数据遍历出来)
v-bind(绑定属性)
v-model(实现双向绑定)
</code></pre>
<h3 id="♥︎♥︎♥︎-Vuex是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#♥︎♥︎♥︎-Vuex是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="♥︎♥︎♥︎ Vuex是什么？怎么使用？描述使用它实现登录功能的流程？"></a>♥︎♥︎♥︎ Vuex是什么？怎么使用？描述使用它实现登录功能的流程？</h3><p>Vuex是一个专为Vue.js应用程序开发的状态管理模式；它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex可以管理复杂应用的数据状态，比如兄弟组件的通信、多层嵌套的组件的传值等等。</p>
<p>如何使用</p>
<pre><code class="css">1.安装vuex
按照官网给出的步骤
npm install vuex --save  //安装vuex

2.Vuex 依赖 Promise  浏览器支持promise的此步骤可省略
注意：Vuex 依赖 Promise (opens new window)。如果你支持的浏览器并没有实现 Promise (比如 IE)，那么你可以使用一个 polyfill 的库，例如 es6-promise (opens new window)。

你可以通过 CDN 将其引入：
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js&quot;&gt;
&lt;/script&gt;
然后 window.Promise 会自动可用。
如果你喜欢使用诸如 npm 或 Yarn 等包管理器，可以按照下列方式执行安装：
npm install es6-promise --save # npm
yarn add es6-promise # Yarn
或者更进一步，将下列代码添加到你使用 Vuex 之前的一个地方：
import &#39;es6-promise/auto&#39;

3.在项目引用
找到项目中的main.js文件，将内容引入
import store from &#39;./store&#39;
.use(store)
</code></pre>
<p>4.使用方法<br>    首先，在项目中找到store文件夹，如果没有就自己建一个文件夹，在文件夹内再新建一个js文件。</p>
<pre><code class="css">import &#123; createStore &#125; from &#39;vuex&#39;
 
export default createStore(&#123;
  state: &#123;  //数据存放的位置
        data:&#39;&#39;
  &#125;,
  mutations: &#123;//在mutations写方法更改state中的值
      data(state,data)&#123;
        state.data=data
   &#125;
  &#125;,
  actions: &#123;//通过actions触发mutations的方法
      dataone(context,data)&#123;
          context.commit(&#39;data&#39;,data);//带引号的data是mutation里的，第二个data，是页面上
                                      //传过来的参数
    &#125;
  &#125;,
  modules: &#123;
      
  &#125;
&#125;)
然后，将要保存的数据从页面传过来
这是页面：
import &#123;useStore&#125; from &#39;vuex&#39;
    export default&#123;
        setup()&#123;
            let A =124
            const store=useStore();
            store.dispatch(&#39;dataone&#39;,A)
              //括号内第一个参数为actions中的方法名,方法名不能与mutations中重复    
              //第二个为需要存储改变的值的变量
        &#125;
    &#125;
</code></pre>
<h3 id="♥︎♥︎♥︎Vue-loader解释一下"><a href="#♥︎♥︎♥︎Vue-loader解释一下" class="headerlink" title="♥︎♥︎♥︎Vue-loader解释一下"></a>♥︎♥︎♥︎Vue-loader解释一下</h3><p>解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。</p>
<h3 id="♥︎♥︎♥︎-用过插槽吗？用的是具名插槽还是匿名插槽"><a href="#♥︎♥︎♥︎-用过插槽吗？用的是具名插槽还是匿名插槽" class="headerlink" title="♥︎♥︎♥︎ 用过插槽吗？用的是具名插槽还是匿名插槽"></a>♥︎♥︎♥︎ 用过插槽吗？用的是具名插槽还是匿名插槽</h3><p>用过，都使用过。插槽相当于预留了一个位置，可以将我们书写在组件内的内容放入，写一个插槽就会将组件内的内容替换一次，两次则替换两次。为了自定义插槽的位置我们可以给插槽取名，它会根据插槽名来插入内容，一一对应。</p>
<h3 id="♥︎♥︎♥︎Vue路由守卫"><a href="#♥︎♥︎♥︎Vue路由守卫" class="headerlink" title="♥︎♥︎♥︎Vue路由守卫"></a>♥︎♥︎♥︎Vue路由守卫</h3><p>vue-router 提供的导航守卫主要用来对路由的跳转进行监控，控制它的跳转或取消，路由守卫有全局的,单个路由独享的, 或者组件级的。导航钩子有3个参数：</p>
<p>1、to:即将要进入的目标路由对象；</p>
<p>2、from:当前导航即将要离开的路由对象；</p>
<p>3、next ：调用该方法后，才能进入下一个钩子函数（afterEach）。</p>
<h3 id="♥︎♥︎♥︎请你说一下Vue中create和mount的区别"><a href="#♥︎♥︎♥︎请你说一下Vue中create和mount的区别" class="headerlink" title="♥︎♥︎♥︎请你说一下Vue中create和mount的区别"></a>♥︎♥︎♥︎请你说一下Vue中create和mount的区别</h3><p>create为组件初始化阶段，在此阶段主要完成数据观测(data observer)，属性和方法的运算，watch&#x2F;event 事件回调。</p>
<p>然而，挂载阶段还没开始，此时还未生成真实的DOM，也就无法获取和操作DOM元素。</p>
<p>而mount主要完成从虚拟DOM到真实DOM的转换挂载，此时html已经渲染出来了，所以可以直接操作dom节点。</p>
<h3 id="♥︎♥︎♥︎路由懒加载"><a href="#♥︎♥︎♥︎路由懒加载" class="headerlink" title="♥︎♥︎♥︎路由懒加载"></a>♥︎♥︎♥︎路由懒加载</h3><p>把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应的组件即为路由的懒加载，可以加快项目的加载速度，提高效率。通过这种格式来导入组件const foo &#x3D; () &#x3D;&gt;import(‘.&#x2F;foo.vue’);</p>
<h3 id="♥︎♥︎♥︎Vue中computed的原理"><a href="#♥︎♥︎♥︎Vue中computed的原理" class="headerlink" title="♥︎♥︎♥︎Vue中computed的原理"></a>♥︎♥︎♥︎Vue中computed的原理</h3><p>computed是vue中的计算属性，在依赖的值发生变化的时候进行重新计算，否则使用缓存。</p>
<p>前面说到computed只有在依赖发生变化才会重新计算，那么如何得知computed的值发生了变化呢</p>
<p>这主要是Watcher中的dirty属性，dirty属性为true时，说明computed中的值需要重新计算，dirty为false时，则说明依赖没有变化，不需要重新计算</p>
<p>当计算属性的值发生变化时，计算属性的watcher和组件的watcher都会得到通知。</p>
<p>计算属性的watcher会将dirty置为true,组件的Watcher得到通知，同样将dirty属性置为false,重新计算值，用于本次渲染。</p>
<p>简单来说,computed就是定义在vm上的一个getter属性，这个getter属性被触发时会做两件事</p>
<ol>
<li><p>计算当前属性的值，此时会使用Watcher去观察计算属性中用到的所有其他数据的变化。同时将计算属性的Watcher的dirty属性设置为false.</p>
</li>
<li><p>当计算属性中用到的数据发生变化时,将得到通知从而进行重新渲染</p>
</li>
</ol>
<p>Watcher中的depend和evaluate方法是专门用于实现计算属性的两个API</p>
<pre><code class="javascript">export default class Watcher &#123;
     constructor(vm, expOrFn, cb, options) &#123;
         if(options) &#123;
             this.lazy = !!options.lazy;
         &#125;  else &#123;
             this.lazy = false;
         &#125;
         this.dirty = this.lazy;
         this.value = this.lazy ? undefined : this.get()
     &#125;
     evaluate() &#123;
        this.value = this.get()
        this.dirty = false; 
    &#125;
    depend() &#123;
        let i = this.deps.length
        while(i--) &#123;
            this.deps[i].depend()
        &#125;
    &#125;
&#125;
</code></pre>
<p>执行depend方法可以将组件中的watcher实例添加到dep实例的依赖列表中。换句话说,this.deps是计算属性中用到的所有状态的dep实例,而依次执行了dep实例的depend方法就是将组件的watcher依次加入到这些dep实例的依赖列表。这就实现了让组件的watcher观察计算属性中用到的所有的状态的变化。</p>
<p>Computed逻辑变化</p>
<p>computed在vue2.5.2中的实现发生了一些变化,因为之前的computed的计算存在一些逻辑上的漏洞,因为只要依赖的值发生了变化,vue就认为值发生了变化，组件会重新走一遍渲染的流程，但实际上UI不会由变化，浪费了一些性能。</p>
<p>改动之后的逻辑：</p>
<p>组件的watcher不再监听计算属性的变化,而是让计算属性的watcher得到通知后,计算一次计算属性的值，如果发现这一次计算出来的值与上一次计算出来的值不一样，再去主动通知组件的watcher进行重新渲染。</p>
<h3 id="♥︎♥︎♥︎Vuex的缺点"><a href="#♥︎♥︎♥︎Vuex的缺点" class="headerlink" title="♥︎♥︎♥︎Vuex的缺点"></a>♥︎♥︎♥︎Vuex的缺点</h3><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的，并且state中的值会伴随着浏览器的刷新而初始化，无缓存。</p>
<h3 id="♥︎♥︎♥︎Vue路由传参，刷新后还有吗"><a href="#♥︎♥︎♥︎Vue路由传参，刷新后还有吗" class="headerlink" title="♥︎♥︎♥︎Vue路由传参，刷新后还有吗"></a>♥︎♥︎♥︎Vue路由传参，刷新后还有吗</h3><p>通过params传参会出现参数丢失的情况，可以通过query的传参方式或者在路由匹配规则加入占位符即可以解决参数丢失的情况。</p>
<h3 id="♥︎♥︎♥︎Vue组件如何引入使用"><a href="#♥︎♥︎♥︎Vue组件如何引入使用" class="headerlink" title="♥︎♥︎♥︎Vue组件如何引入使用"></a>♥︎♥︎♥︎Vue组件如何引入使用</h3><ol>
<li><p>定义组件并抛出</p>
</li>
<li><p>import引入，并在component里面定义</p>
</li>
<li><p>使用组件（注意首字母大写）</p>
</li>
</ol>
<h3 id="♥︎♥︎♥︎-Vue-forceUpdate的原理"><a href="#♥︎♥︎♥︎-Vue-forceUpdate的原理" class="headerlink" title="♥︎♥︎♥︎ Vue $forceUpdate的原理"></a>♥︎♥︎♥︎ Vue $forceUpdate的原理</h3><p>1、作用：</p>
<p>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
<p>2、内部原理：</p>
<pre><code class="javascript">Vue.prototype.$forceUpdate = function () &#123;
 const vm: Component = this
 if (vm.watcher) &#123;
 vm.watcher.update()
 &#125;
&#125;
</code></pre>
<p>实例需要重新渲染是在依赖发生变化的时候会通知watcher，然后通知watcher来调用update方法，就是这么简单。</p>
<h3 id="♥︎♥︎♥︎v-for-key"><a href="#♥︎♥︎♥︎v-for-key" class="headerlink" title="♥︎♥︎♥︎v-for key"></a>♥︎♥︎♥︎v-for key</h3><p>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</p>
<p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p>
<p>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. </p>
<p>快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1)</p>
<p>建议使用id，不建议使用索引</p>
<h3 id="♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？"><a href="#♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？" class="headerlink" title="♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？"></a>♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？</h3><p>虚拟DOM中key的作用：<br>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,<br>随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
<p>对比规则：<br>(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。<br>(2).旧虚拟DOM中未找到与新虚拟DOM相同的key<br>创建新的真实DOM，随后渲染到到页面。</p>
<p>用index作为key可能会引发的问题：<br>1.若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br>会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</p>
<p>如果结构中还包含输入类的DOM：<br>会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。</p>
<p>开发中如何选择key?:<br>1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br>使用index作为key是没有问题的。</p>
<h3 id="♥︎♥︎♥︎-Vue的虚拟dom"><a href="#♥︎♥︎♥︎-Vue的虚拟dom" class="headerlink" title="♥︎♥︎♥︎ Vue的虚拟dom"></a>♥︎♥︎♥︎ Vue的虚拟dom</h3><p>从本质来说，Virtual Dom 是一个 JavaScript 对象，通过对象的方式来表示 DOM 结构。将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次 DOM 修改的结果一次性更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p>
<p>虚拟 DOM 是对 DOM 的抽象，这个对象是更加轻量级的对 DOM 的描述。它设计的最初目的就是更好的跨平台，比如 Node.js 就没有 DOM，如果想实现 SSR，那么就只能借助虚拟 DOM，因为虚拟 DOM 本身就是 JS 对象，在代码渲染到页面之前，Vue 和 React 会把代码转化成一个对象（虚拟 DOM），以对象的形式来描述真实 DOM 结构，最终渲染到页面。在每次数据发生变化前，虚拟 DOM 都会缓存一份，变化之时，现在的虚拟 DOM 会与缓存的虚拟 DOM 进行比较。</p>
<p>Vue 和 React 内部都封装了 diff 算法用来进行比较渲染时的变化（具体 diff 算法内容后续重点分析），精准更新发生变化的节点，而没有发生变化的直接通过原先的数据进行渲染。</p>
<p>另外现代前端框架基本都要求无须手动操作 DOM，一方面是因为手动操作 DOM 无法保证程序的性能，多人协作的项目中如果 code review 不严格，很容易出现性能较低的代码，另一方面更重要的是省略手动操作 DOM 可以大大提高开发效率。</p>
<h3 id="♥︎♥︎♥︎diff复杂度原理及具体过程画图"><a href="#♥︎♥︎♥︎diff复杂度原理及具体过程画图" class="headerlink" title="♥︎♥︎♥︎diff复杂度原理及具体过程画图"></a>♥︎♥︎♥︎diff复杂度原理及具体过程画图</h3><p>diff算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。</p>
<p>diff算法有两个比较显著的特点：</p>
<p>1、比较只会在同层级进行, 不会跨层级比较。</p>
<p>2、在diff比较的过程中，循环从两边向中间收拢。</p>
<p>diff流程： 首先定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode的两边的索引。</p>
<p>接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<p>while 循环中会遇到四种情况：</p>
<p>情形一：当新老 VNode 节点的 start 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。</p>
<p>情形二：当新老 VNode 节点的 end 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。</p>
<p>情形三：当老 VNode 节点的 start 和新 VNode 节点的 end 是同一节点时，这说明这次数据更新后oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 patchVnode 后，还需要将当前真实dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1。</p>
<p>情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 是同一节点时，这说明这次数据更新后oldEndVnode 跑到了 oldStartVnode 的前面去了。这时候在 patchVnode 后，还需要将当前真实 dom节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加1。</p>
<p>while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<p>情形一：如果在循环中，oldStartIdx大于oldEndIdx了，那就表示oldChildren比newChildren先循环完毕，那么newChildren里面剩余的节点都是需要新增的节点，把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中</p>
<p>情形二：如果在循环中，newStartIdx大于newEndIdx了，那就表示newChildren比oldChildren先循环完毕，那么oldChildren里面剩余的节点都是需要删除的节点，把[oldStartIdx, oldEndIdx]之间的所有节点都删除</p>
<h3 id="♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法"><a href="#♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法" class="headerlink" title="♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法"></a>♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法</h3><ul>
<li>通过this.$store.state.属性的方法来访问状态</li>
<li>通过this.$store.commit(‘mutation中的方法’) 来修改状态</li>
</ul>
<pre><code class="javascript">// App.vue
&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;
    &lt;button @click=&quot;addition&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;App&#39;,
  computed:&#123;
    count() &#123;
      return this.$store.state.count
    &#125;
  &#125;,
  methods:&#123;
    addition() &#123;
      this.$store.commit(&#39;increment&#39;)
    &#125;,
    decrement() &#123;
      this.$store.commit(&#39;decrement&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="♥︎♥︎♥︎vue-router路由传参的方式"><a href="#♥︎♥︎♥︎vue-router路由传参的方式" class="headerlink" title="♥︎♥︎♥︎vue-router路由传参的方式"></a>♥︎♥︎♥︎vue-router路由传参的方式</h3><p>query</p>
<pre><code class="javascript">this.$router.push(&#123;
 path: &#39;blogDetail&#39;, 
 query: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<p>params</p>
<pre><code class="javascript">this.$router.push(&#123;
 name: &#39;blogDetail&#39;, 
 params: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<h3 id="♥︎♥︎♥︎-hash-history区别"><a href="#♥︎♥︎♥︎-hash-history区别" class="headerlink" title="♥︎♥︎♥︎ hash history区别"></a>♥︎♥︎♥︎ hash history区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">hash</th>
<th align="center">history</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url显示</td>
<td align="center">有#，很Low</td>
<td align="center">无#，好看</td>
</tr>
<tr>
<td align="center">回车刷新</td>
<td align="center">可以加载到hash值对应页面</td>
<td align="center">一般就是404掉了</td>
</tr>
<tr>
<td align="center">支持版本</td>
<td align="center">支持低版本浏览器和IE浏览器</td>
<td align="center">HTML5新推出的API</td>
</tr>
</tbody></table>
<h3 id="♥︎♥︎♥︎-用过beforeEach吗？"><a href="#♥︎♥︎♥︎-用过beforeEach吗？" class="headerlink" title="♥︎♥︎♥︎ 用过beforeEach吗？"></a>♥︎♥︎♥︎ 用过beforeEach吗？</h3><p>每次通过vue-router进行页面跳转，都会触发beforeEach这个钩子函数，这个回调函数共有三个参数，to，from，next这三个参数，to表示我要跳转的目标路由对应的参数，from表示来自那个路由，就是操作路由跳转之前的，即将离开的路由对应的参数，next是一个回调函数，一定要调用next方法来resolve这个钩子函数；</p>
<h3 id="♥︎♥︎♥︎-Vnode的优缺点"><a href="#♥︎♥︎♥︎-Vnode的优缺点" class="headerlink" title="♥︎♥︎♥︎ Vnode的优缺点"></a>♥︎♥︎♥︎ Vnode的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>1、降低浏览器性能消耗</p>
<p>因为Javascript的运算速度远大于DOM操作的执行速度，因此，运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而提高性能。</p>
<blockquote>
<p>在vnode技术出现之前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom，然后修改样式行为或者结构，来达到更新 ui的目的。这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom树。</p>
</blockquote>
<blockquote>
<p>在vnode技术出现之后，我们建立一个虚拟 dom 对象来对应真实的 dom 树，那么每次 dom 的更改就变成了 js 对象的属性的更改 ，这样一来就能查找 js 对象的属性变化要比查询 dom 树的 性能开销小。</p>
</blockquote>
<p>2、diff算法,减少回流和重绘</p>
<p>通过diff算法，优化遍历，对真实dom进行打补丁式的新增、修改、删除，实现局部更新，减少回流和重绘。</p>
<blockquote>
<p>vnode优化性能核心思想，就是每次更新 dom 都尽量避免刷新整个页面，而是有针对性的 去刷新那被更改的一部分，来释放掉被无效渲染占用的 gpu，cup性能。同时，也减少了大量的dom操作，减少了浏览器的回流和重绘。</p>
</blockquote>
<p>3、跨平台</p>
<p>虚拟 DOM 本质上是 JavaScript 对象，而 DOM 与平台强相关，相比之下虚拟 DOM ，可以进行更方便地跨平台操作，例如：<code>服务器渲染、weex 开发</code>等等</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><code>首次显示要慢些</code>:<br>首次渲染大量DOM时，由于多了一层虚拟DOM的计算, 会比innerHTML插入慢</li>
<li><code>无法进行极致优化</code>：<br>虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中 无法进行针对性的极致优化。</li>
</ul>
<h3 id="♥︎♥︎♥︎Vue中的单项数据流"><a href="#♥︎♥︎♥︎Vue中的单项数据流" class="headerlink" title="♥︎♥︎♥︎Vue中的单项数据流"></a>♥︎♥︎♥︎Vue中的单项数据流</h3><p>单向数据流指只能从一个方向来修改状态。</p>
<p>数据从父级组件传递给子组件，只能单向绑定。</p>
<p>子组件内部不能直接修改从父级传递过来的数据。</p>
<h3 id="♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？"><a href="#♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？" class="headerlink" title="♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？"></a>♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？</h3><p>如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p>
<p>所以说vue组件的data必须是函数。这都是因为js的特性带来的，跟vue本身设计无关。</p>
<h3 id="♥︎♥︎♥︎介绍下vue单页面和多页面区别"><a href="#♥︎♥︎♥︎介绍下vue单页面和多页面区别" class="headerlink" title="♥︎♥︎♥︎介绍下vue单页面和多页面区别"></a>♥︎♥︎♥︎介绍下vue单页面和多页面区别</h3><p>单页应用 页面跳转—-&gt;js渲染 优点：页面切换快 缺点：首屏加载稍慢，seo差</p>
<p>多页应用 页面跳转—-&gt;返回html 优点：首屏时间快，seo效果好 缺点：页面切换慢</p>
<h3 id="♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序"><a href="#♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序" class="headerlink" title="♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序"></a>♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序</h3><p>挂载阶段</p>
<blockquote>
<p>执行顺序为：<br>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p>
</blockquote>
<p>更新阶段</p>
<blockquote>
<p>执行顺序为：<br>父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</p>
</blockquote>
<p>销毁阶段</p>
<blockquote>
<p>执行顺序为：<br>父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</p>
</blockquote>
<p>规律就是：父组件先开始执行，然后等到子组件执行完，父组件收尾。</p>
<h3 id="♥︎♥︎♥︎Vue中key的作用？不加会怎么样？"><a href="#♥︎♥︎♥︎Vue中key的作用？不加会怎么样？" class="headerlink" title="♥︎♥︎♥︎Vue中key的作用？不加会怎么样？"></a>♥︎♥︎♥︎Vue中key的作用？不加会怎么样？</h3><p>vue中列表循环需加:key&#x3D;”唯一标识” 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM.</p>
<h3 id="♥︎♥︎♥︎Vue的常用修饰符"><a href="#♥︎♥︎♥︎Vue的常用修饰符" class="headerlink" title="♥︎♥︎♥︎Vue的常用修饰符"></a>♥︎♥︎♥︎Vue的常用修饰符</h3><blockquote>
<ol>
<li>事件修饰符 - 处理 DOM 事件细节</li>
<li>按键修饰符 - 为 v-on 在监听键盘事件时添加按键修饰符</li>
<li>系统修饰键 - 实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</li>
<li>鼠标按钮修饰符 - 限制处理函数仅响应特定的鼠标按键</li>
<li>表单修饰符 - v-model增强的修饰符</li>
</ol>
</blockquote>
<h4 id="一、事件修饰符"><a href="#一、事件修饰符" class="headerlink" title="一、事件修饰符"></a>一、事件修饰符</h4><ol>
<li><p>.stop - 阻止单击事件继续传播, 也就是阻止冒泡</p>
</li>
<li><p>.prevent - 提交事件不再重新加载页面, 可以用来阻止表单提交的默认行为</p>
</li>
</ol>
<blockquote>
<p>注意点: .stop和.prevent可以串联在一起使用,都会生效</p>
</blockquote>
<ol start="3">
<li><p>.capture - 内部元素触发的事件先在此处理，然后才交由内部元素进行处理</p>
</li>
<li><p>.self - 只当在 event.target 是当前元素自身时触发处理函数,即事件不是从内部元素触发的</p>
</li>
</ol>
<blockquote>
<p>注意点: 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p>
</blockquote>
<ol start="5">
<li><p>.once - 点击事件将只会触发一次, 不只能对原生DOM时间生效,还可以用在自定义组件上</p>
</li>
<li><p>.passive - 立即触发默认行为,能够提升移动端性能,和.prevent一起使用时.prevent会被忽略并警告</p>
</li>
<li><p>.native - 使用时将被当做原生的HTML标签看待,绑定事件可以生效</p>
</li>
</ol>
<h4 id="二、按键修饰符"><a href="#二、按键修饰符" class="headerlink" title="二、按键修饰符"></a>二、按键修饰符</h4><ol>
<li><p>.keyup - 键盘抬起</p>
</li>
<li><p>.keydow - 键盘按下</p>
</li>
<li><p>按键码 - 在按键修饰符后面添加,用于监听键盘按下哪个键</p>
</li>
</ol>
<p>常用按键码: </p>
<ul>
<li><p>.enter</p>
</li>
<li><p>.tab</p>
</li>
<li><p>.delete (捕获“删除”和“退格”键)</p>
</li>
<li><p>.esc</p>
</li>
<li><p>.space</p>
</li>
<li><p>.up</p>
</li>
<li><p>.down</p>
</li>
<li><p>.left</p>
</li>
<li><p>.right</p>
</li>
</ul>
<h4 id="三、系统修饰键"><a href="#三、系统修饰键" class="headerlink" title="三、系统修饰键"></a>三、系统修饰键</h4><ul>
<li><p>.ctrl</p>
</li>
<li><p>.alt</p>
</li>
<li><p>.shift</p>
</li>
<li><p>.meta</p>
</li>
</ul>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<blockquote>
<p>注意点: 修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。<br>.exact 修饰符 - 使用系统修饰符时使用可以单击系统修饰键触发,不适用系统修饰符时使用</p>
</blockquote>
<h4 id="四、鼠标按键修饰符"><a href="#四、鼠标按键修饰符" class="headerlink" title="四、鼠标按键修饰符"></a>四、鼠标按键修饰符</h4><p>.left - 只有鼠标左键点击触发<br>.right - 只有鼠标右键点击触发<br>.middle - 只有鼠标中键点击触发</p>
<h4 id="五、表单修饰符"><a href="#五、表单修饰符" class="headerlink" title="五、表单修饰符"></a>五、表单修饰符</h4><ol>
<li><p>.lazy - 在表单输入时不会马上显示在页面,而是等输入完成失去焦点时才会显示在页面</p>
</li>
<li><p>.trim - 过滤表单输入时前后的空格</p>
</li>
<li><p>.number - 限制输入数字或将输入的数据转为数字</p>
</li>
</ol>
<blockquote>
<p>注意点: 如果先输入数字,会限制只能输数字, 如果先输字符串则相当于没加.number</p>
</blockquote>
<h3 id="♥︎♥︎♥︎Vue计算属性和-Watch-的区别"><a href="#♥︎♥︎♥︎Vue计算属性和-Watch-的区别" class="headerlink" title="♥︎♥︎♥︎Vue计算属性和 Watch 的区别"></a>♥︎♥︎♥︎Vue计算属性和 <strong>Watch</strong> 的区别</h3><p>methods（方法）：</p>
<p>只要进行调用就会执行，不管依赖的值有没有改变。无缓存。</p>
<p>computed（计算属性)：</p>
<p>监听其所有依赖的变化，如果有变化会执行，没有变化不执行。有缓存，不用每次重新算。不支持异步。</p>
<p>详解:在vue的 模板内是可以写一些简单的js表达式的 ，很便利。但是如果在页面中使用大量或是复杂的表达式去处理数据，对页面的维护会有很大的影响。这个时候就需要用到computed 计算属性来处理复杂的逻辑运算。</p>
<p>1.优点：</p>
<p>在数据未发生变化时，优先读取缓存。computed 计算属性只有在相关的数据发生变化时才会改变要计算的属性，当相关数据没有变化是，它会读取缓存。而不必想 motheds方法 和 watch 方法是否每次都去执行函数。</p>
<p>2.setter 和 getter方法：（注意在vue中书写时用set 和 get）</p>
<p>setter 方法在设置值是触发。</p>
<p>getter 方法在获取值时触发。</p>
<p>watch（侦听属性）:</p>
<p>观察某一个变量，发生变化会执行。支持异步。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>
<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。</p>
<p>❕小结：</p>
<p>1.主动调用的方法写在methods里，依据某些变量的更新进行某种操作用computed或者watch。</p>
<p>2.computed和watch：如果要异步，只能用watch。如果是计算某个值推荐用computed，比如购物车全选单选功能，购物车计算总价小计功能。</p>
<h3 id="♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？"><a href="#♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？" class="headerlink" title="♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？"></a>♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？</h3><p>vue中v-on是可以绑定多个方法的</p>
<p>1、v-on绑定多个方法（采用的是对象形式）</p>
<pre><code class="html">&lt;button v-on=&quot;&#123;click: clickMethods, mousemove: mouseMethods&#125;&quot;&gt;按钮&lt;button&gt;
</code></pre>
<p>2.v-on 一个事件绑定多个方法 （语法糖 @）</p>
<pre><code class="html">&lt;button @click=&quot;click1,click2&quot;&gt;按钮&lt;/button&gt;
</code></pre>
<h3 id="♥︎♥︎♥︎Vue中template的编译过程"><a href="#♥︎♥︎♥︎Vue中template的编译过程" class="headerlink" title="♥︎♥︎♥︎Vue中template的编译过程"></a>♥︎♥︎♥︎Vue中template的编译过程</h3><p>vue template模板编译的过程经过parse()生成ast(抽象语法树),optimize对静态节点优化，generate()生 成render字符串 之后调用new Watcher()函数，用来监听数据的变化，render 函数就是数据监听的回调,所调用的，其结果便是重新生成 vnode。 当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。 如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode做 diff，对内容做改动之后，就会更新到 我们真正的 DOM</p>
<h3 id="♥︎♥︎♥︎Vue中router-link和传统a链接的区别？"><a href="#♥︎♥︎♥︎Vue中router-link和传统a链接的区别？" class="headerlink" title="♥︎♥︎♥︎Vue中router-link和传统a链接的区别？"></a>♥︎♥︎♥︎Vue中router-link和传统a链接的区别？</h3><p>组件支持用户在具有路由功能的应用中 (点击) 导航。 </p>
<p>通过 to 属性指定目标地址，默认渲染成带有正确链接的 标签，可以通过配置 tag 属性生成别的标签.。 </p>
<p>通过router-link进行跳转不会跳转到新的页面，也不会重新渲染，它会选择路由所指的组件进行渲染，避免了重复渲染的“无用功”。 </p>
<p>总结：对比，router-link组件避免了不必要的重渲染,它只更新变化的部分从而减少DOM性能消耗</p>
<h3 id="♥︎♥︎♥︎-Vue插槽是什么？"><a href="#♥︎♥︎♥︎-Vue插槽是什么？" class="headerlink" title="♥︎♥︎♥︎ Vue插槽是什么？"></a>♥︎♥︎♥︎ Vue插槽是什么？</h3><p>slot用于封装组件中，写在子组件 接收父组件动态传递子组件内容片断</p>
<p>slot插槽的使用方法其实就是类似于一个子组件或者标签的引用的过程，在父组件里面定义一个slot，给她起个name，然后组件引入到子组件，子组件里面有个元素的属性slot值等于name，然后父组件里面没有值的时候就可以显示子组件里面的信息了（切记：插槽slot要写在父组件里面！！！）</p>
<h3 id="♥︎♥︎♥︎-说一下Vue-router守卫有哪些。如何实现路由懒加载？"><a href="#♥︎♥︎♥︎-说一下Vue-router守卫有哪些。如何实现路由懒加载？" class="headerlink" title="♥︎♥︎♥︎ 说一下Vue-router守卫有哪些。如何实现路由懒加载？"></a>♥︎♥︎♥︎ 说一下Vue-router守卫有哪些。如何实现路由懒加载？</h3><ul>
<li>router.beforeEach 全局前置守卫 进入路由之前</li>
<li>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用</li>
<li>router.afterEach 全局后置钩子 进入路由之后</li>
</ul>
<p>1、 Vue异步加载技术</p>
<blockquote>
<p>1：vue-router配置路由，使用vue的异步组件技术，可以实现懒加载，此时一个组件会生成一个js文件。 </p>
<p>2：component: resolve &#x3D;&gt; require([‘放入需要加载的路由地址’], resolve)</p>
</blockquote>
<p>2、 ES6推荐方式imprort ()—-推荐使用</p>
<pre><code class="javascript">import Vue from &#39;vue&#39;;
import Router from &#39;vue-router&#39;;
// 官网可知：下面没有指定webpackChunkName，每个组件打包成一个js文件。
const Foo = () =&gt; import(&#39;../components/Foo&#39;)
const Aoo = () =&gt; import(&#39;../components/Aoo&#39;)
// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。
// const Foo = () =&gt; import(/* webpackChunkName: &#39;ImportFuncDemo&#39; / &#39;../components/Foo&#39;)
// const Aoo = () =&gt; import(/ webpackChunkName: &#39;ImportFuncDemo&#39; */ &#39;../components/Aoo&#39;)
export default new Router(&#123;
 routes: [
 &#123;
 path: &#39;/Foo&#39;,
 name: &#39;Foo&#39;,
 component: Foo
 &#125;,
 &#123;
 path: &#39;/Aoo&#39;,
 name: &#39;Aoo&#39;,
 component: Aoo
 &#125;
 ]
&#125;)
</code></pre>
<p>3、 webpack提供的require.ensure()实现懒加载</p>
<ul>
<li>1：vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。</li>
<li>2：这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</li>
<li>3：require.ensure可实现按需加载资源，包括js,css等。他会给里面require的文件单独打包，不会和主文件打包在一起。</li>
<li>4：第一个参数是数组，表明第二个参数里需要依赖的模块，这些会提前加载。</li>
<li>5：第二个是回调函数,在这个回调函数里面require的文件会被单独打包成一个chunk,不会和主文件打包在一起，这样就生成了两个chunk,第一次加载时只加载主文件。</li>
<li>6：第三个参数是错误回调。</li>
<li>7：第四个参数是单独打包的chunk的文件名</li>
</ul>
<pre><code class="javascript">import Vue from &#39;vue&#39;;
import Router from &#39;vue-router&#39;;
const HelloWorld=resolve=&gt;&#123;
 require.ensure([&#39;@/components/HelloWorld&#39;],()=&gt;&#123;
 resolve(require(&#39;@/components/HelloWorld&#39;))
 &#125;)
 &#125;
Vue.use(&#39;Router&#39;)
export default new Router(&#123;
 routes:[&#123;
 &#123;path:&#39;./&#39;,
 name:&#39;HelloWorld&#39;,
 component:HelloWorld
 &#125;
 &#125;]
&#125;)
</code></pre>
<h3 id="♥︎♥︎♥︎什么是Vue-js动态组件与异步组件？"><a href="#♥︎♥︎♥︎什么是Vue-js动态组件与异步组件？" class="headerlink" title="♥︎♥︎♥︎什么是Vue.js动态组件与异步组件？"></a>♥︎♥︎♥︎什么是Vue.js动态组件与异步组件？</h3><h4 id="1-动态组件"><a href="#1-动态组件" class="headerlink" title="1.动态组件"></a>1.动态组件</h4><ul>
<li>:is &#x3D; “component-name” 用法</li>
<li>需要根据数据，动态渲染的场景。即组件类型不确定</li>
</ul>
<pre><code class="html">//代码实例
&lt;template&gt;
  &lt;div&gt;
      &lt;p&gt;vue高级特性&lt;/p&gt;
      &lt;hr&gt;
      &lt;!-- 动态组件 --&gt;
      &lt;component :is=&quot;NextTickName&quot;&gt;&lt;/component&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
&lt;/style&gt;
</code></pre>
<pre><code class="javascript">&lt;script&gt;
import NextTick from &#39;./nextTick&#39;
export default &#123;
  components: &#123;
    NextTick
  &#125;,
  data () &#123;
    return &#123;
      name: &#39;夹心&#39;,
      website: &#123;
        url: &#39;http://imooc.com/&#39;,
        title: &#39;imooc&#39;,
        subTitle: &#39;程序员的梦工厂&#39;
      &#125;,
      NextTickName: &#39;NextTick&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h4 id="2-异步组件"><a href="#2-异步组件" class="headerlink" title="2.异步组件"></a>2.异步组件</h4><ul>
<li>import() 函数</li>
<li>按需加载，异步加载大组件</li>
</ul>
<pre><code class="javascript">export default &#123;
  components: &#123;
    FormDemo: () =&gt; import(&#39;../components/FormDemo&#39;)
  &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式"><a href="#♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式" class="headerlink" title="♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式"></a>♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式</h3><p>1、路由跳转</p>
<p>router-link组件 默认会被渲染成一个 标签，进行跳转，在组件中可以通过绑定to属性来指定要跳转的链接；tag属性指本来的标签</p>
<blockquote>
<p>$router.push()方法</p>
</blockquote>
<p>2、路由传参</p>
<p>query</p>
<pre><code class="javascript">this.$router.push(&#123;
 path: &#39;blogDetail&#39;, 
 query: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<p>params</p>
<pre><code class="javascript">this.$router.push(&#123;
 name: &#39;blogDetail&#39;, 
 params: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<h3 id="♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3-0与Vue2-0对比"><a href="#♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3-0与Vue2-0对比" class="headerlink" title="♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3.0与Vue2.0对比)"></a>♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3.0与Vue2.0对比)</h3><p>[Vue3.0与Vue2.0区别]: 	“<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/389421424">https://zhuanlan.zhihu.com/p/389421424</a>  “</p>
<h4 id="一、六大亮点"><a href="#一、六大亮点" class="headerlink" title="一、六大亮点"></a>一、六大亮点</h4><p>性能比vue2.x快1.2~2倍</p>
<p>支持tree-shaking，按需编译，体积比vue2.x更小</p>
<p>支持组合API</p>
<p>更好的支持TS</p>
<p>更先进的组件</p>
<h4 id="二、性能比vue2-x快1-2-2倍如何实现的呢"><a href="#二、性能比vue2-x快1-2-2倍如何实现的呢" class="headerlink" title="二、性能比vue2.x快1.2~2倍如何实现的呢"></a>二、性能比vue2.x快1.2~2倍如何实现的呢</h4><p>1.diff算法更快</p>
<p>vue2.0是需要全局去比较每个节点的，若发现有节点发生变化后，就去更新该节点</p>
<p>vue3.0是在创建虚拟dom中，会根据DOM的的内容会不会发生内容变化，添加静态标记， 谁有flag！比较谁。</p>
<p>2、静态提升</p>
<p>vue2中无论元素是否参与更新，每次都会重新创建，然后再渲染 vue3中对于不参与更新的元素，会做静态提升，只被创建一次，在渲染时直接复用即可</p>
<p>3、事件侦听缓存默认情况下，onclick为动态绑定，所以每次都会追踪它的变化，但是因为是同一函数，没有必要追踪变化，直接缓存复用即可在之前会添加静态标记8 会把点击事件当做动态属性 会进行diff算法比较， 但是在事件监听缓存之后就没有静态标记了，就会进行缓存复用</p>
<h4 id="三、为什么vue3-0体积比vue2-x小"><a href="#三、为什么vue3-0体积比vue2-x小" class="headerlink" title="三、为什么vue3.0体积比vue2.x小"></a>三、为什么vue3.0体积比vue2.x小</h4><p>在vue3.0中创建vue项目 除了vue-cli，webpack外还有 一种创建方法是Vite Vite是作者开发的一款有意取代webpack的工具，其实现原理是利用ES6的import会发送请求去加载文件的特性，拦截这些请求，做一些预编译，省去webpack冗长的打包时间</p>
<h4 id="四、vue3-0组合API"><a href="#四、vue3-0组合API" class="headerlink" title="四、vue3.0组合API"></a>四、vue3.0组合API</h4><p>1.说一说vue3.0的组合API跟之前vue2.0在完成业务逻辑上的区别：</p>
<p>在vue2.0中： 主要是往data 和method里面添加内容，一个业务逻辑需要什么data和method就往里面添加，而组合API就是 有一个自己的方法，里面有自己专注的data 和method。</p>
<p>2.再说一下组合API的本质是什么： 首先composition API（组合API） 和 Option API（vue2.0中的data和method）可以共用 composition API（组合API）本质就是把内容添加到Option API中进行使用</p>
<h4 id="五、ref和reactive的简单理解"><a href="#五、ref和reactive的简单理解" class="headerlink" title="五、ref和reactive的简单理解"></a>五、ref和reactive的简单理解</h4><p>1.ref和reactive都是vue3的监听数据的方法，本质是proxy </p>
<p>2.ref 基本类型复杂类型都可以监听(我们一般用ref监听基本类型)，reactive只能监听对象（arr，json） </p>
<p>3.ref底层还是reactive</p>
<h4 id="六、对生命周期的监听（ref获取属性）"><a href="#六、对生命周期的监听（ref获取属性）" class="headerlink" title="六、对生命周期的监听（ref获取属性）"></a>六、对生命周期的监听（ref获取属性）</h4><h4 id="七、proxy响应式本质"><a href="#七、proxy响应式本质" class="headerlink" title="七、proxy响应式本质"></a>七、proxy响应式本质</h4><h3 id="♥︎♥︎♥︎v-if和v-show的区别"><a href="#♥︎♥︎♥︎v-if和v-show的区别" class="headerlink" title="♥︎♥︎♥︎v-if和v-show的区别"></a>♥︎♥︎♥︎v-if和v-show的区别</h3><p>1、手段：v-if是动态的向DOM树添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显示和隐藏。</p>
<p>2、编译过程：v-if切换有一个局部编译&#x2F;卸载的过程， 切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换。</p>
<p>3、编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留</p>
<p>4、性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换</p>
<p>6、相同点： v-show 都可以动态控制着dom元素的显示隐藏 </p>
<p>​    不同点： v-if 的显示隐藏是将DOM元素整个添加或删除，v-show 的显示隐藏是为DOM元素添</p>
<p>7、加css的样式display，设置none或者是block，DOM元素是还存在的</p>
<p>8、在渲染多个元素的时候，可以把一个 元素作为包装元素，并使用v-if 进行条件判断，最终的渲染不会包含这个元素，v-show是不支持 语法</p>
<h3 id="♥︎♥︎♥︎-简述Vue每个生命周期具体适合哪些场景"><a href="#♥︎♥︎♥︎-简述Vue每个生命周期具体适合哪些场景" class="headerlink" title="♥︎♥︎♥︎ 简述Vue每个生命周期具体适合哪些场景"></a>♥︎♥︎♥︎ 简述Vue每个生命周期具体适合哪些场景</h3><table>
<thead>
<tr>
<th align="center">钩子函数</th>
<th align="center">具体发生了什么</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beforeCreate</td>
<td align="center">初始化界面前 : 在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问，都还没有完成初始化。</td>
</tr>
<tr>
<td align="center">created</td>
<td align="center">初始化界面后 : 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数,也就是不会更新视图。实例的data数据和methods方法都已经被初始化完毕了，可以正常访问</td>
</tr>
<tr>
<td align="center">beforeMount</td>
<td align="center">挂载前 ：完成模板编译，虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。数据还没有更新到页面上去。当编译完成之后，只是在内存中已经有了编译好的页面，但并未渲染。</td>
</tr>
<tr>
<td align="center">mounted</td>
<td align="center">挂载完成 ： 将编译好的模板挂载到页面 (虚拟DOM挂载) ，可以在这进行异步请求以及DOM节点的访问，在vue用$ref操作</td>
</tr>
<tr>
<td align="center">beforeUpdate</td>
<td align="center">更新数据前 ： 组件数据更新之前调用，数据都是新的,页面上数据都是旧的。将要根据最新的data数据，重新解析所有指令，从而重新渲染浏览器页面。</td>
</tr>
<tr>
<td align="center">updated</td>
<td align="center">组件更新后 ： render重新渲染 , 此时数据和界面都是新的 ,要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新</td>
</tr>
<tr>
<td align="center">beforeDestroy</td>
<td align="center">组件卸载前 : 实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器</td>
</tr>
<tr>
<td align="center">destroyed</td>
<td align="center">组件卸载后 ： 组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</td>
</tr>
<tr>
<td align="center">activited</td>
<td align="center">keep-alive 专属 , 组件被激活时调用</td>
</tr>
<tr>
<td align="center">deactivated</td>
<td align="center">keep-alive 专属 , 组件被销毁时调用</td>
</tr>
</tbody></table>
<h3 id="♥︎♥︎♥︎-什么是v-model？它的原理是什么？"><a href="#♥︎♥︎♥︎-什么是v-model？它的原理是什么？" class="headerlink" title="♥︎♥︎♥︎ 什么是v-model？它的原理是什么？"></a>♥︎♥︎♥︎ 什么是v-model？它的原理是什么？</h3><p>1、v-model本质上是一个语法糖，可以看成是value + input 方法的语法糖。可以通过model的prop属性和event事件来进行自定义。</p>
<p>2、v-model是vue的双向绑定的指令，能将页面上控件输入的值同步更新到相关绑定的data属性， 也会在更新data绑定属性时候，更新页面上输入控件的值。</p>
<h3 id="♥︎♥︎♥︎简单说一下-微信小程序-与Vue的区别（了解即可，具体区别请看各自具体部分）"><a href="#♥︎♥︎♥︎简单说一下-微信小程序-与Vue的区别（了解即可，具体区别请看各自具体部分）" class="headerlink" title="♥︎♥︎♥︎简单说一下 微信小程序 与Vue的区别（了解即可，具体区别请看各自具体部分）"></a>♥︎♥︎♥︎简单说一下 微信小程序 与Vue的区别（了解即可，具体区别请看各自具体部分）</h3><p>1、生命周期：</p>
<p>小程序的钩子函数要简单得多 。 vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。</p>
<p>在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。</p>
<p>2、数据绑定：</p>
<p>vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：</p>
<p>小程序 绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串</p>
<p>3、列表循环</p>
<p>4、显示与隐藏元素</p>
<p>vue中，使用v-if 和v-show控制元素的显示和隐藏</p>
<p>小程序中，使用wx-if和hidden控制元素的显示和隐藏</p>
<p>5、事件处理</p>
<p>vue：使用v-on:event绑定事件，或者使用@event绑定事件</p>
<p>小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件</p>
<p>6、数据的双向绑定</p>
<p>在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变 。</p>
<p>当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值 。 </p>
<p>7、绑定事件传参</p>
<p>在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了</p>
<p>在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取</p>
<p>8、父子组件通信</p>
<p>父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量 在子组件properties中，接收传递的值</p>
<h3 id="♥︎♥︎♥︎Vue的组件通信"><a href="#♥︎♥︎♥︎Vue的组件通信" class="headerlink" title="♥︎♥︎♥︎Vue的组件通信"></a>♥︎♥︎♥︎Vue的组件通信</h3><p>1、props和$emit</p>
<p>父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件</p>
<p>2、$attrs和$listeners</p>
<p>3、中央事件总线 bus</p>
<p>上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。</p>
<p>4、provide和inject</p>
<p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p>
<p>5、v-model</p>
<p>父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</p>
<p>6、$parent和$children</p>
<p>7、boradcast和dispatch</p>
<p>8、vuex处理组件之间的数据交互 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>
<h3 id="♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？"><a href="#♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？" class="headerlink" title="♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？"></a>♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？</h3><p>现在 我们需要实现这样 一个功能，登录拦截，其实就是 路由拦截，首先在定义路由的时候就需要多添加一个自定义字段requireAuth，用于判断该路由的访问是否需要登录。如果用户已经登录，则顺利进入路由， 否则就进入登录页面。在路由管理页面添加meta字段</p>
<pre><code class="javascript">&#123;
 path:&#39;/manage&#39;,
 name:&#39;manage&#39;,
 component:manage,
 meta:&#123;requireAuth:true&#125;
&#125;
</code></pre>
<p>在入口文件中，添加路由守卫</p>
<p>先判断该路由是否需要登录权限</p>
<p>判断本地是否存在token，如果存在token就next()，不存在token重定向到登录页</p>
<h3 id="♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。"><a href="#♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。" class="headerlink" title="♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。"></a>♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。</h3><p>Redux和Vuex区别</p>
<p>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值就可以</p>
<p>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state就可以</p>
<p>Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数 – store改变(vue检测到数据变化自动渲染)</p>
<p>共同思想</p>
<ul>
<li>单一的数据源</li>
<li>变化可以预测</li>
<li>本质上:Redux和Vuex都是对MVVM思想的服务，将数据从视图中抽离的一种方案</li>
<li>形式上:Vuex借鉴了Redux，将store作为全局的数据中心，进行数据管理</li>
</ul>
<hr>
<h3 id="♥︎♥︎♥︎♥︎Composition-API的出现带来哪些新的开发体验，为啥需要这个？"><a href="#♥︎♥︎♥︎♥︎Composition-API的出现带来哪些新的开发体验，为啥需要这个？" class="headerlink" title="♥︎♥︎♥︎♥︎Composition API的出现带来哪些新的开发体验，为啥需要这个？"></a>♥︎♥︎♥︎♥︎Composition API的出现带来哪些新的开发体验，为啥需要这个？</h3><p>1：在Compostion API 中时根据逻辑相关组织代码的，提高可读性和可维护性，类似于react的hook写法。</p>
<p>2：更好的重用逻辑代码，在Options API中通过MIxins重用逻辑代码，容易发生命名冲突且关系不清。</p>
<p>3：解决在生命周期函数经常包含不相关的逻辑，但又不得不把相关逻辑分离到了几个不同方法中的问题，如在mounted中设置定时器，但需要在destroyed中来清除定时器，将同一功能的代码拆分到不同的位置，造成后期代码维护的困难。</p>
<h3 id="♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作"><a href="#♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作" class="headerlink" title="♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作"></a>♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作</h3><p>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，否则无法被devtools所监测。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>
<h3 id="♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法"><a href="#♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法" class="headerlink" title="♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法"></a>♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法</h3><p>[封装vue组件的原则和技巧]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/leilei__66/article/details/119348108">https://blog.csdn.net/leilei__66/article/details/119348108</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎Object-defineProperty有什么缺点"><a href="#♥︎♥︎♥︎♥︎Object-defineProperty有什么缺点" class="headerlink" title="♥︎♥︎♥︎♥︎Object.defineProperty有什么缺点"></a>♥︎♥︎♥︎♥︎Object.defineProperty有什么缺点</h3><p>1：无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</p>
<p>2：只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。</p>
<h3 id="♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程"><a href="#♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程" class="headerlink" title="♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程?"></a>♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程?</h3><p>axios 是请求后台资源的模块。 </p>
<p>通过npm install axios -S来安装，在大多数情况下我们需要封装拦截器。</p>
<p>在实现登录的过程中我们一般在请求拦截器中来加入token，在响应请求器中通过判断后端返回的状态码来对返回的数据进行不同的处理。如果发送的是跨域请求，需在配置文件中 config&#x2F;index.js 进行代理配置。</p>
<h3 id="♥︎♥︎♥︎♥︎-computed和watcher的区别？watch实现原理？watch有几种写法？"><a href="#♥︎♥︎♥︎♥︎-computed和watcher的区别？watch实现原理？watch有几种写法？" class="headerlink" title="♥︎♥︎♥︎♥︎ computed和watcher的区别？watch实现原理？watch有几种写法？"></a>♥︎♥︎♥︎♥︎ computed和watcher的区别？watch实现原理？watch有几种写法？</h3><p>计算属性computed :</p>
<ol>
<li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li>
<li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li>
<li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>
<li>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li>
</ol>
<p>侦听属性watch： </p>
<ol>
<li>不支持缓存，数据变，直接会触发相应的操作；</li>
<li>watch支持异步；</li>
<li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li>
<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>
<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</li>
</ol>
<p>immediate：组件加载立即触发回调函数执行，</p>
<p>deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。</p>
<p>注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p>
<p>watch工作原理:</p>
<p>watch在一开始初始化的时候，会读取一遍监听的数据的值，此时那个数据就收集到watch的watcher了，然后你给watch设置的handler，watch 会放入watcher的更新函数中，当数据改变时，通知watch的watcher进行更新，于是你设置的handler就被调用了。</p>
<h3 id="♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？"><a href="#♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？" class="headerlink" title="♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？"></a>♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？</h3><p>评估项目成员的水平，如果成员js基础较好、编码能力较强则选择React，否则Vue。</p>
<p>评估系统的大小，如果想构建生态系统，则选择React，如果要求而快，简单和“能用就行”,则选择Vue。</p>
<p>评估系统运行环境，如果你想要一个同时适用于Web端和原生APP的框架，请选择React(RN)。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue和React区别"><a href="#♥︎♥︎♥︎♥︎Vue和React区别" class="headerlink" title="♥︎♥︎♥︎♥︎Vue和React区别"></a>♥︎♥︎♥︎♥︎Vue和React区别</h3><p>1：Vue 使用的是 web 开发者更熟悉的模板与特性，Vue的API跟传统web开发者熟悉的模板契合度更高，比如Vue的单文件组件是以模板+JavaScript+CSS的组合模式呈现，它跟web现有的HTML、JavaScript、CSS能够更好地配合。React 的特色在于函数式编程的理念和丰富的技术选型，Vue更加注重web开发者的习惯。</p>
<p>2：Vue跟React的最大区别在于数据的reactivity，就是反应式系统上。Vue提供反应式的数据，当数据改动时，界面就会自动更新，而React里面需要调用方法SetState。我把两者分别称为Push-based和Pull-based</p>
<h3 id="♥︎♥︎♥︎♥︎Vue路由实现的底层原理"><a href="#♥︎♥︎♥︎♥︎Vue路由实现的底层原理" class="headerlink" title="♥︎♥︎♥︎♥︎Vue路由实现的底层原理"></a>♥︎♥︎♥︎♥︎Vue路由实现的底层原理</h3><p>在Vue中利用数据劫持defineProperty在原型prototype上初始化了一些getter,分别是router代表当前Router的实例 、route 代表当前Router的信息。在install中也全局注册了router-view,router-link,其中的Vue.util.defineReactive, 这是Vue里面观察者劫持数据的方法，劫持<em>route</em>，当route触发setter方法的时候，则会通知到依赖的组件。</p>
<p>接下来在init中，会挂载判断是路由的模式，是history或者是hash,点击行为按钮，调用hashchange或 者popstate的同时更*route,*route的更新会触发route-view的重新渲染。</p>
<h3 id="♥︎♥︎♥︎♥︎如何封装一个通用组件"><a href="#♥︎♥︎♥︎♥︎如何封装一个通用组件" class="headerlink" title="♥︎♥︎♥︎♥︎如何封装一个通用组件"></a>♥︎♥︎♥︎♥︎如何封装一个通用组件</h3><p>通用组件的封装就是对可复用组件的解耦和样式复用，为了解耦一般数据都是通过父组件传递过来，在子组件中进行数据处理，对于一些较为复杂的数据可能还需要做数据验证，为了避免高耦合，逻辑最好放在父组件中，通过自定义事件将数据回传，子组件只是一个承载体，这样既降低耦合，保证子组件中数据和逻辑不会混乱。如果同一组件需要适应不同需求时，我们需要配合slot来使用，可以通过具名插槽灵活地解决了不同场景同一组件不同配置的问题。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue-proxy的原理"><a href="#♥︎♥︎♥︎♥︎Vue-proxy的原理" class="headerlink" title="♥︎♥︎♥︎♥︎Vue proxy的原理"></a>♥︎♥︎♥︎♥︎Vue proxy的原理</h3><p>主要通过Proxy对对象进行绑定监听处理，通过new Map对对象的属性操作进行处理，将要执行的函数匹配到存到对应的prop上面，通过每次的访问触发get方法，进行存方法的操作，通过修改触发set的方法，此时执行回调监听的函数，这样达到修改数据和视图的</p>
<h3 id="♥︎♥︎♥︎♥︎-defineProperty在数据劫持后是如何通知数据的更新和视图的更新的"><a href="#♥︎♥︎♥︎♥︎-defineProperty在数据劫持后是如何通知数据的更新和视图的更新的" class="headerlink" title="♥︎♥︎♥︎♥︎ defineProperty在数据劫持后是如何通知数据的更新和视图的更新的"></a>♥︎♥︎♥︎♥︎ defineProperty在数据劫持后是如何通知数据的更新和视图的更新的</h3><p>vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的，那么什么是数据劫持？vue是如何进行数据劫持的？说白了就是通过Object.defineProperty()来劫持对象属性的setter和getter操作，在数据变动时做你想要做的事情</p>
<p>我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发生变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：</p>
<p>1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p>
<p>2.实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。</p>
<p>3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的"><a href="#♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的" class="headerlink" title="♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的"></a>♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的</h3><p>[Vue虚拟DOM以及diff算法]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/wytraining/article/details/110831015">https://blog.csdn.net/wytraining/article/details/110831015</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听"><a href="#♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听" class="headerlink" title="♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听"></a>♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听</h3><p>[Vuex跨组价的数据监听]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/Flowering_Vivian/article/details/108868907">https://blog.csdn.net/Flowering_Vivian/article/details/108868907</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的"><a href="#♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的" class="headerlink" title="♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的"></a>♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的</h3><pre><code class="javascript">// 使用axios用于对数据的请求
import axios from &#39;axios&#39;
// 创建axios实例
const instance = axios.create(&#123;
 baseURL: baseURL + version,
 timeout: 5000
&#125;)
// 创建请求的拦截器
instance.interceptors.request.use(config =&gt; &#123;
 config.headers[&#39;Authorization&#39;] = localStorage.getItem(&#39;token&#39;)
 return config
&#125;, error =&gt; &#123;
 return Promise.reject(error)
&#125;)
// 创建响应的拦截器
instance.interceptors.response.use(response =&gt; &#123;
 let res = null
 // 对相应的数据进行过滤
 if (response.status === 200) &#123;
 if (response.data &amp;&amp; response.data.err === 0) &#123;
 res = response.data.data
 &#125; else if (response.data.err === -1) &#123;
 return alert(&#39;token无效&#39;)
 &#125;
 &#125; else &#123;
 return alert(&#39;请求失败&#39;)
 &#125;
 return res
&#125;, error =&gt; &#123;
 return Promise.reject(error)
&#125;)
export default instance
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？"><a href="#♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？" class="headerlink" title="♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？"></a>♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？</h3><p>1、虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom 的 diff 算法避免了没有必要的 dom 操作，从而提高性能。<br>2、用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中，当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue的computed的原理"><a href="#♥︎♥︎♥︎♥︎Vue的computed的原理" class="headerlink" title="♥︎♥︎♥︎♥︎Vue的computed的原理"></a>♥︎♥︎♥︎♥︎Vue的computed的原理</h3><h4 id="1-computed大致流程"><a href="#1-computed大致流程" class="headerlink" title="1.computed大致流程"></a>1.computed大致流程</h4><p>computed是vue中的计算属性，在依赖的值发生变化的时候进行重新计算，否则使用缓存。</p>
<p>前面说到computed只有在依赖发生变化才会重新计算，那么如何得知computed的值发生了变化呢</p>
<p>这主要是Watcher中的dirty属性，dirty属性为true时，说明computed中的值需要重新计算，dirty为false时，则说明依赖没有变化，不需要重新计算</p>
<p>当计算属性的值发生变化时，计算属性的watcher和组件的watcher都会得到通知。</p>
<p>计算属性的watcher会将dirty置为true,组件的Watcher得到通知，同样将dirty属性置为false,重新计算值，用于本次渲染。</p>
<p>简单来说,computed就是定义在vm上的一个getter属性，这个getter属性被触发时会做两件事</p>
<ol>
<li>计算当前属性的值，此时会使用Watcher去观察计算属性中用到的所有其他数据的变化。同时将计算属性的Watcher的dirty属性设置为false.</li>
</ol>
<p>2.当计算属性中用到的数据发生变化时,将得到通知从而进行重新渲染</p>
<p>Watcher中的depend和evaluate方法是专门用于实现计算属性的两个API</p>
<pre><code class="javascript">export default class Watcher &#123;
     constructor(vm, expOrFn, cb, options) &#123;
         if(options) &#123;
             this.lazy = !!options.lazy;
         &#125;  else &#123;
             this.lazy = false;
         &#125;
         this.dirty = this.lazy;
         this.value = this.lazy ? undefined : this.get()
     &#125;
     evaluate() &#123;
        this.value = this.get()
        this.dirty = false; 
    &#125;
    depend() &#123;
        let i = this.deps.length
        while(i--) &#123;
            this.deps[i].depend()
        &#125;
    &#125;
&#125;
</code></pre>
<p>执行depend方法可以将组件中的watcher实例添加到dep实例的依赖列表中。换句话说,this.deps是计算属性中用到的所有状态的dep实例,而依次执行了dep实例的depend方法就是将组件的watcher依次加入到这些dep实例的依赖列表。这就实现了让组件的watcher观察计算属性中用到的所有的状态的变化。</p>
<h4 id="2-Computed逻辑变化"><a href="#2-Computed逻辑变化" class="headerlink" title="2.Computed逻辑变化"></a>2.Computed逻辑变化</h4><p>computed在vue2.5.2中的实现发生了一些变化,因为之前的computed的计算存在一些逻辑上的漏洞,因为只要依赖的值发生了变化,vue就认为值发生了变化，组件会重新走一遍渲染的流程，但实际上UI不会由变化，浪费了一些性能。</p>
<p>改动之后的逻辑：</p>
<p>组件的watcher不再监听计算属性的变化,而是让计算属性的watcher得到通知后,计算一次计算属性的值，如果发现这一次计算出来的值与上一次计算出来的值不一样，再去主动通知组件的watcher进行重新渲染。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改"><a href="#♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改" class="headerlink" title="♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改"></a>♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改</h3><p>vue是单向数据流，父组件通过props传值给子组件，如果在子组件中修改会报错，一般是不在子组件中修改props的，但偶尔有需要在子组件有修改props,这里介绍三种可以修改子组件props的方法。</p>
<p>1.父组件用sync修饰，子组件通过<code>$emit(&#39;update:参数&#39;，值)</code>函数去修改。在项目中通常可以用改方法关闭弹框</p>
<pre><code class="vue">&lt;template&gt;
    //父组件
   &lt;CommonDialog
     :title=&quot;dialogTitle&quot;
     :showDialog.sync=&quot;isShowDialog&quot;
     :footer=&quot;true&quot;
     :width=&quot;dialogWidth&quot;
   &gt;
      ....
   &lt;/CommonDialog&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="vue">//子组件 弹框是否打开props: showDialog
&lt;el-dialog :title=&quot;title&quot; :visible=&quot;showDialog&quot; :show-close=&quot;false&quot; :width=&quot;width&quot;&gt;
      &lt;i class=&quot;el-dialog__headerbtn&quot; @click=&quot;closeModal&quot;&gt;
        &lt;span class=&quot;iconfont iconclose&quot;&gt;&lt;/span&gt;
      &lt;/i&gt;
      &lt;div class=&quot;dialog-body&quot;&gt;
          &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
      &lt;div v-if=&quot;!footer&quot; slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
    &lt;/el-dialog&gt;
</code></pre>
<pre><code class="javascript">//关闭弹框------子组件修改props
 closeModal() &#123;
   this.$emit(&quot;update:showDialog&quot;, false);
 &#125;,
</code></pre>
<p>2.如果props是对象，在子组件中修改props</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;csd-select&quot;&gt;
    &lt;el-popover
      placement=&quot;bottom&quot;
      :width=&quot;width&quot;
      :trigger=&quot;config.trigger&quot;
      :config=&quot;config&quot;
      transition=&quot;fade-in&quot;
      popper-class=&quot;casade-selector&quot;
      v-model=&quot;options_show&quot;
    &gt;
    ...
    &lt;/el-popover&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  name: &quot;CasadeSelector&quot;,
  props: &#123;
    config: &#123;
      type: Object,
      //让props默认返回
      default() &#123;
        return &#123;&#125;;
      &#125;
    &#125;,
  &#125;,
&lt;/script&gt;
</code></pre>
<p>3.props是双向绑定的</p>
<pre><code class="vue">&lt;template&gt;
    &lt;control v-model=&quot;deviceF&quot;&gt;&lt;/control&gt;
&lt;/template&gt;

 //v-model里面写上我们要传给子组件，并且还会在子组件中改变这个值
 &lt;script&gt;
 import control from &#39;@/components/control&#39;
 export default &#123;
    name:&quot;test&quot;,
    components: &#123;
        control
    &#125;,
    data () &#123;
        return &#123;
        deviceF: true,
        &#125;
    &#125;
&#125;
 &lt;/script&gt;
</code></pre>
<pre><code class="vue">&lt;template&gt;
   &lt;div&gt;
       &#123;&#123;device&#125;&#125;
       &lt;button @click=&quot;look&quot;&gt;改变值&lt;/button&gt;
   &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
 data () &#123;
   return &#123;
     device: this.value,  //定义一下
   &#125;
 &#125;,
 props: [&#39;value&#39;],//因为想要改变device，所以device要写成value，这里是写死的
 components: &#123;
 &#125;,
 methods: &#123;
   look () &#123;
     this.device = !this.device
     this.$emit(&#39;input&#39;, this.device)  //这样this.device就会被修改；前面的input是固定写死的
   &#125;
 &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？"><a href="#♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？" class="headerlink" title="♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？"></a>♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？</h3><p>1、问题描述：页面刷新的时候vuex里的数据会重新初始化，导致数据丢失。因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被重新赋值。</p>
<p>2、解决思路：</p>
<p>办法一：将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie） </p>
<p>办法二：在页面刷新的时候再次请求远程数据，使之动态更新vuex数据 办法三：在父页面向后台请求远程数据，并且在页面刷新前将vuex的数据先保存至sessionStorage（以防请求数据量过大页面加载时拿不到返回的数据）</p>
<p>3、 解决过程：</p>
<p>3.1、选择合适的浏览器存储</p>
<p>3.2、解决方案由于state里的数据是响应式，所以sessionStorage存储也要跟随变化，而且只能通过mutations来改变state中的值。 首先在用户登录成功之后，然后把用户信息，菜单信息通过actions分发保存至vuex中。然后在菜单页面计算vuex中state的菜单数据，将数据解析组装成前端组件所需的格式，然后渲染组件，生成菜单树。如果页面没有刷新，则一切正常。</p>
<p>监听浏览器刷新前事件，在浏览器刷新之前就把vuex里的数据保存至sessionStorage中，刷新成功后如果异步请求的数据还没返回则直接获取sessionStorage里的数据，否则获取vuex里的数据。</p>
<h3 id="♥︎♥︎♥︎♥︎什么是Vue-nextTick-？"><a href="#♥︎♥︎♥︎♥︎什么是Vue-nextTick-？" class="headerlink" title="♥︎♥︎♥︎♥︎什么是Vue.nextTick()？"></a>♥︎♥︎♥︎♥︎什么是Vue.nextTick()？</h3><p>$nextTick 是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM，意思是 等你dom加载完毕以后再去调用nextTick()里面的数据内容</p>
<hr>
<h3 id="♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object-defineProperty优劣对比？"><a href="#♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object-defineProperty优劣对比？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object.defineProperty优劣对比？"></a>♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object.defineProperty优劣对比？</h3><p>1、响应式原理</p>
<p>vue的响应式实现主要是利用了Object.defineProperty的方法里面的setter 与getter方法的观察者模式来实现。在组件初始化时会给每一个data属性注册getter和setter，然后再new 一个自己的Watcher对象，此时watcher会立即调用组件的render函数去生成虚拟DOM。在调用render的时候，就会需要用到data的属性值，此时会触发getter函数，将当前的Watcher函数注册进sub里。当data属性发生改变之后，就会遍历sub里所有的watcher对象，通知它们去重新渲染组件。</p>
<p>2、proxy的优势如下：</p>
<p>Proxy 可以直接监听对象而非属性，可以直接监听数组的变化；</p>
<p>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是</p>
<p>Object.defineProperty 不具备的；</p>
<p>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</p>
<p>3、Object.defineProperty 的优势如下:</p>
<p>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill(垫片)来弥补</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-vue-router路由实现原理"><a href="#♥︎♥︎♥︎♥︎♥︎-vue-router路由实现原理" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ vue-router路由实现原理"></a>♥︎♥︎♥︎♥︎♥︎ vue-router路由实现原理</h3><p>[vue-router路由模式]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43638968/article/details/109303363">https://blog.csdn.net/weixin_43638968/article/details/109303363</a>  “</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-Vue3中的双向数据绑定proxy"><a href="#♥︎♥︎♥︎♥︎♥︎-Vue3中的双向数据绑定proxy" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ Vue3中的双向数据绑定proxy"></a>♥︎♥︎♥︎♥︎♥︎ Vue3中的双向数据绑定proxy</h3><p>Proxy相当于在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy是Object.defineProperty的全方位加强版，它解决了之前defineProperty无法监听到数组变化等缺点。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-Vue和React中diff算法区别"><a href="#♥︎♥︎♥︎♥︎♥︎-Vue和React中diff算法区别" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ Vue和React中diff算法区别"></a>♥︎♥︎♥︎♥︎♥︎ Vue和React中diff算法区别</h3><p>vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。</p>
<p>1.vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。</p>
<p>2.vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎Vue-响应式原理"><a href="#♥︎♥︎♥︎♥︎♥︎Vue-响应式原理" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎Vue 响应式原理"></a>♥︎♥︎♥︎♥︎♥︎Vue 响应式原理</h3><p>[Vue 响应式原理]: 	“<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903561327820808">https://juejin.cn/post/6844903561327820808</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"><a href="#♥︎♥︎♥︎♥︎♥︎-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"></a>♥︎♥︎♥︎♥︎♥︎ nextTick知道吗、实现的原理是什么？是宏任务还是微任务？</h3><p>微任务</p>
<p>原理：nextTick方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空队列。</p>
<p>作用： nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick,则可以在回调中获取更新后的DOM。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-Vue项目常见优化点"><a href="#♥︎♥︎♥︎♥︎♥︎-Vue项目常见优化点" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ Vue项目常见优化点"></a>♥︎♥︎♥︎♥︎♥︎ Vue项目常见优化点</h3><p>1、首屏加载优化</p>
<p>2、路由懒加载</p>
<pre><code class="javascript">&#123; 
 path: &#39;/&#39;,
 name: &#39;home&#39;, 
 component: () =&gt; import(&#39;./views/home/index.vue&#39;), 
 meta: &#123; isShowHead: true &#125;
&#125;
</code></pre>
<p>3、开启服务器 Gzip</p>
<p>开启 Gzip 就是一种压缩技术，需要前端提供压缩包，然后在服务器开启压缩，文件在服务器压缩后传给浏览器，浏览器解压后进行再进行解析。首先安装 webpack 提供的compression-webpack-plugin进行压缩,然后在 vue.config.js：</p>
<pre><code class="javascript">const CompressionWebpackPlugin = require(&#39;compression-webpack-plugin&#39;)
const productionGzipExtensions = [&#39;js&#39;, &#39;css&#39;]......plugins: [ 
 new CompressionWebpackPlugin(
 &#123; 
 algorithm: &#39;gzip&#39;, 
 test: new RegExp(&#39;\.(&#39; + productionGzipExtensions.join(&#39;|&#39;) + &#39;)$&#39;), 
 threshold: 10240, 
 minRatio: 0.8 
 &#125;
)]....
</code></pre>
<p>4、启动 CDN 加速</p>
<p>我们继续采用 cdn 的方式来引入一些第三方资源，就可以缓解我们服务器的压力，原理是将我们的压力分给其他服务器点。</p>
<p>5、代码层面优化</p>
<p>computed 和 watch 区分使用场景</p>
<p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>
<p> watch：类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<p>v-if 和 v-show 区分使用场景 v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景。这里要说的优化点在于减少页面中 dom 总数，我比较倾向于使用 v-if，因为减少了 dom 数量。</p>
<p>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if v-for 遍历必须为 item 添加 key，循环调用子组件时添加 key，key 可以唯一标识一个循环个体，可以使用例如 item.id 作为 key 避免同时使用 v-if，vfor 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度。</p>
<p>6、Webpack 对图片进行压缩</p>
<p>7、避免内存泄漏</p>
<p>8、减少 ES6 转为 ES5 的冗余代码</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>