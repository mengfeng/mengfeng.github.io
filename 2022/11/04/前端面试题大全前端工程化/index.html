<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>前端面试题大全前端工程化 |  艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-前端面试题大全前端工程化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  前端面试题大全前端工程化
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" class="article-date">
  <time datetime="2022-11-04T03:25:24.000Z" itemprop="datePublished">2022-11-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">15.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">61 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（前端工程化）"><a href="#前端面试题大全（前端工程化）" class="headerlink" title="前端面试题大全（前端工程化）"></a>前端面试题大全（前端工程化）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="♥︎-♥︎-♥︎-什么是-bundle-什么是-chunk，什么是module？"><a href="#♥︎-♥︎-♥︎-什么是-bundle-什么是-chunk，什么是module？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是 bundle, 什么是 chunk，什么是module？"></a>♥︎ ♥︎ ♥︎ 什么是 bundle, 什么是 chunk，什么是module？</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>bundle</code>、<code>module</code>、<code>chunk</code> 都是 webpack 中的术语，下面就一个一个介绍他们的定义是什么，怎么产生的。</p>
<h5 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h5><p>Bundle是由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本。 Bundle 分离（Bundle Splitting）:这个流程提供了一个优化 build 的方法，允许 webpack 为应用程序生成多个 bundle。最终效果是，当其他某些 bundle 的改动时，彼此独立的另一些 bundle 都可以不受到影响，减少需要重新发布的代码量，因此由客户端重新下载并利用浏览器缓存。</p>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h5><p>模块（Module）提供比较完整程序接触面（surface area）更小的离散功能块。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。 模块解析（Module Resolution）一个模块可以作为另一个模块的依赖模块，resolver 是一个库（libary）用于帮助找不到模块的绝对路径，模块将在resolve.modules中指定的所有目录内搜索。</p>
<h5 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h5><p>Chunk这是 webpack 特定的术语被用在内部来管理 building 过程。bundle 是由 chunk 组成，其中有几种类型（例如，入口 chunk(entry chunk)和子 chunk(child chunk)）。通常 chunk 会直接对应所输出的 bundle，但是有一些配置并不会产生一对一的关系。 代码分离（Code Splitting）指将代码分离到每个 bundles&#x2F;chunks 里面，你可以按需加载，而不是加载一个包含全部的 bundle。 配置（Configuration）webpack 的配置文件是一个普通的 JavaScript 文件，它导出为一个对象。然后由 webpack 根据这个对象定义的属性进行处理。</p>
<h4 id="Bundle-VS-Chunk-VS-Module"><a href="#Bundle-VS-Chunk-VS-Module" class="headerlink" title="Bundle VS Chunk VS Module"></a>Bundle VS Chunk VS Module</h4><p>我们从定义和时期来说：</p>
<ul>
<li>“模块”<code>(module)</code>的概念大家都比较熟悉，如 <code>CommonJS 模块</code>、<code>AMD</code>、<code>ES6 Modules</code> 模块</li>
<li><code>chunk</code> 表示打包的时候产生得模块，由他来组成 <code>bundle</code></li>
<li>打包完成的源代码</li>
</ul>
<p>我们现在就只创建一个能编译<code>js</code>的<code>webpack</code>配置，步骤如下：</p>
<ol>
<li>创建一个空文件夹，并且在当文件夹中打开 <code>bash or cmd</code>。</li>
<li><code>npm init -y</code> 生成<code>package.json</code>。</li>
<li>如果你安装了<code>cnpm or yarn</code> 就执行 <code>cnpm i webpack webpack-cli -D</code>, 安装<code>webpack</code>的包。</li>
<li>创建<code>src</code>，在<code>src</code>内部创建<code>chunk0.js</code>、<code>chunk1.js</code>、<code>common.js</code>、<code>index.js</code>、<code>style.css</code>，并且编写内部代码</li>
<li>在项目根目录创建 <code>webpack.config.js</code></li>
<li>直接在<code>cmd</code>中运行 <code>webpack</code></li>
</ol>
<p>下面是代码 </p>
<p>chunk0.js</p>
<pre><code class="javascript">export default function add(a, b) &#123;
  return a + b;
&#125;
</code></pre>
<p>chunk1.js</p>
<pre><code class="javascript">export default function flow() &#123;
  return &quot;flow&quot;;
&#125;
</code></pre>
<p>common.js</p>
<pre><code class="javascript">export default function commonJs() &#123;
  return &quot;commonJs&quot;;
&#125;
</code></pre>
<p>index.js</p>
<pre><code class="javascript">import add from &quot;./chunk0.js&quot;;
import commonJs from &quot;./common&quot;;
console.log(add(1, 2));
console.log(commonJs());
</code></pre>
<p>webpack.config.js</p>
<pre><code class="java">module.exports = &#123;
  mode: &quot;production&quot;, // 如果不添加就会警告
  entry: &#123;
    index: &quot;./src/index.js&quot;, // 一个入口文件
    chunk1: &quot;./src/chunk1.js&quot; // 两一个入口文件
  &#125;,
  output: &#123;
    filename: &quot;[name].bundle.js&quot; // 出口文件
  &#125;
&#125;;
</code></pre>
<p>运行的效果如下</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image-20221104082742567.png"></p>
<p>通过上面的代码知道，<code>module</code> 就是没有被编译之前的代码，通过 <code>webpack</code> 的根据文件引用关系生成 <code>chunk</code> 文件，webpack 处理好 <code>chunk</code> 文件后，生成运行在浏览器中的代码 <code>bundle</code>。</p>
<h3 id="♥︎-♥︎-♥︎-hash-chunkhash-contenthash三者区别"><a href="#♥︎-♥︎-♥︎-hash-chunkhash-contenthash三者区别" class="headerlink" title="♥︎ ♥︎ ♥︎ hash chunkhash contenthash三者区别"></a>♥︎ ♥︎ ♥︎ hash chunkhash contenthash三者区别</h3><h4 id="一、Webpack与hash算法"><a href="#一、Webpack与hash算法" class="headerlink" title="一、Webpack与hash算法"></a>一、Webpack与hash算法</h4><p>在使用Webpack对构建的时候，Webpack会根据所有的文件内容计算出一个特殊的字符串。只要有文件的内容变化了，Webpack就会计算出一个新的特殊字符串。</p>
<p>Webpack在根据文件内容计算出一个特殊字符串的时候，使用的就是hash算法，这个特殊字符串一般叫做hash值。</p>
<p>我们一般取计算出的特殊字符串的前八位作为文件名的一部分，因为hash算法计算出的前八位基本可以保证唯一性了。</p>
<p>在Webpack里，我们通常用[hash:8]这种形式表示取hash值的前八位，例如在Webpack配置文件中，我们用 filename: ‘jQuery-[hash:8].js’。</p>
<h4 id="二、webpack中hash、chunkhash和contenthash的区别"><a href="#二、webpack中hash、chunkhash和contenthash的区别" class="headerlink" title="二、webpack中hash、chunkhash和contenthash的区别"></a>二、webpack中hash、chunkhash和contenthash的区别</h4><p>Webpack通过对文件进行hash算法获得的hash值，除了有hash，还有chunkhash和contenthash，那么这三者有什么不同呢？</p>
<p>首先，hash、chunkhash和contenthash这三者都是根据文件内容计算出的hash值，只是它们所计算的文件不一样。</p>
<p>hash是根据打包中所有的文件计算出的hash值。在一次打包中，所有出口文件的filename获得的[hash]都是一样的。</p>
<p>chunkhash是根据打包过程中当前chunk计算出的hash值。如果Webpack配置是多入口配置，那么通常会生成多个chunk，每个chunk对应的出口filename获得的[chunkhash]是不一样的。这样可以保证打包后每一个JS文件名都不一样（这么说不太严谨，但有助于理解）。</p>
<p>Webpack配置文件如下，第一次打包filename取值为’[name]-[hash:8].js’，第二次为’[name]-[chunkhash:8].js’。</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
module.exports = &#123;
    entry: &#123;
        app1: &#39;./a.js&#39;,
        app2: &#39;./b.js&#39;,
        app3: &#39;./c.js&#39;,
&#125;,
output: &#123;
path: path.resolve(__dirname, &#39;&#39;),
filename: &#39;[name]-[hash:8].js&#39;
// filename: &#39;[name]-[chunkhash:8].js&#39;
&#125;,
mode: &#39;none&#39;
&#125;;
</code></pre>
<p>contenthash有点像chunkhash，是根据打包时CSS内容计算出的hash值。一般在使用提取CSS的插件的时候，我们使用contenthash。例如下面的配置，我们生成的CSS文件名可能会是main.3aa2e3c6.css。</p>
<pre><code class="javascript">plugins:[
new miniExtractPlugin(&#123;
        filename: &#39;main.[contenthash:8].css&#39;
&#125;)
]
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Webpack中hash、chunkhash和contenthash主要与浏览器缓存行为有关。浏览器在初次请求服务端资源的时候，服务器给JS、CSS和图片等资源一个较长的缓存时间，我们通过给资源名称增加hash值来控制浏览器是否继续使用本地缓存。hash、chunkhash和contenthash这三者都是根据文件内容计算出的hash值，[hash]是根据全部参与打包的文件计算出来的，[chunkhash]是根据当前打包的chunk计算出来的，[contenthash]是CSS文件的。</p>
<h3 id="♥︎-♥︎-♥︎-你知道什么是脚手架吗？"><a href="#♥︎-♥︎-♥︎-你知道什么是脚手架吗？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你知道什么是脚手架吗？"></a>♥︎ ♥︎ ♥︎ 你知道什么是脚手架吗？</h3><p>脚手架的概念和作用：就是拥有完整的开发环境，帮助我们快速的生成一套既定的项目架构、文件、配置。使用者只需要专注自己的业务代码即可，不需要使用者单独配置 </p>
<p>脚手架的构成：常见的脚手架的开发环境主要分为三种模式：生产模式，开发模式，测试模式。以及需要配置完整的路由系统(vue-router,react-router-dom)，和状态管理系统(vuex,redux)才能保证开发环境的完整性 </p>
<p>常见的脚手架：Vue-cli,Creat-React-app,umi-app</p>
<h3 id="♥︎-♥︎-♥︎-你对webpack的理解？解决了什么问题？"><a href="#♥︎-♥︎-♥︎-你对webpack的理解？解决了什么问题？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你对webpack的理解？解决了什么问题？"></a>♥︎ ♥︎ ♥︎ 你对webpack的理解？解决了什么问题？</h3><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p><code>Webpack</code> 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p>
<h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的<code> JS</code> 文件中</p>
<p>约定每个文件是一个独立的模块，然后再将这些<code>js</code>文件引入到页面，一个<code>script</code>标签对应一个模块，然后调用模块化的成员</p>
<pre><code class="ini">&lt;script src=&quot;module-a.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;module-b.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题</p>
<p>项目一旦变大，上述问题会尤其明显</p>
<p>随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p>
<pre><code class="javascript">window.moduleA = &#123;
  method1: function () &#123;
    console.log(&#39;moduleA#method1&#39;)
  &#125;
&#125;
</code></pre>
<p>这种方式也并没有解决第一种方式的依赖等问题</p>
<p>再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下</p>
<pre><code class="javascript">// module-a.js
(function ($) &#123;
  var name = &#39;module-a&#39;

  function method1 () &#123;
    console.log(name + &#39;#method1&#39;)
    $(&#39;body&#39;).animate(&#123; margin: &#39;200px&#39; &#125;)
  &#125;
    
  window.moduleA = &#123;
    method1: method1
  &#125;
&#125;)(jQuery)
</code></pre>
<p>上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过<code>script</code>标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦</p>
<p>理想的解决方式是，在页面中引入一个<code>JS</code>入口文件，其余用到的模块可以通过代码控制，按需加载进来</p>
<p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS </code>、<code>ES Modules</code></p>
<h4 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h4><p>从后端渲染的<code>JSP</code>、<code>PHP</code>，到前端原生<code>JavaScript</code>，再到<code>jQuery</code>开发，再到目前的三大框架<code>Vue</code>、<code>React</code>、<code>Angular</code></p>
<p>开发方式，也从<code>javascript</code>到后面的<code>es5</code>、<code>es6、7、8、9、10</code>，再到<code>typescript</code>，包括编写<code>CSS</code>的预处理器<code>less</code>、<code>scss</code>等</p>
<p>现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：</p>
<ul>
<li>需要通过模块化的方式来开发</li>
<li>使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码</li>
<li>监听文件的变化来并且反映到浏览器上，提高开发的效率</li>
<li>JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题</li>
<li>开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化</li>
</ul>
<p>而<code>webpack</code>恰巧可以解决以上问题</p>
<h4 id="三、是什么"><a href="#三、是什么" class="headerlink" title="三、是什么"></a>三、是什么</h4><p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具</p>
<ul>
<li>静态模块</li>
</ul>
<p>这里的静态模块指的是开发阶段，可以被 <code>webpack</code> 直接引用的资源（可以直接被获取打包进<code>bundle.js</code>的资源）</p>
<p>当 <code>webpack </code>处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限<code>js</code>文件），并生成一个或多个 <code>bundle</code></p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39636531393461302d613537382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="webpack的能力："><a href="#webpack的能力：" class="headerlink" title="webpack的能力："></a><code>webpack</code>的能力：</h5><p>编译代码能力，提高效率，解决浏览器兼容问题<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63356332643336302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"><br>模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64333036643236302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"><br>万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65336335613034302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-webpack的核心思想是什么"><a href="#♥︎-♥︎-♥︎-webpack的核心思想是什么" class="headerlink" title="♥︎ ♥︎ ♥︎ webpack的核心思想是什么"></a>♥︎ ♥︎ ♥︎ webpack的核心思想是什么</h3><p>万物皆模块：在webpacck的世界中，其他任何资源都可以当做模块的方式引入 </p>
<p>代码分割：webapp 的优化关键在于代码体积，当应用体积增大，实现代码的按需加载是刚需，这也是 webpack 出现的根本原因 </p>
<p>可定制化：任何一个工具都不可能解决所有问题，提供解决方案才是最可行的，webpack基于可定制化的理念构建，通过插件系统，配置文件，可实现大型项目的定制需求</p>
<h3 id="♥︎-♥︎-♥︎-说说webpack的构建流程"><a href="#♥︎-♥︎-♥︎-说说webpack的构建流程" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说webpack的构建流程?"></a>♥︎ ♥︎ ♥︎ 说说webpack的构建流程?</h3><h4 id="一、运行流程"><a href="#一、运行流程" class="headerlink" title="一、运行流程"></a>一、运行流程</h4><p><code>webpack</code> 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来</p>
<p>在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条<code>webpack</code>机制中，去改变<code>webpack</code>的运作，使得整个系统扩展性良好</p>
<p>从启动到结束会依次执行以下三大步骤：</p>
<ul>
<li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li>编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>
<li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li>
</ul>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62353636643430302d613635382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h5><p>从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数</p>
<p>配置文件默认下为<code>webpack.config.js</code>，也或者通过命令的形式指定配置文件，主要作用是用于激活<code>webpack</code>的加载项和插件</p>
<p>关于文件配置内容分析，如下注释：</p>
<pre><code class="javascript">var path = require(&#39;path&#39;);
var node_modules = path.resolve(__dirname, &#39;node_modules&#39;);
var pathToReact = path.resolve(node_modules, &#39;react/dist/react.min.js&#39;);

module.exports = &#123;
  // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。
  entry: &#39;./path/to/my/entry/file.js&#39;，
  // 文件路径指向(可加快打包过程)。
  resolve: &#123;
    alias: &#123;
      &#39;react&#39;: pathToReact
    &#125;
  &#125;,
  // 生成文件，是模块构建的终点，包括输出文件与输出路径。
  output: &#123;
    path: path.resolve(__dirname, &#39;build&#39;),
    filename: &#39;[name].js&#39;
  &#125;,
  // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。
  module: &#123;
    loaders: [
      &#123;
        test: /\.js$/,
        loader: &#39;babel&#39;,
        query: &#123;
          presets: [&#39;es2015&#39;, &#39;react&#39;]
        &#125;
      &#125;
    ],
    noParse: [pathToReact]
  &#125;,
  // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
&#125;;
webpack` 将 `webpack.config.js` 中的各个配置项拷贝到 `options` 对象中，并加载用户配置的 `plugins
</code></pre>
<p>完成上述步骤之后，则开始初始化<code>Compiler</code>编译对象，该对象掌控者<code>webpack</code>声明周期，不执行具体的任务，只是进行一些调度工作</p>
<pre><code class="javascript">class Compiler extends Tapable &#123;
    constructor(context) &#123;
        super();
        this.hooks = &#123;
            beforeCompile: new AsyncSeriesHook([&quot;params&quot;]),
            compile: new SyncHook([&quot;params&quot;]),
            afterCompile: new AsyncSeriesHook([&quot;compilation&quot;]),
            make: new AsyncParallelHook([&quot;compilation&quot;]),
            entryOption: new SyncBailHook([&quot;context&quot;, &quot;entry&quot;])
            // 定义了很多不同类型的钩子
        &#125;;
        // ...
    &#125;
&#125;

function webpack(options) &#123;
  var compiler = new Compiler();
  ...// 检查options,若watch字段为true,则开启watch线程
  return compiler;
&#125;
...
</code></pre>
<p><code>Compiler</code> 对象继承自 <code>Tapable</code>，初始化时定义了很多钩子函数</p>
<h5 id="编译构建流程"><a href="#编译构建流程" class="headerlink" title="编译构建流程"></a>编译构建流程</h5><p>根据配置中的 <code>entry</code> 找出所有的入口文件</p>
<pre><code class="javascript">module.exports = &#123;
  entry: &#39;./src/file.js&#39;
&#125;
</code></pre>
<p>初始化完成后会调用<code>Compiler</code>的<code>run</code>来真正启动<code>webpack</code>编译构建流程，主要流程如下：</p>
<ul>
<li><code>compile</code> 开始编译</li>
<li><code>make</code> 从入口点分析模块及其依赖的模块，创建这些模块对象</li>
<li><code>build-module</code> 构建模块</li>
<li><code>seal</code> 封装构建结果</li>
<li><code>emit</code> 把各个chunk输出到结果文件</li>
</ul>
<h5 id="compile-编译"><a href="#compile-编译" class="headerlink" title="compile 编译"></a>compile 编译</h5><p>执行了<code>run</code>方法后，首先会触发<code>compile</code>，主要是构建一个<code>Compilation</code>对象</p>
<p>该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象</p>
<h5 id="make-编译模块"><a href="#make-编译模块" class="headerlink" title="make 编译模块"></a>make 编译模块</h5><p>当完成了上述的<code>compilation</code>对象后，就开始从<code>Entry</code>入口文件开始读取，主要执行<code>_addModuleChain()</code>函数，如下：</p>
<pre><code class="javascript">_addModuleChain(context, dependency, onModule, callback) &#123;
   ...
   // 根据依赖查找对应的工厂函数
   const Dep = /** @type &#123;DepConstructor&#125; */ (dependency.constructor);
   const moduleFactory = this.dependencyFactories.get(Dep);
   
   // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象
   moduleFactory.create(&#123;
       dependencies: [dependency]
       ...
   &#125;, (err, module) =&gt; &#123;
       ...
       const afterBuild = () =&gt; &#123;
        this.processModuleDependencies(module, err =&gt; &#123;
         if (err) return callback(err);
         callback(null, module);
           &#125;);
    &#125;;
       
       this.buildModule(module, false, null, null, err =&gt; &#123;
           ...
           afterBuild();
       &#125;)
   &#125;)
&#125;
</code></pre>
<p>过程如下：</p>
<p><code>_addModuleChain</code>中接收参数<code>dependency</code>传入的入口依赖，使用对应的工厂函数<code>NormalModuleFactory.create</code>方法生成一个空的<code>module</code>对象</p>
<p>回调中会把此<code>module</code>存入<code>compilation.modules</code>对象和<code>dependencies.module</code>对象中，由于是入口文件，也会存入<code>compilation.entries</code>中</p>
<p>随后执行<code>buildModule</code>进入真正的构建模块<code>module</code>内容的过程</p>
<h5 id="build-module-完成模块编译"><a href="#build-module-完成模块编译" class="headerlink" title="build module 完成模块编译"></a>build module 完成模块编译</h5><p>这里主要调用配置的<code>loaders</code>，将我们的模块转成标准的<code>JS</code>模块</p>
<p>在用<code> Loader</code> 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 <code>Webpack </code>后面对代码的分析</p>
<p>从配置的入口模块开始，分析其 <code>AST</code>，当遇到<code>require</code>等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</p>
<h5 id="输出流程"><a href="#输出流程" class="headerlink" title="输出流程"></a>输出流程</h5><h5 id="seal-输出资源"><a href="#seal-输出资源" class="headerlink" title="seal 输出资源"></a>seal 输出资源</h5><p><code>seal</code>方法主要是要生成<code>chunks</code>，对<code>chunks</code>进行一系列的优化操作，并生成要输出的代码</p>
<p><code>webpack</code> 中的 <code>chunk</code> ，可以理解为配置在 <code>entry</code> 中的模块，或者是动态引入的模块</p>
<p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表</p>
<h5 id="emit-输出完成"><a href="#emit-输出完成" class="headerlink" title="emit 输出完成"></a>emit 输出完成</h5><p>在确定好输出内容后，根据配置确定输出的路径和文件名</p>
<pre><code class="javascript">output: &#123;
    path: path.resolve(__dirname, &#39;build&#39;),
        filename: &#39;[name].js&#39;
&#125;
</code></pre>
<p>在 <code>Compiler</code> 开始生成文件前，钩子 <code>emit</code> 会被执行，这是我们修改最终文件的最后一个机会</p>
<p>从而<code>webpack</code>整个打包过程则结束了</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64373766633536302d613635382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-Loader和Plugin的区别"><a href="#♥︎-♥︎-♥︎-Loader和Plugin的区别" class="headerlink" title="♥︎ ♥︎ ♥︎  Loader和Plugin的区别"></a>♥︎ ♥︎ ♥︎  Loader和Plugin的区别</h3><h4 id="loader是一个转换器"><a href="#loader是一个转换器" class="headerlink" title="loader是一个转换器"></a>loader是一个转换器</h4><p>1、用于对模块源码文件的预编译和转换，，loader描述了webpack如何处理非javascript模块。</p>
<p>2、没有loader，构建的打包过程无法顺利完成</p>
<p>3、loader作用在打包前</p>
<p>4、将A文件转换为B文件，操作的是文件，比如将A.scss转换为A.css，是单纯的文件转换过程</p>
<h4 id="Plugin是插件扩展器"><a href="#Plugin是插件扩展器" class="headerlink" title="Plugin是插件扩展器"></a>Plugin是插件扩展器</h4><p>1、plugin构建过程更完整的补充和优化，如使用new UglifyJsPlugin(),new CssMinimizerPlugin()压缩js和css</p>
<p>2、没有plugin，文件的打包过程可以完成</p>
<p>3、plugin作用于整个打包过程，</p>
<p>4、针对webpack的打包过程，他不直接操作文件，而是基于事件机制工作，会监听webpack打包过程的事件钩子，执行任务，通过事件钩子拦截webpack的执行。</p>
<h3 id="♥︎-♥︎-♥︎-有哪些常见的Loader"><a href="#♥︎-♥︎-♥︎-有哪些常见的Loader" class="headerlink" title="♥︎ ♥︎ ♥︎ 有哪些常见的Loader"></a>♥︎ ♥︎ ♥︎ 有哪些常见的Loader</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>loader</code> 用于对模块的”源代码”进行转换，在 <code>import</code> 或”加载”模块时预处理文件</p>
<p><code>webpack</code>做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。如下图所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37623864393634302d613666662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在<code>webpack</code>内部中，任何文件都是模块，不仅仅只是<code>js</code>文件</p>
<p>默认情况下，在遇到<code>import</code>或者<code>load</code>加载模块的时候，<code>webpack</code>只支持对<code>js</code>文件打包</p>
<p>像<code>css</code>、<code>sass</code>、<code>png</code>等这些类型的文件的时候，<code>webpack</code>则无能为力，这时候就需要配置对应的<code>loader</code>进行文件内容的解析</p>
<p>在加载模块的时候，执行顺序如下：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39633263343362302d613666662d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>当 <code>webpack</code> 碰到不识别的模块的时候，<code>webpack</code> 会在配置的中查找该文件解析规则</p>
<p>关于配置<code>loader</code>的方式有三种：</p>
<ul>
<li>配置方式（推荐）：在 webpack.config.js文件中指定 loader</li>
<li>内联方式：在每个 import 语句中显式指定 loader</li>
<li>CLI 方式：在 shell 命令中指定它们</li>
</ul>
<h5 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h5><p>关于<code>loader</code>的配置，我们是写在<code>module.rules</code>属性中，属性介绍如下：</p>
<ul>
<li><code>rules</code>是一个数组的形式，因此我们可以配置很多个<code>loader</code></li>
<li>每一个<code>loader</code>对应一个对象的形式，对象属性<code>test</code> 为匹配的规则，一般情况为正则表达式</li>
<li>属性<code>use</code>针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</li>
</ul>
<p>代码编写，如下形式：</p>
<pre><code class="javascript">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        test: /\.css$/,
        use: [
          &#123; loader: &#39;style-loader&#39; &#125;,
          &#123;
            loader: &#39;css-loader&#39;,
            options: &#123;
              modules: true
            &#125;
          &#125;,
          &#123; loader: &#39;sass-loader&#39; &#125;
        ]
      &#125;
    ]
  &#125;
&#125;;
</code></pre>
<h4 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h4><p>这里继续拿上述代码，来讲讲<code>loader</code>的特性</p>
<p>从上述代码可以看到，在处理<code>css</code>模块的时候，<code>use</code>属性中配置了三个<code>loader</code>分别处理<code>css</code>文件</p>
<p>因为<code>loader </code>支持链式调用，链中的每个<code>loader</code>会处理之前已处理过的资源，最终变为<code>js</code>代码。顺序为相反的顺序执行，即上述执行方式为<code>sass-loader</code>、<code>css-loader</code>、<code>style-loader</code></p>
<p>除此之外，<code>loader</code>的特性还有如下：</p>
<ul>
<li>loader 可以是同步的，也可以是异步的</li>
<li>loader 运行在 Node.js 中，并且能够执行任何操作</li>
<li>除了常见的通过 <code>package.json</code> 的 <code>main</code> 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 <code>loader</code> 字段直接引用一个模块</li>
<li>插件(plugin)可以为 loader 带来更多特性</li>
<li>loader 能够产生额外的任意文件</li>
</ul>
<p>可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和更多其他特性</p>
<h4 id="三、常见的loader"><a href="#三、常见的loader" class="headerlink" title="三、常见的loader"></a>三、常见的loader</h4><p>在页面开发过程中，我们经常性加载除了<code>js</code>文件以外的内容，这时候我们就需要配置响应的<code>loader</code>进行加载</p>
<p>常见的<code>loader</code>如下：</p>
<ul>
<li>style-loader: 将css添加到DOM的内联样式标签style里</li>
<li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li>
<li>less-loader: 处理less</li>
<li>sass-loader: 处理sass</li>
<li>postcss-loader: 用postcss来处理CSS</li>
<li>autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss</li>
<li>file-loader: 分发文件到output目录并返回相对路径</li>
<li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li>
<li>html-minify-loader: 压缩HTML</li>
<li>babel-loader :用babel来转换ES6文件到ES</li>
</ul>
<p>下面给出一些常见的<code>loader</code>的使用：</p>
<h5 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h5><p>分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p>
<pre><code class="javascript">npm install --save-dev css-loader
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: &#123;
      loader: &quot;css-loader&quot;,
      options: &#123;
     // 启用/禁用 url() 处理
     url: true,
     // 启用/禁用 @import 处理
     import: true,
        // 启用/禁用 Sourcemap
        sourceMap: false
      &#125;
    &#125;
 &#125;
]
</code></pre>
<p>如果只通过<code>css-loader</code>加载文件，这时候页面代码设置的样式并没有生效</p>
<p>原因在于，<code>css-loader</code>只是负责将<code>.css</code>文件进行一个解析，而并不会将解析后的<code>css</code>插入到页面中</p>
<p>如果我们希望再完成插入<code>style</code>的操作，那么我们还需要另外一个<code>loader</code>，就是<code>style-loader</code></p>
<h5 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h5><p>把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到页面的 <code>head</code> 中</p>
<pre><code class="javascript">npm install --save-dev style-loader
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;]
 &#125;
]
</code></pre>
<p>同一个任务的 <code>loader</code> 可以同时挂载多个，处理顺序为：从右到左，从下往上</p>
<h5 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h5><p>开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高，这里需要使用<code>less-loader</code></p>
<pre><code class="javascript">npm install less-loader -D
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;,&quot;less-loader&quot;]
 &#125;
]
</code></pre>
<h5 id="raw-loader"><a href="#raw-loader" class="headerlink" title="raw-loader"></a>raw-loader</h5><p>在 <code>webpack </code>中通过 <code>import </code>方式导入文件内容，该<code>loader </code>并不是内置的，所以首先要安装</p>
<pre><code class="shell">npm install --save-dev raw-loader
</code></pre>
<p>然后在 webpack.config.js 中进行配置</p>
<pre><code class="javascript">module.exports = &#123;  
...,  
module: &#123;      
rules: [      
&#123;        
test: /\.(txt|md)$/,  
use: &#39;raw-loader&#39;   
&#125;   
] &#125;&#125;
</code></pre>
<h5 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h5><p>把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串)</p>
<pre><code class="javascript">npm install --save-dev file-loader
rules: [  ..., &#123;  
test: /\.(png|jpe?g|gif)$/,    
use: &#123;      
loader: &quot;file-loader&quot;,  
options: &#123;       
// placeholder 占位符 [name] 源资源模块的名称        
// [ext] 源资源模块的后缀       
name: &quot;[name]_[hash].[ext]&quot;,        //打包后的存放位置        
outputPath: &quot;./images&quot;,        // 打包后文件的 url        
publicPath: &#39;./images&#39;,      &#125;    &#125; &#125;]
</code></pre>
<h5 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h5><p>可以处理理 <code>file-loader</code> 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code> 格式的字符串，并打包到 <code>js</code> 中，对小体积的图片比较合适，大图片不合适。</p>
<pre><code class="javascript">npm install --save-dev url-loader
rules: [  ..., &#123;  
        test: /\.(png|jpe?g|gif)$/,    
        use: &#123;     
        loader: &quot;url-loader&quot;,      
        options: &#123;        
        // placeholder 占位符 [name] 源资源模块的名称        
        // [ext] 源资源模块的后缀        
        name: &quot;[name]_[hash].[ext]&quot;,        //打包后的存放位置        
        outputPath: &quot;./images&quot;        // 打包后文件的 url        
        publicPath: &#39;./images&#39;,        // 小于 100 字节转成 base64 格式        limit: 100      &#125;    &#125; &#125;]
</code></pre>
<h3 id="♥︎-♥︎-♥︎-有哪些常见的Plugin"><a href="#♥︎-♥︎-♥︎-有哪些常见的Plugin" class="headerlink" title="♥︎ ♥︎ ♥︎ 有哪些常见的Plugin"></a>♥︎ ♥︎ ♥︎ 有哪些常见的Plugin</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>Plugin</code>（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能</p>
<p>是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据</p>
<p><code>webpack</code>中的<code>plugin</code>也是如此，<code>plugin</code>赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 <code>webpack</code> 的不同阶段（钩子 &#x2F; 生命周期），贯穿了<code>webpack</code>整个编译周期</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39613034656334302d613763322d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>目的在于解决<code>loader</code> 无法实现的其他事</p>
<h5 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h5><p>这里讲述文件的配置方式，一般情况，通过配置文件导出对象中<code>plugins</code>属性传入<code>new</code>实例对象。如下所示：</p>
<pre><code class="javascript">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); // 通过 npm 安装
const webpack = require(&#39;webpack&#39;); // 访问内置的插件
module.exports = &#123;
  ...
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin(&#123; template: &#39;./src/index.html&#39; &#125;),
  ],
&#125;;
</code></pre>
<h4 id="二、特性-1"><a href="#二、特性-1" class="headerlink" title="二、特性"></a>二、特性</h4><p>其本质是一个具有<code>apply</code>方法<code>javascript</code>对象</p>
<p><code>apply</code> 方法会被 <code>webpack compiler </code>调用，并且在整个编译生命周期都可以访问 <code>compiler </code>对象</p>
<pre><code class="javascript">const pluginName = &#39;ConsoleLogOnBuildWebpackPlugin&#39;;

class ConsoleLogOnBuildWebpackPlugin &#123;
  apply(compiler) &#123;
    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;
      console.log(&#39;webpack 构建过程开始！&#39;);
    &#125;);
  &#125;
&#125;

module.exports = ConsoleLogOnBuildWebpackPlugin;
</code></pre>
<p><code>compiler hook</code> 的 <code>tap </code>方法的第一个参数，应是驼峰式命名的插件名称</p>
<p>关于整个编译生命周期钩子，有如下：</p>
<ul>
<li>entry-option ：初始化 option</li>
<li>run</li>
<li>compile： 真正开始的编译，在创建 compilation 对象之前</li>
<li>compilation ：生成好了 compilation 对象</li>
<li>make 从 entry 开始递归分析依赖，准备对每个模块进行 build</li>
<li>after-compile： 编译 build 过程结束</li>
<li>emit ：在将内存中 assets 内容写到磁盘文件夹之前</li>
<li>after-emit ：在将内存中 assets 内容写到磁盘文件夹之后</li>
<li>done： 完成所有的编译过程</li>
<li>failed： 编译失败的时候</li>
</ul>
<h4 id="三、常见的Plugin"><a href="#三、常见的Plugin" class="headerlink" title="三、常见的Plugin"></a>三、常见的Plugin</h4><p>常见的<code>plugin</code>有如图所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643734393430302d613763322d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>下面介绍几个常用的插件用法：</p>
<h5 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h5><p>在打包结束后，⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code> js</code> 模块引⼊到该 <code>html</code> 中</p>
<pre><code class="javascript">npm install --save-dev html-webpack-plugin
// webpack.config.js
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
module.exports = &#123;
 ...
  plugins: [
     new HtmlWebpackPlugin(&#123;
       title: &quot;My App&quot;,
       filename: &quot;app.html&quot;,
       template: &quot;./src/html/index.html&quot;
     &#125;) 
  ]
&#125;;
&lt;!--./src/html/index.html--&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;%=htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;html-webpack-plugin&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在 <code>html</code> 模板中，可以通过 <code>&lt;%=htmlWebpackPlugin.options.XXX%&gt;</code> 的方式获取配置的值</p>
<p>更多的配置可以自寻查找</p>
<h5 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h5><p>删除（清理）构建目录</p>
<pre><code class="javascript">npm install --save-dev clean-webpack-plugin
const &#123;CleanWebpackPlugin&#125; = require(&#39;clean-webpack-plugin&#39;);
module.exports = &#123;
 ...
  plugins: [
    ...,
    new CleanWebpackPlugin(),
    ...
  ]
&#125;
</code></pre>
<h5 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h5><p>提取 <code>CSS</code> 到一个单独的文件中</p>
<pre><code class="javascript">npm install --save-dev mini-css-extract-plugin
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
module.exports = &#123; ...,  
                  module: &#123;   
                  rules: [    
                  &#123;     test: /\.s[ac]ss$/,     
                  use: [     
                  &#123;      loader: MiniCssExtractPlugin.loader     &#125;,          
  &#39;css-loader&#39;,          &#39;sass-loader&#39;        ]   &#125;   ] &#125;,  
    plugins: [    ...,    
              new MiniCssExtractPlugin(&#123;     filename: &#39;[name].css&#39;    &#125;),    ...  ]&#125;
</code></pre>
<h5 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h5><p>允许在编译时创建配置的全局对象，是一个<code>webpack</code>内置的插件，不需要安装</p>
<pre><code class="javascript">const &#123; DefinePlugun &#125; = require(&#39;webpack&#39;)module.exports = &#123; ...    plugins:[        new DefinePlugin(&#123;            BASE_URL:&#39;&quot;./&quot;&#39;        &#125;)    ]&#125;
</code></pre>
<p>这时候编译<code>template</code>模块的时候，就能通过下述形式获取全局对象</p>
<pre><code class="javascript">&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL%&gt;favicon.ico&gt;&quot;
</code></pre>
<h5 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h5><p>复制文件或目录到执行区域，如<code>vue</code>的打包过程中，如果我们将一些文件放到<code>public</code>的目录下，那么这个目录会被复制到<code>dist</code>文件夹中</p>
<pre><code class="javascript">npm install copy-webpack-plugin -D
new CopyWebpackPlugin(&#123;    parrerns:[        &#123;            
  from:&quot;public&quot;,            
  globOptions:&#123;                i
               gnore:[                    &#39;**/index.html&#39;                ]            &#125;        &#125;    ]&#125;)
</code></pre>
<p>复制的规则在<code>patterns</code>属性中设置：</p>
<ul>
<li>from：设置从哪一个源中开始复制</li>
<li>to：复制到的位置，可以省略，会默认复制到打包的目录下</li>
<li>globOptions：设置一些额外的选项，其中可以编写需要忽略的文件</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-说一下-Webpack-的热更新原理"><a href="#♥︎-♥︎-♥︎-说一下-Webpack-的热更新原理" class="headerlink" title="♥︎ ♥︎ ♥︎ 说一下 Webpack 的热更新原理"></a>♥︎ ♥︎ ♥︎ 说一下 Webpack 的热更新原理</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>HMR </code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</p>
<p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失</p>
<p>如果使用的是 <code>HMR</code>，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用</p>
<p>在<code>webpack</code>中配置开启热模块也非常的简单，如下代码：</p>
<pre><code class="javascript">const webpack = require(&#39;webpack&#39;)
module.exports = &#123;
  // ...
  devServer: &#123;
    // 开启 HMR 特性
    hot: true
    // hotOnly: true
  &#125;
&#125;
</code></pre>
<p>通过上述这种配置，如果我们修改并保存<code>css</code>文件，确实能够以不刷新的形式更新到页面中</p>
<p>但是，当我们修改并保存<code>js</code>文件之后，页面依旧自动刷新了，这里并没有触发热模块</p>
<p>所以，<code>HMR </code>并不像 <code>Webpack</code> 的其他特性一样可以开箱即用，需要有一些额外的操作</p>
<p>我们需要去指定哪些模块发生更新时进行<code>HRM</code>，如下代码：</p>
<pre><code class="javascript">if(module.hot)&#123;
    module.hot.accept(&#39;./util.js&#39;,()=&gt;&#123;
        console.log(&quot;util.js更新了&quot;)
    &#125;)
&#125;
</code></pre>
<h4 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h4><p>首先来看看一张图，如下：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61646330353738302d616364342d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<ul>
<li>Webpack Compile：将 JS 源代码编译成 bundle.js</li>
<li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li>
<li>Bundle Server：静态资源文件服务器，提供文件访问路径</li>
<li>HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化</li>
<li>bundle.js：构建输出的文件</li>
<li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li>
</ul>
<p>上面图中，可以分成两个阶段：</p>
<ul>
<li>启动阶段为上图 1 - 2 - A - B</li>
</ul>
<p>在编写未经过<code>webpack</code>打包的源代码后，<code>Webpack Compile</code> 将源代码和 <code>HMR Runtime</code> 一起编译成 <code>bundle </code>文件，传输给<code> Bundle Server</code> 静态资源服务器</p>
<ul>
<li>更新阶段为上图 1 - 2 - 3 - 4</li>
</ul>
<p>当某一个文件或者模块发生变化时，<code>webpack </code>监听到文件变化对文件重新编译打包，编译生成唯一的<code>hash</code>值，这个<code>hash </code>值用来作为下一次热更新的标识</p>
<p>根据变化的内容生成两个补丁文件：<code>manifest</code>（包含了 <code>hash</code> 和 <code>chundId </code>，用来说明变化的内容）和<code> chunk.js</code> 模块</p>
<p>由于<code>socket</code>服务器在<code>HMR Runtime</code> 和 <code>HMR Server</code>之间建立 <code>websocket</code>链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的<code>hash</code>值，如下图的<code>h</code>属性，作为下一次热更细的标识</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30356130656466302d616434612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在浏览器接受到这条消息之前，浏览器已经在上一次<code> socket</code> 消息中已经记住了此时的<code> hash</code> 标识，这时候我们会创建一个 <code>ajax</code> 去服务端请求获取到变化内容的 <code>manifest</code> 文件</p>
<p><code>mainfest</code>文件包含重新<code>build</code>生成的<code>hash</code>值，以及变化的模块，对应上图的<code>c</code>属性</p>
<p>浏览器根据 <code>manifest</code> 文件获取模块变化的内容，从而触发<code>render</code>流程，实现局部模块更新</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30653762373835302d616434612d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>关于<code>webpack</code>热模块更新的总结如下：</p>
<ul>
<li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li>
<li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li>
<li>socket server 是一个 websocket 的长连接，双方可以通信</li>
<li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li>
<li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li>
<li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何优化-Webpack-的构建速度"><a href="#♥︎-♥︎-♥︎-如何优化-Webpack-的构建速度" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何优化 Webpack 的构建速度"></a>♥︎ ♥︎ ♥︎ 如何优化 Webpack 的构建速度</h3><h4 id="一、背景-1"><a href="#一、背景-1" class="headerlink" title="一、背景"></a>一、背景</h4><p>随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 <code>webpack</code> 的构建时间也会越来越久</p>
<p>构建时间与我们日常开发效率密切相关，当我们本地开发启动 <code>devServer</code> 或者 <code>build</code> 的时候，如果时间过长，会大大降低我们的工作效率</p>
<p>所以，优化<code>webpack</code> 构建速度是十分重要的环节</p>
<h4 id="二、如何优化"><a href="#二、如何优化" class="headerlink" title="二、如何优化"></a>二、如何优化</h4><p>常见的提升构建速度的手段有如下：</p>
<ul>
<li>优化 loader 配置</li>
<li>合理使用 resolve.extensions</li>
<li>优化 resolve.modules</li>
<li>优化 resolve.alias</li>
<li>使用 DLLPlugin 插件</li>
<li>使用 cache-loader</li>
<li>terser 启动多线程</li>
<li>合理使用 sourceMap</li>
</ul>
<h5 id="优化loader配置"><a href="#优化loader配置" class="headerlink" title="优化loader配置"></a>优化loader配置</h5><p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件，接触<code>include</code>、<code>exclude</code>规定哪些匹配应用<code>loader</code></p>
<p>如采用 ES6 的项目为例，在配置 <code>babel-loader </code>时，可以这样：</p>
<pre><code class="javascript">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        // 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能
        test: /\.js$/,
        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启
        use: [&#39;babel-loader?cacheDirectory&#39;],
        // 只对项目根目录下的 src 目录中的文件采用 babel-loader
        include: path.resolve(__dirname, &#39;src&#39;),
      &#125;,
    ]
  &#125;,
&#125;;
</code></pre>
<h5 id="合理使用-resolve-extensions"><a href="#合理使用-resolve-extensions" class="headerlink" title="合理使用 resolve.extensions"></a>合理使用 resolve.extensions</h5><p>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， <code>resolve</code>可以帮助<code>webpack</code>从每个 <code>require/import</code> 语句中，找到需要引入到合适的模块代码</p>
<p>通过<code>resolve.extensions</code>是解析到文件时自动添加拓展名，默认情况如下：</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    extensions:[&quot;.warm&quot;,&quot;.mjs&quot;,&quot;.js&quot;,&quot;.json&quot;]
&#125;
</code></pre>
<p>当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找</p>
<p>当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度</p>
<h5 id="优化-resolve-modules"><a href="#优化-resolve-modules" class="headerlink" title="优化 resolve.modules"></a>优化 resolve.modules</h5><p><code>resolve.modules</code> 用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。默认值为<code>[&#39;node_modules&#39;]</code>，所以默认会从<code>node_modules</code>中查找文件<br>当安装的第三方模块都放在项目根目录下的 <code>./node_modules </code>目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p>
<pre><code class="javascript">module.exports = &#123;
  resolve: &#123;
    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤
    // 其中 __dirname 表示当前工作目录，也就是项目根目录
    modules: [path.resolve(__dirname, &#39;node_modules&#39;)]
  &#125;,
&#125;;
</code></pre>
<h5 id="优化-resolve-alias"><a href="#优化-resolve-alias" class="headerlink" title="优化 resolve.alias"></a>优化 resolve.alias</h5><p><code>alias</code>给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式</p>
<p>通过配置<code>alias</code>以减少查找过程</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    resolve:&#123;
        alias:&#123;
            &quot;@&quot;:path.resolve(__dirname,&#39;./src&#39;)
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="使用-DLLPlugin-插件"><a href="#使用-DLLPlugin-插件" class="headerlink" title="使用 DLLPlugin 插件"></a>使用 DLLPlugin 插件</h5><p><code>DLL</code>全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中</p>
<p>使用步骤分成两部分：</p>
<ul>
<li>打包一个 DLL 库</li>
<li>引入 DLL 库</li>
</ul>
<h6 id="打包一个-DLL-库"><a href="#打包一个-DLL-库" class="headerlink" title="打包一个 DLL 库"></a>打包一个 DLL 库</h6><p><code>webpack</code>内置了一个<code>DllPlugin</code>可以帮助我们打包一个DLL的库文件</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    plugins:[
        new webpack.DllPlugin(&#123;
            name:&#39;dll_[name]&#39;,
            path:path.resolve(__dirname,&quot;./dll/[name].mainfest.json&quot;)
        &#125;)
    ]
&#125;
</code></pre>
<h6 id="引入-DLL-库"><a href="#引入-DLL-库" class="headerlink" title="引入 DLL 库"></a>引入 DLL 库</h6><p>使用 <code>webpack</code> 自带的 <code>DllReferencePlugin</code> 插件对 <code>mainfest.json</code> 映射文件进行分析，获取要使用的<code>DLL</code>库</p>
<p>然后再通过<code>AddAssetHtmlPlugin</code>插件，将我们打包的<code>DLL</code>库引入到<code>Html</code>模块中</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    new webpack.DllReferencePlugin(&#123;
        context:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;),
        mainfest:path.resolve(__dirname,&quot;./dll/react.mainfest.json&quot;)
    &#125;),
    new AddAssetHtmlPlugin(&#123;
        outputPath:&quot;./auto&quot;,
        filepath:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;)
    &#125;)
&#125;
</code></pre>
<h5 id="使用-cache-loader"><a href="#使用-cache-loader" class="headerlink" title="使用 cache-loader"></a>使用 cache-loader</h5><p>在一些性能开销较大的 <code>loader </code>之前添加 <code>cache-loader</code>，以将结果缓存到磁盘里，显著提升二次构建速度</p>
<p>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code> loader</code></p>
<pre><code class="javascript">module.exports = &#123;
    module: &#123;
        rules: [
            &#123;
                test: /\.ext$/,
                use: [&#39;cache-loader&#39;, ...loaders],
                include: path.resolve(&#39;src&#39;),
            &#125;,
        ],
    &#125;,
&#125;;
</code></pre>
<h5 id="terser-启动多线程"><a href="#terser-启动多线程" class="headerlink" title="terser 启动多线程"></a>terser 启动多线程</h5><p>使用多进程并行运行来提高构建速度</p>
<pre><code class="javascript">module.exports = &#123;
  optimization: &#123;
    minimizer: [
      new TerserPlugin(&#123;
        parallel: true,
      &#125;),
    ],
  &#125;,
&#125;;
</code></pre>
<h5 id="合理使用-sourceMap"><a href="#合理使用-sourceMap" class="headerlink" title="合理使用 sourceMap"></a>合理使用 sourceMap</h5><p>打包生成 <code>sourceMap</code> 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31313634376166302d623031642d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，优化<code>webpack</code>构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手</p>
<h3 id="♥︎-♥︎-♥︎-自己写过Loader和Plugin么"><a href="#♥︎-♥︎-♥︎-自己写过Loader和Plugin么" class="headerlink" title="♥︎ ♥︎ ♥︎ 自己写过Loader和Plugin么"></a>♥︎ ♥︎ ♥︎ 自己写过Loader和Plugin么</h3><h4 id="一、编写loader"><a href="#一、编写loader" class="headerlink" title="一、编写loader"></a>一、编写loader</h4><p>在编写 <code>loader</code> 前，我们首先需要了解 <code>loader</code> 的本质</p>
<p>其本质为函数，函数中的 <code>this</code> 作为上下文会被 <code>webpack</code> 填充，因此我们不能将 <code>loader</code>设为一个箭头函数</p>
<p>函数接受一个参数，为 <code>webpack</code> 传递给 <code>loader</code> 的文件源内容</p>
<p>函数中 <code>this</code> 是由 <code>webpack</code> 提供的对象，能够获取当前 <code>loader</code> 所需要的各种信息</p>
<p>函数中有异步操作或同步操作，异步操作通过 <code>this.callback</code> 返回，返回值要求为 <code>string</code> 或者 <code>Buffer</code></p>
<p>代码如下所示：</p>
<pre><code class="javascript">// 导出一个函数，source为webpack传递给loader的文件源内容
module.exports = function(source) &#123;
    const content = doSomeThing2JsString(source);
    
    // 如果 loader 配置了 options 对象，那么this.query将指向 options
    const options = this.query;
    
    // 可以用作解析其他模块路径的上下文
    console.log(&#39;this.context&#39;);
    
    /*
     * this.callback 参数：
     * error：Error | null，当 loader 出错时向外抛出一个 error
     * content：String | Buffer，经过 loader 编译后需要导出的内容
     * sourceMap：为方便调试生成的编译后内容的 source map
     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程
     */
    this.callback(null, content); // 异步
    return content; // 同步
&#125;
</code></pre>
<p>一般在编写<code>loader</code>的过程中，保持功能单一，避免做多种功能</p>
<p>如<code>less</code>文件转换成 <code>css </code>文件也不是一步到位，而是 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code>几个 <code>loader </code>的链式调用才能完成转换</p>
<h4 id="二、编写plugin"><a href="#二、编写plugin" class="headerlink" title="二、编写plugin"></a>二、编写plugin</h4><p>由于<code>webpack</code>基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务</p>
<p>在之前也了解过，<code>webpack</code>编译会创建两个核心对象：</p>
<ul>
<li>compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子</li>
<li>compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建</li>
</ul>
<p>如果自己要实现<code>plugin</code>，也需要遵循一定的规范：</p>
<ul>
<li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例</li>
<li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，因此不建议修改</li>
<li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住</li>
</ul>
<p>实现<code>plugin</code>的模板如下：</p>
<pre><code class="javascript">class MyPlugin &#123;
    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象
  apply (compiler) &#123;
    // 找到合适的事件钩子，实现自己的插件功能
    compiler.hooks.emit.tap(&#39;MyPlugin&#39;, compilation =&gt; &#123;
        // compilation: 当前打包构建流程的上下文
        console.log(compilation);
        
        // do something...
    &#125;)
  &#125;
&#125;
</code></pre>
<p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容</p>
<h4 id="三、手写一个loader和plugin"><a href="#三、手写一个loader和plugin" class="headerlink" title="三、手写一个loader和plugin"></a>三、手写一个loader和plugin</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903689442820110">手写一个loader和plugin</a></p>
<h3 id="♥︎-♥︎-♥︎-webpack-proxy工作原理？为什么能解决跨域"><a href="#♥︎-♥︎-♥︎-webpack-proxy工作原理？为什么能解决跨域" class="headerlink" title="♥︎ ♥︎ ♥︎ webpack proxy工作原理？为什么能解决跨域?"></a>♥︎ ♥︎ ♥︎ webpack proxy工作原理？为什么能解决跨域?</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p>
<p>基本行为就是接收客户端发送的请求后转发给其他服务器</p>
<p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p>
<p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p>
<h5 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h5><p><code>webpack-dev-server</code>是 <code>webpack</code> 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起</p>
<p>目的是为了提高开发者日常的开发效率，只适用在开发阶段</p>
<p>关于配置方面，在<code>webpack</code>配置对象属性中通过<code>devServer</code>属性提供，如下：</p>
<pre><code class="javascript">// ./webpack.config.js
const path = require(&#39;path&#39;)

module.exports = &#123;
    // ...
    devServer: &#123;
        contentBase: path.join(__dirname, &#39;dist&#39;),
        compress: true,
        port: 9000,
        proxy: &#123;
            &#39;/api&#39;: &#123;
                target: &#39;https://api.github.com&#39;
            &#125;
        &#125;
        // ...
    &#125;
&#125;
</code></pre>
<p><code>devServetr</code>里面<code>proxy</code>则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p>
<p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为<code> /api</code>，值为对应的代理匹配规则，对应如下：</p>
<ul>
<li>target：表示的是代理到的目标地址</li>
<li>pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite</li>
<li>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false</li>
<li>changeOrigin：它表示是否更新代理后请求的 headers 中host地址</li>
</ul>
<h4 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h4><p><code>proxy</code>工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器</p>
<p>举个例子：</p>
<p>在开发阶段，本地地址为<code>http://localhost:3000</code>，该浏览器发送一个前缀带有<code>/api</code>标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p>
<pre><code class="javascript">const express = require(&#39;express&#39;);
const proxy = require(&#39;http-proxy-middleware&#39;);

const app = express();

app.use(&#39;/api&#39;, proxy(&#123;target: &#39;http://www.example.org&#39;, changeOrigin: true&#125;));
app.listen(3000);

// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar
</code></pre>
<h4 id="三、跨域"><a href="#三、跨域" class="headerlink" title="三、跨域"></a>三、跨域</h4><p>在开发阶段， <code>webpack-dev-server</code> 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 <code>localhost </code>的一个端口上，而后端服务又是运行在另外一个地址上</p>
<p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p>
<p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p>
<p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36356235653563302d616365352d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据</p>
<p>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</p>
<h3 id="♥︎-♥︎-♥︎-如何借助webpack来优化前端性能？"><a href="#♥︎-♥︎-♥︎-如何借助webpack来优化前端性能？" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何借助webpack来优化前端性能？"></a>♥︎ ♥︎ ♥︎ 如何借助webpack来优化前端性能？</h3><h4 id="一、背景-2"><a href="#一、背景-2" class="headerlink" title="一、背景"></a>一、背景</h4><p>随着前端的项目逐渐扩大，必然会带来的一个问题就是性能</p>
<p>尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃</p>
<p>一般项目在完成后，会通过<code>webpack</code>进行打包，利用<code>webpack</code>对前端项目性能优化是一个十分重要的环节</p>
<h4 id="二、如何优化-1"><a href="#二、如何优化-1" class="headerlink" title="二、如何优化"></a>二、如何优化</h4><p>通过<code>webpack</code>优化前端的手段有：</p>
<ul>
<li>JS代码压缩</li>
<li>CSS代码压缩</li>
<li>Html文件代码压缩</li>
<li>文件大小压缩</li>
<li>图片压缩</li>
<li>Tree Shaking</li>
<li>代码分离</li>
<li>内联 chunk</li>
</ul>
<h5 id="JS代码压缩"><a href="#JS代码压缩" class="headerlink" title="JS代码压缩"></a>JS代码压缩</h5><p><code>terser</code>是一个<code>JavaScript</code>的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让<code>bundle</code>更小</p>
<p>在<code>production</code>模式下，<code>webpack</code> 默认就是使用 <code>TerserPlugin</code> 来处理我们的代码的。如果想要自定义配置它，配置方法如下：</p>
<pre><code class="javascript">const TerserPlugin = require(&#39;terser-webpack-plugin&#39;)
module.exports = &#123;
    ...
    optimization: &#123;
        minimize: true,
        minimizer: [
            new TerserPlugin(&#123;
                parallel: true // 电脑cpu核数-1
            &#125;)
        ]
    &#125;
&#125;
</code></pre>
<p>属性介绍如下：</p>
<ul>
<li>extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释</li>
<li>parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1</li>
<li>terserOptions：设置我们的terser相关的配置：<ul>
<li>compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true</li>
<li>mangle：设置丑化相关的选项，可以直接设置为true</li>
<li>toplevel：底层变量是否进行转换</li>
<li>keep_classnames：保留类的名称</li>
<li>keep_fnames：保留函数的名称</li>
</ul>
</li>
</ul>
<h5 id="CSS代码压缩"><a href="#CSS代码压缩" class="headerlink" title="CSS代码压缩"></a>CSS代码压缩</h5><p><code>CSS</code>压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等</p>
<p>CSS的压缩我们可以使用另外一个插件：<code>css-minimizer-webpack-plugin</code></p>
<pre><code class="ini">npm install css-minimizer-webpack-plugin -D
</code></pre>
<p>配置方法如下：</p>
<pre><code class="javascript">const CssMinimizerPlugin = require(&#39;css-minimizer-webpack-plugin&#39;)
module.exports = &#123;
    // ...
    optimization: &#123;
        minimize: true,
        minimizer: [
            new CssMinimizerPlugin(&#123;
                parallel: true
            &#125;)
        ]
    &#125;
&#125;
</code></pre>
<h5 id="Html文件代码压缩"><a href="#Html文件代码压缩" class="headerlink" title="Html文件代码压缩"></a>Html文件代码压缩</h5><p>使用<code>HtmlWebpackPlugin</code>插件来生成<code>HTML</code>的模板时候，通过配置属性<code>minify</code>进行<code>html</code>优化</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    plugin:[
        new HtmlwebpackPlugin(&#123;
            ...
            minify:&#123;
                minifyCSS:false, // 是否压缩css
                collapseWhitespace:false, // 是否折叠空格
                removeComments:true // 是否移除注释
            &#125;
        &#125;)
    ]
&#125;
</code></pre>
<p>设置了<code>minify</code>，实际会使用另一个插件<code>html-minifier-terser</code></p>
<h5 id="文件大小压缩"><a href="#文件大小压缩" class="headerlink" title="文件大小压缩"></a>文件大小压缩</h5><p>对文件的大小进行压缩，减少<code>http</code>传输过程中宽带的损耗</p>
<pre><code class="javascript">npm install compression-webpack-plugin -D
new ComepressionPlugin(&#123;
    test:/\.(css|js)$/,  // 哪些文件需要压缩
    threshold:500, // 设置文件多大开始压缩
    minRatio:0.7, // 至少压缩的比例
    algorithm:&quot;gzip&quot;, // 采用的压缩算法
&#125;)
</code></pre>
<h5 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h5><p>一般来说在打包之后，一些图片文件的大小是远远要比 <code>js</code> 或者 <code>css</code> 文件要来的大，所以图片压缩较为重要</p>
<p>配置方法如下：</p>
<pre><code class="javascript">module: &#123;
  rules: [
    &#123;
      test: /\.(png|jpg|gif)$/,
      use: [
        &#123;
          loader: &#39;file-loader&#39;,
          options: &#123;
            name: &#39;[name]_[hash].[ext]&#39;,
            outputPath: &#39;images/&#39;,
          &#125;
        &#125;,
        &#123;
          loader: &#39;image-webpack-loader&#39;,
          options: &#123;
            // 压缩 jpeg 的配置
            mozjpeg: &#123;
              progressive: true,
              quality: 65
            &#125;,
            // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭
            optipng: &#123;
              enabled: false,
            &#125;,
            // 使用 imagemin-pngquant 压缩 png
            pngquant: &#123;
              quality: &#39;65-90&#39;,
              speed: 4
            &#125;,
            // 压缩 gif 的配置
            gifsicle: &#123;
              interlaced: false,
            &#125;,
            // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式
            webp: &#123;
              quality: 75
            &#125;
          &#125;
        &#125;
      ]
    &#125;,
  ]
&#125; 
</code></pre>
<h5 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h5><p><code>Tree Shaking</code> 是一个术语，在计算机中表示消除死代码，依赖于<code>ES Module</code>的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）</p>
<p>在<code>webpack</code>实现<code>Trss shaking</code>有两种不同的方案：</p>
<ul>
<li>usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的</li>
<li>sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用</li>
</ul>
<p>两种不同的配置方案， 有不同的效果</p>
<h5 id="usedExports"><a href="#usedExports" class="headerlink" title="usedExports"></a>usedExports</h5><p>配置方法也很简单，只需要将<code>usedExports</code>设为<code>true</code></p>
<pre><code class="javascript">module.exports = &#123;
    ...
    optimization:&#123;
        usedExports
    &#125;
&#125;
</code></pre>
<p>使用之后，没被用上的代码在<code>webpack</code>打包中会加入<code>unused harmony export mul</code>注释，用来告知 <code>Terser</code> 在优化时，可以删除掉这段代码</p>
<p>如下面<code>sum</code>函数没被用到，<code>webpack</code>打包会添加注释，<code>terser</code>在优化时，则将该函数去掉</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32316232653230302d616565342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h5><p><code>sideEffects</code>用于告知<code>webpack compiler</code>哪些模块时有副作用，配置方法是在<code>package.json</code>中设置<code>sideEffects</code>属性</p>
<p>如果<code>sideEffects</code>设置为false，就是告知<code>webpack</code>可以安全的删除未用到的<code>exports</code></p>
<p>如果有些文件需要保留，可以设置为数组的形式</p>
<pre><code class="javascript">&quot;sideEffecis&quot;:[    &quot;./src/util/format.js&quot;,    &quot;*.css&quot; // 所有的css文件]
</code></pre>
<p>上述都是关于<code>javascript</code>的<code>tree shaking</code>，<code>css</code>同样也能够实现<code>tree shaking</code></p>
<h5 id="css-tree-shaking"><a href="#css-tree-shaking" class="headerlink" title="css tree shaking"></a>css tree shaking</h5><p><code>css</code>进行<code>tree shaking</code>优化可以安装<code>PurgeCss</code>插件</p>
<pre><code class="javascript">npm install purgecss-plugin-webpack -D
const PurgeCssPlugin = require(&#39;purgecss-webpack-plugin&#39;)module.exports = &#123;    ...    plugins:[        new PurgeCssPlugin(&#123;            path:glob.sync(`$&#123;path.resolve(&#39;./src&#39;)&#125;/**/*`), &#123;nodir:true&#125;// src里面的所有文件            satelist:function()&#123;                return &#123;                    standard:[&quot;html&quot;]                &#125;            &#125;        &#125;)    ]&#125;
</code></pre>
<ul>
<li>paths：表示要检测哪些目录下的内容需要被分析，配合使用glob</li>
<li>默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性</li>
</ul>
<h5 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h5><p>将代码分离到不同的<code>bundle</code>中，之后我们可以按需加载，或者并行加载这些文件</p>
<p>默认情况下，所有的<code>JavaScript</code>代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度</p>
<p>代码分离可以分出出更小的<code>bundle</code>，以及控制资源加载优先级，提供代码的加载性能</p>
<p>这里通过<code>splitChunksPlugin</code>来实现，该插件<code>webpack</code>已经默认安装和集成，只需要配置即可</p>
<p>默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all</p>
<pre><code class="javascript">module.exports = &#123;    ...    optimization:&#123;        splitChunks:&#123;            chunks:&quot;all&quot;        &#125;    &#125;&#125;
</code></pre>
<p><code>splitChunks</code>主要属性有如下：</p>
<ul>
<li>Chunks，对同步代码还是异步代码进行处理</li>
<li>minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分</li>
<li>maxSize： 将大于maxSize的包，拆分为不小于minSize的包</li>
<li>minChunks：被引入的次数，默认是1</li>
</ul>
<h5 id="内联chunk"><a href="#内联chunk" class="headerlink" title="内联chunk"></a>内联chunk</h5><p>可以通过<code>InlineChunkHtmlPlugin</code>插件将一些<code>chunk</code>的模块内联到<code>html</code>，如<code>runtime</code>的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的</p>
<pre><code class="javascript">const InlineChunkHtmlPlugin = require(&#39;react-dev-utils/InlineChunkHtmlPlugin&#39;)const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)module.exports = &#123;    ...    plugin:[        new InlineChunkHtmlPlugin(HtmlWebpackPlugin,[/runtime.+\.js/]&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>关于<code>webpack</code>对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化</p>
<h3 id="♥︎-♥︎-♥︎-与webpack类似的工具还有哪些？区别？"><a href="#♥︎-♥︎-♥︎-与webpack类似的工具还有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ 与webpack类似的工具还有哪些？区别？"></a>♥︎ ♥︎ ♥︎ 与webpack类似的工具还有哪些？区别？</h3><h4 id="一、模块化工具"><a href="#一、模块化工具" class="headerlink" title="一、模块化工具"></a>一、模块化工具</h4><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式</p>
<p>可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)</p>
<p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code></p>
<p>通过这些模块打包工具，能够提高我们的开发效率，减少开发成本</p>
<p>这里没有提及<code>gulp</code>、<code>grunt</code>是因为它们只是定义为构建工具，不能类比</p>
<h5 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h5><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup </code>要小巧的多</p>
<p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p>
<p>举个例子：</p>
<pre><code class="javascript">// ./src/messages.js
export default &#123;
  hi: &#39;Hey Guys, I am zce~&#39;
&#125;

// ./src/logger.js
export const log = msg =&gt; &#123;
  console.log(&#39;---------- INFO ----------&#39;)
  console.log(msg)
  console.log(&#39;--------------------------&#39;)
&#125;

export const error = msg =&gt; &#123;
  console.error(&#39;---------- ERROR ----------&#39;)
  console.error(msg)
  console.error(&#39;---------------------------&#39;)
&#125;

// ./src/index.js
import &#123; log &#125; from &#39;./logger&#39;
import messages from &#39;./messages&#39;
log(messages.hi)
</code></pre>
<p>然后通过<code>rollup</code>进行打包</p>
<pre><code class="ini">$ npx rollup ./src/index.js --file ./dist/bundle.js
</code></pre>
<p>打包结果如下图</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38666530373833302d623134332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>可以看到，代码非常简洁，完成不像<code>webpack</code>那样存在大量引导代码和模块函数</p>
<p>并且<code>error</code>方法由于没有被使用，输出的结果中并无<code>error</code>方法，可以看到，<code>rollup</code>默认开始<code>Tree-shaking</code> 优化输出结果</p>
<p>因此，可以看到<code>Rollup</code>的优点：</p>
<ul>
<li>代码效率更简洁、效率更高</li>
<li>默认支持 Tree-shaking</li>
</ul>
<p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup </code>需要使用插件去完成</p>
<p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p>
<p>但是在用于打包<code> JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p>
<h5 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h5><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p>
<p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。如下所示：</p>
<pre><code class="javascript">&lt;!-- ./src/index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Parcel Tutorials&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>main.js文件通过<code>ES Moudle</code>方法导入其他模块成员</p>
<pre><code class="javascript">// ./src/main.js
import &#123; log &#125; from &#39;./logger&#39;
log(&#39;hello parcel&#39;)
// ./src/logger.js
export const log = msg =&gt; &#123;
  console.log(&#39;---------- INFO ----------&#39;)
  console.log(msg)
&#125;
</code></pre>
<p>运行之后，使用命令打包</p>
<pre><code class="ini">npx parcel src/index.html
</code></pre>
<p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个开发服务器，跟<code>webpack Dev Server</code>一样</p>
<p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单</p>
<p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p>
<p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p>
<p>打包命令如下：</p>
<pre><code class="ini">npx parcel src/index.html
</code></pre>
<p>由于打包过程是多进程同时工作，构建速度会比<code>Webpack</code> 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65633137653761302d623161322d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>可以感受到，<code>Parcel </code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决</p>
<h5 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h5><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p>
<p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p>
<p>下图给出<code>webpack</code>与<code>snowpack</code>打包区别：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37393139373833302d623161332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新</p>
<h5 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h5><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p>
<p>它主要由两部分组成：</p>
<ul>
<li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR</li>
<li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li>
</ul>
<p>其作用类似<code>webpack </code>+ <code>webpack-dev-server</code>，其特点如下：</p>
<ul>
<li>快速的冷启动</li>
<li>即时的模块热更新</li>
<li>真正的按需编译</li>
</ul>
<p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p>
<p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p>
<p>原理图如下所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39663265656433302d623134332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p>
<h5 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h5><p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：一切皆模块和按需加载</p>
<p>与其他构建工具相比，有如下优势：</p>
<ul>
<li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li>
<li>万物模块：对 js、css、图片等资源文件都支持打包</li>
<li>开箱即用：HRM、Tree-shaking等功能</li>
<li>代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li>
<li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li>
<li>易于调试：支持 SourceUrls 和 SourceMaps</li>
<li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li>
<li>生态环境好：社区更丰富，出现的问题更容易解决</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-代码分割的本质是什么？有什么意义呢？"><a href="#♥︎-♥︎-♥︎-代码分割的本质是什么？有什么意义呢？" class="headerlink" title="♥︎ ♥︎ ♥︎ 代码分割的本质是什么？有什么意义呢？"></a>♥︎ ♥︎ ♥︎ 代码分割的本质是什么？有什么意义呢？</h3><p>代码分割的本质： 是能够把代码分离到不同的bundle中，避免出现大体积的代码包，然后可以按需加载或并行加载这些文件 </p>
<p>代码分离的意义： 代码分离可以获取更小的bundle，以及控制资源加载优先级，合理使用可以极大的减少加载时间 </p>
<p>代码分割的实现方式有三种： 入口起点：使用entry手动分离代码(不建议) 防止重复加载：</p>
<p>使用optimization.splitChunks配置选项，可以将第三方公共模块和业务代码直接分离 </p>
<p>动态引入：使 用import()方法来分离代码，原理是当 Webpack 解析到该语法时，会自动进行代码分割，分割出不同的chunks  </p>
<p>语法：使用的时候再去下载对应的文件，返回一个Promise，当Promise成功后再去执行回调</p>
<h3 id="♥︎-♥︎-♥︎-说下-tree-shaking-的原理"><a href="#♥︎-♥︎-♥︎-说下-tree-shaking-的原理" class="headerlink" title="♥︎ ♥︎ ♥︎ 说下 tree-shaking 的原理"></a>♥︎ ♥︎ ♥︎ 说下 tree-shaking 的原理</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7002410645316436004">tree-shaking 的原理</a></p>
<h3 id="♥︎-♥︎-♥︎-babel原理"><a href="#♥︎-♥︎-♥︎-babel原理" class="headerlink" title="♥︎ ♥︎ ♥︎  babel原理"></a>♥︎ ♥︎ ♥︎  babel原理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wmaoshu/article/details/119813090">babel原理</a></p>
<h3 id="♥︎-♥︎-♥︎-linux部署和windows-sever服务器区别？"><a href="#♥︎-♥︎-♥︎-linux部署和windows-sever服务器区别？" class="headerlink" title="♥︎ ♥︎ ♥︎  linux部署和windows sever服务器区别？"></a>♥︎ ♥︎ ♥︎  linux部署和windows sever服务器区别？</h3><p>性价比：Linux服务器性价比更高，Linux作为资源管理器和操作系统来说，是开源的，免费的，而正版windows的操作系统是收费的。</p>
<p>性能方面：相同配置的Linux服务器的性能比windows服务器好一些，Linux服务器占用的资源少一点</p>
<p>稳定性方面：Window系统用户量大，因而攻击者多一些，所以暴露了更多的系统安全漏洞。Linux是多用户多进程系统，意味着Linux能够一次性处理大量正在进行的进程，比windows处理的多</p>
<p>安全性方面：Linux系统开源软件的开发方式有助于暴露错误，集众人智慧解决问题，补丁更新更快。这是windows不具备的，Windows的另一个不利因素是其许多应用程序依靠远程过程调用，这就迫使Windows的防火墙没有Linux那样严格。而Linux远程过程调用是限制使用的。</p>
<h3 id="♥︎-♥︎-♥︎-前端资源发布路径怎么实现非覆盖式发布（平滑升级）？"><a href="#♥︎-♥︎-♥︎-前端资源发布路径怎么实现非覆盖式发布（平滑升级）？" class="headerlink" title="♥︎ ♥︎ ♥︎ 前端资源发布路径怎么实现非覆盖式发布（平滑升级）？"></a>♥︎ ♥︎ ♥︎ 前端资源发布路径怎么实现非覆盖式发布（平滑升级）？</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903457984512014">前端资源发布路径怎么实现非覆盖式发布</a></p>
<h3 id="♥︎-♥︎-♥︎-你有发布过自己的npm包吗？流程是怎样的？"><a href="#♥︎-♥︎-♥︎-你有发布过自己的npm包吗？流程是怎样的？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你有发布过自己的npm包吗？流程是怎样的？"></a>♥︎ ♥︎ ♥︎ 你有发布过自己的npm包吗？流程是怎样的？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CapejasmineY/article/details/126251986">npm包发布流程</a></p>
<h3 id="♥︎-♥︎-♥︎-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？"><a href="#♥︎-♥︎-♥︎-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？" class="headerlink" title="♥︎ ♥︎ ♥︎ 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？"></a>♥︎ ♥︎ ♥︎ 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/75786d5c9cac">npm 模块安装机制</a></p>
<h3 id="♥︎-♥︎-♥︎-你会搭建私有的npm仓库吗？怎么搭建？"><a href="#♥︎-♥︎-♥︎-你会搭建私有的npm仓库吗？怎么搭建？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你会搭建私有的npm仓库吗？怎么搭建？"></a>♥︎ ♥︎ ♥︎ 你会搭建私有的npm仓库吗？怎么搭建？</h3><p><a target="_blank" rel="noopener" href="https://zhaomenghuan.js.org/blog/npm-private-repository-verdaccio.html">私有的npm仓库</a></p>
<h3 id="♥︎-♥︎-♥︎-jenkins-上线流程"><a href="#♥︎-♥︎-♥︎-jenkins-上线流程" class="headerlink" title="♥︎ ♥︎ ♥︎  jenkins 上线流程"></a>♥︎ ♥︎ ♥︎  jenkins 上线流程</h3><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/608413">jenkins 上线流程</a></p>
<h3 id="♥︎-♥︎-♥︎-什么是长缓存，在webpack中如何做到长缓存优化？"><a href="#♥︎-♥︎-♥︎-什么是长缓存，在webpack中如何做到长缓存优化？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是长缓存，在webpack中如何做到长缓存优化？"></a>♥︎ ♥︎ ♥︎ 什么是长缓存，在webpack中如何做到长缓存优化？</h3><p>浏览器在用户访问页面的时候，都会对静态资源进行存储，但是每次代码更新或者升级的时候，我们都需要浏览器去重新加载代码，最方便的方法就是以文件名的方式引入，只下载新的代码块，不加载旧的没有变化的代码块，这就是长缓存，</p>
<p>在webpack4中使用SplitChunkPlugin把第三方库和业务代码分离，由于第三方库的chunkHash未改变，所以只会对改变的业务代码的模块进行更新。而第三方库的代码块因为长缓存而不更新。</p>
<h3 id="♥︎-♥︎-♥︎-什么是组件？什么是模块化？有什么区别？"><a href="#♥︎-♥︎-♥︎-什么是组件？什么是模块化？有什么区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是组件？什么是模块化？有什么区别？"></a>♥︎ ♥︎ ♥︎ 什么是组件？什么是模块化？有什么区别？</h3><p>组件化</p>
<p>就是基础库或者基础组件，意思是把代码重复的部分提炼出一个个组件供给功能使用</p>
<p>模块化</p>
<p>就是业务框架或者业务模块，也可以理解为框架，意思是把功能进行划分，将同一类型的代码整合在一起，所以模</p>
<p>块的功能相对复杂，都属于同一个业务。</p>
<p>区别：</p>
<p>使用：组件的使用能在不同项目(模块)重复应用的代码，而模块按照项目功能需求划分成不同类型的业务框架 </p>
<p>目的：组件是复用，解耦，模块是为了隔离、封装 </p>
<p>依赖：组件之间低依赖，比较独立，模块之间的依赖可通过路由进行耦合 </p>
<p>架构定位：组件位于架构底层，被其它层所依赖，模块位于架构业务层</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903935795265549">https://juejin.cn/post/6844903935795265549</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mengfeng.github.io/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/11/05/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E9%97%AE%E9%A2%98/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            前端异常捕获问题
          
        </div>
      </a>
    
    
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">前端面试大全git</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '6887374e7666a97fd4dc',
    clientSecret: '09a8e143dd4a3f5d11311e1435842321e063157d',
    repo: 'mengfeng.github.io',
    owner: 'mengfeng',
    admin: ['mengfeng'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>