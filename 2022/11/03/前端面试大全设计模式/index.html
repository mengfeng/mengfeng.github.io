<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>前端面试大全设计模式 |  艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-前端面试大全设计模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  前端面试大全设计模式
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-11-03T01:26:38.000Z" itemprop="datePublished">2022-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">常用设计模式</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">7.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">29 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（设计模式）"><a href="#前端面试题大全（设计模式）" class="headerlink" title="前端面试题大全（设计模式）"></a>前端面试题大全（设计模式）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ul>
<li>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</li>
</ul>
<h3 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h3><ul>
<li>看懂源代码：如果你不懂设计模式去看Jdk、Spring、SpringMVC、IO等等等等的源码，你会很迷茫，你会寸步难行</li>
<li>看看前辈的代码：你去个公司难道都是新项目让你接手？很有可能是接盘的，前辈的开发难道不用设计模式？</li>
<li>编写自己的理想中的好代码：我个人反正是这样的，对于我自己开发的项目我会很认真，我对他比对我女朋友还好，把项目当成自己的儿子一样</li>
</ul>
<h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17172acfe20b2d2d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png"></p>
<ul>
<li>创建型模式，共五种：工厂方法模式、抽象工厂模式<strong>、</strong>单例模式、建造者模式、原型模式。</li>
<li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17172acff10be430~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.jpeg"></p>
<h4 id="开放封闭原则（Open-Close-Principle）"><a href="#开放封闭原则（Open-Close-Principle）" class="headerlink" title="开放封闭原则（Open Close Principle）"></a>开放封闭原则（Open Close Principle）</h4><ul>
<li>原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</li>
<li>描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li>
<li>优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。</li>
</ul>
<h4 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h4><ul>
<li>原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。</li>
<li>大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。</li>
<li>优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。</li>
</ul>
<h4 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h4><ul>
<li>依赖倒置原则的核心思想是面向接口编程.</li>
<li>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，</li>
<li>这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。</li>
</ul>
<h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h4><ul>
<li>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</li>
<li>例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口</li>
</ul>
<h4 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h4><ul>
<li>原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦</li>
<li>大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</li>
<li>优点：低耦合，高内聚。</li>
</ul>
<h4 id="单一职责原则（Principle-of-single-responsibility）"><a href="#单一职责原则（Principle-of-single-responsibility）" class="headerlink" title="单一职责原则（Principle of single responsibility）"></a>单一职责原则（Principle of single responsibility）</h4><ul>
<li>原则思想：一个方法只负责一件事情。</li>
<li>描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。</li>
<li>优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>单例模式（Singleton Pattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建</p>
<p>在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66613738393864302d336232632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>从定义上来看，全局变量好像就是单例模式，但是一般情况我们不认为全局变量是一个单例模式，原因是：</p>
<ul>
<li>全局命名污染</li>
<li>不易维护，容易被重写覆盖</li>
</ul>
<h4 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h4><p>在<code>javascript</code>中，实现一个单例模式可以用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可，如下：</p>
<pre><code class="javascript">// 定义一个类
function Singleton(name) &#123;
  this.name = name;
  this.instance = null;
&#125;
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 获取类的实例
Singleton.getInstance = function(name) &#123;
  if(!this.instance) &#123;
      this.instance = new Singleton(name);
  &#125;
  return this.instance
&#125;;

// 获取对象1
const a = Singleton.getInstance(&#39;a&#39;);
// 获取对象2
const b = Singleton.getInstance(&#39;b&#39;);
// 进行比较
console.log(a === b);
</code></pre>
<p>使用闭包也能够实现，如下：</p>
<pre><code class="javascript">function Singleton(name) &#123;
  this.name = name;
&#125;
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 获取类的实例
Singleton.getInstance = (function() &#123;
  var instance = null;
  return function(name) &#123;
      if(!this.instance) &#123;
          this.instance = new Singleton(name);
      &#125;
      return this.instance
  &#125;        
&#125;)();

// 获取对象1
const a = Singleton.getInstance(&#39;a&#39;);
// 获取对象2
const b = Singleton.getInstance(&#39;b&#39;);
// 进行比较
console.log(a === b);
</code></pre>
<p>也可以将上述的方法稍作修改，变成构造函数的形式，如下：</p>
<pre><code class="javascript">// 单例构造函数
function CreateSingleton (name) &#123;
  this.name = name;
  this.getName();
&#125;;

// 获取实例的名字
CreateSingleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 单例对象
const Singleton = (function()&#123;
  var instance;
  return function (name) &#123;
      if(!instance) &#123;
          instance = new CreateSingleton(name);
      &#125;
      return instance;
  &#125;
&#125;)();

// 创建实例对象1
const a = new Singleton(&#39;a&#39;);
// 创建实例对象2
const b = new Singleton(&#39;b&#39;);

console.log(a===b); // true
</code></pre>
<h4 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>在前端中，很多情况都是用到单例模式，例如页面存在一个模态框的时候，只有用户点击的时候才会创建，而不是加载完成之后再创建弹窗和隐藏，并且保证弹窗全局只有一个</p>
<p>可以先创建一个通常的获取对象的方法，如下：</p>
<pre><code class="javascript">const getSingle = function( fn )&#123;
let result;
return function()&#123;
  return result || ( result = fn .apply(this, arguments ) );
&#125;
&#125;; 
</code></pre>
<p>创建弹窗的代码如下：</p>
<pre><code class="javascript">const createLoginLayer = function()&#123;
var div = document.createElement( &#39;div&#39; );
div.innerHTML = &#39;我是浮窗&#39;;
div.style.display = &#39;none&#39;;
document.body.appendChild( div );
return div;
&#125;; 

const createSingleLoginLayer = getSingle( createLoginLayer ); 

document.getElementById( &#39;loginBtn&#39; ).onclick = function()&#123;
var loginLayer = createSingleLoginLayer();
loginLayer.style.display = &#39;block&#39;;
&#125;;
</code></pre>
<p>上述这种实现称为惰性单例，意图解决需要时才创建类实例对象</p>
<p>并且<code>Vuex</code>、<code>redux</code>全局态管理库也应用单例模式的思想，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38626535306638302d336232622d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>现在很多第三方库都是单例模式，多次引用只会使用同一个对象，如<code>jquery</code>、<code>lodash</code>、<code>moment</code>…</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂</p>
<p>其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品</p>
<p>举个例子：</p>
<ul>
<li>编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联（耦合）</li>
<li>后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事；</li>
<li>这种情况下，就需要将创建实例的工作从调用方（A类）中分离，与调用方解耦，也就是使用工厂方法创建实例的工作封装起来（减少代码重复），由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，而降低调用者因为创建逻辑导致的错误；</li>
</ul>
<h4 id="二、实现-1"><a href="#二、实现-1" class="headerlink" title="二、实现"></a>二、实现</h4><p>工厂模式根据抽象程度的不同可以分为：</p>
<ul>
<li>简单工厂模式（Simple Factory）</li>
<li>工厂方法模式（Factory Method）</li>
<li>抽象工厂模式（Abstract Factory）</li>
</ul>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例</p>
<p>假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致</p>
<p>代码如下：</p>
<pre><code class="javascript">function Factory(career) &#123;
    function User(career, work) &#123;
        this.career = career 
        this.work = work
    &#125;
    let work
    switch(career) &#123;
        case &#39;coder&#39;:
            work =  [&#39;写代码&#39;, &#39;修Bug&#39;] 
            return new User(career, work)
            break
        case &#39;hr&#39;:
            work = [&#39;招聘&#39;, &#39;员工信息管理&#39;]
            return new User(career, work)
            break
        case &#39;driver&#39;:
            work = [&#39;开车&#39;]
            return new User(career, work)
            break
        case &#39;boss&#39;:
            work = [&#39;喝茶&#39;, &#39;开会&#39;, &#39;审批文件&#39;]
            return new User(career, work)
            break
    &#125;
&#125;
let coder = new Factory(&#39;coder&#39;)
console.log(coder)
let boss = new Factory(&#39;boss&#39;)
console.log(boss)
</code></pre>
<p><code>Factory</code>就是一个简单工厂。当我们调用工厂函数时，只需要传递name、age、career就可以获取到包含用户工作内容的实例对象</p>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂方法模式跟简单工厂模式差不多，但是把具体的产品放到了工厂函数的<code>prototype</code>中</p>
<p>这样一来，扩展产品种类就不必修改工厂函数了，核心类就变成抽象类，也可以随时重写某种具体的产品</p>
<p>也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产；但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产</p>
<p>如下代码：</p>
<pre><code class="javascript">// 工厂方法
function Factory(career)&#123;
    if(this instanceof Factory)&#123;
        var a = new this[career]();
        return a;
    &#125;else&#123;
        return new Factory(career);
    &#125;
&#125;
// 工厂方法函数的原型中设置所有对象的构造函数
Factory.prototype=&#123;
    &#39;coder&#39;: function()&#123;
        this.careerName = &#39;程序员&#39;
        this.work = [&#39;写代码&#39;, &#39;修Bug&#39;] 
    &#125;,
    &#39;hr&#39;: function()&#123;
        this.careerName = &#39;HR&#39;
        this.work = [&#39;招聘&#39;, &#39;员工信息管理&#39;]
    &#125;,
    &#39;driver&#39;: function () &#123;
        this.careerName = &#39;司机&#39;
        this.work = [&#39;开车&#39;]
    &#125;,
    &#39;boss&#39;: function()&#123;
        this.careerName = &#39;老板&#39;
        this.work = [&#39;喝茶&#39;, &#39;开会&#39;, &#39;审批文件&#39;]
    &#125;
&#125;
let coder = new Factory(&#39;coder&#39;)
console.log(coder)
let hr = new Factory(&#39;hr&#39;)
console.log(hr)
</code></pre>
<p>工厂方法关键核心代码是工厂里面的判断this是否属于工厂，也就是做了分支判断，这个工厂只做我能做的产品</p>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>上述简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建</p>
<p>通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的</p>
<p>由于<code>JavaScript</code>中并没有抽象类的概念，只能模拟，可以分成四部分：</p>
<ul>
<li>用于创建抽象类的函数</li>
<li>抽象类</li>
<li>具体类</li>
<li>实例化具体类</li>
</ul>
<p>上面的例子中有<code>coder</code>、<code>hr</code>、<code>boss</code>、<code>driver</code>四种岗位，其中<code>coder</code>可能使用不同的开发语言进行开发，比如<code>JavaScript</code>、<code>Java</code>等等。那么这两种语言就是对应的类簇</p>
<p>示例代码如下：</p>
<pre><code class="javascript">let CareerAbstractFactory = function(subType, superType) &#123;
  // 判断抽象工厂中是否有该抽象类
  if (typeof CareerAbstractFactory[superType] === &#39;function&#39;) &#123;
    // 缓存类
    function F() &#123;&#125;
    // 继承父类属性和方法
    F.prototype = new CareerAbstractFactory[superType]()
    // 将子类的constructor指向父类
    subType.constructor = subType;
    // 子类原型继承父类
    subType.prototype = new F()
  &#125; else &#123;
    throw new Error(&#39;抽象类不存在&#39;)
  &#125;
&#125;
</code></pre>
<p>上面代码中<code>CareerAbstractFactory</code>就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>从上面可看到，简单简单工厂的优点就是我们只要传递正确的参数，就能获得所需的对象，而不需要关心其创建的具体细节</p>
<p>应用场景也容易识别，有构造函数的地方，就应该考虑简单工厂，但是如果函数构建函数太多与复杂，会导致工厂函数变得复杂，所以不适合复杂的情况</p>
<p>抽象工厂模式一般用于严格要求以面向对象思想进行开发的超大型项目中，我们一般常规的开发的话一般就是简单工厂和工厂方法模式会用的比较多一些</p>
<p>综上，工厂模式适用场景如下：</p>
<ul>
<li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li>
<li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li>
<li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来</p>
<p>一个基于策略模式的程序至少由两部分组成：</p>
<ul>
<li>策略类，策略类封装了具体的算法，并负责具体的计算过程</li>
<li>环境类Context，Context 接受客户的请求，随后 把请求委托给某一个策略类</li>
</ul>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>举个例子，公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍</p>
<p>若使用<code>if</code>来实现，代码则如下：</p>
<pre><code class="javascript">var calculateBouns = function(salary,level) &#123;
    if(level === &#39;A&#39;) &#123;
        return salary * 4;
    &#125;
    if(level === &#39;B&#39;) &#123;
        return salary * 3;
    &#125;
    if(level === &#39;C&#39;) &#123;
        return salary * 2;
    &#125;
&#125;;
// 调用如下：
console.log(calculateBouns(4000,&#39;A&#39;)); // 16000
console.log(calculateBouns(2500,&#39;B&#39;)); // 7500
</code></pre>
<p>从上述可有看到，函数内部包含过多<code>if...else</code>，并且后续改正的时候，需要在函数内部添加逻辑，违反了开放封闭原则</p>
<p>而如果使用策略模式，就是先定义一系列算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，如下：</p>
<pre><code class="javascript">var obj = &#123;
        &quot;A&quot;: function(salary) &#123;
            return salary * 4;
        &#125;,
        &quot;B&quot; : function(salary) &#123;
            return salary * 3;
        &#125;,
        &quot;C&quot; : function(salary) &#123;
            return salary * 2;
        &#125; 
&#125;;
var calculateBouns =function(level,salary) &#123;
    return obj[level](salary);
&#125;;
console.log(calculateBouns(&#39;A&#39;,10000)); // 40000
</code></pre>
<p>上述代码中，<code>obj</code>对应的是策略类，而<code>calculateBouns</code>对应上下通信类</p>
<p>又比如实现一个表单校验的代码，常常会像如下写法：</p>
<pre><code class="javascript">var registerForm = document.getElementById(&quot;registerForm&quot;);
registerForm.onsubmit = function()&#123;
    if(registerForm.userName.value === &#39;&#39;) &#123;
        alert(&#39;用户名不能为空&#39;);
        return;
    &#125;
    if(registerForm.password.value.length &lt; 6) &#123;
        alert(&quot;密码的长度不能小于6位&quot;);
        return;
    &#125;
    if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123;
        alert(&quot;手机号码格式不正确&quot;);
        return;
    &#125;
&#125;
</code></pre>
<p>上述代码包含多处<code>if</code>语句，并且违反了开放封闭原则，如果应用中还有其他的表单，需要重复编写代码</p>
<p>此处也可以使用策略模式进行重构校验，第一步确定不变的内容，即策略规则对象，如下：</p>
<pre><code class="javascript">var strategy = &#123;
    isNotEmpty: function(value,errorMsg) &#123;
        if(value === &#39;&#39;) &#123;
            return errorMsg;
        &#125;
    &#125;,
    // 限制最小长度
    minLength: function(value,length,errorMsg) &#123;
        if(value.length &lt; length) &#123;
            return errorMsg;
        &#125;
    &#125;,
    // 手机号码格式
    mobileFormat: function(value,errorMsg) &#123;
        if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123;
            return errorMsg;
        &#125;
    &#125; 
&#125;;
</code></pre>
<p>然后找出变的地方，作为环境类<code>context</code>，负责接收用户的要求并委托给策略规则对象，如下<code>Validator</code>类：</p>
<pre><code class="javascript">var Validator = function()&#123;
        this.cache = [];  // 保存效验规则
&#125;;
Validator.prototype.add = function(dom,rule,errorMsg) &#123;
    var str = rule.split(&quot;:&quot;);
    this.cache.push(function()&#123;
        // str 返回的是 minLength:6 
        var strategy = str.shift();
        str.unshift(dom.value); // 把input的value添加进参数列表
        str.push(errorMsg);  // 把errorMsg添加进参数列表
        return strategys[strategy].apply(dom,str);
    &#125;);
&#125;;
Validator.prototype.start = function()&#123;
    for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123;
        var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息
        if(msg) &#123;
            return msg;
        &#125;
    &#125;
&#125;;
</code></pre>
<p>通过<code>validator.add</code>方法添加校验规则和错误信息提示，使用如下：</p>
<pre><code class="javascript">var validateFunc = function()&#123;
    var validator = new Validator(); // 创建一个Validator对象
    /* 添加一些效验规则 */
    validator.add(registerForm.userName,&#39;isNotEmpty&#39;,&#39;用户名不能为空&#39;);
    validator.add(registerForm.password,&#39;minLength:6&#39;,&#39;密码长度不能小于6位&#39;);
    validator.add(registerForm.userName,&#39;mobileFormat&#39;,&#39;手机号码格式不正确&#39;);

    var errorMsg = validator.start(); // 获得效验结果
    return errorMsg; // 返回效验结果
&#125;;
var registerForm = document.getElementById(&quot;registerForm&quot;);
registerForm.onsubmit = function()&#123;
    var errorMsg = validateFunc();
    if(errorMsg)&#123;
        alert(errorMsg);
        return false;
    &#125;
&#125;
</code></pre>
<p>上述通过策略模式完成表单的验证，并且可以随时调用，在修改表单验证规则的时候，也非常方便，通过传递参数即可调用</p>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>从上面可以看到，使用策略模式的优点有如下：</p>
<ul>
<li>策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句</li>
<li>策略模式提供了开放-封闭原则，使代码更容易理解和扩展</li>
<li>策略模式中的代码可以复用</li>
</ul>
<p>策略模式不仅仅用来封装算法，在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装 一系列的“业务规则”</p>
<p>只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>代理模式（Proxy Pattern）是为一个对象提供一个代用品或占位符，以便控制对它的访问</p>
<p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39353163393962302d336436612d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>在生活中，代理模式的场景是十分常见的，例如我们现在如果有租房、买房的需求，更多的是去找链家等房屋中介机构，而不是直接寻找想卖房或出租房的人谈。此时，链家起到的作用就是代理的作用</p>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p>在<code>ES6</code>中，存在<code>proxy</code>构建函数能够让我们轻松使用代理模式：</p>
<pre><code class="javascript">const proxy = new Proxy(target, handler);
</code></pre>
<p>关于<code>Proxy</code>的使用可以翻看以前的文章</p>
<p>而按照功能来划分，<code>javascript</code>代理模式常用的有：</p>
<ul>
<li>缓存代理</li>
<li>虚拟代理</li>
</ul>
<h5 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h5><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</p>
<p>如实现一个求积乘的函数，如下：</p>
<pre><code class="javascript">var muti = function () &#123;
  console.log(&quot;开始计算乘积&quot;);
  var a = 1;
  for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;
    a = a * arguments[i];
  &#125;
  return a;
&#125;;
</code></pre>
<p>现在加入缓存代理，如下：</p>
<pre><code class="javascript">var proxyMult = (function () &#123;
  var cache = &#123;&#125;;
  return function () &#123;
    var args = Array.prototype.join.call(arguments, &quot;,&quot;);
    if (args in cache) &#123;
      return cache[args];
    &#125;
    return (cache[args] = mult.apply(this, arguments));
  &#125;;
&#125;)();

proxyMult(1, 2, 3, 4); // 输出:24
proxyMult(1, 2, 3, 4); // 输出:24
</code></pre>
<p>当第二次调用 <code>proxyMult(1, 2, 3, 4)</code> 时，本体 <code>mult</code> 函数并没有被计算，<code>proxyMult</code> 直接返回了之前缓存好的计算结果</p>
<h5 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h5><p>虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建</p>
<p>常见的就是图片预加载功能：</p>
<p>未使用代理模式如下：</p>
<pre><code class="javascript">let MyImage = (function()&#123;
    let imgNode = document.createElement( &#39;img&#39; );
    document.body.appendChild( imgNode );
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;

    img.onload = function()&#123;
        // 监听到图片加载完成后，设置src为加载完成后的图片
        imgNode.src = img.src;
    &#125;;

    return &#123;
        setSrc: function( src )&#123;
            // 设置图片的时候，设置为默认的loading图
            imgNode.src = &#39;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#39;;
            // 把真正需要设置的图片传给Image对象的src属性
            img.src = src;
        &#125;
    &#125;
&#125;)();

MyImage.setSrc( &#39;https://xxx.jpg&#39; );
</code></pre>
<p><code>MyImage</code>对象除了负责给<code>img</code>节点设置<code>src</code>外，还要负责预加载图片，违反了面向对象设计的原则——单一职责原则</p>
<p>上述过程<code>loding</code>则是耦合进<code>MyImage</code>对象里的，如果以后某个时候，我们不需要预加载显示loading这个功能了，就只能在<code>MyImage</code>对象里面改动代码</p>
<p>使用代理模式，代码则如下：</p>
<pre><code class="javascript">// 图片本地对象，负责往页面中创建一个img标签，并且提供一个对外的setSrc接口
let myImage = (function()&#123;
    let imgNode = document.createElement( &#39;img&#39; );
    document.body.appendChild( imgNode );

    return &#123;
        //setSrc接口，外界调用这个接口，便可以给该img标签设置src属性
        setSrc: function( src )&#123;
            imgNode.src = src;
        &#125;
    &#125;
&#125;)();
// 代理对象，负责图片预加载功能
let proxyImage = (function()&#123;
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;
    img.onload = function()&#123;
        // 监听到图片加载完成后，给被代理的图片本地对象设置src为加载完成后的图片
        myImage.setSrc( this.src );
    &#125;
    return &#123;
        setSrc: function( src )&#123;
            // 设置图片时，在图片未被真正加载好时，以这张图作为loading，提示用户图片正在加载
            myImage.setSrc( &#39;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#39; );
            img.src = src;
        &#125;
    &#125;
&#125;)();

proxyImage.setSrc( &#39;https://xxx.jpg&#39; );
</code></pre>
<p>使用代理模式后，图片本地对象负责往页面中创建一个<code>img</code>标签，并且提供一个对外的<code>setSrc</code>接口；</p>
<p>代理对象负责在图片未加载完成之前，引入预加载的<code>loading</code>图，负责了图片预加载的功能</p>
<p>上述并没有改变或者增加<code>MyImage</code>的接口，但是通过代理对象，实际上给系统添加了新的行为</p>
<p>并且上述代理模式可以发现，代理和本体接口的一致性，如果有一天不需要预加载，那么就不需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了 <code>setSrc</code> 方法</p>
<p>‘</p>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>现在的很多前端框架或者状态管理框架都使用代理模式，用与监听变量的变化</p>
<p>使用代理模式代理对象的访问的方式，一般又被称为拦截器，比如我们在项目中经常使用 <code>Axios</code> 的实例来进行 HTTP 的请求，使用拦截器 <code>interceptor</code> 可以提前对 请求前的数据 服务器返回的数据进行一些预处理</p>
<p>以及上述应用到的缓存代理和虚拟代理</p>
<h3 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h3><h4 id="一、观察者模式"><a href="#一、观察者模式" class="headerlink" title="一、观察者模式"></a>一、观察者模式</h4><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p>
<p>观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64336138303032302d336637632d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸</p>
<p>报社和订报纸的客户就形成了一对多的依赖关系</p>
<p>实现代码如下：</p>
<p>被观察者模式</p>
<pre><code class="javascript">class Subject &#123;

  constructor() &#123;
    this.observerList = [];
  &#125;

  addObserver(observer) &#123;
    this.observerList.push(observer);
  &#125;

  removeObserver(observer) &#123;
    const index = this.observerList.findIndex(o =&gt; o.name === observer.name);
    this.observerList.splice(index, 1);
  &#125;

  notifyObservers(message) &#123;
    const observers = this.observeList;
    observers.forEach(observer =&gt; observer.notified(message));
  &#125;

&#125;
</code></pre>
<p>观察者：</p>
<pre><code class="javascript">class Observer &#123;

  constructor(name, subject) &#123;
    this.name = name;
    if (subject) &#123;
      subject.addObserver(this);
    &#125;
  &#125;

  notified(message) &#123;
    console.log(this.name, &#39;got message&#39;, message);
  &#125;
&#125;
</code></pre>
<p>使用代码如下：</p>
<pre><code class="javascript">const subject = new Subject();
const observerA = new Observer(&#39;observerA&#39;, subject);
const observerB = new Observer(&#39;observerB&#39;);
subject.addObserver(observerB);
subject.notifyObservers(&#39;Hello from subject&#39;);
subject.removeObserver(observerA);
subject.notifyObservers(&#39;Hello again&#39;);
</code></pre>
<p>上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表</p>
<h4 id="二、发布订阅模式"><a href="#二、发布订阅模式" class="headerlink" title="二、发布订阅模式"></a>二、发布订阅模式</h4><p>发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在</p>
<p>同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65323464336364302d336637632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>实现代码如下：</p>
<pre><code class="javascript">class PubSub &#123;
  constructor() &#123;
    this.messages = &#123;&#125;;
    this.listeners = &#123;&#125;;
  &#125;
  // 添加发布者
  publish(type, content) &#123;
    const existContent = this.messages[type];
    if (!existContent) &#123;
      this.messages[type] = [];
    &#125;
    this.messages[type].push(content);
  &#125;
  // 添加订阅者
  subscribe(type, cb) &#123;
    const existListener = this.listeners[type];
    if (!existListener) &#123;
      this.listeners[type] = [];
    &#125;
    this.listeners[type].push(cb);
  &#125;
  // 通知
  notify(type) &#123;
    const messages = this.messages[type];
    const subscribers = this.listeners[type] || [];
    subscribers.forEach((cb, index) =&gt; cb(messages[index]));
  &#125;
&#125;
</code></pre>
<p>发布者代码如下：</p>
<pre><code class="javascript">class Publisher &#123;
  constructor(name, context) &#123;
    this.name = name;
    this.context = context;
  &#125;
  publish(type, content) &#123;
    this.context.publish(type, content);
  &#125;
&#125;
</code></pre>
<p>订阅者代码如下：</p>
<pre><code class="javascript">class Subscriber &#123;
  constructor(name, context) &#123;
    this.name = name;
    this.context = context;
  &#125;
  subscribe(type, cb) &#123;
    this.context.subscribe(type, cb);
  &#125;
&#125;
</code></pre>
<p>使用代码如下：</p>
<pre><code class="javascript">const TYPE_A = &#39;music&#39;;
const TYPE_B = &#39;movie&#39;;
const TYPE_C = &#39;novel&#39;;

const pubsub = new PubSub();

const publisherA = new Publisher(&#39;publisherA&#39;, pubsub);
publisherA.publish(TYPE_A, &#39;we are young&#39;);
publisherA.publish(TYPE_B, &#39;the silicon valley&#39;);
const publisherB = new Publisher(&#39;publisherB&#39;, pubsub);
publisherB.publish(TYPE_A, &#39;stronger&#39;);
const publisherC = new Publisher(&#39;publisherC&#39;, pubsub);
publisherC.publish(TYPE_C, &#39;a brief history of time&#39;);

const subscriberA = new Subscriber(&#39;subscriberA&#39;, pubsub);
subscriberA.subscribe(TYPE_A, res =&gt; &#123;
  console.log(&#39;subscriberA received&#39;, res)
&#125;);
const subscriberB = new Subscriber(&#39;subscriberB&#39;, pubsub);
subscriberB.subscribe(TYPE_C, res =&gt; &#123;
  console.log(&#39;subscriberB received&#39;, res)
&#125;);
const subscriberC = new Subscriber(&#39;subscriberC&#39;, pubsub);
subscriberC.subscribe(TYPE_B, res =&gt; &#123;
  console.log(&#39;subscriberC received&#39;, res)
&#125;);

pubsub.notify(TYPE_A);
pubsub.notify(TYPE_B);
pubsub.notify(TYPE_C);
</code></pre>
<p>上述代码，发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>两种设计模式思路是一样的，举个生活例子：</p>
<ul>
<li>观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体</li>
<li>发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决</li>
</ul>
<p>上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的</p>
<p>两者区别如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f3135352f39313431363832632d373338362d346631322d383431322d6662313761316364346266362e706e67.png"></p>
<ul>
<li>在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</li>
<li>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</li>
<li>观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</li>
</ul>
<h3 id="其他完整的设计模式（感兴趣可以看看）"><a href="#其他完整的设计模式（感兴趣可以看看）" class="headerlink" title="其他完整的设计模式（感兴趣可以看看）"></a>其他完整的设计模式（感兴趣可以看看）</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904032826294286">23种设计模式</a></p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mengfeng.github.io/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            前端面试大全git
          
        </div>
      </a>
    
    
      <a href="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">前端面试大全TypeScript</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '6887374e7666a97fd4dc',
    clientSecret: '09a8e143dd4a3f5d11311e1435842321e063157d',
    repo: 'mengfeng.github.io',
    owner: 'mengfeng',
    admin: ['mengfeng'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>