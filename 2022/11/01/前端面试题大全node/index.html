<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>前端面试题大全node |  艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-前端面试题大全node"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  前端面试题大全node
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/" class="article-date">
  <time datetime="2022-11-01T02:53:32.000Z" itemprop="datePublished">2022-11-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/node-js/">node.js</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">18.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">74 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（node-js）"><a href="#前端面试题大全（node-js）" class="headerlink" title="前端面试题大全（node.js）"></a>前端面试题大全（node.js）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><h3 id="♥︎-♥︎-说说你对Node-js-的理解？优缺点？应用场景？"><a href="#♥︎-♥︎-说说你对Node-js-的理解？优缺点？应用场景？" class="headerlink" title="♥︎ ♥︎ 说说你对Node.js 的理解？优缺点？应用场景？"></a>♥︎ ♥︎ 说说你对Node.js 的理解？优缺点？应用场景？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>Node.js</code> 是一个开源与跨平台的 <code>JavaScript</code> 运行时环境</p>
<p>在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能</p>
<p>可以理解为 <code>Node.js</code> 就是一个服务器端的、非阻塞式I&#x2F;O的、事件驱动的<code>JavaScript</code>运行环境</p>
<h5 id="非阻塞异步"><a href="#非阻塞异步" class="headerlink" title="非阻塞异步"></a>非阻塞异步</h5><p><code>Nodejs</code>采用了非阻塞型<code>I/O</code>机制，在做<code>I/O</code>操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作</p>
<p>例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率</p>
<h5 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h5><p>事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数</p>
<p>比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61373732393539302d633165382d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、优缺点"><a href="#二、优缺点" class="headerlink" title="二、优缺点"></a>二、优缺点</h4><p>优点：</p>
<ul>
<li>处理高并发场景性能更佳</li>
<li>适合I&#x2F;O密集型应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I&#x2F;O硬盘内存读写操作</li>
</ul>
<p>因为<code>Nodejs</code>是单线程，带来的缺点有：</p>
<ul>
<li>不适合CPU密集型应用</li>
<li>只支持单核CPU，不能充分利用CPU</li>
<li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>
</ul>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>借助<code>Nodejs</code>的特点和弊端，其应用场景分类如下：</p>
<ul>
<li>善于<code>I/O</code>，不善于计算。因为Nodejs是一个单线程，如果计算（同步）太多，则会阻塞这个线程</li>
<li>大量并发的I&#x2F;O，应用程序内部并不需要进行非常复杂的处理</li>
<li>与 websocket 配合，开发长连接的实时交互应用程序</li>
</ul>
<p>具体场景可以表现为如下：</p>
<ul>
<li>第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序</li>
<li>第二大类：基于web、canvas等多人联网游戏</li>
<li>第三大类：基于web的多人实时聊天客户端、聊天室、图文直播</li>
<li>第四大类：单页面浏览器应用程序</li>
<li>第五大类：操作数据库、为前端和移动端提供基于<code>json</code>的API</li>
</ul>
<p>其实，<code>Nodejs</code>能实现几乎一切的应用，只考虑适不适合使用它</p>
<h3 id="♥︎-♥︎-为什么-Node-js-是单线程的？"><a href="#♥︎-♥︎-为什么-Node-js-是单线程的？" class="headerlink" title="♥︎ ♥︎ 为什么 Node.js 是单线程的？"></a>♥︎ ♥︎ 为什么 Node.js 是单线程的？</h3><p>回答一：怼：如果不幸遇到面试官问这个问题，你反问他 nodejs 为什么叫做 nodejs.</p>
<p>回答二：苟：您好，贵公司的面试题还挺有深度的，这让我越来越期待加入贵公司了。关于 ndoejs 是单线程的，刚好前段时间阅读过有关 node 的文章。node 的作者在设计之初选择语言时，评估过当时的流行语言，最终选择了存在多年在后端却一直没有市场的 js,正是 js 的不被关注，使得使用 js 没有额外阻力，而 js 在浏览器中有广泛的事件驱动方面的应用，正符合作者的喜好。于是 node 使用了 js 作为开发语言，node 的作者在开发时保持了 js 单线程的特点，所以 nodejs 是单线程的。</p>
<h3 id="♥︎-♥︎-什么是回调函数？"><a href="#♥︎-♥︎-什么是回调函数？" class="headerlink" title="♥︎ ♥︎ 什么是回调函数？"></a>♥︎ ♥︎ 什么是回调函数？</h3><p>概念：</p>
<p>回调就是一种利用函数指针进行函数调用的过程。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。</p>
<p>对普通函数的调用：</p>
<p>调用程序发出对普通函数的调用后，程序执行立即转向被调用函数执行，直到被调用函数执行完毕后，再返回调用程序继续执行。从发出调用的程序的角度看，这个过程为“调用–&gt;等待被调用函数执行完毕–&gt;继续执行”</p>
<p>对回调函数调用：</p>
<p>调用程序发出对回调函数的调用后，不等函数执行完毕，立即返回并继续执行。这样，调用程序执和被调用函数同时在执行。当被调函数执行完毕后，被调函数会反过来调用某个事先指定函数，以通知调用程序：函数调用结束。这个过程称为回调(Callback)，这正是回调函数名称的由来。<br>回调函数机制：</p>
<p>1、定义一个函数（图中的sub&#x2F;mul函数）；</p>
<p>2、将此函数的地址注册给调用者test函数；</p>
<p>3、特定的事件或条件发生时（main主函数），调用者使用函数指针调用回调函数。</p>
<p>回调函数的缺点：</p>
<p>1）回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。</p>
<p>2）回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。</p>
<h3 id="♥︎-♥︎-Node-js-和-ajax-的区别是什么"><a href="#♥︎-♥︎-Node-js-和-ajax-的区别是什么" class="headerlink" title="♥︎ ♥︎  Node.js 和 ajax 的区别是什么?"></a>♥︎ ♥︎  Node.js 和 ajax 的区别是什么?</h3><p>区别一：</p>
<p>Ajax（异步Javascript和XML的简称）是一种客户端技术，通常用于更新页面内容而不刷新它。</p>
<p>而Node.js是服务器端Javascript，是一个基于 Chrome V8 引擎的 JavaScript 运行环境，是一个让 JavaScript 运行在服务端的开发平台。</p>
<p>区别二：</p>
<p>Node.js不在浏览器中执行，而是由服务器执行。而Ajax在浏览器中执行。</p>
<p>区别三：</p>
<p>node主要是提供后台服务，而ajax主要是用来前后台数据的请求与发送数据的。</p>
<h3 id="♥︎-♥︎-请使用-Node-js-原生的-HTTP-模块创建一个-web-Server。"><a href="#♥︎-♥︎-请使用-Node-js-原生的-HTTP-模块创建一个-web-Server。" class="headerlink" title="♥︎ ♥︎ 请使用 Node.js 原生的 HTTP 模块创建一个 web Server。"></a>♥︎ ♥︎ 请使用 Node.js 原生的 HTTP 模块创建一个 web Server。</h3><pre><code class="js">const http = require(&#39;http&#39;)
const port = 3000
const server = http.createServer((req, res) =&gt; &#123;
 res.statusCode = 200
 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;)
 res.end(&#39;Hello World&#39;)
&#125;)
server.listen(port, () =&gt; &#123;
 console.log( Server is running on http://127.0.0.1:$&#123;port&#125;/ )
&#125;)
</code></pre>
<hr>
<h3 id="♥︎-♥︎-♥︎-如何使用原生-Node-js-操做-cookie？"><a href="#♥︎-♥︎-♥︎-如何使用原生-Node-js-操做-cookie？" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何使用原生 Node.js 操做 cookie？"></a>♥︎ ♥︎ ♥︎ 如何使用原生 Node.js 操做 cookie？</h3><p>获取 cookie： req.headers.cookie</p>
<p>设置 cookie： res.writeHead(200, { ‘Set-Cookie’: ‘myCookie&#x3D;test’, ‘Content-Type’: ‘text&#x2F;plain’ }) </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012732909/article/details/119107135">node操作cookie</a>参考请点击</p>
<h3 id="♥︎-♥︎-♥︎-setImmediate-和-setTimeOut-区别在哪里"><a href="#♥︎-♥︎-♥︎-setImmediate-和-setTimeOut-区别在哪里" class="headerlink" title="♥︎ ♥︎ ♥︎ setImmediate 和 setTimeOut 区别在哪里?"></a>♥︎ ♥︎ ♥︎ setImmediate 和 setTimeOut 区别在哪里?</h3><p>setImmediate 和 setTimeOut 都是延迟加载。而当这两个定时器同时运行在主模块时，运行顺序是不一定的。setTimeOut 受进程性能的约束，有可能比 setImmediate 快，也有可能慢于 setImmediate。</p>
<p>而在 I&#x2F;O 事件的回调中，setImmediate 方法的回调永远在 setTimeOut 的回调前执行。</p>
<h3 id="♥︎-♥︎-♥︎-如何更新-Node-js-的版本"><a href="#♥︎-♥︎-♥︎-如何更新-Node-js-的版本" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何更新 Node.js 的版本?"></a>♥︎ ♥︎ ♥︎ 如何更新 Node.js 的版本?</h3><pre><code class="css">npm install npm -g (在命令行中将 npm 在重新安装一遍，如需指定版本需要加上 @版本数字 )
</code></pre>
<h3 id="♥︎-♥︎-♥︎-nextTick-和-setImmediate-的区别是什么？"><a href="#♥︎-♥︎-♥︎-nextTick-和-setImmediate-的区别是什么？" class="headerlink" title="♥︎ ♥︎ ♥︎  nextTick 和 setImmediate 的区别是什么？"></a>♥︎ ♥︎ ♥︎  nextTick 和 setImmediate 的区别是什么？</h3><p>nextTick 和 setImmediate 都是延迟加载。但是 nextTick 是放在当前队列的最后一个执行，</p>
<p>setImmediate 是在下一个队列的队首执行</p>
<h3 id="♥︎-♥︎-♥︎-请使用-Node-js-编写代码实现遍历文件夹并输出所有的文件名"><a href="#♥︎-♥︎-♥︎-请使用-Node-js-编写代码实现遍历文件夹并输出所有的文件名" class="headerlink" title="♥︎ ♥︎ ♥︎ 请使用 Node.js 编写代码实现遍历文件夹并输出所有的文件名"></a>♥︎ ♥︎ ♥︎ 请使用 Node.js 编写代码实现遍历文件夹并输出所有的文件名</h3><pre><code class="js">const fs = require(&#39;fs&#39;)
const path = require(&#39;path&#39;)
const getAllFile = function (dir) &#123;
 function traverse(dir) &#123;
 fs.readdirSync(dir).forEach(file =&gt; &#123;
 const pathname = path.join(dir, file)
 if (fs.statSync(pathname).isDirectory()) &#123;
 traverse(pathname)
 &#125; else &#123;
 console.log(file)
 &#125;
 &#125;)
 &#125;
 traverse(dir)
&#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？"><a href="#♥︎-♥︎-♥︎-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？" class="headerlink" title="♥︎ ♥︎ ♥︎ token 存储在 localStorage 里，当过期时过期的 token 怎么处理？"></a>♥︎ ♥︎ ♥︎ token 存储在 localStorage 里，当过期时过期的 token 怎么处理？</h3><p>当前端进行页面跳转或者需要鉴权的操作时，会发送请求到后台，而 token 会跟随请求头一起发送，后台通过请求头接收到 token 时会进行判断，若是过期了，应该返回一个 401 的状态码给前端，前端接收到以后，应该重定向到登录页要求用户重新登陆。</p>
<h3 id="♥︎-♥︎-♥︎-MySQL-和-MongoDB-的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？"><a href="#♥︎-♥︎-♥︎-MySQL-和-MongoDB-的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？" class="headerlink" title="♥︎ ♥︎ ♥︎ MySQL 和 MongoDB 的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？"></a>♥︎ ♥︎ ♥︎ MySQL 和 MongoDB 的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>数据库模型 mysql 是关系型数据库，现在使用最多的数据存储技术 mongodb 是非关系型数据库，并且是非关系型数据库中最像关系型的数据库</p>
<p>存储方式 mongodb-以类 JSON 的文档的格式存储 mysql-不同引擎有不同的存储方式</p>
<p>数据处理方式 mongodb-基于内存，将热数据存放在物理内存中，从而达到高速读写 mysql-不同引擎有自己的特点</p>
<h4 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h4><p>mongodb 的查询语句类似于 js 使用 api 的场景，通过 . 来调用，并传递参数来进行控制查询内容 如：查询 username 为张三，age 为 27 的数据</p>
<pre><code class="ini">db.users.find(&#123; username: &#39;张三&#39;, age: 27 &#125;)
</code></pre>
<p>而 mysql 则是标准的 sql 语句，同样查询代码如下：</p>
<pre><code class="ini">select * from users where &quot;username&quot; = &quot;张三&quot; and age = 27
</code></pre>
<h3 id="♥︎-♥︎-♥︎-什么是服务端渲染，服务端渲染的优点？"><a href="#♥︎-♥︎-♥︎-什么是服务端渲染，服务端渲染的优点？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是服务端渲染，服务端渲染的优点？"></a>♥︎ ♥︎ ♥︎ 什么是服务端渲染，服务端渲染的优点？</h3><p>服务端渲染：页面渲染过程是在服务端完成，最终的 HTML 字符串，直接通过请求发送给客户端。</p>
<p>服务器端渲染的优势就是利于 SEO 优化，首屏加载快，因为客户端接收到的是完整的 HTML 页面。</p>
<h3 id="♥︎-♥︎-♥︎-如何在-Node-js-中操作-MongoDb-数据库"><a href="#♥︎-♥︎-♥︎-如何在-Node-js-中操作-MongoDb-数据库" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何在 Node.js 中操作 MongoDb 数据库"></a>♥︎ ♥︎ ♥︎ 如何在 Node.js 中操作 MongoDb 数据库</h3><h4 id="一、在-Nodejs-中使用-Mongodb"><a href="#一、在-Nodejs-中使用-Mongodb" class="headerlink" title="一、在 Nodejs 中使用 Mongodb"></a>一、在 Nodejs 中使用 Mongodb</h4><p>Nodejs 操作 mongodb 数据库官方文档：</p>
<p><a target="_blank" rel="noopener" href="http://mongodb.github.io/node-mongodb-native/">http://mongodb.github.io/node-mongodb-native/</a></p>
<pre><code class="ini">npm install mongodb --save 
或者
cnpm install mongodb --save 
或者
yarn add mongodb
</code></pre>
<h4 id="二、Nodejs-操作-MongoDb-数据库"><a href="#二、Nodejs-操作-MongoDb-数据库" class="headerlink" title="二、Nodejs 操作 MongoDb 数据库"></a>二、Nodejs 操作 MongoDb 数据库</h4><pre><code class="javascript">// 1 cnpm install mongodb --save

//2、引入mongodb
const &#123; MongoClient &#125; = require(&#39;mongodb&#39;);

//3、定义数据库连接的地址
const url = &#39;mongodb://127.0.0.1:27017&#39;;

//4、定义要操作的数据库
const dbName = &#39;itying&#39;;

//5、实例化MongoClient 传入数据库连接地址
const client = new MongoClient(url, &#123; useUnifiedTopology: true &#125;);

//6、连接数据库 操作数据

client.connect((err) =&gt; &#123;
    if (err) &#123;
        console.log(err);
        return;
    &#125;
    console.log(&quot;数据库连接成功&quot;);

    let db = client.db(dbName);

    // //1、查找数据
    db.collection(&quot;user&quot;).find(&#123;&quot;age&quot;:13&#125;).toArray((err,data)=&gt;&#123;
       if(err)&#123; 
            console.log(err);
            return;
        &#125;
        console.log(data);       
        //操作数据库完毕以后一定要 关闭数据库连接
        client.close();
    &#125;)


    //2、增加数据

    // db.collection(&quot;user&quot;).insertOne(&#123;&quot;username&quot;:&quot;nodejs操作mongodb&quot;,&quot;age&quot;:10&#125;,(err,result)=&gt;&#123;
    //     if(err)&#123; //增加失败
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;增加成功&quot;);
    //     console.log(result);
    //       //操作数据库完毕以后一定要 关闭数据库连接
    //      client.close();

    // &#125;)


    //3、修改数据

    // db.collection(&quot;user&quot;).updateOne(&#123; &quot;name&quot;: &quot;zhangsan&quot; &#125;, &#123; $set: &#123; &quot;age&quot;: 10 &#125; &#125;, (err, result) =&gt; &#123;
    //     if (err) &#123; //修改失败
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;修改成功&quot;);
    //     console.log(result);
    //     //操作数据库完毕以后一定要 关闭数据库连接
    //     client.close();
    // &#125;)


    //4、删除一条数据

    // db.collection(&quot;user&quot;).deleteOne(&#123; &quot;username&quot;: &quot;nodejs&quot; &#125;, (err)=&gt;&#123;

    //     if (err) &#123; 
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;删除一条数据成功&quot;);
    //     client.close();
    // &#125;)

     //5、删除多条数据

    // db.collection(&quot;user&quot;).deleteMany(&#123; &quot;username&quot;: &quot;nodejs&quot; &#125;, (err)=&gt;&#123;

    //     if (err) &#123; 
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;删除多条数据成功&quot;);
    //     client.close();
    // &#125;)

&#125;)
</code></pre>
<h3 id="♥︎-♥︎-♥︎-谈谈-socket-的三种常见使用方式"><a href="#♥︎-♥︎-♥︎-谈谈-socket-的三种常见使用方式" class="headerlink" title="♥︎ ♥︎ ♥︎ 谈谈 socket 的三种常见使用方式"></a>♥︎ ♥︎ ♥︎ 谈谈 socket 的三种常见使用方式</h3><p>第一种方式是 netSocket，主要使用的是 node 中的 net 模块。服务端通过 new net.createServer() 创建服务，使用 on(‘connection’) 方法建立连接，在回调函数中即可获取到客户端发送的信息。客户端通过 new net.Socket() 创建 Socket，通过 connect 连接指定端口和域名后，即可调用 write 方法发送数据</p>
<p>第二种方式是 webSocket，服务端引入第三方插件 ws 创建 socket 服务，客户端使用 H5 新增 API new WebSocket 连接服务端，通过 send 方法发送数据，onmessage 方法接收数据</p>
<p>第三种方式是 socket.io，服务端引入 socket.io’ 模块创建服务，客户端引入 socket.io.js’ 文件，建立连接后，客户端和服务端都是通过 on 方法接收数据，都是使用 emit 方法发送数据。</p>
<h3 id="♥︎-♥︎-♥︎-前后端数据交互的常见使用方式"><a href="#♥︎-♥︎-♥︎-前后端数据交互的常见使用方式" class="headerlink" title="♥︎ ♥︎ ♥︎ 前后端数据交互的常见使用方式"></a>♥︎ ♥︎ ♥︎ 前后端数据交互的常见使用方式</h3><p>cookie：前端可以直接设置或获取 cookie，后端可以使用 req.set(‘set-cookie’， ‘’)设置 cookie，在前端发送请求时通过 req 的 header 字段中获取 cookie</p>
<p>利用 AJAX，和 JQuery 中已经封装好的 $.ajax、$.post、$.getJSON 通过创建一个 XMLHttpRequest 对象，来进行前后端交互。</p>
<p>服务端渲染，浏览器请求到的内容可以通过后端加工一下，将数据直接渲染好，再返回给浏览器。</p>
<h3 id="♥︎-♥︎-♥︎-Node-js-优缺点以及适用场景"><a href="#♥︎-♥︎-♥︎-Node-js-优缺点以及适用场景" class="headerlink" title="♥︎ ♥︎ ♥︎ Node.js 优缺点以及适用场景"></a>♥︎ ♥︎ ♥︎ Node.js 优缺点以及适用场景</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Node.js 采用事件驱动、异步编程，为网络服务而设计。简单易学，可以很快上手做后端设计。</p>
<p>Node.js 非阻塞模式的 IO 处理给 Node.js 带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它 IO 资源的中间层服务。</p>
<p>Node.js 轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>单线程，可靠性低，一旦这个进程崩掉，那么整个 web 服务就崩掉了。</p>
<p>开源组件库质量参差不齐，更新快，向下不兼容</p>
<p>不适合做企业级应用开发，特别是复杂业务逻辑的，代码不好维护，事务支持不是很好。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>大量 Ajax 请求的应用，例如个性化应用，每个用户看到的页面都不一样，需要在页面加载的时候发起Ajax 请求，NodeJS 能响应大量的并发请求。</p>
<p>实时应用：如在线聊天，实时通知推送等等</p>
<p>工具类应用：海量的工具，小到前端压缩部署，大到桌面图形界面应用程序</p>
<p>总而言之，NodeJS 适合运用在高并发、I&#x2F;O 密集、少量业务逻辑的场景。</p>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-process-的理解？有哪些常用方法？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-process-的理解？有哪些常用方法？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 process 的理解？有哪些常用方法？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 process 的理解？有哪些常用方法？</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>process</code> 对象是一个全局变量，提供了有关当前 <code>Node.js </code>进程的信息并对其进行控制，作为一个全局变量</p>
<p>我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器</p>
<p>当我们启动一个<code>js</code>文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享</p>
<p>由于<code>JavaScript</code>是一个单线程语言，所以通过<code>node xxx</code>启动一个文件后，只有一条主线程</p>
<h4 id="二、属性与方法"><a href="#二、属性与方法" class="headerlink" title="二、属性与方法"></a>二、属性与方法</h4><p>关于<code>process</code>常见的属性有如下：</p>
<ul>
<li>process.env：环境变量，例如通过 &#96;process.env.NODE_ENV 获取不同环境项目配置信息</li>
<li>process.nextTick：这个在谈及 <code>EventLoop</code> 时经常为会提到</li>
<li>process.pid：获取当前进程id</li>
<li>process.ppid：当前进程对应的父进程</li>
<li>process.cwd()：获取当前进程工作目录，</li>
<li>process.platform：获取当前进程运行的操作系统平台</li>
<li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li>
<li>进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</li>
<li>三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li>
<li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li>
</ul>
<p>下面再稍微介绍下某些方法的使用：</p>
<h5 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h5><p>返回当前 <code>Node </code>进程执行的目录</p>
<p>一个<code> Node</code> 模块 <code>A</code> 通过 NPM 发布，项目 <code>B</code> 中使用了模块 <code>A</code>。在 <code>A</code> 中需要操作 <code>B</code> 项目下的文件时，就可以用 <code>process.cwd()</code> 来获取 <code>B</code> 项目的路径</p>
<h5 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h5><p>在终端通过 Node 执行命令的时候，通过 <code>process.argv</code> 可以获取传入的命令行参数，返回值是一个数组：</p>
<ul>
<li>0: Node 路径（一般用不到，直接忽略）</li>
<li>1: 被执行的 JS 文件路径（一般用不到，直接忽略）</li>
<li>2~n: 真实传入命令的参数</li>
</ul>
<p>所以，我们只要从 <code>process.argv[2]</code> 开始获取就好了</p>
<pre><code class="ini">const args = process.argv.slice(2);
</code></pre>
<h5 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h5><p>返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。</p>
<p>一般我们会在 <code>process.env</code> 上挂载一些变量标识当前的环境。比如最常见的用 <code>process.env.NODE_ENV</code> 区分 <code>development</code> 和 <code>production</code></p>
<p>在 <code>vue-cli</code> 的源码中也经常会看到 <code>process.env.VUE_CLI_DEBUG</code> 标识当前是不是 <code>DEBUG</code> 模式</p>
<h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h5><p>我们知道<code>NodeJs</code>是基于事件轮询，在这个过程中，同一时间只会处理一件事情</p>
<p>在这种处理模式下，<code>process.nextTick()</code>就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行</p>
<p>例如下面例子将一个<code>foo</code>函数在下一个时间点调用</p>
<pre><code class="js">function foo() &#123;
    console.error(&#39;foo&#39;);
&#125;

process.nextTick(foo);
console.error(&#39;bar&#39;);
</code></pre>
<p>输出结果为<code>bar</code>、<code>foo</code></p>
<p>虽然下述方式也能实现同样效果：</p>
<pre><code class="javascript">setTimeout(foo, 0);
console.log(&#39;bar&#39;);
</code></pre>
<p>两者区别在于：</p>
<ul>
<li>process.nextTick()会在这一次event loop的call stack清空后（下一次event loop开始前）再调用callback</li>
<li>setTimeout()是并不知道什么时候call stack清空的，所以何时调用callback函数是不确定的</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-fs模块的理解-有哪些常用方法"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-fs模块的理解-有哪些常用方法" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 fs模块的理解? 有哪些常用方法"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 fs模块的理解? 有哪些常用方法</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>fs（filesystem），该模块提供本地文件的读写能力，基本上是<code>POSIX</code>文件操作命令的简单包装</p>
<p>可以说，所有与文件的操作都是通过<code>fs</code>核心模块实现</p>
<p>导入模块如下：</p>
<pre><code class="ini">const fs = require(&#39;fs&#39;);
</code></pre>
<p>这个模块对所有文件系统操作提供异步（不具有<code>sync</code> 后缀）和同步（具有 <code>sync</code> 后缀）两种操作方式，而供开发者选择</p>
<h4 id="二、文件知识"><a href="#二、文件知识" class="headerlink" title="二、文件知识"></a>二、文件知识</h4><p>在计算机中有关于文件的知识：</p>
<ul>
<li>权限位 mode</li>
<li>标识位 flag</li>
<li>文件描述为 fd</li>
</ul>
<h5 id="权限位-mode"><a href="#权限位-mode" class="headerlink" title="权限位 mode"></a>权限位 mode</h5><p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34663464343161302d633436622d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位4、2、1，不具备权限为0</p>
<p>如在<code>linux</code>查看文件权限位：</p>
<pre><code class="javascript">drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core
-rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md
</code></pre>
<p>在开头前十位中，<code>d</code>为文件夹，<code>-</code>为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限</p>
<h5 id="标识位"><a href="#标识位" class="headerlink" title="标识位"></a>标识位</h5><p>标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读取文件，如果文件不存在则抛出异常。</td>
</tr>
<tr>
<td>r+</td>
<td>读取并写入文件，如果文件不存在则抛出异常。</td>
</tr>
<tr>
<td>rs</td>
<td>读取并写入文件，指示操作系统绕开本地文件系统缓存。</td>
</tr>
<tr>
<td>w</td>
<td>写入文件，文件不存在会被创建，存在则清空后写入。</td>
</tr>
<tr>
<td>wx</td>
<td>写入文件，排它方式打开。</td>
</tr>
<tr>
<td>w+</td>
<td>读取并写入文件，文件不存在则创建文件，存在则清空后写入。</td>
</tr>
<tr>
<td>wx+</td>
<td>和 w+ 类似，排他方式打开。</td>
</tr>
<tr>
<td>a</td>
<td>追加写入，文件不存在则创建文件。</td>
</tr>
<tr>
<td>ax</td>
<td>与 a 类似，排他方式打开。</td>
</tr>
<tr>
<td>a+</td>
<td>读取并追加写入，不存在则创建。</td>
</tr>
<tr>
<td>ax+</td>
<td>与 a+ 类似，排他方式打开。</td>
</tr>
</tbody></table>
<h5 id="文件描述为-fd"><a href="#文件描述为-fd" class="headerlink" title="文件描述为 fd"></a>文件描述为 fd</h5><p>操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件</p>
<p><code>Window </code>系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，<code>NodeJS </code>抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符</p>
<p>在 <code>NodeJS </code>中，每操作一个文件，文件描述符是递增的，文件描述符一般从 <code>3</code> 开始，因为前面有 <code>0</code>、<code>1</code>、<code>2</code>三个比较特殊的描述符，分别代表 <code>process.stdin</code>（标准输入）、<code>process.stdout</code>（标准输出）和 <code>process.stderr</code>（错误输出）</p>
<h4 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h4><p>下面针对<code>fs</code>模块常用的方法进行展开：</p>
<ul>
<li>文件读取</li>
<li>文件写入</li>
<li>文件追加写入</li>
<li>文件拷贝</li>
<li>创建目录</li>
</ul>
<h5 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h5><h6 id="fs-readFileSync"><a href="#fs-readFileSync" class="headerlink" title="fs.readFileSync"></a>fs.readFileSync</h6><p>同步读取，参数如下：</p>
<ul>
<li>第一个参数为读取文件的路径或文件描述符</li>
<li>第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding</li>
</ul>
<p>结果为返回文件的内容</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

let buf = fs.readFileSync(&quot;1.txt&quot;);
let data = fs.readFileSync(&quot;1.txt&quot;, &quot;utf8&quot;);

console.log(buf); // &lt;Buffer 48 65 6c 6c 6f&gt;
console.log(data); // Hello
</code></pre>
<h6 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile"></a>fs.readFile</h6><p>异步读取方法 <code>readFile</code> 与 <code>readFileSync</code> 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 <code>err</code>（错误）和 <code>data</code>（数据），该方法没有返回值，回调函数在读取文件成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.readFile(&quot;1.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
   if(!err)&#123;
       console.log(data); // Hello
   &#125;
&#125;);
</code></pre>
<h5 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h5><h6 id="writeFileSync"><a href="#writeFileSync" class="headerlink" title="writeFileSync"></a>writeFileSync</h6><p>同步写入，有三个参数：</p>
<ul>
<li>第一个参数为写入文件的路径或文件描述符</li>
<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>
<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>
</ul>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.writeFileSync(&quot;2.txt&quot;, &quot;Hello world&quot;);
let data = fs.readFileSync(&quot;2.txt&quot;, &quot;utf8&quot;);

console.log(data); // Hello world
</code></pre>
<h6 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h6><p>异步写入，<code>writeFile</code> 与 <code>writeFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件写入数据成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.writeFile(&quot;2.txt&quot;, &quot;Hello world&quot;, err =&gt; &#123;
    if (!err) &#123;
        fs.readFile(&quot;2.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
            console.log(data); // Hello world
        &#125;);
    &#125;
&#125;);
</code></pre>
<h5 id="文件追加写入"><a href="#文件追加写入" class="headerlink" title="文件追加写入"></a>文件追加写入</h5><h6 id="appendFileSync"><a href="#appendFileSync" class="headerlink" title="appendFileSync"></a>appendFileSync</h6><p>参数如下：</p>
<ul>
<li>第一个参数为写入文件的路径或文件描述符</li>
<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>
<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>
</ul>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.appendFileSync(&quot;3.txt&quot;, &quot; world&quot;);
let data = fs.readFileSync(&quot;3.txt&quot;, &quot;utf8&quot;);
</code></pre>
<h6 id="appendFile"><a href="#appendFile" class="headerlink" title="appendFile"></a>appendFile</h6><p>异步追加写入方法 <code>appendFile</code> 与 <code>appendFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件追加写入数据成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.appendFile(&quot;3.txt&quot;, &quot; world&quot;, err =&gt; &#123;
    if (!err) &#123;
        fs.readFile(&quot;3.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
            console.log(data); // Hello world
        &#125;);
    &#125;
&#125;);
</code></pre>
<h5 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h5><h6 id="copyFileSync"><a href="#copyFileSync" class="headerlink" title="copyFileSync"></a>copyFileSync</h6><p>同步拷贝</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.copyFileSync(&quot;3.txt&quot;, &quot;4.txt&quot;);
let data = fs.readFileSync(&quot;4.txt&quot;, &quot;utf8&quot;);

console.log(data); // Hello world
</code></pre>
<h6 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h6><p>异步拷贝</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.copyFile(&quot;3.txt&quot;, &quot;4.txt&quot;, () =&gt; &#123;
    fs.readFile(&quot;4.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
        console.log(data); // Hello world
    &#125;);
&#125;);
</code></pre>
<h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><h6 id="mkdirSync"><a href="#mkdirSync" class="headerlink" title="mkdirSync"></a>mkdirSync</h6><p>同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常</p>
<pre><code class="javascript">// 假设已经有了 a 文件夹和 a 下的 b 文件夹
fs.mkdirSync(&quot;a/b/c&quot;)
</code></pre>
<h6 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h6><p>异步创建，第二个参数为回调函数</p>
<pre><code class="javascript">fs.mkdir(&quot;a/b/c&quot;, err =&gt; &#123;
    if (!err) console.log(&quot;创建成功&quot;);
&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-Buffer-的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-Buffer-的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 Buffer 的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 Buffer 的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在<code>Node</code>应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而<code>Buffer</code>就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据</p>
<p>在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量</p>
<p>如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理</p>
<p>这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 <code>RAM</code> 中</p>
<p>简单来讲，<code>Nodejs</code>不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在<code>Buffer</code>中，即在<code>RAM</code>中，直至将它们发送完毕</p>
<p>上面讲到了<code>Buffer</code>是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存8位二进制：<code>00000000</code>，也就是一个字节</p>
<p>例如：</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;why&quot;)
</code></pre>
<p>其存储过程如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32303337313235302d633639632d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h4><p><code>Buffer</code> 类在全局作用域中，无须<code>require</code>导入</p>
<p>创建<code>Buffer</code>的方法有很多种，我们讲讲下面的两种常见的形式：</p>
<ul>
<li>Buffer.from()</li>
<li>Buffer.alloc()</li>
</ul>
<h5 id="Buffer-from"><a href="#Buffer-from" class="headerlink" title="Buffer.from()"></a>Buffer.from()</h5><pre><code class="javascript">const b1 = Buffer.from(&#39;10&#39;);
const b2 = Buffer.from(&#39;10&#39;, &#39;utf8&#39;);
const b3 = Buffer.from([10]);
const b4 = Buffer.from(b3);

console.log(b1, b2, b3, b4); // &lt;Buffer 31 30&gt; &lt;Buffer 31 30&gt; &lt;Buffer 0a&gt; &lt;Buffer 0a&gt;
</code></pre>
<h5 id="Buffer-alloc"><a href="#Buffer-alloc" class="headerlink" title="Buffer.alloc()"></a>Buffer.alloc()</h5><pre><code class="javascript">const bAlloc1 = Buffer.alloc(10); // 创建一个大小为 10 个字节的缓冲区
const bAlloc2 = Buffer.alloc(10, 1); // 建一个长度为 10 的 Buffer,其中全部填充了值为 `1` 的字节
console.log(bAlloc1); // &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;
console.log(bAlloc2); // &lt;Buffer 01 01 01 01 01 01 01 01 01 01&gt;
</code></pre>
<p>在上面创建<code>buffer</code>后，则能够<code>toString</code>的形式进行交互，默认情况下采取<code>utf8</code>字符编码形式，如下</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;你好&quot;);
console.log(buffer);
// &lt;Buffer e4 bd a0 e5 a5 bd&gt;
const str = buffer.toString();
console.log(str);
// 你好
</code></pre>
<p>如果编码与解码不是相同的格式则会出现乱码的情况，如下：</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;你好&quot;,&quot;utf-8 &quot;);
console.log(buffer);
// &lt;Buffer e4 bd a0 e5 a5 bd&gt;
const str = buffer.toString(&quot;ascii&quot;);
console.log(str); 
// d= e%=
</code></pre>
<p>当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下：</p>
<pre><code class="javascript">const buf = Buffer.from(&#39;Node.js 技术栈&#39;, &#39;UTF-8&#39;);

console.log(buf)          // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;
console.log(buf.length)   // 17

console.log(buf.toString(&#39;UTF-8&#39;, 0, 9))  // Node.js �
console.log(buf.toString(&#39;UTF-8&#39;, 0, 11)) // Node.js 技
</code></pre>
<p>所支持的字符集有如下：</p>
<ul>
<li>ascii：仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的</li>
<li>utf8：多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8</li>
<li>utf16le：2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000至 U+10FFFF）</li>
<li>ucs2，utf16le 的别名</li>
<li>base64：Base64 编码</li>
<li>latin：一种把 Buffer 编码成一字节编码的字符串的方式</li>
<li>binary：latin1 的别名，</li>
<li>hex：将每个字节编码为两个十六进制字符</li>
</ul>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p><code>Buffer</code>的应用场景常常与流的概念联系在一起，例如有如下：</p>
<ul>
<li>I&#x2F;O操作</li>
<li>加密解密</li>
<li>zlib.js</li>
</ul>
<h5 id="I-x2F-O操作"><a href="#I-x2F-O操作" class="headerlink" title="I&#x2F;O操作"></a>I&#x2F;O操作</h5><p>通过流的形式，将一个文件的内容读取到另外一个文件</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;);

const inputStream = fs.createReadStream(&#39;input.txt&#39;); // 创建可读流
const outputStream = fs.createWriteStream(&#39;output.txt&#39;); // 创建可写流

inputStream.pipe(outputStream); // 管道读写
</code></pre>
<h5 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h5><p>在一些加解密算法中会遇到使用 <code>Buffer</code>，例如 <code>crypto.createCipheriv</code> 的第二个参数 <code>key</code> 为 <code>string</code> 或 <code>Buffer</code> 类型</p>
<h5 id="zlib-js"><a href="#zlib-js" class="headerlink" title="zlib.js"></a>zlib.js</h5><p><code>zlib.js</code> 为 <code>Node.js</code> 的核心库之一，其利用了缓冲区（<code>Buffer</code>）的功能来操作二进制数据流，提供了压缩或解压功能</p>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-Stream-的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-Stream-的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 Stream 的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 Stream 的理解？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>流（Stream），是一个数据传输手段，是端到端信息交换的一种方式，而且是有顺序的,是逐块读取数据、处理内容，用于顺序读取输入或写入输出</p>
<p><code>Node.js</code>中很多对象都实现了流，总之它是会冒数据（以 <code>Buffer</code> 为单位）</p>
<p>它的独特之处在于，它不像传统的程序那样一次将一个文件读入内存，而是逐块读取数据、处理其内容，而不是将其全部保存在内存中</p>
<p>流可以分成三部分：<code>source</code>、<code>dest</code>、<code>pipe</code></p>
<p>在<code>source</code>和<code>dest</code>之间有一个连接的管道<code>pipe</code>,它的基本语法是<code>source.pipe(dest)</code>，<code>source</code>和<code>dest</code>就是通过pipe连接，让数据从<code>source</code>流向了<code>dest</code>，如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61656330353637302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、种类"><a href="#二、种类" class="headerlink" title="二、种类"></a>二、种类</h4><p>在<code>NodeJS</code>，几乎所有的地方都使用到了流的概念，分成四个种类：</p>
<ul>
<li>可写流：可写入数据的流。例如 fs.createWriteStream() 可以使用流将数据写入文件</li>
<li>可读流： 可读取数据的流。例如fs.createReadStream() 可以从文件读取内容</li>
<li>双工流： 既可读又可写的流。例如 net.Socket</li>
<li>转换流： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据</li>
</ul>
<p>在<code>NodeJS</code>中<code>HTTP</code>服务器模块中，<code>request</code> 是可读流，<code>response</code> 是可写流。还有<code>fs</code> 模块，能同时处理可读和可写文件流</p>
<p>可读流和可写流都是单向的，比较容易理解，而另外两个是双向的</p>
<h5 id="双工流"><a href="#双工流" class="headerlink" title="双工流"></a>双工流</h5><p>之前了解过<code>websocket</code>通信，是一个全双工通信，发送方和接受方都是各自独立的方法，发送和接收都没有任何关系</p>
<p>如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62376163366430302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>基本代码如下：</p>
<pre><code class="javascript">const &#123; Duplex &#125; = require(&#39;stream&#39;);

const myDuplex = new Duplex(&#123;
  read(size) &#123;
    // ...
  &#125;,
  write(chunk, encoding, callback) &#123;
    // ...
  &#125;
&#125;);
</code></pre>
<h5 id="双工流-1"><a href="#双工流-1" class="headerlink" title="双工流"></a>双工流</h5><p>双工流的演示图如下所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63303238383362302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>除了上述压缩包的例子，还比如一个 <code>babel</code>，把<code>es6</code>转换为，我们在左边写入 <code>es6</code>，从右边读取 <code>es5</code></p>
<p>基本代码如下所示：</p>
<pre><code class="javascript">const &#123; Transform &#125; = require(&#39;stream&#39;);

const myTransform = new Transform(&#123;
  transform(chunk, encoding, callback) &#123;
    // ...
  &#125;
&#125;);
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p><code>stream</code>的应用场景主要就是处理<code>IO</code>操作，而<code>http</code>请求和文件操作都属于<code>IO</code>操作</p>
<p>思想一下，如果一次<code>IO</code>操作过大，硬件的开销就过大，而将此次大的<code>IO</code>操作进行分段操作，让数据像水管一样流动，知道流动完成</p>
<p>常见的场景有：</p>
<ul>
<li>get请求返回文件给客户端</li>
<li>文件操作</li>
<li>一些打包工具的底层操作</li>
</ul>
<h5 id="get请求返回文件给客户端"><a href="#get请求返回文件给客户端" class="headerlink" title="get请求返回文件给客户端"></a>get请求返回文件给客户端</h5><p>使用<code>stream</code>流返回文件，<code>res</code>也是一个<code>stream</code>对象，通过<code>pipe</code>管道将文件数据返回</p>
<pre><code class="javascript">const server = http.createServer(function (req, res) &#123;
    const method = req.method; // 获取请求方法
    if (method === &#39;GET&#39;) &#123; // get 请求
        const fileName = path.resolve(__dirname, &#39;data.txt&#39;);
        let stream = fs.createReadStream(fileName);
        stream.pipe(res); // 将 res 作为 stream 的 dest
    &#125;
&#125;);
server.listen(8000);
</code></pre>
<h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><p>创建一个可读数据流<code>readStream</code>，一个可写数据流<code>writeStream</code>，通过<code>pipe</code>管道把数据流转过去</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;)
const path = require(&#39;path&#39;)

// 两个文件名
const fileName1 = path.resolve(__dirname, &#39;data.txt&#39;)
const fileName2 = path.resolve(__dirname, &#39;data-bak.txt&#39;)
// 读取文件的 stream 对象
const readStream = fs.createReadStream(fileName1)
// 写入文件的 stream 对象
const writeStream = fs.createWriteStream(fileName2)
// 通过 pipe执行拷贝，数据流转
readStream.pipe(writeStream)
// 数据读取完成监听，即拷贝完成
readStream.on(&#39;end&#39;, function () &#123;
    console.log(&#39;拷贝完成&#39;)
&#125;)
</code></pre>
<h5 id="一些打包工具的底层操作"><a href="#一些打包工具的底层操作" class="headerlink" title="一些打包工具的底层操作"></a>一些打包工具的底层操作</h5><p>目前一些比较火的前端打包构建工具，都是通过<code>node.js</code>编写的，打包和构建的过程肯定是文件频繁操作的过程，离不来<code>stream</code>，如<code>gulp</code></p>
<h3 id="♥︎-♥︎-♥︎-说说Node中的EventEmitter-如何实现一个EventEmitter"><a href="#♥︎-♥︎-♥︎-说说Node中的EventEmitter-如何实现一个EventEmitter" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说Node中的EventEmitter? 如何实现一个EventEmitter?"></a>♥︎ ♥︎ ♥︎ 说说Node中的EventEmitter? 如何实现一个EventEmitter?</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>我们了解到，<code>Node </code>采用了事件驱动机制，而<code>EventEmitter </code>就是<code>Node</code>实现事件驱动的基础</p>
<p>在<code>EventEmitter</code>的基础上，<code>Node </code>几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作</p>
<p><code>Node.js</code> 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件</p>
<p>这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上</p>
<h4 id="二、使用方法-1"><a href="#二、使用方法-1" class="headerlink" title="二、使用方法"></a>二、使用方法</h4><p><code>Node </code>的<code>events</code>模块只提供了一个<code>EventEmitter</code>类，这个类实现了<code>Node</code>异步事件驱动架构的基本模式——观察者模式</p>
<p>在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们</p>
<p>基本代码如下所示：</p>
<pre><code class="javascript">const EventEmitter = require(&#39;events&#39;)

class MyEmitter extends EventEmitter &#123;&#125;
const myEmitter = new MyEmitter()

function callback() &#123;
    console.log(&#39;触发了event事件！&#39;)
&#125;
myEmitter.on(&#39;event&#39;, callback)
myEmitter.emit(&#39;event&#39;)
myEmitter.removeListener(&#39;event&#39;, callback);
</code></pre>
<p>通过实例对象的<code>on</code>方法注册一个名为<code>event</code>的事件，通过<code>emit</code>方法触发该事件，而<code>removeListener</code>用于取消事件的监听</p>
<p>关于其常见的方法如下：</p>
<ul>
<li>emitter.addListener&#x2F;on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部</li>
<li>emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部</li>
<li>emitter.emit(eventName[, …args])：触发类型为 eventName 的监听事件</li>
<li>emitter.removeListener&#x2F;off(eventName, listener)：移除类型为 eventName 的监听事件</li>
<li>emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除</li>
<li>emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件</li>
</ul>
<h4 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h4><p>通过上面的方法了解，<code>EventEmitter</code>是一个构造函数，内部存在一个包含所有事件的对象</p>
<pre><code class="javascript">class EventEmitter &#123;
    constructor() &#123;
        this.events = &#123;&#125;;
    &#125;
&#125;
</code></pre>
<p>其中<code>events</code>存放的监听事件的函数的结构如下：</p>
<pre><code class="javascript">&#123;
  &quot;event1&quot;: [f1,f2,f3]，
  &quot;event2&quot;: [f4,f5]，
  ...
&#125;
</code></pre>
<p>然后开始一步步实现实例方法，首先是<code>emit</code>，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：</p>
<pre><code class="javascript">emit(type, ...args) &#123;
    this.events[type].forEach((item) =&gt; &#123;
        Reflect.apply(item, this, args);
    &#125;);
&#125;
</code></pre>
<p>当实现了<code>emit</code>方法之后，然后实现<code>on</code>、<code>addListener</code>、<code>prependListener</code>这三个实例方法，都是添加事件监听触发函数，实现也是大同小异</p>
<pre><code class="javascript">on(type, handler) &#123;
    if (!this.events[type]) &#123;
        this.events[type] = [];
    &#125;
    this.events[type].push(handler);
&#125;

addListener(type,handler)&#123;
    this.on(type,handler)
&#125;

prependListener(type, handler) &#123;
    if (!this.events[type]) &#123;
        this.events[type] = [];
    &#125;
    this.events[type].unshift(handler);
&#125;
</code></pre>
<p>紧接着就是实现事件监听的方法<code>removeListener/on</code></p>
<pre><code class="javascript">removeListener(type, handler) &#123;
    if (!this.events[type]) &#123;
        return;
    &#125;
    this.events[type] = this.events[type].filter(item =&gt; item !== handler);
&#125;

off(type,handler)&#123;
    this.removeListener(type,handler)
&#125;
</code></pre>
<p>最后再来实现<code>once</code>方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过<code>fired</code>属性值判断事件函数是否执行过</p>
<pre><code class="javascript">once(type, handler) &#123;
    this.on(type, this._onceWrap(type, handler, this));
  &#125;

  _onceWrap(type, handler, target) &#123;
    const state = &#123; fired: false, handler, type , target&#125;;
    const wrapFn = this._onceWrapper.bind(state);
    state.wrapFn = wrapFn;
    return wrapFn;
  &#125;

  _onceWrapper(...args) &#123;
    if (!this.fired) &#123;
      this.fired = true;
      Reflect.apply(this.handler, this.target, args);
      this.target.off(this.type, this.wrapFn);
    &#125;
 &#125;
</code></pre>
<p>完整代码如下：</p>
<pre><code class="javascript">class EventEmitter &#123;
    constructor() &#123;
        this.events = &#123;&#125;;
    &#125;

    on(type, handler) &#123;
        if (!this.events[type]) &#123;
            this.events[type] = [];
        &#125;
        this.events[type].push(handler);
    &#125;

    addListener(type,handler)&#123;
        this.on(type,handler)
    &#125;

    prependListener(type, handler) &#123;
        if (!this.events[type]) &#123;
            this.events[type] = [];
        &#125;
        this.events[type].unshift(handler);
    &#125;

    removeListener(type, handler) &#123;
        if (!this.events[type]) &#123;
            return;
        &#125;
        this.events[type] = this.events[type].filter(item =&gt; item !== handler);
    &#125;

    off(type,handler)&#123;
        this.removeListener(type,handler)
    &#125;

    emit(type, ...args) &#123;
        this.events[type].forEach((item) =&gt; &#123;
            Reflect.apply(item, this, args);
        &#125;);
    &#125;

    once(type, handler) &#123;
        this.on(type, this._onceWrap(type, handler, this));
    &#125;

    _onceWrap(type, handler, target) &#123;
        const state = &#123; fired: false, handler, type , target&#125;;
        const wrapFn = this._onceWrapper.bind(state);
        state.wrapFn = wrapFn;
        return wrapFn;
    &#125;

    _onceWrapper(...args) &#123;
        if (!this.fired) &#123;
            this.fired = true;
            Reflect.apply(this.handler, this.target, args);
            this.target.off(this.type, this.wrapFn);
        &#125;
    &#125;
&#125;
</code></pre>
<p>测试代码如下：</p>
<pre><code class="javascript">const ee = new EventEmitter();// 注册所有事件ee.once(&#39;wakeUp&#39;, (name) =&gt; &#123; console.log(`$&#123;name&#125; 1`); &#125;);ee.on(&#39;e
</code></pre>
<h3 id="♥︎-♥︎-♥︎-说说-Node-文件查找的优先级以及-Require-方法的文件查找策略"><a href="#♥︎-♥︎-♥︎-说说-Node-文件查找的优先级以及-Require-方法的文件查找策略" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?"></a>♥︎ ♥︎ ♥︎ 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?</h3><h4 id="一、模块规范"><a href="#一、模块规范" class="headerlink" title="一、模块规范"></a>一、模块规范</h4><p><code>NodeJS</code>对<code>CommonJS</code>进行了支持和实现，让我们在开发<code>node</code>的过程中可以方便的进行模块化开发：</p>
<ul>
<li>在Node中每一个js文件都是一个单独的模块</li>
<li>模块中包括CommonJS规范的核心变量：exports、module.exports、require</li>
<li>通过上述变量进行模块化开发</li>
</ul>
<p>而模块化的核心是导出与导入，在<code>Node</code>中通过<code>exports</code>与<code>module.exports</code>负责对模块中的内容进行导出，通过<code>require</code>函数导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</p>
<h4 id="二、查找策略"><a href="#二、查找策略" class="headerlink" title="二、查找策略"></a>二、查找策略</h4><p><code>require</code>方法接收一下几种参数的传递：</p>
<ul>
<li>原生模块：http、fs、path等</li>
<li>相对路径的文件模块：.&#x2F;mod或..&#x2F;mod</li>
<li>绝对路径的文件模块：&#x2F;pathtomodule&#x2F;mod</li>
<li>目录作为模块：.&#x2F;dirname</li>
<li>非原生模块的文件模块：mod</li>
</ul>
<p><code>require</code>参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33336165386566302d633962612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会优先从缓存中加载已经存在的模块</p>
<h5 id="原生模块"><a href="#原生模块" class="headerlink" title="原生模块"></a>原生模块</h5><p>而像原生模块这些，通过<code>require </code>方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载</p>
<h5 id="绝对路径、相对路径"><a href="#绝对路径、相对路径" class="headerlink" title="绝对路径、相对路径"></a>绝对路径、相对路径</h5><p>如果<code>require</code>绝对路径的文件，则直接查找对应的路径，速度最快</p>
<p>相对路径的模块则相对于当前调用<code>require</code>的文件去查找</p>
<p>如果按确切的文件名没有找到模块，则 <code>NodeJs</code> 会尝试带上 <code>.js</code>、<code>.json </code>或 <code>.node </code>拓展名再加载</p>
<h5 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h5><p>默认情况是根据根目录中<code>package.json</code>文件的<code>main</code>来指定目录模块，如：</p>
<pre><code class="javascript">&#123; &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;main.js&quot; &#125;
</code></pre>
<p>如果这是在<code>./some-library node_modules</code>目录中，则 <code>require(&#39;./some-library&#39;)</code> 会试图加载 <code>./some-library/main.js</code></p>
<p>如果目录里没有 <code>package.json</code>文件，或者 <code>main</code>入口不存在或无法解析，则会试图加载目录下的 <code>index.js</code> 或 <code>index.node</code> 文件</p>
<h5 id="非原生模块"><a href="#非原生模块" class="headerlink" title="非原生模块"></a>非原生模块</h5><p>在每个文件中都存在<code>module.paths</code>，表示模块的搜索路径，<code>require</code>就是根据其来寻找文件</p>
<p>在<code>window</code>下输出如下：</p>
<pre><code class="javascript">[ &#39;c:\\nodejs\\node_modules&#39;,
&#39;c:\\node_modules&#39; ]
</code></pre>
<p>可以看出<code>module path</code>的生成规则为：从当前文件目录开始查找<code>node_modules</code>目录；然后依次进入父目录，查找父目录下的<code>node_modules</code>目录，依次迭代，直到根目录下的<code>node_modules</code>目录</p>
<p>当都找不到的时候，则会从系统<code>NODE_PATH</code>环境变量查找</p>
<h5 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h5><p>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ul>
<li>&#x2F;home&#x2F;ry&#x2F;projects&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;home&#x2F;ry&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;home&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;node_modules&#x2F;bar.js</li>
</ul>
<p>这使得程序本地化它们的依赖，避免它们产生冲突</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面模块的文件查找策略之后，总结下文件查找的优先级：</p>
<ul>
<li>缓存的模块优先级最高</li>
<li>如果是内置模块，则直接返回，优先级仅次缓存的模块</li>
<li>如果是绝对路径 &#x2F; 开头，则从根目录找</li>
<li>如果是相对路径 .&#x2F;开头，则从当前require文件相对位置找</li>
<li>如果文件没有携带后缀，先从js、json、node按顺序查找</li>
<li>如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js</li>
<li>如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何实现jwt鉴权机制？说说你的思路"><a href="#♥︎-♥︎-♥︎-如何实现jwt鉴权机制？说说你的思路" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何实现jwt鉴权机制？说说你的思路"></a>♥︎ ♥︎ ♥︎ 如何实现jwt鉴权机制？说说你的思路</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>JWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30353239303463302d636438392d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在目前前后端分离的开发过程中，使用<code>token</code>鉴权机制用于身份验证是最常见的方案，流程如下：</p>
<ul>
<li>服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证</li>
<li>后续访问会根据这个令牌判断用户时候有权限进行访问</li>
</ul>
<p><code>Token</code>，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以<code>.</code>进行拼接。其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31313735663939302d636438392d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="header"><a href="#header" class="headerlink" title="header"></a>header</h5><p>每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为<code>alg</code>，同时还有一个<code>typ</code>的字段，默认<code>JWT</code>即可。以下示例中算法为HS256</p>
<pre><code class="javascript">&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot; &#125; 
</code></pre>
<p>因为JWT是字符串，所以我们还需要对以上内容进行Base64编码，编码后字符串如下：</p>
<pre><code class="ini">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9        
</code></pre>
<h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p>载荷即消息体，这里会存放实际的内容，也就是<code>Token</code>的数据声明，例如用户的<code>id</code>和<code>name</code>，默认情况下也会携带令牌的签发时间<code>iat</code>，通过还可以设置过期时间，如下：</p>
<pre><code class="javascript">&#123;
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;iat&quot;: 1516239022
&#125;
</code></pre>
<p>同样进行Base64编码后，字符串如下：</p>
<pre><code class="ini">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
</code></pre>
<h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>签名是对头部和载荷内容进行签名，一般情况，设置一个<code>secretKey</code>，对前两个的结果进行<code>HMACSHA25</code>算法，公式如下：</p>
<pre><code class="javascript">Signature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)
</code></pre>
<p>一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致</p>
<h4 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p><code>Token</code>的使用分成了两部分：</p>
<ul>
<li>生成token：登录成功的时候，颁发token</li>
<li>验证token：访问某些资源或者接口时，验证token</li>
</ul>
<h5 id="生成-token"><a href="#生成-token" class="headerlink" title="生成 token"></a>生成 token</h5><p>借助第三方库<code>jsonwebtoken</code>，通过<code>jsonwebtoken</code> 的 <code>sign</code> 方法生成一个 <code>token</code>：</p>
<ul>
<li>第一个参数指的是 Payload</li>
<li>第二个是秘钥，服务端特有</li>
<li>第三个参数是 option，可以定义 token 过期时间</li>
</ul>
<pre><code class="javascript">const crypto = require(&quot;crypto&quot;),
  jwt = require(&quot;jsonwebtoken&quot;);
// TODO:使用数据库
// 这里应该是用数据库存储，这里只是演示用
let userList = [];

class UserController &#123;
  // 用户登录
  static async login(ctx) &#123;
    const data = ctx.request.body;
    if (!data.name || !data.password) &#123;
      return ctx.body = &#123;
        code: &quot;000002&quot;, 
        message: &quot;参数不合法&quot;
      &#125;
    &#125;
    const result = userList.find(item =&gt; item.name === data.name &amp;&amp; item.password === crypto.createHash(&#39;md5&#39;).update(data.password).digest(&#39;hex&#39;))
    if (result) &#123;
      // 生成token
      const token = jwt.sign(  
        &#123;
          name: result.name
        &#125;,
        &quot;test_token&quot;, // secret
        &#123; expiresIn: 60 * 60 &#125; // 过期时间：60 * 60 s
      );
      return ctx.body = &#123;
        code: &quot;0&quot;,
        message: &quot;登录成功&quot;,
        data: &#123;
          token
        &#125;
      &#125;;
    &#125; else &#123;
      return ctx.body = &#123;
        code: &quot;000002&quot;,
        message: &quot;用户名或密码错误&quot;
      &#125;;
    &#125;
  &#125;
&#125;

module.exports = UserController;
</code></pre>
<p>在前端接收到<code>token</code>后，一般情况会通过<code>localStorage</code>进行缓存，然后将<code>token</code>放到<code>HTTP </code>请求头<code>Authorization</code> 中，关于<code>Authorization</code> 的设置，前面要加上 Bearer ，注意后面带有空格</p>
<pre><code class="javascript">axios.interceptors.request.use(config =&gt; &#123;
  const token = localStorage.getItem(&#39;token&#39;);
  config.headers.common[&#39;Authorization&#39;] = &#39;Bearer &#39; + token; // 留意这里的 Authorization
  return config;
&#125;)
</code></pre>
<h5 id="校验token"><a href="#校验token" class="headerlink" title="校验token"></a>校验token</h5><p>使用 <code>koa-jwt</code> 中间件进行验证，方式比较简单</p>
<pre><code class="javascript">/ 注意：放在路由前面
app.use(koajwt(&#123;
  secret: &#39;test_token&#39;
&#125;).unless(&#123; // 配置白名单
  path: [/\/api\/register/, /\/api\/login/]
&#125;))
</code></pre>
<ul>
<li>secret 必须和 sign 时候保持一致</li>
<li>可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆&#x2F;注册都可以不用校验</li>
<li>校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验</li>
</ul>
<p>获取<code>token</code>用户的信息方法如下：</p>
<pre><code class="javascript">router.get(&#39;/api/userInfo&#39;,async (ctx,next) =&gt;&#123;    const authorization =  ctx.header.authorization // 获取jwt    const token = authorization.replace(&#39;Beraer &#39;,&#39;&#39;)    const result = jwt.verify(token,&#39;test_token&#39;)    ctx.body = result
</code></pre>
<p>注意：上述的<code>HMA256</code>加密算法为单秘钥的形式，一旦泄露后果非常的危险</p>
<p>在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌</p>
<p>这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择<code>RS256</code></p>
<h4 id="三、优缺点"><a href="#三、优缺点" class="headerlink" title="三、优缺点"></a>三、优缺点</h4><p>优点：</p>
<ul>
<li>json具有通用性，所以可以跨语言</li>
<li>组成简单，字节占用小，便于传输</li>
<li>服务端无需保存会话信息，很容易进行水平扩展</li>
<li>一处生成，多处使用，可以在分布式系统中，解决单点登录问题</li>
<li>可防护CSRF攻击</li>
</ul>
<p>缺点：</p>
<ul>
<li>payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息</li>
<li>需要保护好加密密钥，一旦泄露后果不堪设想</li>
<li>为避免token被劫持，最好使用https协议</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何实现文件上传？说说你的思路"><a href="#♥︎-♥︎-♥︎-如何实现文件上传？说说你的思路" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何实现文件上传？说说你的思路"></a>♥︎ ♥︎ ♥︎ 如何实现文件上传？说说你的思路</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能</p>
<p>因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里</p>
<p>对于文件上传，我们需要设置请求头为<code>content-type:multipart/form-data</code></p>
<blockquote>
<p>multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件</p>
</blockquote>
<p>结构如下：</p>
<pre><code class="http">POST /t2/upload.do HTTP/1.1
User-Agent: SOHUWapRebot
Accept-Language: zh-cn,zh;q=0.5
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Content-Length: 60408
Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Host: w.sohu.com

--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data; name=&quot;city&quot;

Santa colo
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name=&quot;desc&quot;
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
 
...
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name=&quot;pic&quot;; filename=&quot;photo.jpg&quot;
Content-Type: application/octet-stream
Content-Transfer-Encoding: binary
 
... binary data of the jpg ...
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--
</code></pre>
<p><code>boundary</code>表示分隔符，如果要上传多个表单项，就要使用<code>boundary</code>分割，每个表单项由<code>———XXX</code>开始，以<code>———XXX</code>结尾</p>
<p>而<code>xxx</code>是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现</p>
<p>每个表单项必须包含一个 <code>Content-Disposition</code> 头，其他的头信息则为可选项， 比如 <code>Content-Type</code></p>
<p><code>Content-Disposition</code> 包含了 <code>type </code>和 一个名字为<code>name</code>的 <code>parameter</code>，<code>type</code> 是 <code>form-data</code>，<code>name </code>参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 <code>filename </code>参数，值就是文件名</p>
<pre><code class="javascript">Content-Disposition: form-data; name=&quot;user&quot;; filename=&quot;logo.png&quot;
</code></pre>
<p>至于使用<code>multipart/form-data</code>，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高</p>
<h4 id="二、如何实现-1"><a href="#二、如何实现-1" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>关于文件的上传的上传，我们可以分成两步骤：</p>
<ul>
<li>文件的上传</li>
<li>文件的解析</li>
</ul>
<h5 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h5><p>传统前端文件上传的表单结构如下：</p>
<pre><code class="html">&lt;form action=&quot;http://localhost:8080/api/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; value=&quot;&quot; multiple=&quot;multiple&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;
action` 就是我们的提交到的接口，`enctype=&quot;multipart/form-data&quot;` 就是指定上传文件格式，`input` 的 `name` 属性一定要等于`file
</code></pre>
<h5 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h5><p>在服务器中，这里采用<code>koa2</code>中间件的形式解析上传的文件数据，分别有下面两种形式：</p>
<ul>
<li>koa-body</li>
<li>koa-multer</li>
</ul>
<h5 id="koa-body"><a href="#koa-body" class="headerlink" title="koa-body"></a>koa-body</h5><p>安装依赖</p>
<pre><code class="nginx">npm install koa-body
</code></pre>
<p>引入<code>koa-body</code>中间件</p>
<pre><code class="javascript">const koaBody = require(&#39;koa-body&#39;);
app.use(koaBody(&#123;
    multipart: true,
    formidable: &#123;
        maxFileSize: 200*1024*1024    // 设置上传文件大小最大限制，默认2M
    &#125;
&#125;));
</code></pre>
<p>获取上传的文件</p>
<pre><code class="javascript">const file = ctx.request.files.file; // 获取上传文件
</code></pre>
<p>获取文件数据后，可以通过<code>fs</code>模块将文件保存到指定目录</p>
<pre><code class="javascript">router.post(&#39;/uploadfile&#39;, async (ctx, next) =&gt; &#123;
  // 上传单个文件
  const file = ctx.request.files.file; // 获取上传文件
  // 创建可读流
  const reader = fs.createReadStream(file.path);
  let filePath = path.join(__dirname, &#39;public/upload/&#39;) + `/$&#123;file.name&#125;`;
  // 创建可写流
  const upStream = fs.createWriteStream(filePath);
  // 可读流通过管道写入可写流
  reader.pipe(upStream);
  return ctx.body = &quot;上传成功！&quot;;
&#125;);
</code></pre>
<h5 id="koa-multer"><a href="#koa-multer" class="headerlink" title="koa-multer"></a>koa-multer</h5><p>安装依赖：</p>
<pre><code class="ini">npm install koa-multer
</code></pre>
<p>使用 <code>multer</code> 中间件实现文件上传</p>
<pre><code class="javascript">const storage = multer.diskStorage(&#123;  destination: (req, file, cb) =&gt; &#123;    cb(null, &quot;./upload/&quot;)  &#125;,  filename: (req, file, cb) =&gt; &#123;    cb(null, Date.now() + path.extname(file.originalname))  &#125;&#125;)
const upload = multer(&#123;  storage&#125;);
const fileRouter = new Router();
fileRouter.post(&quot;/upload&quot;, upload.single(&#39;file&#39;), (ctx, next) =&gt; &#123;  console.log(ctx.req.file); // 获取文件&#125;)app.use(fileRouter.routes());
</code></pre>
<h3 id="♥︎-♥︎-♥︎-如果让你来设计一个分页功能-你会怎么设计-前后端如何交互"><a href="#♥︎-♥︎-♥︎-如果让你来设计一个分页功能-你会怎么设计-前后端如何交互" class="headerlink" title="♥︎ ♥︎ ♥︎ 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?"></a>♥︎ ♥︎ ♥︎ 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在我们做数据查询的时候，如果数据量很大，比如几万条数据，放在一个页面显示的话显然不友好，这时候就需要采用分页显示的形式，如每次只显示10条数据</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36303730653863302d636631342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>要实现分页功能，实际上就是从结果集中显示第1<del>10条记录作为第1页,显示第11</del>20条记录作为第2页，以此类推</p>
<p>因此，分页实际上就是从结果集中截取出第M~N条记录</p>
<h4 id="二、如何实现-2"><a href="#二、如何实现-2" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>前端实现分页功能，需要后端返回必要的数据，如总的页数，总的数据量，当前页，当前的数据</p>
<pre><code class="javascript">&#123;
 &quot;totalCount&quot;: 1836,   // 总的条数
 &quot;totalPages&quot;: 92,  // 总页数
 &quot;currentPage&quot;: 1   // 当前页数
 &quot;data&quot;: [     // 当前页的数据
   &#123;
 ...
   &#125;
]
</code></pre>
<p>后端采用<code>mysql</code>作为数据的持久性存储</p>
<p>前端向后端发送目标的页码<code>page</code>以及每页显示数据的数量<code>pageSize</code>，默认情况每次取10条数据，则每一条数据的起始位置<code>start</code>为：</p>
<pre><code class="javascript">const start = (page - 1) * pageSize
</code></pre>
<p>当确定了<code>limit</code>和<code>start</code>的值后，就能够确定<code>SQL</code>语句：</p>
<pre><code class="javascript">const sql = `SELECT * FROM record limit $&#123;pageSize&#125; OFFSET $&#123;start&#125;;`
</code></pre>
<p>上诉<code>SQL</code>语句表达的意思为：截取从<code>start</code>到<code>start</code>+<code>pageSize</code>之间（左闭右开）的数据</p>
<p>关于查询数据总数的<code>SQL</code>语句为，<code>record</code>为表名：</p>
<pre><code class="javascript">SELECT COUNT(*) FROM record
</code></pre>
<p>因此后端的处理逻辑为：</p>
<ul>
<li>获取用户参数页码数page和每页显示的数目 pageSize ，其中page 是必须传递的参数，pageSize为可选参数，默认为10</li>
<li>编写 SQL 语句，利用 limit 和 OFFSET 关键字进行分页查询</li>
<li>查询数据库，返回总数据量、总页数、当前页、当前页数据给前端</li>
</ul>
<p>代码如下所示：</p>
<pre><code class="javascript">router.all(&#39;/api&#39;, function (req, res, next) &#123;
  var param = &#39;&#39;;
  // 获取参数
  if (req.method == &quot;POST&quot;) &#123;
    param = req.body;
  &#125; else &#123;
    param = req.query || req.params;
  &#125;
  if (param.page == &#39;&#39; || param.page == null || param.page == undefined) &#123;
    res.end(JSON.stringify(&#123; msg: &#39;请传入参数page&#39;, status: &#39;102&#39; &#125;));
    return;
  &#125;
  const pageSize = param.pageSize || 10;
  const start = (param.page - 1) * pageSize;
  const sql = `SELECT * FROM record limit $&#123;pageSize&#125; OFFSET $&#123;start&#125;;`
  pool.getConnection(function (err, connection) &#123;
    if (err) throw err;
    connection.query(sql, function (err, results) &#123;
      connection.release();
      if (err) &#123;
        throw err
      &#125; else &#123;
        // 计算总页数
        var allCount = results[0][0][&#39;COUNT(*)&#39;];
        var allPage = parseInt(allCount) / 20;
        var pageStr = allPage.toString();
        // 不能被整除
        if (pageStr.indexOf(&#39;.&#39;) &gt; 0) &#123;
          allPage = parseInt(pageStr.split(&#39;.&#39;)[0]) + 1;
        &#125;
        var list = results[1];
        res.end(JSON.stringify(&#123; msg: &#39;操作成功&#39;, status: &#39;200&#39;, totalPages: allPage, currentPage: param.page, totalCount: allCount, data: list &#125;));
      &#125;
    &#125;)
  &#125;)
&#125;);
</code></pre>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面的分析，可以看到分页查询的关键在于，要首先确定每页显示的数量<code>pageSize</code>，然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p>
<ul>
<li>LIMIT 总是设定为 pageSize</li>
<li>OFFSET 计算公式为 pageSize * (pageIndex - 1)</li>
</ul>
<p>确定了这两个值，就能查询出第 <code>N</code>页的数据</p>
<hr>
<h3 id="♥︎-♥︎-♥︎-♥︎-koa-中间件的实现原理"><a href="#♥︎-♥︎-♥︎-♥︎-koa-中间件的实现原理" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎  koa 中间件的实现原理"></a>♥︎ ♥︎ ♥︎ ♥︎  koa 中间件的实现原理</h3><p>每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next 函数。只要调用 next函数，就可以把执行权转交给下一个中间件。</p>
<p>如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。</p>
<p>多个中间件会形成一个栈结构，以“先进后出”的顺序执行。整个过程就像，先是入栈，然后出栈的操作。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-图片上传到服务器的过程"><a href="#♥︎-♥︎-♥︎-♥︎-图片上传到服务器的过程" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 图片上传到服务器的过程"></a>♥︎ ♥︎ ♥︎ ♥︎ 图片上传到服务器的过程</h3><h4 id="前端业务"><a href="#前端业务" class="headerlink" title="前端业务"></a>前端业务</h4><p>根据后台接口发送请求，图片作为参数，需要带上一个 name 字段</p>
<h4 id="后台业务"><a href="#后台业务" class="headerlink" title="后台业务"></a>后台业务</h4><p>后台接收图片可以使用 ndoe 的 fs、path 文件系统加上 multer 的 npm 包实现。主要思想是通过multer 创建一个临时空间用来接收并存储前端发送过来的二进制图片数据。通过 fs 模块读取临时空间的数据，并使用 pipe 方法注入到 fs 模块创建 path 模块指向的服务器文件夹下</p>
<p>后台代码试例，express 环境</p>
<pre><code class="javascript">var express = require(&#39;express&#39;)
var router = express.Router()
var fs = require(&#39;fs&#39;)
var path = require(&#39;path&#39;)
/* 用于处理非表单的文件数据流 */
var multer = require(&#39;multer&#39;)
// 配置数据流向的文件,绝对路径，相对于根目录
var upload = multer(&#123; dest: &#39;upload/&#39; &#125;)
// 创建一个接收为编码的二进制数据流的方法实例 接收 name 为 newimg 字段的上传文件，最大接收
为 1
var cpUpload = upload.fields([&#123; name: &#39;newimg&#39;, maxCount: 1 &#125;])
// 接口
router.post(&#39;/add&#39;, cpUpload, (req, res) =&gt; &#123;
 // 前端发送请求后，服务器已经接受到了前端传递过来的图片数据，保存在 files 对象下
 // 加上 cpUpload，数据就会从这个方法所设置的地址流过来，生成一个本地临时空间，类似于虚拟
DOM
 // 获取这段数据
 var img = req.files.newimg[0]
 
 // fs 模块读取临时空间的数据 
 var readStream = fs.createReadStream(img.path) 
 // 设置图片存入的路径，并给文件名前面加上一个时间轴，防止命名重复 
 var imgpath = `/cdn/$&#123;Date.now()&#125;-$&#123;img.originalname&#125;` 
 // 创建一个写入图片数据的地址 
 var writeStram = fs.createWriteStream( path.resolve(__dirname, `../public$&#123;imgpath&#125;`) )
 // 设置一个 pipe 管道，将读取的数据解析并注入到写入地址 
 readStream.pipe(writeStram) 
 // 监听注入地址的 close 事件，表示注入完毕 
 writeStram.on(&#39;close&#39;, () =&gt; &#123; 
   // 返回给前端一个图片地址 
   res.json(&#123; err: 0, msg: &#39;success&#39;, data: &#123; img: imgpath &#125; &#125;) &#125;)
   &#125;)
module.exports = router
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-koa-和-express-的区别"><a href="#♥︎-♥︎-♥︎-♥︎-koa-和-express-的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ koa 和 express 的区别"></a>♥︎ ♥︎ ♥︎ ♥︎ koa 和 express 的区别</h3><p>最大的区别在于语法，experss 的异步采用的是回调函数的形式，而 koa1 支持 generator + yeild，koa2 支持 await&#x2F;async，无疑更加优雅。</p>
<p>中间件的区别：koa 采用洋葱模型，进行顺序执行，出去反向执行，支持 context 传递数据 。express 本身无洋葱模型，需要引入插件，不支持 context express 的中间件中执行异步函数，执行顺序不会按照洋葱模型，异步的执行结果有可能被放到最后，response 之前。 这是由于，其中间件执行机制，递归回调中没有等待中间件中的异步函数执行完毕，就是没有 await 中间件异步函数</p>
<p>集成度区别：express 内置了很多中间件，集成度高，使用省心， koa 轻量简洁，容易定制</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-了解-eggjs-吗？"><a href="#♥︎-♥︎-♥︎-♥︎-了解-eggjs-吗？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 了解 eggjs 吗？"></a>♥︎ ♥︎ ♥︎ ♥︎ 了解 eggjs 吗？</h3><p>eggjs 的特性 提供基于 Egg 定制上层框架的能力 高度可扩展的插件机制 内置多进程管理 基于 Koa 开发，性能优异 框架稳定，测试覆盖率高 渐进式开发</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-说说对Nodejs中的事件循环机制理解"><a href="#♥︎-♥︎-♥︎-♥︎-说说对Nodejs中的事件循环机制理解" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说说对Nodejs中的事件循环机制理解?"></a>♥︎ ♥︎ ♥︎ ♥︎ 说说对Nodejs中的事件循环机制理解?</h3><h4 id="一、是什么-9"><a href="#一、是什么-9" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在浏览器事件循环中，我们了解到<code>javascript</code>在浏览器中的事件循环机制，其是根据<code>HTML5</code>定义的规范来实现</p>
<p>而在<code>NodeJS</code>中，事件循环是基于<code>libuv</code>实现，<code>libuv</code>是一个多平台的专注于异步IO的库，如下图最右侧所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613639306239302d633930652d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>上图<code>EVENT_QUEUE</code> 给人看起来只有一个队列，但<code>EventLoop</code>存在6个阶段，每个阶段都有对应的一个先进先出的回调队列</p>
<h4 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h4><p>上节讲到事件循环分成了六个阶段，对应如下：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326533346438302d633930652d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<ul>
<li>timers阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li>
<li>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数</li>
<li>I&#x2F;O事件回调阶段(I&#x2F;O callbacks)：执行延迟到下一个循环迭代的 I&#x2F;O 回调，即上一轮循环中未被执行的一些I&#x2F;O回调</li>
<li>闲置阶段(idle, prepare)：仅系统内部使用</li>
<li>轮询阶段(poll)：检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞</li>
<li>检查阶段(check)：setImmediate() 回调函数在这里执行</li>
<li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)</li>
</ul>
<p>每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段</p>
<p>除了上述6个阶段，还存在<code>process.nextTick</code>，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队</p>
<p>流程图如下所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66626537333164302d633930652d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在<code>Node</code>中，同样存在宏任务和微任务，与浏览器中的事件循环相似</p>
<p>微任务对应有：</p>
<ul>
<li>next tick queue：process.nextTick</li>
<li>other queue：Promise的then回调、queueMicrotask</li>
</ul>
<p>宏任务对应有：</p>
<ul>
<li>timer queue：setTimeout、setInterval</li>
<li>poll queue：IO事件</li>
<li>check queue：setImmediate</li>
<li>close queue：close事件</li>
</ul>
<p>其执行顺序为：</p>
<ul>
<li>next tick microtask queue</li>
<li>other microtask queue</li>
<li>timer queue</li>
<li>poll queue</li>
<li>check queue</li>
<li>close queue</li>
</ul>
<h4 id="三、题目"><a href="#三、题目" class="headerlink" title="三、题目"></a>三、题目</h4><p>通过上面的学习，下面开始看看题目</p>
<pre><code class="javascript">async function async1() &#123;
    console.log(&#39;async1 start&#39;)
    await async2()
    console.log(&#39;async1 end&#39;)
&#125;

async function async2() &#123;
    console.log(&#39;async2&#39;)
&#125;

console.log(&#39;script start&#39;)

setTimeout(function () &#123;
    console.log(&#39;setTimeout0&#39;)
&#125;, 0)

setTimeout(function () &#123;
    console.log(&#39;setTimeout2&#39;)
&#125;, 300)

setImmediate(() =&gt; console.log(&#39;setImmediate&#39;));

process.nextTick(() =&gt; console.log(&#39;nextTick1&#39;));

async1();

process.nextTick(() =&gt; console.log(&#39;nextTick2&#39;));

new Promise(function (resolve) &#123;
    console.log(&#39;promise1&#39;)
    resolve();
    console.log(&#39;promise2&#39;)
&#125;).then(function () &#123;
    console.log(&#39;promise3&#39;)
&#125;)

console.log(&#39;script end&#39;)
</code></pre>
<p>分析过程：</p>
<ul>
<li>先找到同步任务，输出script start</li>
<li>遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</li>
<li>遇到第二个 setTimeout，300ms后将里面的回调函数放到 timer 队列中</li>
<li>遇到第一个setImmediate，将里面的回调函数放到 check 队列中</li>
<li>遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</li>
<li>执行 async1函数，输出 async1 start</li>
<li>执行 async2 函数，输出 async2，async2 后面的输出 async1 end进入微任务，等待下一轮的事件循环</li>
<li>遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行</li>
<li>遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</li>
<li>then里面的回调函数进入微任务队列</li>
<li>遇到同步任务，输出 script end</li>
<li>执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</li>
<li>然后执行微任务队列，依次输出 async1 end、promise3</li>
<li>执行timer 队列，依次输出 setTimeout0</li>
<li>接着执行 check 队列，依次输出 setImmediate</li>
<li>300ms后，timer 队列存在任务，执行输出 setTimeout2</li>
</ul>
<p>执行结果如下：</p>
<pre><code class="javascript">script start
async1 start
async2
promise1
promise2
script end
nextTick1
nextTick2
async1 end
promise3
setTimeout0
setImmediate
setTimeout2
</code></pre>
<p>最后有一道是关于<code>setTimeout</code>与<code>setImmediate</code>的输出顺序</p>
<pre><code class="javascript">setTimeout(() =&gt; &#123;
  console.log(&quot;setTimeout&quot;);
&#125;, 0);

setImmediate(() =&gt; &#123;
  console.log(&quot;setImmediate&quot;);
&#125;);
</code></pre>
<p>输出情况如下：</p>
<pre><code class="javascript">情况一：
setTimeout
setImmediate

情况二：
setImmediate
setTimeout
</code></pre>
<p>分析下流程：</p>
<ul>
<li>外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段</li>
<li>遇到<code>setTimeout</code>，虽然设置的是0毫秒触发，但实际上会被强制改成1ms，时间到了然后塞入<code>times</code>阶段</li>
<li>遇到<code>setImmediate</code>塞入<code>check</code>阶段</li>
<li>同步代码执行完毕，进入Event Loop</li>
<li>先进入<code>times</code>阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足<code>setTimeout</code>条件，执行回调，如果没过1毫秒，跳过</li>
<li>跳过空的阶段，进入check阶段，执行<code>setImmediate</code>回调</li>
</ul>
<p>这里的关键在于这1ms，如果同步代码执行时间较长，进入<code>Event Loop</code>的时候1毫秒已经过了，<code>setTimeout</code>先执行，如果1毫秒还没到，就先执行了<code>setImmediate</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-说说对中间件概念的理解，如何封装-node-中间件？"><a href="#♥︎-♥︎-♥︎-♥︎-说说对中间件概念的理解，如何封装-node-中间件？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说说对中间件概念的理解，如何封装 node 中间件？"></a>♥︎ ♥︎ ♥︎ ♥︎ 说说对中间件概念的理解，如何封装 node 中间件？</h3><h4 id="一、是什么-10"><a href="#一、是什么-10" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的</p>
<p>在<code>NodeJS</code>中，中间件主要是指封装<code>http</code>请求细节处理的方法</p>
<p>例如在<code>express</code>、<code>koa</code>等<code>web</code>框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36613665643366302d636365342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作</p>
<h4 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h4><p><code>koa</code>是基于<code>NodeJS</code>当前比较流行的<code>web</code>框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。通过添加不同的中间件，实现不同的需求，从而构建一个 <code>Koa</code> 应用</p>
<p><code>Koa</code> 中间件采用的是洋葱圈模型，每次执行下一个中间件传入两个参数：</p>
<ul>
<li>ctx ：封装了request 和 response 的变量</li>
<li>next ：进入下一个要执行的中间件的函数</li>
</ul>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353037623032302d636365342d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>下面就针对<code>koa</code>进行中间件的封装：</p>
<p><code>Koa </code>的中间件就是函数，可以是<code> async</code> 函数，或是普通函数</p>
<pre><code class="javascript">// async 函数
app.use(async (ctx, next) =&gt; &#123;
  const start = Date.now();
  await next();
  const ms = Date.now() - start;
  console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);
&#125;);

// 普通函数
app.use((ctx, next) =&gt; &#123;
  const start = Date.now();
  return next().then(() =&gt; &#123;
    const ms = Date.now() - start;
    console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);
  &#125;);
&#125;);
</code></pre>
<p>下面则通过中间件封装<code>http</code>请求过程中几个常用的功能：</p>
<h5 id="token校验"><a href="#token校验" class="headerlink" title="token校验"></a>token校验</h5><pre><code class="javascript">module.exports = (options) =&gt; async (ctx, next) &#123;
  try &#123;
    // 获取 token
    const token = ctx.header.authorization
    if (token) &#123;
      try &#123;
          // verify 函数验证 token，并获取用户相关信息
          await verify(token)
      &#125; catch (err) &#123;
        console.log(err)
      &#125;
    &#125;
    // 进入下一个中间件
    await next()
  &#125; catch (err) &#123;
    console.log(err)
  &#125;
&#125;
</code></pre>
<h5 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h5><pre><code class="javascript">const fs = require(&#39;fs&#39;)
module.exports = (options) =&gt; async (ctx, next) =&gt; &#123;
  const startTime = Date.now()
  const requestTime = new Date()
  await next()
  const ms = Date.now() - startTime;
  let logout = `$&#123;ctx.request.ip&#125; -- $&#123;requestTime&#125; -- $&#123;ctx.method&#125; -- $&#123;ctx.url&#125; -- $&#123;ms&#125;ms`;
  // 输出日志文件
  fs.appendFileSync(&#39;./log.txt&#39;, logout + &#39;\n&#39;)
&#125;
</code></pre>
<p><code>Koa</code>存在很多第三方的中间件，如<code>koa-bodyparser</code>、<code>koa-static</code>等</p>
<p>下面再来看看它们的大体的简单实现：</p>
<h5 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h5><p><code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值</p>
<pre><code class="javascript">// 文件：my-koa-bodyparser.js
const querystring = require(&quot;querystring&quot;);

module.exports = function bodyParser() &#123;
    return async (ctx, next) =&gt; &#123;
        await new Promise((resolve, reject) =&gt; &#123;
            // 存储数据的数组
            let dataArr = [];

            // 接收数据
            ctx.req.on(&quot;data&quot;, data =&gt; dataArr.push(data));

            // 整合数据并使用 Promise 成功
            ctx.req.on(&quot;end&quot;, () =&gt; &#123;
                // 获取请求数据的类型 json 或表单
                let contentType = ctx.get(&quot;Content-Type&quot;);

                // 获取数据 Buffer 格式
                let data = Buffer.concat(dataArr).toString();

                if (contentType === &quot;application/x-www-form-urlencoded&quot;) &#123;
                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body
                    ctx.request.body = querystring.parse(data);
                &#125; else if (contentType === &quot;applaction/json&quot;) &#123;
                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body
                    ctx.request.body = JSON.parse(data);
                &#125;

                // 执行成功的回调
                resolve();
            &#125;);
        &#125;);

        // 继续向下执行
        await next();
    &#125;;
&#125;;
</code></pre>
<h5 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h5><p><code>koa-static</code> 中间件的作用是在服务器接到请求时，帮我们处理静态文件</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const mime = require(&quot;mime&quot;);
const &#123; promisify &#125; = require(&quot;util&quot;);

// 将 stat 和 access 转换成 Promise
const stat = promisify(fs.stat);
const access = promisify(fs.access)

module.exports = function (dir) &#123;
    return async (ctx, next) =&gt; &#123;
        // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /
        let realPath = path.join(dir, ctx.path);

        try &#123;
            // 获取 stat 对象
            let statObj = await stat(realPath);

            // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html
            if (statObj.isFile()) &#123;
                ctx.set(&quot;Content-Type&quot;, `$&#123;mime.getType()&#125;;charset=utf8`);
                ctx.body = fs.createReadStream(realPath);
            &#125; else &#123;
                let filename = path.join(realPath, &quot;index.html&quot;);

                // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理
                await access(filename);

                // 存在设置文件类型并响应内容
                ctx.set(&quot;Content-Type&quot;, &quot;text/html;charset=utf8&quot;);
                ctx.body = fs.createReadStream(filename);
            &#125;
        &#125; catch (e) &#123;
            await next();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据</p>
<p><code>koa</code>本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得<code>web</code>应用具备良好的可拓展性和组合性</p>
<p>通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗杂代码，过程就如装饰者模式</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-Node性能如何进行监控以及优化？"><a href="#♥︎-♥︎-♥︎-♥︎-Node性能如何进行监控以及优化？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ Node性能如何进行监控以及优化？"></a>♥︎ ♥︎ ♥︎ ♥︎ Node性能如何进行监控以及优化？</h3><h4 id="一、-是什么"><a href="#一、-是什么" class="headerlink" title="一、 是什么"></a>一、 是什么</h4><p><code>Node</code>作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下：</p>
<ul>
<li>CPU</li>
<li>内存</li>
<li>I&#x2F;O</li>
<li>网络</li>
</ul>
<h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><p>主要分成了两部分：</p>
<ul>
<li>CPU负载：在某个时间段内，占用以及等待CPU的进程总数</li>
<li>CPU使用率：CPU时间占用状况，等于 1 - 空闲CPU时间(idle time) &#x2F; CPU总时间</li>
</ul>
<p>这两个指标都是用来评估系统当前CPU的繁忙程度的量化指标</p>
<p><code>Node</code>应用一般不会消耗很多的<code>CPU</code>，如果<code>CPU</code>占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞</p>
<h5 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h5><p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标</p>
<pre><code class="javascript">// /app/lib/memory.js
const os = require(&#39;os&#39;);
// 获取当前Node内存堆栈情况
const &#123; rss, heapUsed, heapTotal &#125; = process.memoryUsage();
// 获取系统空闲内存
const sysFree = os.freemem();
// 获取系统总内存
const sysTotal = os.totalmem();

module.exports = &#123;
  memory: () =&gt; &#123;
    return &#123;
      sys: 1 - sysFree / sysTotal,  // 系统内存占用率
      heap: heapUsed / headTotal,   // Node堆内存占用率
      node: rss / sysTotal,         // Node占用系统内存的比例
    &#125;
  &#125;
&#125;
</code></pre>
<ul>
<li>rss：表示node进程占用的内存总量。</li>
<li>heapTotal：表示堆内存的总量。</li>
<li>heapUsed：实际堆内存的使用量。</li>
<li>external ：外部程序的内存使用量，包含Node核心的C++程序的内存使用量</li>
</ul>
<p>在<code>Node</code>中，一个进程的最大内存容量为1.5GB。因此我们需要减少内存泄露</p>
<h5 id="磁盘-I-x2F-O"><a href="#磁盘-I-x2F-O" class="headerlink" title="磁盘 I&#x2F;O"></a>磁盘 I&#x2F;O</h5><p>硬盘的<code> IO</code> 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍</p>
<p>内存 <code>IO </code>比磁盘<code> IO</code> 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 <code>redis</code>、<code>memcached </code>等</p>
<p>并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决</p>
<h4 id="二、如何监控"><a href="#二、如何监控" class="headerlink" title="二、如何监控"></a>二、如何监控</h4><p>关于性能方面的监控，一般情况都需要借助工具来实现</p>
<p>这里采用<code>Easy-Monitor 2.0</code>，其是轻量级的 <code>Node.js</code> 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 <code>require</code> 一次，无需改动任何业务代码即可开启内核级别的性能监控分析</p>
<p>使用方法如下：</p>
<p>在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：</p>
<pre><code class="javascript">const easyMonitor = require(&#39;easy-monitor&#39;);
easyMonitor(&#39;你的项目名称&#39;);
</code></pre>
<p>打开你的浏览器，访问 <code>http://localhost:12333</code> ，即可看到进程界面</p>
<p>关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档</p>
<h4 id="三、如何优化"><a href="#三、如何优化" class="headerlink" title="三、如何优化"></a>三、如何优化</h4><p>关于<code>Node</code>的性能优化的方式有：</p>
<ul>
<li>使用最新版本Node.js</li>
<li>正确使用流 Stream</li>
<li>代码层面优化</li>
<li>内存管理优化</li>
</ul>
<h5 id="使用最新版本Node-js"><a href="#使用最新版本Node-js" class="headerlink" title="使用最新版本Node.js"></a>使用最新版本Node.js</h5><p>每个版本的性能提升主要来自于两个方面：</p>
<ul>
<li>V8 的版本更新</li>
<li>Node.js 内部代码的更新优化</li>
</ul>
<h5 id="正确使用流-Stream"><a href="#正确使用流-Stream" class="headerlink" title="正确使用流 Stream"></a>正确使用流 Stream</h5><p>在<code>Node</code>中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存</p>
<pre><code class="javascript">const http = require(&#39;http&#39;);
const fs = require(&#39;fs&#39;);

// bad
http.createServer(function (req, res) &#123;
    fs.readFile(__dirname + &#39;/data.txt&#39;, function (err, data) &#123;
        res.end(data);
    &#125;);
&#125;);

// good
http.createServer(function (req, res) &#123;
    const stream = fs.createReadStream(__dirname + &#39;/data.txt&#39;);
    stream.pipe(res);
&#125;);
</code></pre>
<h5 id="代码层面优化"><a href="#代码层面优化" class="headerlink" title="代码层面优化"></a>代码层面优化</h5><p>合并查询，将多次查询合并一次，减少数据库的查询次数</p>
<pre><code class="javascript">// bad
for user_id in userIds 
     let account = user_account.findOne(user_id)

// good
const user_account_map = &#123;&#125;   // 注意这个对象将会消耗大量内存。
user_account.find(user_id in user_ids).forEach(account)&#123;
    user_account_map[account.user_id] =  account
&#125;
for user_id in userIds 
    var account = user_account_map[user_id]
</code></pre>
<h5 id="内存管理优化"><a href="#内存管理优化" class="headerlink" title="内存管理优化"></a>内存管理优化</h5><p>在 V8 中，主要将内存分为新生代和老生代两代：</p>
<ul>
<li>新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象</li>
<li>老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象</li>
</ul>
<p>若新生代内存空间不够，直接分配到老生代</p>
<p>通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低</p>
<p>如下面情况：</p>
<pre><code class="javascript">const buffer = fs.readFileSync(__dirname + &#39;/source/index.htm&#39;);

app.use(
    mount(&#39;/&#39;, async (ctx) =&gt; &#123;
        ctx.status = 200;
        ctx.type = &#39;html&#39;;
        ctx.body = buffer;
        leak.push(fs.readFileSync(__dirname + &#39;/source/index.htm&#39;));
    &#125;)
);

const leak = [];
</code></pre>
<p><code>leak</code>的内存非常大，造成内存泄露，应当避免这样的操作，通过减少内存使用，是提高服务性能的手段之一</p>
<p>而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作</p>
<p>例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新new这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动</p>
<p>使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中。每次用到该对象时，就取对象池空闲的对象，并对它进行初始化操作，从而提高框架的性能</p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mengfeng.github.io/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            前端面试大全网络攻防
          
        </div>
      </a>
    
    
      <a href="/2022/10/31/%E7%A7%8B%E5%A4%A9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%83%A4%E7%BA%A2%E8%96%AF/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">秋天的第一个烤红薯</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '6887374e7666a97fd4dc',
    clientSecret: '09a8e143dd4a3f5d11311e1435842321e063157d',
    repo: 'mengfeng.github.io',
    owner: 'mengfeng',
    admin: ['mengfeng'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>