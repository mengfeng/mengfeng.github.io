<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Vite-Vue3-Ts搭建私有组件库2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/21/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%932/"
    >Vite+Vue3+Ts搭建私有组件库2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/21/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%932/" class="article-date">
  <time datetime="2022-11-21T06:40:38.000Z" itemprop="datePublished">2022-11-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%932/">Vite+Vue3+Ts搭建私有组件库2</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Vite-Vue3-Ts搭建私有组件库2"><a href="#Vite-Vue3-Ts搭建私有组件库2" class="headerlink" title="Vite+Vue3+Ts搭建私有组件库2"></a>Vite+Vue3+Ts搭建私有组件库2</h1><p>本文章只供参考，具体实现可能会有出入（会尽快完善）</p>
<h3 id="一、vite打包"><a href="#一、vite打包" class="headerlink" title="一、vite打包"></a>一、vite打包</h3><p>上一篇末尾的打包还是有缺陷的，打包的组件库只能给js项目使用,在ts项目下运行会出现一些错误，而且使用的时候还会失去代码提示功能，这样的话我们就失去了用ts开发组件库的意义了。所以我们需要在打包的库里加入声明文件(.d.ts)。</p>
<p>那么如何向打包后的库里加入声明文件呢？ 其实很简单，只需要引入 vite-plugin-dts</p>
<pre><code class="css">pnpm i vite-plugin-dts -D -w
</code></pre>
<p>如果pnpm命令一直error，用其他命令下载安装也是一样的（下载到根目录）</p>
<p>然后修改一下我们的vite.config.ts引入这个插件</p>
<pre><code class="javascript">//components/vite.config.ts
import &#123; defineConfig &#125; from &quot;vite&quot;;
import vue from &quot;@vitejs/plugin-vue&quot;
import dts from &#39;vite-plugin-dts&#39;

export default defineConfig(
    &#123;
        build: &#123;...&#125;,
        plugins: [
            vue(),
            dts(&#123;
                //指定使用的tsconfig.json为我们整个项目根目录下掉,如果不配置,你也可以在components下新建tsconfig.json
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;),
            //因为这个插件默认打包到es下，我们想让lib目录下也生成声明文件需要再配置一个
            dts(&#123;
                outputDir:&#39;lib&#39;,
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;)

        ]
    &#125;
)
</code></pre>
<p>执行pnpm run build你就会发现你的es和lib下就有了声明文件</p>
<h3 id="二、组件样式"><a href="#二、组件样式" class="headerlink" title="二、组件样式"></a>二、组件样式</h3><p>首先我们需要做的是将less打包成css然后放到打包后对应的文件目录下,我们在components下新建build文件夹来存放我们的一些打包工具,然后新建buildLess.ts,首先我们需要先安装一些工具cpy和fast-glob</p>
<pre><code class="css">pnpm i cpy fast-glob -D -w
</code></pre>
<p>它可以直接复制我们规定的文件并将我们的文件copy到指定目录,比如buildLess.ts:</p>
<pre><code class="javascript">//build/buildLess.ts
import cpy from &#39;cpy&#39;
import &#123; resolve &#125; from &#39;path&#39;

const sourceDir = resolve(__dirname, &#39;../src&#39;)
//lib文件
const targetLib = resolve(__dirname, &#39;../lib&#39;)
//es文件
const targetEs = resolve(__dirname, &#39;../es&#39;)
console.log(sourceDir);
const buildLess = async () =&gt; &#123;
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetLib)
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetEs)
&#125;
buildLess()
</code></pre>
<p>然后在package.json中新增命令</p>
<pre><code class="erlang">...
&quot;scripts&quot;: &#123;
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;build:less&quot;: &quot;esno build/buildLess&quot;
  &#125;,
...
</code></pre>
<p>终端执行 pnpm run build:less 你就会发现lib和es文件对应目录下就出现了less文件.(如果error，切换node版本)</p>
<p>但是我们最终要的并不是less文件而是css文件,所以我们要将less打包成css,所以我们需要用的less模块.在ts中引入less因为它本身没有声明文件所以会出现类型错误,所以我们要先安装它的 @types&#x2F;less</p>
<pre><code class="css">pnpm i --save-dev @types/less -D -w
</code></pre>
<p>buildLess.ts如下(详细注释都在代码中)</p>
<pre><code class="javascript">import cpy from &#39;cpy&#39;
import &#123; resolve &#125; from &#39;path&#39;
import &#123; promises as fs &#125; from &quot;fs&quot;
import less from &quot;less&quot;
import glob from &quot;fast-glob&quot;
const sourceDir = resolve(__dirname, &#39;../src&#39;)
//lib文件目录
const targetLib = resolve(__dirname, &#39;../lib&#39;)
//es文件目录
const targetEs = resolve(__dirname, &#39;../es&#39;)



const buildLess = async () =&gt; &#123;
    //直接将less文件复制到打包后目录
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetLib)
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetEs)

    //获取打包后.less文件目录(lib和es一样)
    const lessFils = await glob(&quot;**/*.less&quot;, &#123; cwd: targetLib, onlyFiles: true &#125;)

    //遍历含有less的目录
    for (let path in lessFils) &#123;
        const lessPathLib = `$&#123;targetLib&#125;/$&#123;lessFils[path]&#125;`
        const lessPathEs = `$&#123;targetEs&#125;/$&#123;lessFils[path]&#125;`

        //获取less文件字符串
        const lessCode = await fs.readFile(lessPathLib, &#39;utf-8&#39;)
        //将less解析成css
        const code = await less.render(lessCode)

        //拿到.css后缀path
        const cssPathLib = lessPathLib.replace(&#39;.less&#39;, &#39;.css&#39;)
        const cssPathEs = lessPathEs.replace(&#39;.less&#39;, &#39;.css&#39;)

        //将css写入对应目录
        await fs.writeFile(cssPathLib, code.css)
        await fs.writeFile(cssPathEs, code.css)
    &#125;



&#125;
buildLess()
</code></pre>
<p>执行打包命令之后你会发现对应文件夹下多了.css文件</p>
<p><img src="/2022/11/21/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%932/image-20221121092003205.png"></p>
<p>现在我已经将css文件放入对应的目录下了,但是我们的相关组件并没有引入这个css文件;所以我们需要的是每个打包后组件的index.js中出现如:</p>
<pre><code class="cpp">import &quot;xxx/xxx.css&quot;
</code></pre>
<p>之类的代码我们的css才会生效;所以我们需要对vite.config.ts进行相关配置</p>
<p>首先我们先将.less文件忽略external: [‘vue’, &#x2F;.less&#x2F;],这时候打包后的文件中如button&#x2F;index.js就会出现</p>
<pre><code class="cpp">import &quot;./style/index.less&quot;;
</code></pre>
<p>然后我们再将打包后代码的.less换成.css就大功告成了</p>
<pre><code class="typescript">...
plugins: [
            ...

            &#123;
                name: &#39;style&#39;,
                generateBundle(config, bundle) &#123;
                    //这里可以获取打包后的文件目录以及代码code
                    const keys = Object.keys(bundle)

                    for (const key of keys) &#123;
                        const bundler: any = bundle[key as any]
                        //rollup内置方法,将所有输出文件code中的.less换成.css,因为我们当时没有打包less文件

                        this.emitFile(&#123;
                            type: &#39;asset&#39;,
                            fileName: key,//文件名名不变
                            source: bundler.code.replace(/\.less/g, &#39;.css&#39;)
                        &#125;)
                    &#125;
                &#125;
            &#125;
        ...
        ]
...
</code></pre>
<p>我们最终的vite.config.ts如下</p>
<pre><code class="typescript">import &#123; defineConfig &#125; from &quot;vite&quot;;
import vue from &quot;@vitejs/plugin-vue&quot;
import dts from &#39;vite-plugin-dts&#39;

export default defineConfig(
    &#123;
        build: &#123;
            target: &#39;modules&#39;,
            //打包文件目录
            outDir: &quot;es&quot;,
            //压缩
            minify: false,
            //css分离
            //cssCodeSplit: true,
            rollupOptions: &#123;
                //忽略打包vue和.less文件
                external: [&#39;vue&#39;, /\.less/],
                input: [&#39;src/index.ts&#39;],
                output: [
                    &#123;
                        format: &#39;es&#39;,
                        //不用打包成.es.js,这里我们想把它打包成.js
                        entryFileNames: &#39;[name].js&#39;,
                        //让打包目录和我们目录对应
                        preserveModules: true,
                        //配置打包根目录
                        dir: &#39;es&#39;,
                        preserveModulesRoot: &#39;src&#39;
                    &#125;,
                    &#123;
                        format: &#39;cjs&#39;,
                        //不用打包成.mjs
                        entryFileNames: &#39;[name].js&#39;,
                        //让打包目录和我们目录对应
                        preserveModules: true,
                        //配置打包根目录
                        dir: &#39;lib&#39;,
                        preserveModulesRoot: &#39;src&#39;
                    &#125;
                ]
            &#125;,
            lib: &#123;
                entry: &#39;./index.ts&#39;,
                formats: [&#39;es&#39;, &#39;cjs&#39;]
            &#125;
        &#125;,




        plugins: [
            vue(),
            dts(&#123;
                //指定使用的tsconfig.json为我们整个项目根目录下掉,如果不配置,你也可以在components下新建tsconfig.json
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;),
            //因为这个插件默认打包到es下，我们想让lib目录下也生成声明文件需要再配置一个
            dts(&#123;
                outputDir: &#39;lib&#39;,
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;),

            &#123;
                name: &#39;style&#39;,
                generateBundle(config, bundle) &#123;
                    //这里可以获取打包后的文件目录以及代码code
                    const keys = Object.keys(bundle)

                    for (const key of keys) &#123;
                        const bundler: any = bundle[key as any]
                        //rollup内置方法,将所有输出文件code中的.less换成.css,因为我们当时没有打包less文件

                        this.emitFile(&#123;
                            type: &#39;asset&#39;,
                            fileName: key,//文件名名不变
                            source: bundler.code.replace(/\.less/g, &#39;.css&#39;)
                        &#125;)
                    &#125;
                &#125;
            &#125;

        ]
    &#125;
)
</code></pre>
<p>最后我们将打包less与打包组件合成一个命令(package.json):</p>
<pre><code class="erlang">...
&quot;scripts&quot;: &#123;
     &quot;build&quot;:&quot;vite build&quot;,
    &quot;build:less&quot;: &quot;esno build/buildLess&quot;
  &#125;,
...
</code></pre>
<p>后续直接执行pnpm run build 即可完成所有打包啦</p>
<h3 id="三、引用ui包"><a href="#三、引用ui包" class="headerlink" title="三、引用ui包"></a>三、引用ui包</h3><p>做了那么多终于到发布的阶段了；其实npm发包是很容易的，就拿我们的组件alanmf举例吧</p>
<p>发布之前记得到<a target="_blank" rel="noopener" href="https://www.npmjs.com/">npm</a>官网注册个账户,如果你要发布@xx&#x2F;xx这种包的话需要在npm新建个组织组织组织名就是@后面的，比如我建的组织就是kitty-ui,注册完之后你就可以发布了</p>
<p>首先要将我们代码提交到git仓库，不然pnpm发布无法通过，后面每次发版记得在对应包下执行 <strong>pnpm version patch</strong>你就会发现这个包的版本号patch(版本号第三个数) +1 了</p>
<p>如果你发布的是公共包的话，在对应包下执行</p>
<pre><code class="cpp">pnpm publish --access public
</code></pre>
<p>输入你的账户和密码（记得输入密码的时候是不显示的，不要以为卡了）正常情况下应该是发布成功了</p>
<p><strong>注意</strong></p>
<p>发布的时候要将npm的源切换到npm的官方地址(<a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>); 如果你使用了其它镜像源的话</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/" rel="tag">私有组件库</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vite-Vue3-Ts搭建私有组件库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/"
    >Vite+Vue3+Ts搭建私有组件库</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/" class="article-date">
  <time datetime="2022-11-20T09:04:55.000Z" itemprop="datePublished">2022-11-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/">Vite+Vue3+Ts搭建私有组件库</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Vite-Vue3-Ts搭建私有组件库"><a href="#Vite-Vue3-Ts搭建私有组件库" class="headerlink" title="Vite+Vue3+Ts搭建私有组件库"></a>Vite+Vue3+Ts搭建私有组件库</h1><p>目前前端技术的持续发展，社区生态出现了一批比较适用的组件库，例如：ElementUI,Vant，AntDesign等，但这些组件库的组件不一定能满足我们一些项目的特定业务需求，那么我们的团队就应该建立起我们自己的组件库，方便于我们自己的业务开发，那么我们这篇文章就来了解一下我们开发组件库的大体技术架构体系。</p>
<p>搭建组件库的技术要点：</p>
<ul>
<li>如何使用pnpm搭建出一个menorepo环境</li>
<li>如何使用vite搭建一个基本的Vue3脚手架项目</li>
<li>如何开发调试一个自己的UI组件库</li>
<li>如何使用vite打包并发布自己的UI组件库</li>
</ul>
<h3 id="一、menorepo环境的搭建"><a href="#一、menorepo环境的搭建" class="headerlink" title="一、menorepo环境的搭建"></a>一、menorepo环境的搭建</h3><p>首先我们要了解什么是menorepo及它是如何搭建 (单仓库 多项目)</p>
<p>就是指在一个大的项目仓库中，管理多个模块&#x2F;包（package），这种类型的项目大都在项目根目录下有一个packages文件夹，分多个项目管理。大概结构如下：</p>
<pre><code class="ini">-- packages
  -- pkg1
    --package.json
  -- pkg2
    --package.json
--package.json
</code></pre>
<p>目前很多我们熟知的项目都是采用这种模式，如Vant，ElementUI，Vue3等。打造一个menorepo环境的工具有很多，如：lerna、pnpm、yarn等，这里我们将使用pnpm来开发我们的UI组件库</p>
<h4 id="1-使用pnpm"><a href="#1-使用pnpm" class="headerlink" title="1.使用pnpm"></a>1.使用pnpm</h4><pre><code class="ini">npm install pnpm -g //安装pnpm
pnpm init //初始化package.json
</code></pre>
<p>新建配置文件 .npmrc</p>
<pre><code class="ini">shamefully-hoist = true
</code></pre>
<p>这里简单说下为什么要配置shamefully-hoist。</p>
<p>如果某些工具仅在根目录的node_modules时才有效，可以将其设置为true来提升那些不在根目录的node_modules，就是将你安装的依赖包的依赖包的依赖包的…都放到同一级别（扁平化）。说白了就是不设置为true有些包就有可能会出问题。</p>
<p>安装对应依赖</p>
<pre><code class="ini">pnpm i vue@next typescript less -D -w //开发环境中的依赖一般全部安装在整个项目根目录下，方便下面我们每个包都可以引用,所以在安装的时候需要加个 -w
</code></pre>
<p>如果我们是在根目录下运行命令，那么就不用加 -w 了，要不然会提示</p>
<pre><code class="error">--workspace-root may only be used inside a workspace
</code></pre>
<p>配置tsconfit.json</p>
<pre><code class="ini">npx tsc --init //初始化
</code></pre>
<pre><code class="javascript">//tsconfit.json配置
&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;jsx&quot;: &quot;preserve&quot;,
    &quot;strict&quot;: true,
    &quot;target&quot;: &quot;ES2015&quot;,
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,
    &quot;esModuleInterop&quot;: true,
    &quot;moduleResolution&quot;: &quot;Node&quot;,
    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;]
  &#125;
&#125;
</code></pre>
<h4 id="2-monorepo的实现"><a href="#2-monorepo的实现" class="headerlink" title="2.monorepo的实现"></a>2.monorepo的实现</h4><p>各个项目之间能够互相引用我们要新建一个pnpm-workspace.yaml文件将我们的包关联起来</p>
<pre><code class="ini">packages:
    - &#39;packages/**&#39;
    - &#39;examples&#39;
</code></pre>
<p>这样就能将我们项目下的packages目录和examples目录关联起来了，当然如果你想关联更多目录你只需要往里面添加即可。根据上面的目录结构很显然你在根目录下新建packages和examples文件夹，packages文件夹存放我们开发的包，examples用来调试我们的组件。</p>
<p>examples文件夹就是接下来我们要使用vite搭建一个基本的Vue3脚手架项目的地方。</p>
<h4 id="3-手动搭建一个基于vite的vue3项目"><a href="#3-手动搭建一个基于vite的vue3项目" class="headerlink" title="3.手动搭建一个基于vite的vue3项目"></a>3.手动搭建一个基于vite的vue3项目</h4><p>进入examples文件夹，执行</p>
<pre><code class="ini">pnpm init //初始化仓库
pnpm install vite @vitejs/plugin-vue -D -w //安装vite和@vitejs/plugin-vue
</code></pre>
<p>配置vite.config.ts</p>
<p>新建vite.config.ts文件</p>
<pre><code class="ini">import &#123; defineConfig &#125; from &#39;vite&#39;
import vue from &#39;@vitejs/plugin-vue&#39;

export default defineConfig(&#123;
    plugins:[vue()]
&#125;)
</code></pre>
<p>新建html文件</p>
<p>@vitejs&#x2F;plugin-vue 会默认加载examples下的index.html</p>
<p>新建index.html</p>
<pre><code class="xml">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;main.ts&quot; type=&quot;module&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意：<br>vite 是基于esmodule的 所以type&#x3D;”module”</p>
<p>新建app.vue模板</p>
<pre><code class="xml">&lt;template&gt;
    &lt;div&gt;
        启动测试
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>新建main.ts</p>
<pre><code class="javascript">import &#123;createApp&#125; from &#39;vue&#39;
import App from &#39;./app.vue&#39;

const app = createApp(App)

app.mount(&#39;#app&#39;)
</code></pre>
<p>此时会发现编译器会提示个错误：找不到模块“.&#x2F;app.vue”或其相应的类型声明</p>
<p>因为直接引入.vue文件 TS会找不到对应的类型声明；所以需要新建typings（命名没有明确规定，TS会自动寻找.d.ts文件）文件夹来专门放这些声明文件。</p>
<p>typings&#x2F;vue-shim.d.ts</p>
<p>TypeScriptTS默认只认ES 模块。如果你要导入.vue文件就要declare module把他们声明出来。</p>
<pre><code class="typescript">declare module &#39;*.vue&#39; &#123;
    import type &#123; DefineComponent &#125; from &quot;vue&quot;;
    const component:DefineComponent&lt;&#123;&#125;,&#123;&#125;,any&gt;
&#125;
</code></pre>
<p>配置脚本启动项目</p>
<p>最后在package.json文件中配置scripts脚本</p>
<pre><code class="erlang">...
&quot;scripts&quot;: &#123;
    &quot;dev&quot;: &quot;vite&quot;
  &#125;,
...
</code></pre>
<p>然后终端输入我们熟悉的命令：pnpm run dev</p>
<p><img src="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/image-20221120114028908.png"></p>
<p>如果出现了cannot find module ‘node:path’这样的错误提示，那可能是node版本不兼容，升级一下node版本就可以了</p>
<p>我的node 版本是 v14.17.0 的版本，出现了不兼容的问题，于是升级到了稳定版 v16.16.0 。</p>
<p>再运行vite就没问题了</p>
<p><img src="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/image-20221120114403681.png"></p>
<h3 id="二、本地调试"><a href="#二、本地调试" class="headerlink" title="二、本地调试"></a>二、本地调试</h3><h4 id="1-新建包文件"><a href="#1-新建包文件" class="headerlink" title="1.新建包文件"></a>1.新建包文件</h4><p>往packages文件夹冲填充内容</p>
<p>一般packages要有utils包来存放我们公共方法，工具函数等</p>
<p>既然它是一个包，所以我们新建utils目录后就需要初始化它，让它变成一个包；终端进入utils文件夹执行：pnpm init 然后会生成一个package.json文件；这里需要改一下包名，我这里将name改成@alanmf&#x2F;utils表示这个utils包是属于alanmf这个组织下的。所以记住发布之前要登录npm新建一个组织；例如alanmf</p>
<p><img src="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/image-20221120152720676.png"></p>
<p>因为我们使用ts写的，所以需要将入口文件index.js改为index.ts，并新建index.ts文件:(先导出一个简单的加法函数)</p>
<p>components是我们用来存放各种UI组件的包</p>
<p>新建components文件夹并执行 pnpm init 生成package.json</p>
<ul>
<li>组件库包 这里命名为alanmf</li>
</ul>
<pre><code class="ini">&#123;
  &quot;name&quot;: &quot;@alanmf/utils&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.ts&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<p>新建index.ts入口文件并引入utils包</p>
<pre><code class="tsx">//@kitty-ui/utils
import &#123;testfun&#125; from &#39;@alanmf/utils&#39;

const result = testfun (1,1)

console.log(result)
</code></pre>
<p>由于组件库是基于ts的，所以需要安装esno来执行ts文件便于测试组件之间的引入情况</p>
<p>控制台输入esno xxx.ts即可执行ts文件</p>
<pre><code class="ini">npm i esno -g //安装esno
eson index.ts //执行index.ts文件
</code></pre>
<p><img src="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/image-20221120151321307.png"></p>
<h4 id="2-包之间本地调试"><a href="#2-包之间本地调试" class="headerlink" title="2.包之间本地调试"></a>2.包之间本地调试</h4><p>进入components文件夹执行</p>
<pre><code class="bash">pnpm install @alanmf/utils
</code></pre>
<p>你会发现pnpm会自动创建个软链接直接指向我们的utils包；此时components下的packages：</p>
<pre><code class="swift">&#123;
  &quot;name&quot;: &quot;alanmf&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.ts&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: &#123;
    &quot;@alanmf/utils&quot;: &quot;workspace:^1.0.0&quot;
  &#125;
&#125;
</code></pre>
<p>你会发现它的依赖@alanmf&#x2F;utils对应的版本为：workspace:^1.0.0；因为pnpm是由workspace管理的，所以有一个前缀workspace可以指向utils下的工作空间从而方便本地调试各个包直接的关联引用。</p>
<p>到这里基本开发方法我们已经知道啦；接下来就要进入正题了，开发一个button组件</p>
<h3 id="三、开发一个button组件"><a href="#三、开发一个button组件" class="headerlink" title="三、开发一个button组件"></a>三、开发一个button组件</h3><h4 id="1-创建一个测试组件"><a href="#1-创建一个测试组件" class="headerlink" title="1.创建一个测试组件"></a>1.创建一个测试组件</h4><p>在components文件夹下新建src,同时在src下新建button组件目录和icon组件目录(新建icon为了便于调试);此时components文件目录如下</p>
<pre><code class="lua">-- components
  -- src
    -- button
    -- icon
    -- index.ts
-- package.json
</code></pre>
<p>让我们先测试一下我们的button组件能否在我们搭建的examples下的vue3项目本引用~</p>
<p>首先在button下新建一个简单的button.vue</p>
<pre><code class="xml">&lt;template&gt;
    &lt;button&gt;测试按钮&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>然后在button&#x2F;index.ts将其导出</p>
<pre><code class="javascript">import Button from &#39;./button.vue&#39;

export default Button
</code></pre>
<p>因为我们开发组件库的时候不可能只有button，所以我们需要一个components&#x2F;index.ts将我们开发的组件一个个的集中导出</p>
<pre><code class="javascript">import Button from &#39;./button&#39;

export &#123;
    Button
&#125;
</code></pre>
<p>好了，一个组件的大体目录差不多就是这样了，接下来请进入我们的examples来看看能否引入我们的button组件</p>
<h4 id="2-测试项目引入"><a href="#2-测试项目引入" class="headerlink" title="2.测试项目引入"></a>2.测试项目引入</h4><p>上面已经说过执行在workspace执行 pnpm i xxx的时候pnpm会自动创建个软链接直接指向我们的xxx包。</p>
<p>所以这里我们直接在examples执行：pnpm i alanmf</p>
<p>此时你就会发现packages.json的依赖多了个</p>
<pre><code class="json">&quot;alanmf&quot;: &quot;workspace:^1.0.0&quot;
</code></pre>
<p>这时候我们就能直接在我们的测试项目下引入我们本地的components组件库了，启动我们的测试项目，来到我们的 examples&#x2F;app.vue 直接引入Button</p>
<pre><code class="xml">&lt;template&gt;
    &lt;div&gt;
        &lt;Button /&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script lang=&quot;ts&quot; setup&gt;
import &#123; Button &#125; from &#39;alanmf/src&#39;
&lt;/script&gt;
</code></pre>
<p>不出意外的话你的页面就会展示我们刚刚写的button组件了</p>
<p>接下来的工作就是专注于组件的开发了；让我们回到我们的button组件目录下（测试页面不用关，此时我们已经可以边开发边调试边看效果了）</p>
<h4 id="3-types-ts文件规范组件属性"><a href="#3-types-ts文件规范组件属性" class="headerlink" title="3.types.ts文件规范组件属性"></a>3.types.ts文件规范组件属性</h4><p>我们的button组件是需要接收很多属性的，如type、size等等，所以我们要新建个types.ts文件来规范这些属性</p>
<p>在button目录下新建types.ts</p>
<pre><code class="tsx">
import &#123; ExtractPropTypes &#125; from &#39;vue&#39;


export const ButtonType = [&#39;default&#39;, &#39;primary&#39;, &#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;]

export const ButtonSize = [&#39;large&#39;, &#39;normal&#39;, &#39;small&#39;, &#39;mini&#39;];


export const buttonProps = &#123;
  type: &#123;
    type: String,
    values: ButtonType
  &#125;,
  size: &#123;
    type: String,
    values: ButtonSize
  &#125;
&#125;

export type ButtonProps = ExtractPropTypes&lt;typeof buttonProps&gt;
</code></pre>
<p>import type 表示只导入类型；ExtractPropTypes是vue3中内置的类型声明,它的作用是接收一个类型，然后把对应的vue3所接收的props类型提供出来，后面有需要可以直接使用</p>
<p>很多时候我们在vue中使用一个组件会用的app.use 将组件挂载到全局。要使用app.use函数的话我们需要让我们的每个组件都提供一个install方法，app.use()的时候就会调用这个方法;</p>
<p>我们将button&#x2F;index.ts调整为</p>
<pre><code class="typescript">import button from &#39;./button.vue&#39;
import type &#123;App,Plugin&#125; from &quot;vue&quot;
type SFCWithInstall&lt;T&gt; = T&amp;Plugin
const withInstall = &lt;T&gt;(comp:T) =&gt; &#123;
    (comp as SFCWithInstall&lt;T&gt;).install = (app:App)=&gt;&#123;
        //注册组件
        app.component((comp as any).name,comp)
    &#125;
    return comp as SFCWithInstall&lt;T&gt;
&#125;
const Button = withInstall(button)
export default Button
</code></pre>
<p>此时我们就可以使用app.use来挂载我们的组件啦</p>
<p>其实withInstall方法可以做个公共方法放到工具库里，因为后续每个组件都会用到，这里等后面开发组件的时候再调整</p>
<p>到这里组件开发的基本配置已经完成，最后我们对我们的组件库以及工具库进行打包，打包之前如果要发公共包的话记得将我们的各个包的协议改为MIT开源协议</p>
<pre><code class="python-repl">...
&quot;license&quot;: &quot;MIT&quot;,
...
</code></pre>
<h3 id="四、vite打包"><a href="#四、vite打包" class="headerlink" title="四、vite打包"></a>四、vite打包</h3><h4 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h4><p>打包们这里选择vite，它有一个库模式专门为我们来打包这种库组件的。</p>
<p>前面已经安装过vite了，所以这里直接在components下直接新建vite.config.ts(配置参数文件中已经注释):</p>
<pre><code class="json">import &#123; defineConfig &#125; from &quot;vite&quot;;
import vue from &quot;@vitejs/plugin-vue&quot;
export default defineConfig(
    &#123;
        build: &#123;
            target: &#39;modules&#39;,
            //打包文件目录
            outDir: &quot;es&quot;,
            //压缩
            minify: false,
            //css分离
            //cssCodeSplit: true,
            rollupOptions: &#123;
                //忽略打包vue文件
                external: [&#39;vue&#39;],
                input: [&#39;src/index.ts&#39;],
                output: [
                    &#123;
                        format: &#39;es&#39;,
                        //不用打包成.es.js,这里我们想把它打包成.js
                        entryFileNames: &#39;[name].js&#39;,
                        //让打包目录和我们目录对应
                        preserveModules: true,
                        //配置打包根目录
                        dir: &#39;es&#39;,
                        preserveModulesRoot: &#39;src&#39;
                    &#125;,
                    &#123;
                        format: &#39;cjs&#39;,
                        entryFileNames: &#39;[name].js&#39;,
                        //让打包目录和我们目录对应
                        preserveModules: true,
                        //配置打包根目录
                        dir: &#39;lib&#39;,
                        preserveModulesRoot: &#39;src&#39;
                    &#125;
                ]
            &#125;,
            lib: &#123;
                entry: &#39;./index.ts&#39;,
                formats: [&#39;es&#39;, &#39;cjs&#39;]
            &#125;
        &#125;,
        plugins: [
            vue()
        ]
    &#125;
)
</code></pre>
<p>这里我们选择打包cjs(CommonJS)和esm(ESModule)两种形式,cjs模式主要用于服务端引用(ssr),而esm就是我们现在经常使用的方式，它本身自带treeShaking而不需要额外配置按需引入(前提是你将模块分别导出)</p>
<h4 id="2-vite打包"><a href="#2-vite打包" class="headerlink" title="2.vite打包"></a>2.vite打包</h4><p>到这里就已经可以直接打包了；components下执行： pnpm run build你就会发现打包了es和lib两个目录</p>
<p><img src="/2022/11/20/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/image-20221120165853742.png"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[私有仓库搭建源码]: 	“<a target="_blank" rel="noopener" href="https://github.com/mengfeng/alanmf_ui.git">https://github.com/mengfeng/alanmf_ui.git</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/" rel="tag">组件库</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vue3-Ts-Vite-Pinia组合的高效开发套件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/"
    >Vue3+Ts+Vite+Pinia组合的高效开发套件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/" class="article-date">
  <time datetime="2022-11-19T07:34:30.000Z" itemprop="datePublished">2022-11-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/">Vue3+Ts+Vite+Pinia组合的高效开发套件</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Vue3-Ts-Vite-Pinia组合的高效开发套件"><a href="#Vue3-Ts-Vite-Pinia组合的高效开发套件" class="headerlink" title="Vue3+Ts+Vite+Pinia组合的高效开发套件"></a>Vue3+Ts+Vite+Pinia组合的高效开发套件</h1><p>2022年最受欢迎的组合</p>
<h3 id="一、Vite和Webpack区别"><a href="#一、Vite和Webpack区别" class="headerlink" title="一、Vite和Webpack区别"></a>一、Vite和Webpack区别</h3><ul>
<li>webpack是一个JavaScript应用程序的静态模块打包工具，它会对整个应用程序进行依赖关系图构建。</li>
<li>vite是构建工具的高阶封装，使用简单，快（开发的时候感觉没有编译过程），便于扩展。而他集成的esbuild(Go 编写) 预构建依赖，比node快 10-100 倍。</li>
</ul>
<p>区别：</p>
<h4 id="1-关注层级不同"><a href="#1-关注层级不同" class="headerlink" title="1.关注层级不同"></a>1.关注层级不同</h4><p>vite关注的层级更高：vite是 high level api，关注的是如何快速方便的搭建项目，相比webpack，减少了很多配置量。</p>
<p>webpack关注的层级更低：webpack是low level api，因为webpack更关注的是各种功能的实现，重点放在构建上。</p>
<h4 id="2-vite自己不包含编译能力。"><a href="#2-vite自己不包含编译能力。" class="headerlink" title="2.vite自己不包含编译能力。"></a>2.vite自己不包含编译能力。</h4><p>它本身并不参与编译，它的编译能力只是集成了rollup和ESbuild的功能.</p>
<h4 id="3-启动项目vite更快，可以说是超级快。"><a href="#3-启动项目vite更快，可以说是超级快。" class="headerlink" title="3.启动项目vite更快，可以说是超级快。"></a>3.启动项目vite更快，可以说是超级快。</h4><p>对比webpack在dev-serve的时候，会提交所有编译的文件，而vite在dev-serve的时候利用了浏览器的native ES module功能，在浏览器请求对应的url时才提供文件，实现了根据路由的懒加载，所以启动的时候是超快的。</p>
<h4 id="4-vite的热更新更快。"><a href="#4-vite的热更新更快。" class="headerlink" title="4.vite的热更新更快。"></a>4.vite的热更新更快。</h4><p>对比webpack的热更新，热更新时，把改动过模块的相关依赖模块全部编译一次。而vite热更新时，仅让浏览器重新请求改动过的模块。</p>
<p>现在公司项目从webpack过渡到vite,还在不断摸索爬坑中，虽然目前vite的生态不如webpack丰富，且实用的开发者也不及webpack。<br>但是不可否认的是，相比于webpack, vite非常适合项目的开发，webpack适合工具的开发。</p>
<ul>
<li><p>vite为构建项目而生</p>
</li>
<li><p>webpack为构建工具而生</p>
</li>
</ul>
<h3 id="二、Pinia和Vuex"><a href="#二、Pinia和Vuex" class="headerlink" title="二、Pinia和Vuex"></a>二、Pinia和Vuex</h3><p>Pinia是Vue生态里Vuex的代替者，一个全新Vue的状态管理库。在Vue3成为正式版以后，尤雨溪强势推荐的项目就是Pinia。</p>
<p>Pinia 是 Vue.js 的轻量级状态管理库，它使用 Vue 3 中的新反应系统来构建一个直观且完全类型化的状态管理库。<br>Vuex也是为Vue框架建立的一个流行的状态管理库，它也是Vue核心团队推荐的状态管理库。 Vuex高度关注应用程序的可扩展性、开发人员的工效和信心。它基于与redux相同的流量架构。Pinia 完整的符合了当时 Vuex5 提案所提到的功能点。</p>
<h4 id="Pinia-和-Vuex"><a href="#Pinia-和-Vuex" class="headerlink" title="Pinia 和 Vuex"></a>Pinia 和 Vuex</h4><p>Vuex： <code>State</code>、<code>Gettes</code>、<code>Mutations</code>(同步)、<code>Actions</code>(异步)</p>
<p>Pinia： <code>State</code>、<code>Gettes</code>、<code>Actions</code>(同步异步都支持)</p>
<h4 id="Pinia-核心特性"><a href="#Pinia-核心特性" class="headerlink" title="Pinia 核心特性"></a>Pinia 核心特性</h4><ul>
<li><p>Pinia 没有 <code>Mutations</code></p>
</li>
<li><p><code>Actions</code> 支持同步和异步</p>
</li>
<li><p>没有模块的嵌套结构</p>
</li>
<li><ul>
<li>Pinia 通过设计提供扁平结构，就是说每个 store 都是互相独立的，谁也不属于谁，也就是扁平化了，更好的代码分割且没有命名空间。当然你也可以通过在一个模块中导入另一个模块来隐式嵌套 store，甚至可以拥有 store 的循环依赖关系</li>
</ul>
</li>
<li><p>更好的 <code>TypeScript</code> 支持 </p>
</li>
<li><ul>
<li>不需要再创建自定义的复杂包装器来支持 TypeScript 所有内容都类型化，并且 API 的设计方式也尽可能的使用 TS 类型推断</li>
</ul>
</li>
<li><p>不需要注入、导入函数、调用它们，享受自动补全，让我们开发更加方便</p>
</li>
<li><p>无需手动添加 store，它的模块默认情况下创建就自动注册的</p>
</li>
<li><p>Vue2 和 Vue3 都支持 </p>
</li>
<li><ul>
<li>除了初始化安装和SSR配置之外，两者使用上的API都是相同的</li>
</ul>
</li>
<li><p>支持 <code>Vue DevTools</code></p>
</li>
<li><ul>
<li>跟踪 actions, mutations 的时间线</li>
<li>在使用了模块的组件中就可以观察到模块本身</li>
<li>支持 time-travel 更容易调试</li>
<li>在 Vue2 中 Pinia 会使用 Vuex 的所有接口，所以它俩不能一起使用</li>
<li>但是针对 Vue3 的调试工具支持还不够完美，比如还没有 time-travel 功能</li>
</ul>
</li>
<li><p>模块热更新 </p>
</li>
<li><ul>
<li>无需重新加载页面就可以修改模块</li>
<li>热更新的时候会保持任何现有状态</li>
</ul>
</li>
<li><p>支持使用插件扩展 Pinia 功能</p>
</li>
<li><p>支持服务端渲染</p>
</li>
</ul>
<h3 id="三、Vite生成Vue3脚手架"><a href="#三、Vite生成Vue3脚手架" class="headerlink" title="三、Vite生成Vue3脚手架"></a>三、Vite生成Vue3脚手架</h3><pre><code class="ini">npm create vite@latest //构建vite+vue
npm i //下载依赖
npm run dev //启动项目
</code></pre>
<p><img src="/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/image-20221119091852577.png"></p>
<p><img src="/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/image-20221119101610847.png"></p>
<h3 id="四、集成pinia"><a href="#四、集成pinia" class="headerlink" title="四、集成pinia"></a>四、集成pinia</h3><pre><code class="ini">npm install pinia //安装pinia
</code></pre>
<p>pinia简单使用</p>
<p><img src="/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/image-20221119150910678.png"></p>
<p>1.在main.ts中注册pinia</p>
<pre><code class="tsx">//main.ts
import &#123; createApp &#125; from &#39;vue&#39;
import &#39;./style.css&#39;
import App from &#39;./App.vue&#39;
import &#123;createPinia&#125; from &#39;pinia&#39; 

createApp(App).use(createPinia()).mount(&#39;#app&#39;)
</code></pre>
<p>2.创建src&#x2F;type&#x2F;user.d.ts</p>
<pre><code class="tsx">// 用户的类型声明文件
interface IUser &#123;
    name: string;
    age: number;
&#125;  
</code></pre>
<p>3.创建src&#x2F;store&#x2F;user.ts</p>
<pre><code class="tsx">//user.ts
import &#123; defineStore &#125; from &quot;pinia&quot;;
 
export default defineStore(&quot;user&quot;, &#123;
  state() &#123;
    return &#123;
      userList: [] as IUser[],
    &#125;;
  &#125;,
  actions: &#123;
    getList() &#123;
      // 模拟从后端获取数据
      let resList: IUser[] = [
        &#123; name: &quot;孟峰&quot;, age: 24 &#125;,
        &#123; name: &quot;孟一&quot;, age: 19 &#125;
      ];
      this.userList = resList;
    &#125;,
  &#125;,
&#125;);
</code></pre>
<p>4.创建src&#x2F;store&#x2F;index.ts</p>
<pre><code class="tsx">//index.ts
import useUserStore from &quot;./user&quot;;
 
export default function useStore() &#123;
  return &#123;
    user: useUserStore(),
  &#125;;
&#125;
</code></pre>
<p>5.App.vue使用</p>
<pre><code class="vue">&lt;script setup lang=&quot;ts&quot;&gt;
// 从状态层导出指定模块
import useStore from &quot;./store&quot;;
const &#123; user &#125; = useStore();
// 获取用户列表
user.getList();
&lt;/script&gt;
 
&lt;template&gt;
  &lt;div&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;item in user.userList&quot;&gt;
        姓名：&#123;&#123; item.name &#125;&#125; ---- 年龄：&#123;&#123; item.age &#125;&#125;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><img src="/2022/11/19/Vue3-Ts-Vite-Pinia%E7%BB%84%E5%90%88%E7%9A%84%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6/image-20221119151532682.png"></p>
<h3 id="五、集成pretter和eslint"><a href="#五、集成pretter和eslint" class="headerlink" title="五、集成pretter和eslint"></a>五、集成pretter和eslint</h3><pre><code class="ini">npm i prettier -D //安装prettier
npm i eslint -D //安装eslint
npx eslint --init //初始化eslint
</code></pre>
<p>根目录创建<code>.prettierrc.js</code>文件</p>
<pre><code class="javascript">//.prettierrc.js
module.exports = &#123;
    printWidth: 140,// 超过最大值换行
    tabWidth: 4, // tab键宽度，默认为4
    useTabs: true,// 使用tab（制表符）缩进而非空格
    singleQuote: true,// 用单引号代替双引号
    semi: true,// 行末是否加分号
    trailingComma: &#39;none&#39;,// 最后一个对象元素加逗号
    bracketSpacing: true,// 对象，数组加空格
    jsxBracketSameLine: true, // jsx &gt; 是否另起一行
  
  &#125;;
</code></pre>
<pre><code class="js">//.eslintrc.cjs
module.exports = &#123;
  root: true,
  env: &#123;
    browser: true,
    node: true,
    es6: true,
    commonjs: true,
    amd: true
  &#125;,
  // ts eslint 配置
  parserOptions: &#123;
    parser:&#39;@typescript-eslint/parser&#39;,
  &#125;,
  plugins: [&#39;@typescript-eslint&#39;],
  extends: [&#39;plugin:vue/vue3-recommended&#39;,&#39;plugin:prettier/recommended&#39;,&#39;prettier/@typescript-eslint&#39;,&#39;plugin:@typescript-eslint/recommended&#39;],
  // js eslint 配置
  // parserOptions: &#123;
  //   parser: &#39;babel-eslint&#39;,
  //   sourceType: &#39;module&#39;
  // &#125;,
  // plugins: [&#39;html&#39;, &#39;vue&#39;],
  // extends: [&#39;plugin:vue/recommended&#39;, &#39;eslint:recommended&#39;],
 
  rules: &#123;
    &#39;max-len&#39;: &#39;off&#39;,
     // 统一豁免规则，原因：直接修改可能对现有功能产生影响
     &#39;eqeqeq&#39;: 1,
    //  &#39;vue/no-v-html&#39;: 1,
     // 其中代码本身有问题的规则错误有
     &#39;no-undef&#39;: 0,
     &#39;import/no-duplicates&#39;: 0,
 
     // 可能引起格式化问题但建议手动修改代码的有
     &#39;no-plusplus&#39;: 0,
     &#39;no-eval&#39;: 0,
     &#39;no-prototype-builtins&#39;: 0,
     &#39;no-multi-assign&#39;: 0,
     &#39;no-unused-vars&#39;: 0,
     &#39;no-useless-escape&#39;: 0,
     &#39;camelcase&#39;: 0,
     &#39;vue/no-unused-components&#39;: 0,
     &#39;vue/return-in-computed-property&#39;: 0,
     &#39;no-param-reassign&#39;: 0,
     &#39;prefer-const&#39;: 0,
     &#39;prefer-destructuring&#39;: 0,
     &#39;no-underscore-dangle&#39;: 0,
     &#39;no-restricted-syntax&#39;: 0,
     &#39;no-nested-ternary&#39;: 0,
     &#39;radix&#39;: 0,
     &#39;vue/no-side-effects-in-computed-properties&#39;: 0,
     &#39;vue/order-in-components&#39;: 0,
     &#39;function-paren-newline&#39;: 0,
  &#125;,
&#125;;
</code></pre>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[git仓库项目源码]: 	“<a target="_blank" rel="noopener" href="https://github.com/mengfeng/vite-vue3-pinia-ts">https://github.com/mengfeng/vite-vue3-pinia-ts</a> “<br>[Vite中文官网]: 		“<a target="_blank" rel="noopener" href="https://cn.vitejs.dev/">https://cn.vitejs.dev</a> “<br>[pinia中文官网]: 	“<a target="_blank" rel="noopener" href="https://pinia.web3doc.top/getting-started.html#%E5%AE%89%E8%A3%85">https://pinia.web3doc.top/getting-started.html#安装</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-webgl"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/18/webgl/"
    >webgl</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/18/webgl/" class="article-date">
  <time datetime="2022-11-18T06:22:29.000Z" itemprop="datePublished">2022-11-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/WebGl/">WebGl</a> / <a class="article-category-link" href="/categories/WebGl/webgl/">webgl</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="webgl"><a href="#webgl" class="headerlink" title="webgl"></a>webgl</h1><h2 id="第一章-webgl绘图流程"><a href="#第一章-webgl绘图流程" class="headerlink" title="第一章  webgl绘图流程"></a>第一章  webgl绘图流程</h2><hr>
<h3 id="一、创建canvas画布"><a href="#一、创建canvas画布" class="headerlink" title="一、创建canvas画布"></a>一、创建canvas画布</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        body&#123;
            margin: 0;
            overflow: hidden;
        &#125;
        #canvas&#123;
            background-color: pink;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="二、js获取canvas画布"><a href="#二、js获取canvas画布" class="headerlink" title="二、js获取canvas画布"></a>二、js获取canvas画布</h3><pre><code class="javascript">const canvas = document.querySelector(&#39;#canvas&#39;)
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
</code></pre>
<h3 id="三、使用canvas获取webgl绘图上下文"><a href="#三、使用canvas获取webgl绘图上下文" class="headerlink" title="三、使用canvas获取webgl绘图上下文"></a>三、使用canvas获取webgl绘图上下文</h3><pre><code class="javascript"> const gl = canvas.getContext(&quot;webgl&quot;)
        gl.clearColor(1,0,0,1)
        gl.clear(gl.COLOR_BUFFER_BIT)
</code></pre>
<h3 id="四、在script中建立顶点着色器和顶点着色器-glsl-es语言"><a href="#四、在script中建立顶点着色器和顶点着色器-glsl-es语言" class="headerlink" title="四、在script中建立顶点着色器和顶点着色器(glsl es语言)"></a>四、在script中建立顶点着色器和顶点着色器(glsl es语言)</h3><pre><code class="javascript">&lt;!-- 顶点着色器 --&gt;
&lt;script id=&quot;vertexShader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
        void main()&#123;
            gl_Position = vec4(0,0,0,1);
            gl_PointSize = 50.0;
        &#125;
&lt;/script&gt;
    &lt;!-- 片元着色器 --&gt;
&lt;script id=&quot;fragmentShader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
        void main()&#123;
            gl_FragColor = vec4(1,1,1,1);
        &#125;
&lt;/script&gt;
</code></pre>
<h3 id="五、在js中获取顶点着色器和片元着色器"><a href="#五、在js中获取顶点着色器和片元着色器" class="headerlink" title="五、在js中获取顶点着色器和片元着色器"></a>五、在js中获取顶点着色器和片元着色器</h3><pre><code class="javascript">//顶点着色器文本
const vsSource = document.getElementById(&#39;vertexShader&#39;).innerText;
//片元舍色器文本
const fsSourse = document.getElementById(&#39;fragmentShader&#39;).innerText;
</code></pre>
<h3 id="六、初始化节点"><a href="#六、初始化节点" class="headerlink" title="六、初始化节点"></a>六、初始化节点</h3><pre><code class="javascript"> //初始化着色器
 initShaders(gl,vsSource,fsSourse);
</code></pre>
<h3 id="七、指定将来用来清空绘图区的颜色"><a href="#七、指定将来用来清空绘图区的颜色" class="headerlink" title="七、指定将来用来清空绘图区的颜色"></a>七、指定将来用来清空绘图区的颜色</h3><pre><code class="javascript">//指定将要用来清理绘图区的颜色
gl.clearColor(0,0,0,1);
</code></pre>
<h3 id="八、使用指定颜色清空绘图区"><a href="#八、使用指定颜色清空绘图区" class="headerlink" title="八、使用指定颜色清空绘图区"></a>八、使用指定颜色清空绘图区</h3><pre><code class="javascript">//清理绘图区
gl.clear(gl.COLOR_BUFFER_BIT);
</code></pre>
<h3 id="九、绘制顶点"><a href="#九、绘制顶点" class="headerlink" title="九、绘制顶点"></a>九、绘制顶点</h3><pre><code class="javascript">//绘制顶点(点模式)
gl.drawArrays(gl.POINTS,0,1);
</code></pre>
<h3 id="十、初始化节点具体代码实现"><a href="#十、初始化节点具体代码实现" class="headerlink" title="十、初始化节点具体代码实现"></a>十、初始化节点具体代码实现</h3><pre><code class="javascript">function initShaders(gl,vsSource,fsSourse)&#123;
//创建程序对象
const program = gl.createProgram();
//建立着色对象
const vertexShader = loadShader(gl,gl.VERTEX_SHADER,vsSource);
const fragmentShader = loadShader(gl,gl.FRAGMENT_SHADER,fsSourse);
//将顶点着色对象装进程序对象中
gl.attachShader(program, vertexShader);
//将片元着色对象装进程序对象中
         gl.attachShader(program,fragmentShader);
//连接webgl上下文对象和程序对象
gl.linkProgram(program);
//启动程序对象
gl.useProgram(program);
//将程序对象挂到上下文对象
gl.program = program;
return true;
&#125;

function loadShader(gl,type,source)&#123;
//根据着色器的类型，建立着色器对象
const shader = gl.createShader(type);
//将着色器源文件传入着色器对象中
gl.shaderSource(shader, source);
//编译着色器对象
gl.compileShader(shader);
//返回着色器对象
return shader;
&#125;
</code></pre>
<h2 id="第二章-用js控制点位"><a href="#第二章-用js控制点位" class="headerlink" title="第二章  用js控制点位"></a>第二章  用js控制点位</h2><h3 id="一、js中声明attribute变量"><a href="#一、js中声明attribute变量" class="headerlink" title="一、js中声明attribute变量"></a>一、js中声明attribute变量</h3><pre><code class="javascript">&lt;script id=&quot;vertexShader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
//声明变量类型vec4，导出变量a_Position
        attribute vec4 a_Position;
//修改顶点尺寸和修改顶点位置是一样的原理，只是类型为float
        void main()&#123;
            gl_Position = a_Position;
            gl_PointSize = 50.0;
        &#125;
    &lt;/script&gt;
</code></pre>
<h3 id="二、js获取attribute变量"><a href="#二、js获取attribute变量" class="headerlink" title="二、js获取attribute变量"></a>二、js获取attribute变量</h3><pre><code class="javascript">//设置attribute变量
const a_Position = gl.getAttribLocation(gl.program, &#39;a_Position&#39;);
</code></pre>
<h3 id="三、在js中修改attribute变量"><a href="#三、在js中修改attribute变量" class="headerlink" title="三、在js中修改attribute变量"></a>三、在js中修改attribute变量</h3><pre><code class="javascript">//修改attribute变量值
gl.vertexAttrib3f(a_Position,0,0,0)
//参数（变量名,x,y,z）
//也有许多同族函数
gl.vertexAttrib1f(a_Position,0)
gl.vertexAttrib2f(a_Position,0,0)
gl.vertexAttrib3f(a_Position,0,0,0)
gl.vertexAttrib4f(a_Position,0,0,0,0)
</code></pre>
<h3 id="案例小节（鼠标控制点位）"><a href="#案例小节（鼠标控制点位）" class="headerlink" title="案例小节（鼠标控制点位）"></a>案例小节（鼠标控制点位）</h3><h4 id="1-获取鼠标在canvas中的位置"><a href="#1-获取鼠标在canvas中的位置" class="headerlink" title="1.获取鼠标在canvas中的位置"></a>1.获取鼠标在canvas中的位置</h4><pre><code class="javascript">//获取鼠标点在canvas中的位置
canvas.addEventListener(&#39;click&#39;,(event)=&gt;&#123;
const &#123;clientX,clientY&#125; = event;
const &#123;left,top&#125; = canvas.getBoundingClientRect();
const [cssX,cssY]=[clientX - left,clientY - top];
        &#125;)
</code></pre>
<p><img src="/2022/11/18/webgl/image-20220922115516857.png"></p>
<pre><code class="javascript">//解决canvas和webgl差异
//1.解决原点差异
const [halfWidth,halfHeight] = [width/2,height/2];
const [xBaseCenter,yBaseCenter] = [cssX - halfWidth,cssY - halfHeight];
//2.解决y轴轴向差异
const yBaseCenterTop = -yBaseCenter;
//3.解决基底差异
const [x,y] = [xBaseCenter/halfWidth,yBaseCenterTop/halfHeight];
</code></pre>
<h4 id="2-绘制图层"><a href="#2-绘制图层" class="headerlink" title="2.绘制图层"></a>2.绘制图层</h4><pre><code class="javascript">gl.vertexAttrib2f(a_Position,x,y);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.drawArrays(gl.POINTS,0,1);
</code></pre>
<h3 id="四、webgl同步绘图原理"><a href="#四、webgl同步绘图原理" class="headerlink" title="四、webgl同步绘图原理"></a>四、webgl同步绘图原理</h3><p>​       webgl 的同步绘图的现象,其实是由于 webgl 底层内置颜色缓冲区导致的.它在电脑中会占用一块内存,在我们使用 webgl 绘图的时候,是在颜色缓冲区中画出来,但是图片暂时还未渲染出来.只有 webgl 自己知道.如果我们想要将图像的时候,那就照着缓冲区的图像去画,这个步骤是 webgl 内部自己完成的,我们只需要执行绘图命令就行了,颜色缓冲区存储的图像,只有当前线程有效,比如我们先在 js 主线程绘图的时候,主线程结束后,会在执行信息队列的异步线程,子啊执行异步线程时,颜色缓冲区会被 webgl 重置,导致颜色缓冲器绘制的图形被清除,导致以前绘制的图像也会消失.</p>
<h2 id="第三章-用js控制顶点颜色"><a href="#第三章-用js控制顶点颜色" class="headerlink" title="第三章  用js控制顶点颜色"></a>第三章  用js控制顶点颜色</h2><h3 id="一、js中声明uniform变量"><a href="#一、js中声明uniform变量" class="headerlink" title="一、js中声明uniform变量"></a>一、js中声明uniform变量</h3><pre><code class="javascript">&lt;script id=&quot;fragmentShader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
 //将float精度设置为中等
 precision mediump float;
 uniform vec4 u_FragColor;
 void main()&#123;
    gl_FragColor = u_FragColor;
 &#125;
&lt;/script&gt;
</code></pre>
<h3 id="二、js获取uniform变量"><a href="#二、js获取uniform变量" class="headerlink" title="二、js获取uniform变量"></a>二、js获取uniform变量</h3><pre><code class="javascript">const u_FragColor = gl.getUniformLocation(gl.program, &#39;u_FragColor&#39;);
</code></pre>
<h3 id="三、在js中修改uniform变量值"><a href="#三、在js中修改uniform变量值" class="headerlink" title="三、在js中修改uniform变量值"></a>三、在js中修改uniform变量值</h3><pre><code class="javascript">//一个一个传递参数
gl.uniform4f(u_FragColor, 0.0, 1.0, 0.0, 1.0);
//可以以数组的形式传递参数
//Float32Array为一种32位浮点型数组，在浏览器中的运行效率比Array要高的多
const color = new Float32Array([1.0,1.0,0.0,1.0]);
gl.uniform4v(u_FragColor,color);
</code></pre>
<h3 id="四、片元着色器的绘图原理"><a href="#四、片元着色器的绘图原理" class="headerlink" title="四、片元着色器的绘图原理"></a>四、片元着色器的绘图原理</h3><p>​     我们所看到的图形都是由多个片元组成的，那么想要绘制相应图形，只需要渲染范围内的片元就可以了</p>
<p><img src="/2022/11/18/webgl/image-20220922162314987.png"></p>
<p>具体代码实现：</p>
<pre><code class="javascript">&lt;script id=&quot;fragmentShader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
precision mediump float;
uniform vec4 u_FragColor;
void main()&#123;
  //distance为计算两个点的距离 distance(p1,p2)
  //gl_PointCoord片元在一个点中的位置是统一化的
  //discard丢弃，不会进行渲染
float dist = distance(gl_PointCoord,vec2(0.5,0.5));
if(dist &lt; 0.5)&#123;
  //进入范围就渲染
    gl_FragColor = u_FragColor;
&#125;else&#123;
    discard;
&#125;
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="五、片元着色器合成功能"><a href="#五、片元着色器合成功能" class="headerlink" title="五、片元着色器合成功能"></a>五、片元着色器合成功能</h3><p>开启着色器合成功能和声明合成方式才可以生效</p>
<pre><code class="javascript">//开启片元着色器合成功能
gl.enable(gl.BLEND);
//设置片元着色器合成方式
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
</code></pre>
<h2 id="第四章-架构补间动画"><a href="#第四章-架构补间动画" class="headerlink" title="第四章 架构补间动画"></a>第四章 架构补间动画</h2><p>完成透明度动画</p>
<h3 id="一、建立合成对象"><a href="#一、建立合成对象" class="headerlink" title="一、建立合成对象"></a>一、建立合成对象</h3><pre><code class="javascript">export default class Compose &#123;
    constructor()&#123;
//parent 父对象，合成对象可以嵌套
        this.parent = null;
//children 子对象集合，其集合可以是时间轨，也可以是合成对象
        this.children = [];
    &#125;
//添加子对象方法
    add(obj)&#123;
        obj.parent = this;
        this.children.push(obj);
    &#125;
//基于当前时间更新子对象状态的方法
    update(t) &#123;
        this.children.forEach((ele)=&gt;&#123;
            ele.update(t);
        &#125;)
    &#125;
&#125;
</code></pre>
<h3 id="二、建立时间轨"><a href="#二、建立时间轨" class="headerlink" title="二、建立时间轨"></a>二、建立时间轨</h3><pre><code class="javascript">export default class Track&#123;
    constructor(target)&#123;
        this.target = target;
        this.parent = null;
        this.start = 0;
        this.timeLen = 5;
        this.loop = false;
        this.keyMap = new Map();
    &#125;
    update(t) &#123;
        const &#123;target,start,timeLen,loop,keyMap&#125; = this;
        //本地时间
        let time = t - start;
        if(loop)&#123;
            time = time % timeLen;
        &#125;
        //遍历关键帧集合，判断在两个关键帧之前还是之后
        for(const [key,fms] of keyMap)&#123;
            const last = fms.length - 1;
            if(time &lt; fms[0][0])&#123;
                target[key] = fms[0][1]; 
            &#125;else if(time &gt; fms[0][1])&#123;
                target[key] = fms[last][0];
            &#125;else&#123;
                target[key] = getValBetweenFms(time,fms,last);
            &#125;
        &#125;
    &#125;
&#125;

//获取两个关键帧之间的补间状态的方法
function getValBetweenFms(time,fms,last)&#123;
    for(let i = 0;i &lt; last;i++)&#123;
        //两个关键帧fm1和fm2
        const fm1 = fms[i];
        const fm2 = fms[i + 1];
        //如果在两个关键帧之间，基于两个关键帧的时间和状态求点斜式
        if(time &gt;= fm1[0] &amp;&amp; time &lt;= fm2[0])&#123;
            const delta = &#123;
                x: fm2[0] - fm1[0],
                y: fm2[1] - fm1[1],
            &#125;;
            //获取斜率k和截距b
            const k = delta.y / delta.x;
            const b = fm1[1] - fm1[0] * k;
            //根据点斜式求当前时间对应的状态
            return k * time + b;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="/2022/11/18/webgl/image-20220922181506452.png"></p>
<h3 id="三、使用合成对象和轨道对象制作补间动画"><a href="#三、使用合成对象和轨道对象制作补间动画" class="headerlink" title="三、使用合成对象和轨道对象制作补间动画"></a>三、使用合成对象和轨道对象制作补间动画</h3><pre><code class="javascript">//引入合成对象Compose和轨道对象Track
import Compose from &#39;./utils/Compose.js&#39;
import Track from &#39;./utils/ComposeOne.js&#39;
</code></pre>
<pre><code class="javascript">const compose = new Compose();
</code></pre>
<pre><code class="javascript">const obj = &#123;x,y,size&#125;;
starts.push(obj);
//建立轨道对象
const track = new Track(obj);
track.start = new Date();
track.timeLen = 2000;
track.loop = true;
track.keyMap = new Map([
            [
                &#39;size&#39;,
                [
                    [500,size],
                    [1000,0],
                    [1500,size]
                ]
            ]
           ])
compose.add(track);
</code></pre>
<pre><code class="javascript">//连续渲染
!(function ani()&#123;
            compose.update(new Date());
            render();
            requestAnimationFrame(ani);
 &#125;)()
 //渲染方法
 function render()&#123;
gl.clear(gl.COLOR_BUFFER_BIT);
starts.forEach((&#123;x,y,size&#125;)=&gt;&#123;
   gl.vertexAttrib2f(a_Position,x,y);
   gl.vertexAttrib1f(a_PointSize,size);
   gl.uniform4f(u_FragColor, 1.0, 1.0,1.0, Math.random()*1);
   
  gl.drawArrays(gl.POINTS,0,1);
            &#125;)
        &#125;
</code></pre>
<h2 id="第五章-绘制多点图形"><a href="#第五章-绘制多点图形" class="headerlink" title="第五章 绘制多点图形"></a>第五章 绘制多点图形</h2><h3 id="一、绘制多点步骤"><a href="#一、绘制多点步骤" class="headerlink" title="一、绘制多点步骤"></a>一、绘制多点步骤</h3><p>和之前的webgl绘图流程是一样的只是赋值attribute不一样</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;webgl多点绘制&lt;/title&gt;
    &lt;style&gt;
        body&#123;
            margin: 0;
            overflow: hidden;
        &#125;
        #canvas&#123;
            background-color: antiquewhite;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
    &lt;!-- 顶点着色器 --&gt;
    &lt;script id=&quot;vertexShader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
        attribute vec4 a_Position;
        void main()&#123;
            gl_Position = a_Position;
            gl_PointSize = 50.0;
        &#125;
    &lt;/script&gt;
    &lt;!-- 片元着色器 --&gt;
    &lt;script id=&quot;fragmentShader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
        void main()&#123;
            gl_FragColor = vec4(1,1,1,1);
        &#125;
    &lt;/script&gt;
    &lt;script type=&quot;module&quot;&gt;
        import &#123;initShaders&#125; from &#39;./utils/index.js&#39;
        //canvas画布，获取上下文对象
        const canvas = document.querySelector(&#39;#canvas&#39;);
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        //webgl画笔
        const gl = canvas.getContext(&quot;webgl&quot;);
        //顶点着色器文本
        const vsSource = document.getElementById(&#39;vertexShader&#39;).innerText;
        //片元舍色器文本
        const fsSourse = document.getElementById(&#39;fragmentShader&#39;).innerText;
        //初始化着色器
        initShaders(gl,vsSource,fsSourse);
      //设置attribute变量
        const a_Position =                        gl.getAttribLocation(gl.program, &#39;a_Position&#39;);
        //在这开始修改

        //指定将要用来清理绘图区的颜色
        gl.clearColor(0,0,0,1);
        //清理绘图区
        gl.clear(gl.COLOR_BUFFER_BIT);
        //绘制顶点
        gl.drawArrays(gl.POINTS,0,1);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="二、绘制多点"><a href="#二、绘制多点" class="headerlink" title="二、绘制多点"></a>二、绘制多点</h3><p><img src="/2022/11/18/webgl/image-20220923105127932.png"></p>
<pre><code class="javascript">//如何向attribute变量中写入多点，并绘制多点
//创建顶点数据
const vertices =new Float32Array([0.0,0.1,-0.1,-0.1,0.1,-0.1])
//建立缓存对象，独立缓存区
const vertexBuffer = gl.createBuffer();
//绑定缓存对象
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
//写入数据
gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);
//获取attribute变量
gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
//开启批处理功能
gl.enableVertexAttribArray(a_Position);
</code></pre>
<pre><code class="javascript">//添加顶点的时候，也要修改绘制顶点的数量 
//绘制顶点
 gl.drawArrays(gl.POINTS,0,3);
</code></pre>
<h3 id="三、绘制三角面"><a href="#三、绘制三角面" class="headerlink" title="三、绘制三角面"></a>三、绘制三角面</h3><pre><code class="javascript">//不需要顶点大小了
//修改绘图方式就可以了
gl.drawArrays(gl.TRIANGLES,0,3);
</code></pre>
<h3 id="四、绘制线"><a href="#四、绘制线" class="headerlink" title="四、绘制线"></a>四、绘制线</h3><p>绘制线的方式主要是修改顶点个数和绘图方式gl.drawArrays(mode,first,count);</p>
<ul>
<li>POINTS 可视的点</li>
<li>LINES 单独线段</li>
<li>LINE_STRIP 线条</li>
<li>LINE_LOOP闭合线条</li>
<li>TRIANGLES 单独三角形</li>
<li>TRIANGLE_STRIP 三角带</li>
<li>TRIANGLE_FAN 三角扇</li>
</ul>
<h3 id="五、三角带和三角扇的规则"><a href="#五、三角带和三角扇的规则" class="headerlink" title="五、三角带和三角扇的规则"></a>五、三角带和三角扇的规则</h3><p><img src="/2022/11/18/webgl/image-20220923120827422.png"></p>
<p><img src="/2022/11/18/webgl/image-20220923122032402.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webgl/" rel="tag">webgl</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全之手写代码一"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E4%B8%80/"
    >前端面试大全之手写代码一</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E4%B8%80/" class="article-date">
  <time datetime="2022-11-17T06:51:50.000Z" itemprop="datePublished">2022-11-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E4%B8%80/">前端面试大全之手写代码一</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试大全之手写代码（一）"><a href="#前端面试大全之手写代码（一）" class="headerlink" title="前端面试大全之手写代码（一）"></a>前端面试大全之手写代码（一）</h1><p>每日12题（高频基础）</p>
<h3 id="1-构造函数继承"><a href="#1-构造函数继承" class="headerlink" title="1.构造函数继承"></a>1.构造函数继承</h3><pre><code class="javascript">function Super(name,age)&#123;
    this.name = name;
    this.age = age;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;];
    this.sayHi = function()&#123;
        console.log(&#39;hi&#39;)
    &#125;
    console.log(this)
&#125;
function Sub()&#123;
    Super.apply(this,arguments)
    this.height = 180;
&#125;

var instance1 = new Sub(&#39;mengfeng&#39;,25);
var instance2 = new Sub(&#39;mengfeng123&#39;,24);
instance1.sayHi();
</code></pre>
<h3 id="2-计时器"><a href="#2-计时器" class="headerlink" title="2.计时器"></a>2.计时器</h3><pre><code class="javascript">var i = 10;
let fn = () =&gt; &#123;
    console.log(i--);
&#125;
function mySetInterval(fn, delay, times) &#123;
    let timer = setTimeout(function a() &#123;
        fn()
        times--
        timer = setTimeout(a, delay)
        if (times &lt;= 0) &#123;
            clearTimeout(timer)
        &#125;
    &#125;, delay)
&#125;
mySetInterval(fn, 1000, 10)
</code></pre>
<h3 id="3-寄生组合继承"><a href="#3-寄生组合继承" class="headerlink" title="3.寄生组合继承"></a>3.寄生组合继承</h3><pre><code class="javascript"> function inheritPrototype(Sub,Super)&#123;
    var subPrototype=Object.create(Super.prototype)
    subPrototype.constructor=Sub
    Sub.prototype=subPrototype
    
  &#125;
  function Super(name)&#123;
    this.name=name
  &#125;
  Super.prototype.sayHi=function()&#123;
    console.log(this.name)//ccdida
  &#125;
  function Sub(name)&#123;
    Super.call(this,name)
  &#125;
  inheritPrototype(Sub,Super)

  Sub.prototype.sayHello=function()&#123;
    console.log(&#39;sayHello&#39;)
  &#125;

  var instance1=new Sub(&#39;ccdida&#39;)
  console.log(instance1.__proto__)
  console.log(instance1.__proto__.__proto__)
</code></pre>
<h3 id="4-柯里化函数"><a href="#4-柯里化函数" class="headerlink" title="4.柯里化函数"></a>4.柯里化函数</h3><pre><code class="javascript">function add() &#123;
    const _args = [...arguments];
    function fn() &#123;
      _args.push(...arguments);
      return fn; //一直重复收集参数
    &#125;
    fn.toString = function() &#123;
      return _args.reduce((sum, cur) =&gt; sum + cur);
    &#125;
    return fn;
  &#125;
console.log(add(1)(2)(3)(4).toString())
console.log(add(1,2)(1, 2, 3)(2).toString())
</code></pre>
<h3 id="5-千位符"><a href="#5-千位符" class="headerlink" title="5.千位符"></a>5.千位符</h3><pre><code class="javascript">// 将金额类型转为数字类型
function toNum(str) &#123;
    return str.replace(/\,|\￥/g, &quot;&quot;);
&#125;

// 保留两位小数（四舍五入）
function toPrice(num) &#123;
    num = parseFloat(toNum(num)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);
&#125;

// 保留两位小数（不四舍五入）
function toPrice1(num) &#123;
    num = parseFloat(toNum(num).replace(/(\.\d&#123;2&#125;)\d+$/,&quot;$1&quot;)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);;
&#125;

// 不处理小数部分
function toPrice2(num) &#123;
    var source = toNum(num).split(&quot;.&quot;);
    source[0] = source[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + source.join(&quot;.&quot;)
&#125;

console.log(toPrice(&#39;12312.236&#39;)) //￥12,312.24
console.log(toPrice1(&#39;12312.234&#39;)) //￥12,312.23
console.log(toPrice2(&#39;1232342312.234&#39;)) //￥1,232,342,312.234
</code></pre>
<h3 id="6-深拷贝"><a href="#6-深拷贝" class="headerlink" title="6.深拷贝"></a>6.深拷贝</h3><pre><code class="javascript">function deepClone(obj,hash = new WeakMap())&#123;
    if(obj == null) return obj;
    if(obj instanceof Date) return new Date(obj);
    if(obj instanceof RegExp) return new RegExp(obj);
    if(typeof obj !== &#39;object&#39;) return obj;
    if(hash.get(obj)) return hash.get(obj);
    let cloneObj = new obj.constructor;
    hash.set(obj,cloneObj);
    for(let key in obj)&#123;
        if(obj.hasOwnProperty(key))&#123;
            cloneObj[key] = deepClone(obj[key],hash);
        &#125;
    &#125;
    return cloneObj;
&#125;

let obj = &#123;name:1,address:&#123;x:1000&#125;&#125;;
let d = deepClone(obj);
obj.address.x = 200;
console.log(d); //&#123;name:1,address:&#123;x:1000&#125;&#125;
</code></pre>
<h3 id="7-数组扁平化"><a href="#7-数组扁平化" class="headerlink" title="7.数组扁平化"></a>7.数组扁平化</h3><pre><code class="javascript">//递归实现
var arr = [1,2,[3,4,[5,6]]]
function flatten(arr)&#123;
    let result = []
    arr.forEach(item =&gt; &#123;
        if(Array.isArray(item))&#123;
            result = result.concat(flatten(item))
        &#125;else&#123;
            result.push(item)
        &#125;
    &#125;);
    return result
&#125;
console.log(flatten(arr)) //[ 1, 2, 3, 4, 5, 6 ]

//利用reduce函数迭代
var arr1 = [1,2,[3,4,[5,6]]]
function flatten1(arr)&#123;
    return arr.reduce((res,next) =&gt; &#123;
        return res.concat(Array.isArray(next) ? flatten1(next) : next)
    &#125;,[])
&#125;
console.log(flatten1(arr1)) //[ 1, 2, 3, 4, 5, 6 ]
</code></pre>
<h3 id="8-原型链继承"><a href="#8-原型链继承" class="headerlink" title="8.原型链继承"></a>8.原型链继承</h3><pre><code class="javascript">//1.原型链继承
function Super()&#123;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;black&#39;]
&#125;
function Sub()&#123;
&#125;

Sub.prototype = new Super();
const instance1 = new Sub();
const instance2 = new Sub();
console.log(instance1.__proto__.color === instance2.__proto__.color)//true
</code></pre>
<h3 id="9-组合继承"><a href="#9-组合继承" class="headerlink" title="9.组合继承"></a>9.组合继承</h3><pre><code class="javascript">function Super(name,age)&#123;
    this.name = name;
    this.age = age;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;]
&#125;

Super.prototype.sayHi = function()&#123;
    console.log(&#39;hi&#39;)
&#125;

function Sub(name,age,height)&#123;
    Super.apply(this,arguments)
    this.height = height;
&#125;

Sub.prototype = new Super(&#39;w&#39;,22);
Sub.prototype.constructor = Sub;
console.log(Sub.prototype)
Sub.prototype.sayHello = function()&#123;
    console.log(&#39;hello&#39;)
&#125;

var instance1 = new Sub(&#39;mengfeng&#39;,23,180);
var instance2 = new Sub(&#39;mengfeng123&#39;,24,181);
console.log(instance1)
</code></pre>
<h3 id="10-instanceof"><a href="#10-instanceof" class="headerlink" title="10.instanceof"></a>10.instanceof</h3><pre><code class="javascript">function new_instance_of(leftValue,rightValue)&#123;
    let rightProto = rightValue.prototype;//取右边表达式的 prototype 值
    leftValue = leftValue.__proto__;//取左表达式的 __proto__ 值
    while(true)&#123;
        if(leftValue == null)&#123;
            return false;
        &#125;
        if(leftValue === rightProto)&#123;
            return true;
        &#125;
        leftValue = leftValue.__proto__;
    &#125;
&#125;
function Foo()&#123;&#125;
console.log(new_instance_of(Foo,Object))//true
</code></pre>
<h3 id="11-promise-all"><a href="#11-promise-all" class="headerlink" title="11.promise.all"></a>11.promise.all</h3><pre><code class="javascript">Promise.prototype.all = function(promises)&#123;
    let results = [];
    let promiseCount = 0;
    let promisesLength = promises.length;
    return new Promise(function(resolve,reject)&#123;
        for(let val of promises)&#123;
            Promise.resolve(val).then(function(res)&#123;
                promiseCount++;
                results[i] = res;
                if(promiseCount === promisesLength)&#123;
                    return resolve(results);
                &#125;
            &#125;,function(err)&#123;
                return reject(err);
            &#125;)
        &#125;
    &#125;)
&#125;

let promise1 = new Promise(function(resolve) &#123;
    resolve(1);
  &#125;);
  let promise2 = new Promise(function(resolve) &#123;
    resolve(2);
  &#125;);
  let promise3 = new Promise(function(resolve) &#123;
    resolve(3);
  &#125;);
  
  let promiseAll = Promise.all([promise1, promise2, promise3]);
  promiseAll.then(function(res) &#123;
    console.log(res);
  &#125;);
</code></pre>
<h3 id="12-promise-race"><a href="#12-promise-race" class="headerlink" title="12.promise.race"></a>12.promise.race</h3><pre><code class="javascript">Promise.race = function(promises)&#123;
    //将可迭代对象转换为数组
    promises = Array.from(promises);
    return new Promise((resolve,reject)=&gt;&#123;
        if(promises.length === 0)&#123;
            //空的可迭代对象，用于pending状态
        &#125;else&#123;
            for(let i = 0;i &lt; promises.length;i++)&#123;
                Promise.resolve(promises[i]).then((data)=&gt;&#123;
                    resolve(data);
                &#125;).catch((reason)=&gt;&#123;
                    reject(reason)
                &#125;)
            &#125;
        &#125;
    &#125;)
&#125;

let p1 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;success&#39;)
    &#125;,1000)
&#125;)

let p2 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;faild&#39;)
    &#125;,500)
&#125;)

Promise.race([p1,p2]).then(result=&gt;&#123;
console.log(result)             //  faild    faild耗时短
&#125;)
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Drone-UI挂起"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/"
    >Drone-UI挂起</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/" class="article-date">
  <time datetime="2022-11-16T03:02:29.000Z" itemprop="datePublished">2022-11-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CI-CD/">CI/CD</a> / <a class="article-category-link" href="/categories/CI-CD/Drone-UI%E6%8C%82%E8%B5%B7/">Drone-UI挂起</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Drone-UI挂起"><a href="#Drone-UI挂起" class="headerlink" title="Drone-UI挂起"></a>Drone-UI挂起</h1><h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>当我们将.drone.yml配置文件放在项目根目录，执行</p>
<pre><code class="ini">git init //初始化仓库
git remote add origin 仓库地址 //链接远程仓库
git add . 
git commit -m &quot;xxxx&quot;
git push 仓库地址 //推送远程仓库
</code></pre>
<p>当我们将.drone.yml推送到仓库的时候，那么webhooks就会被触发，我们在drone ci页面就可以看见构建流程</p>
<p>但如果我们的.drone.yml配置失败，那么就会出现一直卡在pending上，或者构建失败</p>
<p><img src="/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/image-20221115090812831.png"></p>
<h3 id="二、修改配置文件"><a href="#二、修改配置文件" class="headerlink" title="二、修改配置文件"></a>二、修改配置文件</h3><p>1、.dron.yml文件配置和执行程序对应</p>
<p>如果没有对应配置，那么就会pending</p>
<p><img src="/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/image-20221116105118132.png"></p>
<p>举个荔枝：</p>
<pre><code class="ini">#.dron.yml
kind: pipeline
type: docker
name: deployment

platform:
  os: linux
  arch: arm64

steps:
  - name: deployment
    image: node
    commands:
      - pwd
      - ls
      - node app.js

branches: main
</code></pre>
<pre><code class="javascript">//app.js
let res = function()&#123;
    console.log(&quot;hello word&quot;)
&#125;
res()
</code></pre>
<h3 id="三、推送到远程仓库"><a href="#三、推送到远程仓库" class="headerlink" title="三、推送到远程仓库"></a>三、推送到远程仓库</h3><pre><code class="ini">git add . 
git commit -m &quot;xxxx&quot;
git push 仓库地址 //推送远程仓库
</code></pre>
<p><img src="/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/image-20221116105715577.png"></p>
<h3 id="四、查看构建结果"><a href="#四、查看构建结果" class="headerlink" title="四、查看构建结果"></a>四、查看构建结果</h3><p>构建成功</p>
<p><img src="/2022/11/16/Drone-UI%E6%8C%82%E8%B5%B7/image-20221116105812556.png"></p>
<p>我们CI持续集成构建就成功了，我们可以去继续丰富我们配置文件，直到达到我们想要的结果</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Drone入门]: 	“<a target="_blank" rel="noopener" href="https://0-8-0.docs.drone.io/zh/getting-started/">https://0-8-0.docs.drone.io/zh/getting-started/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CI/" rel="tag">CI</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-宝塔Linux部署"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/"
    >宝塔Linux部署</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/" class="article-date">
  <time datetime="2022-11-15T05:29:18.000Z" itemprop="datePublished">2022-11-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CI-CD/">CI/CD</a> / <a class="article-category-link" href="/categories/CI-CD/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/">宝塔Linux部署</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="宝塔Linux部署"><a href="#宝塔Linux部署" class="headerlink" title="宝塔Linux部署"></a>宝塔Linux部署</h1><h3 id="一、购买云服务器"><a href="#一、购买云服务器" class="headerlink" title="一、购买云服务器"></a>一、购买云服务器</h3><p>[阿里云官网]: 	“<a target="_blank" rel="noopener" href="https://cn.aliyun.com/?from_alibabacloud=&amp;utm_content=se_1013083955">https://cn.aliyun.com/?from_alibabacloud=&amp;utm_content=se_1013083955</a> “</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100233843.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100305806.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100353042.png"></p>
<p>当我购买了云服务器，那我们就可以登陆我们的服务器去下载mac的宝塔面板（通过外网地址访问浏览器）</p>
<h3 id="二、登陆云服务器"><a href="#二、登陆云服务器" class="headerlink" title="二、登陆云服务器"></a>二、登陆云服务器</h3><p>初始化（重置）实例密码</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101533088.png"></p>
<p>输入Password密码和实例密码</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100757824.png"></p>
<h3 id="三、安装宝塔"><a href="#三、安装宝塔" class="headerlink" title="三、安装宝塔"></a>三、安装宝塔</h3><p>然后可以看到已经进了服务器，那么我们就可以开始安装了</p>
<pre><code class="php">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh fa1f2600
</code></pre>
<p>稍等片刻后，输入“y”继续</p>
<p>下载成功之后，就会出现账户和密码和访问地址</p>
<p>我们通过外网面板地址访问</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101323474.png"></p>
<p>如果现在无法访问的话，就去阿里云服务器实例安全组添加提示端口</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101750883.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101826756.png"></p>
<p>现在应该可以访问了，如果还不行就添加8888端口</p>
<h3 id="四、配置宝塔"><a href="#四、配置宝塔" class="headerlink" title="四、配置宝塔"></a>四、配置宝塔</h3><p>当我们访问成功，根据提示安装宝塔面板所需要的创建就可以了</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102042938.png"></p>
<p>如果我们下载插件时间过长，重启宝塔面板</p>
<h3 id="五、创建站点"><a href="#五、创建站点" class="headerlink" title="五、创建站点"></a>五、创建站点</h3><p>我们来创建我们第一个站点</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102605290.png"></p>
<p>提交的时候我们可能遇见下面的提示，配置错误</p>
<pre><code class="ini">nginx: [emerg] open() &quot;/www/server/nginx/conf/enable-php.conf&quot; failed (2: No such file or directory) in /www/server/nginx/conf/nginx.conf:79 nginx: configuration file /www/server/nginx/conf/nginx.conf test failed
</code></pre>
<p>有一个最简单的方案就是，替换nginx 的版本，换一个更低一点的版本</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102833852.png"></p>
<p>重启宝塔面板就可以了</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102931757.png"></p>
<h3 id="六、上传站点部署文件"><a href="#六、上传站点部署文件" class="headerlink" title="六、上传站点部署文件"></a>六、上传站点部署文件</h3><p>选择要上传文件的站点</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115103700868.png"></p>
<p>选择要上传的文件，可以拖拽</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115103850298.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115104445278.png"></p>
<p>那么我们现在访问网站就可以了</p>
<p>如果还是访问不到的话（阿里云购买的域名），建议先进行备案，然后再部署网站</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115132138765.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CD/" rel="tag">CD</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Dokcer部署Drone2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/"
    >Dokcer部署Drone2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/" class="article-date">
  <time datetime="2022-11-14T03:43:51.000Z" itemprop="datePublished">2022-11-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CI-CD/">CI/CD</a> / <a class="article-category-link" href="/categories/CI-CD/Dokcer%E9%83%A8%E7%BD%B2Drone2/">Dokcer部署Drone2</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Dokcer部署Drone2"><a href="#Dokcer部署Drone2" class="headerlink" title="Dokcer部署Drone2"></a>Dokcer部署Drone2</h1><p>这一篇延续上一篇的问题，这一篇解决仓库初始化失败（500）的问题</p>
<h3 id="一、问题原因"><a href="#一、问题原因" class="headerlink" title="一、问题原因"></a>一、问题原因</h3><p>问题在于 drone 创建 webhooks 时失败，Github 不允许创建本地 localhost 类型的 webhooks，因为这样执行时是在本地，没办法定位到具体的用户主机。可以使用 <a href="https://link.juejin.cn/?target=https://ngrok.com">ngrok</a> 这样的工具把本地服务绑定到公网。</p>
<h3 id="二、解决问题"><a href="#二、解决问题" class="headerlink" title="二、解决问题"></a>二、解决问题</h3><h4 id="1-安装ngrok"><a href="#1-安装ngrok" class="headerlink" title="1.安装ngrok"></a>1.安装ngrok</h4><p>安装ngrok的时候，mac用户默认下载的位置和终端的位置不一样，所以我们统一安装到 &#x2F;usr&#x2F;local&#x2F;bin 目录</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114110814408.png"></p>
<p>具体步骤是：</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111042057.png" alt="步骤一：解压缩文件后复制ngrok"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111257463.png" alt="步骤二：前往文件夹"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111332755.png"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111355186.png" alt="步骤三：复制ngrok，双击执行"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111451022.png" alt="进程完成"></p>
<h4 id="2-连接服务"><a href="#2-连接服务" class="headerlink" title="2.连接服务"></a>2.连接服务</h4><p>执行ngrok的密钥，连接服务</p>
<pre><code class="ini">ngrok config add-authtoken 2HW491ApRpQILMM3kwW_4T7x8zVrAXpqUEjdSGU4y
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111554074.png"></p>
<p>当出现下面的情况，就说明安装成功了，就可以使用命令了</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111712382.png"></p>
<p>如果提示没有验证邮箱，就先去验证邮箱，要不然服务会中断</p>
<h4 id="3-开启服务端口"><a href="#3-开启服务端口" class="headerlink" title="3.开启服务端口"></a>3.开启服务端口</h4><pre><code class="ini">ngrok http 80
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111950182.png"></p>
<h4 id="4-修改Drone配置（github）"><a href="#4-修改Drone配置（github）" class="headerlink" title="4.修改Drone配置（github）"></a>4.修改Drone配置（github）</h4><pre><code class="ini">#Homepage URL
https://8313-183-202-88-243.ap.ngrok.io
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114112053258.png"></p>
<p>5.修改docker-compose.yml 和 .env 文件</p>
<pre><code class="ini">vim docker-compose.yml  //配置文件
vim .env
</code></pre>
<pre><code class="javascript">//docker-compose.yml
version: &#39;3.7&#39;

services:

  drone-server:
    image: drone/drone:2.3.1
    ports:
      - 80:80
    volumes:
      - drone-data:/data:rw
      - ./ssl:/etc/certs
    restart: always
    environment:
      - DRONE_SERVER_HOST=$&#123;DRONE_SERVER_HOST:-https://drone.yeasy.com&#125;
      - DRONE_SERVER_PROTO=$&#123;DRONE_SERVER_PROTO:-https&#125;
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_GITHUB_SERVER=https://github.com
      - DRONE_GITHUB_CLIENT_ID=$&#123;DRONE_GITHUB_CLIENT_ID&#125;
      - DRONE_GITHUB_CLIENT_SECRET=$&#123;DRONE_GITHUB_CLIENT_SECRET&#125;

  drone-runner:
    image: drone/drone-runner-docker:1
    restart: always
    depends_on:
      - drone-server
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:rw
    environment:
      - DRONE_RPC_PROTO=http
      - DRONE_RPC_HOST=drone-server
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_RUNNER_NAME=$&#123;HOSTNAME:-demo&#125;
      - DRONE_RUNNER_CAPACITY=2
    dns: 114.114.114.114

volumes:
  drone-data:
</code></pre>
<pre><code class="ini">//.env
# 必填 服务器地址，例如 drone.domain.com
DRONE_SERVER_HOST=8313-183-202-88-243.ap.ngrok.io
DRONE_SERVER_PROTO=https
DRONE_RPC_SECRET=24c08d3d73e59c5d9dd5e26e3256c1f9
HOSTNAME=demo
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_ID=
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_SECRET=
</code></pre>
<h4 id="5-重启Drone"><a href="#5-重启Drone" class="headerlink" title="5.重启Drone"></a>5.重启Drone</h4><pre><code class="ini">docker-compose up -d
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114112748311.png"></p>
<p>这样我们就解决了500的问题，github上的Webhooks就启动了</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114113100300.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CI/" rel="tag">CI</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Docker部署Drone"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/"
    >Docker部署Drone</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/" class="article-date">
  <time datetime="2022-11-13T11:43:16.000Z" itemprop="datePublished">2022-11-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CI-CD/">CI/CD</a> / <a class="article-category-link" href="/categories/CI-CD/Docker%E9%83%A8%E7%BD%B2Drone/">Docker部署Drone</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Docker部署Drone"><a href="#Docker部署Drone" class="headerlink" title="Docker部署Drone"></a>Docker部署Drone</h1><h3 id="一、新建-GitHub-应用"><a href="#一、新建-GitHub-应用" class="headerlink" title="一、新建 GitHub 应用"></a>一、新建 GitHub 应用</h3><p>具体顺序Settings-&gt;Developer settings-&gt;OAuth Apps-&gt;New OAuth App</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155624239.png"></p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155447805.png" alt="image-20221113155447805"></p>
<p>新建完成后记住Client ID和Client secrets，后面配置需要</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155825926.png"></p>
<h3 id="二、下载drone"><a href="#二、下载drone" class="headerlink" title="二、下载drone"></a>二、下载drone</h3><pre><code class="ini">docker pull drone/drone //下载drone
</code></pre>
<h3 id="三、配置-Drone"><a href="#三、配置-Drone" class="headerlink" title="三、配置 Drone"></a>三、配置 Drone</h3><p>通过使用 <code>Docker Compose</code> 来启动 <code>Drone</code>，编写 <code>docker-compose.yml</code> 文件（这个文件直接新建就可以了）</p>
<pre><code class="ini">touch docker-compose.yml //新建文件
vim docker-compose.yml  //配置文件
</code></pre>
<pre><code class="javascript">//docker-compose.yml 文件不用修改
version: &#39;3&#39;

services:

  drone-server:
    image: drone/drone:2.3.1
    ports:
      - 443:443
      - 80:80
    volumes:
      - drone-data:/data:rw
      - ./ssl:/etc/certs
    restart: always
    environment:
      - DRONE_SERVER_HOST=$&#123;DRONE_SERVER_HOST:-https://drone.yeasy.com&#125;
      - DRONE_SERVER_PROTO=$&#123;DRONE_SERVER_PROTO:-https&#125;
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_GITHUB_SERVER=https://github.com
      - DRONE_GITHUB_CLIENT_ID=$&#123;DRONE_GITHUB_CLIENT_ID&#125;
      - DRONE_GITHUB_CLIENT_SECRET=$&#123;DRONE_GITHUB_CLIENT_SECRET&#125;

  drone-agent:
    image: drone/drone-runner-docker:1
    restart: always
    depends_on:
      - drone-server
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:rw
    environment:
      - DRONE_RPC_PROTO=http
      - DRONE_RPC_HOST=drone-server
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_RUNNER_NAME=$&#123;HOSTNAME:-demo&#125;
      - DRONE_RUNNER_CAPACITY=2
    dns: 114.114.114.114

volumes:
  drone-data:
</code></pre>
<p>新建 <code>.env</code> 文件，输入变量及其值（上面docker-compose.yml文件配置会默认读取 .env 文件变量）</p>
<pre><code class="ini">touch .env //新建文件
</code></pre>
<pre><code class="ini">//.env
# 必填 服务器地址，例如 drone.domain.com
DRONE_SERVER_HOST=
DRONE_SERVER_PROTO=https
DRONE_RPC_SECRET=secret
HOSTNAME=demo
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_ID=
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_SECRET=
</code></pre>
<pre><code class="ini">#我的配置（参考）
# 必填 服务器地址，例如 drone.domain.com
DRONE_SERVER_HOST=localhost
DRONE_SERVER_PROTO=http
DRONE_RPC_SECRET=secret
HOSTNAME=demo
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_ID=
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_SECRET=
</code></pre>
<h3 id="四、启动Drone"><a href="#四、启动Drone" class="headerlink" title="四、启动Drone"></a>四、启动Drone</h3><pre><code class="ini">docker-compose up -d
</code></pre>
<p>访问http:localhost:80（我配置的，你和我配置一样就可以打开）就成功了</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113161124001.png"></p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155240845-8325994.png"></p>
<p>等到验证完成就可以了（如果出现错误，关机重启，重新配置就可以了）</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113165243948.png"></p>
<h3 id="五、激活仓库-具体看下一篇"><a href="#五、激活仓库-具体看下一篇" class="headerlink" title="五、激活仓库(具体看下一篇)"></a>五、激活仓库(具体看下一篇)</h3><p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113171114692.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/drone-ci/" rel="tag">drone ci</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-搭建私有的npm仓库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/"
    >搭建私有的npm仓库</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/" class="article-date">
  <time datetime="2022-11-12T05:05:31.000Z" itemprop="datePublished">2022-11-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/npm-yarn/">npm&yarn</a> / <a class="article-category-link" href="/categories/npm-yarn/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/">搭建私有的npm仓库</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="使用docker和verdaccio搭建npm私有库"><a href="#使用docker和verdaccio搭建npm私有库" class="headerlink" title="使用docker和verdaccio搭建npm私有库"></a>使用docker和verdaccio搭建npm私有库</h1><p>本文章docker环境为macos</p>
<h3 id="1-使用-docker-镜像安装verdaccio"><a href="#1-使用-docker-镜像安装verdaccio" class="headerlink" title="1.使用 docker 镜像安装verdaccio"></a>1.使用 docker 镜像安装verdaccio</h3><pre><code class="ini">docker pull verdaccio/verdaccio //安装verdaccio镜像
</code></pre>
<h3 id="2-启动端口映射verdaccio容器"><a href="#2-启动端口映射verdaccio容器" class="headerlink" title="2.启动端口映射verdaccio容器"></a>2.启动端口映射verdaccio容器</h3><pre><code class="ini">docker run -it --name verdaccio -p 4873:4873 verdaccio/verdaccio //运行 verdaccio，使用 docker 命令运行镜像，创建 verdaccio 容器 ，端口4873
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095140709.png"></p>
<h3 id="3-私有部署npm仓库成功"><a href="#3-私有部署npm仓库成功" class="headerlink" title="3.私有部署npm仓库成功"></a>3.私有部署npm仓库成功</h3><p>访问<a target="_blank" rel="noopener" href="http://localhost:4873/">http://localhost:4873/</a></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095258155.png"></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095230480.png"></p>
<h3 id="4-添加权限用户"><a href="#4-添加权限用户" class="headerlink" title="4.添加权限用户"></a>4.添加权限用户</h3><pre><code class="ini">npm adduser --registry http://localhost:4873/ //根据提示添加用户
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095338495.png"></p>
<h3 id="5-登陆"><a href="#5-登陆" class="headerlink" title="5.登陆"></a>5.登陆</h3><p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095621194.png"></p>
<h3 id="6-发布npm包"><a href="#6-发布npm包" class="headerlink" title="6.发布npm包"></a>6.发布npm包</h3><p>当我们的私有仓库搭建好之后，那么我们就可以向仓库发布npm包了，到我们npm包目录下上传就可以了</p>
<pre><code class="css">1.创建npm-me包目录
2.npm init 初始化目录
3.编写功能文件
4.如果是改版发布，更新版本号
5.登陆私有仓库
6.向私有仓库发布npm包
</code></pre>
<pre><code class="javascript">//ifYes.js
exports.ifYes = function() &#123;
    return &quot;If you&#39;re late, your wages will be docked version new（registry）&quot;
&#125;
</code></pre>
<pre><code class="json">//package.json
&#123;
  &quot;name&quot;: &quot;alan-npm-me&quot;,
  &quot;version&quot;: &quot;1.0.3&quot;,
  &quot;description&quot;: &quot;If you&#39;re late, your wages will be docked&quot;,
  &quot;main&quot;: &quot;ifYes.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [
    &quot;ifYes&quot;
  ],
  &quot;author&quot;: &quot;alan_mf&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<pre><code class="ini">npm version patch  //补丁版本更新
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112101529827.png"></p>
<pre><code class="ini">npm-me % npm publish --registry http://localhost:4873/ //发布
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112102102928.png"></p>
<p>这时候刷新我们的私有仓库页面就可以看到了<a target="_blank" rel="noopener" href="http://localhost:4873/">http://localhost:4873/</a></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112102228314.png"></p>
<h3 id="7-下载私有仓库的包"><a href="#7-下载私有仓库的包" class="headerlink" title="7.下载私有仓库的包"></a>7.下载私有仓库的包</h3><pre><code class="css">1.创建一个文件目录
2.初始化 npm init -y
3.编辑测试代码
4. npm install --registry http://localhost:4873 alan-npm-me //下载私有仓库npm包
5.执行测试代码
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112105324344.png"></p>
<h3 id="8-修改verdaccio权限"><a href="#8-修改verdaccio权限" class="headerlink" title="8.修改verdaccio权限"></a>8.修改verdaccio权限</h3><p>因为我是docker安装的verdaccio，所以查找配置文件路径是这样的</p>
<pre><code class="ini">1. docker exec --user root -it verdaccio sh
2. cd /verdaccio
3. cd conf
4. vi config.yaml
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112125337815.png"></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112125352787.png"></p>
<p>里面就可以配置你们的文件了，重启容器就生效了</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>