<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>前端面试大全Vue-Vue3 |  艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-前端面试大全Vue-Vue3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  前端面试大全Vue-Vue3
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8Vue-Vue3/" class="article-date">
  <time datetime="2022-10-28T03:50:56.000Z" itemprop="datePublished">2022-10-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/Vue-Vue3/">Vue-Vue3</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">19.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">75 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（Vue-Vue3）"><a href="#前端面试题大全（Vue-Vue3）" class="headerlink" title="前端面试题大全（Vue + Vue3）"></a>前端面试题大全（Vue + Vue3）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="Vue-Vue3"><a href="#Vue-Vue3" class="headerlink" title="Vue + Vue3"></a>Vue + Vue3</h2><h3 id="♥︎♥︎vue-router-3-1-0新增的v-slot属性怎么用？"><a href="#♥︎♥︎vue-router-3-1-0新增的v-slot属性怎么用？" class="headerlink" title="♥︎♥︎vue-router 3.1.0新增的v-slot属性怎么用？"></a>♥︎♥︎vue-router 3.1.0新增的v-slot属性怎么用？</h3><p>router-link 通过一个作用域插槽暴露底层的定制能力。这是一个更高阶的 API，主要面向库作者，但也可以为开发者提供便利，多数情况用在一个类似 NavLink 这样的自定义组件里。</p>
<p>在使用 v-slot API 时，需要向 router-link 传入一个单独的子元素。否则 router-link 将会把子元素包裹在一个 span 元素内。</p>
<h3 id="♥︎♥︎说一下-root，-parent，-refs"><a href="#♥︎♥︎说一下-root，-parent，-refs" class="headerlink" title="♥︎♥︎说一下$root，$parent，$refs"></a>♥︎♥︎说一下$root，$parent，$refs</h3><p>$root，和$parent都能访问父组件的属性和方法，区别在于如果存在多级子组件，通过parent 访问得到的是它最近一级的父组件，通过root 访问得到的是根父组件。</p>
<p>通过在子组件标签定义 ref 属性，在父组件中可以使用$refs 访问子组件实例。</p>
<h3 id="♥︎♥︎对比-jQuery，Vue-有什么不同"><a href="#♥︎♥︎对比-jQuery，Vue-有什么不同" class="headerlink" title="♥︎♥︎对比 jQuery，Vue 有什么不同"></a>♥︎♥︎对比 jQuery，Vue 有什么不同</h3><p>jQuery 专注视图层，通过直接操作 DOM 去实现页面的一些逻辑渲染；</p>
<p>Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作。</p>
<p>Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发</p>
<h3 id="♥︎♥︎-Vue中如何实现子组件内的css样式名在项目中绝对唯一性"><a href="#♥︎♥︎-Vue中如何实现子组件内的css样式名在项目中绝对唯一性" class="headerlink" title="♥︎♥︎ Vue中如何实现子组件内的css样式名在项目中绝对唯一性"></a>♥︎♥︎ Vue中如何实现子组件内的css样式名在项目中绝对唯一性</h3><p>在style标签上加上scoped属性</p>
<h3 id="♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？"><a href="#♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？" class="headerlink" title="♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？"></a>♥︎♥︎v-model是什么？Vue中标签怎么绑定事件？</h3><p>v-model是一个语法糖，这一个指令可以分为几个指令，它内部已经帮我们处理整合了。对于普通的文本框来说，v-model &#x3D; v-bind:value + @input。对单选框和复选框来说，v-model &#x3D; v-bind:checked +@change，并且它还有一个非常重要的功能，就是解决父子组件之间的通讯问题，可以提升我们的开发效率。在vue中通过使用&lt;v-on:事件名 &#x3D; 函数名&gt;的方式来绑定事件。</p>
<h3 id="♥︎♥︎Vue生命周期通常使用哪些"><a href="#♥︎♥︎Vue生命周期通常使用哪些" class="headerlink" title="♥︎♥︎Vue生命周期通常使用哪些"></a>♥︎♥︎Vue生命周期通常使用哪些</h3><p>常用的生命周期有，beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed</p>
<h3 id="♥︎♥︎Vue深层次的组件怎么和父组件通讯"><a href="#♥︎♥︎Vue深层次的组件怎么和父组件通讯" class="headerlink" title="♥︎♥︎Vue深层次的组件怎么和父组件通讯"></a>♥︎♥︎Vue深层次的组件怎么和父组件通讯</h3><p>使用$attrs和$listeners</p>
<pre><code class="vue">//C
Vue.component(&#39;C&#39;, &#123;
 template: &lt;div&gt; &lt;p&gt;我是C组件&lt;/p&gt; &lt;input type=&#39;text&#39; v-model=&#39;$attrs.msgc&#39; @input=&#39;$emit(&quot;getC&quot;, $attrs.msgc)&#39; /&gt; &lt;/div&gt;
&#125;)

//B
Vue.component(&#39;B&#39;, &#123;
 /**
 给C组件绑定$attrs属性和$listeners事件，C组件可以直接获取到A组件中传递下来的props（除了B组
件中props声明的）
 */
 template: &lt;div&gt; &lt;p&gt;我是B组件&lt;/p&gt; &lt;input type=&#39;text&#39; v-model=&#39;mymsg1&#39; @input=&quot;$emit(&#39;getChild&#39;, mymsg1)&quot; /&gt;&lt;C v-bind=&#39;$attrs&#39; v-on=&#39;$listeners&#39;/&gt; &lt;/div&gt; ,
 props: [&#39;msg1&#39;],
 data () &#123;
 return &#123;
 mymsg1: this.msg1
 &#125;
 &#125;
&#125;)

Vue.component(&#39;A&#39;, &#123;
 template: &lt;div id=&#39;app&#39;&gt; &lt;p&gt;我是A组件&lt;/p&gt; &lt;B:msg1=&#39;msg1&#39; :msgc=&#39;msgc&#39; @getChild=&#39;getChild&#39; @getC=&#39;getC&#39; /&gt; &lt;/div&gt; ,
 data () &#123;
 return &#123;
 msg1: &#39;A&#39;,
 msgc: &#39;hello c!&#39;
 &#125;
 &#125;,
 methods: &#123;
 getChild (val) &#123;
 console.log( val )
 &#125;,
 getC (val) &#123;
 console.log( val )
 &#125;
 &#125;
&#125;)
const app = new Vue(&#123;
 el: &#39;#app&#39;,
 template: &lt;A /&gt;
&#125;)
</code></pre>
<hr>
<h3 id="♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？"><a href="#♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？" class="headerlink" title="♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？"></a>♥︎♥︎♥︎如何再Vue的单文件组件里的样式定义全局CSS？</h3><p>在style标签上不加上scoped的属性，默认为全局css样式</p>
<h3 id="♥︎♥︎♥︎如何实现一个路径渲染多个组件？"><a href="#♥︎♥︎♥︎如何实现一个路径渲染多个组件？" class="headerlink" title="♥︎♥︎♥︎如何实现一个路径渲染多个组件？"></a>♥︎♥︎♥︎如何实现一个路径渲染多个组件？</h3><p>可以通过命名视图(router-view)，它容许同一界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。通过设置components即可同时渲染多个组件。</p>
<h3 id="♥︎♥︎♥︎-如何实现多个路径共享一个组件？"><a href="#♥︎♥︎♥︎-如何实现多个路径共享一个组件？" class="headerlink" title="♥︎♥︎♥︎ 如何实现多个路径共享一个组件？"></a>♥︎♥︎♥︎ 如何实现多个路径共享一个组件？</h3><p>只需将多个路径的component字段的值设置为同一个组件即可。</p>
<h3 id="♥︎♥︎♥︎如何监测动态路由的变化"><a href="#♥︎♥︎♥︎如何监测动态路由的变化" class="headerlink" title="♥︎♥︎♥︎如何监测动态路由的变化"></a>♥︎♥︎♥︎如何监测动态路由的变化</h3><p>可以通过watch方法来对$route进行监听，或者通过导航守卫的钩子函数beforeRouteUpdate来监听它的变化。</p>
<h3 id="♥︎♥︎♥︎对MVC，MVP，MVVM的理解"><a href="#♥︎♥︎♥︎对MVC，MVP，MVVM的理解" class="headerlink" title="♥︎♥︎♥︎对MVC，MVP，MVVM的理解"></a>♥︎♥︎♥︎对MVC，MVP，MVVM的理解</h3><p>mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。</p>
<p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。</p>
<p>1：Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>
<p>2：在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>
<p>3：ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<p>MVP与MVC很接近，P指的是Presenter，presenter可以理解为一个中间人，它负责着View和Model之间的数据流动，防止View和Model之间直接交流。</p>
<p><img src="/2022/10/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8Vue-Vue3/2021022520492697.png" alt="MVP"></p>
<p>presenter负责和Model进行双向交互，还和View进行双向交互。这种交互方式，相对于MVC来说少了一些灵活，Vlew变成了被动视图，并且本身变得很小。虽然它分离了View和Model。但是presenter除了要做事件监听，还要更新DOM等各种事情，应用逐渐变大之后，导致presenter的体积增大，难以维护。</p>
<h3 id="♥︎♥︎♥︎什么情况下使用-Vuex"><a href="#♥︎♥︎♥︎什么情况下使用-Vuex" class="headerlink" title="♥︎♥︎♥︎什么情况下使用 Vuex"></a>♥︎♥︎♥︎<strong>什么情况下使用</strong> Vuex</h3><p>如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可，需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态</p>
<h3 id="♥︎♥︎♥︎Vuex可以直接修改state的值吗？"><a href="#♥︎♥︎♥︎Vuex可以直接修改state的值吗？" class="headerlink" title="♥︎♥︎♥︎Vuex可以直接修改state的值吗？"></a>♥︎♥︎♥︎Vuex可以直接修改state的值吗？</h3><p>可以直接修改，但是极其不推荐，state的修改必须在mutation来修改，否则无法被devtool所监测，无法监测数据的来源，无法保存状态快照，也就无法实现时间漫游&#x2F;回滚之类的操作。</p>
<h3 id="♥︎♥︎♥︎v-model和vuex有冲突吗？"><a href="#♥︎♥︎♥︎v-model和vuex有冲突吗？" class="headerlink" title="♥︎♥︎♥︎v-model和vuex有冲突吗？"></a>♥︎♥︎♥︎v-model和vuex有冲突吗？</h3><p>当我们v-model的数据是存储在vuex中时写法如下时会报错</p>
<pre><code class="javascript">computed:&#123;
  editableTabsValue2:&#123;
     return this.$store.state.activeName
  &#125;
&#125;
</code></pre>
<p>报错：Computed property  “editableTabsValue2”  was assigned  to but  it has no  setter</p>
<p>原因：v-model是双向数据绑定 vue实例的data改变或者用户输入的改变都会触发视图更新。vuex是一个状态的存储，对于里面的状态的改变都是通过commit mutation 所以当用户输入直接修改editableTabsValue2,又不是通过commit更改状态时会报错</p>
<p>解决方法:</p>
<pre><code class="javascript">computed:&#123;
  editableTabsValue2:&#123;
    get:function () &#123;
      return this.$store.state.activeName
    &#125;,
    set:function () &#123;
    &#125;
  &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎解释单向数据流和双向数据绑定"><a href="#♥︎♥︎♥︎解释单向数据流和双向数据绑定" class="headerlink" title="♥︎♥︎♥︎解释单向数据流和双向数据绑定"></a>♥︎♥︎♥︎解释单向数据流和双向数据绑定</h3><p>对于 Vue 来说，组件之间的数据传递具有单向数据流这样的特性称为单向数据流，单向数据流（Unidirectional data flow）方式使用一个上传数据流和一个下传数据流进行双向数据通信，两个数据流之间相互独立，单向数据流指只能从一个方向来修改状态。</p>
<p>而双向数据绑定即为当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化，两个数据流之间互为影响。</p>
<h3 id="♥︎♥︎♥︎-route和-router的区别"><a href="#♥︎♥︎♥︎-route和-router的区别" class="headerlink" title="♥︎♥︎♥︎$route和 $router的区别"></a>♥︎♥︎♥︎$route和 $router的区别</h3><p>$route用来获取路由的信息的，它是路由信息的一个对象，里面包含路由的一些基本信息，包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom等。</p>
<p>而$router主要是用来操作路由的，它是VueRouter的实例，包含了一些路由的跳转方法，钩子函数等</p>
<h3 id="♥︎♥︎♥︎Vue-中怎么自定义指令"><a href="#♥︎♥︎♥︎Vue-中怎么自定义指令" class="headerlink" title="♥︎♥︎♥︎Vue 中怎么自定义指令"></a>♥︎♥︎♥︎Vue <strong>中怎么自定义指令</strong></h3><p>通过directive来自定义指令，自定义指令分为全局指令和局部指令，自定义指令也有几个的钩子函数，常用的有bind和update，当 bind 和 update 时触发相同行为，而不关心其它的钩子时可以简写。一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右。</p>
<h3 id="♥︎♥︎♥︎Vue中怎么自定义过滤器"><a href="#♥︎♥︎♥︎Vue中怎么自定义过滤器" class="headerlink" title="♥︎♥︎♥︎Vue中怎么自定义过滤器"></a>♥︎♥︎♥︎Vue中怎么自定义过滤器</h3><p>通过filter来定义过滤器，过滤器分为全局和局部过滤器，过滤器的主体为一个普通的函数，来对数据进行处理，可以传递参数。当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用。</p>
<h3 id="♥︎♥︎♥︎Vue等单页面应用的优缺点"><a href="#♥︎♥︎♥︎Vue等单页面应用的优缺点" class="headerlink" title="♥︎♥︎♥︎Vue等单页面应用的优缺点"></a>♥︎♥︎♥︎Vue等单页面应用的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、单页应用的内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。</p>
<p>2、单页应用没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象</p>
<p>3、单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提</p>
<p>高几倍。</p>
<p>4、良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代</p>
<p>码，不用修改就可以用于Web界面、手机、平板等多种客户端。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1、首次加载耗时比较多。</p>
<p>2、SEO问题，不利于百度，360等搜索引擎收录。</p>
<p>3、容易造成Css命名冲突。</p>
<p>4、前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开</p>
<p>发成本高。</p>
<h3 id="♥︎♥︎♥︎Vue-router使用params与query传参有什么区别"><a href="#♥︎♥︎♥︎Vue-router使用params与query传参有什么区别" class="headerlink" title="♥︎♥︎♥︎Vue-router使用params与query传参有什么区别"></a>♥︎♥︎♥︎Vue-router使用params与query传参有什么区别</h3><p>&#x2F;&#x2F; 用法上</p>
<p>query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和this.$route.params.name。</p>
<p>&#x2F;&#x2F; 展示上</p>
<p>1：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p>
<p>2：params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。</p>
<p>3：params、query不设置也可以传参，params不设置的时候，刷新页面或者返回参数会丢失</p>
<h3 id="♥︎♥︎♥︎Vue中keep-alive的作用"><a href="#♥︎♥︎♥︎Vue中keep-alive的作用" class="headerlink" title="♥︎♥︎♥︎Vue中keep-alive的作用"></a>♥︎♥︎♥︎Vue中keep-alive的作用</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。一旦使用keepalive包裹组件，此时mouted，created等钩子函数只会在第一次进入组件时调用，当再次切换回来时将不会调用。此时如果我们还想在每次切换时做一些事情，就需要用到另外的周期函数，actived和deactived，这两个钩子函数只有被keepalive包裹后才会调用。</p>
<h3 id="♥︎♥︎♥︎Vue如何实现单页面应用"><a href="#♥︎♥︎♥︎Vue如何实现单页面应用" class="headerlink" title="♥︎♥︎♥︎Vue如何实现单页面应用"></a>♥︎♥︎♥︎Vue如何实现单页面应用</h3><p>通常的url 地址由以下内容构成：协议名 域名 端口号 路径 参数 哈希值，当哈希值改变，页面不会发生跳转，单页面应用就是利用了这一点，给window注册onhashchange事件，当哈希值改变时通过location.hash就能获得相应的哈希值，然后就能跳到相应的页面。</p>
<h3 id="♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？"><a href="#♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？" class="headerlink" title="♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？"></a>♥︎♥︎♥︎说出至少4种Vue当中的指令和它的用法？</h3><pre><code class="css">v-if(判断是否隐藏，用来判断元素是否创建)
v-show(元素的显示隐藏，类似css中的display的block和hidden)
v-for(把数据遍历出来)
v-bind(绑定属性)
v-model(实现双向绑定)
</code></pre>
<h3 id="♥︎♥︎♥︎-Vuex是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#♥︎♥︎♥︎-Vuex是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="♥︎♥︎♥︎ Vuex是什么？怎么使用？描述使用它实现登录功能的流程？"></a>♥︎♥︎♥︎ Vuex是什么？怎么使用？描述使用它实现登录功能的流程？</h3><p>Vuex是一个专为Vue.js应用程序开发的状态管理模式；它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex可以管理复杂应用的数据状态，比如兄弟组件的通信、多层嵌套的组件的传值等等。</p>
<p>如何使用</p>
<pre><code class="css">1.安装vuex
按照官网给出的步骤
npm install vuex --save  //安装vuex

2.Vuex 依赖 Promise  浏览器支持promise的此步骤可省略
注意：Vuex 依赖 Promise (opens new window)。如果你支持的浏览器并没有实现 Promise (比如 IE)，那么你可以使用一个 polyfill 的库，例如 es6-promise (opens new window)。

你可以通过 CDN 将其引入：
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js&quot;&gt;
&lt;/script&gt;
然后 window.Promise 会自动可用。
如果你喜欢使用诸如 npm 或 Yarn 等包管理器，可以按照下列方式执行安装：
npm install es6-promise --save # npm
yarn add es6-promise # Yarn
或者更进一步，将下列代码添加到你使用 Vuex 之前的一个地方：
import &#39;es6-promise/auto&#39;

3.在项目引用
找到项目中的main.js文件，将内容引入
import store from &#39;./store&#39;
.use(store)
</code></pre>
<p>4.使用方法<br>    首先，在项目中找到store文件夹，如果没有就自己建一个文件夹，在文件夹内再新建一个js文件。</p>
<pre><code class="css">import &#123; createStore &#125; from &#39;vuex&#39;
 
export default createStore(&#123;
  state: &#123;  //数据存放的位置
        data:&#39;&#39;
  &#125;,
  mutations: &#123;//在mutations写方法更改state中的值
      data(state,data)&#123;
        state.data=data
   &#125;
  &#125;,
  actions: &#123;//通过actions触发mutations的方法
      dataone(context,data)&#123;
          context.commit(&#39;data&#39;,data);//带引号的data是mutation里的，第二个data，是页面上
                                      //传过来的参数
    &#125;
  &#125;,
  modules: &#123;
      
  &#125;
&#125;)
然后，将要保存的数据从页面传过来
这是页面：
import &#123;useStore&#125; from &#39;vuex&#39;
    export default&#123;
        setup()&#123;
            let A =124
            const store=useStore();
            store.dispatch(&#39;dataone&#39;,A)
              //括号内第一个参数为actions中的方法名,方法名不能与mutations中重复    
              //第二个为需要存储改变的值的变量
        &#125;
    &#125;
</code></pre>
<h3 id="♥︎♥︎♥︎Vue-loader解释一下"><a href="#♥︎♥︎♥︎Vue-loader解释一下" class="headerlink" title="♥︎♥︎♥︎Vue-loader解释一下"></a>♥︎♥︎♥︎Vue-loader解释一下</h3><p>解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。</p>
<h3 id="♥︎♥︎♥︎-用过插槽吗？用的是具名插槽还是匿名插槽"><a href="#♥︎♥︎♥︎-用过插槽吗？用的是具名插槽还是匿名插槽" class="headerlink" title="♥︎♥︎♥︎ 用过插槽吗？用的是具名插槽还是匿名插槽"></a>♥︎♥︎♥︎ 用过插槽吗？用的是具名插槽还是匿名插槽</h3><p>用过，都使用过。插槽相当于预留了一个位置，可以将我们书写在组件内的内容放入，写一个插槽就会将组件内的内容替换一次，两次则替换两次。为了自定义插槽的位置我们可以给插槽取名，它会根据插槽名来插入内容，一一对应。</p>
<h3 id="♥︎♥︎♥︎Vue路由守卫"><a href="#♥︎♥︎♥︎Vue路由守卫" class="headerlink" title="♥︎♥︎♥︎Vue路由守卫"></a>♥︎♥︎♥︎Vue路由守卫</h3><p>vue-router 提供的导航守卫主要用来对路由的跳转进行监控，控制它的跳转或取消，路由守卫有全局的,单个路由独享的, 或者组件级的。导航钩子有3个参数：</p>
<p>1、to:即将要进入的目标路由对象；</p>
<p>2、from:当前导航即将要离开的路由对象；</p>
<p>3、next ：调用该方法后，才能进入下一个钩子函数（afterEach）。</p>
<h3 id="♥︎♥︎♥︎请你说一下Vue中create和mount的区别"><a href="#♥︎♥︎♥︎请你说一下Vue中create和mount的区别" class="headerlink" title="♥︎♥︎♥︎请你说一下Vue中create和mount的区别"></a>♥︎♥︎♥︎请你说一下Vue中create和mount的区别</h3><p>create为组件初始化阶段，在此阶段主要完成数据观测(data observer)，属性和方法的运算，watch&#x2F;event 事件回调。</p>
<p>然而，挂载阶段还没开始，此时还未生成真实的DOM，也就无法获取和操作DOM元素。</p>
<p>而mount主要完成从虚拟DOM到真实DOM的转换挂载，此时html已经渲染出来了，所以可以直接操作dom节点。</p>
<h3 id="♥︎♥︎♥︎路由懒加载"><a href="#♥︎♥︎♥︎路由懒加载" class="headerlink" title="♥︎♥︎♥︎路由懒加载"></a>♥︎♥︎♥︎路由懒加载</h3><p>把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应的组件即为路由的懒加载，可以加快项目的加载速度，提高效率。通过这种格式来导入组件const foo &#x3D; () &#x3D;&gt;import(‘.&#x2F;foo.vue’);</p>
<h3 id="♥︎♥︎♥︎Vue中computed的原理"><a href="#♥︎♥︎♥︎Vue中computed的原理" class="headerlink" title="♥︎♥︎♥︎Vue中computed的原理"></a>♥︎♥︎♥︎Vue中computed的原理</h3><p>computed是vue中的计算属性，在依赖的值发生变化的时候进行重新计算，否则使用缓存。</p>
<p>前面说到computed只有在依赖发生变化才会重新计算，那么如何得知computed的值发生了变化呢</p>
<p>这主要是Watcher中的dirty属性，dirty属性为true时，说明computed中的值需要重新计算，dirty为false时，则说明依赖没有变化，不需要重新计算</p>
<p>当计算属性的值发生变化时，计算属性的watcher和组件的watcher都会得到通知。</p>
<p>计算属性的watcher会将dirty置为true,组件的Watcher得到通知，同样将dirty属性置为false,重新计算值，用于本次渲染。</p>
<p>简单来说,computed就是定义在vm上的一个getter属性，这个getter属性被触发时会做两件事</p>
<ol>
<li><p>计算当前属性的值，此时会使用Watcher去观察计算属性中用到的所有其他数据的变化。同时将计算属性的Watcher的dirty属性设置为false.</p>
</li>
<li><p>当计算属性中用到的数据发生变化时,将得到通知从而进行重新渲染</p>
</li>
</ol>
<p>Watcher中的depend和evaluate方法是专门用于实现计算属性的两个API</p>
<pre><code class="javascript">export default class Watcher &#123;
     constructor(vm, expOrFn, cb, options) &#123;
         if(options) &#123;
             this.lazy = !!options.lazy;
         &#125;  else &#123;
             this.lazy = false;
         &#125;
         this.dirty = this.lazy;
         this.value = this.lazy ? undefined : this.get()
     &#125;
     evaluate() &#123;
        this.value = this.get()
        this.dirty = false; 
    &#125;
    depend() &#123;
        let i = this.deps.length
        while(i--) &#123;
            this.deps[i].depend()
        &#125;
    &#125;
&#125;
</code></pre>
<p>执行depend方法可以将组件中的watcher实例添加到dep实例的依赖列表中。换句话说,this.deps是计算属性中用到的所有状态的dep实例,而依次执行了dep实例的depend方法就是将组件的watcher依次加入到这些dep实例的依赖列表。这就实现了让组件的watcher观察计算属性中用到的所有的状态的变化。</p>
<p>Computed逻辑变化</p>
<p>computed在vue2.5.2中的实现发生了一些变化,因为之前的computed的计算存在一些逻辑上的漏洞,因为只要依赖的值发生了变化,vue就认为值发生了变化，组件会重新走一遍渲染的流程，但实际上UI不会由变化，浪费了一些性能。</p>
<p>改动之后的逻辑：</p>
<p>组件的watcher不再监听计算属性的变化,而是让计算属性的watcher得到通知后,计算一次计算属性的值，如果发现这一次计算出来的值与上一次计算出来的值不一样，再去主动通知组件的watcher进行重新渲染。</p>
<h3 id="♥︎♥︎♥︎Vuex的缺点"><a href="#♥︎♥︎♥︎Vuex的缺点" class="headerlink" title="♥︎♥︎♥︎Vuex的缺点"></a>♥︎♥︎♥︎Vuex的缺点</h3><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的，并且state中的值会伴随着浏览器的刷新而初始化，无缓存。</p>
<h3 id="♥︎♥︎♥︎Vue路由传参，刷新后还有吗"><a href="#♥︎♥︎♥︎Vue路由传参，刷新后还有吗" class="headerlink" title="♥︎♥︎♥︎Vue路由传参，刷新后还有吗"></a>♥︎♥︎♥︎Vue路由传参，刷新后还有吗</h3><p>通过params传参会出现参数丢失的情况，可以通过query的传参方式或者在路由匹配规则加入占位符即可以解决参数丢失的情况。</p>
<h3 id="♥︎♥︎♥︎Vue组件如何引入使用"><a href="#♥︎♥︎♥︎Vue组件如何引入使用" class="headerlink" title="♥︎♥︎♥︎Vue组件如何引入使用"></a>♥︎♥︎♥︎Vue组件如何引入使用</h3><ol>
<li><p>定义组件并抛出</p>
</li>
<li><p>import引入，并在component里面定义</p>
</li>
<li><p>使用组件（注意首字母大写）</p>
</li>
</ol>
<h3 id="♥︎♥︎♥︎-Vue-forceUpdate的原理"><a href="#♥︎♥︎♥︎-Vue-forceUpdate的原理" class="headerlink" title="♥︎♥︎♥︎ Vue $forceUpdate的原理"></a>♥︎♥︎♥︎ Vue $forceUpdate的原理</h3><p>1、作用：</p>
<p>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
<p>2、内部原理：</p>
<pre><code class="javascript">Vue.prototype.$forceUpdate = function () &#123;
 const vm: Component = this
 if (vm.watcher) &#123;
 vm.watcher.update()
 &#125;
&#125;
</code></pre>
<p>实例需要重新渲染是在依赖发生变化的时候会通知watcher，然后通知watcher来调用update方法，就是这么简单。</p>
<h3 id="♥︎♥︎♥︎v-for-key"><a href="#♥︎♥︎♥︎v-for-key" class="headerlink" title="♥︎♥︎♥︎v-for key"></a>♥︎♥︎♥︎v-for key</h3><p>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</p>
<p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p>
<p>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. </p>
<p>快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1)</p>
<p>建议使用id，不建议使用索引</p>
<h3 id="♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？"><a href="#♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？" class="headerlink" title="♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？"></a>♥︎♥︎♥︎为什么要设置key值，可以用index吗？为什么不能？</h3><p>虚拟DOM中key的作用：<br>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,<br>随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
<p>对比规则：<br>(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。<br>(2).旧虚拟DOM中未找到与新虚拟DOM相同的key<br>创建新的真实DOM，随后渲染到到页面。</p>
<p>用index作为key可能会引发的问题：<br>1.若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br>会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</p>
<p>如果结构中还包含输入类的DOM：<br>会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。</p>
<p>开发中如何选择key?:<br>1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br>使用index作为key是没有问题的。</p>
<h3 id="♥︎♥︎♥︎-Vue的虚拟dom"><a href="#♥︎♥︎♥︎-Vue的虚拟dom" class="headerlink" title="♥︎♥︎♥︎ Vue的虚拟dom"></a>♥︎♥︎♥︎ Vue的虚拟dom</h3><p>从本质来说，Virtual Dom 是一个 JavaScript 对象，通过对象的方式来表示 DOM 结构。将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次 DOM 修改的结果一次性更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p>
<p>虚拟 DOM 是对 DOM 的抽象，这个对象是更加轻量级的对 DOM 的描述。它设计的最初目的就是更好的跨平台，比如 Node.js 就没有 DOM，如果想实现 SSR，那么就只能借助虚拟 DOM，因为虚拟 DOM 本身就是 JS 对象，在代码渲染到页面之前，Vue 和 React 会把代码转化成一个对象（虚拟 DOM），以对象的形式来描述真实 DOM 结构，最终渲染到页面。在每次数据发生变化前，虚拟 DOM 都会缓存一份，变化之时，现在的虚拟 DOM 会与缓存的虚拟 DOM 进行比较。</p>
<p>Vue 和 React 内部都封装了 diff 算法用来进行比较渲染时的变化（具体 diff 算法内容后续重点分析），精准更新发生变化的节点，而没有发生变化的直接通过原先的数据进行渲染。</p>
<p>另外现代前端框架基本都要求无须手动操作 DOM，一方面是因为手动操作 DOM 无法保证程序的性能，多人协作的项目中如果 code review 不严格，很容易出现性能较低的代码，另一方面更重要的是省略手动操作 DOM 可以大大提高开发效率。</p>
<h3 id="♥︎♥︎♥︎diff复杂度原理及具体过程画图"><a href="#♥︎♥︎♥︎diff复杂度原理及具体过程画图" class="headerlink" title="♥︎♥︎♥︎diff复杂度原理及具体过程画图"></a>♥︎♥︎♥︎diff复杂度原理及具体过程画图</h3><p>diff算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。</p>
<p>diff算法有两个比较显著的特点：</p>
<p>1、比较只会在同层级进行, 不会跨层级比较。</p>
<p>2、在diff比较的过程中，循环从两边向中间收拢。</p>
<p>diff流程： 首先定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode的两边的索引。</p>
<p>接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<p>while 循环中会遇到四种情况：</p>
<p>情形一：当新老 VNode 节点的 start 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。</p>
<p>情形二：当新老 VNode 节点的 end 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。</p>
<p>情形三：当老 VNode 节点的 start 和新 VNode 节点的 end 是同一节点时，这说明这次数据更新后oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 patchVnode 后，还需要将当前真实dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1。</p>
<p>情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 是同一节点时，这说明这次数据更新后oldEndVnode 跑到了 oldStartVnode 的前面去了。这时候在 patchVnode 后，还需要将当前真实 dom节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加1。</p>
<p>while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<p>情形一：如果在循环中，oldStartIdx大于oldEndIdx了，那就表示oldChildren比newChildren先循环完毕，那么newChildren里面剩余的节点都是需要新增的节点，把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中</p>
<p>情形二：如果在循环中，newStartIdx大于newEndIdx了，那就表示newChildren比oldChildren先循环完毕，那么oldChildren里面剩余的节点都是需要删除的节点，把[oldStartIdx, oldEndIdx]之间的所有节点都删除</p>
<h3 id="♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法"><a href="#♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法" class="headerlink" title="♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法"></a>♥︎♥︎♥︎怎么修改Vuex中的状态？Vuex中有哪些方法</h3><ul>
<li>通过this.$store.state.属性的方法来访问状态</li>
<li>通过this.$store.commit(‘mutation中的方法’) 来修改状态</li>
</ul>
<pre><code class="javascript">// App.vue
&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;
    &lt;button @click=&quot;addition&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;App&#39;,
  computed:&#123;
    count() &#123;
      return this.$store.state.count
    &#125;
  &#125;,
  methods:&#123;
    addition() &#123;
      this.$store.commit(&#39;increment&#39;)
    &#125;,
    decrement() &#123;
      this.$store.commit(&#39;decrement&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="♥︎♥︎♥︎vue-router路由传参的方式"><a href="#♥︎♥︎♥︎vue-router路由传参的方式" class="headerlink" title="♥︎♥︎♥︎vue-router路由传参的方式"></a>♥︎♥︎♥︎vue-router路由传参的方式</h3><p>query</p>
<pre><code class="javascript">this.$router.push(&#123;
 path: &#39;blogDetail&#39;, 
 query: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<p>params</p>
<pre><code class="javascript">this.$router.push(&#123;
 name: &#39;blogDetail&#39;, 
 params: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<h3 id="♥︎♥︎♥︎-hash-history区别"><a href="#♥︎♥︎♥︎-hash-history区别" class="headerlink" title="♥︎♥︎♥︎ hash history区别"></a>♥︎♥︎♥︎ hash history区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">hash</th>
<th align="center">history</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url显示</td>
<td align="center">有#，很Low</td>
<td align="center">无#，好看</td>
</tr>
<tr>
<td align="center">回车刷新</td>
<td align="center">可以加载到hash值对应页面</td>
<td align="center">一般就是404掉了</td>
</tr>
<tr>
<td align="center">支持版本</td>
<td align="center">支持低版本浏览器和IE浏览器</td>
<td align="center">HTML5新推出的API</td>
</tr>
</tbody></table>
<h3 id="♥︎♥︎♥︎-用过beforeEach吗？"><a href="#♥︎♥︎♥︎-用过beforeEach吗？" class="headerlink" title="♥︎♥︎♥︎ 用过beforeEach吗？"></a>♥︎♥︎♥︎ 用过beforeEach吗？</h3><p>每次通过vue-router进行页面跳转，都会触发beforeEach这个钩子函数，这个回调函数共有三个参数，to，from，next这三个参数，to表示我要跳转的目标路由对应的参数，from表示来自那个路由，就是操作路由跳转之前的，即将离开的路由对应的参数，next是一个回调函数，一定要调用next方法来resolve这个钩子函数；</p>
<h3 id="♥︎♥︎♥︎-Vnode的优缺点"><a href="#♥︎♥︎♥︎-Vnode的优缺点" class="headerlink" title="♥︎♥︎♥︎ Vnode的优缺点"></a>♥︎♥︎♥︎ Vnode的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>1、降低浏览器性能消耗</p>
<p>因为Javascript的运算速度远大于DOM操作的执行速度，因此，运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而提高性能。</p>
<blockquote>
<p>在vnode技术出现之前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom，然后修改样式行为或者结构，来达到更新 ui的目的。这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom树。</p>
</blockquote>
<blockquote>
<p>在vnode技术出现之后，我们建立一个虚拟 dom 对象来对应真实的 dom 树，那么每次 dom 的更改就变成了 js 对象的属性的更改 ，这样一来就能查找 js 对象的属性变化要比查询 dom 树的 性能开销小。</p>
</blockquote>
<p>2、diff算法,减少回流和重绘</p>
<p>通过diff算法，优化遍历，对真实dom进行打补丁式的新增、修改、删除，实现局部更新，减少回流和重绘。</p>
<blockquote>
<p>vnode优化性能核心思想，就是每次更新 dom 都尽量避免刷新整个页面，而是有针对性的 去刷新那被更改的一部分，来释放掉被无效渲染占用的 gpu，cup性能。同时，也减少了大量的dom操作，减少了浏览器的回流和重绘。</p>
</blockquote>
<p>3、跨平台</p>
<p>虚拟 DOM 本质上是 JavaScript 对象，而 DOM 与平台强相关，相比之下虚拟 DOM ，可以进行更方便地跨平台操作，例如：<code>服务器渲染、weex 开发</code>等等</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><code>首次显示要慢些</code>:<br>首次渲染大量DOM时，由于多了一层虚拟DOM的计算, 会比innerHTML插入慢</li>
<li><code>无法进行极致优化</code>：<br>虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中 无法进行针对性的极致优化。</li>
</ul>
<h3 id="♥︎♥︎♥︎Vue中的单项数据流"><a href="#♥︎♥︎♥︎Vue中的单项数据流" class="headerlink" title="♥︎♥︎♥︎Vue中的单项数据流"></a>♥︎♥︎♥︎Vue中的单项数据流</h3><p>单向数据流指只能从一个方向来修改状态。</p>
<p>数据从父级组件传递给子组件，只能单向绑定。</p>
<p>子组件内部不能直接修改从父级传递过来的数据。</p>
<h3 id="♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？"><a href="#♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？" class="headerlink" title="♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？"></a>♥︎♥︎♥︎Vue组件中的Data为什么是函数，根组件却是对象呢？</h3><p>如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p>
<p>所以说vue组件的data必须是函数。这都是因为js的特性带来的，跟vue本身设计无关。</p>
<h3 id="♥︎♥︎♥︎介绍下vue单页面和多页面区别"><a href="#♥︎♥︎♥︎介绍下vue单页面和多页面区别" class="headerlink" title="♥︎♥︎♥︎介绍下vue单页面和多页面区别"></a>♥︎♥︎♥︎介绍下vue单页面和多页面区别</h3><p>单页应用 页面跳转—-&gt;js渲染 优点：页面切换快 缺点：首屏加载稍慢，seo差</p>
<p>多页应用 页面跳转—-&gt;返回html 优点：首屏时间快，seo效果好 缺点：页面切换慢</p>
<h3 id="♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序"><a href="#♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序" class="headerlink" title="♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序"></a>♥︎♥︎♥︎介绍下vue父子组件生命周期的执行顺序</h3><p>挂载阶段</p>
<blockquote>
<p>执行顺序为：<br>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p>
</blockquote>
<p>更新阶段</p>
<blockquote>
<p>执行顺序为：<br>父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</p>
</blockquote>
<p>销毁阶段</p>
<blockquote>
<p>执行顺序为：<br>父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</p>
</blockquote>
<p>规律就是：父组件先开始执行，然后等到子组件执行完，父组件收尾。</p>
<h3 id="♥︎♥︎♥︎Vue中key的作用？不加会怎么样？"><a href="#♥︎♥︎♥︎Vue中key的作用？不加会怎么样？" class="headerlink" title="♥︎♥︎♥︎Vue中key的作用？不加会怎么样？"></a>♥︎♥︎♥︎Vue中key的作用？不加会怎么样？</h3><p>vue中列表循环需加:key&#x3D;”唯一标识” 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM.</p>
<h3 id="♥︎♥︎♥︎Vue的常用修饰符"><a href="#♥︎♥︎♥︎Vue的常用修饰符" class="headerlink" title="♥︎♥︎♥︎Vue的常用修饰符"></a>♥︎♥︎♥︎Vue的常用修饰符</h3><blockquote>
<ol>
<li>事件修饰符 - 处理 DOM 事件细节</li>
<li>按键修饰符 - 为 v-on 在监听键盘事件时添加按键修饰符</li>
<li>系统修饰键 - 实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</li>
<li>鼠标按钮修饰符 - 限制处理函数仅响应特定的鼠标按键</li>
<li>表单修饰符 - v-model增强的修饰符</li>
</ol>
</blockquote>
<h4 id="一、事件修饰符"><a href="#一、事件修饰符" class="headerlink" title="一、事件修饰符"></a>一、事件修饰符</h4><ol>
<li><p>.stop - 阻止单击事件继续传播, 也就是阻止冒泡</p>
</li>
<li><p>.prevent - 提交事件不再重新加载页面, 可以用来阻止表单提交的默认行为</p>
</li>
</ol>
<blockquote>
<p>注意点: .stop和.prevent可以串联在一起使用,都会生效</p>
</blockquote>
<ol start="3">
<li><p>.capture - 内部元素触发的事件先在此处理，然后才交由内部元素进行处理</p>
</li>
<li><p>.self - 只当在 event.target 是当前元素自身时触发处理函数,即事件不是从内部元素触发的</p>
</li>
</ol>
<blockquote>
<p>注意点: 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p>
</blockquote>
<ol start="5">
<li><p>.once - 点击事件将只会触发一次, 不只能对原生DOM时间生效,还可以用在自定义组件上</p>
</li>
<li><p>.passive - 立即触发默认行为,能够提升移动端性能,和.prevent一起使用时.prevent会被忽略并警告</p>
</li>
<li><p>.native - 使用时将被当做原生的HTML标签看待,绑定事件可以生效</p>
</li>
</ol>
<h4 id="二、按键修饰符"><a href="#二、按键修饰符" class="headerlink" title="二、按键修饰符"></a>二、按键修饰符</h4><ol>
<li><p>.keyup - 键盘抬起</p>
</li>
<li><p>.keydow - 键盘按下</p>
</li>
<li><p>按键码 - 在按键修饰符后面添加,用于监听键盘按下哪个键</p>
</li>
</ol>
<p>常用按键码: </p>
<ul>
<li><p>.enter</p>
</li>
<li><p>.tab</p>
</li>
<li><p>.delete (捕获“删除”和“退格”键)</p>
</li>
<li><p>.esc</p>
</li>
<li><p>.space</p>
</li>
<li><p>.up</p>
</li>
<li><p>.down</p>
</li>
<li><p>.left</p>
</li>
<li><p>.right</p>
</li>
</ul>
<h4 id="三、系统修饰键"><a href="#三、系统修饰键" class="headerlink" title="三、系统修饰键"></a>三、系统修饰键</h4><ul>
<li><p>.ctrl</p>
</li>
<li><p>.alt</p>
</li>
<li><p>.shift</p>
</li>
<li><p>.meta</p>
</li>
</ul>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<blockquote>
<p>注意点: 修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。<br>.exact 修饰符 - 使用系统修饰符时使用可以单击系统修饰键触发,不适用系统修饰符时使用</p>
</blockquote>
<h4 id="四、鼠标按键修饰符"><a href="#四、鼠标按键修饰符" class="headerlink" title="四、鼠标按键修饰符"></a>四、鼠标按键修饰符</h4><p>.left - 只有鼠标左键点击触发<br>.right - 只有鼠标右键点击触发<br>.middle - 只有鼠标中键点击触发</p>
<h4 id="五、表单修饰符"><a href="#五、表单修饰符" class="headerlink" title="五、表单修饰符"></a>五、表单修饰符</h4><ol>
<li><p>.lazy - 在表单输入时不会马上显示在页面,而是等输入完成失去焦点时才会显示在页面</p>
</li>
<li><p>.trim - 过滤表单输入时前后的空格</p>
</li>
<li><p>.number - 限制输入数字或将输入的数据转为数字</p>
</li>
</ol>
<blockquote>
<p>注意点: 如果先输入数字,会限制只能输数字, 如果先输字符串则相当于没加.number</p>
</blockquote>
<h3 id="♥︎♥︎♥︎Vue计算属性和-Watch-的区别"><a href="#♥︎♥︎♥︎Vue计算属性和-Watch-的区别" class="headerlink" title="♥︎♥︎♥︎Vue计算属性和 Watch 的区别"></a>♥︎♥︎♥︎Vue计算属性和 <strong>Watch</strong> 的区别</h3><p>methods（方法）：</p>
<p>只要进行调用就会执行，不管依赖的值有没有改变。无缓存。</p>
<p>computed（计算属性)：</p>
<p>监听其所有依赖的变化，如果有变化会执行，没有变化不执行。有缓存，不用每次重新算。不支持异步。</p>
<p>详解:在vue的 模板内是可以写一些简单的js表达式的 ，很便利。但是如果在页面中使用大量或是复杂的表达式去处理数据，对页面的维护会有很大的影响。这个时候就需要用到computed 计算属性来处理复杂的逻辑运算。</p>
<p>1.优点：</p>
<p>在数据未发生变化时，优先读取缓存。computed 计算属性只有在相关的数据发生变化时才会改变要计算的属性，当相关数据没有变化是，它会读取缓存。而不必想 motheds方法 和 watch 方法是否每次都去执行函数。</p>
<p>2.setter 和 getter方法：（注意在vue中书写时用set 和 get）</p>
<p>setter 方法在设置值是触发。</p>
<p>getter 方法在获取值时触发。</p>
<p>watch（侦听属性）:</p>
<p>观察某一个变量，发生变化会执行。支持异步。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>
<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。</p>
<p>❕小结：</p>
<p>1.主动调用的方法写在methods里，依据某些变量的更新进行某种操作用computed或者watch。</p>
<p>2.computed和watch：如果要异步，只能用watch。如果是计算某个值推荐用computed，比如购物车全选单选功能，购物车计算总价小计功能。</p>
<h3 id="♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？"><a href="#♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？" class="headerlink" title="♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？"></a>♥︎♥︎♥︎Vue中v-on可以绑定多个方法吗？</h3><p>vue中v-on是可以绑定多个方法的</p>
<p>1、v-on绑定多个方法（采用的是对象形式）</p>
<pre><code class="html">&lt;button v-on=&quot;&#123;click: clickMethods, mousemove: mouseMethods&#125;&quot;&gt;按钮&lt;button&gt;
</code></pre>
<p>2.v-on 一个事件绑定多个方法 （语法糖 @）</p>
<pre><code class="html">&lt;button @click=&quot;click1,click2&quot;&gt;按钮&lt;/button&gt;
</code></pre>
<h3 id="♥︎♥︎♥︎Vue中template的编译过程"><a href="#♥︎♥︎♥︎Vue中template的编译过程" class="headerlink" title="♥︎♥︎♥︎Vue中template的编译过程"></a>♥︎♥︎♥︎Vue中template的编译过程</h3><p>vue template模板编译的过程经过parse()生成ast(抽象语法树),optimize对静态节点优化，generate()生 成render字符串 之后调用new Watcher()函数，用来监听数据的变化，render 函数就是数据监听的回调,所调用的，其结果便是重新生成 vnode。 当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。 如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode做 diff，对内容做改动之后，就会更新到 我们真正的 DOM</p>
<h3 id="♥︎♥︎♥︎Vue中router-link和传统a链接的区别？"><a href="#♥︎♥︎♥︎Vue中router-link和传统a链接的区别？" class="headerlink" title="♥︎♥︎♥︎Vue中router-link和传统a链接的区别？"></a>♥︎♥︎♥︎Vue中router-link和传统a链接的区别？</h3><p>组件支持用户在具有路由功能的应用中 (点击) 导航。 </p>
<p>通过 to 属性指定目标地址，默认渲染成带有正确链接的 标签，可以通过配置 tag 属性生成别的标签.。 </p>
<p>通过router-link进行跳转不会跳转到新的页面，也不会重新渲染，它会选择路由所指的组件进行渲染，避免了重复渲染的“无用功”。 </p>
<p>总结：对比，router-link组件避免了不必要的重渲染,它只更新变化的部分从而减少DOM性能消耗</p>
<h3 id="♥︎♥︎♥︎-Vue插槽是什么？"><a href="#♥︎♥︎♥︎-Vue插槽是什么？" class="headerlink" title="♥︎♥︎♥︎ Vue插槽是什么？"></a>♥︎♥︎♥︎ Vue插槽是什么？</h3><p>slot用于封装组件中，写在子组件 接收父组件动态传递子组件内容片断</p>
<p>slot插槽的使用方法其实就是类似于一个子组件或者标签的引用的过程，在父组件里面定义一个slot，给她起个name，然后组件引入到子组件，子组件里面有个元素的属性slot值等于name，然后父组件里面没有值的时候就可以显示子组件里面的信息了（切记：插槽slot要写在父组件里面！！！）</p>
<h3 id="♥︎♥︎♥︎-说一下Vue-router守卫有哪些。如何实现路由懒加载？"><a href="#♥︎♥︎♥︎-说一下Vue-router守卫有哪些。如何实现路由懒加载？" class="headerlink" title="♥︎♥︎♥︎ 说一下Vue-router守卫有哪些。如何实现路由懒加载？"></a>♥︎♥︎♥︎ 说一下Vue-router守卫有哪些。如何实现路由懒加载？</h3><ul>
<li>router.beforeEach 全局前置守卫 进入路由之前</li>
<li>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用</li>
<li>router.afterEach 全局后置钩子 进入路由之后</li>
</ul>
<p>1、 Vue异步加载技术</p>
<blockquote>
<p>1：vue-router配置路由，使用vue的异步组件技术，可以实现懒加载，此时一个组件会生成一个js文件。 </p>
<p>2：component: resolve &#x3D;&gt; require([‘放入需要加载的路由地址’], resolve)</p>
</blockquote>
<p>2、 ES6推荐方式imprort ()—-推荐使用</p>
<pre><code class="javascript">import Vue from &#39;vue&#39;;
import Router from &#39;vue-router&#39;;
// 官网可知：下面没有指定webpackChunkName，每个组件打包成一个js文件。
const Foo = () =&gt; import(&#39;../components/Foo&#39;)
const Aoo = () =&gt; import(&#39;../components/Aoo&#39;)
// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。
// const Foo = () =&gt; import(/* webpackChunkName: &#39;ImportFuncDemo&#39; / &#39;../components/Foo&#39;)
// const Aoo = () =&gt; import(/ webpackChunkName: &#39;ImportFuncDemo&#39; */ &#39;../components/Aoo&#39;)
export default new Router(&#123;
 routes: [
 &#123;
 path: &#39;/Foo&#39;,
 name: &#39;Foo&#39;,
 component: Foo
 &#125;,
 &#123;
 path: &#39;/Aoo&#39;,
 name: &#39;Aoo&#39;,
 component: Aoo
 &#125;
 ]
&#125;)
</code></pre>
<p>3、 webpack提供的require.ensure()实现懒加载</p>
<ul>
<li>1：vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。</li>
<li>2：这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</li>
<li>3：require.ensure可实现按需加载资源，包括js,css等。他会给里面require的文件单独打包，不会和主文件打包在一起。</li>
<li>4：第一个参数是数组，表明第二个参数里需要依赖的模块，这些会提前加载。</li>
<li>5：第二个是回调函数,在这个回调函数里面require的文件会被单独打包成一个chunk,不会和主文件打包在一起，这样就生成了两个chunk,第一次加载时只加载主文件。</li>
<li>6：第三个参数是错误回调。</li>
<li>7：第四个参数是单独打包的chunk的文件名</li>
</ul>
<pre><code class="javascript">import Vue from &#39;vue&#39;;
import Router from &#39;vue-router&#39;;
const HelloWorld=resolve=&gt;&#123;
 require.ensure([&#39;@/components/HelloWorld&#39;],()=&gt;&#123;
 resolve(require(&#39;@/components/HelloWorld&#39;))
 &#125;)
 &#125;
Vue.use(&#39;Router&#39;)
export default new Router(&#123;
 routes:[&#123;
 &#123;path:&#39;./&#39;,
 name:&#39;HelloWorld&#39;,
 component:HelloWorld
 &#125;
 &#125;]
&#125;)
</code></pre>
<h3 id="♥︎♥︎♥︎什么是Vue-js动态组件与异步组件？"><a href="#♥︎♥︎♥︎什么是Vue-js动态组件与异步组件？" class="headerlink" title="♥︎♥︎♥︎什么是Vue.js动态组件与异步组件？"></a>♥︎♥︎♥︎什么是Vue.js动态组件与异步组件？</h3><h4 id="1-动态组件"><a href="#1-动态组件" class="headerlink" title="1.动态组件"></a>1.动态组件</h4><ul>
<li>:is &#x3D; “component-name” 用法</li>
<li>需要根据数据，动态渲染的场景。即组件类型不确定</li>
</ul>
<pre><code class="html">//代码实例
&lt;template&gt;
  &lt;div&gt;
      &lt;p&gt;vue高级特性&lt;/p&gt;
      &lt;hr&gt;
      &lt;!-- 动态组件 --&gt;
      &lt;component :is=&quot;NextTickName&quot;&gt;&lt;/component&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
&lt;/style&gt;
</code></pre>
<pre><code class="javascript">&lt;script&gt;
import NextTick from &#39;./nextTick&#39;
export default &#123;
  components: &#123;
    NextTick
  &#125;,
  data () &#123;
    return &#123;
      name: &#39;夹心&#39;,
      website: &#123;
        url: &#39;http://imooc.com/&#39;,
        title: &#39;imooc&#39;,
        subTitle: &#39;程序员的梦工厂&#39;
      &#125;,
      NextTickName: &#39;NextTick&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h4 id="2-异步组件"><a href="#2-异步组件" class="headerlink" title="2.异步组件"></a>2.异步组件</h4><ul>
<li>import() 函数</li>
<li>按需加载，异步加载大组件</li>
</ul>
<pre><code class="javascript">export default &#123;
  components: &#123;
    FormDemo: () =&gt; import(&#39;../components/FormDemo&#39;)
  &#125;
&#125;
</code></pre>
<h3 id="♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式"><a href="#♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式" class="headerlink" title="♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式"></a>♥︎♥︎♥︎说一下Vue中路由跳转和传值的方式</h3><p>1、路由跳转</p>
<p>router-link组件 默认会被渲染成一个 标签，进行跳转，在组件中可以通过绑定to属性来指定要跳转的链接；tag属性指本来的标签</p>
<blockquote>
<p>$router.push()方法</p>
</blockquote>
<p>2、路由传参</p>
<p>query</p>
<pre><code class="javascript">this.$router.push(&#123;
 path: &#39;blogDetail&#39;, 
 query: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<p>params</p>
<pre><code class="javascript">this.$router.push(&#123;
 name: &#39;blogDetail&#39;, 
 params: &#123; 
 id: item.id,
 views: item.views
 &#125;
&#125;)
</code></pre>
<h3 id="♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3-0与Vue2-0对比"><a href="#♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3-0与Vue2-0对比" class="headerlink" title="♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3.0与Vue2.0对比)"></a>♥︎♥︎♥︎最近关注了什么新技术吗，简单说下你的理解（Vue3.0与Vue2.0对比)</h3><p>[Vue3.0与Vue2.0区别]: 	“<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/389421424">https://zhuanlan.zhihu.com/p/389421424</a>  “</p>
<h4 id="一、六大亮点"><a href="#一、六大亮点" class="headerlink" title="一、六大亮点"></a>一、六大亮点</h4><p>性能比vue2.x快1.2~2倍</p>
<p>支持tree-shaking，按需编译，体积比vue2.x更小</p>
<p>支持组合API</p>
<p>更好的支持TS</p>
<p>更先进的组件</p>
<h4 id="二、性能比vue2-x快1-2-2倍如何实现的呢"><a href="#二、性能比vue2-x快1-2-2倍如何实现的呢" class="headerlink" title="二、性能比vue2.x快1.2~2倍如何实现的呢"></a>二、性能比vue2.x快1.2~2倍如何实现的呢</h4><p>1.diff算法更快</p>
<p>vue2.0是需要全局去比较每个节点的，若发现有节点发生变化后，就去更新该节点</p>
<p>vue3.0是在创建虚拟dom中，会根据DOM的的内容会不会发生内容变化，添加静态标记， 谁有flag！比较谁。</p>
<p>2、静态提升</p>
<p>vue2中无论元素是否参与更新，每次都会重新创建，然后再渲染 vue3中对于不参与更新的元素，会做静态提升，只被创建一次，在渲染时直接复用即可</p>
<p>3、事件侦听缓存默认情况下，onclick为动态绑定，所以每次都会追踪它的变化，但是因为是同一函数，没有必要追踪变化，直接缓存复用即可在之前会添加静态标记8 会把点击事件当做动态属性 会进行diff算法比较， 但是在事件监听缓存之后就没有静态标记了，就会进行缓存复用</p>
<h4 id="三、为什么vue3-0体积比vue2-x小"><a href="#三、为什么vue3-0体积比vue2-x小" class="headerlink" title="三、为什么vue3.0体积比vue2.x小"></a>三、为什么vue3.0体积比vue2.x小</h4><p>在vue3.0中创建vue项目 除了vue-cli，webpack外还有 一种创建方法是Vite Vite是作者开发的一款有意取代webpack的工具，其实现原理是利用ES6的import会发送请求去加载文件的特性，拦截这些请求，做一些预编译，省去webpack冗长的打包时间</p>
<h4 id="四、vue3-0组合API"><a href="#四、vue3-0组合API" class="headerlink" title="四、vue3.0组合API"></a>四、vue3.0组合API</h4><p>1.说一说vue3.0的组合API跟之前vue2.0在完成业务逻辑上的区别：</p>
<p>在vue2.0中： 主要是往data 和method里面添加内容，一个业务逻辑需要什么data和method就往里面添加，而组合API就是 有一个自己的方法，里面有自己专注的data 和method。</p>
<p>2.再说一下组合API的本质是什么： 首先composition API（组合API） 和 Option API（vue2.0中的data和method）可以共用 composition API（组合API）本质就是把内容添加到Option API中进行使用</p>
<h4 id="五、ref和reactive的简单理解"><a href="#五、ref和reactive的简单理解" class="headerlink" title="五、ref和reactive的简单理解"></a>五、ref和reactive的简单理解</h4><p>1.ref和reactive都是vue3的监听数据的方法，本质是proxy </p>
<p>2.ref 基本类型复杂类型都可以监听(我们一般用ref监听基本类型)，reactive只能监听对象（arr，json） </p>
<p>3.ref底层还是reactive</p>
<h4 id="六、对生命周期的监听（ref获取属性）"><a href="#六、对生命周期的监听（ref获取属性）" class="headerlink" title="六、对生命周期的监听（ref获取属性）"></a>六、对生命周期的监听（ref获取属性）</h4><h4 id="七、proxy响应式本质"><a href="#七、proxy响应式本质" class="headerlink" title="七、proxy响应式本质"></a>七、proxy响应式本质</h4><h3 id="♥︎♥︎♥︎v-if和v-show的区别"><a href="#♥︎♥︎♥︎v-if和v-show的区别" class="headerlink" title="♥︎♥︎♥︎v-if和v-show的区别"></a>♥︎♥︎♥︎v-if和v-show的区别</h3><p>1、手段：v-if是动态的向DOM树添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显示和隐藏。</p>
<p>2、编译过程：v-if切换有一个局部编译&#x2F;卸载的过程， 切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换。</p>
<p>3、编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留</p>
<p>4、性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换</p>
<p>6、相同点： v-show 都可以动态控制着dom元素的显示隐藏 </p>
<p>​    不同点： v-if 的显示隐藏是将DOM元素整个添加或删除，v-show 的显示隐藏是为DOM元素添</p>
<p>7、加css的样式display，设置none或者是block，DOM元素是还存在的</p>
<p>8、在渲染多个元素的时候，可以把一个 元素作为包装元素，并使用v-if 进行条件判断，最终的渲染不会包含这个元素，v-show是不支持 语法</p>
<h3 id="♥︎♥︎♥︎-简述Vue每个生命周期具体适合哪些场景"><a href="#♥︎♥︎♥︎-简述Vue每个生命周期具体适合哪些场景" class="headerlink" title="♥︎♥︎♥︎ 简述Vue每个生命周期具体适合哪些场景"></a>♥︎♥︎♥︎ 简述Vue每个生命周期具体适合哪些场景</h3><table>
<thead>
<tr>
<th align="center">钩子函数</th>
<th align="center">具体发生了什么</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beforeCreate</td>
<td align="center">初始化界面前 : 在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问，都还没有完成初始化。</td>
</tr>
<tr>
<td align="center">created</td>
<td align="center">初始化界面后 : 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数,也就是不会更新视图。实例的data数据和methods方法都已经被初始化完毕了，可以正常访问</td>
</tr>
<tr>
<td align="center">beforeMount</td>
<td align="center">挂载前 ：完成模板编译，虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。数据还没有更新到页面上去。当编译完成之后，只是在内存中已经有了编译好的页面，但并未渲染。</td>
</tr>
<tr>
<td align="center">mounted</td>
<td align="center">挂载完成 ： 将编译好的模板挂载到页面 (虚拟DOM挂载) ，可以在这进行异步请求以及DOM节点的访问，在vue用$ref操作</td>
</tr>
<tr>
<td align="center">beforeUpdate</td>
<td align="center">更新数据前 ： 组件数据更新之前调用，数据都是新的,页面上数据都是旧的。将要根据最新的data数据，重新解析所有指令，从而重新渲染浏览器页面。</td>
</tr>
<tr>
<td align="center">updated</td>
<td align="center">组件更新后 ： render重新渲染 , 此时数据和界面都是新的 ,要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新</td>
</tr>
<tr>
<td align="center">beforeDestroy</td>
<td align="center">组件卸载前 : 实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器</td>
</tr>
<tr>
<td align="center">destroyed</td>
<td align="center">组件卸载后 ： 组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</td>
</tr>
<tr>
<td align="center">activited</td>
<td align="center">keep-alive 专属 , 组件被激活时调用</td>
</tr>
<tr>
<td align="center">deactivated</td>
<td align="center">keep-alive 专属 , 组件被销毁时调用</td>
</tr>
</tbody></table>
<h3 id="♥︎♥︎♥︎-什么是v-model？它的原理是什么？"><a href="#♥︎♥︎♥︎-什么是v-model？它的原理是什么？" class="headerlink" title="♥︎♥︎♥︎ 什么是v-model？它的原理是什么？"></a>♥︎♥︎♥︎ 什么是v-model？它的原理是什么？</h3><p>1、v-model本质上是一个语法糖，可以看成是value + input 方法的语法糖。可以通过model的prop属性和event事件来进行自定义。</p>
<p>2、v-model是vue的双向绑定的指令，能将页面上控件输入的值同步更新到相关绑定的data属性， 也会在更新data绑定属性时候，更新页面上输入控件的值。</p>
<h3 id="♥︎♥︎♥︎简单说一下-微信小程序-与Vue的区别（了解即可，具体区别请看各自具体部分）"><a href="#♥︎♥︎♥︎简单说一下-微信小程序-与Vue的区别（了解即可，具体区别请看各自具体部分）" class="headerlink" title="♥︎♥︎♥︎简单说一下 微信小程序 与Vue的区别（了解即可，具体区别请看各自具体部分）"></a>♥︎♥︎♥︎简单说一下 微信小程序 与Vue的区别（了解即可，具体区别请看各自具体部分）</h3><p>1、生命周期：</p>
<p>小程序的钩子函数要简单得多 。 vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。</p>
<p>在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。</p>
<p>2、数据绑定：</p>
<p>vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：</p>
<p>小程序 绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串</p>
<p>3、列表循环</p>
<p>4、显示与隐藏元素</p>
<p>vue中，使用v-if 和v-show控制元素的显示和隐藏</p>
<p>小程序中，使用wx-if和hidden控制元素的显示和隐藏</p>
<p>5、事件处理</p>
<p>vue：使用v-on:event绑定事件，或者使用@event绑定事件</p>
<p>小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件</p>
<p>6、数据的双向绑定</p>
<p>在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变 。</p>
<p>当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值 。 </p>
<p>7、绑定事件传参</p>
<p>在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了</p>
<p>在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取</p>
<p>8、父子组件通信</p>
<p>父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量 在子组件properties中，接收传递的值</p>
<h3 id="♥︎♥︎♥︎Vue的组件通信"><a href="#♥︎♥︎♥︎Vue的组件通信" class="headerlink" title="♥︎♥︎♥︎Vue的组件通信"></a>♥︎♥︎♥︎Vue的组件通信</h3><p>1、props和$emit</p>
<p>父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件</p>
<p>2、$attrs和$listeners</p>
<p>3、中央事件总线 bus</p>
<p>上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。</p>
<p>4、provide和inject</p>
<p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p>
<p>5、v-model</p>
<p>父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</p>
<p>6、$parent和$children</p>
<p>7、boradcast和dispatch</p>
<p>8、vuex处理组件之间的数据交互 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>
<h3 id="♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？"><a href="#♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？" class="headerlink" title="♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？"></a>♥︎♥︎♥︎Vue如何在用户没登陆的时候重定向登录界面？</h3><p>现在 我们需要实现这样 一个功能，登录拦截，其实就是 路由拦截，首先在定义路由的时候就需要多添加一个自定义字段requireAuth，用于判断该路由的访问是否需要登录。如果用户已经登录，则顺利进入路由， 否则就进入登录页面。在路由管理页面添加meta字段</p>
<pre><code class="javascript">&#123;
 path:&#39;/manage&#39;,
 name:&#39;manage&#39;,
 component:manage,
 meta:&#123;requireAuth:true&#125;
&#125;
</code></pre>
<p>在入口文件中，添加路由守卫</p>
<p>先判断该路由是否需要登录权限</p>
<p>判断本地是否存在token，如果存在token就next()，不存在token重定向到登录页</p>
<h3 id="♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。"><a href="#♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。" class="headerlink" title="♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。"></a>♥︎♥︎♥︎Vuex和redux有什么区别？他们的共同思想。</h3><p>Redux和Vuex区别</p>
<p>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值就可以</p>
<p>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state就可以</p>
<p>Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数 – store改变(vue检测到数据变化自动渲染)</p>
<p>共同思想</p>
<ul>
<li>单一的数据源</li>
<li>变化可以预测</li>
<li>本质上:Redux和Vuex都是对MVVM思想的服务，将数据从视图中抽离的一种方案</li>
<li>形式上:Vuex借鉴了Redux，将store作为全局的数据中心，进行数据管理</li>
</ul>
<hr>
<h3 id="♥︎♥︎♥︎♥︎Composition-API的出现带来哪些新的开发体验，为啥需要这个？"><a href="#♥︎♥︎♥︎♥︎Composition-API的出现带来哪些新的开发体验，为啥需要这个？" class="headerlink" title="♥︎♥︎♥︎♥︎Composition API的出现带来哪些新的开发体验，为啥需要这个？"></a>♥︎♥︎♥︎♥︎Composition API的出现带来哪些新的开发体验，为啥需要这个？</h3><p>1：在Compostion API 中时根据逻辑相关组织代码的，提高可读性和可维护性，类似于react的hook写法。</p>
<p>2：更好的重用逻辑代码，在Options API中通过MIxins重用逻辑代码，容易发生命名冲突且关系不清。</p>
<p>3：解决在生命周期函数经常包含不相关的逻辑，但又不得不把相关逻辑分离到了几个不同方法中的问题，如在mounted中设置定时器，但需要在destroyed中来清除定时器，将同一功能的代码拆分到不同的位置，造成后期代码维护的困难。</p>
<h3 id="♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作"><a href="#♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作" class="headerlink" title="♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作"></a>♥︎♥︎♥︎♥︎为什么Vuex的mutation不能做异步操作</h3><p>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，否则无法被devtools所监测。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>
<h3 id="♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法"><a href="#♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法" class="headerlink" title="♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法"></a>♥︎♥︎♥︎♥︎说明一下封装vue组件的原则和方法</h3><p>[封装vue组件的原则和技巧]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/leilei__66/article/details/119348108">https://blog.csdn.net/leilei__66/article/details/119348108</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎Object-defineProperty有什么缺点"><a href="#♥︎♥︎♥︎♥︎Object-defineProperty有什么缺点" class="headerlink" title="♥︎♥︎♥︎♥︎Object.defineProperty有什么缺点"></a>♥︎♥︎♥︎♥︎Object.defineProperty有什么缺点</h3><p>1：无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</p>
<p>2：只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。</p>
<h3 id="♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程"><a href="#♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程" class="headerlink" title="♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程?"></a>♥︎♥︎♥︎♥︎axios是什么？怎么使用？描述使用它实现登录功能的流程?</h3><p>axios 是请求后台资源的模块。 </p>
<p>通过npm install axios -S来安装，在大多数情况下我们需要封装拦截器。</p>
<p>在实现登录的过程中我们一般在请求拦截器中来加入token，在响应请求器中通过判断后端返回的状态码来对返回的数据进行不同的处理。如果发送的是跨域请求，需在配置文件中 config&#x2F;index.js 进行代理配置。</p>
<h3 id="♥︎♥︎♥︎♥︎-computed和watcher的区别？watch实现原理？watch有几种写法？"><a href="#♥︎♥︎♥︎♥︎-computed和watcher的区别？watch实现原理？watch有几种写法？" class="headerlink" title="♥︎♥︎♥︎♥︎ computed和watcher的区别？watch实现原理？watch有几种写法？"></a>♥︎♥︎♥︎♥︎ computed和watcher的区别？watch实现原理？watch有几种写法？</h3><p>计算属性computed :</p>
<ol>
<li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li>
<li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li>
<li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>
<li>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li>
</ol>
<p>侦听属性watch： </p>
<ol>
<li>不支持缓存，数据变，直接会触发相应的操作；</li>
<li>watch支持异步；</li>
<li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li>
<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>
<li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</li>
</ol>
<p>immediate：组件加载立即触发回调函数执行，</p>
<p>deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。</p>
<p>注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p>
<p>watch工作原理:</p>
<p>watch在一开始初始化的时候，会读取一遍监听的数据的值，此时那个数据就收集到watch的watcher了，然后你给watch设置的handler，watch 会放入watcher的更新函数中，当数据改变时，通知watch的watcher进行更新，于是你设置的handler就被调用了。</p>
<h3 id="♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？"><a href="#♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？" class="headerlink" title="♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？"></a>♥︎♥︎♥︎♥︎如果你是leader，做管理系统项目Vue和React怎么选择？</h3><p>评估项目成员的水平，如果成员js基础较好、编码能力较强则选择React，否则Vue。</p>
<p>评估系统的大小，如果想构建生态系统，则选择React，如果要求而快，简单和“能用就行”,则选择Vue。</p>
<p>评估系统运行环境，如果你想要一个同时适用于Web端和原生APP的框架，请选择React(RN)。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue和React区别"><a href="#♥︎♥︎♥︎♥︎Vue和React区别" class="headerlink" title="♥︎♥︎♥︎♥︎Vue和React区别"></a>♥︎♥︎♥︎♥︎Vue和React区别</h3><p>1：Vue 使用的是 web 开发者更熟悉的模板与特性，Vue的API跟传统web开发者熟悉的模板契合度更高，比如Vue的单文件组件是以模板+JavaScript+CSS的组合模式呈现，它跟web现有的HTML、JavaScript、CSS能够更好地配合。React 的特色在于函数式编程的理念和丰富的技术选型，Vue更加注重web开发者的习惯。</p>
<p>2：Vue跟React的最大区别在于数据的reactivity，就是反应式系统上。Vue提供反应式的数据，当数据改动时，界面就会自动更新，而React里面需要调用方法SetState。我把两者分别称为Push-based和Pull-based</p>
<h3 id="♥︎♥︎♥︎♥︎Vue路由实现的底层原理"><a href="#♥︎♥︎♥︎♥︎Vue路由实现的底层原理" class="headerlink" title="♥︎♥︎♥︎♥︎Vue路由实现的底层原理"></a>♥︎♥︎♥︎♥︎Vue路由实现的底层原理</h3><p>在Vue中利用数据劫持defineProperty在原型prototype上初始化了一些getter,分别是router代表当前Router的实例 、route 代表当前Router的信息。在install中也全局注册了router-view,router-link,其中的Vue.util.defineReactive, 这是Vue里面观察者劫持数据的方法，劫持<em>route</em>，当route触发setter方法的时候，则会通知到依赖的组件。</p>
<p>接下来在init中，会挂载判断是路由的模式，是history或者是hash,点击行为按钮，调用hashchange或 者popstate的同时更*route,*route的更新会触发route-view的重新渲染。</p>
<h3 id="♥︎♥︎♥︎♥︎如何封装一个通用组件"><a href="#♥︎♥︎♥︎♥︎如何封装一个通用组件" class="headerlink" title="♥︎♥︎♥︎♥︎如何封装一个通用组件"></a>♥︎♥︎♥︎♥︎如何封装一个通用组件</h3><p>通用组件的封装就是对可复用组件的解耦和样式复用，为了解耦一般数据都是通过父组件传递过来，在子组件中进行数据处理，对于一些较为复杂的数据可能还需要做数据验证，为了避免高耦合，逻辑最好放在父组件中，通过自定义事件将数据回传，子组件只是一个承载体，这样既降低耦合，保证子组件中数据和逻辑不会混乱。如果同一组件需要适应不同需求时，我们需要配合slot来使用，可以通过具名插槽灵活地解决了不同场景同一组件不同配置的问题。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue-proxy的原理"><a href="#♥︎♥︎♥︎♥︎Vue-proxy的原理" class="headerlink" title="♥︎♥︎♥︎♥︎Vue proxy的原理"></a>♥︎♥︎♥︎♥︎Vue proxy的原理</h3><p>主要通过Proxy对对象进行绑定监听处理，通过new Map对对象的属性操作进行处理，将要执行的函数匹配到存到对应的prop上面，通过每次的访问触发get方法，进行存方法的操作，通过修改触发set的方法，此时执行回调监听的函数，这样达到修改数据和视图的</p>
<h3 id="♥︎♥︎♥︎♥︎-defineProperty在数据劫持后是如何通知数据的更新和视图的更新的"><a href="#♥︎♥︎♥︎♥︎-defineProperty在数据劫持后是如何通知数据的更新和视图的更新的" class="headerlink" title="♥︎♥︎♥︎♥︎ defineProperty在数据劫持后是如何通知数据的更新和视图的更新的"></a>♥︎♥︎♥︎♥︎ defineProperty在数据劫持后是如何通知数据的更新和视图的更新的</h3><p>vue的双向绑定是由数据劫持结合发布者－订阅者模式实现的，那么什么是数据劫持？vue是如何进行数据劫持的？说白了就是通过Object.defineProperty()来劫持对象属性的setter和getter操作，在数据变动时做你想要做的事情</p>
<p>我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发生变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：</p>
<p>1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p>
<p>2.实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。</p>
<p>3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的"><a href="#♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的" class="headerlink" title="♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的"></a>♥︎♥︎♥︎♥︎Vue是怎么做虚拟DOM的diff的</h3><p>[Vue虚拟DOM以及diff算法]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/wytraining/article/details/110831015">https://blog.csdn.net/wytraining/article/details/110831015</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听"><a href="#♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听" class="headerlink" title="♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听"></a>♥︎♥︎♥︎♥︎Vuex如何实现跨组价的数据监听</h3><p>[Vuex跨组价的数据监听]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/Flowering_Vivian/article/details/108868907">https://blog.csdn.net/Flowering_Vivian/article/details/108868907</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的"><a href="#♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的" class="headerlink" title="♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的"></a>♥︎♥︎♥︎♥︎axios谁封装的，怎么封装的</h3><pre><code class="javascript">// 使用axios用于对数据的请求
import axios from &#39;axios&#39;
// 创建axios实例
const instance = axios.create(&#123;
 baseURL: baseURL + version,
 timeout: 5000
&#125;)
// 创建请求的拦截器
instance.interceptors.request.use(config =&gt; &#123;
 config.headers[&#39;Authorization&#39;] = localStorage.getItem(&#39;token&#39;)
 return config
&#125;, error =&gt; &#123;
 return Promise.reject(error)
&#125;)
// 创建响应的拦截器
instance.interceptors.response.use(response =&gt; &#123;
 let res = null
 // 对相应的数据进行过滤
 if (response.status === 200) &#123;
 if (response.data &amp;&amp; response.data.err === 0) &#123;
 res = response.data.data
 &#125; else if (response.data.err === -1) &#123;
 return alert(&#39;token无效&#39;)
 &#125;
 &#125; else &#123;
 return alert(&#39;请求失败&#39;)
 &#125;
 return res
&#125;, error =&gt; &#123;
 return Promise.reject(error)
&#125;)
export default instance
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？"><a href="#♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？" class="headerlink" title="♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？"></a>♥︎♥︎♥︎♥︎虚拟dom为什么会提高性能？</h3><p>1、虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom 的 diff 算法避免了没有必要的 dom 操作，从而提高性能。<br>2、用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中，当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue的computed的原理"><a href="#♥︎♥︎♥︎♥︎Vue的computed的原理" class="headerlink" title="♥︎♥︎♥︎♥︎Vue的computed的原理"></a>♥︎♥︎♥︎♥︎Vue的computed的原理</h3><h4 id="1-computed大致流程"><a href="#1-computed大致流程" class="headerlink" title="1.computed大致流程"></a>1.computed大致流程</h4><p>computed是vue中的计算属性，在依赖的值发生变化的时候进行重新计算，否则使用缓存。</p>
<p>前面说到computed只有在依赖发生变化才会重新计算，那么如何得知computed的值发生了变化呢</p>
<p>这主要是Watcher中的dirty属性，dirty属性为true时，说明computed中的值需要重新计算，dirty为false时，则说明依赖没有变化，不需要重新计算</p>
<p>当计算属性的值发生变化时，计算属性的watcher和组件的watcher都会得到通知。</p>
<p>计算属性的watcher会将dirty置为true,组件的Watcher得到通知，同样将dirty属性置为false,重新计算值，用于本次渲染。</p>
<p>简单来说,computed就是定义在vm上的一个getter属性，这个getter属性被触发时会做两件事</p>
<ol>
<li>计算当前属性的值，此时会使用Watcher去观察计算属性中用到的所有其他数据的变化。同时将计算属性的Watcher的dirty属性设置为false.</li>
</ol>
<p>2.当计算属性中用到的数据发生变化时,将得到通知从而进行重新渲染</p>
<p>Watcher中的depend和evaluate方法是专门用于实现计算属性的两个API</p>
<pre><code class="javascript">export default class Watcher &#123;
     constructor(vm, expOrFn, cb, options) &#123;
         if(options) &#123;
             this.lazy = !!options.lazy;
         &#125;  else &#123;
             this.lazy = false;
         &#125;
         this.dirty = this.lazy;
         this.value = this.lazy ? undefined : this.get()
     &#125;
     evaluate() &#123;
        this.value = this.get()
        this.dirty = false; 
    &#125;
    depend() &#123;
        let i = this.deps.length
        while(i--) &#123;
            this.deps[i].depend()
        &#125;
    &#125;
&#125;
</code></pre>
<p>执行depend方法可以将组件中的watcher实例添加到dep实例的依赖列表中。换句话说,this.deps是计算属性中用到的所有状态的dep实例,而依次执行了dep实例的depend方法就是将组件的watcher依次加入到这些dep实例的依赖列表。这就实现了让组件的watcher观察计算属性中用到的所有的状态的变化。</p>
<h4 id="2-Computed逻辑变化"><a href="#2-Computed逻辑变化" class="headerlink" title="2.Computed逻辑变化"></a>2.Computed逻辑变化</h4><p>computed在vue2.5.2中的实现发生了一些变化,因为之前的computed的计算存在一些逻辑上的漏洞,因为只要依赖的值发生了变化,vue就认为值发生了变化，组件会重新走一遍渲染的流程，但实际上UI不会由变化，浪费了一些性能。</p>
<p>改动之后的逻辑：</p>
<p>组件的watcher不再监听计算属性的变化,而是让计算属性的watcher得到通知后,计算一次计算属性的值，如果发现这一次计算出来的值与上一次计算出来的值不一样，再去主动通知组件的watcher进行重新渲染。</p>
<h3 id="♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改"><a href="#♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改" class="headerlink" title="♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改"></a>♥︎♥︎♥︎♥︎Vue中子组件是否可以修改props，如果想修改的话如何修改</h3><p>vue是单向数据流，父组件通过props传值给子组件，如果在子组件中修改会报错，一般是不在子组件中修改props的，但偶尔有需要在子组件有修改props,这里介绍三种可以修改子组件props的方法。</p>
<p>1.父组件用sync修饰，子组件通过<code>$emit(&#39;update:参数&#39;，值)</code>函数去修改。在项目中通常可以用改方法关闭弹框</p>
<pre><code class="vue">&lt;template&gt;
    //父组件
   &lt;CommonDialog
     :title=&quot;dialogTitle&quot;
     :showDialog.sync=&quot;isShowDialog&quot;
     :footer=&quot;true&quot;
     :width=&quot;dialogWidth&quot;
   &gt;
      ....
   &lt;/CommonDialog&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="vue">//子组件 弹框是否打开props: showDialog
&lt;el-dialog :title=&quot;title&quot; :visible=&quot;showDialog&quot; :show-close=&quot;false&quot; :width=&quot;width&quot;&gt;
      &lt;i class=&quot;el-dialog__headerbtn&quot; @click=&quot;closeModal&quot;&gt;
        &lt;span class=&quot;iconfont iconclose&quot;&gt;&lt;/span&gt;
      &lt;/i&gt;
      &lt;div class=&quot;dialog-body&quot;&gt;
          &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
      &lt;div v-if=&quot;!footer&quot; slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;
        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
    &lt;/el-dialog&gt;
</code></pre>
<pre><code class="javascript">//关闭弹框------子组件修改props
 closeModal() &#123;
   this.$emit(&quot;update:showDialog&quot;, false);
 &#125;,
</code></pre>
<p>2.如果props是对象，在子组件中修改props</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;csd-select&quot;&gt;
    &lt;el-popover
      placement=&quot;bottom&quot;
      :width=&quot;width&quot;
      :trigger=&quot;config.trigger&quot;
      :config=&quot;config&quot;
      transition=&quot;fade-in&quot;
      popper-class=&quot;casade-selector&quot;
      v-model=&quot;options_show&quot;
    &gt;
    ...
    &lt;/el-popover&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  name: &quot;CasadeSelector&quot;,
  props: &#123;
    config: &#123;
      type: Object,
      //让props默认返回
      default() &#123;
        return &#123;&#125;;
      &#125;
    &#125;,
  &#125;,
&lt;/script&gt;
</code></pre>
<p>3.props是双向绑定的</p>
<pre><code class="vue">&lt;template&gt;
    &lt;control v-model=&quot;deviceF&quot;&gt;&lt;/control&gt;
&lt;/template&gt;

 //v-model里面写上我们要传给子组件，并且还会在子组件中改变这个值
 &lt;script&gt;
 import control from &#39;@/components/control&#39;
 export default &#123;
    name:&quot;test&quot;,
    components: &#123;
        control
    &#125;,
    data () &#123;
        return &#123;
        deviceF: true,
        &#125;
    &#125;
&#125;
 &lt;/script&gt;
</code></pre>
<pre><code class="vue">&lt;template&gt;
   &lt;div&gt;
       &#123;&#123;device&#125;&#125;
       &lt;button @click=&quot;look&quot;&gt;改变值&lt;/button&gt;
   &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
 data () &#123;
   return &#123;
     device: this.value,  //定义一下
   &#125;
 &#125;,
 props: [&#39;value&#39;],//因为想要改变device，所以device要写成value，这里是写死的
 components: &#123;
 &#125;,
 methods: &#123;
   look () &#123;
     this.device = !this.device
     this.$emit(&#39;input&#39;, this.device)  //这样this.device就会被修改；前面的input是固定写死的
   &#125;
 &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？"><a href="#♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？" class="headerlink" title="♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？"></a>♥︎♥︎♥︎♥︎Vuex刷新页面数据会丢失吗？咋解决的？</h3><p>1、问题描述：页面刷新的时候vuex里的数据会重新初始化，导致数据丢失。因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被重新赋值。</p>
<p>2、解决思路：</p>
<p>办法一：将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie） </p>
<p>办法二：在页面刷新的时候再次请求远程数据，使之动态更新vuex数据 办法三：在父页面向后台请求远程数据，并且在页面刷新前将vuex的数据先保存至sessionStorage（以防请求数据量过大页面加载时拿不到返回的数据）</p>
<p>3、 解决过程：</p>
<p>3.1、选择合适的浏览器存储</p>
<p>3.2、解决方案由于state里的数据是响应式，所以sessionStorage存储也要跟随变化，而且只能通过mutations来改变state中的值。 首先在用户登录成功之后，然后把用户信息，菜单信息通过actions分发保存至vuex中。然后在菜单页面计算vuex中state的菜单数据，将数据解析组装成前端组件所需的格式，然后渲染组件，生成菜单树。如果页面没有刷新，则一切正常。</p>
<p>监听浏览器刷新前事件，在浏览器刷新之前就把vuex里的数据保存至sessionStorage中，刷新成功后如果异步请求的数据还没返回则直接获取sessionStorage里的数据，否则获取vuex里的数据。</p>
<h3 id="♥︎♥︎♥︎♥︎什么是Vue-nextTick-？"><a href="#♥︎♥︎♥︎♥︎什么是Vue-nextTick-？" class="headerlink" title="♥︎♥︎♥︎♥︎什么是Vue.nextTick()？"></a>♥︎♥︎♥︎♥︎什么是Vue.nextTick()？</h3><p>$nextTick 是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM，意思是 等你dom加载完毕以后再去调用nextTick()里面的数据内容</p>
<hr>
<h3 id="♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object-defineProperty优劣对比？"><a href="#♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object-defineProperty优劣对比？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object.defineProperty优劣对比？"></a>♥︎♥︎♥︎♥︎♥︎你知道Vue响应式数据原理吗？Proxy与Object.defineProperty优劣对比？</h3><p>1、响应式原理</p>
<p>vue的响应式实现主要是利用了Object.defineProperty的方法里面的setter 与getter方法的观察者模式来实现。在组件初始化时会给每一个data属性注册getter和setter，然后再new 一个自己的Watcher对象，此时watcher会立即调用组件的render函数去生成虚拟DOM。在调用render的时候，就会需要用到data的属性值，此时会触发getter函数，将当前的Watcher函数注册进sub里。当data属性发生改变之后，就会遍历sub里所有的watcher对象，通知它们去重新渲染组件。</p>
<p>2、proxy的优势如下：</p>
<p>Proxy 可以直接监听对象而非属性，可以直接监听数组的变化；</p>
<p>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是</p>
<p>Object.defineProperty 不具备的；</p>
<p>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</p>
<p>3、Object.defineProperty 的优势如下:</p>
<p>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill(垫片)来弥补</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-vue-router路由实现原理"><a href="#♥︎♥︎♥︎♥︎♥︎-vue-router路由实现原理" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ vue-router路由实现原理"></a>♥︎♥︎♥︎♥︎♥︎ vue-router路由实现原理</h3><p>[vue-router路由模式]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43638968/article/details/109303363">https://blog.csdn.net/weixin_43638968/article/details/109303363</a>  “</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-Vue3中的双向数据绑定proxy"><a href="#♥︎♥︎♥︎♥︎♥︎-Vue3中的双向数据绑定proxy" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ Vue3中的双向数据绑定proxy"></a>♥︎♥︎♥︎♥︎♥︎ Vue3中的双向数据绑定proxy</h3><p>Proxy相当于在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy是Object.defineProperty的全方位加强版，它解决了之前defineProperty无法监听到数组变化等缺点。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-Vue和React中diff算法区别"><a href="#♥︎♥︎♥︎♥︎♥︎-Vue和React中diff算法区别" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ Vue和React中diff算法区别"></a>♥︎♥︎♥︎♥︎♥︎ Vue和React中diff算法区别</h3><p>vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。</p>
<p>1.vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。</p>
<p>2.vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎Vue-响应式原理"><a href="#♥︎♥︎♥︎♥︎♥︎Vue-响应式原理" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎Vue 响应式原理"></a>♥︎♥︎♥︎♥︎♥︎Vue 响应式原理</h3><p>[Vue 响应式原理]: 	“<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903561327820808">https://juejin.cn/post/6844903561327820808</a> “</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"><a href="#♥︎♥︎♥︎♥︎♥︎-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"></a>♥︎♥︎♥︎♥︎♥︎ nextTick知道吗、实现的原理是什么？是宏任务还是微任务？</h3><p>微任务</p>
<p>原理：nextTick方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空队列。</p>
<p>作用： nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick,则可以在回调中获取更新后的DOM。</p>
<h3 id="♥︎♥︎♥︎♥︎♥︎-Vue项目常见优化点"><a href="#♥︎♥︎♥︎♥︎♥︎-Vue项目常见优化点" class="headerlink" title="♥︎♥︎♥︎♥︎♥︎ Vue项目常见优化点"></a>♥︎♥︎♥︎♥︎♥︎ Vue项目常见优化点</h3><p>1、首屏加载优化</p>
<p>2、路由懒加载</p>
<pre><code class="javascript">&#123; 
 path: &#39;/&#39;,
 name: &#39;home&#39;, 
 component: () =&gt; import(&#39;./views/home/index.vue&#39;), 
 meta: &#123; isShowHead: true &#125;
&#125;
</code></pre>
<p>3、开启服务器 Gzip</p>
<p>开启 Gzip 就是一种压缩技术，需要前端提供压缩包，然后在服务器开启压缩，文件在服务器压缩后传给浏览器，浏览器解压后进行再进行解析。首先安装 webpack 提供的compression-webpack-plugin进行压缩,然后在 vue.config.js：</p>
<pre><code class="javascript">const CompressionWebpackPlugin = require(&#39;compression-webpack-plugin&#39;)
const productionGzipExtensions = [&#39;js&#39;, &#39;css&#39;]......plugins: [ 
 new CompressionWebpackPlugin(
 &#123; 
 algorithm: &#39;gzip&#39;, 
 test: new RegExp(&#39;\.(&#39; + productionGzipExtensions.join(&#39;|&#39;) + &#39;)$&#39;), 
 threshold: 10240, 
 minRatio: 0.8 
 &#125;
)]....
</code></pre>
<p>4、启动 CDN 加速</p>
<p>我们继续采用 cdn 的方式来引入一些第三方资源，就可以缓解我们服务器的压力，原理是将我们的压力分给其他服务器点。</p>
<p>5、代码层面优化</p>
<p>computed 和 watch 区分使用场景</p>
<p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>
<p> watch：类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<p>v-if 和 v-show 区分使用场景 v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景。这里要说的优化点在于减少页面中 dom 总数，我比较倾向于使用 v-if，因为减少了 dom 数量。</p>
<p>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if v-for 遍历必须为 item 添加 key，循环调用子组件时添加 key，key 可以唯一标识一个循环个体，可以使用例如 item.id 作为 key 避免同时使用 v-if，vfor 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度。</p>
<p>6、Webpack 对图片进行压缩</p>
<p>7、避免内存泄漏</p>
<p>8、减少 ES6 转为 ES5 的冗余代码</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mengfeng.github.io/2022/10/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8Vue-Vue3/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/10/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8React/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            前端面试大全React
          
        </div>
      </a>
    
    
      <a href="/2022/10/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8javaScript/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">前端面试大全javaScript</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '6887374e7666a97fd4dc',
    clientSecret: '09a8e143dd4a3f5d11311e1435842321e063157d',
    repo: 'mengfeng.github.io',
    owner: 'mengfeng',
    admin: ['mengfeng'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>