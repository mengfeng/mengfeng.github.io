<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-什么是CI-CD"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/12/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/"
    >什么是CI/CD</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/12/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/" class="article-date">
  <time datetime="2022-11-12T05:05:01.000Z" itemprop="datePublished">2022-11-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CI-CD/">CI/CD</a> / <a class="article-category-link" href="/categories/CI-CD/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/">什么是CI/CD</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="CI-x2F-CD是什么？如何理解持续集成、持续交付和持续部署"><a href="#CI-x2F-CD是什么？如何理解持续集成、持续交付和持续部署" class="headerlink" title="CI&#x2F;CD是什么？如何理解持续集成、持续交付和持续部署"></a>CI&#x2F;CD是什么？如何理解持续集成、持续交付和持续部署</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>CI&#x2F;CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI&#x2F;CD 的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI&#x2F;CD 主要针对在集成新代码时所引发的问题（亦称：”集成地狱”）。</p>
<p>具体而言，CI&#x2F;CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为”CI&#x2F;CD 管道”，由开发和运维团队以敏捷方式协同支持。</p>
<h3 id="CI-是什么？CI-和-CD-有什么区别？"><a href="#CI-是什么？CI-和-CD-有什么区别？" class="headerlink" title="CI 是什么？CI 和 CD 有什么区别？"></a>CI 是什么？CI 和 CD 有什么区别？</h3><p>缩略词 CI &#x2F; CD 具有几个不同的含义。CI&#x2F;CD 中的”CI”始终指持续集成，它属于开发人员的自动化流程。成功的 CI 意味着应用代码的新更改会定期构建、测试并合并到共享存储库中。该解决方案可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题。</p>
<p>CI&#x2F;CD 中的”CD”指的是持续交付和&#x2F;或持续部署，这些相关概念有时会交叉使用。两者都事关管道后续阶段的自动化，但它们有时也会单独使用，用于说明自动化程度。</p>
<p>持续<em>交付</em>通常是指开发人员对应用的更改会自动进行错误测试并上传到存储库（如 GitHub或容器注册表），然后由运维团队将其部署到实时生产环境中。这旨在解决开发和运维团队之间可见性及沟通较差的问题。因此，持续交付的目的就是确保尽可能减少部署新代码时所需的工作量。</p>
<p>持续<em>部署</em>（另一种”CD”）指的是自动将开发人员的更改从存储库发布到生产环境，以供客户使用。它主要为了解决因手动流程降低应用交付速度，从而使运维团队超负荷的问题。持续部署以持续交付的优势为根基，实现了管道后续阶段的自动化。</p>
<p><img src="/2022/11/12/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/ci-cd-flow-desktop_edited_0.png" alt="CI/CD flow"></p>
<p>CI&#x2F;CD 既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这三项构成的关联环节。更为复杂的是，有时”持续交付”也包含了持续部署流程。</p>
<p>归根结底，我们没必要纠结于这些语义，您只需记得 CI&#x2F;CD 其实就是一个流程（通常形象地表述为管道），用于实现应用开发中的高度持续自动化和持续监控。因案例而异，该术语的具体含义取决于 CI&#x2F;CD 管道的自动化程度。许多企业最开始先添加 CI，然后逐步实现交付和部署的自动化（例如作为云原生应用的一部分）。</p>
<h3 id="CI-持续集成（Continuous-Integration）"><a href="#CI-持续集成（Continuous-Integration）" class="headerlink" title="CI 持续集成（Continuous Integration）"></a>CI 持续集成（Continuous Integration）</h3><p>现代应用开发的目标是让多位开发人员同时处理同一应用的不同功能。但是，如果企业安排在一天内将所有分支源代码合并在一起（称为”合并日”），最终可能造成工作繁琐、耗时，而且需要手动完成。这是因为当一位独立工作的开发人员对应用进行更改时，有可能会与其他开发人员同时进行的更改发生冲突。如果每个开发人员都自定义自己的本地集成开发环境（IDE），而不是让团队就一个基于云的 IDE 达成一致，那么就会让问题更加雪上加霜。</p>
<p>持续集成（CI）可以帮助开发人员更加频繁地（有时甚至每天）将代码更改合并到共享分支或”主干”中。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。这意味着测试内容涵盖了从类和函数到构成整个应用的不同模块。如果自动化测试发现新代码和现有代码之间存在冲突，CI 可以更加轻松地快速修复这些错误。</p>
<h3 id="CD-持续交付（Continuous-Delivery）"><a href="#CD-持续交付（Continuous-Delivery）" class="headerlink" title="CD 持续交付（Continuous Delivery）"></a>CD 持续交付（Continuous Delivery）</h3><p>完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。</p>
<p>在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。</p>
<h3 id="CD-持续部署（Continuous-Deployment）"><a href="#CD-持续部署（Continuous-Deployment）" class="headerlink" title="CD 持续部署（Continuous Deployment）"></a>CD 持续部署（Continuous Deployment）</h3><p>对于一个成熟的 CI&#x2F;CD 管道来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的测试自动化。</p>
<p>实际上，持续部署意味着开发人员对应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI&#x2F;CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。不过，由于还需要编写自动化测试以适应 CI&#x2F;CD 管道中的各种测试和发布阶段，因此前期投资还是会很大。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CI-CD/" rel="tag">CI&#x2F;CD</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-docker入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/11/docker%E5%85%A5%E9%97%A8/"
    >docker入门</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/11/docker%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2022-11-11T04:17:53.000Z" itemprop="datePublished">2022-11-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a> / <a class="article-category-link" href="/categories/Docker/docker%E5%85%A5%E9%97%A8/">docker入门</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="docker入门"><a href="#docker入门" class="headerlink" title="docker入门"></a>docker入门</h1><h3 id="一、docker安装"><a href="#一、docker安装" class="headerlink" title="一、docker安装"></a>一、docker安装</h3><p>目前我们只是基于macos环境下的安装和学习</p>
<p>（很多平台都是windows的）</p>
<h4 id="1-docker下载"><a href="#1-docker下载" class="headerlink" title="1.docker下载"></a>1.docker下载</h4><p>直接去Docker官网去下载对应的版本就可以了（官网地址：<a target="_blank" rel="noopener" href="https://dockerdocs.cn/%EF%BC%89">https://dockerdocs.cn/）</a></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109091347433.png"></p>
<p>选择对应inter芯片或者m1和m2芯片的docker版本就可以</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109091446299.png"></p>
<h4 id="2-设置国内镜像源"><a href="#2-设置国内镜像源" class="headerlink" title="2.设置国内镜像源"></a>2.设置国内镜像源</h4><p>在国内使用docker拉取镜像会非常的慢，所以一定得设置国内镜像源。</p>
<p>设置镜像源在设置里的Docker Engine</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109094123087.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器：点击管理控制台-&gt;登陆账号（淘宝账号）-&gt;右侧镜像工具-&gt;镜像加速器-&gt;拷贝镜像链接</a></p>
<p>网易云加速器：<a target="_blank" rel="noopener" href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></p>
<p>百度云加速器：<a target="_blank" rel="noopener" href="https://mirror.baidubce.com/">https://mirror.baidubce.com</a></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109095852276.png"></p>
<p>配置完成后，查看是否配置成功</p>
<pre><code class="ini">docker info 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109100105080.png"></p>
<p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 Nginx 服务器</p>
<pre><code class="ini">docker run -d -p 80:80 --name webserver nginx
</code></pre>
<p>服务运行后，可以访问 <a target="_blank" rel="noopener" href="http://localhost,如果看到了/">http://localhost，如果看到了</a> “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109101903810.png"></p>
<pre><code class="ini">docker ps -a //查看所有的容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102114729.png"></p>
<pre><code class="ini">docker stop webserver //停止容器服务
docker rm webserver //删除容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102355610.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102417586.png"></p>
<h3 id="二、docker镜像"><a href="#二、docker镜像" class="headerlink" title="二、docker镜像"></a>二、docker镜像</h3><h4 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1.获取镜像"></a>1.获取镜像</h4><p><a target="_blank" rel="noopener" href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p>
<pre><code class="ini">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] //获取镜像命令格式
docker pull ubuntu:18.04 //具体一点
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103151217.png"></p>
<p>查看下载镜像</p>
<pre><code class="ini">docker images -a //查看所有镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103328637.png"></p>
<p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p>
<pre><code class="ini">docker run -it --rm ubuntu:18.04 bash
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103803885.png"></p>
<p><code>docker run</code> 就是运行容器的命令，具体格式我们会在容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p>
<p>最后我们通过 <code>exit</code> 退出了这个容器。</p>
<h4 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2.列出镜像"></a>2.列出镜像</h4><pre><code class="ini">docker image ls //列出所有下载的镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109104611497.png"></p>
<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<p><code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<pre><code class="ini">docker system df //便捷的查看镜像、容器、数据卷所占用的空间
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109104851278.png" alt="image-20221109104851278"></p>
<pre><code class="ini">docker image ls ubuntu //列出部分镜像
docker image ls ubuntu:18.04 //列出特定的某个镜像，也就是说指定仓库名和标签
</code></pre>
<p>docker image ls<code>还支持强大的过滤器参数</code>–filter<code>，或者简写 </code>-f，之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>nginx</code> 之后建立的镜像，可以用下面的命令：</p>
<pre><code class="ini">docker image ls -f since=nginx
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105424883.png"></p>
<p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可</p>
<pre><code class="ini">docker image ls -q //以特定格式显示
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105634317.png"></p>
<pre><code class="ini">docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot; //直接列出镜像结果，并且只包含镜像ID和仓库名
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105755189.png"></p>
<pre><code class="ini">docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot; //以表格等距显示，并且有标题行，和默认一样，不过自己定义列
</code></pre>
<h4 id="3-删除镜像"><a href="#3-删除镜像" class="headerlink" title="3.删除镜像"></a>3.删除镜像</h4><pre><code class="ini">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] //删除镜像命令格式
</code></pre>
<p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code></p>
<p>我们先列出我们下载的所有镜像</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109110129824.png"></p>
<pre><code class="ini">docker image rm afb //删除redis镜像
docker image ls //查看所有镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109110407331.png"></p>
<p>发现已经删除了指定镜像</p>
<pre><code class="ini">docker image rm $(docker image ls -q redis) //组合命令使用
</code></pre>
<p>充分利用你的想象力和 Linux 命令行的强大</p>
<h3 id="三、docker容器"><a href="#三、docker容器" class="headerlink" title="三、docker容器"></a>三、docker容器</h3><h4 id="1-启动容器"><a href="#1-启动容器" class="headerlink" title="1.启动容器"></a>1.启动容器</h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<pre><code class="ini">docker run ubuntu:18.04 /bin/echo &#39;Hello world&#39; //执行后命令后终止容器
</code></pre>
<pre><code class="ini">docker run -t -i ubuntu:18.04 /bin/bash //保持交互
</code></pre>
<p><code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110081411097.png"></p>
<p>Docker run创建容器时，docker的标准操作</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 registry下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<pre><code class="ini">docker start 9a115164bf87//启动一个终止（exited）的容器
</code></pre>
<pre><code class="ini">docker ps -a//查看所有容器信息
docker logs 9a115164bf87//获取容器输出信息
</code></pre>
<h4 id="2-终止容器"><a href="#2-终止容器" class="headerlink" title="2.终止容器"></a>2.终止容器</h4><pre><code class="ini">docker stop (ID) //终止容器
docker ps //查看启动容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110083759963.png"></p>
<h4 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3.进入容器"></a>3.进入容器</h4><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台</p>
<p><code>docker attach</code> 命令或 <code>docker exec</code> 命令都可以进入容器，推荐大家使用 <code>docker exec</code> 命令</p>
<pre><code class="ini">docker attach (ID) //会导致容器的终止
</code></pre>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符</p>
<pre><code class="ini">docker exec -i 4e56f70383c9 /bin/bash 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110084917152.png"></p>
<pre><code class="ini">docker exec -it 4e56f70383c9 /bin/bash //不会导致容器的终止
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110085014483.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110085250397.png"></p>
<pre><code class="ini">docker exec --help //查看更多参数
</code></pre>
<h4 id="4-导入和导出"><a href="#4-导入和导出" class="headerlink" title="4.导入和导出"></a>4.导入和导出</h4><pre><code class="ini">docker export 4e56f70383c9 &gt; ubuntu.tar //导出容器快照到本地文件
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110090757653.png"></p>
<pre><code class="ini">cat nginx.tar | docker import - test/nginx //从容器快照文件中再导入为镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110092840790.png"></p>
<p>用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<h4 id="5-删除容器"><a href="#5-删除容器" class="headerlink" title="5.删除容器"></a>5.删除容器</h4><pre><code class="ini">docker rm (ID or Name) //删除一个处于终止状态的容器
</code></pre>
<p>删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器</p>
<pre><code class="ini">sudo docker rm $(sudo docker ps -a -q) //删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了）
</code></pre>
<h3 id="四、访问仓库"><a href="#四、访问仓库" class="headerlink" title="四、访问仓库"></a>四、访问仓库</h3><h4 id="1-Docker-Hub"><a href="#1-Docker-Hub" class="headerlink" title="1.Docker Hub"></a>1.Docker Hub</h4><p>Docker 官方维护了一个公共仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 <a target="_blank" rel="noopener" href="https://hub.docker.com/search/?type=image">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<p>注册一个docker账号</p>
<blockquote>
<p>在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号</p>
</blockquote>
<p>登陆</p>
<blockquote>
<p>1.可以在docker App上登陆dockr账号（会跳转到 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> ）</p>
<p>2.通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <code>docker logout</code> 退出登录。</p>
</blockquote>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110094750263.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110094815601.png"></p>
<p>拉取镜像</p>
<blockquote>
<p>可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地</p>
</blockquote>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110095756575.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110095822481.png"></p>
<p>推送镜像</p>
<blockquote>
<p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub</p>
</blockquote>
<pre><code class="ini">docker tag ubuntu:18.04 username/ubuntu:18.04 //username 请替换为你的 Docker 账号用户名
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110100404351.png"></p>
<p>自动化构建</p>
<p>自动构建（<code>Automated Builds</code>）可以自动触发构建镜像，方便升级镜像。</p>
<p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p>
<p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a target="_blank" rel="noopener" href="https://github.com/">GitHub</a> 或 <a target="_blank" rel="noopener" href="https://bitbucket.org/">BitBucket</a>）上的项目，一旦项目发生新的提交 （<code>commit</code>）或者创建了新的标签（<code>tag</code>），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动构建，包括如下的步骤：</p>
<p>- </p>
<p>  登录 Docker Hub；</p>
<p>- </p>
<p>  在 Docker Hub 点击右上角头像，在账号设置（<code>Account Settings</code>）中关联（<code>Linked Accounts</code>）目标网站；</p>
<p>- </p>
<p>  在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</p>
<p>- </p>
<p>  选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</p>
<p>- </p>
<p>  指定 <code>Dockerfile</code> 的位置，并保存。</p>
<p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p>
<p>（‼️这个需要付钱）</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110101243394.png"></p>
<h4 id="2-私有仓库"><a href="#2-私有仓库" class="headerlink" title="2.私有仓库"></a>2.私有仓库</h4><p>安装运行 docker-registry</p>
<pre><code class="ini">docker run -d -p 5000:5000 --restart=always --name registry registry //使用官方 registry 镜像来运行
</code></pre>
<p>如果报错端口不可用</p>
<pre><code class="ini">docker run -d -p 8080:8080 --restart=always --name registry registry //删除原来容器，重新创建
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110104412354.png"></p>
<p>在私有仓库上传、搜索、下载镜像</p>
<pre><code class="ini">docker tag ubuntu:latest alan0924/ubuntu:latest //将 ubuntu:latest 这个镜像标记为 alan0924/ubuntu:latest
docker image ls //查看所有镜像
docker push alan0924/ubuntu:latest //上传私有仓库
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110105039054.png"></p>
<p>删除已有镜像，再尝试从私有仓库中下载这个镜像</p>
<pre><code class="ini">docker image rm alan0924/ubuntu:latest
docker image ls
docker pull  alan0924/ubuntu:latest
docker image ls 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110110006213.png"></p>
<p>这是我们docker的私有仓库</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110111655879.png"></p>
<h3 id="五、数据管理"><a href="#五、数据管理" class="headerlink" title="五、数据管理"></a>五、数据管理</h3><h4 id="1-数据卷"><a href="#1-数据卷" class="headerlink" title="1.数据卷"></a>1.数据卷</h4><pre><code class="ini">docker volume create my-vol //创建一个数据卷
docker volume ls //查看所有的数据卷
docker volume inspect my-vol //主机里使用以下命令可以查看指定 数据卷 的信息
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110163653187.png"></p>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<pre><code class="ini">//启动一个挂载数据卷的容器
docker run -d -P \
    --name web \
    --mount source=my-vol,target=/usr/share/nginx/html \
    nginx:alpine
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164146345.png"></p>
<pre><code class="ini">docker inspect web //查看数据卷的具体信息
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164302235.png"></p>
<pre><code class="ini">docker volume rm my-vol //删除数据卷
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164601907.png"></p>
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令</p>
<p>无主的数据卷可能会占据很多空间,要清理请使用以下命令</p>
<pre><code class="ini">docker volume prune
</code></pre>
<h3 id="六、访问网络"><a href="#六、访问网络" class="headerlink" title="六、访问网络"></a>六、访问网络</h3><h4 id="1-外部访问容器"><a href="#1-外部访问容器" class="headerlink" title="1.外部访问容器"></a>1.外部访问容器</h4><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker ps</code> 可以看到，本地主机的 55000 被映射到了容器的 80 端口。此时访问本机的 55000 端口即可访问容器内 NGINX 默认页面。</p>
<pre><code class="ini">docker run -d -P nginx:alpine // 
docker logs 75bbd0b01745 //查看日志
</code></pre>
<p>-p<code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。</code> </p>
<p> <code>支持的格式有 </code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111102609943.png"></p>
<p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p>
<pre><code class="ini">docker run -d -p 80:80 nginx:alpine //映射所有接口地址,此时默认会绑定本地所有接口上的所有地址。
</code></pre>
<p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<pre><code class="ini">docker run -d -p 127.0.0.1:80:80 nginx:alpine //映射到指定地址的指定端口,
</code></pre>
<p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<pre><code class="ini">docker run -d -p 127.0.0.1::80 nginx:alpine //映射到指定地址的任意端口
</code></pre>
<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<pre><code class="ini">docker run -d -p 127.0.0.1:80:80/udp nginx:alpine 
</code></pre>
<p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<pre><code class="ini">docker port 75b 80 //查看映射端口配置
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111103203892.png"></p>
<ul>
<li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li>
<li><code>-p</code> 标记可以多次使用来绑定多个端口</li>
</ul>
<pre><code class="ini">docker run -d \
    -p 80:80 \
    -p 443:443 \
    nginx:alpine
</code></pre>
<h4 id="2-容器互联"><a href="#2-容器互联" class="headerlink" title="2.容器互联"></a>2.容器互联</h4><p>新建网络</p>
<pre><code class="ini">docker network create -d bridge my-net //创建一个新的 Docker 网络
</code></pre>
<p>连接容器</p>
<pre><code class="ini">docker run -it --rm --name busybox1 --network my-net busybox sh //运行一个容器并连接到新建的 my-net 网络
</code></pre>
<pre><code class="ini">docker run -it --rm --name busybox2 --network my-net busybox sh //打开新的终端，再运行一个容器并加入到 my-net 网络
</code></pre>
<pre><code class="ini">docker ps //再打开一个新的终端查看容器信息
</code></pre>
<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<pre><code class="ini">/ # ping busybox2
PING busybox2 (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms
64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms
</code></pre>
<p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code></p>
<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到</p>
<pre><code class="ini">/ # ping busybox1
PING busybox1 (172.19.0.2): 56 data bytes
64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms
64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111104242497.png"></p>
<p><code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<h3 id="七、Docker-Compose"><a href="#七、Docker-Compose" class="headerlink" title="七、Docker Compose"></a>七、Docker Compose</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p><code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用</p>
<pre><code class="ini">docker-compose --version
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111110532499.png"></p>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><ul>
<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</li>
</ul>
<p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>
<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p>
<pre><code class="python">//app.py
from flask import Flask
from redis import Redis

app = Flask(__name__)
redis = Redis(host=&#39;redis&#39;, port=6379)

@app.route(&#39;/&#39;)
def hello():
    count = redis.incr(&#39;hits&#39;)
    return &#39;Hello World! 该页面已被访问 &#123;&#125; 次。\n&#39;.format(count)

if __name__ == &quot;__main__&quot;:
    app.run(host=&quot;0.0.0.0&quot;, debug=True)
</code></pre>
<pre><code class="javascript">//docker-compose.yml
version: &#39;3&#39;
services:

  web:
    build: .
    ports:
     - &quot;5500:5500&quot;

  redis:
    image: &quot;redis:alpine&quot;
</code></pre>
<pre><code class="javascript">//Dockerfile
FROM python:3.6-alpine
ADD . /code
WORKDIR /code
RUN pip install redis flask
CMD [&quot;python&quot;, &quot;app.py&quot;]
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111112418983.png"></p>
<pre><code class="ini">docker-compose up //运行 compose 项目
</code></pre>
<p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>
<h4 id="3-命令说明"><a href="#3-命令说明" class="headerlink" title="3.命令说明"></a>3.命令说明</h4><p>命令对象与格式</p>
<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<p>docker-compose [-f&#x3D;<arg>…] [options] [COMMAND] [ARGS…]</p>
<p>命令选项</p>
<p>- </p>
<p>  <code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</p>
<p>- </p>
<p>  <code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</p>
<p>- </p>
<p>  <code>--verbose</code> 输出更多调试信息。</p>
<p>- </p>
<p>  <code>-v, --version</code> 打印版本并退出。</p>
<p>命令使用说明</p>
<p><code>build</code></p>
<p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>
<p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p>
<p>选项包括：</p>
<ul>
<li><code>--force-rm</code> 删除构建过程中的临时容器。</li>
<li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li>
<li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li>
</ul>
<p><code>config</code></p>
<p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<p><code>down</code></p>
<p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<p><code>exec</code></p>
<p>进入指定的容器。</p>
<p><code>help</code></p>
<p>获得一个命令的帮助。</p>
<p><code>images</code></p>
<p>列出 Compose 文件中包含的镜像。</p>
<p><code>kill</code></p>
<p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p>
<p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p>
<pre><code class="ini">docker-compose kill -s SIGINT
</code></pre>
<p><code>logs</code></p>
<p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p>
<p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p>
<p>该命令在调试问题的时候十分有用。</p>
<p><code>pause</code></p>
<p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p>
<p>暂停一个服务容器。</p>
<p><code>port</code></p>
<p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p>
<p>打印某个容器端口所映射的公共端口。</p>
<p>选项：</p>
<ul>
<li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li>
<li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li>
</ul>
<p><code>ps</code></p>
<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<p><code>pull</code></p>
<p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p>
<p>拉取服务依赖的镜像。</p>
<p>选项：</p>
<ul>
<li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li>
</ul>
<p><code>push</code></p>
<p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<p><code>restart</code></p>
<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<p><code>rm</code></p>
<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<p><code>run</code></p>
<p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p>
<p>在指定服务上执行一个命令。</p>
<p>例如：</p>
<pre><code class="ini">docker-compose run ubuntu ping docker.com
</code></pre>
<p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<ul>
<li>给定命令将会覆盖原有的自动运行命令；</li>
<li>不会自动创建端口，以避免冲突。</li>
</ul>
<p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p>
<pre><code class="ini">docker-compose run --no-deps web python manage.py shell
</code></pre>
<p>将不会启动 web 容器所关联的其它容器。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 后台运行容器。</li>
<li><code>--name NAME</code> 为容器指定一个名字。</li>
<li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li>
<li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li>
<li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li>
<li><code>--no-deps</code> 不自动启动关联的服务容器。</li>
<li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li>
<li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li>
<li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li>
<li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li>
</ul>
<p><code>scale</code></p>
<p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p>
<p>设置指定服务运行的容器个数。</p>
<p>通过 <code>service=num</code> 的参数来设置数量。例如：</p>
<pre><code class="ini">docker-compose scale web=3 db=2
</code></pre>
<p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p>
<p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>start</code></p>
<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<p><code>stop</code></p>
<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>top</code></p>
<p>查看各个服务容器内运行的进程。</p>
<p><code>unpause</code></p>
<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<p><code>up</code></p>
<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 在后台运行服务容器。</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像。</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>version</code></p>
<p>格式为 <code>docker-compose version</code>。</p>
<p>打印版本信息。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-表白爱心biu"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/11/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/"
    >表白爱心biu</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/11/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/" class="article-date">
  <time datetime="2022-11-11T01:57:54.000Z" itemprop="datePublished">2022-11-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/">趣味技术</a> / <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/">表白爱心biu</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="爱心代码（canvas）"><a href="#爱心代码（canvas）" class="headerlink" title="爱心代码（canvas）"></a>爱心代码（canvas）</h1><p>每天浪漫一点点</p>
<p>发给你女朋友，有奖励🥳</p>
<p><img src="/2022/11/11/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/image-20221111095138378.png"></p>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;玥小公主爱心&lt;/title&gt;

    &lt;style&gt;
      html,
      body &#123;
        height: 100%;
        padding: 0;
        margin: 0;
        background: #000;
      &#125;
      canvas &#123;
        width: 100%;
        height: 100%;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;pinkboard&quot;&gt;&lt;/canvas&gt;
    &lt;script&gt;
      /*
       * 参数配置
       */
      var settings = &#123;
        particles: &#123;
          length: 500, // 最大颗粒量
          duration: 2, // 粒子持续时间（秒）
          velocity: 110, // 粒子范围（像素/秒）
          effect: -1.0, // 内轮廓
          size: 35, // 颗粒大小（像素）
        &#125;,
      &#125;;

      /*
       * Point class
       */
      var Point = (function () &#123;
        function Point(x, y) &#123;
          this.x = typeof x !== &quot;undefined&quot; ? x : 0;
          this.y = typeof y !== &quot;undefined&quot; ? y : 0;
        &#125;
        Point.prototype.clone = function () &#123;
          return new Point(this.x, this.y);
        &#125;;
        Point.prototype.length = function (length) &#123;
          if (typeof length == &quot;undefined&quot;)
            return Math.sqrt(this.x * this.x + this.y * this.y);
          this.normalize();
          this.x *= length;
          this.y *= length;
          return this;
        &#125;;
        Point.prototype.normalize = function () &#123;
          var length = this.length();
          this.x /= length;
          this.y /= length;
          return this;
        &#125;;
        return Point;
      &#125;)();

      /*
       * Particle class
       */
      var Particle = (function () &#123;
        function Particle() &#123;
          this.position = new Point();
          this.velocity = new Point();
          this.acceleration = new Point();
          this.age = 0;
        &#125;
        Particle.prototype.initialize = function (x, y, dx, dy) &#123;
          this.position.x = x;
          this.position.y = y;
          this.velocity.x = dx;
          this.velocity.y = dy;
          this.acceleration.x = dx * settings.particles.effect;
          this.acceleration.y = dy * settings.particles.effect;
          this.age = 0;
        &#125;;
        Particle.prototype.update = function (deltaTime) &#123;
          this.position.x += this.velocity.x * deltaTime;
          this.position.y += this.velocity.y * deltaTime;
          this.velocity.x += this.acceleration.x * deltaTime;
          this.velocity.y += this.acceleration.y * deltaTime;
          this.age += deltaTime;
        &#125;;
        Particle.prototype.draw = function (context, image) &#123;
          function ease(t) &#123;
            return --t * t * t + 1;
          &#125;
          var size = image.width * ease(this.age / settings.particles.duration);
          context.globalAlpha = 1 - this.age / settings.particles.duration;
          context.drawImage(
            image,
            this.position.x - size / 2,
            this.position.y - size / 2,
            size,
            size
          );
        &#125;;
        return Particle;
      &#125;)();

      /*
       * ParticlePool class
       */
      var ParticlePool = (function () &#123;
        var particles,
          firstActive = 0,
          firstFree = 0,
          duration = settings.particles.duration;

        function ParticlePool(length) &#123;
          // create and populate particle pool
          particles = new Array(length);
          for (var i = 0; i &lt; particles.length; i++)
            particles[i] = new Particle();
        &#125;
        ParticlePool.prototype.add = function (x, y, dx, dy) &#123;
          particles[firstFree].initialize(x, y, dx, dy);

          // handle circular queue
          firstFree++;
          if (firstFree == particles.length) firstFree = 0;
          if (firstActive == firstFree) firstActive++;
          if (firstActive == particles.length) firstActive = 0;
        &#125;;
        ParticlePool.prototype.update = function (deltaTime) &#123;
          var i;

          // update active particles
          if (firstActive &lt; firstFree) &#123;
            for (i = firstActive; i &lt; firstFree; i++)
              particles[i].update(deltaTime);
          &#125;
          if (firstFree &lt; firstActive) &#123;
            for (i = firstActive; i &lt; particles.length; i++)
              particles[i].update(deltaTime);
            for (i = 0; i &lt; firstFree; i++) particles[i].update(deltaTime);
          &#125;

          // remove inactive particles
          while (
            particles[firstActive].age &gt;= duration &amp;&amp;
            firstActive != firstFree
          ) &#123;
            firstActive++;
            if (firstActive == particles.length) firstActive = 0;
          &#125;
        &#125;;
        ParticlePool.prototype.draw = function (context, image) &#123;
          // draw active particles
          if (firstActive &lt; firstFree) &#123;
            for (i = firstActive; i &lt; firstFree; i++)
              particles[i].draw(context, image);
          &#125;
          if (firstFree &lt; firstActive) &#123;
            for (i = firstActive; i &lt; particles.length; i++)
              particles[i].draw(context, image);
            for (i = 0; i &lt; firstFree; i++) particles[i].draw(context, image);
          &#125;
        &#125;;
        return ParticlePool;
      &#125;)();

      /*
       * Putting it all together
       */
      (function (canvas) &#123;
        var context = canvas.getContext(&quot;2d&quot;),
          particles = new ParticlePool(settings.particles.length),
          particleRate =
            settings.particles.length / settings.particles.duration, // particles/sec
          time;

        // get point on heart with -PI &lt;= t &lt;= PI
        function pointOnHeart(t) &#123;
          return new Point(
            160 * Math.pow(Math.sin(t), 3),
            130 * Math.cos(t) -
              50 * Math.cos(2 * t) -
              20 * Math.cos(3 * t) -
              10 * Math.cos(4 * t) +
              25
          );
        &#125;

        // 使用虚拟画布创建粒子图像
        var image = (function () &#123;
          var canvas = document.createElement(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;);
          canvas.width = settings.particles.size;
          canvas.height = settings.particles.size;
          // helper function to create the path
          function to(t) &#123;
            var point = pointOnHeart(t);
            point.x =
              settings.particles.size / 2 +
              (point.x * settings.particles.size) / 450;
            point.y =
              settings.particles.size / 2 -
              (point.y * settings.particles.size) / 450;
            return point;
          &#125;
          // create the path
          context.beginPath();
          var t = -Math.PI;
          var point = to(t);
          context.moveTo(point.x, point.y);
          while (t &lt; Math.PI) &#123;
            t += 0.03; // baby steps!
            point = to(t);
            context.lineTo(point.x, point.y);
          &#125;
          context.closePath();
          // create the fill （更换爱心颜色）
          context.fillStyle = &quot;#ea80b0&quot;;
          context.fill();
          // create the image
          var image = new Image();
          image.src = canvas.toDataURL();
          return image;
        &#125;)();

        // render that thing!
        function render() &#123;
          // next animation frame
          requestAnimationFrame(render);

          // update time（粒子速度）
          var newTime = new Date().getTime() / 1000,
            deltaTime = newTime - (time || newTime);
          time = newTime;

          // clear canvas
          context.clearRect(0, 0, canvas.width, canvas.height);

          // create new particles
          var amount = particleRate * deltaTime;
          for (var i = 0; i &lt; amount; i++) &#123;
            var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
            var dir = pos.clone().length(settings.particles.velocity);
            particles.add(
              canvas.width / 2 + pos.x,
              canvas.height / 2 - pos.y,
              dir.x,
              -dir.y
            );
          &#125;

          // update and draw particles
          particles.update(deltaTime);
          particles.draw(context, image);
        &#125;

        // handle (re-)sizing of the canvas
        function onResize() &#123;
          canvas.width = canvas.clientWidth;
          canvas.height = canvas.clientHeight;
        &#125;
        window.onresize = onResize;

        // delay rendering bootstrap
        setTimeout(function () &#123;
          onResize();
          render();
        &#125;, 10);
      &#125;)(document.getElementById(&quot;pinkboard&quot;));
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%AA%E6%BC%AB%E4%BB%A3%E7%A0%81/" rel="tag">浪漫代码</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何上传npm包"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/"
    >如何上传npm包</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/" class="article-date">
  <time datetime="2022-11-10T07:43:07.000Z" itemprop="datePublished">2022-11-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/npm-yarn/">npm&yarn</a> / <a class="article-category-link" href="/categories/npm-yarn/%E4%B8%8A%E4%BC%A0%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85/">上传自己的npm包</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="如何上传自己的npm包"><a href="#如何上传自己的npm包" class="headerlink" title="如何上传自己的npm包"></a>如何上传自己的npm包</h1><h3 id="一、创建自己的npm账号"><a href="#一、创建自己的npm账号" class="headerlink" title="一、创建自己的npm账号"></a>一、创建自己的npm账号</h3><p>[npm官网]: 	“<a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
<h3 id="二、创建npm包目录"><a href="#二、创建npm包目录" class="headerlink" title="二、创建npm包目录"></a>二、创建npm包目录</h3><pre><code class="ini">mkdir npm-me // 在终端输入以下命令，npm-me为包的目录，可以自己任意取名
cd npm-me // 进入包目录
</code></pre>
<h3 id="三、-编写模块"><a href="#三、-编写模块" class="headerlink" title="三、 编写模块"></a>三、 编写模块</h3><p>在npm-me目录下创建 ifYes.js文件</p>
<pre><code class="javascript">//ifYes.js
exports.ifYes = function() &#123;
    return &quot;If you&#39;re late, your wages will be docked&quot;
&#125;
</code></pre>
<h3 id="四、-初始化包描述文件"><a href="#四、-初始化包描述文件" class="headerlink" title="四、 初始化包描述文件"></a>四、 初始化包描述文件</h3><pre><code class="ini">npm init //初始化会生成package.json文件
</code></pre>
<p>初始化的过程会出现一系列的问题，根据我们自己的情况去选择就可以，如果没有其他要求，回车就可哟</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110143318339.png"></p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110143450471.png"></p>
<h3 id="五、注册包仓库账号"><a href="#五、注册包仓库账号" class="headerlink" title="五、注册包仓库账号"></a>五、注册包仓库账号</h3><pre><code class="ini">npm adduser
</code></pre>
<p>当你没有创建npm账户或者输入错误的账户和密码，都会出现下面的error</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110143800873.png"></p>
<p>这是处理正确的结果（确认的时候需要接收验证码：例30466554）</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110144117450.png"></p>
<h3 id="六、上传包"><a href="#六、上传包" class="headerlink" title="六、上传包"></a>六、上传包</h3><pre><code class="ini">npm publish 包文件夹名字 //上传npm命令格式
</code></pre>
<p>1.为了不出现npm命名冲突，第一个方法是在npm官网查一下，如果重复就需要重新修改一下（现在我的npm包就冲突了）</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110144658634.png"></p>
<p>2.当你上传npm包的时候可能才会发现npm命名冲突</p>
<pre><code class="ini">npm publish . //上传npm包
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110145002168.png"></p>
<p>修改后上传</p>
<pre><code class="javascript">//package.json
&#123;
  &quot;name&quot;: &quot;alan-npm-me&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;If you&#39;re late, your wages will be docked&quot;,
  &quot;main&quot;: &quot;ifYes.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [
    &quot;ifYes&quot;
  ],
  &quot;author&quot;: &quot;alan_mf&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110145126857.png"></p>
<p>上传成功啦啦啦</p>
<p>npm账户上可以看到我们上传的包</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110151414170.png"></p>
<h3 id="七、-更新npm包"><a href="#七、-更新npm包" class="headerlink" title="七、 更新npm包"></a>七、 更新npm包</h3><p>npm包修改后，手动把package.json里的version版本号修改了，或者使用以下命令自动更新版本号，再执行npm publish . 命令就可以了。</p>
<ul>
<li>升级补丁版本号(修改bug)：npm version patch</li>
<li>升级小版本号(新增功能)：npm version minor</li>
<li>升级大版本号(较大改版)：npm version major</li>
</ul>
<pre><code class="ini">npm version patch //补丁
npm publish . //更新npm包
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110151715232.png"></p>
<p>更新成功版本1.0.1</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110151928908.png"></p>
<h3 id="八、-对上传的npm进行测试"><a href="#八、-对上传的npm进行测试" class="headerlink" title="八、 对上传的npm进行测试"></a>八、 对上传的npm进行测试</h3><pre><code class="ini">mkdir npm-me-test //新建目录
cd  npm-me-test //进入目录
</code></pre>
<p>下载我们上传的npm包</p>
<pre><code class="ini">npm init -y //初始化生成package.json文件
npm install alan-npm-me -D
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110153117681.png"></p>
<p>创建test.js文件并编写代码</p>
<pre><code class="javascript">//test.js
const demo = require(&#39;alan-npm-me&#39;);
const res = demo.ifYes();
console.log(res);
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110153427301.png"></p>
<p>目前我们所开发的都是共享的npm包，具有一定的安全性风险，如果用于企业，就会具有一定的风险。企业的限制在于，一方面需要享受模块开发带来的低耦合和项目组织上的好处，另一方面却要考虑到模块保密性的问题。所以，通过NPM共享和发布存在潜在的风险。</p>
<p>为了同时能够享受到NPM上众多的包，同时对自己的包进行保密和限制，现有的解决方案就是企业搭建自己的NPM仓库。局域NPM仓库的搭建方法与搭建镜像站的方式几乎一样，与镜像仓库不同的地方在于，企业局域NPM可以选择不同步官方源仓库中的包，即企业可混合使用官方仓库和局域仓库。</p>
<p>对于企业内部而言，私有的可重用模块可以打包到局域NPM仓库中，这样可以保持更新的中心化，不至于让各个小项目各自维护相同功能的模块，杜绝通过复制粘贴实现代码共享的行为。</p>
<p>链接：</p>
<p>[npm官网]: 	“<a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-yarn命令详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/09/yarn%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"
    >yarn命令详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/09/yarn%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-11-09T07:09:37.000Z" itemprop="datePublished">2022-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/npm-yarn/">npm&yarn</a> / <a class="article-category-link" href="/categories/npm-yarn/yarn%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">yarn常用命令</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="yarn命令详解"><a href="#yarn命令详解" class="headerlink" title="yarn命令详解"></a>yarn命令详解</h1><h3 id="一、yarn安装初始化"><a href="#一、yarn安装初始化" class="headerlink" title="一、yarn安装初始化"></a>一、yarn安装初始化</h3><pre><code class="css">npm i yarn -g #yarn安装
yarn -v #查看版本
yarn init ｜ yarn #初始化，创建package.json文件
yarn init --yes #简写 -y 跳过会话，直接通过默认值生成 package.json
</code></pre>
<h3 id="二、yarn安装依赖"><a href="#二、yarn安装依赖" class="headerlink" title="二、yarn安装依赖"></a>二、yarn安装依赖</h3><pre><code class="css">yarn add webpack@2.3.3 # yarn --save 是 yarn 默认的，默认记录在 package.json dependencies 中
</code></pre>
<pre><code class="css">yarn add webpack --dev # yarn 简写 -D  devDependencies 中
</code></pre>
<pre><code class="css">yarn global add webpack # yarn 安装全局依赖
</code></pre>
<h3 id="三、yarn更新依赖"><a href="#三、yarn更新依赖" class="headerlink" title="三、yarn更新依赖"></a>三、yarn更新依赖</h3><pre><code class="css">yarn upgrade # 升级所有依赖项，不记录在 package.json 中
yarn upgrade webpack # 升级指定包
yarn upgrade --latest # 忽略版本规则，升级到最新版本，并且更新 package.json
</code></pre>
<h3 id="四、yarn移除依赖"><a href="#四、yarn移除依赖" class="headerlink" title="四、yarn移除依赖"></a>四、yarn移除依赖</h3><pre><code class="css">yarn remove webpack # yarn
</code></pre>
<h3 id="五、其他命令"><a href="#五、其他命令" class="headerlink" title="五、其他命令"></a>五、其他命令</h3><pre><code class="css">yarn install # 或者 yarn 在 node_modules 目录安装 package.json 中列出的所有依赖
yarn install --force # 强制下载安装
yarn start # yarn  执行 scripts 下 start 对应的脚本

###用来查看某个模块的最新版本信息
yarn info webpack # yarn
yarn info webpack --json # 输出 json 格式
yarn info webpack readme # 输出 README 部分

yarn list # 列出当前项目的依赖
yarn list --depth=0 # 限制依赖的深度
sudo yarn global list # 列出全局安装的模块

###yarn配置文件
yarn config set key value # 设置
yarn config get key # 读取值
yarn config delete key # 删除
yarn config list # 显示当前配置
yarn config set registry [https://registry.npm.taobao.org](https://links.jianshu.com/go?to=https%3A%2F%2Fregistry.npm.taobao.org) # 设置淘宝镜像

###缓存
sudo yarn cache list # 列出已缓存的每个包
sudo yarn cache dir # 返回 全局缓存位置
sudo yarn cache clean # 清除缓存
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/yarn/" rel="tag">yarn</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-npm命令详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/09/npm%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"
    >npm命令详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/09/npm%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-11-09T07:09:15.000Z" itemprop="datePublished">2022-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/npm-yarn/">npm&yarn</a> / <a class="article-category-link" href="/categories/npm-yarn/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">npm常用命令</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="npm命令详解"><a href="#npm命令详解" class="headerlink" title="npm命令详解"></a>npm命令详解</h1><h3 id="一、npm配置命令"><a href="#一、npm配置命令" class="headerlink" title="一、npm配置命令"></a>一、npm配置命令</h3><pre><code class="css">npm install -g cnpm --registry=https://registry.npm.taobao.org  #通过cnpm使用淘宝镜像
npm config set registry https://registry.npm.taobao.org #将npm设置为淘宝镜像
npm config set registry https://registry.npmjs.org #切换回默认全局镜像
npm config get registry #查看npm镜像设置
npm config list #查看npm配置
cnpm config list #查看cnpm配置
npm -v #查看npm版本
</code></pre>
<p>方便统一和阅读，文中全部使用简写方式。</p>
<blockquote>
<p>-g： 为 –global 的缩写，表示安装到全局目录里<br>-S： 为 –save 的缩写，表示安装的包将写入package.json里面的dependencies<br>-D： 为 –save-dev 的缩写，表示将安装的包将写入packege.json里面的devDependencies<br> i： 为install的缩写，表示安装</p>
</blockquote>
<h3 id="二、npm安装命令"><a href="#二、npm安装命令" class="headerlink" title="二、npm安装命令"></a>二、npm安装命令</h3><pre><code class="css">npm init  # npm 初始化当前目录
npm i  # 安装所有依赖
npm i express  # 安装模块到默认dependencies
npm i express -g  # 会安装到配置的全局目录下
npm i express -S  # 安装包信息将加入到dependencies生产依赖
npm i express -D  # 安装包信息将加入到devDependencies开发依赖
npm i jquery@1.8.3  # 安装jquery指定的1.8.3版本
</code></pre>
<h3 id="三、npm更新命令"><a href="#三、npm更新命令" class="headerlink" title="三、npm更新命令"></a>三、npm更新命令</h3><pre><code class="css">npm update jquery  # 更新最新版本的jquery
npm update jquery@2.1.0  # 更新到指定版本号的jquery
npm install jquery@latest  # 可以直接更新到最后一个新版本
</code></pre>
<h3 id="四、npm卸载命令"><a href="#四、npm卸载命令" class="headerlink" title="四、npm卸载命令"></a>四、npm卸载命令</h3><pre><code class="css">npm uninstall express  # 卸载模块，但不卸载模块留在package.json中的对应信息
npm uninstall express -g  # 卸载全局模块
npm uninstall express --save  # 卸载模块，同时卸载留在package.json中dependencies下的信息
npm uninstall express --save-dev  # 卸载模块，同时卸载留在package.json中devDependencies下的信息
</code></pre>
<h3 id="五、npm查看命令"><a href="#五、npm查看命令" class="headerlink" title="五、npm查看命令"></a>五、npm查看命令</h3><pre><code class="css">npm root  # 查看项目中模块所在的目录
npm root -g  # 查看全局安装的模块所在目录
npm list 或者 npm ls  # 查看本地已安装模块的清单列表
npm view jquery dependencies  # 查看某个包对于各种包的依赖关系
npm view jquery version  # 查看jquery最新的版本号
npm view jquery versions  # 查看所有jquery历史版本号（很实用）
npm view jquery  # 查看最新的jquery版本的信息
npm info jquery  # 查看jquery的详细信息，等同于上面的npm view jquery
npm list jquery 或 npm ls jquery  # 查看本地已安装的jquery的详细信息
npm view jquery repository.url  # 查看jquery包的来源地址
</code></pre>
<h3 id="六、其他命令"><a href="#六、其他命令" class="headerlink" title="六、其他命令"></a>六、其他命令</h3><pre><code class="css">npm cache clean  # 清除npm的缓存
npm prune  # 清除项目中没有被使用的包
npm outdated  # 检查模块是否已经过时
npm repo jquery  # 会打开默认浏览器跳转到github中jquery的页面
npm docs jquery  # 会打开默认浏览器跳转到github中jquery的README.MD文件信息
npm home jquery  # 会打开默认浏览器跳转到github中jquery的主页
</code></pre>
<h3 id="七、package-json字段"><a href="#七、package-json字段" class="headerlink" title="七、package.json字段"></a>七、package.json字段</h3><p>[package.json字段详解]: 	“<a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json">https://docs.npmjs.com/cli/v8/configuring-npm/package-json</a> “</p>
<h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p>[npm官网]: 	“<a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-从0到1搭建自己的脚手架react"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/"
    >从0到1搭建自己的脚手架react</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/" class="article-date">
  <time datetime="2022-11-08T09:16:45.000Z" itemprop="datePublished">2022-11-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/">从0到1搭建自己的脚手架react</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="从0到1搭建自己的脚手架react"><a href="#从0到1搭建自己的脚手架react" class="headerlink" title="从0到1搭建自己的脚手架react"></a>从0到1搭建自己的脚手架react</h1><h3 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1.初始化项目"></a>1.初始化项目</h3><pre><code class="ini">npm init -y
</code></pre>
<p>执行初始化命令之后，会出现package.json文件</p>
<h3 id="2-建立项目目录（基础项目目录）"><a href="#2-建立项目目录（基础项目目录）" class="headerlink" title="2.建立项目目录（基础项目目录）"></a>2.建立项目目录（基础项目目录）</h3><p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108085707668.png"></p>
<h3 id="3-下载依赖"><a href="#3-下载依赖" class="headerlink" title="3.下载依赖"></a>3.下载依赖</h3><p>react</p>
<pre><code class="ini">npm i react react-dom 
</code></pre>
<p>下载babel。babel是javascript编辑器，作用如下：</p>
<ol>
<li>负责把ES6、ES7等高版本js编译成低版本js，供浏览器运行。</li>
<li>负责把react语法（jsx）编译成js。</li>
</ol>
<pre><code class="ini"> npm i @babel/core @babel/cli @babel/preset-env @babel/preset-react --save-dev
</code></pre>
<p>集成webpack。webpack是一个现代JavaScript应用程序的静态模块打包器，现代前端应用很多都是用webpack打包。webpack-dev-server用来搭建一个本地服务，可以热加载前端项目</p>
<pre><code class="ini">npm i webpack webpack-dev-server webpack-cli --save-dev
</code></pre>
<p>webpack集成babel还需要babel-loader，加载html文件还需要插件html-webpack-plugin：</p>
<pre><code class="ini">npm i babel-loader html-webpack-plugin --save-dev
</code></pre>
<h3 id="4-编辑index-html、App-js、index-js"><a href="#4-编辑index-html、App-js、index-js" class="headerlink" title="4.编辑index.html、App.js、index.js"></a>4.编辑index.html、App.js、index.js</h3><pre><code class="html">//index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;root&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="javascript">//App.js
import React from &quot;react&quot;;
class App extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                App
            &lt;/div&gt;
          );
    &#125;
&#125;

export default App
</code></pre>
<pre><code class="javascript">//index.js
import React from &#39;react&#39;;
import &#123; createRoot &#125; from &#39;react-dom/client&#39;;
import App from &#39;./App&#39;;

const root = createRoot(document.getElementById(&#39;root&#39;))
root.render(&lt;App /&gt;)
</code></pre>
<h3 id="5-在根目录下添加-babelrc文件、webpack-config-js文件"><a href="#5-在根目录下添加-babelrc文件、webpack-config-js文件" class="headerlink" title="5.在根目录下添加.babelrc文件、webpack.config.js文件"></a>5.在根目录下添加.babelrc文件、webpack.config.js文件</h3><p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108093539451.png"></p>
<h3 id="6-配置-babelrc、webpack-config-js"><a href="#6-配置-babelrc、webpack-config-js" class="headerlink" title="6.配置.babelrc、webpack.config.js"></a>6.配置.babelrc、webpack.config.js</h3><pre><code class="javascript">//.babelrc
&#123;
    &quot;presets&quot;: [&quot;@babel/preset-env&quot;,&quot;@babel/preset-react&quot;]
&#125;
</code></pre>
<pre><code class="javascript">//webpack.config.js
const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.js&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.m?js/,
                use:&#39;babel-loader&#39;,
                exclude:/node_modules/
            &#125;
        ]
    &#125;,
    //webpack加载html文件需要html-webpack-plugin插件处理。
    //启动webpack-dev-server的时候，会把打包好的js文件，css文件，html文件放在内存里
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;

&#125;
</code></pre>
<h3 id="7-当我们配置好上面的项目了，现在我们就可以运行了"><a href="#7-当我们配置好上面的项目了，现在我们就可以运行了" class="headerlink" title="7.当我们配置好上面的项目了，现在我们就可以运行了"></a>7.当我们配置好上面的项目了，现在我们就可以运行了</h3><p>现在我们还得配置一个小细节package,json</p>
<pre><code class="javascript">&#123;
  &quot;name&quot;: &quot;react-app-start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: &#123;
    //--mode=development为开发环境，速度较快，上线可以配置为生产环境，会压缩，优化代码
    //--watch为监听代码变化，只要代码变化，会重新编译
    //build是生产环境的打包
    &quot;serve&quot;: &quot;webpack --mode=development --watch&quot;,
    &quot;build&quot;: &quot;webpack --mode=production&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: &#123;
    &quot;react&quot;: &quot;^18.2.0&quot;,
    &quot;react-dom&quot;: &quot;^18.2.0&quot;,
    &quot;webpack&quot;: &quot;^5.74.0&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;@babel/cli&quot;: &quot;^7.19.3&quot;,
    &quot;@babel/core&quot;: &quot;^7.20.2&quot;,
    &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;,
    &quot;@babel/preset-react&quot;: &quot;^7.18.6&quot;,
    &quot;babel-loader&quot;: &quot;^9.1.0&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,
    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;
  &#125;
&#125;
</code></pre>
<p>这时候就可以执行命令了</p>
<pre><code class="ini">npm run serve
</code></pre>
<p>打包执行命令</p>
<pre><code class="ini">npm run build
</code></pre>
<h3 id="8-如果没有报错的话，你就会看见下面的页面"><a href="#8-如果没有报错的话，你就会看见下面的页面" class="headerlink" title="8.如果没有报错的话，你就会看见下面的页面"></a>8.如果没有报错的话，你就会看见下面的页面</h3><p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108100300240.png"></p>
<h3 id="9-至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server："><a href="#9-至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server：" class="headerlink" title="9.至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server："></a>9.至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server：</h3><pre><code class="ini">npm i webpack-dev-server --save-dev
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108100733217.png"></p>
<p>执行命令：</p>
<pre><code class="ini">npm run start
</code></pre>
<p>项目在3000端口启动，启动后会自动打开浏览器窗口。热加载配置完成，文件修改保存后浏览器直接展示出来。</p>
<p>到此react项目简化版搭建完成。后续继续集成其他工具库即可。</p>
<h3 id="10-react使用ts"><a href="#10-react使用ts" class="headerlink" title="10.react使用ts"></a>10.react使用ts</h3><p>ts对比js最大的特点就是多了类型检查。推荐前端语言使用ts。接下来介绍在webpack中配置ts。</p>
<p>安装typescript、ts-loader。typescript是ts编辑器，把ts代码编译成js，ts-loader是让webpack识别.ts&#x2F;.tsx文件，调用编译器编译，</p>
<pre><code class="ini">npm i typescript ts-loader --save-dev
</code></pre>
<p>添加ts配置文件,在根目录下添加tsconfig.json：</p>
<pre><code class="ini">//tsconfig.json
&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;es5&quot;,
        &quot;lib&quot;:[&quot;es6&quot;,&quot;dom&quot;],
        &quot;module&quot;: &quot;esnext&quot;,
        &quot;moduleResolution&quot;: &quot;node&quot;,
        &quot;jsx&quot;:&quot;react&quot;,
        &quot;sourceMap&quot;: true,
        &quot;strict&quot;: true,
        &quot;importHelpers&quot;: true,
        &quot;skipLibCheck&quot;: true,
        &quot;allowJs&quot;: true,
        &quot;allowSyntheticDefaultImports&quot;: true
    &#125;
&#125;
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108101701100.png"></p>
<p>修改webpack配置</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.tsx&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.m?js|tsx$/,
                use:&#39;ts-loader&#39;,
                exclude:/node_modules/
            &#125;
        ]
    &#125;,
    //增加扩展选项，让webpack可以识别.ts/tsx文件
    resolve:&#123;
        extensions:[&#39;.ts&#39;,&#39;.tsx&#39;,&#39;.js&#39;]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;

&#125;
</code></pre>
<p>目前可能会报错</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108110219148.png"></p>
<p>根据提示，我们缺一些依赖</p>
<pre><code class="ini">npm i --save-dev @types/react
npm i --save-dev @types/react-dom
</code></pre>
<p>这个时候我们还会遇到一个问题</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108111925911.png"></p>
<p>那么这个问题的原因是缺null类型检测</p>
<p>其他人回答说应该添加null检查，但Typescript也有一个非null断言，当您通过添加！运算符添加到语句末尾：</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108112118833.png"></p>
<p>这个时候我们react使用ts的问题就解决了</p>
<p>启动项目，运行成功，ts集成成功了</p>
<h3 id="11-react集成路由"><a href="#11-react集成路由" class="headerlink" title="11.react集成路由"></a>11.react集成路由</h3><p>安装路由库</p>
<pre><code class="ini">npm install react-router-dom@6
</code></pre>
<p>创建项目目录</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108143446498.png"></p>
<p>编辑About.tsx、Home.tsx、index.tsx、App.tsx</p>
<pre><code class="tsx">//About.tsx
import React from &quot;react&quot;;
import &#123; Link &#125; from &quot;react-router-dom&quot;;

class About extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                this is about&lt;br/&gt;
                &lt;Link to=&#123;&#39;/home&#39;&#125;&gt;to home&lt;/Link&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default About;
</code></pre>
<pre><code class="tsx">//Home.tsx
import React from &quot;react&quot;;
import &#123; Link &#125; from &quot;react-router-dom&quot;;

class Home extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                this is home&lt;br/&gt;
                &lt;Link to=&#123;&#39;/about&#39;&#125;&gt;to about&lt;/Link&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default Home;
</code></pre>
<pre><code class="tsx">//App.tsx
import React from &quot;react&quot;;
import &#123; Routes,Route &#125; from &quot;react-router-dom&quot;;
import About from &quot;./compents/About&quot;;
import Home from &quot;./compents/Home&quot;;

class App extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                &lt;Routes&gt;
                    &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;
                &lt;/Routes&gt;
            &lt;/div&gt;
          );
    &#125;
&#125;

export default App
</code></pre>
<pre><code class="tsx">//index.tsx
import React from &#39;react&#39;;
import &#123; createRoot &#125; from &#39;react-dom/client&#39;;
import App from &#39;./App&#39;;
import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;;

const root = createRoot(document.getElementById(&#39;root&#39;)!)
root.render(
    &lt;BrowserRouter&gt;
        &lt;App /&gt;
    &lt;/BrowserRouter&gt;
)
</code></pre>
<p>react路由搭建成功</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108143901241.png"></p>
<h3 id="12-react使用redux"><a href="#12-react使用redux" class="headerlink" title="12.react使用redux"></a>12.react使用redux</h3><p>对于大型项目来说，数据管理工具也是必不可少的。我们简单介绍redux、react-redux的使用。这里使用的是@reduxjs&#x2F;toolkit库，相比redux库使用方法有很大区别，想用redux库的请自行查看redux文档。</p>
<p>下载依赖</p>
<pre><code class="ini">npm i @reduxjs/toolkit react-redux
</code></pre>
<p>创建项目目录</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108151822086.png"></p>
<p>编辑store.ts、countSlice.ts、counter.tsx、index.tsx、App.tsx</p>
<pre><code class="tsx">//store.ts
import &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;;
import counterReducer from &#39;./countSlice&#39;;

export default configureStore(&#123;
    reducer:&#123;
        counter:counterReducer
    &#125;
&#125;)
</code></pre>
<pre><code class="tsx">//countSlice.ts
import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;

export const counterSlice = createSlice(&#123;
    name:&#39;counter&#39;,
    initialState:&#123;
        value:0
    &#125;,
    reducers:&#123;
        increment:(state) =&gt; &#123;
            state.value += 1
        &#125;,
        decrement:(state) =&gt;&#123;
            state.value -= 1
        &#125;,
        incrementByAmount:(state,action) =&gt; &#123;
            state.value += action.payload
        &#125;
    &#125;
&#125;)

export const &#123; increment,decrement,incrementByAmount &#125; = counterSlice.actions
export default counterSlice.reducer
</code></pre>
<pre><code class="tsx">//index.tsx
import React from &#39;react&#39;;
import &#123; createRoot &#125; from &#39;react-dom/client&#39;;
import App from &#39;./App&#39;;
import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;;
import store  from &#39;./store/store&#39;;
import &#123; Provider &#125; from &#39;react-redux&#39;;

const root = createRoot(document.getElementById(&#39;root&#39;)!)
root.render(
    &lt;BrowserRouter&gt;
    &lt;Provider store=&#123;store&#125;&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;  
    &lt;/BrowserRouter&gt;
)
</code></pre>
<pre><code class="tsx">//counter.tsx
import React from &quot;react&quot;;
import &#123; useSelector,useDispatch &#125; from &quot;react-redux&quot;;
import &#123; decrement,increment &#125; from &quot;../store/countSlice&quot;;

function Counter()&#123;
    const count = useSelector((state:any) =&gt; state.counter.value)
    const dispatch = useDispatch()
    
    return (
        &lt;div&gt;
            &lt;div&gt;
                &lt;button 
                aria-label=&quot;Increment value&quot;
                onClick=&#123;() =&gt; dispatch(increment())&#125;
                &gt;
                    increment
                &lt;/button&gt;
                &lt;span&gt;&#123;count&#125;&lt;/span&gt;
                &lt;button
                aria-label=&quot;Decrement value&quot;
                onClick=&#123;() =&gt; dispatch(decrement())&#125;
                &gt;
                    Decrement
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
&#125;

export default Counter;
</code></pre>
<pre><code class="tsx">//App.tsx
import React from &quot;react&quot;;
import &#123; Routes,Route &#125; from &quot;react-router-dom&quot;;
import About from &quot;./compents/About&quot;;
import Home from &quot;./compents/Home&quot;;
import Counter from &quot;./compents/Counter&quot;;

class App extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                &lt;Routes&gt;
                    &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/counter&quot; element=&#123;&lt;Counter /&gt;&#125;&gt;&lt;/Route&gt;
                &lt;/Routes&gt;
            &lt;/div&gt;
          );
    &#125;
&#125;

export default App
</code></pre>
<p>当我执行命令进入counter组件点击功能按钮就发现redux使用成功了</p>
<pre><code class="ini">npm run start
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108152335825.png"></p>
<h3 id="13-集成UI库"><a href="#13-集成UI库" class="headerlink" title="13.集成UI库"></a>13.集成UI库</h3><p>这里使用的是antd第三方库</p>
<p>安装ui库</p>
<pre><code class="ini">npm i antd
</code></pre>
<p>使用antd还需要引用其样式文件，因此还需要下载css-loader、style-loader。</p>
<pre><code class="ini">npm i style-loader css-loader -D
</code></pre>
<p>修改webpack配置</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.tsx&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.j|tsx$/,
                use:&#39;ts-loader&#39;,
                exclude:/node_modules/
            &#125;,
            &#123;
                test:/.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;
        ]
    &#125;,
    //增加扩展选项，让webpack可以识别.ts/tsx文件
    resolve:&#123;
        extensions:[&#39;.ts&#39;,&#39;.tsx&#39;,&#39;.js&#39;]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;
&#125;
</code></pre>
<p>使用antd的话直接引入使用就可以了</p>
<pre><code class="tsx">//Home.tsx
import React from &quot;react&quot;;
import &#123; Link &#125; from &quot;react-router-dom&quot;;
import &#123; Button &#125; from &quot;antd&quot;;

class Home extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                this is home&lt;br/&gt;
                &lt;Link to=&#123;&#39;/about&#39;&#125;&gt;
                    &lt;Button type=&#123;&#39;primary&#39;&#125;&gt;to about&lt;/Button&gt;
                &lt;/Link&gt;
                &lt;Link to=&#123;&#39;/counter&#39;&#125;&gt;
                    &lt;Button type=&#123;&#39;primary&#39;&#125;&gt;to counter&lt;/Button&gt; 
                &lt;/Link&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default Home;
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108153155300.png"></p>
<h3 id="14-跨域问题"><a href="#14-跨域问题" class="headerlink" title="14.跨域问题"></a>14.跨域问题</h3><p>修改webpack.config.js使用proxy</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.tsx&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.j|tsx$/,
                use:&#39;ts-loader&#39;,
                exclude:/node_modules/
            &#125;,
            &#123;
                test:/.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;
        ]
    &#125;,
    //增加扩展选项，让webpack可以识别.ts/tsx文件
    resolve:&#123;
        extensions:[&#39;.ts&#39;,&#39;.tsx&#39;,&#39;.js&#39;]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;,
    devServer:&#123;
        proxy:&#123;
            &#39;/api&#39;:&#39;http://localhost:8080&#39;,
        &#125;,
        client:&#123;
            progress:true
        &#125;
    &#125;

&#125;
</code></pre>
<p>配置后，前端请求就会被代理到8080端口，解决跨域问题</p>
<p>15.集成ESLint和prettier</p>
<p>安装ESLint</p>
<pre><code class="ini">//本地安装
npm install eslint --save-dev
//全局安装
npm install -g eslint
</code></pre>
<p>运行eslint –init，选择工程使用了react，自动生成.eslintrc.js文件</p>
<pre><code class="ini">eslint --init
</code></pre>
<p>安装prettier</p>
<pre><code class="ini">//本地
npm i -D --save-exact prettier
//全局
npm i --global prettier
</code></pre>
<p>安装eslint-config-prettier插件（禁用 eslint 风格校验)</p>
<pre><code class="ini">npm i -D eslint-config-prettier
</code></pre>
<p>安装eslint-plugin-prettier插件（使eslint采用prettier的风格校验）</p>
<pre><code class="ini">npm i -D eslint-plugin-prettier
</code></pre>
<p>配置eslintrc.js文件</p>
<pre><code class="javascript">// eslint-disable-next-line no-undef
module.exports = &#123;
    &quot;env&quot;: &#123;
        &quot;browser&quot;: true,
        &quot;es2021&quot;: true,
        &quot;jest&quot;:true
    &#125;,
    &quot;extends&quot;: [
        &quot;eslint:recommended&quot;,
        &quot;plugin:react/recommended&quot;,
        &quot;plugin:@typescript-eslint/recommended&quot;
    ],
    &quot;overrides&quot;: [
    ],
    &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,
    &quot;parserOptions&quot;: &#123;
        &quot;ecmaVersion&quot;: &quot;latest&quot;
    &#125;,
    &quot;plugins&quot;: [
        &quot;react&quot;,
        &quot;@typescript-eslint&quot;
    ],
    &quot;rules&quot;: &#123;
    &quot;no-cond-assign&quot;: 2,
    &quot;no-console&quot;: [
      &quot;error&quot;, &#123;
        &quot;allow&quot;: [&quot;log&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;info&quot;]
      &#125;
    ],
    // 禁止 function 定义中出现重名参数
    &quot;no-dupe-args&quot;: 2,
    // 禁止对象字面量中出现重复的 key
    &quot;no-dupe-keys&quot;: 2,
    // 禁止重复的 case 标签
    &quot;no-duplicate-case&quot;: 2,
    // 禁止对 catch 子句的参数重新赋值
    &quot;no-ex-assign&quot;: 2,
    // 禁止不必要的布尔转换
    &quot;no-extra-boolean-cast&quot;: 2,
    // 禁止不必要的括号 //(a * b) + c;//报错
    &quot;no-extra-parens&quot;: 0,
    // 禁止 catch 子句的参数与外层作用域中的变量同名
    &quot;no-catch-shadow&quot;: 0,
    // 不允许标签与变量同名
    &quot;no-label-var&quot;: 2,
    // 禁用特定的全局变量
    &quot;no-restricted-globals&quot;: 2,
    // 禁止覆盖受限制的标识符
    &quot;no-shadow-restricted-names&quot;: 2,
    // 禁止将变量初始化为 undefined
    
    // 强制使用一致的换行风格
    &quot;linebreak-style&quot;: [2, &quot;unix&quot;],
    //在JSX中强制布尔属性符号
    &quot;react/jsx-boolean-value&quot;: 2,
    //在JSX中验证右括号位置
    // &quot;react/jsx-closing-bracket-location&quot;: 1,
    //在JSX属性和表达式中加强或禁止大括号内的空格。
    &quot;react/jsx-curly-spacing&quot;: [2, &#123;
      &quot;when&quot;: &quot;never&quot;,
      &quot;children&quot;: true
    &#125;],
    //在数组或迭代器中验证JSX具有key属性
    &quot;react/jsx-key&quot;: 2,
    // 限制JSX中单行上的props的最大数量
    &quot;react/jsx-max-props-per-line&quot;: [1, &#123;
      &quot;maximum&quot;: 5
    &#125;],
    //防止在JSX中重复的props
    &quot;react/jsx-no-duplicate-props&quot;: 2,
    //  //防止使用未包装的JSX字符串
    // &quot;react/jsx-no-literals&quot;: 0,
    //在JSX中禁止未声明的变量
    &quot;react/jsx-no-undef&quot;: 2,
    //为用户定义的JSX组件强制使用PascalCase
    &quot;react/jsx-pascal-case&quot;: 0,
    //防止反应被错误地标记为未使用
    &quot;react/jsx-uses-react&quot;: 2,
    //防止在JSX中使用的变量被错误地标记为未使用
    &quot;react/jsx-uses-vars&quot;: 2,
    //防止在componentDidMount中使用setState
    &quot;react/no-did-mount-set-state&quot;: 2,
    //防止在componentDidUpdate中使用setState
    &quot;react/no-did-update-set-state&quot;: 2,
    //防止使用未知的DOM属性
    &quot;react/no-unknown-property&quot;: 2,
    //为React组件强制执行ES5或ES6类
    &quot;react/prefer-es6-class&quot;: 2,
    //防止在React组件定义中丢失props验证
    // &quot;react/prop-types&quot;: 1,
    //使用JSX时防止丢失React
    &quot;react/react-in-jsx-scope&quot;: 2,
    //防止没有children的组件的额外结束标签
    &quot;react/self-closing-comp&quot;: 0,
    //禁止不必要的bool转换
    // &quot;no-extra-boolean-cast&quot;: 0,
    //防止在数组中遍历中使用数组key做索引
    // &quot;react/no-array-index-key&quot;: 0,
    //不使用弃用的方法
    &quot;react/no-deprecated&quot;: 2,
    //在JSX属性中强制或禁止等号周围的空格
    &quot;react/jsx-equals-spacing&quot;: 2,
    &quot;react/jsx-filename-extension&quot;: [2, &#123;
      &quot;extensions&quot;: [&quot;.js&quot;, &quot;.jsx&quot;]
    &#125;],
    // 禁止未使用的变量
    &quot;no-unused-vars&quot;: 0,
    &#125;
&#125;
</code></pre>
<p>当我们代码被eslint检测到不符合规则的代码就会提示，根据eslint指示修改就可以</p>
<p>在根目录下创建.prettierrc 或 prettier.config.js文件</p>
<pre><code class="javascript">module.exports = &#123;
    endOfLine: &#39;auto&#39;, // 不检测检测文件每行结束的格式
    semi: true, // 使用分号, 默认true
    singleQuote: true // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)
 &#125;
</code></pre>
<p>安装vscode插件：Prettier ESLint</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221107154026317.png"></p>
<p>该插件会根据工程根目录下的eslintrc.js和prettier.config.js文件格式化代码。可以进一步设置为vscode默认formater和自动格式化。</p>
<p>Prettier配置常用的参数可以根据团队需求制定</p>
<p>该文章只是配置简单的react脚手架，核心流程和方法是如此，其他具体需求可以根据团队客制化定制</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[antd官网]: 	“<a target="_blank" rel="noopener" href="https://ant.design/docs/react/introduce-cn">https://ant.design/docs/react/introduce-cn</a> “<br>[ESLint中文文档]: 	“<a target="_blank" rel="noopener" href="https://eslint.bootcss.com/">https://eslint.bootcss.com</a> “<br>[Prettier中文网]: 	“<a target="_blank" rel="noopener" href="https://www.prettier.cn/">https://www.prettier.cn</a> “</p>
<h3 id="源码仓库地址："><a href="#源码仓库地址：" class="headerlink" title="源码仓库地址："></a>源码仓库地址：</h3><p><a target="_blank" rel="noopener" href="https://github.com/mengfeng/react-app-start.git">https://github.com/mengfeng/react-app-start.git</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-从0到1搭建自己的脚手架vue3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/"
    >从0到1搭建自己的脚手架vue3</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/" class="article-date">
  <time datetime="2022-11-07T08:16:04.000Z" itemprop="datePublished">2022-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/">从0到1搭建自己的脚手架vue3</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="搭建vue项目脚手架"><a href="#搭建vue项目脚手架" class="headerlink" title="搭建vue项目脚手架"></a>搭建vue项目脚手架</h1><h3 id="1-所以的网站都需要一个页面，所以创建第一个-html文件（index-html）"><a href="#1-所以的网站都需要一个页面，所以创建第一个-html文件（index-html）" class="headerlink" title="1.所以的网站都需要一个页面，所以创建第一个.html文件（index.html）"></a>1.所以的网站都需要一个页面，所以创建第一个.html文件（index.html）</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;vue-cli-start&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
   &lt;!-- 引入打包后的js文件 --&gt;
    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="2-创建src和dist文件夹"><a href="#2-创建src和dist文件夹" class="headerlink" title="2.创建src和dist文件夹"></a>2.创建src和dist文件夹</h3><p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107081630590.png"></p>
<p>因为index.html需要引入打包后的bundle.js文件，所以将index.js放到了dist目录下</p>
<h3 id="3-创建入口文件main-js"><a href="#3-创建入口文件main-js" class="headerlink" title="3.创建入口文件main.js"></a>3.创建入口文件main.js</h3><p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107082550022.png"></p>
<p>我们需要引入vue实例，但是现在我们没有vue包，所以要先下载vue</p>
<p>我们也可以一次性下载vue所需要的依赖</p>
<pre><code class="ini">npm i vue element-ui axios
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107083055837.png"></p>
<h3 id="4-安装开发依赖"><a href="#4-安装开发依赖" class="headerlink" title="4.安装开发依赖"></a>4.安装开发依赖</h3><pre><code class="ini">npm i -D webpack webpack-cli vue-loader vue-template-compiler sass sass-loader css-loader style-loader babel-loader @babel/core @babel/preset-env
</code></pre>
<p>如果项目文件没有package.json,那么</p>
<pre><code class="ini">npm init -y
</code></pre>
<h3 id="5-创建webpack-config-js并配置-根目录下和package-json同一目录创建"><a href="#5-创建webpack-config-js并配置-根目录下和package-json同一目录创建" class="headerlink" title="5.创建webpack.config.js并配置(根目录下和package.json同一目录创建)"></a>5.创建webpack.config.js并配置(根目录下和package.json同一目录创建)</h3><pre><code class="javascript">//webpack.config.js基本配置模板
module.exports = &#123;
    //入口，表示从那个文件开始解析
    entry:&#39;&#39;,
    //出口，表示输出文件位置和信息
    output:&#123;
        path:&#39;&#39;,
        filename:&#39;&#39;
    &#125;,
    //模块，定义匹配规则和转换loader
    module:&#123;
        rules:[
            &#123;test:/\.vue$/,use:&#39;vue-loader&#39;&#125;,
            &#123;&#125;
        ]
    &#125;,
    //插件,给予webpack更丰富的功能
    plugins:[
        //实例化
        new PluginA()
    ]

&#125;
</code></pre>
<p>基本配置完成的webpack.config.js</p>
<pre><code class="javascript">const path = require(&#39;path&#39;)
const &#123;VueLoaderPlugin&#125; = require(&#39;vue-loader&#39;)
module.exports = &#123;
    entry:&#39;./src/main.js&#39;,
    output:&#123;
        path:path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    module:&#123;
        rules:[
            &#123;test:/\.vue$/,use:&#39;vue-loader&#39;&#125;,
            &#123;test:/\.s[ca]ss$/,use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;sass-loader&#39;]&#125;,
            &#123;
                test:/\.m?js$/,
                use:&#123;
                    loader:&#39;babel-loader&#39;,
                    options:&#123;
                        presets:[&#39;@babel/preset-env&#39;],
                    &#125;
                &#125;
            &#125;,
            //老语法
            // &#123;test:/\.(png|jpe?g|svg|gif|webp)$/,use:&#123;loader:&#39;file-loader&#39;,options:&#123;esModule:&#39;false&#39;&#125;&#125;&#125;
            &#123;test:/\.(png|jpe?g|svg|gif|webp)$/,type:&#39;asset/resource&#39;&#125;,
        ]
    &#125;,
    plugins:[
        new VueLoaderPlugin()
    ]
&#125;
</code></pre>
<h3 id="6-编辑书写main-js文件和App-vue"><a href="#6-编辑书写main-js文件和App-vue" class="headerlink" title="6.编辑书写main.js文件和App.vue"></a>6.编辑书写main.js文件和App.vue</h3><pre><code class="javascript">//main.js
import &#123; createApp &#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;
createApp(App).mount(&#39;#app&#39;)
</code></pre>
<pre><code class="vue">//App.vue
&lt;template&gt;
    &lt;div&gt;
        艺术码畜博客‘https://mengfeng.github.io/’
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;&#125;
&lt;/script&gt;
&lt;style lang=&quot;scss&quot; scoped&gt;
&lt;/style&gt;
</code></pre>
<h3 id="7-那么我们现在应该可以运行所配置的代码了"><a href="#7-那么我们现在应该可以运行所配置的代码了" class="headerlink" title="7.那么我们现在应该可以运行所配置的代码了"></a>7.那么我们现在应该可以运行所配置的代码了</h3><p>现在出现一个问题，直接执行webpack命令会找不到webpack命令，虽然我们下载了webpack-cli，但是只是存在于.&#x2F;node_modules&#x2F;.bin里面</p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107100606449.png"></p>
<p>那我们执行.&#x2F;node_modules&#x2F;.bin&#x2F;webpack也是可以打包的，但是我们每次执行这么长的命令不是很方便，所以通过配置package.json文件来简化命令</p>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;vue-cli-start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;:&#123;
    //--mode=development为开发环境，速度较快，上线可以配置为生产环境，会压缩，优化代码
    //--watch为监听代码变化，只要代码变化，会重新编译
    //build是生产环境的打包
    &quot;serve&quot;:&quot;webpack --mode=development --watch&quot;,
    &quot;build&quot;:&quot;webpack --mode=production&quot;
  &#125;,
 &quot;dependencies&quot;: &#123;
    &quot;axios&quot;: &quot;^1.1.3&quot;,
    &quot;element-ui&quot;: &quot;^2.15.10&quot;,
    &quot;vue&quot;: &quot;^3.2.41&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;@babel/core&quot;: &quot;^7.20.2&quot;,
    &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;,
    &quot;babel-loader&quot;: &quot;^9.1.0&quot;,
    &quot;css-loader&quot;: &quot;^6.7.1&quot;,
    &quot;sass&quot;: &quot;^1.56.0&quot;,
    &quot;sass-loader&quot;: &quot;^13.1.0&quot;,
    &quot;style-loader&quot;: &quot;^3.3.1&quot;,
    &quot;vue-loader&quot;: &quot;^17.0.1&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.7.13&quot;,
    &quot;webpack&quot;: &quot;^5.74.0&quot;,
    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<p>当我们执行npm run serve</p>
<pre><code class="ini">npm run serve
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107110605226.png"></p>
<p>表示我们编译成功了，我们现在可以试着运行一下index.html</p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107110725484.png"></p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107110748068.png"></p>
<p>恭喜，目前为止已经没有什么问题了！！！基础的vue脚手架就完成了（目前只是一个页面）</p>
<h3 id="8-我们需要多个页面的时候，就需要其他依赖了"><a href="#8-我们需要多个页面的时候，就需要其他依赖了" class="headerlink" title="8.我们需要多个页面的时候，就需要其他依赖了"></a>8.我们需要多个页面的时候，就需要其他依赖了</h3><p>根据下面的配置来修改自己的代码，可能下面的代码于上面的不同，但效果是一样的</p>
<pre><code class="ini">npm i vue-router
</code></pre>
<h3 id="9-创建route文件夹和pages文件夹"><a href="#9-创建route文件夹和pages文件夹" class="headerlink" title="9.创建route文件夹和pages文件夹"></a>9.创建route文件夹和pages文件夹</h3><p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107143307837.png"></p>
<h3 id="10-编辑App-vue和route下的index-js文件"><a href="#10-编辑App-vue和route下的index-js文件" class="headerlink" title="10.编辑App.vue和route下的index.js文件"></a>10.编辑App.vue和route下的index.js文件</h3><pre><code class="vue">//App.vue
&lt;template&gt;
    &lt;div id=&quot;nav&quot;&gt;
        &lt;router-link to=&quot;/&quot;&gt; home &lt;/router-link&gt; |
        &lt;router-link to=&quot;/food&quot;&gt; food &lt;/router-link&gt; |
        &lt;router-link to=&quot;/banner&quot;&gt; banner &lt;/router-link&gt;
    &lt;/div&gt;
    &lt;router-view /&gt;
&lt;/template&gt;
</code></pre>
<p>这里我们使用的是history，也可以用hash</p>
<pre><code class="javascript">//route/index.js
import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;
//注册
import home from &#39;../pages/Home.vue&#39;
import food from &#39;../pages/Food.vue&#39;
import banner from &#39;../pages/Banner.vue&#39;

const routes = [
  &#123; path: &quot;/&quot;, redirect: &quot;/home&quot; &#125;,
  &#123;
    path: &quot;/home&quot;,
    name: &quot;home&quot;,
    component: home
  &#125;,
  &#123;
    path: &quot;/food&quot;,
    name: &quot;food&quot;,
    component: food
  &#125;,
  &#123;
    path: &quot;/banner&quot;,
    name: &quot;banner&quot;,
    component: banner
  &#125;
]
//导出
const router = createRouter(&#123;
    history: createWebHashHistory(),
    routes: routes
  &#125;)

  export default router;
</code></pre>
<h3 id="11-需要在main-js里面去注册"><a href="#11-需要在main-js里面去注册" class="headerlink" title="11.需要在main.js里面去注册"></a>11.需要在main.js里面去注册</h3><pre><code class="javascript">import &#123; createApp &#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import router from &#39;./route&#39;

const app = createApp(App)
app.use(router)
app.mount(&#39;#app&#39;)
</code></pre>
<h3 id="12-这个时候再去跑我们的代码就可以了"><a href="#12-这个时候再去跑我们的代码就可以了" class="headerlink" title="12.这个时候再去跑我们的代码就可以了"></a>12.这个时候再去跑我们的代码就可以了</h3><pre><code class="ini">npm run serve
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107143925345.png"></p>
<h3 id="13-页面之间的route跳转"><a href="#13-页面之间的route跳转" class="headerlink" title="13.页面之间的route跳转"></a>13.页面之间的route跳转</h3><pre><code class="vue">//Food.vue
&lt;template&gt;
    &lt;p&gt;food&lt;/p&gt;
    &lt;button @click=&quot;toHome&quot;&gt;toHome&lt;/button&gt;
     &lt;!-- router-link组件跳转 --&gt;
    &lt;router-link to=&quot;/home&quot;&gt;toHome&lt;/router-link&gt;
  &lt;/template&gt;
  &lt;script&gt;
  import &#123; useRouter &#125; from &#39;vue-router&#39;
  export default &#123;
    setup () &#123;
      //编程式跳转
      const router = useRouter()
      const toHome = (() =&gt; &#123;
        router.push(&#123;
          name: &#39;home&#39;
        &#125;)
      &#125;)
      return &#123;
        toHome
      &#125;
    &#125;,
  &#125;
  &lt;/script&gt;
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107145442966.png"></p>
<p>当我们点击toHome按钮就可以跳转到home页了,两种方式都可以跳转</p>
<h3 id="14-配置ESLint和Prettier"><a href="#14-配置ESLint和Prettier" class="headerlink" title="14.配置ESLint和Prettier"></a>14.配置ESLint和Prettier</h3><p>安装ESLint</p>
<pre><code class="ini">//本地安装
npm install eslint --save-dev
//全局安装
npm install -g eslint
</code></pre>
<p>运行eslint –init，选择工程使用了vue，自动生成.eslintrc.js文件</p>
<pre><code class="ini">eslint --init
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107151858584.png"></p>
<p>我们按照需求去选择就可以了</p>
<p>安装prettier</p>
<pre><code class="ini">//本地
npm i -D --save-exact prettier
//全局
npm i --global prettier
</code></pre>
<p>安装eslint-config-prettier插件（禁用 eslint 风格校验)</p>
<pre><code class="ini">npm i -D eslint-config-prettier
</code></pre>
<p>安装eslint-plugin-prettier插件（使eslint采用prettier的风格校验）</p>
<pre><code class="ini">npm i -D eslint-plugin-prettier
</code></pre>
<p>配置eslintrc.js文件</p>
<pre><code class="javascript">module.exports = &#123;
    &quot;env&quot;: &#123;
        &quot;browser&quot;: true,
        &quot;es2021&quot;: true,
        &quot;node&quot;:true,
    &#125;,
    &quot;extends&quot;: [
        &quot;eslint:recommended&quot;,
        &quot;plugin:vue/vue3-essential&quot;
    ],
    &quot;overrides&quot;: [
    ],
    &quot;parserOptions&quot;: &#123;
        &quot;ecmaVersion&quot;: &quot;latest&quot;
    &#125;,
    &quot;plugins&quot;: [
        &quot;vue&quot;
    ],
    &quot;rules&quot;: &#123;
      &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;warn&#39; : &#39;off&#39;,
      &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;warn&#39; : &#39;off&#39;,
       //在rules中添加自定义规则
       //关闭组件命名规则
       &quot;vue/multi-word-component-names&quot;:&quot;off&quot;,
    &#125;
&#125;
</code></pre>
<p>在根目录下创建.prettierrc 或 prettier.config.js文件</p>
<pre><code class="javascript">module.exports = &#123;
    endOfLine: &#39;auto&#39;, // 不检测检测文件每行结束的格式
    semi: true, // 使用分号, 默认true
    singleQuote: true // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)
  &#125;
</code></pre>
<p>安装vscode插件：Prettier ESLint</p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107154026317.png"></p>
<p>该插件会根据工程根目录下的eslintrc.js和prettier.config.js文件格式化代码。可以进一步设置为vscode默认formater和自动格式化。</p>
<p>Prettier配置常用的参数可以根据团队需求制定</p>
<h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p>[ESLint中文文档]: 	“<a target="_blank" rel="noopener" href="https://eslint.bootcss.com/">https://eslint.bootcss.com</a> “<br>[Prettier中文网]: 	“<a target="_blank" rel="noopener" href="https://www.prettier.cn/">https://www.prettier.cn</a> “</p>
<h3 id="源码仓库地址："><a href="#源码仓库地址：" class="headerlink" title="源码仓库地址："></a>源码仓库地址：</h3><p><a target="_blank" rel="noopener" href="https://github.com/mengfeng/vue-cli-start">https://github.com/mengfeng/vue-cli-start</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/" rel="tag">工程技术</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据埋点监控系统设计"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"
    >数据埋点监控系统设计</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2022-11-06T01:48:56.000Z" itemprop="datePublished">2022-11-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">数据埋点监控系统设计</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="数据监控和数据埋点"><a href="#数据监控和数据埋点" class="headerlink" title="数据监控和数据埋点"></a>数据监控和数据埋点</h1><h3 id="一、数据监控分类"><a href="#一、数据监控分类" class="headerlink" title="一、数据监控分类"></a>一、数据监控分类</h3><h4 id="1-数据监控"><a href="#1-数据监控" class="headerlink" title="(1)数据监控"></a>(1)数据监控</h4><p>数据监控，顾名思义就是监听用户的行为。常见的数据监控包括：</p>
<ul>
<li>PV&#x2F;UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数</li>
<li>用户在每一个页面的停留时间</li>
<li>用户通过什么入口来访问该网页</li>
<li>用户在相应的页面中触发的行为</li>
</ul>
<p>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</p>
<h4 id="2-性能监控"><a href="#2-性能监控" class="headerlink" title="(2)性能监控"></a>(2)性能监控</h4><p>性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：</p>
<ul>
<li>不同用户，不同机型和不同系统下的首屏加载时间</li>
<li>白屏时间</li>
<li>http等请求的响应时间</li>
<li>静态资源整体下载时间</li>
<li>页面渲染时间</li>
<li>页面交互动画完成时间</li>
</ul>
<p>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。</p>
<h4 id="3-异常监控"><a href="#3-异常监控" class="headerlink" title="(3)异常监控"></a>(3)异常监控</h4><p>此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>
<ul>
<li>Javascript的异常监控</li>
<li>样式丢失的异常监控</li>
</ul>
<h3 id="二、常见的埋点方案"><a href="#二、常见的埋点方案" class="headerlink" title="二、常见的埋点方案"></a>二、常见的埋点方案</h3><h4 id="1-代码埋点"><a href="#1-代码埋点" class="headerlink" title="1. 代码埋点"></a>1. 代码埋点</h4><p>代码埋点是最早的埋点方式，根据业务的分析需求，将埋点的采集代码加入到应用端。按照埋点实施方，又分为前端(客户端)埋点和后端(服务端)埋点两种类型。</p>
<h5 id="1）客户端埋点"><a href="#1）客户端埋点" class="headerlink" title="1）客户端埋点"></a>1）客户端埋点</h5><p>由前端开发手动定义数据采集时机、内容等将数据采集的代码代码段加入到前端业务代码中，当用户在前端产生对应行为时，触发数据采集代码。</p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>按需埋点，采集数据更全面，几乎可覆盖所有数据采集场景</li>
<li>行为数据和业务数据可充分联合分析</li>
</ul>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>延迟上报，数据丢失率高(5%-10%)</li>
<li>需要客户端发版，用户端更新App</li>
<li>埋点开发工作量大</li>
<li>埋点流程需要多方协作，容易漏埋、错埋</li>
</ul>
<h6 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h6><p>全面分析用户在客户端的操作行为，对于一些电商交易类的产品，需要把行为和业务数据充分结合分析</p>
<h5 id="2）服务端埋点"><a href="#2）服务端埋点" class="headerlink" title="2）服务端埋点"></a>2）服务端埋点</h5><p>由服务端开发将埋点采集代码加入到后端服务请求中，当用户前端操作请求服务端数据时，按照约定规则触发埋点代码</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>按需埋点，采集数据更全面，几乎可覆盖所有数据采集场景</li>
<li>行为数据和业务数据可充分联合分析</li>
<li>数据采集实时上报，准确性高，丢失率低</li>
<li>服务端更新，不需要客户端发版或用户更新版本</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>纯前端操作不触发服务请求的按钮点击无法采集数据</li>
<li>埋点开发工作量大</li>
<li>埋点流程需要多方协作，容易漏埋、错埋</li>
</ul>
<h6 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h6><p>对于一些非点击、不可见的行为，或者要获取用户身份信息、更多的业务相关的属性信息。如果前后端都可以采集到，优先后端埋点</p>
<h4 id="2-全埋点"><a href="#2-全埋点" class="headerlink" title="2. 全埋点"></a>2. 全埋点</h4><p>全埋点也有称之为无埋点或无痕埋点的，主要是将埋点采集代码封装成标准的SDK，应用端接入后，按照SDK的采集规则自动化地进行数据采集和上报</p>
<h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>接入SDK后，可自动采集数据，无需按需开发，节省开发成本</li>
<li>页面可见元素均可自动采集，数据更全面</li>
<li>埋点流程简单，业务使用埋点系统自助定义事件，新增埋点需求无需业务开发参与</li>
</ul>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>动态页面或页面不可见行为数据无法采集</li>
<li>和业务强相关的属性信息采集困难</li>
<li>数据全部采集，数据存储压力大</li>
</ul>
<h6 id="适用场景：-2"><a href="#适用场景：-2" class="headerlink" title="适用场景："></a>适用场景：</h6><p>业务场景简单，如工具、应用类的产品，或者业务发展初期，产品快速迭代需求比精细化分析优先级更高，只需要分析简单的PV、UV</p>
<h4 id="3-可视化埋点"><a href="#3-可视化埋点" class="headerlink" title="3. 可视化埋点"></a>3. 可视化埋点</h4><p>默认不采集数据，当数据分析人员通过设备连接用户行为分析工具的数据接入管理界面，在页面可视化定义需要采集的位点后下发采集请求，采集代码生效</p>
<h6 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>默认不上报数据，可视化圈选才按需触发埋点，节约存储和传输成本</li>
<li>业务可视化圈选，埋点操作简单方便</li>
</ul>
<h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>数据只在埋点圈选定义之后才有，历史数据无法回溯</li>
<li>只能覆盖基本的点击、展示等用户行为，和业务强相关的属性信息采集困难</li>
</ul>
<h6 id="适用场景：-3"><a href="#适用场景：-3" class="headerlink" title="适用场景："></a>适用场景：</h6><p>业务场景简单，如工具、应用类的产品，或者业务发展初期，产品快速迭代需求比精细化分析优先级更高，只需要分析简单的PV、UV</p>
<h3 id="三、sdk设计"><a href="#三、sdk设计" class="headerlink" title="三、sdk设计"></a>三、sdk设计</h3><h4 id="SDK的设计"><a href="#SDK的设计" class="headerlink" title="SDK的设计"></a>SDK的设计</h4><p>在开始设计之前，先看一下SDK怎么使用。</p>
<pre><code class="javascript">import StatisticSDK from &#39;StatisticSDK&#39;;
// 全局初始化一次
window.insSDK = new StatisticSDK(&#39;uuid-12345&#39;);
&lt;button onClick=&#123;()=&gt;&#123;
  window.insSDK.event(&#39;click&#39;,&#39;confirm&#39;);
  ...// 其他业务代码
&#125;&#125;&gt;确认&lt;/button&gt;
</code></pre>
<p>首先把SDK实例挂载到全局，之后在业务代码中调用，这里的新建实例时需要传入一个id，因为这个埋点监控系统往往是给多个业务去使用的，通过id去区分不同的数据来源。</p>
<p>首先实现实例化部分：</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
  &#125;
&#125;
</code></pre>
<h4 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h4><p>数据发送是一个最基础的api，后面的功能都要基于此进行。通常这种前后端分离的场景会使用AJAX的方式发送数据，但是这里使用图片的src属性。原因有两点：</p>
<ol>
<li>没有跨域的限制，像srcipt标签、img标签都可以直接发送跨域的GET请求，不用做特殊处理。</li>
<li>兼容性好，一些静态页面可能禁用了脚本，这时script标签就不能使用了。</li>
</ol>
<p>但要注意，这个图片不是用来展示的，我们的目的是去「传递数据」，只是借助img标签的的src属性，在其url后面拼接上参数，服务端收到再去解析。</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
  &#125;
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
    let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
    let img = new Image();
    img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
&#125;
</code></pre>
<p>img标签的优点是不需要将其append到文档，只需设置src属性便能成功发起请求。</p>
<p>通常请求的这个url会是一张1X1px的GIF图片，网上的文章对于这里为什么返回图片的是一张GIF都是含糊带过，这里查阅了一些资料并测试了：</p>
<p>1.同样大小，不同格式的的图片中GIF大小是最小的，所以选择返回一张GIF，这样对性能的损耗更小。</p>
<p>2.如果返回204，会走到img的onerror事件，并抛出一个全局错误;如果返回200和一个空对象会有一个CORB的告警。</p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/346cd16826c82e6bd7a2246d22d56fc478dfc3.png"></p>
<p>3.当然如果不在意这个报错可以采取返回空对象，事实上也有一些工具是这样做的。</p>
<p>有一些埋点需要真实的加到页面上，比如垃圾邮件的发送者会添加这样一个隐藏标志来验证邮件是否被打开，如果返回204或者是200空对象会导致一个明显图片占位符。</p>
<pre><code>&lt;img src=&quot;http://www.example.com/logger?event_id=1234&quot;&gt;1.
</code></pre>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/77236ef50e0237529c0080434f48bd20be8ce5.png"></p>
<h4 id="更优雅的web-beacon"><a href="#更优雅的web-beacon" class="headerlink" title="更优雅的web beacon"></a>更优雅的web beacon</h4><p>这种打点标记的方式被称web beacon(网络信标)。除了gif图片，从2014年开始，浏览器逐渐实现专门的API，来更优雅的完成这件事：Navigator.sendBeacon。</p>
<p>使用很简单。</p>
<pre><code class="javascript">Navigator.sendBeacon(url,data)
</code></pre>
<p>相较于图片的src，这种方式的更有优势：</p>
<ul>
<li>不会和主要业务代码抢占资源，而是在浏览器空闲时去做发送。</li>
<li>并且在页面卸载时也能保证请求成功发送，不阻塞页面刷新和跳转。</li>
</ul>
<p>现在的埋点监控工具通常会优先使用sendBeacon，但由于浏览器兼容性，还是需要用图片的src兜底。</p>
<h4 id="用户行为监控"><a href="#用户行为监控" class="headerlink" title="用户行为监控"></a>用户行为监控</h4><p>上面实现了数据发送的api，现在可以基于它去实现用户行为监控的api。</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
  &#125;
  // 数据发送
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
      let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
      let img = new Image();
      img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
  // 自定义事件
  event(key, val=&#123;&#125;) &#123;
    let eventURL = &#39;http://demo/&#39;
    this.send(eventURL,&#123;event:key,...val&#125;)
  &#125;
  // pv曝光
  pv() &#123;
    this.event(&#39;pv&#39;)
  &#125;
&#125;
</code></pre>
<p>用户行为包括自定义事件和pv曝光，也可以把pv曝光看作是一种特殊的自定义行为事件。</p>
<h4 id="页面性能监控"><a href="#页面性能监控" class="headerlink" title="页面性能监控"></a>页面性能监控</h4><p>页面的性能数据可以通过performance.timing这个API获取到，获取的数据是单位为毫秒的时间戳。</p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/272519802405fa2531a97471630d64ab493783.png"></p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/95d45e432d6684cc4ab527d2ac28bddad1a98e.png" alt="img">上面的不需要全部了解，但比较关键的数据有下面几个，根据它们可以计算出FP&#x2F;DCL&#x2F;Load等关键事件的时间点：</p>
<ol>
<li>页面首次渲染时间：FP(firstPaint)&#x3D;domLoading-navigationStart。</li>
<li>DOM加载完成：DCL(DOMContentEventLoad)&#x3D;domContentLoadedEventEnd-navigationStart。</li>
<li>图片、样式等外链资源加载完成：L(Load)&#x3D;loadEventEnd-navigationStart。</li>
</ol>
<p>上面的数值可以跟performance面板里的结果对应。</p>
<p>回到SDK，我们只用实现一个上传所有性能数据的api就可以了：</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
    // 初始化自动调用性能上报
    this.initPerformance()
  &#125;
  // 数据发送
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
      let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
      let img = new Image();
      img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
  // 性能上报
  initPerformance()&#123;
    let performanceURL = &#39;http://performance/&#39;
    this.send(performanceURL,performance.timing)
  &#125;
&#125;
</code></pre>
<p>并且，在构造函数里自动调用，因为性能数据是必须要上传的，就不需要用户每次都手动调用了。</p>
<h4 id="错误告警监控"><a href="#错误告警监控" class="headerlink" title="错误告警监控"></a>错误告警监控</h4><p>错误报警监控分为JS原生错误和React&#x2F;Vue的组件错误的处理。</p>
<h5 id="JS原生错误"><a href="#JS原生错误" class="headerlink" title="JS原生错误"></a>JS原生错误</h5><p>除了try catch中捕获住的错误，我们还需要上报没有被捕获住的错误——通过error事件和unhandledrejection事件去监听。</p>
<h5 id="error"><a href="#error" class="headerlink" title="error"></a>error</h5><p>error事件是用来监听DOM操作错误DOMException和JS错误告警的，具体来说，JS错误分为下面8类：</p>
<ol>
<li>InternalError: 内部错误，比如如递归爆栈。</li>
<li>RangeError: 范围错误，比如new Array(-1)。</li>
<li>EvalError: 使用eval()时错误。</li>
<li>ReferenceError: 引用错误，比如使用未定义变量。</li>
<li>SyntaxError: 语法错误，比如var a &#x3D; 。</li>
<li>TypeError: 类型错误，比如[1,2].split(‘.’)。</li>
<li>URIError: 给 encodeURI或 decodeURl()传递的参数无效，比如decodeURI(‘%2’)。</li>
<li>Error: 上面7种错误的基类，通常是开发者抛出。</li>
</ol>
<p>也就是说，代码运行时发生的上述8类错误，都可以被检测到。</p>
<h5 id="unhandledrejection"><a href="#unhandledrejection" class="headerlink" title="unhandledrejection"></a>unhandledrejection</h5><p>Promise内部抛出的错误是无法被error捕获到的，这时需要用unhandledrejection事件。</p>
<p>回到SDK的实现，处理错误报警的代码如下：</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
    // 初始化错误监控
    this.initError()
  &#125;
  // 数据发送
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
      let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
      let img = new Image();
      img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
  // 自定义错误上报
  error(err, etraInfo=&#123;&#125;) &#123;
    const errorURL = &#39;http://error/&#39;
    const &#123; message, stack &#125; = err;
    this.send(errorURL, &#123; message, stack, ...etraInfo&#125;)
  &#125;
  // 初始化错误监控
  initError()&#123;
    window.addEventListener(&#39;error&#39;, event=&gt;&#123;
      this.error(error);
    &#125;)
    window.addEventListener(&#39;unhandledrejection&#39;, event=&gt;&#123;
      this.error(new Error(event.reason), &#123; type: &#39;unhandledrejection&#39;&#125;)
    &#125;)
  &#125;
&#125;
</code></pre>
<p>和初始化性能监控一样，初始化错误监控也是一定要做的，所以需要在构造函数中调用。后续开发人员只用在业务代码的try catch中调用error方法即可。</p>
<h3 id="React-x2F-Vue组件错误"><a href="#React-x2F-Vue组件错误" class="headerlink" title="React&#x2F;Vue组件错误"></a>React&#x2F;Vue组件错误</h3><p>成熟的框架库都会有错误处理机制，React和Vue也不例外。</p>
<h5 id="React的错误边界"><a href="#React的错误边界" class="headerlink" title="React的错误边界"></a>React的错误边界</h5><p>错误边界是希望当应用内部发生渲染错误时，不会整个页面崩溃。我们提前给它设置一个兜底组件，并且可以细化粒度，只有发生错误的部分被替换成这个「兜底组件」，不至于整个页面都不能正常工作。</p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/562c10735609456ff5d155aa6880f7ca2598a4.png"></p>
<p>它的使用很简单，就是一个带有特殊生命周期的类组件，用它把业务组件包裹起来。</p>
<p>这两个生命周期是getDerivedStateFromError和componentDidCatch。</p>
<p>代码如下：</p>
<pre><code class="javascript">// 定义错误边界
class ErrorBoundary extends React.Component &#123;
  state = &#123; error: null &#125;
  static getDerivedStateFromError(error) &#123;
    return &#123; error &#125;
  &#125;
  componentDidCatch(error, errorInfo) &#123;
    // 调用我们实现的SDK实例
    insSDK.error(error, errorInfo)
  &#125;
  render() &#123;
    if (this.state.error) &#123;
      return &lt;h2&gt;Something went wrong.&lt;/h2&gt;
    &#125;
    return this.props.children
  &#125;
&#125;
...
&lt;ErrorBoundary&gt;
  &lt;BuggyCounter /&gt;
&lt;/ErrorBoundary&gt;1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.
</code></pre>
<p>回到SDK的整合上，在生产环境下，被错误边界包裹的组件，如果内部抛出错误，全局的error事件是无法监听到的，因为这个错误边界本身就相当于一个try catch。所以需要在错误边界这个组件内部去做上报处理。也就是上面代码中的componentDidCatch生命周期。</p>
<h3 id="Vue的错误边界"><a href="#Vue的错误边界" class="headerlink" title="Vue的错误边界"></a>Vue的错误边界</h3><p>vue也有一个类似的生命周期来做这件事，不再赘述：errorCaptured。</p>
<pre><code class="javascript">Vue.component(&#39;ErrorBoundary&#39;, &#123;
  data: () =&gt; (&#123; error: null &#125;),
  errorCaptured (err, vm, info) &#123;
    this.error = `$&#123;err.stack&#125;\n\nfound in $&#123;info&#125; of component`
    // 调用我们的SDK，上报错误信息
    insSDK.error(err,info)
    return false
  &#125;,
  render (h) &#123;
    if (this.error) &#123;
      return h(&#39;pre&#39;, &#123; style: &#123; color: &#39;red&#39; &#125;&#125;, this.error)
    &#125;
    return this.$slots.default[0]
  &#125;
&#125;)
...
&lt;error-boundary&gt;
  &lt;buggy-counter /&gt;
&lt;/error-boundary&gt;
</code></pre>
<p>现在我们已经实现了一个完整的SDK的骨架，并且处理了在实际开发时，react&#x2F;vue项目应该怎么接入。</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/706364.html">https://www.51cto.com/article/706364.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/" rel="tag">工程技术</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全算法篇"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/"
    >前端面试大全算法篇</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/" class="article-date">
  <time datetime="2022-11-05T02:32:27.000Z" itemprop="datePublished">2022-11-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95%E7%AF%87/">算法篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（算法）"><a href="#前端面试题大全（算法）" class="headerlink" title="前端面试题大全（算法）"></a>前端面试题大全（算法）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-算法中时间复杂度，空间复杂度的理解？如何计算？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-算法中时间复杂度，空间复杂度的理解？如何计算？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 算法中时间复杂度，空间复杂度的理解？如何计算？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 算法中时间复杂度，空间复杂度的理解？如何计算？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别</p>
<p>衡量不同算法之间的优劣主要是通过时间和空间两个维度去考量：</p>
<ul>
<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>
<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述</li>
</ul>
<p>通常会遇到一种情况，时间和空间维度不能够兼顾，需要在两者之间取得一个平衡点是我们需要考虑的</p>
<p>一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况</p>
<p>最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差</p>
<h4 id="二、时间复杂度"><a href="#二、时间复杂度" class="headerlink" title="二、时间复杂度"></a>二、时间复杂度</h4><p>时间复杂度是指执行这个算法所需要的计算工作量，其复杂度反映了程序执行时间「随输入规模增长而增长的量级」，在很大程度上能很好地反映出算法的优劣与否</p>
<p>一个算法花费的时间与算法中语句的「执行次数成正比」，执行次数越多，花费的时间就越多</p>
<p>算法的复杂度通常用大O符号表述，定义为<code>T(n) = O(f(n))</code>，常见的时间复杂度有：O(1)常数型、O(log n)对数型、O(n)线性型、O(nlogn)线性对数型、O(n^2)平方型、O(n^3)立方型、O(n^k)k次方型、O(2^n)指数型，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33336435656266302d313666632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>从上述可以看到，随着问题规模<code>n</code>的不断增大，上述时间复杂度不断增大，算法的执行效率越低，由小到大排序如下：</p>
<pre><code class="ini">Ο(1)＜Ο(log n)＜Ο(n)＜Ο(nlog n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n)＜Ο(n!)
</code></pre>
<p>注意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效，如果常数项过大的时候也会导致算法的执行时间变长</p>
<p>关于如何计算时间复杂度，可以看看如下简单例子：</p>
<pre><code class="javascript">function process(n) &#123;
  let a = 1
  let b = 2
  let sum = a + b
  for(let i = 0; i &lt; n; i++) &#123;
    sum += i
  &#125;
  return sum
&#125;
</code></pre>
<p>该函数算法需要执行的运算次数用输入大小<code>n</code>的函数表示，即 <code>T(n) = 2 + n + 1</code>，那么时间复杂度为<code>O(n + 3)</code>，又因为时间复杂度只关注最高数量级，且与之系数也没有关系，因此上述的时间复杂度为<code>O(n)</code></p>
<p>又比如下面的例子：</p>
<pre><code class="javascript">function process(n) &#123;
 let count = 0
  for(let i = 0; i &lt; n; i++)&#123;
    for(let i = 0; i &lt; n; i++)&#123;
      count += 1
    &#125;
  &#125;
&#125;
</code></pre>
<p>循环里面嵌套循环，外面的循环执行一次，里面的循环执行<code>n</code>次，因此时间复杂度为 <code>O(n*n*1 + 2) = O(n^2)</code></p>
<p>对于顺序执行的语句，总的时间复杂度等于其中最大的时间复杂度，如下：</p>
<pre><code class="javascript">function process(n) &#123;
  let sum = 0
  for(let i = 0; i &lt; n; i++) &#123;
    sum += i
  &#125;
  for(let i = 0; i &lt; n; i++)&#123;
    for(let i = 0; i &lt; n; i++)&#123;
      sum += 1
    &#125;
  &#125;
  return sum
&#125;
</code></pre>
<p>上述第一部分复杂度为<code>O(n)</code>，第二部分复杂度为<code>O(n^2)</code>，总复杂度为<code>max(O(n^2), O(n)) = O(n^2)</code></p>
<p>又如下一个例子：</p>
<pre><code class="javascript">function process(n) &#123;
  let i = 1; // ①
  while (i &lt;= n) &#123;
     i = i * 2; // ②
  &#125;
&#125;
</code></pre>
<p>循环语句中以2的倍数来逼近<code>n</code>，每次都乘以2。如果用公式表示就是1 * 2 * 2 * 2 … * 2 &lt;&#x3D;n，也就是说2的<code>x</code>次方小于等于<code>n</code>时会执行循环体，记作<code>2^x &lt;= n</code>，于是得出<code>x&lt;=logn</code></p>
<p>因此循环在执行<code>logn</code>次之后，便结束，因此时间复杂度为<code>O(logn)</code></p>
<p>同理，如果一个<code>O(n)</code>循环里面嵌套<code>O(logn)</code>的循环，则时间复杂度为<code>O(nlogn)</code>，像<code>O(n^3)</code>无非也就是嵌套了三层<code>O(n)</code>循环</p>
<h4 id="三、空间复杂度"><a href="#三、空间复杂度" class="headerlink" title="三、空间复杂度"></a>三、空间复杂度</h4><p>空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量</p>
<p>除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间</p>
<p>下面给出空间复杂度为<code>O(1)</code>的示例，如下</p>
<pre><code class="javascript">let a = 1
let b = 2
let c = 3
</code></pre>
<p>上述代码的临时空间不会随着<code>n</code>的变化而变化，因此空间复杂度为<code>O(1)</code></p>
<pre><code class="javascript">let arr []
for(i=1; i&lt;=n; ++i)&#123;
  arr.push(i)
&#125;
</code></pre>
<p>上述可以看到，随着<code>n</code>的增加，数组的占用的内存空间越大</p>
<p>通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为<code>O(1)</code>，一个一维数组<code>a[n]</code>，空间复杂度<code>O(n)</code>，二维数组为<code>O(n^2)</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对数据结构的理解？有哪些？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对数据结构的理解？有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对数据结构的理解？有哪些？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对数据结构的理解？有哪些？区别？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合</p>
<p>前面讲到，一个程序 &#x3D; 算法 + 数据结构，数据结构是实现算法的基础，选择合适的数据结构可以带来更高的运行或者存储效率</p>
<p>数据元素相互之间的关系称为结构，根据数据元素之间关系的不同特性，通常有如下四类基本的结构：</p>
<ul>
<li>集合结构：该结构的数据元素间的关系是“属于同一个集合”</li>
<li>线性结构：该结构的数据元素之间存在着一对一的关系</li>
<li>树型结构：该结构的数据元素之间存在着一对多的关系</li>
<li>图形结构：该结构的数据元素之间存在着多对多的关系，也称网状结构</li>
</ul>
<p>由于数据结构种类太多，逻辑结构可以再分成为：</p>
<ul>
<li>线性结构：有序数据元素的集合，其中数据元素之间的关系是一对一的关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的</li>
<li>非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生关联</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/c16cd7ef078a9270d5e13a8eca64d7b5469bf5ba3cfa7b88564c0065ba3ba230/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39616564633564302d316161362d313165632d386536342d3931666465633066303561312e706e67"><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39616564633564302d316161362d313165632d386536342d3931666465633066303561312e706e67.png" alt="img"></a></p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的数据结构有如下：</p>
<ul>
<li>数组</li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>树</li>
<li>图</li>
<li>堆</li>
<li>散列表</li>
</ul>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>在程序设计中，为了处理方便， 一般情况把具有相同类型的若干变量按有序的形式组织起来，这些按序排列的同类数据元素的集合称为数组</p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>一种特殊的线性表，只能在某一端插入和删除的特殊线性表，按照先进后出的特性存储数据</p>
<p>先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>跟栈基本一致，也是一种特殊的线性表，其特性是先进先出，只允许在表的前端进行删除操作，而在表的后端进行插入操作</p>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p>
<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成</p>
<p>一般情况，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><p>树是典型的非线性结构，在树的结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个以上的后继结点</p>
<h5 id="图"><a href="#图" class="headerlink" title="图"></a>图</h5><p>一种非线性结构。在图结结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系</p>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆是一种特殊的树形数据结构，每个结点都有一个值，特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆</p>
<h5 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h5><p>若结构中存在关键字和<code>K</code>相等的记录，则必定在<code>f(K)</code>的存储位置上，不需比较便可直接取得所查记录</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>上述的数据结构，之前的区别可以分成线性结构和非线性结构：</p>
<ul>
<li>线性结构有：数组、栈、队列、链表等</li>
<li>非线性结构有：树、图、堆等</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对栈、队列的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对栈、队列的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对栈、队列的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对栈、队列的理解？应用场景？</h3><h4 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h4><p>栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表</p>
<p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p>
<p>所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p>
<p>关于栈的简单实现，如下：</p>
<pre><code class="javascript">class Stack &#123;
  constructor() &#123;
    this.items = [];
  &#125;

  /**
   * 添加一个（或几个）新元素到栈顶
   * @param &#123;*&#125; element 新元素
   */
  push(element) &#123;
    this.items.push(element)
  &#125;

  /**
   * 移除栈顶的元素，同时返回被移除的元素
   */
  pop() &#123;
    return this.items.pop()
  &#125;

  /**
   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）
   */
  peek() &#123;
    return this.items[this.items.length - 1]
  &#125;

  /**
   * 如果栈里没有任何元素就返回true,否则返回false
   */
  isEmpty() &#123;
    return this.items.length === 0
  &#125;

  /**
   * 移除栈里的所有元素
   */
  clear() &#123;
    this.items = []
  &#125;

  /**
   * 返回栈里的元素个数。这个方法和数组的length属性很类似
   */
  size() &#123;
    return this.items.length
  &#125;
&#125;
</code></pre>
<p>关于栈的操作主要的方法如下：</p>
<ul>
<li>push：入栈操作</li>
<li>pop：出栈操作</li>
</ul>
<h4 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h4><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</p>
<p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p>
<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出</p>
<p>简单实现一个队列的方式，如下：</p>
<pre><code>class Queue &#123;
    constructor() &#123;
        this.list = []
        this.frontIndex = 0
        this.tailIndex = 0
    &#125;
    enqueue(item) &#123;
        this.list[this.tailIndex++] = item
    &#125;
    unqueue() &#123;
        const item  = this.list[this.frontIndex]
        this.frontIndex++        
        return item
    &#125;
&#125;
</code></pre>
<p>上述这种入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用</p>
<p>当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作，出该现象称为”假溢”</p>
<p>在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：</p>
<p>无论插入或删除，一旦<code>rear</code>指针增1或<code>front</code>指针增1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置，这种队列也就是循环队列</p>
<p>下面实现一个循环队列，如下：</p>
<pre><code class="javascript">class Queue &#123;
    constructor(size) &#123;
        this.size = size; // 长度需要限制, 来达到空间的利用, 代表空间的长度
        this.list = [];
        this.font = 0; // 指向首元素
        this.rear = 0;  // 指向准备插入元素的位置
    &#125;
    enQueue() &#123;
        if (this.isFull() == true) &#123;
            return false
        &#125;
        this.rear = this.rear % this.k;
        this._data[this.rear++] = value;
        return true
    &#125;
    deQueue() &#123;
        if(this.isEmpty())&#123;
            return false;
        &#125;
        this.font++;
        this.font = this.font % this.k;
        return true;
    &#125;
    isEmpty() &#123;
        return this.font == this.rear - 1;
    &#125;
    isFull() &#123;
        return this.rear % this.k == this.font;
    &#125;
&#125;
</code></pre>
<p>上述通过求余的形式代表首尾指针增1 时超出了所分配的队列空间</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><h5 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h5><p>借助栈的先进后出的特性，可以简单实现一个逆序数处的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p>
<p>包括编译器的在对输入的语法进行分析的时候，例如<code>&quot;()&quot;</code>、<code>&quot;&#123;&#125;&quot;</code>、<code>&quot;[]&quot;</code>这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>
<p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p>
<p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p>
<h5 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h5><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p>
<p>队列的使用广泛应用在广度优先搜索种，例如层次遍历一个二叉树的节点值（后续将到）</p>
<p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对链表的理解？常见的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对链表的理解？常见的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对链表的理解？常见的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对链表的理解？常见的操作有哪些？</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>链表（Linked List）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，由一系列结点（链表中每一个元素称为结点）组成</p>
<p>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65346539333439302d316337362d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>节点用代码表示，则如下：</p>
<pre><code class="javascript">class Node &#123;
  constructor(val) &#123;
    this.val = val;
    this.next = null;
  &#125;
&#125;
</code></pre>
<ul>
<li>data 表示节点存放的数据</li>
<li>next 表示下一个节点指向的内存空间</li>
</ul>
<p>相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到<code>O(1)</code>的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是<code>O(logn)</code>和<code>O(1)</code></p>
<p>链表的结构也十分多，常见的有四种形式：</p>
<ul>
<li>单链表：除了头节点和尾节点，其他节点只包含一个后继指针</li>
<li>循环链表：跟单链表唯一的区别就在于它的尾结点又指回了链表的头结点，首尾相连，形成了一个环</li>
<li>双向链表：每个结点具有两个方向指针，后继指针(next)指向后面的结点，前驱指针(prev)指向前面的结点，其中节点的前驱指针和尾结点的后继指针均指向空地址NULL</li>
<li>双向循环链表：跟双向链表基本一致，不过头节点前驱指针指向尾迹诶单和尾节点的后继指针指向头节点</li>
</ul>
<h4 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于链表的操作可以主要分成如下：</p>
<ul>
<li>遍历</li>
<li>插入</li>
<li>删除</li>
</ul>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>遍历很好理解，就是根据<code>next</code>指针遍历下去，直到为<code>null</code>，如下：</p>
<pre><code class="javascript">let current = head
while(current)&#123;
 console.log(current.val)
  current = current.next
&#125;
</code></pre>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>向链表中间插入一个元素，可以如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66356665356664302d316337362d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>可以看到，插入节点可以分成如下步骤：</p>
<ul>
<li>存储插入位置的前一个节点</li>
<li>存储插入位置的后一个节点</li>
<li>将插入位置的前一个节点的 next 指向插入节点</li>
<li>将插入节点的 next 指向前面存储的 next 节点</li>
</ul>
<p>相关代码如下所示：</p>
<pre><code class="javascript">let current = head
while (current &lt; position)&#123;
  pervious = current;
  current = current.next;
&#125;
pervious.next = node;
node.next = current;
</code></pre>
<p>如果在头节点进行插入操作的时候，会实现<code>previousNode</code>节点为<code>undefined</code>，不适合上述方式</p>
<p>解放方式可以是在头节点前面添加一个虚拟头节点，保证插入行为一致</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>向链表任意位置删除节点，如下图操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30313630636439302d316337372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>从上图可以看到删除节点的步骤为如下：</p>
<ul>
<li>获取删除节点的前一个节点</li>
<li>获取删除节点的后一个节点</li>
<li>将前一个节点的 next 指向后一个节点</li>
<li>向删除节点的 next 指向为null</li>
</ul>
<p>如果想要删除制定的节点，示意代码如下：</p>
<pre><code class="javascript">while (current != node)&#123;
  pervious = current;
  current = current.next;
  nextNode = current.next;
&#125;
pervious.next = nextNode
</code></pre>
<p>同样如何希望删除节点处理行为一致，可以在头节点前面添加一个虚拟头节点</p>
<h5 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h5><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的<code>CPU</code>缓存、数据库缓存、浏览器缓存等等</p>
<p>当缓存空间被用满时，我们可能会使用<code>LRU</code>最近最好使用策略去清楚，而实现<code>LRU</code>算法的数据结构是链表，思路如下：</p>
<p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表</p>
<ul>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部</li>
<li>如果此数据没在缓存链表中<ul>
<li>如果此时缓存未满，可直接在链表头部插入新节点存储此数据</li>
<li>如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点</li>
</ul>
</li>
</ul>
<p>由于链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据的情况的时候，都可以使用链表</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对集合的理解？常见的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对集合的理解？常见的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对集合的理解？常见的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对集合的理解？常见的操作有哪些？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>集合（Set），指具有某种特定性质的事物的总体，里面的每一项内容称作元素</p>
<p>在数学中，我们经常会遇到集合的概念：</p>
<ul>
<li>有限集合：例如一个班集所有的同学构成的集合</li>
<li>无限集合：例如全体自然数集合</li>
</ul>
<p>在计算机中集合道理也基本一致，具有三大特性：</p>
<ul>
<li>确定性：于一个给定的集合，集合中的元素是确定的。即一个元素，或者属于该集合，或者不属于该集合，两者必居其一</li>
<li>无序性：在一个集合中，不考虑元素之间的顺序，只要元素完全相同，就认为是同一个集合</li>
<li>互异性：集合中任意两个元素都是不同的</li>
</ul>
<h4 id="二、操作-1"><a href="#二、操作-1" class="headerlink" title="二、操作"></a>二、操作</h4><p>在<code>ES6</code>中，集合本身是一个构建函数<code>Set</code>，用来生成 <code>Set</code> 数据结构，如下：</p>
<pre><code class="javascript">const s = new Set();
</code></pre>
<p>关于集合常见的方法有：</p>
<ul>
<li>add()：增</li>
<li>delete()：删</li>
<li>has()：改</li>
<li>clear()：查</li>
</ul>
<h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><p>添加某个值，返回 <code>Set</code> 结构本身</p>
<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>
<pre><code class="javascript">s.add(1).add(2).add(2); // 2只被添加了一次
</code></pre>
<p>体现了集合的互异性特性</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h5><p>删除某个值，返回一个布尔值，表示删除是否成功</p>
<pre><code class="ini">s.delete(1)
</code></pre>
<h5 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h5><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>
<pre><code class="ini">s.has(2)
</code></pre>
<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p>清除所有成员，没有返回值</p>
<pre><code class="ini">s.clear()
</code></pre>
<p>关于多个集合常见的操作有：</p>
<ul>
<li>并集</li>
<li>交集</li>
<li>差集</li>
</ul>
<h5 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h5><p>两个集合的共同元素，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65643936646635302d316433362d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>代码实现方式如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;
</code></pre>
<h5 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h5><p>两个集合<code>A</code> 和 <code>B</code>，即属于<code>A</code>又属于<code>B</code>的元素，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66386139636438302d316433362d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>用代码标识则如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;
</code></pre>
<h5 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h5><p>两个集合<code>A</code> 和 <code>B</code>，属于<code>A</code>的元素但不属于<code>B</code>的元素称为<code>A</code>相对于<code>B</code>的差集，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30313931633536302d316433372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>代码标识则如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>一般情况下，使用数组的概率会比集合概率高很多</p>
<p>使用<code>set</code>集合的场景一般是借助其确定性，其本身只包含不同的元素</p>
<p>所以，可以利用<code>Set</code>的一些原生方法轻松的完成数组去重，查找数组公共元素及不同元素等操作</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对树的理解？相关的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对树的理解？相关的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对树的理解？相关的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对树的理解？相关的操作有哪些？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机领域，树形数据结构是一类重要的非线性数据结构，可以表示数据之间一对多的关系。以树与二叉树最为常用，直观看来，树是以分支关系定义的层次结构</p>
<p>二叉树满足以下两个条件：</p>
<ul>
<li>本身是有序树</li>
<li>树中包含的各个结点的不能超过 2，即只能是 0、1 或者 2</li>
</ul>
<p>如下图，左侧的为二叉树，而右侧的因为头结点的子结点超过2，因此不属于二叉树：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36363735383830302d316466652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>同时，二叉树可以继续进行分类，分成了满二叉树和完成二叉树：</p>
<ul>
<li>满二叉树：如果二叉树中除了叶子结点，每个结点的度都为 2</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353964623035302d316466652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>完成二叉树：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38346165333166302d316466652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h4 id="二、操作-2"><a href="#二、操作-2" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于二叉树的遍历，常见的有：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问根节点</li>
<li>访问当前节点的左子树</li>
<li>若当前节点无左子树，则访问当前节点的右子</li>
</ul>
<p>根据遍历特性，递归版本用代码表示则如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  console.log(root)
  preOrder(root.left)
  preOrder(root.right)
&#125;
</code></pre>
<p>如果不使用递归版本，可以借助栈先进后出的特性实现，先将根节点压入栈，再分别压入右节点和左节点，直到栈中没有元素，如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  const stack = [root]
  while (stack.length) &#123;
    const n = stack.pop()
    console.log(n.val)
    if (n.right) &#123;
      stack.push(n.right)
    &#125;
    if (n.left) &#123;
      stack.push(n.left)
    &#125;
  &#125;
&#125;
</code></pre>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问当前节点的左子树</li>
<li>访问根节点</li>
<li>访问当前节点的右子</li>
</ul>
<p>递归版本很好理解，用代码表示则如下：</p>
<pre><code class="javascript">const inOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  inOrder(root.left)
  console.log(root.val)
  inOrder(root.right)
&#125;
</code></pre>
<p>非递归版本也是借助栈先进后出的特性，可以一直首先一直压入节点的左元素，当左节点没有后，才开始进行出栈操作，压入右节点，然后有依次压入左节点，如下：</p>
<pre><code class="javascript">const inOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  const stack = [root]
  let p = root
  while(stack.length || p)&#123;
    while (p) &#123;
      stack.push(p)
      p = p.left
    &#125;
    const n = stack.pop()
    console.log(n.val)
    p = n.right
  &#125;
&#125;
</code></pre>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问当前节点的左子树</li>
<li>访问当前节点的右子</li>
<li>访问根节点</li>
</ul>
<p>递归版本，用代码表示则如下：</p>
<pre><code class="javascript">const postOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  postOrder(root.left)
  postOrder(root.right)
  console.log(n.val)
 &#125;
</code></pre>
<p>后序遍历非递归版本实际根全序遍历是逆序关系，可以再多创建一个栈用来进行输出，如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  const stack = [root]
  const outPut = []
  while (stack.length) &#123;
    const n = stack.pop()
    outPut.push(n.val)
    if (n.right) &#123;
      stack.push(n.right)
    &#125;
    if (n.left) &#123;
      stack.push(n.left)
    &#125;
  &#125;
  while (outPut.length) &#123;
    const n = outPut.pop()
    console.log(n.val)
  &#125;
&#125;
</code></pre>
<h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>按照二叉树中的层次从左到右依次遍历每层中的结点</p>
<p>借助队列先进先出的特性，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果</p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const levelOrder = (root) =&gt; &#123;
    if (!root) &#123; return [] &#125;
    const queue = [[root, 0]]
    const res = []
    while (queue.length) &#123;
        const n = queue.shift()
        const [node, leval] = n
        if (!res[leval]) &#123;
            res[leval] = [node.val]
        &#125; else &#123;
            res[leval].push(node.val)
        &#125;
        if (node.left) &#123; queue.push([node.left, leval + 1]) &#125;
        if (node.right) &#123; queue.push([node.right, leval + 1]) &#125;
    &#125;
    return res
&#125;;
</code></pre>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>树是一个非常重要的非线性结构，其中二叉树以二叉树最常见，二叉树的遍历方式可以分成前序遍历、中序遍历、后序遍历</p>
<p>同时，二叉树又分成了完成二叉树和满二叉树</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对堆的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对堆的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对堆的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对堆的理解？如何实现？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称</p>
<p>堆通常是一个可以被看做一棵完全二叉树的数组对象，如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613066643166302d316564372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>总是满足下列性质：</p>
<ul>
<li>堆中某个结点的值总是不大于或不小于其父结点的值</li>
<li>堆总是一棵完全二叉树</li>
</ul>
<p>堆又可以分成最大堆和最小堆：</p>
<ul>
<li>最大堆：每个根结点，都有根结点的值大于两个孩子结点的值</li>
<li>最小堆：每个根结点，都有根结点的值小于孩子结点的值</li>
</ul>
<h4 id="二、操作-3"><a href="#二、操作-3" class="headerlink" title="二、操作"></a>二、操作</h4><p>堆的元素存储方式，按照完全二叉树的顺序存储方式存储在一个一维数组中，如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613066643166302d316564372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用一维数组存储则如下：</p>
<pre><code class="javascript">[0, 1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<p>根据完全二叉树的特性，可以得到如下特性：</p>
<ul>
<li>数组零坐标代码的是堆顶元素</li>
<li>一个节点的父亲节点的坐标等于其坐标除以2整数部分</li>
<li>一个节点的左节点等于其本身节点坐标 * 2 + 1</li>
<li>一个节点的右节点等于其本身节点坐标 * 2 + 2</li>
</ul>
<p>根据上述堆的特性，下面构建最小堆的构造函数和对应的属性方法：</p>
<pre><code class="javascript">class MinHeap &#123;
  constructor() &#123;
    // 存储堆元素
    this.heap = []
  &#125;
  // 获取父元素坐标
  getParentIndex(i) &#123;
    return (i - 1) &gt;&gt; 1
  &#125;
  
  // 获取左节点元素坐标
  getLeftIndex(i) &#123;
    return i * 2 + 1
  &#125;
  
 // 获取右节点元素坐标
  getRightIndex(i) &#123;
    return i * 2 + 2
  &#125;
  
  // 交换元素
  swap(i1, i2) &#123;
    const temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp
  &#125;
  
  // 查看堆顶元素
  peek() &#123;
    return this.heap[0]
  &#125;
  
  // 获取堆元素的大小
  size() &#123;
    return this.heap.length
  &#125;
&#125;
</code></pre>
<p>涉及到堆的操作有：</p>
<ul>
<li>插入</li>
<li>删除</li>
</ul>
<h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><p>将值插入堆的底部，即数组的尾部，当插入一个新的元素之后，堆的结构就会被破坏，因此需要堆中一个元素做上移操作</p>
<p>将这个值和它父节点进行交换，直到父节点小于等于这个插入的值，大小为<code>k</code>的堆中插入元素的时间复杂度为<code>O(logk)</code></p>
<p>如下图所示，22节点是新插入的元素，然后进行上移操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30363839336662302d316564382d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>相关代码如下：</p>
<pre><code class="java">// 插入元素
insert(value) &#123;
  this.heap.push(value)
  this.shifUp(this.heap.length - 1)
&#125;

// 上移操作
shiftUp(index) &#123;
  if (index === 0) &#123; return &#125;
  const parentIndex = this.getParentIndex(index)
  if(this.heap[parentIndex] &gt; this.heap[index])&#123;
    this.swap(parentIndex, index)
    this.shiftUp(parentIndex)
  &#125;
&#125;
</code></pre>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>常见操作是用数组尾部元素替换堆顶，这里不直接删除堆顶，因为所有的元素会向前移动一位，会破坏了堆的结构</p>
<p>然后进行下移操作，将新的堆顶和它的子节点进行交换，直到子节点大于等于这个新的堆顶，删除堆顶的时间复杂度为<code>O(logk)</code></p>
<p>整体如下图操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31326132613136302d316564382d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>相关代码如下：</p>
<pre><code class="javascript">// 删除元素
pop() &#123;
  this.heap[0] = this.heap.pop()
  this.shiftDown(0)
&#125;

// 下移操作
shiftDown(index) &#123;
  const leftIndex = this.getLeftIndex(index)
  const rightIndex = this.getRightIndex(index)
  if (this.heap[leftIndex] &lt; this.heap[index])&#123;
    this.swap(leftIndex, index)
    this.shiftDown(leftIndex)
  &#125;
  if (this.heap[rightIndex] &lt; this.heap[index])&#123;
    this.swap(rightIndex, index)
    this.shiftDown(rightIndex)
  &#125;
&#125;
</code></pre>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>关于堆的插入和删除时间复杂度都是<code>Olog(n)</code>，原因在于包含n个节点的完全二叉树，树的高度不会超过<code>log2n</code></p>
<p>堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是<code>Olog(n)</code>，插入数据和删除堆顶元素的主要逻辑就是堆化</p>
<h3 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h3><ul>
<li>堆是一个完全二叉树</li>
<li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值</li>
<li>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”</li>
<li>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“小顶堆”</li>
<li>根据堆的特性，我们可以使用堆来进行排序操作，也可以使用其来求第几大或者第几小的值</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对图的理解？相关操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对图的理解？相关操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对图的理解？相关操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对图的理解？相关操作有哪些？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机科学中，图是一种抽象的数据类型，在图中的数据元素通常称为结点，<code>V</code>是所有顶点的集合，<code>E</code>是所有边的集合</p>
<p>如果两个顶点<code>v</code>,<code> w</code>，只能由<code>v</code>向<code>w</code>，而不能由<code>w</code>向<code>v</code>，那么我们就把这种情况叫做一个从 <code>v</code> 到 <code>w</code> 的有向边。<code>v </code>也被称做初始点，<code>w</code>也被称为终点。这种图就被称做有向图</p>
<p>如果<code>v</code>和<code>w</code>是没有顺序的，从<code>v</code>到达<code>w</code>和从<code>w</code>到达<code>v</code>是完全相同的，这种图就被称为无向图</p>
<p>图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系</p>
<p>常见表达图的方式有如下：</p>
<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
</ul>
<h5 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h5><p>通过使用一个二维数组<code>G[N][N]</code>进行表示<code>N</code>个点到<code>N-1</code>编号，通过邻接矩阵可以立刻看出两顶点之间是否存在一条边，只需要检查邻接矩阵行<code>i</code>和列<code>j</code>是否是非零值，对于无向图，邻接矩阵是对称的</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38383164343330302d323035392d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><p>存储方式如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39343966656464302d323035392d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>在<code>javascript</code>中，可以使用<code>Object</code>进行表示，如下：</p>
<pre><code class="javascript">const graph = &#123;
  A: [2, 3, 5],
  B: [2],
  C: [0, 1, 3],
  D: [0, 2],
  E: [6],
  F: [0, 6],
  G: [4, 5]
&#125;
</code></pre>
<p>图的数据结构还可能包含和每条边相关联的数值（edge value），例如一个标号或一个数值（即权重，weight；表示花费、容量、长度等）</p>
<h4 id="二、操作-4"><a href="#二、操作-4" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于的图的操作常见的有：</p>
<ul>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
</ul>
<p>首先构建一个图的邻接矩阵表示，如下面的图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61313331313739302d323035392d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const graph = &#123;
  0: [1, 4],
  1: [2, 4],
  2: [2, 3],
  3: [],
  4: [3],
&#125;
</code></pre>
<h5 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h5><p>也就是尽可能的往深处的搜索图的分支</p>
<p>实现思路是，首先应该确定一个根节点，然后对根节点的没访问过的相邻节点进行深度优先遍历</p>
<p>确定以 0 为根节点，然后进行深度遍历，然后遍历1，接着遍历 2，然后3，此时完成一条分支<code>0 - 1- 2- 3</code>的遍历，换一条分支，也就是4，4后面因为3已经遍历过了，所以就不访问了</p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const visited = new Set()
const dfs = (n) =&gt; &#123;
  console.log(n)
  visited.add(n) // 访问过添加记录
  graph[n].forEach(c =&gt; &#123;
    if(!visited.has(c))&#123; // 判断是否访问呢过
      dfs(c)
    &#125;
  &#125;)
&#125;
</code></pre>
<h5 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h5><p>先访问离根节点最近的节点，然后进行入队操作，解决思路如下：</p>
<ul>
<li>新建一个队列，把根节点入队</li>
<li>把队头出队并访问</li>
<li>把队头的没访问过的相邻节点入队</li>
<li>重复二、三步骤，知道队列为空</li>
</ul>
<p>用代码标识则如下：</p>
<pre><code class="javascript">const visited = new Set()
const dfs = (n) =&gt; &#123;
  visited.add(n)
  const q = [n]
  while(q.length)&#123;
    const n = q.shift()
    console.log(n)
    graph[n].forEach(c =&gt; &#123;
      if(!visited.has(c))&#123;
        q.push(c)  
        visited.add(c)
      &#125;
    &#125;)
  &#125;
&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面的初步了解，可以看到图就是由顶点的有穷非空集合和顶点之间的边组成的集合，分成了无向图与有向图</p>
<p>图的表达形式可以分成邻接矩阵和邻接表两种形式，在<code>javascript</code>中，则可以通过二维数组和对象的形式进行表达</p>
<p>图实际是很复杂的，后续还可以延伸出无向图和带权图，对应如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62306438383230302d323035392d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-常见的排序算法有哪些？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-常见的排序算法有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 常见的排序算法有哪些？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 常见的排序算法有哪些？区别？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列</p>
<p>排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的</p>
<p>对与排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性</p>
<p>时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义</p>
<p>稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变</p>
<p>即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的</p>
<h4 id="二、有哪些-1"><a href="#二、有哪些-1" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的算法排序算法有：</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来</p>
<p>思路如下：</p>
<ul>
<li>比较相邻的元素，如果第一个比第二个大，就交换它们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>重复上述步骤，直到没有任何一堆数字需要比较</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963342e7a68696d672e636f6d2f76322d33336139343763373161643632623235346361623632653533363464323831335f622e77656270.gif"></p>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法</p>
<p>无论什么数据进去都是 <code>O(n²) </code>的时间复杂度。所以用到它的时候，数据规模越小越好</p>
<p>唯一的好处是不占用额外的内存存储空间</p>
<p>思路如下：</p>
<ul>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963312e7a68696d672e636f6d2f76322d31633765323066333036646463303265623465336135306661373831376666345f622e77656270.gif"></p>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>插入排序是一种简单直观的排序算法</p>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<p>解决思路如下：</p>
<ul>
<li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的</li>
<li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
<li>重复上述过程直到最后一个元素被插入有序子数组中</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d39316237366538653464616239623063616439613031376437646434333165325f622e77656270.gif"></p>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>归并排序是建立在归并操作上的一种有效的排序算法</p>
<p>该算法是采用分治法的一个非常典型的应用</p>
<p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p>
<p>解决思路如下：</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d63646461336631316336656662633031353737663563323961393036363737325f622e6a7067.jpeg"></p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小</p>
<p>再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列</p>
<p>解决思路如下：</p>
<ul>
<li>从数列中挑出一个元素，称为”基准”（pivot）</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963312e7a68696d672e636f6d2f76322d63343131333339623739663932343939646362376235663330346338323666345f622e6a7067.jpeg"></p>
<h2 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h2><p>除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等……</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对冒泡排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对冒泡排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对冒泡排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对冒泡排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法</p>
<p>冒泡排序的思想就是在每次遍历一遍未排序的数列之后，将一个数据元素浮上去（也就是排好了一个数据）</p>
<p>如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”</p>
<p>假如我们要把 12、35、99、18、76 这 5 个数从大到小进行排序，那么数越大，越需要把它放在前面</p>
<p>思路如下：</p>
<ul>
<li>从后开始遍历，首先比较 18 和 76，发现 76 比 18 大，就把两个数交换顺序，得到 12、35、99、76、18</li>
<li>接着比较 76 和 99，发现 76 比 99 小，所以不用交换顺序</li>
<li>接着比较 99 和 35，发现 99 比 35 大，交换顺序</li>
<li>接着比较 99 和 12，发现 99 比 12 大，交换顺序</li>
</ul>
<p>最终第 1 趟排序的结果变成了 99、12、35、76、18，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37613336333737302d323635322d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>上述可以看到，经过第一趟的排序，可以得到最大的元素，接下来第二趟排序则对剩下的的4个元素进行排序，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38346239646466302d323635322d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>经过第 2 趟排序，结果为 99、76、12、35、18</p>
<p>然后开始第3趟的排序，结果为99、76、35、12、18</p>
<p>然后第四趟排序结果为99、76、35、18、12</p>
<p>经过 4 趟排序之后，只剩一个 12 需要排序了，这时已经没有可比较的元素了，这时排序完成</p>
<h4 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>如果要实现一个从小到大的排序，算法原理如下：</p>
<ul>
<li>首先比较相邻的元素，如果第一个元素比第二个元素大，则交换它们</li>
<li>针对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样，最后的元素回事最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li>
</ul>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function bubbleSort(arr) &#123;
    const len = arr.length;
    for (let i = 0; i &lt; len - 1; i++) &#123;
        for (let j = 0; j &lt; len - 1 - i; j++) &#123;
            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
    return arr;
&#125;
</code></pre>
<p>可以看到：冒泡排序在每一轮排序中都会使一个元素排到一趟， 也就是最终需要 n-1 轮这样的排序</p>
<p>而在每轮排序中都需要对相邻的两个元素进行比较，在最坏的情况下，每次比较之后都需要交换位置，此时时间复杂度为<code>O(n^2)</code></p>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>对冒泡排序常见的改进方法是加入一标志性变量<code>exchange</code>，用于标志某一趟排序过程中是否有数据交换</p>
<p>如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程</p>
<p>可以设置一标志性变量<code>pos</code>，用于记录每趟排序中最后一次进行交换的位置，由于<code>pos</code>位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到<code>pos</code>位置即可，如下：</p>
<pre><code class="javascript">function bubbleSort1(arr)&#123;
 const i=arr.length-1;//初始时,最后位置保持不变  
 while(i&gt;0)&#123;
  let pos = 0;//每趟开始时,无记录交换
  for(let j = 0; j &lt; i; j++)&#123;
   if(arr[j] &gt; arr[j+1])&#123;
        let tmp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = tmp;
    pos = j;//记录最后交换的位置  
   &#125;   
  &#125;
  i = pos;//为下一趟排序作准备
 &#125;
 return arr;
&#125;
</code></pre>
<p>在待排序的数列有序的情况下，只需要一轮排序并且不用交换，此时情况最好，时间复杂度为<code>O(n)</code></p>
<p>并且从上述比较中看到，只有后一个元素比前面的元素大（小）时才会对它们交换位置并向上冒出，对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对位置是不会改变的，因此， 冒泡排序是稳定的</p>
<h4 id="三、应用场景-3"><a href="#三、应用场景-3" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>冒泡排的核心部分是双重嵌套循环，<br>时间复杂度是 O(N 2 )，相比其它排序算法，这是一个相对较高的时间复杂度，一般情况不推荐使用，由于冒泡排序的简洁性，通常被用来对于程序设计入门的学生介绍算法的概念</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对选择排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对选择排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对选择排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对选择排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>选择排序（Selection sort）是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²) </code>的时间复杂度，所以用到它的时候，数据规模越小越好</p>
<p>其基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置</p>
<p>然后再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾</p>
<p>以此类推，直到所有元素均排序完毕</p>
<p>举个例子，一个数组为 56、12、80、91、29，其排序过程如下：</p>
<ul>
<li>第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置。此时数组为 12、56、80、91、20</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36306264323035302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置，此时数组为12、20、80、91、56</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36623034636634302d323637312d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<ul>
<li>第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置，此时数组为 12、20、56、91、80</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353766346530302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置，此时排序完成，变成有序数组</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353766346530302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h4 id="二、如何实现-1"><a href="#二、如何实现-1" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>从上面可以看到，对于具有 <code>n</code> 个记录的无序表遍历 <code>n-1</code> 次，第<code> i</code> 次从无序表中第 <code>i</code> 个记录开始，找出后序关键字中最小的记录，然后放置在第 <code>i</code> 的位置上</p>
<p>直至到从第<code>n</code>个和第<code>n-1</code>个元素中选出最小的放在第<code>n-1</code>个位置</p>
<p>如下动画所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f73656c656374696f6e536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function selectionSort(arr) &#123;
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) &#123;
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) &#123;
            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    return arr;
&#125;
</code></pre>
<p>第一次内循环比较<code>N - 1</code>次，然后是<code>N-2</code>次，<code>N-3</code>次，……，最后一次内循环比较1次<br>共比较的次数是 <code>(N - 1) + (N - 2) + ... + 1</code>，求等差数列和，得 <code>(N - 1 + 1)* N / 2 = N^2 / 2</code>，舍去最高项系数，其时间复杂度为 <code>O(N^2)</code></p>
<p>从上述也可以看到，选择排序是一种稳定的排序</p>
<h4 id="三、应用场景-4"><a href="#三、应用场景-4" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>和冒泡排序一致，相比其它排序算法，这也是一个相对较高的时间复杂度，一般情况不推荐使用</p>
<p>但是我们还是要掌握冒泡排序的思想及实现，这对于我们的算法思维是有很大帮助的</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对插入排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对插入排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对插入排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对插入排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-9"><a href="#一、是什么-9" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>插入排序（Insertion Sort），一般也被称为直接插入排序。对于少量元素的排序，它是一个有效、简单的算法</p>
<p>其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据</p>
<p>插入排序的工作方式像许多人排序一手扑克牌，开始时，我们的左手为空并且桌子上的牌面向下</p>
<p>然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置，该正确位置需要从右到左将它与已在手中的每张牌进行比较</p>
<p>例如一个无序数组 3、1、7、5、2、4、9、6，将其升序的结果则如下：</p>
<p>一开始有序表中无数据，直接插入3</p>
<p>从第二个数开始，插入一个元素1，然后和有序表中记录3比较，1&lt;3，所以插入到记录 3 的左侧</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39643234663566302d323637662d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>向有序表插入记录 7 时，同有序表中记录 3 进行比较，3&lt;7，所以插入到记录 3 的右侧</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61366139353465302d323637662d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>向有序表中插入记录 5 时，同有序表中记录 7 进行比较，5&lt;7，同时 5&gt;3，所以插入到 3 和 7 中间</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62313938313934302d323637662d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>照此规律，依次将无序表中的记录 4，9 和 6插入到有序表中</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62633265643239302d323637662d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h4 id="二、如何实现-2"><a href="#二、如何实现-2" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置</p>
<p>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f696e73657274696f6e536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function insertionSort(arr) &#123;
    const len = arr.length;
    let preIndex, current;
    for (let i = 1; i &lt; len; i++) &#123;
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        &#125;
        arr[preIndex+1] = current;
    &#125;
    return arr;
&#125;
</code></pre>
<p>在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较<code>N- 1</code>次，时间复杂度为<code>O(n)</code></p>
<p>最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为<code>O(n^2)</code></p>
<p>通过上面了解，可以看到插入排序是一种稳定的排序方式</p>
<h4 id="三、应用场景-5"><a href="#三、应用场景-5" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>插入排序时间复杂度是 O(n2)，适用于数据量不大，算法稳定性要求高，且数据局部或整体有序的数列排序</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对归并排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对归并排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对归并排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对归并排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-10"><a href="#一、是什么-10" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>归并排序（Merge Sort）是建立归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用</p>
<p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p>
<p>例如对于含有 <code>n</code> 个记录的无序表，首先默认表中每个记录各为一个有序表（只不过表的长度都为 1）</p>
<p>然后进行两两合并，使 <code>n</code> 个有序表变为<code>n/2</code> 个长度为 2 或者 1 的有序表（例如 4 个小有序表合并为 2 个大的有序表）</p>
<p>通过不断地进行两两合并，直到得到一个长度为 <code>n</code> 的有序表为止</p>
<p>例如对无序表{49，38，65，97，76，13，27}进行归并排序分成了分、合两部分：</p>
<p>如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30356631346236302d323661642d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>归并合过程中，每次得到的新的子表本身有序，所以最终得到有序表</p>
<p>上述分成两部分，则称为二路归并，如果分成三个部分则称为三路归并，以此类推</p>
<h4 id="二、如何实现-3"><a href="#二、如何实现-3" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>关于归并排序的算法思路如下：</p>
<ul>
<li>分：把数组分成两半，再递归对子数组进行分操作，直至到一个个单独数字</li>
<li>合：把两个数合成有序数组，再对有序数组进行合并操作，直到全部子数组合成一个完整的数组<ul>
<li>合并操作可以新建一个数组，用于存放排序后的数组</li>
<li>比较两个有序数组的头部，较小者出队并且推入到上述新建的数组中</li>
<li>如果两个数组还有值，则重复上述第二步</li>
<li>如果只有一个数组有值，则将该数组的值出队并推入到上述新建的数组中</li>
</ul>
</li>
</ul>
<p>用代码表示则如下图所示：</p>
<pre><code class="javascript">function mergeSort(arr) &#123;  // 采用自上而下的递归方法
    const len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    let middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    const result = [];

    while (left.length &amp;&amp; right.length) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
&#125;
</code></pre>
<p>上述归并分成了分、合两部分，在处理分过程中递归调用两个分的操作，所花费的时间为2乘<code>T(n/2)</code>，合的操作时间复杂度则为<code>O(n)</code>，因此可以得到以下公式：</p>
<p>总的执行时间 &#x3D; 2 × 输入长度为<code>n/2</code>的<code>sort</code>函数的执行时间 + <code>merge</code>函数的执行时间<code>O(n)</code></p>
<p>当只有一个元素时，<code>T(1) = O(1)</code></p>
<p>如果对<code>T(n) = 2 * T(n/2) + O(n) </code>进行左右 &#x2F; n的操作，得到 <code>T(n) / n = (n / 2) * T(n/2) + O(1)</code></p>
<p>现在令 <code>S(n) = T(n)/n</code>，则<code>S(1) = O(1)</code>，然后利用表达式带入得到<code>S(n) = S(n/2) + O(1)</code></p>
<p>所以可以得到：<code>S(n) = S(n/2) + O(1) = S(n/4) + O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)</code></p>
<p>综上可得，<code>T(n) = n * log(n) = nlogn</code></p>
<p>关于归并排序的稳定性，在进行合并过程，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也不会交换，由此可见归并排序是稳定的排序算法</p>
<h4 id="三、应用场景-6"><a href="#三、应用场景-6" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>在外排序中通常使用排序-归并的策略，外排序是指处理超过内存限度的数据的排序算法，通常将中间结果放在读写较慢的外存储器，如下分成两个阶段：</p>
<ul>
<li>排序阶段：读入能够放进内存中的数据量，将其排序输出到临时文件，一次进行，将带排序数据组织为多个有序的临时文件</li>
<li>归并阶段：将这些临时文件组合为大的有序文件</li>
</ul>
<p>例如，使用100m内存对900m的数据进行排序，过程如下：</p>
<ul>
<li>读入100m数据内存，用常规方式排序</li>
<li>将排序后的数据写入磁盘</li>
<li>重复前两个步骤，得到9个100m的临时文件</li>
<li>将100m的内存划分为10份，将9份为输入缓冲区，第10份为输出缓冲区</li>
<li>进行九路归并排序，将结果输出到缓冲区<ul>
<li>若输出缓冲区满，将数据写到目标文件，清空缓冲区</li>
<li>若缓冲区空，读入相应文件的下一份数据</li>
</ul>
</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对快速排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对快速排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对快速排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对快速排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-11"><a href="#一、是什么-11" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>快速排序（Quick Sort）算法是在冒泡排序的基础上进行改进的一种算法，从名字上看就知道该排序算法的特点是快、效率高，是处理大数据最快的排序算法之一</p>
<p>实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小</p>
<p>然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就变成有序序列</p>
<p>例如，对无序表49，38，65，97，76，13，27，49进行快速排序，大致过程为：</p>
<ul>
<li>首先从表中选取一个记录的关键字作为分割点（称为“枢轴”或者支点，一般选择第一个关键字），例如选取 49</li>
<li>将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：{27，38，13，49，65，97，76，49}</li>
<li>以 49 为支点，将整个无序表分割成了两个部分，分别为{27，38，13}和{65，97，76，49}，继续采用此种方法分别对两个子表进行排序</li>
<li>前部分子表以 27 为支点，排序后的子表为{13，27，38}，此部分已经有序；后部分子表以 65 为支点，排序后的子表为{49，65，97，76}</li>
<li>此时前半部分子表中的数据已完成排序；后部分子表继续以 65 为支点，将其分割为{49}和{97，76}，前者不需排序，后者排序后的结果为{76， 97}</li>
<li>通过以上几步的排序，最后由子表{13，27，38}、{49}、{49}、{65}、{76，97}构成有序表：{13，27，38，49，49，65，76，97}</li>
</ul>
<h4 id="二、如何实现-4"><a href="#二、如何实现-4" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>可以分成以下步骤：</p>
<ul>
<li>分区：从数组中选择任意一个基准，所有比基准小的元素放在基准的左边，比基准大的元素放到基准的右边</li>
<li>递归：递归地对基准前后的子数组进行分区</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f717569636b536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function quickSort (arr) &#123;
  const rec = (arr) =&gt; &#123;
    if (arr.length &lt;= 1) &#123; return arr; &#125;
    const left = [];
    const right = [];
    const mid = arr[0]; // 基准元素
    for (let i = 1; i &lt; arr.length; i++)&#123;
      if (arr[i] &lt; mid) &#123;
        left.push(arr[i]);
      &#125; else &#123;
        right.push(arr[i]);
      &#125;
    &#125;
    return [...rec(left), mid, ...rec(right)]
  &#125;
  return rec(arr)
&#125;;
</code></pre>
<p>快速排序是冒泡排序的升级版，最坏情况下每一次基准元素都是数组中最小或者最大的元素，则快速排序就是冒泡排序</p>
<p>这种情况时间复杂度就是冒泡排序的时间复杂度：<code>T[n] = n * (n-1) = n^2 + n</code>，也就是<code>O(n^2)</code></p>
<p>最好情况下是<code>O(nlogn)</code>，其中递归算法的时间复杂度公式：<code>T[n] = aT[n/b] + f(n)</code>，推导如下所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62363031393534302d326235652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>关于上述代码实现的快速排序，可以看到是稳定的</p>
<h4 id="三、应用场景-7"><a href="#三、应用场景-7" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>快速排序时间复杂度为<code>O(nlogn)</code>，是目前基于比较的内部排序中被认为最好的方法，当数据过大且数据杂乱无章时，则适合采用快速排序</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对二分查找的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对二分查找的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对二分查找的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对二分查找的理解？如何实现？应用场景？</h3><h4 id="一、是什么-12"><a href="#一、是什么-12" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机科学中，二分查找算法，也称折半搜索算法，是一种在有序数组中查找某一特定元素的搜索算法</p>
<p>想要应用二分查找法，则这一堆数应有如下特性：</p>
<ul>
<li>存储在数组中</li>
<li>有序排序</li>
</ul>
<p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束</p>
<p>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较</p>
<p>如果在某一步骤数组为空，则代表找不到</p>
<p>这种搜索算法每一次比较都使搜索范围缩小一半</p>
<p>如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65323130383532302d323938372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>相比普通的顺序查找，除了数据量很少的情况下，二分查找会比顺序查找更快，区别如下所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963322e7a68696d672e636f6d2f76322d34333333396239363364623633623333313037623536353033616436623162355f622e676966.gif"></p>
<h4 id="二、如何实现-5"><a href="#二、如何实现-5" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>基于二分查找的实现，如果数据是有序的，并且不存在重复项，实现代码如下：</p>
<pre><code class="javascript">function BinarySearch(arr, target) &#123;
    if (arr.length &lt;= 1) return -1
    // 低位下标
    let lowIndex = 0
    // 高位下标
    let highIndex = arr.length - 1

    while (lowIndex &lt;= highIndex) &#123;
        // 中间下标
        const midIndex = Math.floor((lowIndex + highIndex) / 2)
        if (target &lt; arr[midIndex]) &#123;
            highIndex = midIndex - 1
        &#125; else if (target &gt; arr[midIndex]) &#123;
            lowIndex = midIndex + 1
        &#125; else &#123;
            // target === arr[midIndex]
            return midIndex
        &#125;
    &#125;
    return -1
&#125;
</code></pre>
<p>如果数组中存在重复项，而我们需要找出第一个制定的值，实现则如下：</p>
<pre><code class="javascript">function BinarySearchFirst(arr, target) &#123;
    if (arr.length &lt;= 1) return -1
    // 低位下标
    let lowIndex = 0
    // 高位下标
    let highIndex = arr.length - 1

    while (lowIndex &lt;= highIndex) &#123;
        // 中间下标
        const midIndex = Math.floor((lowIndex + highIndex) / 2)
        if (target &lt; arr[midIndex]) &#123;
            highIndex = midIndex - 1
        &#125; else if (target &gt; arr[midIndex]) &#123;
            lowIndex = midIndex + 1
        &#125; else &#123;
            // 当 target 与 arr[midIndex] 相等的时候，如果 midIndex 为0或者前一个数比 target 小那么就找到了第一个等于给定值的元素，直接返回
            if (midIndex === 0 || arr[midIndex - 1] &lt; target) return midIndex
            // 否则高位下标为中间下标减1，继续查找
            highIndex = midIndex - 1
        &#125;
    &#125;
    return -1
&#125;
</code></pre>
<p>实际上，除了有序的数组可以使用，还有一种特殊的数组可以应用，那就是轮转后的有序数组</p>
<p>有序数组即一个有序数字以某一个数为轴，将其之前的所有数都轮转到数组的末尾所得</p>
<p>例如，[4, 5, 6, 7, 0, 1, 2]就是一个轮转后的有序数组</p>
<p>该数组的特性是存在一个分界点用来分界两个有序数组，如下：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65656565323133302d323938372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>分界点有如下特性：</p>
<ul>
<li>分界点元素 &gt;&#x3D; 第一个元素</li>
<li>分界点元素 &lt; 第一个元素</li>
</ul>
<p>代码实现如下：</p>
<pre><code class="javascript">function search (nums, target) &#123;
  // 如果为空或者是空数组的情况
  if (nums == null || !nums.length) &#123;
    return -1;
  &#125;
  // 搜索区间是前闭后闭
  let begin = 0,
    end = nums.length - 1;
  while (begin &lt;= end) &#123;
    // 下面这样写是考虑大数情况下避免溢出
    let mid = begin + ((end - begin) &gt;&gt; 1);
    if (nums[mid] == target) &#123;
      return mid;
    &#125;
    // 如果左边是有序的
    if (nums[begin] &lt;= nums[mid]) &#123;
      //同时target在[ nums[begin],nums[mid] ]中，那么就在这段有序区间查找
      if (nums[begin] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;
        end = mid - 1;
      &#125; else &#123;
        //否则去反方向查找
        begin = mid + 1;
      &#125;
      //如果右侧是有序的
    &#125; else &#123;
      //同时target在[ nums[mid],nums[end] ]中，那么就在这段有序区间查找
      if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end]) &#123;
        begin = mid + 1;
      &#125; else &#123;
        end = mid - 1;
      &#125;
    &#125;
  &#125;
  return -1;
&#125;;
</code></pre>
<p>对比普通的二分查找法，为了确定目标数会落在二分后的哪个部分，我们需要更多的判定条件</p>
<h4 id="三、应用场景-8"><a href="#三、应用场景-8" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>二分查找法的<code>O(logn)</code>让它成为十分高效的算法。不过它的缺陷却也是比较明显，就在它的限定之上：</p>
<ul>
<li>有序：我们很难保证我们的数组都是有序的</li>
<li>数组：数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)，并且数组的存储是需要连续的内存空间，不适合大数据的情况</li>
</ul>
<p>关于二分查找的应用场景，主要如下：</p>
<ul>
<li>不适合数据量太小的数列；数列太小，直接顺序遍历说不定更快，也更简单</li>
<li>每次元素与元素的比较是比较耗时的，这个比较操作耗时占整个遍历算法时间的大部分，那么使用二分查找就能有效减少元素比较的次数</li>
<li>不适合数据量太大的数列，二分查找作用的数据结构是顺序表，也就是数组，数组是需要连续的内存空间的，系统并不一定有这么大的连续内存空间可以使用</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对分而治之、动态规划的理解？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对分而治之、动态规划的理解？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对分而治之、动态规划的理解？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对分而治之、动态规划的理解？区别？</h3><h4 id="一、分而治之"><a href="#一、分而治之" class="headerlink" title="一、分而治之"></a>一、分而治之</h4><p>分而治之是算法设计中的一种方法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p>
<p>关于分而治之的实现，都会经历三个步骤：</p>
<ul>
<li>分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题</li>
<li>解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题</li>
<li>合并：将各子问题的解合并为原问题的解</li>
</ul>
<p>实际上，关于分而治之的思想，我们在前面已经使用，例如归并排序的实现，同样经历了实现分而治之的三个步骤：</p>
<ul>
<li>分解：把数组从中间一分为二</li>
<li>解决：递归地对两个子数组进行归并排序</li>
<li>合并：将两个字数组合并称有序数组</li>
</ul>
<p>同样关于快速排序的实现，亦如此：</p>
<ul>
<li>分：选基准，按基准把数组分成两个字数组</li>
<li>解：递归地对两个字数组进行快速排序</li>
<li>合：对两个字数组进行合并</li>
</ul>
<p>同样二分搜索也能使用分而治之的思想去实现，代码如下：</p>
<pre><code class="javascript">function binarySearch(arr,l,r,target)&#123;
    if(l&gt; r)&#123;
        return -1;
    &#125;
    let mid = l + Math.floor((r-l)/2)
    if(arr[mid] === target)&#123;
        return mid;
    &#125;else if(arr[mid] &lt; target )&#123;
        return binarySearch(arr,mid + 1,r,target)
    &#125;else&#123;
        return binarySearch(arr,l,mid - 1,target)
    &#125;
&#125;
</code></pre>
<h4 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h4><p>动态规划，同样是算法设计中的一种方法，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</p>
<p>常常适用于有重叠子问题和最优子结构性质的问题</p>
<p>简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决</p>
<p>然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。</p>
<p>一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2的时候，F(n) &#x3D; F(n-1) + F(n-2) ，</p>
<p>f(10)&#x3D; f(9)+f(8),f(9) &#x3D; f(8) + f(7)…是重叠子问题，当n &#x3D; 1、2的时候，对应的值为2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划</p>
<p>比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景</p>
<p>关于动态规划题目解决的步骤，一般如下：</p>
<ul>
<li>描述最优解的结构</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值</li>
<li>由计算出的结果构造一个最优解</li>
</ul>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</p>
<p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的，而分而治之的子问题是相互独立的</p>
<p>若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次</p>
<p>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间</p>
<p>综上，可得：</p>
<ul>
<li>动态规划：有最优子结构和重叠子问题</li>
<li>分而治之：各子问题独立</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对贪心算法、回溯算法的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对贪心算法、回溯算法的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对贪心算法、回溯算法的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对贪心算法、回溯算法的理解？应用场景？</h3><h4 id="一、贪心算法"><a href="#一、贪心算法" class="headerlink" title="一、贪心算法"></a>一、贪心算法</h4><p>贪心算法，又称贪婪算法，是算法设计中的一种思想</p>
<p>其期待每一个阶段都是局部最优的选择，从而达到全局最优，但是结果并不一定是最优的</p>
<p>举个零钱兑换的例子，如果你有1元、2元、5元的钱币数张，用于兑换一定的金额，但是要求兑换的钱币张数最少</p>
<p>如果现在你要兑换11元，按照贪心算法的思想，先选择面额最大的5元钱币进行兑换，那么就得到11 &#x3D; 5 + 5 + 1 的选择，这种情况是最优的</p>
<p>但是如果你手上钱币的面额为1、3、4，想要兑换6元，按照贪心算法的思路，我们会 6 &#x3D; 4 + 1 + 1这样选择，这种情况结果就不是最优的选择</p>
<p>从上面例子可以看到，贪心算法存在一些弊端，使用到贪心算法的场景，都会存在一个特性：</p>
<p>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法</p>
<p>至于是否选择贪心算法，主要看是否有如下两大特性：</p>
<ul>
<li>贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择</li>
<li>最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在</li>
</ul>
<h4 id="二、回溯算法"><a href="#二、回溯算法" class="headerlink" title="二、回溯算法"></a>二、回溯算法</h4><p>回溯算法，也是算法设计中的一种思想，是一种渐进式寻找并构建问题解决方式的策略</p>
<p>回溯算法会先从一个可能的工作开始解决问题，如果不行，就回溯并选择另一个动作，知道将问题解决</p>
<p>使用回溯算法的问题，有如下特性：</p>
<ul>
<li>有很多路，例如一个矩阵的方向或者树的路径</li>
<li>在这些的路里面，有死路也有生路，思路即不符合题目要求的路，生路则符合</li>
<li>通常使用递归来模拟所有的路</li>
</ul>
<p>常见的伪代码如下：</p>
<pre><code class="javascript">result = []
function backtrack(路径, 选择列表):
  if 满足结束条件:
    result.add(路径)
  return

  for 选择 of 选择列表:
    做选择
    backtrack(路径, 选择列表)
    撤销选择
</code></pre>
<p>重点解决三个问题：</p>
<ul>
<li>路径：也就是已经做出的选择</li>
<li>选择列表</li>
<li>结束条件</li>
</ul>
<p>例如经典使用回溯算法为解决全排列的问题，如下：</p>
<p>一个不含重复数字的数组 <code>nums</code> ，我们要返回其所有可能的全排列，解决这个问题的思路是：</p>
<ul>
<li>用递归模拟所有的情况</li>
<li>遇到包含重复元素的情况则回溯</li>
<li>收集到所有到达递归终点的情况，并返回、</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32613033306630302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">var permute = function(nums) &#123;
    const res = [], path = [];
    backtracking(nums, nums.length, []);
    return res;
    
    function backtracking(n, k, used) &#123;
        if(path.length === k) &#123;
            res.push(Array.from(path));
            return;
        &#125;
        for (let i = 0; i &lt; k; i++ ) &#123;
            if(used[i]) continue;
            path.push(n[i]);
            used[i] = true; // 同支
            backtracking(n, k, used);
            path.pop();
            used[i] = false;
        &#125;
    &#125;
&#125;;
</code></pre>
<h4 id="三、总结-3"><a href="#三、总结-3" class="headerlink" title="三、总结"></a>三、总结</h4><p>前面也初步了解到分而治之、动态规划，现在再了解到贪心算法、回溯算法</p>
<p>其中关于分而治之、动态规划、贪心策略三者的求解思路如下：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35303462353233302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>其中三者对应的经典问题如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36326364633931302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>