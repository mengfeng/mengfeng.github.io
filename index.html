<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-什么是性能优化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"
    >什么是性能优化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2023-01-06T03:46:03.000Z" itemprop="datePublished">2023-01-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">什么是性能优化</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是性能优化"><a href="#什么是性能优化" class="headerlink" title="什么是性能优化"></a>什么是性能优化</h1><h3 id="1-性能的起因"><a href="#1-性能的起因" class="headerlink" title="1.性能的起因"></a>1.性能的起因</h3><p>​		市场上的某个功能还没有能满足其需求的可选方案的时候，如果出来一个应用即使很难用，用户都要忍着用。如果这个功能确实能解决用户的某些痛点需求，且有其存在的价值，那么让用户忍受糟糕体验的背后，就存在 对产品优化和改进的空间。</p>
<h3 id="2-性能的影响"><a href="#2-性能的影响" class="headerlink" title="2.性能的影响"></a>2.性能的影响</h3><p>​		大部分网站体现的价值都无外乎信息的载体、交互的工具或商品流通的渠道，这就要求它们需要与更多的用户建立联系，同时还要保持所建立的联系拥有绵延不绝的用户黏性，所以网站就不能只关注自我表达，而不顾及用户是否喜欢。</p>
<h4 id="2-1用户的留存"><a href="#2-1用户的留存" class="headerlink" title="2.1用户的留存"></a>2.1用户的留存</h4><p>​		我们都希望用户访问网站所进行的交互，对网站构建的内容来讲是有意义的，比如，电商网站希望用户浏览并购买商品，社交网站希望用户之间进行互动，视频网站希望用户观看视频，而这些希望都是建立在网站用户留存的基础上的。网站用户的留存情况，一般指的是用户自登录注册之日起，经过一段时间后， 仍然还在使用该网站的用户数。统计出注册用户数与留存用户数后，就可以计算出用户留存率，这个指标对网站的运营有重要的指导意义。</p>
<p>​		根据Google营销平台提供的调研发现，如果网站页面的加载时间超过3s,就会有53%的移动网站的访问遭到用户抛弃。同时他们还针对加载时间分别在4s内和20s内的网站进行比较，发现加载时间在5s内的网站，用户的停留时间相比会长70%，用户在一定时间内从该网站离开的跳出率会低35%，而网站上展示广告的可见率也会高25%。</p>
<p>​		虽然影响用户留存的因素不止性能这一方面， 但从上述数据可知，通过优化性能来保证留存事是必要的措施。	</p>
<h4 id="2-2网站的转化率"><a href="#2-2网站的转化率" class="headerlink" title="2.2网站的转化率"></a>2.2网站的转化率</h4><p>​		从运营角度来看，网站转化率是一个非常 重要的考量指标，网站转化率指的是用户进行了某项目标行为的访问次数与总访问次数的比率。某项目标行为可以是用户注册、资源下载、商品购买等一 系列用户行为，简言之，比如在电商网站上浏览了某个商品的用户中，有多少位用户最终购买了该商品，其所占的比例就可以看作访客到消费者的转化率。</p>
<p>​		根据Mobify (一家著 名的电子商务优化平台)的调研，发现商品的结账页面加载时间每减少100ms,基于该商品购买访问的转化率就会增加1.55%， 这个比率对大型电商网站来讲，其所带来的年均收入增长将会是上千万元。Google 营销平台的调研也指出，加载时间在5s以内的网站会比在20s以内的网站的广告收入多一倍。</p>
<p>​		目前大部分互联网广告营销都渐趋精准化，即广告商的广告费会根据经广告导流，产生确定的用户交易后再收取。如此看来网站性能不仅影响用户体验，对于广告主和广告商的经济利益也会带来实实在在的影响。</p>
<h4 id="2-3体验与传播"><a href="#2-3体验与传播" class="headerlink" title="2.3体验与传播"></a>2.3体验与传播</h4><p>​		当用户通过手机、平板电脑等移动设备经运营商网络浏览网站时，所产生的流量数据通常是根据字节数进行收费的。虽然从2G、 3G 到4G,甚至5G,运营商所收取的流量费用单价一直在下滑，但与此同时，页面所承载的内容却在不断增大，并且这一趋势似乎将持续下去。 那么用户必将为过多的流量数据支付相应的费用，若所访问网站包含的资源文件过大、组织冗余，用户便会浪费过多的网络资费，同时过大的资源传输量也会延长请求响应的时间，最终降低用户的体验度。</p>
<p>​		性能问题引起的所谓用户体验差，造成的影响并非单纯是用户觉得不喜欢就放弃了使用。用户还会拒绝向自己的周边网络推荐该网站或应用，更坏的情况是用户会对低性能进行差评。口碑是互联网时代t分可靠的通行证，如果我们不重视性能问题，经过网络口碑的放大效应，网站的发展不仅会遇到瓶颈，甚至还可能会日薄西山。</p>
<h3 id="3-性能评估模型"><a href="#3-性能评估模型" class="headerlink" title="3.性能评估模型"></a>3.性能评估模型</h3><p>​		我们先来约定一个原则，以用户为中心，然后根据该原则引出指导后文涉及的各种优化策略，所参照的性能模型为RAIL性能模型。这个名字的由来是四个英文单词的首字母:响应( Response)、动画(Animation)、 空闲(Idle)、加载(Load)，这四个单词代表与网站或应用的生命周期相关的四个方面，这些方面会以不同的方式影响整个网站的性能。</p>
<p><img src="/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20230106102130579.png"></p>
<p>我们将用户作为之后性能优化的中心，首先需要了解用户对于延迟的反应。用户感知延迟的时间窗口。</p>
<table>
<thead>
<tr>
<th align="center">延迟</th>
<th align="center">用户反应</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0～16ms</td>
<td align="center">人眼可以感知每秒60帧的动画转场，即每帧16ms，除了浏览器将每一帧画面绘制到屏幕上的时间，网站应用大约需要10ms来生成一帧</td>
</tr>
<tr>
<td align="center">0～100ms</td>
<td align="center">在该时间窗口内来响应用户的操作，才会是流畅的体验</td>
</tr>
<tr>
<td align="center">100～300ms</td>
<td align="center">用户能感知轻微的延迟</td>
</tr>
<tr>
<td align="center">300～1000ms</td>
<td align="center">所感知的延迟会被用户当作网站页面加载或更改视图过程的一部分</td>
</tr>
<tr>
<td align="center">&gt;1s</td>
<td align="center">用户的注意力将离开之前执行的任务</td>
</tr>
<tr>
<td align="center">&gt;10s</td>
<td align="center">用户感觉失望，可能会放弃任务</td>
</tr>
</tbody></table>
<h4 id="3-1响应"><a href="#3-1响应" class="headerlink" title="3.1响应"></a>3.1响应</h4><p>​		网站性能对于响应方面的要求是，在用户感知延迟之前接收到操作的反馈。比如用户进行了文本输入，按钮单击、表单切换及启动动画等操作后，必须在100m内收到反馈，如果超过100ms的时间窗口，用户就会感知延迟。</p>
<p>​		看似很基本的用户操作背后，可能会隐藏着复杂的业务逻辑处理及网络请求与数据计算。对此我们应当谨慎，将较大开销的工作放在后台异步执行，而即便后白处理要数百毫秒才能完成的操作，也应当给用户提供及时的阶段性反馈。</p>
<p>​		比如在单击按钮向后台发起某项业务处理请求时，首先反馈给用户开始处理的提示，然后在处理完成的回调后反馈完成的提示。</p>
<h4 id="3-2动画"><a href="#3-2动画" class="headerlink" title="3.2动画"></a>3.2动画</h4><p>​		前端所涉及的动画不仅有炫酷的UI特效，还包括滚动和触摸拖动等交互效果，而这一方面的性能要求就是流畅。 众所周知，人眼具有视觉暂留特性，就是当光对视网膜所产生的视觉在光停止作用后，仍能保留一段时间。</p>
<p>​		研究表明这是由于视神经存在反应速度造成的， 其值是1&#x2F;24s，即当我们所见的物体移除后，该物体在我们眼中并不会立即消失，而会延续存在1&#x2F;24s 的时间。对动画来说，无论动画帧率有多高，最后我们仅能分辨其中的30帧，但越高的帧率会带来更好的流畅体验，因此动画要尽力达到60fps的帧率，每一帧画面的生成都需要经过若干步骤，根据60fps 帧率的计算，帧图像的生成预算为16ms ( 1000ms&#x2F;60 约等于 16.6ms)，除去浏览器绘制新帧的时间，留给执行代码的时间仅10ms 左右。关于这个维度的具体优化策略，会在后面优化谊染过程的相关章节中详细介绍。</p>
<h4 id="3-3空闲"><a href="#3-3空闲" class="headerlink" title="3.3空闲"></a>3.3空闲</h4><p>​		要使网站响应迅速、动画流畅，通常都需要较长的处理时间，但以用户为中心来看待性能问题，就会发现并非所有工作都需要在响应和加载阶段完成，我们完全可以利用浏览器的空闲时间处理可延迟的任务，只要让用户感受不到延迟即可。利用空闲时间处理延迟，可减少预加载的数据大小，以保证网站或应用快速完成加载。</p>
<p>​		为了更加合理地利用浏览器的空闲时间，最好将处理任务按50ms为单位分组。这么做就是保证用户在发生操作后的100ms 内给出响应。</p>
<h4 id="3-4-加载"><a href="#3-4-加载" class="headerlink" title="3.4 加载"></a>3.4 加载</h4><p>​		用户感知要求我们尽量在1s内完成页面加载，如果没有完成，用户的注意力就会分散到其他事情上，并对当前处理的任务产生中断感。需要注意的是，这里在1s内完成加载井谊染出页面的要求，并非要完成所有页面资源的加载，从用户感如体验的角度来说，只要关键谊染路径完成，用户就会认为全部加载已完成。</p>
<p>​		对于其他非关键资源的加载，延迟到浏览器空闲时段再进行，是比较常见的渐进式优化策略。</p>
<h3 id="4-性能优化的步骤"><a href="#4-性能优化的步骤" class="headerlink" title="4.性能优化的步骤"></a>4.性能优化的步骤</h3><p>​		RAIL性能模型指出了用户对不同延迟时间的感知度，以用户为中心的原则，就是要让用户满意网站或应用的性能体验。</p>
<p>​		不同类型的操作，需要在规定的时间窗口内完成，所以进行性能优化的步骤般是:首先可量化地评估出网站或应用的性能表现,然后立足于网站页面响应的生命周期，分析出造成较差性能表现的原因,最后进行技术改造、可行性分析等具体的优化实施。</p>
<h4 id="4-1-性能测量"><a href="#4-1-性能测量" class="headerlink" title="4.1 性能测量"></a>4.1 性能测量</h4><p>​		如果把对网站的性能优化比作一场旅程， 它无疑会是漫长且可能还略带泥泞的，那么在开始之前我们有必要对网站进行性能测量，以知道优化的方向在何处。通常我们会借助.些工具来完成性能测量.</p>
<p>1.Chrome浏览器的Performance功能</p>
<p>​		通过Chrome浏览器访问我们要进行性能测量的网站，打开开发者工具的Performance选项卡。单击左上角的“开始评估”按钮后刷新网站，该工具便开始分析页面资源加载、渲染、请求响应等各环节耗费的时间线，据此便可分析定程度的性能问题， 比如JavaScript 的执行是否会触发大量视觉变化的计算，重绘和重排(或回流)是否会被多次触发等。</p>
<p>2.灯塔(Lighthouse)</p>
<p>​		Lighthouse是一个开源的自动化审查网站页面性能的工具，可根据所提供的网站URL从性能、可访问性、渐进式Web应用、SEO (搜索引擎优化)等多个方面进行自动化分析，最终给出一份具有指导意义的报告。它既可以当作Chrome的扩展插件来使用，又可以在开发者工具中直接使用。</p>
<p><img src="/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20230106110717868.png"></p>
<p><img src="/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20230106110753427.png"></p>
<p>除此之外，还会经常用到的性能测试工具有PageSpeed Insights、WEBPAGETEST、Pingdom等。</p>
<h4 id="4-2生命周期"><a href="#4-2生命周期" class="headerlink" title="4.2生命周期"></a>4.2生命周期</h4><pre><code>     网站页面的生命周期，通俗地讲就是从我们在浏览器的地址栏中输入一个URL后，到整个页面渲染出来的过程。整个过程包括域名解析，建立TCP连接，前后端通过HTTP进行会话，压缩与解压缩，以及前端的关键渲染路径等，把这些阶段拆解开来看，不仅能容易地获得优化性能的启发，而且也能为今后的前端工程师之路构建完整的知识框架。
</code></pre>
<p><img src="/2023/01/06/%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20230106113810661.png"></p>
<h4 id="4-3优化方案"><a href="#4-3优化方案" class="headerlink" title="4.3优化方案"></a>4.3优化方案</h4><p>​		经过对网站页面性能的测量及渲染过程的了解，相信你对于糟糕性能体验的原因已经比较清楚了，那么接下来便是优化性能。</p>
<p>(1)传输资源的优化，比如图像资源， 不同的格式类型会有不同的使用场景，在使用的过程中是否恰当。</p>
<p>(2)加载过程的优化，比如延迟加载，是否有不需要在首屏展示的非关键信息，占用了页面加载的时间。</p>
<p>(3) JavaScript 是现代大型网站中相当“昂贵”的资源，是否进行了压缩，书写是否规范，有无考虑内存泄漏等。</p>
<p>(4)关键渲染路径优化，比如是否存在不必要的重绘和回流。</p>
<p>(5)本地存储和浏览器缓存。</p>
<h3 id="参考：Web前端性能优化"><a href="#参考：Web前端性能优化" class="headerlink" title="参考：Web前端性能优化"></a>参考：Web前端性能优化</h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-面试手撕代码合集"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/05/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/"
    >面试手撕代码合集</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/05/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/" class="article-date">
  <time datetime="2023-01-05T02:10:45.000Z" itemprop="datePublished">2023-01-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/">面试手撕代码合集</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="面试手撕代码合集"><a href="#面试手撕代码合集" class="headerlink" title="面试手撕代码合集"></a>面试手撕代码合集</h1><h2 id="1-柯里化函数"><a href="#1-柯里化函数" class="headerlink" title="1.柯里化函数"></a>1.柯里化函数</h2><pre><code class="javascript">function add() &#123;
    const _args = [...arguments];
    function fn() &#123;
      _args.push(...arguments);
      return fn; //一直重复收集参数
    &#125;
    fn.toString = function() &#123;
      return _args.reduce((sum, cur) =&gt; sum + cur);
    &#125;
    return fn;
  &#125;
console.log(add(1)(2)(3)(4).toString()) //10
console.log(add(1,2)(1, 2, 3)(2).toString()) //11
</code></pre>
<h2 id="2-千位符转换"><a href="#2-千位符转换" class="headerlink" title="2.千位符转换"></a>2.千位符转换</h2><pre><code class="javascript">// 将金额类型转为数字类型
function toNum(str) &#123;
    return str.replace(/\,|\￥/g, &quot;&quot;);
&#125;

// 保留两位小数（四舍五入）
function toPrice(num) &#123;
    num = parseFloat(toNum(num)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);
&#125;

// 保留两位小数（不四舍五入）
function toPrice1(num) &#123;
    num = parseFloat(toNum(num).replace(/(\.\d&#123;2&#125;)\d+$/,&quot;$1&quot;)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);;
&#125;

// 不处理小数部分
function toPrice2(num) &#123;
    var source = toNum(num).split(&quot;.&quot;);
    source[0] = source[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + source.join(&quot;.&quot;)
&#125;

console.log(toPrice(&#39;12312.236&#39;)) //￥12,312.24
console.log(toPrice1(&#39;12312.234&#39;)) //￥12,312.23
console.log(toPrice2(&#39;1232342312.234&#39;)) //￥1,232,342,312.234
</code></pre>
<h2 id="3-用setTimeout实现setInterval-计数器"><a href="#3-用setTimeout实现setInterval-计数器" class="headerlink" title="3.用setTimeout实现setInterval(计数器)"></a>3.用setTimeout实现setInterval(计数器)</h2><pre><code class="javascript">var i = 10;
let fn = () =&gt; &#123;
    console.log(i--);
&#125;
function mySetInterval(fn, delay, times) &#123;
    let timer = setTimeout(function a() &#123;
        fn()
        times--
        timer = setTimeout(a, delay)
        if (times &lt;= 0) &#123;
            clearTimeout(timer)
        &#125;
    &#125;, delay)
&#125;
mySetInterval(fn, 1000, 10)
</code></pre>
<h2 id="4-数组扁平化"><a href="#4-数组扁平化" class="headerlink" title="4.数组扁平化"></a>4.数组扁平化</h2><pre><code class="javascript">//递归实现
var arr = [1,2,[3,4,[5,6]]]
function flatten(arr)&#123;
    let result = []
    arr.forEach(item =&gt; &#123;
        if(Array.isArray(item))&#123;
            result = result.concat(flatten(item))
        &#125;else&#123;
            result.push(item)
        &#125;
    &#125;);
    return result
&#125;
console.log(flatten(arr)) //[ 1, 2, 3, 4, 5, 6 ]

//利用reduce函数迭代
var arr1 = [1,2,[3,4,[5,6]]]
function flatten1(arr)&#123;
    return arr.reduce((res,next) =&gt; &#123;
        return res.concat(Array.isArray(next) ? flatten1(next) : next)
    &#125;,[])
&#125;
console.log(flatten1(arr1)) //[ 1, 2, 3, 4, 5, 6 ]
</code></pre>
<h2 id="5-深拷贝"><a href="#5-深拷贝" class="headerlink" title="5.深拷贝"></a>5.深拷贝</h2><pre><code class="javascript">function deepClone(obj,hash = new WeakMap())&#123;
    if(obj == null) return obj;
    if(obj instanceof Date) return new Date(obj);
    if(obj instanceof RegExp) return new RegExp(obj);
    if(typeof obj !== &#39;object&#39;) return obj;
    if(hash.get(obj)) return hash.get(obj);
    let cloneObj = new obj.constructor;
    hash.set(obj,cloneObj);
    for(let key in obj)&#123;
        if(obj.hasOwnProperty(key))&#123;
            cloneObj[key] = deepClone(obj[key],hash);
        &#125;
    &#125;
    return cloneObj;
&#125;

let obj = &#123;name:1,address:&#123;x:1000&#125;&#125;;
let d = deepClone(obj);
obj.address.x = 200;
console.log(d); //&#123;name:1,address:&#123;x:1000&#125;&#125;
</code></pre>
<h2 id="6-Promise-all"><a href="#6-Promise-all" class="headerlink" title="6.Promise.all"></a>6.Promise.all</h2><pre><code class="javascript">Promise.prototype.all = function(promises)&#123;
    let results = [];
    let promiseCount = 0;
    let promisesLength = promises.length;
    return new Promise(function(resolve,reject)&#123;
        for(let val of promises)&#123;
            Promise.resolve(val).then(function(res)&#123;
                promiseCount++;
                //results.push(res)
                results[i] = res;
                //当所有函数都正确执行了，resolve输出所有返回结果
                if(promiseCount === promisesLength)&#123;
                    return resolve(results);
                &#125;
            &#125;,function(err)&#123;
                return reject(err);
            &#125;)
        &#125;
    &#125;)
&#125;

//测试
let promise1 = new Promise(function(resolve) &#123;
    resolve(1);
  &#125;);
  let promise2 = new Promise(function(resolve) &#123;
    resolve(2);
  &#125;);
  let promise3 = new Promise(function(resolve) &#123;
    resolve(3);
  &#125;);
  
  let promiseAll = Promise.all([promise1, promise2, promise3]);
  promiseAll.then(function(res) &#123;
    console.log(res);
  &#125;);//[1,2,3]
</code></pre>
<h2 id="7-Promise-race"><a href="#7-Promise-race" class="headerlink" title="7.Promise.race"></a>7.Promise.race</h2><pre><code class="javascript">Promise.race = function(promises)&#123;
    //将可迭代对象转换为数组
    promises = Array.from(promises);
    return new Promise((resolve,reject)=&gt;&#123;
        if(promises.length === 0)&#123;
            //空的可迭代对象，用于pending状态
        &#125;else&#123;
            for(let i = 0;i &lt; promises.length;i++)&#123;
                Promise.resolve(promises[i]).then((data)=&gt;&#123;
                    resolve(data);
                &#125;).catch((reason)=&gt;&#123;
                    reject(reason)
                &#125;)
            &#125;
        &#125;
    &#125;)
&#125;

//测试
let p1 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;success&#39;)
    &#125;,1000)
&#125;)
let p2 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;faild&#39;)
    &#125;,500)
&#125;)

Promise.race([p1,p2]).then(result=&gt;&#123;
console.log(result)  //  faild    faild耗时短
&#125;)
</code></pre>
<h2 id="8-instanceof"><a href="#8-instanceof" class="headerlink" title="8.instanceof"></a>8.instanceof</h2><pre><code class="javascript">function new_instance_of(leftValue,rightValue)&#123;
    let rightProto = rightValue.prototype;//取右边表达式的 prototype 值
    leftValue = leftValue.__proto__;//取左表达式的 __proto__ 值
    while(true)&#123;
        if(leftValue == null)&#123;
            return false;
        &#125;
        if(leftValue === rightProto)&#123;
            return true;
        &#125;
        leftValue = leftValue.__proto__;
    &#125;
&#125;
function Foo()&#123;&#125;
console.log(new_instance_of(Foo,Object))//true
</code></pre>
<h2 id="9-js继承"><a href="#9-js继承" class="headerlink" title="9.js继承"></a>9.js继承</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h3><pre><code class="javascript"> // 原型链继承
  function Super()&#123;
    this.color=[&#39;red&#39;,&#39;yellow&#39;,&#39;black&#39;]
  &#125;

  function Sub()&#123;
  &#125;
  //继承了color属性 Sub.prototype.color=[&#39;red&#39;,&#39;yellow&#39;,&#39;black&#39;]
  Sub.prototype=new Super()

  //创建实例 instance1.__proto__.color
  const instance1=new Sub()
  const instance2=new Sub()
  console.log(instance1.__proto__.color===instance2.__proto__.color) //true
</code></pre>
<h3 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2.构造函数继承"></a>2.构造函数继承</h3><pre><code class="javascript">function Super(name,age)&#123;
    this.name = name;
    this.age = age;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;];
    this.sayHi = function()&#123;
        console.log(&#39;hi&#39;)
    &#125;
    console.log(this)
&#125;
function Sub()&#123;
    //改变this指向
    Super.apply(this,arguments)
    this.height = 180;
&#125;

var instance1 = new Sub(&#39;mengfeng&#39;,25);
var instance2 = new Sub(&#39;mengfeng123&#39;,24);
instance1.sayHi();//hi
</code></pre>
<h3 id="3-实例继承"><a href="#3-实例继承" class="headerlink" title="3.实例继承"></a>3.实例继承</h3><pre><code class="javascript">new
</code></pre>
<h3 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4.拷贝继承"></a>4.拷贝继承</h3><pre><code class="javascript">//深拷贝
</code></pre>
<h3 id="5-组合继承"><a href="#5-组合继承" class="headerlink" title="5.组合继承"></a>5.组合继承</h3><pre><code class="javascript">function Super(name,age)&#123;
    this.name = name;
    this.age = age;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;]
&#125;

Super.prototype.sayHi = function()&#123;
    console.log(&#39;hi&#39;)
&#125;

function Sub(name,age,height)&#123;
    Super.apply(this,arguments)
    this.height = height;
&#125;

Sub.prototype = new Super(&#39;w&#39;,22);
Sub.prototype.constructor = Sub;
console.log(Sub.prototype)
Sub.prototype.sayHello = function()&#123;
    console.log(&#39;hello&#39;)
&#125;

var instance1 = new Sub(&#39;mengfeng&#39;,23,180);
var instance2 = new Sub(&#39;mengfeng123&#39;,24,181);
console.log(instance1)
</code></pre>
<h3 id="6-寄生组合继承"><a href="#6-寄生组合继承" class="headerlink" title="6.寄生组合继承"></a>6.寄生组合继承</h3><pre><code class="javascript">function inheritPrototype(Sub,Super)&#123;
    var subPrototype=Object.create(Super.prototype)
    subPrototype.constructor=Sub
    Sub.prototype=subPrototype
    
  &#125;
  function Super(name)&#123;
    this.name=name
  &#125;
  Super.prototype.sayHi=function()&#123;
    console.log(this.name)//ccdida
  &#125;
  function Sub(name)&#123;
    Super.call(this,name)
  &#125;
  inheritPrototype(Sub,Super)

  Sub.prototype.sayHello=function()&#123;
    console.log(&#39;sayHello&#39;)
  &#125;

  var instance1=new Sub(&#39;ccdida&#39;)
  console.log(instance1.__proto__)
  console.log(instance1.__proto__.__proto__)
</code></pre>
<h2 id="10-对象扁平化"><a href="#10-对象扁平化" class="headerlink" title="10.对象扁平化"></a>10.对象扁平化</h2><pre><code class="javascript">//对象扁平化
function flat(obj, key = &quot;&quot;, res = &#123;&#125;, isArray = false) &#123; 
    for (let [k, v] of Object.entries(obj)) &#123; 
      if (Array.isArray(v)) &#123; 
        let tmp = isArray ? key + &quot;[&quot; + k + &quot;]&quot; : key + k 
        flat(v, tmp, res, true) 
      &#125; else if (typeof v === &quot;object&quot;) &#123; 
        let tmp = isArray ? key + &quot;[&quot; + k + &quot;].&quot; : key + k + &quot;.&quot; 
        flat(v, tmp, res) 
      &#125; else &#123; 
        let tmp = isArray ? key + &quot;[&quot; + k + &quot;]&quot; : key + k 
        res[tmp] = v 
      &#125; 
    &#125; 
    return res 
  &#125;
  
  var entryObj = &#123;
    a: &#123;
        b: &#123;
            c: &#123;
                dd: &#39;abcdd&#39;
            &#125;
        &#125;,
        d: &#123;
            xx: &#39;adxx&#39;
        &#125;,
        e: &#39;ae&#39;
    &#125;
&#125;

console.log(flat(entryObj))
</code></pre>
<h2 id="11-发布订阅"><a href="#11-发布订阅" class="headerlink" title="11.发布订阅"></a>11.发布订阅</h2><pre><code class="javascript">class EventEmitter&#123;
    constructor()&#123;
        this._events = &#123;&#125;;
    &#125;

    on(eventName, callback)&#123;
        if(this._events[eventName])&#123;
            if(this.eventName !== &quot;newListener&quot;)&#123;
                this.emit(&quot;newListener&quot;, eventName)
            &#125;
        &#125;
        const callbacks = this._events[eventName] || [];
        callbacks.push(callback);
        this._events[eventName] = callbacks
    &#125;

    emit(eventName, ...args)&#123;
        const callbacks = this._events[eventName] || [];
        callbacks.forEach(cb =&gt; cb(...args))
    &#125;

    once(eventName, callback)&#123;
        const one = (...args)=&gt;&#123;
            callback(...args)
            this.off(eventName, one)
        &#125;
        one.initialCallback = callback;
        this.on(eventName, one)
    &#125;

     off(eventName, callback)&#123;
        const callbacks = this._events[eventName] || []
        const newCallbacks = callbacks.filter(fn =&gt; fn != callback &amp;&amp; fn.initialCallback != callback /* 用于once的取消订阅 */)
        this._events[eventName] = newCallbacks;
    &#125;
&#125;



const events = new EventEmitter()

events.on(&quot;newListener&quot;, function(eventName)&#123;
    console.log(`eventName`, eventName)
&#125;)

events.on(&quot;hello&quot;, function()&#123;
    console.log(&quot;hello&quot;);
&#125;)

let cb = function()&#123;
    console.log(&#39;cb&#39;);
&#125;
events.on(&quot;hello&quot;, cb)

events.off(&quot;hello&quot;, cb)

function once()&#123;
    console.log(&quot;once&quot;);
&#125;
events.once(&quot;hello&quot;, once)

events.off(&quot;hello&quot;, once)
events.emit(&quot;hello&quot;)
events.emit(&quot;hello&quot;)
</code></pre>
<h2 id="12-反柯里化函数"><a href="#12-反柯里化函数" class="headerlink" title="12.反柯里化函数"></a>12.反柯里化函数</h2><pre><code class="javascript">Function.prototype.uncurrying = function() &#123;
    var self = this;   //self为Array.prototype.push
    return function() &#123;
        //obj = &#123;0:1, length: 1&#125;, arguments = [2, callee: ƒ, Symbol(Symbol.iterator): ƒ]
        var obj = Array.prototype.shift.call(arguments); 
        
        //Array.ptototype.push(obj, 2)
        return self.apply(obj, arguments);
    &#125;
&#125;
var testObj = &#123;
    length: 1,
    0: 1
&#125;
var push = Array.prototype.push.uncurrying();
push(testObj, 2);
console.log(testObj);   //&#123;0: 1, 1: 2, length: 2&#125;
</code></pre>
<h2 id="13-防抖"><a href="#13-防抖" class="headerlink" title="13.防抖"></a>13.防抖</h2><pre><code class="javascript">//scroll方法中的do somthing至少间隔500毫秒执行一次
window.addEventListener(&#39;scroll&#39;,function()&#123;
    var timer;//使用闭包，缓存变量
    return function()&#123;
    if(timer) clearTimeout(timer);
    timer = setTimeout(function()&#123;
    console.log(&#39;do somthing&#39;)
&#125;,500)
&#125;
&#125;());//此处()作用 - 立即调用return后面函数，形成闭包
</code></pre>
<h2 id="14-监测数组变化"><a href="#14-监测数组变化" class="headerlink" title="14.监测数组变化"></a>14.监测数组变化</h2><pre><code class="javascript">// 获取Array的原型，并创建一个新的对象指向这个原型
const arrayMethods = Object.create(Array.prototype)
// 创建一个新的原型，这就是改造之后的数组原型
const ArrayProto = []
// 重新构建Array原型里面的虽有方法
Object.getOwnPropertyNames(Array.prototype).forEach(method =&gt; &#123;
    if(typeof arrayMethods[method] === &quot;function&quot;)&#123;
        ArrayProto[method] = function()&#123;
            console.log(&quot;我已经监听到数组触发了&quot;+method+&quot;事件&quot;)
            return arrayMethods[method].apply(this, arguments)
        &#125;
    &#125;else&#123;
        ArrayProto[method] = arrayMethods[method]
    &#125;
&#125;)


let list = [1, 2, 3]
// 将数组的原型链指向新构造的原型
list.__proto__ = ArrayProto
// 执行push事件
list.push(2)
// 输出：
我已经监听到数组触发了push事件 // 这个说明监听成功了
</code></pre>
<h2 id="15-节流"><a href="#15-节流" class="headerlink" title="15.节流"></a>15.节流</h2><pre><code class="javascript">//scroll方法中当间隔时间大于2s，do somthing执行一次
window.addEventListener(&#39;scroll&#39;,function()&#123;
    var timer ;//使用闭包，缓存变量
    var startTime = new Date();
    return function()&#123;
    var curTime = new Date();
    if(curTime - startTime &gt;= 2000)&#123;
    timer = setTimeout(function()&#123;
    console.log(&#39;do somthing&#39;)
    &#125;,500);
    startTime = curTime;
    &#125;
      &#125; &#125;());//此处()作用 - 立即调用return后面函数，形成闭包
</code></pre>
<h2 id="16-拦截全局Promise-reject"><a href="#16-拦截全局Promise-reject" class="headerlink" title="16.拦截全局Promise-reject"></a>16.拦截全局Promise-reject</h2><pre><code class="javascript">// 使用Try catch 只能拦截try语句块里面的
try &#123;
    new Promise((resolve, reject) =&gt; &#123;
      reject(&quot;WTF 123&quot;);
    &#125;);
  &#125; catch (e) &#123;
    console.log(&quot;e&quot;, e);
    throw e;
  &#125;
  
  // 使用 unhandledrejection 来拦截全局错误  （这个是对的）
  window.addEventListener(&quot;unhandledrejection&quot;, (event) =&gt; &#123;
    event &amp;&amp; event.preventDefault();
    console.log(&quot;event&quot;, event);
  &#125;);
</code></pre>
<h2 id="17-千位符"><a href="#17-千位符" class="headerlink" title="17.千位符"></a>17.千位符</h2><pre><code class="javascript">// 将金额类型转为数字类型
function toNum(str) &#123;
    return str.replace(/\,|\￥/g, &quot;&quot;);
&#125;

// 保留两位小数（四舍五入）
function toPrice(num) &#123;
    num = parseFloat(toNum(num)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);
&#125;

// 保留两位小数（不四舍五入）
function toPrice1(num) &#123;
    num = parseFloat(toNum(num).replace(/(\.\d&#123;2&#125;)\d+$/,&quot;$1&quot;)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);;
&#125;

// 不处理小数部分
function toPrice2(num) &#123;
    var source = toNum(num).split(&quot;.&quot;);
    source[0] = source[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + source.join(&quot;.&quot;)
&#125;

console.log(toPrice(&#39;12312.236&#39;)) //￥12,312.24
console.log(toPrice1(&#39;12312.234&#39;)) //￥12,312.23
console.log(toPrice2(&#39;1232342312.234&#39;)) //￥1,232,342,312.234
</code></pre>
<h2 id="18-浅拷贝"><a href="#18-浅拷贝" class="headerlink" title="18.浅拷贝"></a>18.浅拷贝</h2><pre><code class="javascript">let Sclone =(obj)=&gt;&#123;        
    // 方法一        
    // let obj1 = &#123;&#125;        
    // obj1 = Object.assign(&#123;&#125;,obj)        
    // 方法二 
    let obj1 =&#123;...obj&#125;       
    return obj1    
&#125;
</code></pre>
<h2 id="19-数组去重"><a href="#19-数组去重" class="headerlink" title="19.数组去重"></a>19.数组去重</h2><pre><code class="javascript">let arr =  [1,2,2,4,null,null,&#39;3&#39;,&#39;abc&#39;,3,5,4,1,2,2,4,null,null,&#39;3&#39;,&#39;abc&#39;,3,5,4] 

//利用key的唯一
let obj = &#123;&#125;;
for (let i = 0; i &lt; arr.length; i++) &#123;
  let item = arr[i]
  if (obj[item] !== undefined) &#123;
    arr.splice(i, 1);
    i--; // 解决删除元素后，数组塌陷问题
    continue;
  &#125;
  obj[item] = item
&#125;

console.log(arr)
// arr: [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]


// 交换元素位置从而替换调 splice方法
let obj1 = &#123;&#125;;
for (let i = 0; i &lt; arr.length; i++) &#123;
  let item = arr[i]
  if (obj1[item] !== undefined) &#123;
    arr[i] = arr[arr.length-1]
    arr.length--;
    i--; 
    continue;
  &#125;
  obj1[item] = item
&#125;
// arr: [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]


// Array.filter + Array.indexO
let newArr = arr.filter((item, index) =&gt; arr.indexOf(item) === index);  
// [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5


// Array.filter + Object.hasOwnProperty
let obj2 = &#123;&#125;
arr.filter(item =&gt; obj2.hasOwnProperty(typeof item + item) ? false : (obj2[typeof item + item] = true))


// Array.reduce + Array.includes
let newArr1 = arr.reduce((accu, cur) =&gt; &#123;
    return accu.includes(cur) ? accu : accu.concat(cur);  // 1. 拼接方法
    // return accu.includes(cur) ? accu : [...accu, cur]; // 2. 扩展运算
&#125;, [])


// Array.indexOf
let newArr2 = []
for (var i = 0; i &lt; arr.length; i++) &#123;
    if (newArr2.indexOf(arr[i]) === -1) newArr2.push(arr[i])  
&#125;
//等同于 forEach 写法
arr.forEach( item =&gt; newArr2.indexOf(item) === -1 ? newArr2.push(item) : &#39;&#39;)

//Array.includes
let newArr3 = []
for (var i = 0; i &lt; arr.length; i++) &#123;
    if (!newArr3.includes(arr[i]))  newArr3.push(arr[i])
&#125;
//等同于 forEach 写法
arr.forEach( item =&gt; !newArr3.includes(item) ? newArr3.push(item) : &#39;&#39;)


// new Set + 扩展运算符 || Array.from
let newArr5 = [...new Set(arr)];      // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]
let newArr4 = Array.from(new Set(arr));      // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]
let newStr = [...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)  //  &#39;abc&#39;


// new Map
let map = new Map();
let newStr6 = [];

for (let i = 0; i &lt; arr.length; i++) &#123;
    if (!map.has(arr[i])) &#123;
        map.set(arr[i], true);
        newStr6.push(arr[i]);
    &#125;
&#125;
console.log(newArr6)  // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]
</code></pre>
<h2 id="20-数组转为tree"><a href="#20-数组转为tree" class="headerlink" title="20.数组转为tree"></a>20.数组转为tree</h2><pre><code class="javascript">let arr= [
    &#123; id: 1, name: &#39;部门A&#39;, parentId: 0 &#125;,
    &#123; id: 3, name: &#39;部门C&#39;, parentId: 1 &#125;,
    &#123; id: 4, name: &#39;部门D&#39;, parentId: 1 &#125;,
    &#123; id: 5, name: &#39;部门E&#39;, parentId: 2 &#125;,
    &#123; id: 6, name: &#39;部门F&#39;, parentId: 3 &#125;,
    &#123; id: 7, name: &#39;部门G&#39;, parentId: 2 &#125;,
    &#123; id: 8, name: &#39;部门H&#39;, parentId: 4 &#125;,
    &#123; id: 18, name: &#39;部门K&#39;, parentId: 4 &#125;,
    &#123; id: 22, name: &#39;部门zz&#39;, parentId: 21 &#125;
]


function arrToTree(arr) &#123;
  arr=JSON.parse(JSON.stringify(arr))
  const newArr = []
  // 1. 构建一个字典：能够快速根据id找到对象。
  const map = &#123;&#125;
  arr.forEach(item =&gt; &#123;
    // 为了计算方便，统一添加children
    item.children = []
    // 构建一个字典
    map[item.id] = item
  &#125;)
 
  // 2. 对于arr中的每一项
  arr.forEach(item =&gt; &#123;
    const parent = map[item.parentId]
    if (parent) &#123;
      //    如果它有父级，把当前对象添加父级元素的children中
      parent.children.push(item)
    &#125; else &#123;
      //    如果它没有父级（pid:&#39;&#39;）,直接添加到newArr
      newArr.push(item)
    &#125;
  &#125;)
  return newArr
&#125;

console.log(arrToTree(arr))
</code></pre>
<h2 id="21-ajax"><a href="#21-ajax" class="headerlink" title="21.ajax"></a>21.ajax</h2><pre><code class="javascript">function ajax(option) &#123;//type,url,obj,timeout,success,error将所有参数换成一个对象&#123;&#125;
    //  0.将对象转换成字符串
    var str = objToString(option.data);
    //  1.创建一个异步对象xmlhttp；
    var xmlhttp, timer;
    if (window.XMLHttpRequest) &#123;
        xmlhttp = new XMLHttpRequest();
    &#125; else &#123;// code for IE6, IE5 
        xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
    &#125;
    //  2.设置请求方式和请求地址； 
    // 判断请求的类型是POST还是GET
    if (option.type.toLowerCase() === &#39;get&#39;) &#123;
        xmlhttp.open(option.type, option.url + &quot;?t=&quot; + str, true);
        //  3.发送请求；
        xmlhttp.send();
    &#125; else &#123;
        xmlhttp.open(option.type, option.url, true);
        // 注意：在post请求中，必须在open和send之间添加HTTP请求头：setRequestHeader(header,value);
        xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
        //  3.发送请求；
        xmlhttp.send(str);
    &#125;
    //  4.监听状态的变化；
    xmlhttp.onreadystatechange = function () &#123;
        clearInterval(timer);
        if (xmlhttp.readyState === 4) &#123;
            if (xmlhttp.status &gt;= 200 &amp;&amp; xmlhttp.status &lt; 300 || xmlhttp.status == 304) &#123;
                //  5.处理返回的结果；
                option.success(xmlhttp);//成功后回调；
            &#125; else &#123;
                option.error(xmlhttp);//失败后回调；
            &#125;
        &#125;
    &#125;
    //处理obj 
    function objToString(data) &#123;
        data.t = new Date().getTime();
        var res = [];
        for (var key in data) &#123;
            //需要将key和value转成非中文的形式，因为url不能有中文。使用encodeURIComponent();
            res.push(encodeURIComponent(key) + &quot; = &quot; + encodeURIComponent(data[key]));
        &#125;
        return res.join(&quot;&amp;&quot;);
    &#125;
    //判断外界是否传入了超时时间
    if (option.timeout) &#123;
        timer = setInterval(function () &#123;
            xmlhttp.abort();//中断请求
            clearInterval(timer);
        &#125;, timeout);
    &#125;
&#125;
</code></pre>
<h2 id="22-apply"><a href="#22-apply" class="headerlink" title="22.apply"></a>22.apply</h2><pre><code class="javascript">Function.prototype.apply2 = function(obj,arr)&#123;
    obj = obj?Object(obj):window;
    let _fn = &quot;fn&quot;,result;
    while (obj.hasOwnProperty(_fn)) &#123;
      _fn = &quot;fn&quot; + Math.random(); // 循环判断并重新赋值
    &#125;
    obj[_fn] = this;
    if(arr)&#123;
      result = obj[_fn](...arr);
    &#125;else&#123;
      result = obj[_fn]();
    &#125;
    delete obj[_fn];
    return result;
  &#125;
</code></pre>
<h2 id="23-async和await"><a href="#23-async和await" class="headerlink" title="23.async和await"></a>23.async和await</h2><pre><code class="javascript">function asyncToGen(genFunction) &#123;
    return function (...args) &#123;
      const gen = genFunction.apply(this, args);
      return new Promise((resolve, reject) =&gt; &#123;
        function step(key, arg) &#123;
          let genResult;
          try &#123;
            genResult = gen[key](arg);
          &#125; catch (err) &#123;
            return reject(err);
          &#125;
          const &#123; value, done &#125; = genResult;
          if (done) &#123;
            return resolve(value);
          &#125;
          return Promise.resolve(value).then(
            (val) =&gt; &#123;
              step(&#39;next&#39;, val);
            &#125;,
            (err) =&gt; &#123;
              step(&#39;throw&#39;, err);
            &#125;,
          );
        &#125;
        step(&#39;next&#39;);
      &#125;);
    &#125;;
  &#125;
  const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(&#39;data&#39;), 1000));
  function* testG() &#123;
    const data = yield getData();
    console.log(&#39;data: &#39;, data);
    const data2 = yield getData();
    console.log(&#39;data2: &#39;, data2);
    return &#39;success&#39;;
  &#125;
  
  const gen = asyncToGen(testG);
  gen().then(res =&gt; console.log(res));
</code></pre>
<h2 id="24-bind"><a href="#24-bind" class="headerlink" title="24.bind"></a>24.bind</h2><pre><code class="javascript">Function.prototype.bind2 = function (obj) &#123;
    obj = obj ? Object(obj) : window
    let myArguments = arguments
    let self = this
    if (arguments.length &gt; 1) &#123;
      return function () &#123;
        self.apply(obj, [...[...myArguments].slice(1), ...arguments])
      &#125;
    &#125;
    return function () &#123;
      self.apply(obj, [...arguments])
    &#125;
  &#125;
</code></pre>
<h2 id="25-call"><a href="#25-call" class="headerlink" title="25.call"></a>25.call</h2><pre><code class="javascript">Function.prototype.call2 = function(obj)&#123;
    obj = obj?Object(obj):window;
    let _fn = &quot;fn&quot;,result;
    while (obj.hasOwnProperty(_fn)) &#123;
      _fn = &quot;fn&quot; + Math.random(); // 循环判断并重新赋值
    &#125;
    obj[_fn] = this;
    if(arguments.length&gt;1)&#123;
      result = obj[_fn](...([...arguments].slice(1)));
    &#125;else&#123;
      result = obj[_fn]();
    &#125;
    delete obj[_fn];
    return result;
  &#125;
</code></pre>
<h2 id="26-filter"><a href="#26-filter" class="headerlink" title="26.filter"></a>26.filter</h2><pre><code class="javascript">Array.prototype.myFilter = function(callback, thisArg) &#123;
    // 确认调用者必须是个数组
    if (Object.prototype.toString.call(this) !== &#39;[object Array]&#39;) &#123;
      throw new TypeError(&#39;this must be a array&#39;);
    &#125;
    if (typeof callback !== &#39;function&#39;) &#123;
      throw new TypeError(callback + &#39;is not a function&#39;);
    &#125;
    // 返回结果的数组
    const res = [];
    // 让O成为回调函数的对象传递（强制转换对象）
    const O = Object(this);
    console.log(O)
    // &gt;&gt;&gt;0 保证len为number，且为正整数
    // 无符号位移计算符
    const len = O.length &gt;&gt;&gt; 0;
    // 对整个数组进行遍历
    for (let i = 0; i &lt; len; i++) &#123;
        // 遍历回调函数调用传参
        // call是传入（新this指向，参数）
        // thisArg新设置的this，这里无设置就是undefined
        // O[i] 是原数组的当前元素
        // i是当前index
        // O是原数组
        if (callback.call(thisArg, O[i], i, O)) &#123;
          res.push(O[i]);
        &#125;
    &#125;
    // 返回结果
    return res;
  &#125;
  console.log([30,20,16,10].myFilter((num) =&gt; &#123; return num &gt;= 12&#125;));
</code></pre>
<h2 id="27-forEach"><a href="#27-forEach" class="headerlink" title="27.forEach"></a>27.forEach</h2><pre><code class="javascript">Array.prototype.myForEach = function(callback, thisArg) &#123;
    // 判断是否是数组调用，并且传入的是回调函数
    if (this == null) &#123;
      throw new TypeError(&#39;this is null or not defined&#39;);
    &#125;
    if (typeof callback !== &quot;function&quot;) &#123;
      throw new TypeError(callback + &#39; is not a function&#39;);
    &#125;
    const O = Object(this);
    const len = O.length &gt;&gt;&gt; 0;
    let k = 0;
   // 循环所有数据  
   for(let i = 0; i &lt; len; i++) &#123;
    callback.call(thisArg, O[k], k, O);
   &#125;
  &#125;
</code></pre>
<h2 id="28-instanceof"><a href="#28-instanceof" class="headerlink" title="28.instanceof"></a>28.instanceof</h2><pre><code class="javascript">function new_instance_of(leftValue,rightValue)&#123;
    let rightProto = rightValue.prototype;//取右边表达式的 prototype 值
    leftValue = leftValue.__proto__;//取左表达式的 __proto__ 值
    while(true)&#123;
        if(leftValue == null)&#123;
            return false;
        &#125;
        if(leftValue === rightProto)&#123;
            return true;
        &#125;
        leftValue = leftValue.__proto__;
    &#125;
&#125;
function Foo()&#123;&#125;
console.log(new_instance_of(Foo,Object))//true
</code></pre>
<h2 id="29-jsonp"><a href="#29-jsonp" class="headerlink" title="29.jsonp"></a>29.jsonp</h2><pre><code class="javascript">let jsonp=(url,data=&#123;&#125;,callback=&#39;callback&#39;)=&gt;&#123;
    //准备好带有padding的请求url
let dataStr=url.indexOf(&#39;?&#39;)=== -1?&#39;?&#39;:&#39;&amp;&#39;
// console.log(dataStr);
for(let key in data)&#123;
    dataStr +=`$&#123;key&#125;=$&#123;data[key]&#125;&amp;`
&#125;
dataStr +=`callback=`+callback

//构造 script
let oScript=document.createElement(&#39;script&#39;)
oScript.src=url+dataStr
//appendChild () 方法可向节点的子节点列表的末尾添加新的子节点
document.body.appendChild(oScript)

// window[callback]=(data)=&gt;&#123;
//     console.log(data);
// &#125;
return new Promise((resolve,reject)=&gt;&#123;
    window[callback]=(data)=&gt;&#123;
        try&#123;
            resolve(data)
        &#125;catch(e)&#123;
            reject(e)
        &#125;finally&#123;
            oScript.parentNode.removeChild(oScript)// 注意这句代码，OScript移除,细节
        &#125;
    &#125;
&#125;)
&#125;

jsonp(&#39;https://photo.sina.cn/aj/index?a=1&#39;,&#123;
    page:1,
    cate:&#39;recommend&#39;
&#125;).then(response=&gt;&#123;
    console.log(response,&#39;-------then&#39;);
&#125;) 
</code></pre>
<h2 id="30-map"><a href="#30-map" class="headerlink" title="30.map"></a>30.map</h2><pre><code class="javascript">Array.prototype.myMap = function(callback, thisArg) &#123;
    if (this == undefined) &#123;
      throw new TypeError(&#39;this is null or not defined&#39;);
    &#125;
    if (typeof callback !== &#39;function&#39;) &#123;
      throw new TypeError(callback + &#39; is not a function&#39;);
    &#125;
    const res = [];
    const O = Object(this);
    const len = O.length &gt;&gt;&gt; 0;
    for (let i = 0; i &lt; len; i++) &#123;
       // 调用回调函数并传入新数组
       res[i] = callback.call(thisArg, O[i], i, O);
    &#125;
    return res;
  &#125;
</code></pre>
<h2 id="31-new"><a href="#31-new" class="headerlink" title="31.new"></a>31.new</h2><pre><code class="javascript">/**
 * new 使用Js原生实现
 */
function Parent(name, age) &#123;
    this.name = name;
    this.age = age;
    this.sayName = function () &#123;
        console.log(this.name);
    &#125;
&#125;
const _new = function (Parent, ...rest) &#123;
    //1.以构造器Parent的prototype为原型创建新对象
    const child = Object.create(Parent.prototype);
    //2. 将this和调用参数传给构造器执行
    const result = Parent.apply(child, rest);
    return typeof result === &#39;object&#39; ? result : child;
&#125;
const p1 = _new(Parent,&#39;www&#39;,&#39;23&#39;);
console.log(p1);
p1.sayName(); 
</code></pre>
<h2 id="32-object-create"><a href="#32-object-create" class="headerlink" title="32.object-create"></a>32.object-create</h2><pre><code class="javascript">Object.myCreate = function (proto, propertyObject = undefined) &#123;
    if (propertyObject === null) &#123;
      // 这里没有判断propertyObject是否是原始包装对象
      throw &#39;TypeError&#39;
    &#125; else &#123;
      function Fn () &#123;&#125;
      Fn.prototype = proto
      const obj = new Fn()
      if (propertyObject !== undefined) &#123;
        Object.defineProperties(obj, propertyObject)
      &#125;
      if (proto === null) &#123;
        // 创建一个没有原型对象的对象，Object.create(null)
        obj.__proto__ = null
      &#125;
      return obj
    &#125;
  &#125;
  
  // 示例
  // 第二个参数为null时，抛出TypeError
  // const throwErr = Object.myCreate(&#123;a: &#39;aa&#39;&#125;, null)  // Uncaught TypeError
  // 构建一个以
  const obj1 = Object.myCreate(&#123;a: &#39;aa&#39;&#125;)
  console.log(obj1)  // &#123;&#125;, obj1的构造函数的原型对象是&#123;a: &#39;aa&#39;&#125;
  const obj2 = Object.myCreate(&#123;a: &#39;aa&#39;&#125;, &#123;
    b: &#123;
      value: &#39;bb&#39;,
      enumerable: true
    &#125;
  &#125;)
  console.log(obj2)  // &#123;b: &#39;bb&#39;&#125;, obj2的构造函数的原型对象是&#123;a: &#39;aa&#39;&#125;
</code></pre>
<h2 id="33-object-is"><a href="#33-object-is" class="headerlink" title="33.object-is"></a>33.object-is</h2><pre><code class="javascript">Object.is = function(x, y) &#123;
    if (x === y) &#123;
        // 当前情况下，只有一种情况是特殊的，即 +0 -0
        // 如果 x !== 0，则返回true
        // 如果 x === 0，则需要判断+0和-0，则可以直接使用 1/+0 === Infinity 和 1/-0 === -Infinity来进行判断
        return x !== 0 || 1 / x === 1 / y;
    &#125;
    
    // x !== y 的情况下，只需要判断是否为NaN，如果x!==x，则说明x是NaN，同理y也一样
    // x和y同时为NaN时，返回true
    return x !== x &amp;&amp; y !== y;
&#125;
</code></pre>
<h2 id="34-promise-all"><a href="#34-promise-all" class="headerlink" title="34.promise.all"></a>34.promise.all</h2><pre><code class="javascript">Promise.prototype.all = function(promises)&#123;
    let results = [];
    let promiseCount = 0;
    let promisesLength = promises.length;
    return new Promise(function(resolve,reject)&#123;
        for(let val of promises)&#123;
            Promise.resolve(val).then(function(res)&#123;
                promiseCount++;
                results[i] = res;
                if(promiseCount === promisesLength)&#123;
                    return resolve(results);
                &#125;
            &#125;,function(err)&#123;
                return reject(err);
            &#125;)
        &#125;
    &#125;)
&#125;

let promise1 = new Promise(function(resolve) &#123;
    resolve(1);
  &#125;);
  let promise2 = new Promise(function(resolve) &#123;
    resolve(2);
  &#125;);
  let promise3 = new Promise(function(resolve) &#123;
    resolve(3);
  &#125;);
  
  let promiseAll = Promise.all([promise1, promise2, promise3]);
  promiseAll.then(function(res) &#123;
    console.log(res);
  &#125;);
</code></pre>
<h2 id="35-promise"><a href="#35-promise" class="headerlink" title="35.promise"></a>35.promise</h2><pre><code class="javascript">const PENDING = &#39;PENDING&#39;;
const FULFILLED = &#39;FULFILLED&#39;;
const REJECTED = &#39;REJECTED&#39;;

const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;
  // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1
  if (promise2 === x) &#123; 
    return reject(new TypeError(&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;))
  &#125;
  // Promise/A+ 2.3.3.3.3 只能调用一次
  let called;
  // 后续的条件要严格判断 保证代码能和别的库一起使用
  if ((typeof x === &#39;object&#39; &amp;&amp; x != null) || typeof x === &#39;function&#39;) &#123; 
    try &#123;
      // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1
      let then = x.then;
      if (typeof then === &#39;function&#39;) &#123; 
        // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3
        then.call(x, y =&gt; &#123; // 根据 promise 的状态决定是成功还是失败
          if (called) return;
          called = true;
          // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1
          resolvePromise(promise2, y, resolve, reject); 
        &#125;, r =&gt; &#123;
          // 只要失败就失败 Promise/A+ 2.3.3.3.2
          if (called) return;
          called = true;
          reject(r);
        &#125;);
      &#125; else &#123;
        // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4
        resolve(x);
      &#125;
    &#125; catch (e) &#123;
      // Promise/A+ 2.3.3.2
      if (called) return;
      called = true;
      reject(e)
    &#125;
  &#125; else &#123;
    // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4  
    resolve(x)
  &#125;
&#125;

class Promise &#123;
  constructor(executor) &#123;
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks= [];

    let resolve = (value) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125; 

    let reject = (reason) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125;

    try &#123;
      executor(resolve,reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

  then(onFulfilled, onRejected) &#123;
    //解决 onFufilled，onRejected 没有传值的问题
    //Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4
    onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : v =&gt; v;
    //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获
    onRejected = typeof onRejected === &#39;function&#39; ? onRejected : err =&gt; &#123; throw err &#125;;
    // 每次调用 then 都返回一个新的 promise  Promise/A+ 2.2.7
    let promise2 = new Promise((resolve, reject) =&gt; &#123;
      if (this.status === FULFILLED) &#123;
        //Promise/A+ 2.2.2
        //Promise/A+ 2.2.4 --- setTimeout
        setTimeout(() =&gt; &#123;
          try &#123;
            //Promise/A+ 2.2.7.1
            let x = onFulfilled(this.value);
            // x可能是一个proimise
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            //Promise/A+ 2.2.7.2
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === REJECTED) &#123;
        //Promise/A+ 2.2.3
        setTimeout(() =&gt; &#123;
          try &#123;
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === PENDING) &#123;
        this.onResolvedCallbacks.push(() =&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);

        this.onRejectedCallbacks.push(()=&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject)
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);
      &#125;
    &#125;);
  
    return promise2;
  &#125;
&#125;
</code></pre>
<h2 id="36-promise-race"><a href="#36-promise-race" class="headerlink" title="36.promise.race"></a>36.promise.race</h2><pre><code class="javascript">Promise.race = function(promises)&#123;
    //将可迭代对象转换为数组
    promises = Array.from(promises);
    return new Promise((resolve,reject)=&gt;&#123;
        if(promises.length === 0)&#123;
            //空的可迭代对象，用于pending状态
        &#125;else&#123;
            for(let i = 0;i &lt; promises.length;i++)&#123;
                Promise.resolve(promises[i]).then((data)=&gt;&#123;
                    resolve(data);
                &#125;).catch((reason)=&gt;&#123;
                    reject(reason)
                &#125;)
            &#125;
        &#125;
    &#125;)
&#125;

let p1 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;success&#39;)
    &#125;,1000)
&#125;)

let p2 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;faild&#39;)
    &#125;,500)
&#125;)

Promise.race([p1,p2]).then(result=&gt;&#123;
console.log(result)             //  faild    faild耗时短
&#125;)
</code></pre>
<h2 id="37-reduce"><a href="#37-reduce" class="headerlink" title="37.reduce"></a>37.reduce</h2><pre><code class="javascript">Array.prototype.myReduce = function(callback, initialValue) &#123;
    // 判断调用的是否是数组，以及传入的callback是否是函数
    if (this == undefined) &#123;
      throw new TypeError(&#39;this is null or not defined&#39;);
    &#125;
    if (typeof callback !== &#39;function&#39;) &#123;
      throw new TypeError(callbackfn + &#39; is not a function&#39;);
    &#125;
    // 空数组也是不允许的
    if (this.length == 0) &#123;
     throw new TypeError(&#39;Reduce of empty array with no initial value&#39;);
    &#125;
    // 让O成为回调函数的对象传递（强制转换对象）
    const O = Object(this);
    // &gt;&gt;&gt;0 保证len为number，且为正整数
    const len = this.length &gt;&gt;&gt; 0;
    // 保存初始值，初始值不传的时候为undefined
    let accumulator = initialValue;
    // 标志位
    let k = 0;
    // 如果第二个参数为undefined的情况，则数组的第一个有效值作为累加器的初始值
    if (accumulator === undefined) &#123;
      // 这里是k++，就是赋值完成之后k再加1
      accumulator = O[k++];
    &#125;
    // 此时如果有初始值，k是0，如果无初始值k是1
    for(k;k&lt;len;k++) &#123;
     accumulator = callback.call(this, accumulator, O[k], k, O);
    &#125;
    return accumulator;
  &#125;
  console.log([2,4,6].myReduce((t,n)=&gt;&#123;return t+n&#125;));
  console.log([2,4,6].myReduce((t,n)=&gt;&#123;return t+n&#125;,10));
</code></pre>
<h2 id="38-sleep"><a href="#38-sleep" class="headerlink" title="38.sleep"></a>38.sleep</h2><pre><code class="javascript">//Promise
const sleep = time =&gt; &#123;
    return new Promise(resolve =&gt; setTimeout(resolve,time))
  &#125;
  sleep(1000).then(()=&gt;&#123;
    console.log(1)
  &#125;)
  
  //Generator
  function* sleepGenerator(time) &#123;
    yield new Promise(function(resolve,reject)&#123;
      setTimeout(resolve,time);
    &#125;)
  &#125;
  sleepGenerator(1000).next().value.then(()=&gt;&#123;console.log(1)&#125;)
  
  //async
  function sleep(time) &#123;
    return new Promise(resolve =&gt; setTimeout(resolve,time))
  &#125;
  async function output() &#123;
    let out = await sleep(1000);
    console.log(1);
    return out;
  &#125;
  output();
  
  //ES5
  function sleep(callback,time) &#123;
    if(typeof callback === &#39;function&#39;)
      setTimeout(callback,time)
  &#125;
  
  function output()&#123;
    console.log(1);
  &#125;
  sleep(output,1000);
</code></pre>
<h2 id="39-vue-Reactive"><a href="#39-vue-Reactive" class="headerlink" title="39.vue-Reactive"></a>39.vue-Reactive</h2><pre><code class="javascript">const targetMap = new WeakMap();
let activeEffect = null; // 引入 activeEffect 变量

const effect = eff =&gt; &#123;
    activeEffect = eff; // 1. 将副作用赋值给 activeEffect
  activeEffect();     // 2. 执行 activeEffect
  activeEffect = null;// 3. 重置 activeEffect
&#125;

const track = (target, key) =&gt; &#123;
    if (activeEffect) &#123;  // 1. 判断当前是否有 activeEffect
        let depsMap = targetMap.get(target);
        if (!depsMap) &#123;
            targetMap.set(target, (depsMap = new Map()));
        &#125;
        let dep = depsMap.get(key);
        if (!dep) &#123;
            depsMap.set(key, (dep = new Set()));
        &#125;
        dep.add(activeEffect);  // 2. 添加 activeEffect 依赖
    &#125;
&#125;

const trigger = (target, key) =&gt; &#123;
    const depsMap = targetMap.get(target);
    if (!depsMap) return;
    let dep = depsMap.get(key);
    if (dep) &#123;
        dep.forEach(effect =&gt; effect());
    &#125;
&#125;;

const reactive = (target) =&gt; &#123;
    const handler = &#123;
        get(target, key, receiver) &#123;
            const result = Reflect.get(target, key, receiver);
            track(target, key);
            return result;
        &#125;,
        set(target, key, value, receiver) &#123;
            const oldValue = target[key];
            const result = Reflect.set(target, key, value, receiver);
            if (oldValue != result) &#123;
                trigger(target, key);
            &#125;
            return result;
        &#125;
    &#125;

    return new Proxy(target, handler);
&#125;

let product = reactive(&#123; price: 10, quantity: 2 &#125;);
let total = 0, salePrice = 0;
// 修改 effect 使用方式，将副作用作为参数传给 effect 方法
effect(() =&gt; &#123;
    total = product.price * product.quantity
&#125;);
effect(() =&gt; &#123;
    salePrice = product.price * 0.9
&#125;);
console.log(total, salePrice);  // 20 9
product.quantity = 5;
console.log(total, salePrice);  // 50 9
product.price = 20;
console.log(total, salePrice);  // 100 18
</code></pre>
<h2 id="40-算法笔试"><a href="#40-算法笔试" class="headerlink" title="40.算法笔试"></a>40.算法笔试</h2><h3 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h3><pre><code class="javascript">function insertionSort(arr) &#123;
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) &#123;
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        &#125;
        arr[preIndex+1] = current;
    &#125;
    return arr;
&#125;
const arr1 = [2,6,8,2,3,5,0,1,6,8]
let res = insertionSort(arr1)
console.log(arr1)//[ 0, 1, 2, 2, 3, 5, 6, 6, 8, 8]
</code></pre>
<h3 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2.堆排序"></a>2.堆排序</h3><pre><code class="javascript">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) &#123;   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;
        heapify(arr, i);
    &#125;
&#125;

function heapify(arr, i) &#123;     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;
        largest = left;
    &#125;

    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;
        largest = right;
    &#125;

    if (largest != i) &#123;
        swap(arr, i, largest);
        heapify(arr, largest);
    &#125;
&#125;

function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;

function heapSort(arr) &#123;
    buildMaxHeap(arr);

    for (var i = arr.length-1; i &gt; 0; i--) &#123;
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    &#125;
    return arr;
&#125;

const arr1 = [12,4,6,9,11,0,4,3,7,9]
let res = heapSort(arr1)
console.log(res)//[0, 3, 4,  4,  6, 7, 9, 9, 11, 12]
</code></pre>
<h3 id="3-斐波那契数列"><a href="#3-斐波那契数列" class="headerlink" title="3.斐波那契数列"></a>3.斐波那契数列</h3><pre><code class="javascript">//方法一：使用递归
function fibonacci(n) &#123;
    if (n == 1 || n == 2) &#123;
        return 1
    &#125;;
    return fibonacci(n - 2) + fibonacci(n - 1);
&#125;
console.log(fibonacci(3))//2

//方法二：改进递归-把前两位数字做成参数避免重复计算
function fibonacci(n) &#123;
    function fib(n, v1, v2) &#123;
        if (n == 1)
            return v1;
        if (n == 2)
            return v2;
        else
            return fib(n - 1, v2, v1 + v2)
    &#125;
    return fib(n, 1, 1)
&#125;
fibonacci(30)

//方法三：改进递归-利用闭包特性把运算结果存储在数组里，避免重复计算
var fibonacci = function () &#123;
    let memo = [0, 1];
    let fib = function (n) &#123;
        if (memo[n] == undefined) &#123;
            memo[n] = fib(n - 2) + fib(n - 1)
        &#125;
        return memo[n]
    &#125;
    return fib;
&#125;()
fibonacci(30)


//方法四：改进递归-摘出存储计算结果的功能函数
var memoizer = function (func) &#123;
    let memo = [];
    return function (n) &#123;
        if (memo[n] == undefined) &#123;
            memo[n] = func(n)
        &#125;
        return memo[n]
    &#125;
&#125;;
var fibonacci=memoizer(function(n)&#123;
    if (n == 1 || n == 2) &#123;
        return 1
    &#125;;
    return fibonacci(n - 2) + fibonacci(n - 1);
&#125;)
fibonacci(30)


//方法五：普通for循环
function fibonacci(n) &#123;
    var n1 = 1, n2 = 1, sum;
    for (let i = 2; i &lt; n; i++) &#123;
        sum = n1 + n2
        n1 = n2
        n2 = sum
    &#125;
    return sum
&#125;
fibonacci(30)

//方法六：for循环+解构赋值
var fibonacci = function (n) &#123;
    let n1 = 1; n2 = 1;
    for (let i = 2; i &lt; n; i++) &#123;
        [n1, n2] = [n2, n1 + n2]
    &#125;
    return n2
&#125;
fibonacci(30)
</code></pre>
<h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h3><pre><code class="javascript">function mergeSort(arr) &#123;  // 采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    var result = [];

    while (left.length &amp;&amp; right.length) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
&#125;


const arr1 = [1,4,6,1,0,3,4,2,7,3,1]
let res = mergeSort(arr1)
console.log(res)//[0, 1, 1, 1, 2,3, 3, 4, 4, 6,7]
</code></pre>
<h3 id="5-汉诺塔问题"><a href="#5-汉诺塔问题" class="headerlink" title="5.汉诺塔问题"></a>5.汉诺塔问题</h3><pre><code class="javascript">/** 
 * @param &#123;圆盘数：number&#125; plates 
 * @param &#123;起始柱子 a：string&#125; source 
 * @param &#123;辅助柱子 b：string&#125; helper 
 * @param &#123;目标柱子 c：string&#125; dest 
 * @param &#123;移动步骤集：Array，数组的长度就是移动的次数&#125; moves 
 */
function hanoi(plates, source, helper, dest, moves = []) &#123;
    if (plates &lt;= 0) &#123;
        return moves;
    &#125;
    if (plates === 1) &#123;
        moves.push([source, dest]);
    &#125; else &#123;
        hanoi(plates - 1, source, dest, helper, moves);
        moves.push([source, dest]);
        hanoi(plates - 1, helper, source, dest, moves);
    &#125;
    return moves;
&#125;

// test
console.log(hanoi(4, &#39;source&#39;, &#39;helper&#39;, &#39;dest&#39;)); // 输出结果如下图展示
</code></pre>
<h3 id="6-合并两个有序数组"><a href="#6-合并两个有序数组" class="headerlink" title="6.合并两个有序数组"></a>6.合并两个有序数组</h3><pre><code class="javascript">var merge = function (nums1, m, nums2, n) &#123;
    var p = m + n - 1;//0
    var p1 = m - 1;//-1
    var p2 = n - 1;//0
      // 理论上来说，nums2应该全部填充进去，所以这里以p2作为条件
    while (p2 &gt;= 0) &#123;
        // nums1里面全是0的情况，比如[0], 0, [1], 1
        if (p1 &lt; 0) &#123;
            // 直接用nums2去填补nums1就好了
            nums1[p--] = nums2[p2--]
        // 只有nums2比nums1大才用nus2填补
        &#125; else if (nums2[p2] &gt; nums1[p1]) &#123;
            nums1[p] = nums2[p2];
            p--;
            p2--;
        // 反之用nums1填补
        &#125; else &#123;
            nums1[p] = nums1[p1];
            p--;
            p1--;
        &#125;
    &#125;;
    return nums1;
&#125;;

let nums1 = [1,2,3,0,0,0], m = 3,nums2 = [2,5,6],n = 3
console.log(merge(nums1, m, nums2, n))//[ 1, 2, 2, 3, 5, 6 ]
</code></pre>
<h3 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h3><pre><code class="javascript">function quickSort(arr, left, right) &#123;
    var len = arr.length,
        partitionIndex,
        left = typeof left != &#39;number&#39; ? 0 : left,
        right = typeof right != &#39;number&#39; ? len - 1 : right;

    if (left &lt; right) &#123;
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    &#125;
    return arr;
&#125;

function partition(arr, left ,right) &#123;     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) &#123;
        if (arr[i] &lt; arr[pivot]) &#123;
            swap(arr, i, index);
            index++;
        &#125;        
    &#125;
    swap(arr, pivot, index - 1);
    return index-1;
&#125;

function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;
function partition2(arr, low, high) &#123;
  let pivot = arr[low];
  while (low &lt; high) &#123;
    while (low &lt; high &amp;&amp; arr[high] &gt; pivot) &#123;
      --high;
    &#125;
    arr[low] = arr[high];
    while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;
      ++low;
    &#125;
    arr[high] = arr[low];
  &#125;
  arr[low] = pivot;
  return low;
&#125;

function quickSort2(arr, low, high) &#123;
  if (low &lt; high) &#123;
    let pivot = partition2(arr, low, high);
    quickSort2(arr, low, pivot - 1);
    quickSort2(arr, pivot + 1, high);
  &#125;
  return arr;
&#125;

const arr1 = [1,4,6,1,0,3,4,2,7,3,1]
let res = quickSort(arr1,0,11)
console.log(res)//[ 0, 1, 1, 1, 2, 3, 3, 4, 4, 6,7]
</code></pre>
<h3 id="8-两数之和"><a href="#8-两数之和" class="headerlink" title="8.两数之和"></a>8.两数之和</h3><pre><code class="javascript">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number[]&#125;
 */
const twoSum = (nums, target) =&gt; &#123;
    const prevNums = &#123;&#125;;                    // 存储出现过的数字，和对应的索引               
  
    for (let i = 0; i &lt; nums.length; i++) &#123;       // 遍历元素   
      const curNum = nums[i];                     // 当前元素   
      const targetNum = target - curNum;          // 满足要求的目标元素   
      const targetNumIndex = prevNums[targetNum]; // 在prevNums中获取目标元素的索引
      if (targetNumIndex !== undefined) &#123;         // 如果存在，直接返回 [目标元素的索引,当前索引]
        return [targetNumIndex, i];
      &#125; else &#123;                                    // 如果不存在，说明之前没出现过目标元素
        prevNums[curNum] = i;                     // 存入当前的元素和对应的索引
      &#125;
    &#125;
  &#125;

  let nums = [2,7,11,15], target = 17
  console.log(twoSum(nums,target))//[ 0, 3 ]
</code></pre>
<h3 id="9-冒泡排序"><a href="#9-冒泡排序" class="headerlink" title="9.冒泡排序"></a>9.冒泡排序</h3><pre><code class="javascript"> //双向冒泡排序
 function bubbleSort_twoway(arr) &#123;
    var len = arr.length;    //依次将最大的数放置到数组末尾，将第二大的数放到倒数第二位...
    var flag = false;
    for(var i = 0; i &lt; len/2; i++) &#123;
        flag = false;
        for(var j = i; j &lt; len - 1 - i; j++) &#123;   //从前往后,比较相邻两个数,把大的放在后边.之前已放置成功的可以不再参与比较
            if(arr[j] &gt; arr[j + 1]) &#123;
                var middle = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = middle;
                flag =true;
            &#125;
        &#125;
        if(!flag)&#123;
            break;
        &#125;

        for(var j = len - 1 - i; j &gt; i; j--)&#123;
            if(arr[j] &lt; arr[j - 1]) &#123;
                var middle = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = middle;
                flag = true;
            &#125;
        &#125;
        if(!flag)&#123;
            break;
        &#125;
    &#125;
    return arr;
&#125;

var defaultArr = [3, 5, 32, 15, 7, 26, 10, 55, 45, 12, 28, 88, 18];
var resultArr = bubbleSort_twoway(defaultArr);
console.table(resultArr);
</code></pre>
<h3 id="10-爬台阶"><a href="#10-爬台阶" class="headerlink" title="10.爬台阶"></a>10.爬台阶</h3><pre><code class="javascript">/**
 * @param &#123;number&#125; n
 * @return &#123;number&#125;
 */
var climbStairs = function(n) &#123;
    const sqrt_5 = Math.sqrt(5);
    const fib_n = Math.pow((1 + sqrt_5) / 2, n + 1) - Math.pow((1 - sqrt_5) / 2,n + 1);
    return Math.round(fib_n / sqrt_5);
&#125;;


/**
 * @param &#123;number&#125; n
 * @return &#123;number&#125;
 */
var climbStairs = function(n) &#123;
    const dp = [];
    dp[0] = 1;
    dp[1] = 1;
    for(let i = 2; i &lt;= n; i++) &#123;
        dp[i] = dp[i - 1] + dp[i - 2];
    &#125;
    return dp[n];
&#125;;
</code></pre>
<h3 id="11-数组交集"><a href="#11-数组交集" class="headerlink" title="11.数组交集"></a>11.数组交集</h3><pre><code class="javascript">//数组功能扩展
//数组迭代函数
Array.prototype.each = function(fn)&#123;
    fn = fn || Function.K;
    var a = [];
    var args = Array.prototype.slice.call(arguments, 1);
    for(var i = 0; i &lt; this.length; i++)&#123;
    var res = fn.apply(this,[this[i],i].concat(args));
    if(res != null) a.push(res);
    &#125;
    return a;
   &#125;;
   //数组是否包含指定元素
   Array.prototype.contains = function(suArr)&#123;
    for(var i = 0; i &lt; this.length; i ++)&#123;
    if(this[i] == suArr)&#123;
    return true;
    &#125;
    &#125;
    return false;
   &#125;
   //不重复元素构成的数组
   Array.prototype.uniquelize = function()&#123;
    var ra = new Array();
    for(var i = 0; i &lt; this.length; i ++)&#123;
    if(!ra.contains(this[i]))&#123;
    ra.push(this[i]);
    &#125;
    &#125;
    return ra;
   &#125;;
   //两个数组的交集
   Array.intersect = function(a, b)&#123;
    return a.uniquelize().each(function(o)&#123;return b.contains(o) ? o : null&#125;);
   &#125;;
   //两个数组的差集
   Array.minus = function(a, b)&#123;
    return a.uniquelize().each(function(o)&#123;return b.contains(o) ? null : o&#125;);
   &#125;;
   //两个数组的补集
   Array.complement = function(a, b)&#123;
    return Array.minus(Array.union(a, b),Array.intersect(a, b));
   &#125;;
   //两个数组并集
   Array.union = function(a, b)&#123;
    return a.concat(b).uniquelize();
   &#125;;


var a = [1,2,3,4,5]
var b = [2,4,6,8,10]
console.log(&quot;数组a：&quot;, a);
console.log(&quot;数组b：&quot;, b);
var sa = new Set(a);
var sb = new Set(b);
// 交集
let intersect = a.filter(x =&gt; sb.has(x));
// 差集
let minus = a.filter(x =&gt; !sb.has(x));
// 补集
let complement = [...a.filter(x =&gt; !sb.has(x)), ...b.filter(x =&gt; !sa.has(x))];
// 并集
let unionSet = Array.from(new Set([...a, ...b]));
console.log(&quot;a与b的交集：&quot;, intersect);
console.log(&quot;a与b的差集：&quot;, minus);
console.log(&quot;a与b的补集：&quot;, complement);
console.log(&quot;a与b的并集：&quot;, unionSet);
</code></pre>
<h3 id="12-希尔排序"><a href="#12-希尔排序" class="headerlink" title="12.希尔排序"></a>12.希尔排序</h3><pre><code class="javascript">function shellSort(arr) &#123;
    var len = arr.length,
        temp,
        gap = 1;
    while(gap &lt; len/3) &#123;          //动态定义间隔序列
        gap =gap*3+1;
    &#125;
    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123;
        for (var i = gap; i &lt; len; i++) &#123;
            temp = arr[i];
            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;
                arr[j+gap] = arr[j];
            &#125;
            arr[j+gap] = temp;
        &#125;
    &#125;
    return arr;
&#125;

var defaultArr = [3, 5, 32, 15, 7, 26, 10, 55, 45, 12, 28, 88, 18];
var resultArr = shellSort(defaultArr);
console.table(resultArr);
</code></pre>
<h3 id="13-旋转数组"><a href="#13-旋转数组" class="headerlink" title="13.旋转数组"></a>13.旋转数组</h3><pre><code class="javascript">/**
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
 */

let reverse = function(nums, start, end)&#123;
    while(start &lt; end)&#123;
        [nums[start++], nums[end--]] = [nums[end], nums[start]];
    &#125;
&#125;
let rotate = function(nums, k) &#123;
    k %= nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
    return nums;
&#125;;
</code></pre>
<h3 id="14-选择排序"><a href="#14-选择排序" class="headerlink" title="14.选择排序"></a>14.选择排序</h3><pre><code class="javascript">function selectionSort(arr) &#123;
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) &#123;
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) &#123;
            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    return arr;
&#125;
var defaultArr = [3, 5, 32, 15, 7, 26, 10, 55, 45, 12, 28, 88, 18];
var resultArr = selectionSort(defaultArr);
console.table(resultArr);
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AF%95/" rel="tag">笔试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-umi-4-0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/01/02/umi-4-0/"
    >umi-4.0</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/02/umi-4-0/" class="article-date">
  <time datetime="2023-01-02T02:29:54.000Z" itemprop="datePublished">2023-01-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/umi-js/">umi.js</a> / <a class="article-category-link" href="/categories/umi-js/umi-4-0/">umi-4.0</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="umi-4-0"><a href="#umi-4-0" class="headerlink" title="umi 4.0"></a>umi 4.0</h1><h2 id="Umi-4-有什么新功能？"><a href="#Umi-4-有什么新功能？" class="headerlink" title="Umi 4 有什么新功能？"></a>Umi 4 有什么新功能？</h2><p><img src="/2023/01/02/umi-4-0/image-20230102100825501.png"></p>
<h2 id="多构建引擎"><a href="#多构建引擎" class="headerlink" title="多构建引擎"></a>多构建引擎</h2><p> Umi 4 同时支持 Vite 和 Webpack 两种构建方式，并尽量确保他们之间功能的一致性，让开发者可以通过一行配置进行切换。可能有些同学会喜欢 dev 用 vite，build 用 webpack 这样的组合。同时我们也在探索包括 ESMi 在内的其他构建方案的探索。</p>
<pre><code class="javascript">export default &#123;
  vite: &#123;&#125;
&#125;
</code></pre>
<h2 id="默认快"><a href="#默认快" class="headerlink" title="默认快"></a>默认快</h2><p>默认快是多维度的，我们通过 MFSU V3 + Webpack 5 缓存解 Dev 时编译慢的问题；内网还有通过 Webpack 5 物理缓存和 CD 平台结合解 Build 时编译慢的问题；有使用 esbuild 做 js 和 css 的压缩器、配置和 MOCK 文件的读取、jest 的 transformer，让除构建之外的其他环节也飞快；此外还有运行时速度也有考虑。</p>
<h2 id="MFSU-V3"><a href="#MFSU-V3" class="headerlink" title="MFSU V3"></a>MFSU V3</h2><p>Umi 3 的 MFSU 大家可能多少有接触过，虽然有用，但 DX 不够好。用的时候会遇到一些坑，以至于很多同学都掌握了一项特殊技能，遇到问题时 rm -rf src&#x2F;.umi。大家可能会遇到 monorepo 不支持、热更新导致 Tab 卡死、请求多导致页面打开慢、一些语法不支持的问题。以上问题在 MFSU V3 中全解！基于此，我们非常有信心地在 Umi 4 中默认开启 MFSU 功能。当然，如果你不喜欢，会保留手动配置 mfsu: false 关闭的口子。同时，MFSU V3 还可脱离 Umi 独立使用。</p>
<p><img src="/2023/01/02/umi-4-0/42ccadf17ce44ef48af14f70a9071303.png"></p>
<h2 id="Umi-Max"><a href="#Umi-Max" class="headerlink" title="Umi Max"></a>Umi Max</h2><p>这是内部 Bigfish 框架的对外版本，解我们自己的问题，同时也给社区另一个集中化框架的选择，定位是中后台框架，包含了中后台相关的大量最佳实践的插件。如果有定制需求，大家可以参考他来实现内网框架的定制，比如快手团队就有基于 Umi 4 的框架定制，还有 Alita 也是基于 Umi 定制的面向移动端的框架。</p>
<pre><code class="ini">$ npm i @umijs/max -D
</code></pre>
<h2 id="React-Router-6"><a href="#React-Router-6" class="headerlink" title="React Router 6"></a>React Router 6</h2><p>我们升级了路由方案到 React Router 6，喜忧参半。好消息是，React Router 6 是 Remix 的基础库，面向框架层做了很多优化，路由实现层更优雅，Umi 得以删除大量路由渲染的代码；坏消息是，带来不少 Break Change，比如之前父路由渲染子路由用 children，得换成 。</p>
<pre><code class="javascript">- &#123; props.children &#125;
+ &lt;Outlet /&gt;
</code></pre>
<h2 id="支持-Vue"><a href="#支持-Vue" class="headerlink" title="支持 Vue"></a>支持 Vue</h2><p>Umi 4 中提供了 Vue 支持，记得我在 Umi 2 时画过一张架构图，其中就有 Vue 的一环，Umi 3 时也有过尝试，但那会 Vue 3 还不太成熟，接入时遇到不少坑，这个坑今天总算是补上了。此功能由社区同学操刀，只需装载一个 preset 即可切换到 Vue。</p>
<pre><code class="javascript">export default &#123;
  presets: [&#39;@umijs/preset-vue&#39;],
&#125;;
</code></pre>
<h2 id="默认最快的-CSR-请求"><a href="#默认最快的-CSR-请求" class="headerlink" title="默认最快的 CSR 请求"></a>默认最快的 CSR 请求</h2><p>项目构建快解的是 DX 问题，但同时也应该关注 UX。Client Loader 的目的是让应用加载默认快，避免 React 项目经典的 Render-Then-Fetch 的加载瀑布流问题。效果见下图，示例项目的从 9s 降到 6s，这 6s 还是之前截的图，上了 Preload 功能之后其实已更快。</p>
<pre><code class="javascript">export default function() &#123;
  // 使用请求数据
  useClientLoaderData()
&#125;
// 声明请求
export function clientLoader() &#123;&#125;
</code></pre>
<p><img src="/2023/01/02/umi-4-0/96cb23f5545845f6bcd7430b9ddd35a7.png"></p>
<h2 id="白盒文档的-Lint。"><a href="#白盒文档的-Lint。" class="headerlink" title="白盒文档的 Lint。"></a>白盒文档的 Lint。</h2><p> Umi 4 里内置了我们精挑细选的 lint 规则，只有质量类不开可能会导致项目问题的规则，不包含风格类的规则，不包含 TypeScript 中 type-aware 类的规则，这类规则需要跑整个项目，会导致性能问题；同时，我们通过 @rushstack&#x2F;eslint-pach 的方式锁定了 config 里找 plugin 的规则，确保规则是长期稳定的。</p>
<h2 id="SSR。"><a href="#SSR。" class="headerlink" title="SSR。"></a>SSR。</h2><p> Umi 4 重写了 SSR 功能，目前此功能还在 beta 阶段，请勿将其用于生产环境。Umi 4 的 SSR 有以下特点，1）server 代码的构建基于 esbuild，所以极快，2）请求的处理类似 next.js 的 getServerSideProps 和 remix 的 loader，只在服务端跑，3）基于 react 18 的 suspense 和 renderToPipeableStream。实现原因，部署层目前仅实现了 vercel 的 adapter。这里有个简单的 Todos 示例：<a href="https://link.juejin.cn/?target=https://test-vercel-chencheng.vercel.app/">test-vercel-chencheng.vercel.app&#x2F;</a></p>
<pre><code class="javascript">export default &#123;
  ssr: &#123; platform: &#39;vercel&#39; &#125;
&#125;
</code></pre>
<h2 id="API-路由"><a href="#API-路由" class="headerlink" title="API 路由"></a>API 路由</h2><p>Umi 4 约定 src&#x2F;api 目录下存放的 Serverless Function 格式的文件即为 API 路由。这部分路由会打包成不同平台支持的 Serverless Function 产物。场景比如带 token 的 API 调用、动态数据源、基于 Notion API 的 Blog、Hackernews Clone 等等。基于此，Umi 能做的事的边界就大了很多。不再只是写写中后台，实现静态页面。</p>
<pre><code class="javascript">export default &#123;
  apiRoute: &#123;&#125;,
&#125;
</code></pre>
<h2 id="微生成器"><a href="#微生成器" class="headerlink" title="微生成器"></a>微生成器</h2><p>此概念来自 Modern.js。Modern.js 引入很多新概念，其中「微生成器」还是非常贴切的。他包含两个功能，1）小型脚手架，2）功能的开启与关闭。Umi 3 虽然也有 generate 命令，但只包含功能 1。Umi 4 拓展了下 generate（alias 为 g）命令。除了支持更多类型的小型脚手架生成，还支持功能的开启与关闭，以及比如 Monorepo、react 和 antd 版本等的功能切换。</p>
<pre><code class="ini">$ npx umi g
? Pick generator type › - Use arrow-keys. Return to submit.
❯   创建页面 -- Create a umi page by page name
    创建组件 -- .
    创建 mock 代码 -- .
    创建 model 代码 -- .
    启用 Prettier -- Setup Prettier Configurations
    启用 Jest -- Setup Jest Configuration
    启用 E2E 测试 -- .
    启用 Tailwind CSS -- Setup Tailwind CSS configuration
    启用 SSR -- .
    启用 Low Import 研发模式 -- .
    启用权限方案 -- .
    启用 Monaco 编辑器 -- .
    关闭 Dva 数据流 -- Configuration, Dependencies, and Model Files for Dva
    关闭 MFSU -- .
    切换为 Monorepo 项目 -- .
    切换 React 为 18 -- .
    切换 Antd 为 5 -- .
</code></pre>
<p>除此之外，我们还有非常多小而美的 DX 改进。</p>
<h2 id="自动-https"><a href="#自动-https" class="headerlink" title="自动 https"></a>自动 https</h2><p> Umi 4 的 https dev server 的实现基于 mkcert，启动过程中会基于 hosts 自动生成对应的 key 和 cert。开发者除了安装前置的 mkcert，其他无需关心。</p>
<p><img src="/2023/01/02/umi-4-0/1dd8df4ee5a346818acba7bd6a0f3a47.png"></p>
<h2 id="浏览器里的构建进度条。"><a href="#浏览器里的构建进度条。" class="headerlink" title="浏览器里的构建进度条。"></a>浏览器里的构建进度条。</h2><p>如果首次构建没有完成就在浏览器里打开，你会看到一个构建进度条，支持 webpack 多实例，支持 MFSU，完成初始构建后会自动跳转到项目页。</p>
<p><img src="/2023/01/02/umi-4-0/ae6c76af39ae4dcbad21e186de7e1d29.png"></p>
<h2 id="Terminal-中的日志"><a href="#Terminal-中的日志" class="headerlink" title="Terminal 中的日志"></a>Terminal 中的日志</h2><p>有些开发者会更希望在命令行里看到项目里通过 console 输出的日志，比如我。因为命令行日志不会随着刷新而失效，大家可能都经历过一些一闪而过的页面，想截屏都难；同时命令行日志还可以做物理存储，导出后可以方便他人排查。此功能复刻自 <a href="https://link.juejin.cn/?target=https://github.com/patak-dev/vite-plugin-terminal%E3%80%82">github.com&#x2F;patak-dev&#x2F;v…</a></p>
<pre><code class="ini">import &#123; terminal &#125; from &#39;umi&#39;;
terminal.log(`Some info from the app`);
</code></pre>
<p>然后就可以在命令行中看到日志，</p>
<p><img src="/2023/01/02/umi-4-0/53371b8fabe340eaabc9b00abecd7623.png"></p>
<h2 id="umi-js-产物调试"><a href="#umi-js-产物调试" class="headerlink" title="umi.js 产物调试"></a>umi.js 产物调试</h2><p>不知大家是否会有这样的需求，开发项目时发现一些比较复杂的问题时，需要调整构建产物的代码。而 Umi 基于 webpack-dev-server，在 dev 阶段所有文件都存于内存中，没有物理文件的形式，并不方便直接修改后验证效果。如果大家用 Umi 4，可以把 umi.js 等产物文件保存到项目根目录，然后可以直接修改即生效。</p>
<p><img src="/2023/01/02/umi-4-0/e11af2c3f8cb4e5c84b697000c41e7c5.png"></p>
<h2 id="项目级插件：plugin-ts"><a href="#项目级插件：plugin-ts" class="headerlink" title="项目级插件：plugin.ts"></a>项目级插件：plugin.ts</h2><p> 为进一步降低项目中使用插件的门槛，Umi 4 中约定项目根目录下的 plugin.ts 为插件，开发者可在此直接调用插件 API，无需注册，支持 TypeScript。有了这个文件，我们可以在项目级做很多事。比如，</p>
<pre><code class="javascript">import &#123; IApi &#125; from &#39;umi&#39;;
export default (api: IApi) =&gt; &#123;
  // 比如修改 HTML
  api.modifyHTML($ =&gt; &#123;
    return $;
  &#125;);
  // 比如在入口的 umi.ts 中添加代码
  api.addEntryCodeAhead(() =&gt; [`console.log(&#39;entry code ahead&#39;)`]);
  api.addEntryCode(() =&gt; [`console.log(&#39;entry code&#39;)`]);
  // 比如在构建完成时做额外的事
  api.onBuildComplete((opts) =&gt; &#123;&#125;);
  // 比如在启动阶段做额外的事
  api.onStart((opts) =&gt; &#123;&#125;);
  // 比如校验每个 JavaScript/TypeScript 代码
  api.onCheckCode((args) =&gt; &#123;&#125;);
  // 比如动态修改路由
  api.modifyRoutes((routes) =&gt; &#123;&#125;);
&#125;
</code></pre>
<h2 id="deadCode-检测"><a href="#deadCode-检测" class="headerlink" title="deadCode 检测"></a>deadCode 检测</h2><p> 项目中通常会有未使用的文件或导出，Umi 4 中通过配置 deadCode: {} 即可在 build 阶段做检测。如有发现，会有类似信息抛出。</p>
<pre><code class="javascript">Warning: There are 3 unused files:
 1. /mock/a.ts
 2. /mock/b.ts
 3. /pages/index.module.less
 Please be careful if you want to remove them (¬º-°)¬.
</code></pre>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[umi仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/umijs/umi">https://github.com/umijs/umi</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/umi/" rel="tag">umi</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Apifox和Leancloud"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/25/Apifox%E5%92%8CLeancloud/"
    >Apifox和Leancloud</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/25/Apifox%E5%92%8CLeancloud/" class="article-date">
  <time datetime="2022-12-25T02:17:56.000Z" itemprop="datePublished">2022-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/uniapp/">uniapp</a> / <a class="article-category-link" href="/categories/uniapp/Apifox%E5%92%8CLeancloud/">Apifox和Leancloud</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Apifox和Leancloud"><a href="#Apifox和Leancloud" class="headerlink" title="Apifox和Leancloud"></a>Apifox和Leancloud</h1><blockquote>
<p>我们为什么选择Apifox和Leancloud的组合呢</p>
<p>Apifox也是一款可以模拟接口的一款工具，当然也不只可以模拟接口</p>
<p>Leancloud选择是当我们去开发一些小的应用的时候，我们降低开发成本的时候，我们就可以去选择Leancloud去当我们的平台进行数据存储，还是比较方便的。</p>
</blockquote>
<h3 id="一、Apifox下载"><a href="#一、Apifox下载" class="headerlink" title="一、Apifox下载"></a>一、Apifox下载</h3><p>访问<a target="_blank" rel="noopener" href="https://www.apifox.cn/">官网</a>进行下载</p>
<p>有付费和免费的，根据需求下载</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225090853860.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225091357277.png"></p>
<p>我们可以去新建我们的项目和接口</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225092715766.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225093542358.png"></p>
<p>下面会讲如何设置和填写参数以便于和Leancloud去交互请求</p>
<h3 id="二、Leancloud注册登陆"><a href="#二、Leancloud注册登陆" class="headerlink" title="二、Leancloud注册登陆"></a>二、Leancloud注册登陆</h3><p>我们访问<a target="_blank" rel="noopener" href="https://www.leancloud.cn/">官网</a>注册登陆</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225093702335.png"></p>
<p>然后来到我们的控制台创建我们的应用</p>
<p>我们可以对我们每个应用分开管理</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225093850074.png"></p>
<p>我们每个应用都有自己的信息</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094016973.png"></p>
<p>大家测试的时候可以使用自己的应用信息配置</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094046589.png"></p>
<h3 id="三、配置Apifox"><a href="#三、配置Apifox" class="headerlink" title="三、配置Apifox"></a>三、配置Apifox</h3><blockquote>
<p>当我们应用和Apifox环境准备完毕，那么我们就可以根据文档来配置了</p>
</blockquote>
<p>文档-&gt;REST API-&gt;数据存储</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094258347.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094449937.png"></p>
<h4 id="1-新建接口"><a href="#1-新建接口" class="headerlink" title="1.新建接口"></a>1.新建接口</h4><p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094537626.png"></p>
<p>在配置我们的接口的前提是要选好我们接口运行的环境</p>
<p>让我们先配置一下环境</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094638510.png"></p>
<p>我们可以将我们的服务改成我们Leancloud平台的开放服务地址（后续我们可以改成我们的域名）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225094725724.png"></p>
<p>根据文档来配置</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095251514.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095213854.png"></p>
<p>Header-&gt;批量编辑-&gt;冒号模式（然后将负责的配置修改成下面这种格式就可以了）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095423023.png"></p>
<p>下一步我们来携带参数body</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095604642.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095717122.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095746960.png"></p>
<p>修改状态码并添加响应示例</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095819827.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225095940926.png"></p>
<p>保存运行</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225100023787.png"></p>
<p>出error了，修复它（给body添加示例值就可以了）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225100109578.png"></p>
<h4 id="2-发起请求"><a href="#2-发起请求" class="headerlink" title="2.发起请求"></a>2.发起请求</h4><p>我们发送（响应成功）</p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225101014178.png"></p>
<h3 id="四、Leancloud"><a href="#四、Leancloud" class="headerlink" title="四、Leancloud"></a>四、Leancloud</h3><p>当我们查看Leancloud应用的时候，发现我们多了一张表和数据，表示我们的请求已经成功</p>
<blockquote>
<p>我们还可以根据文档来修改，查找，删除我们的数据表，代码中的配置也是一样的，这样我们就可以利用LeanCloud来搭建我们一个小应用的数据表了。</p>
</blockquote>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225101228952.png"></p>
<p><img src="/2022/12/25/Apifox%E5%92%8CLeancloud/image-20221225101502303.png"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leancloud/" rel="tag">leancloud</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vue-eventBus"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/23/Vue-eventBus/"
    >Vue-eventBus</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/23/Vue-eventBus/" class="article-date">
  <time datetime="2022-12-23T01:13:58.000Z" itemprop="datePublished">2022-12-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/uniapp/">uniapp</a> / <a class="article-category-link" href="/categories/uniapp/Vue-eventBus/">Vue-eventBus</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Vue-eventBus"><a href="#Vue-eventBus" class="headerlink" title="Vue-eventBus"></a>Vue-eventBus</h1><p>父子组件通信与兄弟组件通信</p>
<p>vue组件非常常见的有父子组件通信，兄弟组件通信。</p>
<pre><code>父子组件通信：方法有很多，比如：父组件通过 props 向下传数据给子组件，子组件通过 $emit 告诉父组件。
兄弟组件通信：如果两个页面没有任何引入和被引入关系，需要额外的组件来通信，如：事件总线、Vuex。
</code></pre>
<h3 id="一、事件总线是什么"><a href="#一、事件总线是什么" class="headerlink" title="一、事件总线是什么"></a>一、事件总线是什么</h3><p>EventBus 又称为事件总线。在Vue中可以使用 EventBus 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件。</p>
<pre><code>EventBus若使用不慎，就会造成难以维护的“灾难”，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。 
</code></pre>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>解决了多层组件之间繁琐的事件传播。<br>使用原理十分简单，代码量少</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的EventBus会被移除，这样就导致业务走不下去。<br>如果业务有反复操作的页面，EventBus在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理EventBus在项目中的关系。通常在vue页面销毁时，同时移除EventBus事件监听。</p>
<p>由于是都使用一个Vue实例，所以容易出现重复触发的情景：两个页面都定义了同一个事件名，并且没有用$off销毁（常出现在路由切换时）。</p>
<h3 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h3><h4 id="1-创建事件"><a href="#1-创建事件" class="headerlink" title="1.创建事件"></a>1.创建事件</h4><p>首先需要创建事件总线并将其导出，以便其它模块可以使用或者监听它。</p>
<p>方法1、非全局事件组件</p>
<p> 新建EventBus.js</p>
<pre><code class="javascript">import Vue from &#39;vue&#39;
export const EventBus = new Vue()
</code></pre>
<p>法2、全局事件组件</p>
<p>在项目中的 main.js 初始化 EventBus。在main.js添加如下一行：</p>
<pre><code class="javascript">Vue.prototype.$EventBus = new Vue()
</code></pre>
<p>示例：</p>
<pre><code class="vue">import Vue from &#39;vue&#39;
import App from &#39;./App&#39;
import router from &#39;./router&#39;

Vue.config.productionTip = false

Vue.prototype.$EventBus = new Vue();

/* eslint-disable no-new */
new Vue(&#123;
  el: &#39;#app&#39;,
  router,
  components: &#123; App &#125;,
  template: &#39;&lt;App/&gt;&#39;
&#125;)
</code></pre>
<p>组件发送事件：this.$EventBus.$emit(…)</p>
<p>组件接收事件：this.$EventBus.$on(…)</p>
<p>移除事件</p>
<p>一般在销毁组件（也就是离开组件）时移除事件。</p>
<pre><code class="javascript">beforeDestroy()&#123;
  EventBus.$off(&quot;eventName&quot;)
&#125;
</code></pre>
<p>EventBus.$off()                           &#x2F;&#x2F;移除EventBus所有事件监听器</p>
<p>EventBus.$off(‘eventName’)       &#x2F;&#x2F;移除’eventName’事件所有监听器</p>
<p>EventBus.$off(‘eventName’, callback)    &#x2F;&#x2F;只移除这个回调的监听器。</p>
<h4 id="2-事件运用"><a href="#2-事件运用" class="headerlink" title="2.事件运用"></a>2.事件运用</h4><p>本文父组件：CompA.vue，子组件1：ChildOne.vue，子组件2：ChildTwo.vue。子组件1发送事件给父组件和子组件2。</p>
<pre><code class="javascript">router/index.js

import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import CompA from &quot;@/components/CompA&quot;;

Vue.use(Router)

export default new Router(&#123;
  routes: [
    &#123;
      path: &#39;/compA&#39;,
      name: &#39;compA&#39;,
      component: CompA,
    &#125;
  ],
&#125;)
</code></pre>
<p>1.创建EventBus</p>
<p> 新建EventBus.js</p>
<pre><code class="javascript">import Vue from &#39;vue&#39;
export const EventBus = new Vue()
</code></pre>
<p>2.发送事件</p>
<p> components&#x2F;ChildOne.vue</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;childOne&quot;&gt;
    &lt;h1&gt;childOne&lt;/h1&gt;
    &lt;button @click=&quot;sendEvent2CompA&quot;&gt;发送事件给父组件（CompA）&lt;/button&gt;
    &lt;button @click=&quot;sendEvent2ChildTwo&quot;&gt;发送事件给兄弟组件（ChildTwo）&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;EventBus&#125; from &quot;./EventBus&quot;

export default &#123;
  data() &#123;
    return &#123;
      count1: 0,
      count2: 0,
    &#125;
  &#125;,
  methods:&#123;
    sendEvent2CompA() &#123;
      this.count1++;
      EventBus.$emit(&quot;compA&quot;, &quot;compA事件触发次数：&quot; + this.count1)
    &#125;,
    sendEvent2ChildTwo() &#123;
      this.count2++;
      EventBus.$emit(&quot;childTwo&quot;, &quot;childTwo事件触发次数：&quot; + this.count2)
    &#125;
  &#125;
&#125;
&lt;/script&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<p>3.接收事件</p>
<p>父组件：components&#x2F;CompA.vue</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;compA&quot;&gt;
    &lt;h1&gt;compA&lt;/h1&gt;
    compA收到的事件内容：&#123;&#123;msg&#125;&#125;&lt;hr&gt;
    &lt;child-one&gt;&lt;/child-one&gt;&lt;hr&gt;
    &lt;child-two&gt;&lt;/child-two&gt;

  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;EventBus&#125; from &quot;./EventBus&quot;
import ChildOne from &quot;@/components/ChildOne&quot;;
import ChildTwo from &quot;@/components/ChildTwo&quot;;

export default &#123;
  components: &#123;ChildOne, ChildTwo&#125;,
  data() &#123;
    return &#123;
      msg: &quot;&quot;,
    &#125;
  &#125;,
  mounted() &#123;
    EventBus.$on(&quot;compA&quot;, (payload1)=&gt; &#123;
      this.msg = payload1;
    &#125;)
  &#125;
&#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>子组件2：components&#x2F;ChildTwo.vue</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;childTwo&quot;&gt;
    &lt;h1&gt;childTwo&lt;/h1&gt;
    childTwo收到的事件内容：&#123;&#123;msg&#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;EventBus&#125; from &quot;./EventBus&quot;

export default &#123;
  data() &#123;
    return &#123;
      msg: &quot;&quot;,
    &#125;
  &#125;,
  mounted() &#123;
    EventBus.$on(&quot;childTwo&quot;, (payload1)=&gt; &#123;
      this.msg = payload1;
    &#125;)
  &#125;
&#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>事物都有两面性，没有好坏之分，且全在于使用者，好钢用在刀刃上，不滥用即可。有其他更好的方式则优先使用。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/eventBus/" rel="tag">eventBus</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-uniapp生命周期"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/20/uniapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
    >uniapp生命周期</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/20/uniapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time datetime="2022-12-20T01:59:16.000Z" itemprop="datePublished">2022-12-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/uniapp/">uniapp</a> / <a class="article-category-link" href="/categories/uniapp/uniapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">uniapp生命周期</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="uniapp生命周期"><a href="#uniapp生命周期" class="headerlink" title="uniapp生命周期"></a>uniapp生命周期</h1><h3 id="一、应用生命周期"><a href="#一、应用生命周期" class="headerlink" title="一、应用生命周期"></a>一、应用生命周期</h3><p>uni-app 支持如下应用生命周期函数：</p>
<p><img src="/2022/12/20/uniapp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20221220094520002.png"></p>
<p>这几个函数主要还是在App.vue这个文件进行定义，注意：</p>
<p>应用生命周期仅可在App.vue中监听，在其它页面监听无效。<br>onlaunch里进行页面跳转</p>
<p>onPageNotFound 页面实际上已经打开了（比如通过分享卡片、小程序码）且发现页面不存在，才会触发，api 跳转不存在的页面不会触发（如 uni.navigateTo）</p>
<h3 id="二、页面生命周期"><a href="#二、页面生命周期" class="headerlink" title="二、页面生命周期"></a>二、页面生命周期</h3><p><code>uni-app</code> 支持如下页面生命周期函数：</p>
<table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">说明</th>
<th align="left">平台差异说明</th>
<th align="left">最低版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onInit</td>
<td align="left">监听页面初始化，其参数同 onLoad 参数，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad</td>
<td align="left">百度小程序</td>
<td align="left">3.1.0+</td>
</tr>
<tr>
<td align="left">onLoad</td>
<td align="left">监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考<a target="_blank" rel="noopener" href="https://zh.uniapp.dcloud.io/api/router#navigateto">示例</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onShow</td>
<td align="left">监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onReady</td>
<td align="left">监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onHide</td>
<td align="left">监听页面隐藏</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onUnload</td>
<td align="left">监听页面卸载</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onResize</td>
<td align="left">监听窗口尺寸变化</td>
<td align="left">App、微信小程序、快手小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onPullDownRefresh</td>
<td align="left">监听用户下拉动作，一般用于下拉刷新，参考<a target="_blank" rel="noopener" href="https://zh.uniapp.dcloud.io/api/ui/pulldown">示例</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onReachBottom</td>
<td align="left">页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。具体见下方注意事项</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onTabItemTap</td>
<td align="left">点击 tab 时触发，参数为Object，具体见下方注意事项</td>
<td align="left">微信小程序、QQ小程序、支付宝小程序、百度小程序、H5、App、快手小程序、京东小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onShareAppMessage</td>
<td align="left">用户点击右上角分享</td>
<td align="left">微信小程序、QQ小程序、支付宝小程序、字节小程序、飞书小程序、快手小程序、京东小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onPageScroll</td>
<td align="left">监听页面滚动，参数为Object</td>
<td align="left">nvue暂不支持</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onNavigationBarButtonTap</td>
<td align="left">监听原生标题栏按钮点击事件，参数为Object</td>
<td align="left">App、H5</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onBackPress</td>
<td align="left">监听页面返回，返回 event &#x3D; {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：<a target="_blank" rel="noopener" href="http://ask.dcloud.net.cn/article/35120">onBackPress 详解</a>。支付宝小程序只有真机能触发，只能监听非navigateBack引起的返回，不可阻止默认行为。</td>
<td align="left">app、H5、支付宝小程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onNavigationBarSearchInputChanged</td>
<td align="left">监听原生标题栏搜索输入框输入内容变化事件</td>
<td align="left">App、H5</td>
<td align="left">1.6.0</td>
</tr>
<tr>
<td align="left">onNavigationBarSearchInputConfirmed</td>
<td align="left">监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。</td>
<td align="left">App、H5</td>
<td align="left">1.6.0</td>
</tr>
<tr>
<td align="left">onNavigationBarSearchInputClicked</td>
<td align="left">监听原生标题栏搜索输入框点击事件（pages.json 中的 searchInput 配置 disabled 为 true 时才会触发）</td>
<td align="left">App、H5</td>
<td align="left">1.6.0</td>
</tr>
<tr>
<td align="left">onShareTimeline</td>
<td align="left">监听用户点击右上角转发到朋友圈</td>
<td align="left">微信小程序</td>
<td align="left">2.8.1+</td>
</tr>
<tr>
<td align="left">onAddToFavorites</td>
<td align="left">监听用户点击右上角收藏</td>
<td align="left">微信小程序、QQ小程序</td>
<td align="left">2.8.1+</td>
</tr>
</tbody></table>
<p><code>onInit</code>使用注意</p>
<ul>
<li>仅百度小程序基础库 3.260 以上支持 onInit 生命周期</li>
<li>其他版本或平台可以同时使用 onLoad 生命周期进行兼容，注意避免重复执行相同逻辑</li>
<li>不依赖页面传参的逻辑可以直接使用 created 生命周期替代</li>
</ul>
<p><code>onReachBottom</code>使用注意 可在pages.json里定义具体页面底部的触发距离<a target="_blank" rel="noopener" href="https://zh.uniapp.dcloud.io/collocation/pages#globalstyle">onReachBottomDistance</a>，比如设为50，那么滚动页面到距离底部50px时，就会触发onReachBottom事件。</p>
<p>如使用scroll-view导致页面没有滚动，则触底事件不会被触发。scroll-view滚动到底部的事件请参考scroll-view的文档</p>
<p><code>onPageScroll</code> （监听滚动、滚动监听、滚动事件）参数说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scrollTop</td>
<td>Number</td>
<td>页面在垂直方向已滚动的距离（单位px）</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li><code>onPageScroll</code>里不要写交互复杂的js，比如频繁修改页面。因为这个生命周期是在渲染层触发的，在非h5端，js是在逻辑层执行的，两层之间通信是有损耗的。如果在滚动过程中，频发触发两层之间的数据交换，可能会造成卡顿。</li>
<li>如果想实现滚动时标题栏透明渐变，在App和H5下，可在pages.json中配置titleNView下的type为transparent，<a target="_blank" rel="noopener" href="https://uniapp.dcloud.io/collocation/pages?id=app-titlenview">参考</a>。</li>
<li>如果需要滚动吸顶固定某些元素，推荐使用css的粘性布局，参考<a target="_blank" rel="noopener" href="https://ext.dcloud.net.cn/plugin?id=715">插件市场</a>。插件市场也有其他js实现的吸顶插件，但性能不佳，需要时可自行搜索。</li>
<li>在App、微信小程序、H5中，也可以使用wxs监听滚动，<a target="_blank" rel="noopener" href="https://uniapp.dcloud.io/tutorial/miniprogram-subject#wxs">参考</a>；在app-nvue中，可以使用bindingx监听滚动，<a target="_blank" rel="noopener" href="https://uniapp.dcloud.io/tutorial/nvue-api#nvue-%E9%87%8C%E4%BD%BF%E7%94%A8-bindingx">参考</a>。</li>
<li><code>onBackPress</code>上不可使用<code>async</code>，会导致无法阻止默认返回</li>
</ul>
<pre><code class="js">onPageScroll : function(e) &#123; //nvue暂不支持滚动监听，可用bindingx代替
    console.log(&quot;滚动距离为：&quot; + e.scrollTop);
&#125;,
</code></pre>
<p><code>onTabItemTap</code> 返回的json对象说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>Number</td>
<td>被点击tabItem的序号，从0开始</td>
</tr>
<tr>
<td>pagePath</td>
<td>String</td>
<td>被点击tabItem的页面路径</td>
</tr>
<tr>
<td>text</td>
<td>String</td>
<td>被点击tabItem的按钮文字</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li>onTabItemTap常用于点击当前tabitem，滚动或刷新当前页面。如果是点击不同的tabitem，一定会触发页面切换。</li>
<li>如果想在App端实现点击某个tabitem不跳转页面，不能使用onTabItemTap，可以使用<a target="_blank" rel="noopener" href="http://www.html5plus.org/doc/zh_cn/nativeobj.html">plus.nativeObj.view</a>放一个区块盖住原先的tabitem，并拦截点击事件。</li>
<li>支付宝小程序平台onTabItemTap表现为点击非当前tabitem后触发，因此不能用于实现点击返回顶部这种操作</li>
</ul>
<pre><code class="js">onTabItemTap : function(e) &#123;
    console.log(e);
    // e的返回格式为json对象： &#123;&quot;index&quot;:0,&quot;text&quot;:&quot;首页&quot;,&quot;pagePath&quot;:&quot;pages/index/index&quot;&#125;
&#125;,
</code></pre>
<p><code>onNavigationBarButtonTap</code> 参数说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>Number</td>
<td>原生标题栏按钮数组的下标</td>
</tr>
</tbody></table>
<pre><code class="js">onNavigationBarButtonTap : function (e) &#123;
    console.log(e);
    // e的返回格式为json对象：&#123;&quot;text&quot;:&quot;测试&quot;,&quot;index&quot;:0&#125;
&#125;
</code></pre>
<p><code>onBackPress</code> 回调参数对象说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>from</td>
<td>String</td>
<td>触发返回行为的来源：’backbutton’——左上角导航栏按钮及安卓返回键；’navigateBack’——uni.navigateBack() 方法。<strong>支付宝小程序端不支持返回此字段</strong></td>
</tr>
</tbody></table>
<pre><code class="javascript">export default &#123;
    data() &#123;
        return &#123;&#125;;
    &#125;,
    onBackPress(options) &#123;
        console.log(&#39;from:&#39; + options.from)
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong></p>
<ul>
<li>nvue 页面weex编译模式支持的生命周期同weex，具体参考：<a target="_blank" rel="noopener" href="https://uniapp.dcloud.io/tutorial/nvue-outline?id=%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F">weex生命周期介绍</a>。</li>
<li>支付宝小程序真机可以监听到非<code>navigateBack</code>引发的返回事件（使用小程序开发工具时不会触发<code>onBackPress</code>），不可以阻止默认返回行为</li>
</ul>
<h3 id="三、组件生命周期"><a href="#三、组件生命周期" class="headerlink" title="三、组件生命周期"></a>三、组件生命周期</h3><p><code>uni-app</code> 组件支持的生命周期，与vue标准组件的生命周期相同。这里没有页面级的onLoad等生命周期：</p>
<table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">说明</th>
<th align="left">平台差异说明</th>
<th align="left">最低版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">在实例初始化之前被调用。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#beforeCreate">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">在实例创建完成后被立即调用。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#created">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">在挂载开始之前被调用。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#beforeMount">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">挂载到实例上去之后调用。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#mounted">详见</a> 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用<code>$nextTick</code><a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#vm-nextTick">Vue官方文档</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">数据更新时调用，发生在虚拟 DOM 打补丁之前。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#beforeUpdate">详见</a></td>
<td align="left">仅H5平台支持</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">updated</td>
<td align="left">由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#updated">详见</a></td>
<td align="left">仅H5平台支持</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td align="left">实例销毁之前调用。在这一步，实例仍然完全可用。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#beforeDestroy">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">destroyed</td>
<td align="left">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/api/#destroyed">详见</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[uniapp]: 	“<a target="_blank" rel="noopener" href="https://zh.uniapp.dcloud.io/tutorial/page.html#lifecycle">https://zh.uniapp.dcloud.io/tutorial/page.html#lifecycle</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/uniapp/" rel="tag">uniapp</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-uniapp安装及调试"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/"
    >uniapp安装及调试</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/" class="article-date">
  <time datetime="2022-12-18T02:50:45.000Z" itemprop="datePublished">2022-12-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/uniapp/">uniapp</a> / <a class="article-category-link" href="/categories/uniapp/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/">uniapp安装及调试</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="uniapp安装及调试"><a href="#uniapp安装及调试" class="headerlink" title="uniapp安装及调试"></a>uniapp安装及调试</h1><blockquote>
<p>我们本篇文章主要讲解uniapp的项目创建</p>
<p>真机调试、ios模拟器调试、微信小程序调试</p>
</blockquote>
<h3 id="一、下载HBuilder-X"><a href="#一、下载HBuilder-X" class="headerlink" title="一、下载HBuilder X"></a>一、下载HBuilder X</h3><p>[HBuilder X]: 	“<a target="_blank" rel="noopener" href="https://www.dcloud.io/hbuilderx.html">https://www.dcloud.io/hbuilderx.html</a> “</p>
<p>我们可以下载我们需要的版本</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218095304650.png"></p>
<h3 id="二、安装运行并创建项目"><a href="#二、安装运行并创建项目" class="headerlink" title="二、安装运行并创建项目"></a>二、安装运行并创建项目</h3><p>第一次打开HBuilder X，我们可以去定义一下我们的配置，macos是去偏好设置，windows的在工具-&gt;设置</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218095514743.png"></p>
<p>我们可以去新建项目弹出窗口配置我们项目信息，项目名称和vue版本，这里我现在的是vue3，vue3的绑定预设是vite。</p>
<p>我们也可以去选择不一样的模板。</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218095735225.png"></p>
<h3 id="三、运行项目"><a href="#三、运行项目" class="headerlink" title="三、运行项目"></a>三、运行项目</h3><p>当我们打开项目的时候，准备运行的时候，我们可以选择将我们的项目运行到哪里，它会提示你安装相对应的插件，如果安装完插件，我们的软件没有识别到我们的插件，那我们可以选择重启我们的软件。</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218100111748.png"></p>
<p>这里先演示一下运行到内置浏览器（第一次运行我们可能要稍等一下）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218100428208.png"></p>
<h3 id="四、调试"><a href="#四、调试" class="headerlink" title="四、调试"></a>四、调试</h3><h4 id="1-ios模拟器调试"><a href="#1-ios模拟器调试" class="headerlink" title="1.ios模拟器调试"></a>1.ios模拟器调试</h4><blockquote>
<p>当然，在ios模拟器调试的前提是要是macos环境，并且下载了xcode（提前准备一下哦）因为我没有ios手机🫠</p>
</blockquote>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218100850001.png"></p>
<p>我们选择运行到ios模拟器 App基座（loading…）</p>
<p>选择我们的模拟器手机型号</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218101003209.png"></p>
<p>现在我就可以看到程序运行到了我们的iPhone 14 Pro Max（香得嘞）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218101115311.png"></p>
<p>当我们修改我们的程序代码并保存，就可以看见我们的视图更新了</p>
<h4 id="2-Android手机真机调试"><a href="#2-Android手机真机调试" class="headerlink" title="2.Android手机真机调试"></a>2.Android手机真机调试</h4><blockquote>
<p>当然，没有Android手机的也可以借其他同学的（Android模拟器配置有点麻烦，就先不配置了，想配置的同学先自行打开搜索🔍）</p>
</blockquote>
<p>手机真机调试的前提是要打开你的手机的开发者模式，不同的手机开启的方式也是不一样的，我的手机是红米K20 pro</p>
<p>具体打开流程为设置-&gt;我的设备-&gt;全部参数-&gt;点击MIUI版本3下（连击）系统提示进入开发者模式-&gt;返回到更多设置-&gt;开发者选项-&gt;打开usb调试</p>
<p>当我们选择运行到Android App基座，就会识别你的手机（记得用数据线将手机连接到电脑），点击运行</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218102154748.png"></p>
<p>第一次运行，手机会让你安装，点击安装就可以了</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/WechatIMG125.jpeg"></p>
<h4 id="3-微信小程序开发者工具调试"><a href="#3-微信小程序开发者工具调试" class="headerlink" title="3.微信小程序开发者工具调试"></a>3.微信小程序开发者工具调试</h4><blockquote>
<p>这个调试的方式的前提是要有一个开发者账号，没有的同学要先去注册一个</p>
<p>[注册]: 	“<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN">https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN</a> “</p>
<p>然后利用注册绑定的微信登陆我们的微信公众平台</p>
<p>没有下载微信开发者工具的同学也要下载一个</p>
</blockquote>
<p>然后在我们的开发-&gt;开发管理-&gt;开发设置下面有我们的开发者ID（等会要用）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218102931643.png"></p>
<p>当我们点击发行-&gt;小程序-微信的时候，会让你配置你的开发者ID，然后项目就会自动打包</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218103403063.png"></p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218103530235.png"></p>
<p>第一次编译的时候，我们可以根据编译完成的项目路径去手动导入我们的微信开发者工具去调试</p>
<p>注意：不要在微信开发者工具去修改我们的代码，因为下一次发行编译会覆盖掉我们的修改</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218103710649.png"></p>
<p>当然，我们还有另一种导入方法，那就是自动导入</p>
<p>首先我们要将微信开发者工具的安全设置的服务端口打开</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218104049483.png"></p>
<p>再到HBuilder X去配置微信开发者工具的路径（这里的路径可以查看自己的安装路径）</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218104502864.png"></p>
<p>到这我们的配置就完成了</p>
<p>接下来我们再发行微信小程序</p>
<p>我们就可以看见微信开发者工具自动打开并运行我们的项目了</p>
<p><img src="/2022/12/18/uniapp%E5%AE%89%E8%A3%85%E5%8F%8A%E8%B0%83%E8%AF%95/image-20221218104719407.png"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>到目前为止，我们开发时候的调试就可以轻松掌握了</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/uniapp/" rel="tag">uniapp</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vue3api变化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/16/Vue3api%E5%8F%98%E5%8C%96/"
    >Vue3api变化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/16/Vue3api%E5%8F%98%E5%8C%96/" class="article-date">
  <time datetime="2022-12-16T01:20:02.000Z" itemprop="datePublished">2022-12-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue3/">Vue3</a> / <a class="article-category-link" href="/categories/Vue3/Vue3api%E5%8F%98%E5%8C%96/">Vue3api变化</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><blockquote>
<p>官网地址：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/">https://cn.vuejs.org/</a><br>vue最新版分为两个版本： Vue3.0（20年9月18日） Vue 3.2 （21年8月10日）</p>
</blockquote>
<h3 id="Vue-3-2-Vite-volar"><a href="#Vue-3-2-Vite-volar" class="headerlink" title="Vue 3.2 +Vite+volar"></a><strong>Vue 3.2 +Vite+volar</strong></h3><ul>
<li>Vue3 框架做了大量的性能优化，包括虚拟 DOM，编译模板、代理的新数据监听，体积更小的打包文件等。</li>
<li>新的组合式 API （composition-api），更适合大型项目的构建，去除繁琐的 this 操作；</li>
<li>由于是基于 TypeScript 编写，对 TypeScript 原生支持更好，更强大的智能类型推导功能；</li>
<li>生命周期的一些改变，vue2 中的 beforeCreate 和 created 被一个新增的 setup 生命周期函数代替；</li>
<li>一些常见 API 如 v-model 的变化，支持对一个组件同时进行多个 v-model 的数据绑定。</li>
</ul>
<p>vscode 的插件 vetur 对vue3 的composition API语法支持度非常弱，所以开发vue3项目需要将vetur禁用 更换另一个插件</p>
<p>开发vue3安装并使用： volar 插件</p>
<h3 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h3><p>Vite 官网：<a target="_blank" rel="noopener" href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a></p>
<pre><code class="json">yarn create vite my-vue-app --template vue     
</code></pre>
<h3 id="2-SFC-单文件组件"><a href="#2-SFC-单文件组件" class="headerlink" title="2.SFC 单文件组件"></a>2.SFC 单文件组件</h3><blockquote>
<p>html 部分变化不大<br>vue2的 template 中只能有一个子节点，vue3的 template 中可以写多个子节点<br>js 部分内置ts，但是vite创建的项目没有开启 ， <code>&lt;script lang=&quot;ts&quot; setup&gt;</code> 这样写即可支持ts<br>新增setup 语法糖，js代码大量简化<br>代码中不再出现 <code>this</code><br>css 代码中 可以使用v-bind 指令</p>
</blockquote>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
       let color = &#39;#f60&#39;;
&lt;/script&gt;

&lt;style scoped&gt;
.box&#123;
  width: 100px;
  height: 100px;
  background: v-bind(color);
&#125;
&lt;/style&gt;
</code></pre>
<h3 id="2-setup语法糖"><a href="#2-setup语法糖" class="headerlink" title="2. setup语法糖"></a>2. setup语法糖</h3><p>起初 Vue3.0 暴露变量必须 return 出来，template中才能使用； 这样会导致在页面上变量会出现很多次。</p>
<p>vue3.2只需在script标签中添加setup,可以帮助我们解决这个问题。</p>
<p>1.组件只需引入不用注册，属性和方法也不用返回， 也不用写setup函数，也不用写export default ， 甚至是自定义指令也可以在我们的template中自动获得。</p>
<h2 id="3-data-定义"><a href="#3-data-定义" class="headerlink" title="3.data 定义"></a>3.data 定义</h2><h3 id="3-1-直接定义-无响应式"><a href="#3-1-直接定义-无响应式" class="headerlink" title="3.1 直接定义 无响应式"></a>3.1 直接定义 无响应式</h3><pre><code class="html">&lt;template&gt;
  &lt;div&gt;
      &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;
      &lt;!-- 这里双向绑定失效，直接定义变量没有响应式特性 --&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  let name = &#39;张麻子&#39;;

&lt;/script&gt;
</code></pre>
<h3 id="3-2-ref-定义基本数据类型-有响应式"><a href="#3-2-ref-定义基本数据类型-有响应式" class="headerlink" title="3.2 ref 定义基本数据类型 有响应式"></a>3.2 ref 定义基本数据类型 有响应式</h3><pre><code class="html">&lt;template&gt;
  &lt;div&gt;
      &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;
       &lt;!-- 修改数据 有响应式 --&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;
      &lt;button @click=&quot;setData&quot;&gt;修改数据&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
 import &#123;ref&#125; from &#39;vue&#39;;   
    
 let name = ref(&#39;张麻子&#39;);
   //js中修改数据有响应式
 const setData = ()=&gt;&#123;
     name.value = &#39;黄四郎&#39;
 &#125;
     
&lt;/script&gt;
</code></pre>
<h3 id="3-3-reactvie-定义引用数据类型-有响应式"><a href="#3-3-reactvie-定义引用数据类型-有响应式" class="headerlink" title="3.3 reactvie 定义引用数据类型 有响应式"></a>3.3 reactvie 定义引用数据类型 有响应式</h3><pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
      &lt;h2&gt;&#123;&#123;user.name&#125;&#125;&lt;/h2&gt;
      &lt;!-- 修改数据 有响应式 --&gt;
      &lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt;
      &lt;!-- 新增属性 --&gt;
      &lt;button @click=&quot;addItem&quot;&gt;新增属性&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import &#123;ref,reactive&#125; from &#39;vue&#39;
let user = reactive(&#123;
  name:&#39;张麻子&#39;,
  age:40
&#125;)
// js中新增对象属性-可以直接赋值和修改（有响应式），在ts环境下，vscode会提示错误，但在页面中可以正常渲染
const addItem = ()=&gt;&#123;
  user.like=&#39;打豆豆&#39;
&#125;

&lt;/script&gt;
</code></pre>
<h2 id="4-methods-方法定义"><a href="#4-methods-方法定义" class="headerlink" title="4.methods 方法定义"></a>4.methods 方法定义</h2><pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 年龄 + --&gt;
    &lt;h1&gt;&#123;&#123;user.age&#125;&#125;&lt;/h1&gt;
    &lt;!-- 调用方法 --&gt;
    &lt;button @click=&quot;addAge&quot;&gt;年龄+&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import &#123; ref, reactive &#125; from &quot;vue&quot;;

let user = reactive(&#123;
  name: &quot;张麻子&quot;,
  age: 40,
&#125;);
//方法
const addAge=()=&gt;&#123;
    user.age++;
&#125;
//方法调用方法
const getUserInfo=()=&gt;&#123;
  addAge()
  console.log(user.age)
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="5-computed-计算属性"><a href="#5-computed-计算属性" class="headerlink" title="5.computed 计算属性"></a>5.computed 计算属性</h2><pre><code class="java">&lt;script setup&gt;
import &#123; ref, reactive, computed &#125; from &quot;vue&quot;;

let user = reactive(&#123;
  name: &quot;张麻子&quot;,
  age: 40,
&#125;);
//计算属性
const getAge = computed(()=&gt;&#123;
  return &#39;我的年龄&#39;+user.age
&#125;)
&lt;/script&gt;
</code></pre>
<h2 id="6-watch-使用"><a href="#6-watch-使用" class="headerlink" title="6.watch 使用"></a>6.watch 使用</h2><pre><code class="json">watch(监听数据源,执行函数,[配置参数])    
//配置参数： 立即执行 深度监听
&#123;immediate: true, deep: true &#125;
</code></pre>
<h3 id="6-1-监听基本数据类型单一数据源"><a href="#6-1-监听基本数据类型单一数据源" class="headerlink" title="6.1 监听基本数据类型单一数据源"></a>6.1 监听基本数据类型单一数据源</h3><pre><code class="javascript">&lt;script setup&gt;
import &#123;ref, watch&#125; from &#39;vue&#39;
 let name = ref(&#39;张麻子&#39;)

 //监听器
watch(name,(newVal,oldVal)=&gt;&#123;
    console.log(&#39;变量发生了改变...&#39;,newVal);
&#125;)
&lt;/script&gt;
</code></pre>
<h3 id="6-2-监听引用数据类型单一数据源"><a href="#6-2-监听引用数据类型单一数据源" class="headerlink" title="6.2 监听引用数据类型单一数据源"></a>6.2 监听引用数据类型单一数据源</h3><pre><code class="java">&lt;script setup&gt;
import &#123;reactive, ref, watch&#125; from &#39;vue&#39;
let user = reactive(&#123;name:&#39;张三&#39;,age:14&#125;)
 //监听器
watch(()=&gt;user.name,(newVal,oldVal)=&gt;&#123;
  console.log(&#39;对象user中的name属性发生了变化..&#39;,newVal);
&#125;)
&lt;/script&gt;
</code></pre>
<h3 id="6-3-监听引用数据类型-多数据源-深度监听"><a href="#6-3-监听引用数据类型-多数据源-深度监听" class="headerlink" title="6.3 监听引用数据类型 多数据源[深度监听]"></a>6.3 监听引用数据类型 多数据源[深度监听]</h3><pre><code class="java">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;addNum()&quot;&gt; 添加随机数&lt;/button&gt;
    &lt;div v-for=&quot;item in nums&quot; :key=&quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import &#123; reactive, ref, watch &#125; from &#39;vue&#39;
let nums = reactive([]);

//添加随机数
const addNum = () =&gt; &#123;
  let num = Math.ceil(Math.random() * 100);
  nums.push(num);
&#125;
//监听数组变化-深度监听
watch(()=&gt;nums,(newVal,oldVal)=&gt;&#123;
    console.log(&#39;nums数组发生了变化..&#39;,newVal);
&#125;,&#123;deep:true&#125;)

&lt;/script&gt;
</code></pre>
<h2 id="7-生命周期"><a href="#7-生命周期" class="headerlink" title="7.生命周期"></a>7.生命周期</h2><table>
<thead>
<tr>
<th>vue2</th>
<th>vue3.0</th>
<th>vue3.2</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td></td>
<td>setup</td>
<td>组件创建之前 可以获取顶级实例对象</td>
</tr>
<tr>
<td>created</td>
<td></td>
<td>setup</td>
<td>组件创建完成，可以获取变量</td>
</tr>
<tr>
<td>beforeMount</td>
<td></td>
<td>onBeforeMount</td>
<td>挂载前，VNdom创建完成，真实dom未渲染</td>
</tr>
<tr>
<td>mounted</td>
<td></td>
<td>onMounted</td>
<td>挂载完成，真实dom创建完成，可以获取dom</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td></td>
<td>onBeforeUpdate</td>
<td>dom更新前触发</td>
</tr>
<tr>
<td>updated</td>
<td></td>
<td>onUpdated</td>
<td>dom更新完成触发</td>
</tr>
<tr>
<td>beforedestroy，destroyed</td>
<td>beforeUnmount</td>
<td>onBeforeUnmount</td>
<td>组件卸载后触发 所有的挂载的数据 子组件全部卸载后触发</td>
</tr>
<tr>
<td></td>
<td>errorCaptured</td>
<td>onErrorCaptured</td>
<td>在捕获一个来自后代组件的错误时被调用</td>
</tr>
<tr>
<td></td>
<td>renderTracked</td>
<td>onRenderTracked</td>
<td>跟踪虚拟 DOM 重新渲染时调用</td>
</tr>
<tr>
<td></td>
<td>renderTriggered</td>
<td>onRenderTriggered</td>
<td>当虚拟 DOM 重新渲染被触发时调用</td>
</tr>
<tr>
<td>activated</td>
<td>activated</td>
<td>onActivated</td>
<td>缓存组件激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>deactivated</td>
<td>onDeactivated</td>
<td>缓存组件失活时调用</td>
</tr>
</tbody></table>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
      &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
import &#123; onMounted &#125; from &#39;vue&#39;;
  //生命周期钩子监听
  onMounted(()=&gt;&#123;
    console.log(document.querySelector(&#39;.box&#39;)); //可以获取dom
  &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="8-组件使用"><a href="#8-组件使用" class="headerlink" title="8.组件使用"></a>8.组件使用</h2><ul>
<li>创建 src&#x2F;components&#x2F;Son.vue</li>
<li>App.vue中导入并使用该组件</li>
</ul>
<p>vue3.2 中当我们导入子组件时，setup语法糖会自动去注册该组件，所以注册语句不用写了。</p>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
    &lt;son&gt;&lt;/son&gt;
  &lt;/div&gt;
&lt;script setup&gt;
import Son from &#39;./components/Son.vue&#39;
&lt;/script&gt;
</code></pre>
<h2 id="9-组件通信"><a href="#9-组件通信" class="headerlink" title="9.组件通信"></a>9.组件通信</h2><h3 id="9-1-父传子-defineProps"><a href="#9-1-父传子-defineProps" class="headerlink" title="9.1 父传子 defineProps"></a>9.1 父传子 defineProps</h3><ul>
<li>父组件</li>
</ul>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
      &lt;Son class=&quot;box&quot; title=&quot;我是父组件传递的标题&quot; :likes=&quot;likes&quot;&gt;&lt;/Son&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  import Son from &#39;./components/Son.vue&#39;
  let likes = [&#39;张三&#39;,&#39;李四&#39;]
&lt;/script&gt;
</code></pre>
<ul>
<li>子组件</li>
</ul>
<pre><code class="java">&lt;script setup&gt;
const props=defineProps(&#123;
    title:&#123;
        type:String,
        default:&#39;&#39;
    &#125;,
    likes:&#123;
        type:Array,
        default:()=&gt;[]
    &#125;
&#125;)
&lt;/script&gt;
</code></pre>
<h3 id="9-2-子传父-defineEmits"><a href="#9-2-子传父-defineEmits" class="headerlink" title="9.2 子传父 defineEmits"></a>9.2 子传父 defineEmits</h3><ul>
<li>子组件</li>
</ul>
<pre><code class="java">&lt;template&gt;
    &lt;div&gt;
        &lt;button @click=&quot;sendData&quot;&gt;传递数据&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
//定义自定义事件
const emit = defineEmits([&#39;send&#39;])
//自己的事件执行函数
const sendData = () =&gt; &#123;
    //执行自定义事件
    emit(&#39;send&#39;, &#39;我是儿子组件传递的数据&#39;)
&#125;
&lt;/script&gt;
</code></pre>
<ul>
<li>父组件</li>
</ul>
<pre><code class="java">&lt;template&gt;
  &lt;div&gt;
      &lt;Son class=&quot;box&quot;  @send=&quot;getData&quot; &gt;&lt;/Son&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  import Son from &#39;./components/Son.vue&#39;
  //触发自定义事件-接收数据
  const getData = (data)=&gt;&#123;
    console.log(data);
  &#125;
&lt;/script&gt;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue3/" rel="tag">vue3</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-chatGPT是什么"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/chatGPT%E6%98%AF%E4%BB%80%E4%B9%88/"
    >chatGPT是什么</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/chatGPT%E6%98%AF%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2022-12-14T01:04:08.000Z" itemprop="datePublished">2022-12-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/">趣味技术</a> / <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/chatGPT%E6%98%AF%E4%BB%80%E4%B9%88/">chatGPT是什么</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="chatGPT是什么"><a href="#chatGPT是什么" class="headerlink" title="chatGPT是什么"></a>chatGPT是什么</h1><blockquote>
<p>我们都知道目前火出圈的AI绘画和chatGPT</p>
<p>那么它们是什么呢？</p>
</blockquote>
<h3 id="一、chatGPT是什么"><a href="#一、chatGPT是什么" class="headerlink" title="一、chatGPT是什么"></a>一、chatGPT是什么</h3><p><strong>ChatGPT</strong>是由<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/OpenAI">OpenAI</a>开发的一个<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%81%8A%E5%A4%A9%E6%A9%9F%E5%99%A8%E4%BA%BA">聊天机器人</a>程序，于2022年11月推出。该程序使用基于<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/GPT-3">GPT-3.5</a>架构的<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%AA%9E%E8%A8%80%E6%A8%A1%E5%9E%8B">大型语言模型</a>并通过<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0">强化学习</a>进行训练。它以对话方式进行交互。在推广的期间中，所有人可以免费注册，并在登入后后免费使用 ChatGPT 实现与 AI 机器人对话</p>
<p>有世界首富——电动汽车巨头特斯拉掌门人马斯克（ Elon Musk）入股的研发公司OpenAI表示，最新推出的聊天机器人ChatGPT在不到一周时间里就拥有百万用户。</p>
<p>ChatGPT是OpenAI发布的聊天机器人模型，它的交互界面简洁，只有一个输入框，AI将根据输入内容进行回复，并允许在一个语境下持续聊天。</p>
<p><img src="/2022/12/14/chatGPT%E6%98%AF%E4%BB%80%E4%B9%88/image-20221214085330016.png"></p>
<h3 id="二、如何强大"><a href="#二、如何强大" class="headerlink" title="二、如何强大"></a>二、如何强大</h3><p>据浙商和国盛证券研报，ChatGPT相比以往的主要提升点在于记忆能力，ChatGPT可以储存对话信息，延续上下文，从而实现连续对话，这在对话场景中至关重要，极大地提升了对话交互模式下的用户体验。</p>
<p>具体而言，此次新加入的训练方式被称为“从人类反馈中强化学习”（ReinforcementLearning from Human Feedback，RLHF）。这一训练方法增加了人类对模型输出结果的演示，并且对结果进行了排序。具体操作上，人工智能训练者扮演对话的双方，即用户和人工智能助手，提供对话样本。在人类扮演聊天机器人的时候，会让模型生成一些建议辅助训练师撰写回复，训练师会对回复选项打分排名，将更好的结果输回到模型中，通过以上奖励策略对模型进行微调并持续迭代。</p>
<p><strong>此外，ChatGPT的背后离不开大模型、大数据、大算力。</strong></p>
<p>ChatGPT成为AIGC里程碑的背后，是算力发展和数字时代形成的大数据所共同支持的大模型训练，才能实现目前的效果。由OpenAI研发的ChatGPT是微调后的GPT-3.5系列模型，有着多达1750亿个模型参数，并在今年年初训练完成。模型训练的背后离不开大数据的支持，OpenAI主要使用的公共爬虫数据集有着超过万亿单词的人类语言数据集。在算力方面，GPT-3.5在Azure AI超算基础设施（由V100GPU组成的高带宽集群）上进行训练，总算力消耗约3640PF-days（即每秒一千万亿次计算，运行3640个整日）。</p>
<p><strong>AIGC里程碑级应用</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.8btc.com/article/6787780">AIGC</a> 将是 Web3 时代的生产力工具。当我们迈入 Web3.0 时代，人工智能、关联数据和语义网络构建，形成人与网络的全新链接，内容消费需求飞速增长。UGC\PGC 这样的内容生成方式将难以匹配扩张的需求。AIGC 将是新的元宇宙内容生成解决方案。AIGC 的生成利用人工智能学习知识图谱、自动生成，在内容的创作为人类提供协助或是完全由 AI 产生内容。不仅能帮助提高内容生成的效率，还能提高内容的多样性。随着 NLP（Natural Language Processing，自然语言处理）技术和扩散模型（Diffusion Model）的发展，AI 不再仅作为内容创造的辅助工具，创造生成内容成为了可能。由此，将来文字生成、图片绘制、视频剪辑、游戏内容生成皆可由 AI 替代。</p>
<p>国盛证券表示，AIGC不仅改变创作，还将改变获取信息的主要方式。而在此之上，ChatGPT所展示了作为生产力的存在，ChatGPT在寻找答案、解决问题的效率上已经部分的超越了如今的搜索引擎，ChatGPT或许在未来会改变我们获取信息、输出内容的方式，AIGC有望成为数字经济时代驱动需求爆发的杀手级应用。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[维基百科]: 	“<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/ChatGPT">https://zh.m.wikipedia.org/zh-hans/ChatGPT</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/chatGPT/" rel="tag">chatGPT</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-chatGPT注册"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/"
    >chatGPT注册</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/" class="article-date">
  <time datetime="2022-12-14T00:37:52.000Z" itemprop="datePublished">2022-12-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/">趣味技术</a> / <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/chatGPT%E6%B3%A8%E5%86%8C/">chatGPT注册</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="chatGPT注册、登陆具体流程"><a href="#chatGPT注册、登陆具体流程" class="headerlink" title="chatGPT注册、登陆具体流程"></a>chatGPT注册、登陆具体流程</h1><blockquote>
<p>需要科学上网</p>
<p>由于目前推广期间，chatGPT只要注册openai就可以免费使用chatGPT</p>
</blockquote>
<h3 id="一、进入chatGPT的注册页面"><a href="#一、进入chatGPT的注册页面" class="headerlink" title="一、进入chatGPT的注册页面"></a>一、进入chatGPT的注册页面</h3><p>[chatGPT]: 	“<a target="_blank" rel="noopener" href="https://chat.openai.com/auth/login">https://chat.openai.com/auth/login</a> “</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081000882.png"></p>
<h3 id="二、点击Sign-up注册"><a href="#二、点击Sign-up注册" class="headerlink" title="二、点击Sign up注册"></a>二、点击Sign up注册</h3><p>我注册的时候用的谷歌邮箱</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081235003.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081250319.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081403723.png"></p>
<h3 id="三、进入了电话号码验证环节"><a href="#三、进入了电话号码验证环节" class="headerlink" title="三、进入了电话号码验证环节"></a>三、进入了电话号码验证环节</h3><p>一个号码模拟平台 <a target="_blank" rel="noopener" href="https://sms-activate.org/cn?ref=2780512">https://sms-activate.org/cn?ref=2780512</a></p>
<p>第一步去注册登陆（这一步没什么问题）</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081608840.png"></p>
<p>第二步需要存钱了哈哈哈</p>
<p>当然，充多少一般都可以，如果只用这一次的话可以充少一点，0.2-0.5美元</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081921982.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081825615.png"></p>
<p>我们可以选择支付宝来充值，很方便</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082059408.png"></p>
<p>等到充值到账（大概几分钟）</p>
<p>我们就可以购买服务了，点击购物车（这个便宜）</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082407157.png"></p>
<p>然后，可以在激活区看到待使用的临时号码，将此号码复制到 OpenAI 的验证码接收区里面。</p>
<p>先选择对应国家，再填号码，然后发送电话号码，激活区就可以看见验证码了。</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214083118069.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082913264.png"></p>
<p>电话验证完，注册完毕</p>
<h3 id="四、登陆chatGPT"><a href="#四、登陆chatGPT" class="headerlink" title="四、登陆chatGPT"></a>四、登陆chatGPT</h3><p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214083525980.png"></p>
<p>这时候我们就可以开始和它愉快的聊天了</p>
<p>我们下一篇会介绍它是什么？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/chatGPT/" rel="tag">chatGPT</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>