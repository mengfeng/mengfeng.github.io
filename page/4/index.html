<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-宝塔Linux部署"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/"
    >宝塔Linux部署</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/" class="article-date">
  <time datetime="2022-11-15T05:29:18.000Z" itemprop="datePublished">2022-11-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CI-CD/">CI/CD</a> / <a class="article-category-link" href="/categories/CI-CD/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/">宝塔Linux部署</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="宝塔Linux部署"><a href="#宝塔Linux部署" class="headerlink" title="宝塔Linux部署"></a>宝塔Linux部署</h1><h3 id="一、购买云服务器"><a href="#一、购买云服务器" class="headerlink" title="一、购买云服务器"></a>一、购买云服务器</h3><p>[阿里云官网]: 	“<a target="_blank" rel="noopener" href="https://cn.aliyun.com/?from_alibabacloud=&amp;utm_content=se_1013083955">https://cn.aliyun.com/?from_alibabacloud=&amp;utm_content=se_1013083955</a> “</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100233843.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100305806.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100353042.png"></p>
<p>当我购买了云服务器，那我们就可以登陆我们的服务器去下载mac的宝塔面板（通过外网地址访问浏览器）</p>
<h3 id="二、登陆云服务器"><a href="#二、登陆云服务器" class="headerlink" title="二、登陆云服务器"></a>二、登陆云服务器</h3><p>初始化（重置）实例密码</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101533088.png"></p>
<p>输入Password密码和实例密码</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115100757824.png"></p>
<h3 id="三、安装宝塔"><a href="#三、安装宝塔" class="headerlink" title="三、安装宝塔"></a>三、安装宝塔</h3><p>然后可以看到已经进了服务器，那么我们就可以开始安装了</p>
<pre><code class="php">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh fa1f2600
</code></pre>
<p>稍等片刻后，输入“y”继续</p>
<p>下载成功之后，就会出现账户和密码和访问地址</p>
<p>我们通过外网面板地址访问</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101323474.png"></p>
<p>如果现在无法访问的话，就去阿里云服务器实例安全组添加提示端口</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101750883.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115101826756.png"></p>
<p>现在应该可以访问了，如果还不行就添加8888端口</p>
<h3 id="四、配置宝塔"><a href="#四、配置宝塔" class="headerlink" title="四、配置宝塔"></a>四、配置宝塔</h3><p>当我们访问成功，根据提示安装宝塔面板所需要的创建就可以了</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102042938.png"></p>
<p>如果我们下载插件时间过长，重启宝塔面板</p>
<h3 id="五、创建站点"><a href="#五、创建站点" class="headerlink" title="五、创建站点"></a>五、创建站点</h3><p>我们来创建我们第一个站点</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102605290.png"></p>
<p>提交的时候我们可能遇见下面的提示，配置错误</p>
<pre><code class="ini">nginx: [emerg] open() &quot;/www/server/nginx/conf/enable-php.conf&quot; failed (2: No such file or directory) in /www/server/nginx/conf/nginx.conf:79 nginx: configuration file /www/server/nginx/conf/nginx.conf test failed
</code></pre>
<p>有一个最简单的方案就是，替换nginx 的版本，换一个更低一点的版本</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102833852.png"></p>
<p>重启宝塔面板就可以了</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115102931757.png"></p>
<h3 id="六、上传站点部署文件"><a href="#六、上传站点部署文件" class="headerlink" title="六、上传站点部署文件"></a>六、上传站点部署文件</h3><p>选择要上传文件的站点</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115103700868.png"></p>
<p>选择要上传的文件，可以拖拽</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115103850298.png"></p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115104445278.png"></p>
<p>那么我们现在访问网站就可以了</p>
<p>如果还是访问不到的话（阿里云购买的域名），建议先进行备案，然后再部署网站</p>
<p><img src="/2022/11/15/%E5%AE%9D%E5%A1%94Linux%E9%83%A8%E7%BD%B2/image-20221115132138765.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CD/" rel="tag">CD</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Dokcer部署Drone2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/"
    >Dokcer部署Drone2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/" class="article-date">
  <time datetime="2022-11-14T03:43:51.000Z" itemprop="datePublished">2022-11-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CI-CD/">CI/CD</a> / <a class="article-category-link" href="/categories/CI-CD/Dokcer%E9%83%A8%E7%BD%B2Drone2/">Dokcer部署Drone2</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Dokcer部署Drone2"><a href="#Dokcer部署Drone2" class="headerlink" title="Dokcer部署Drone2"></a>Dokcer部署Drone2</h1><p>这一篇延续上一篇的问题，这一篇解决仓库初始化失败（500）的问题</p>
<h3 id="一、问题原因"><a href="#一、问题原因" class="headerlink" title="一、问题原因"></a>一、问题原因</h3><p>问题在于 drone 创建 webhooks 时失败，Github 不允许创建本地 localhost 类型的 webhooks，因为这样执行时是在本地，没办法定位到具体的用户主机。可以使用 <a href="https://link.juejin.cn/?target=https://ngrok.com">ngrok</a> 这样的工具把本地服务绑定到公网。</p>
<h3 id="二、解决问题"><a href="#二、解决问题" class="headerlink" title="二、解决问题"></a>二、解决问题</h3><h4 id="1-安装ngrok"><a href="#1-安装ngrok" class="headerlink" title="1.安装ngrok"></a>1.安装ngrok</h4><p>安装ngrok的时候，mac用户默认下载的位置和终端的位置不一样，所以我们统一安装到 &#x2F;usr&#x2F;local&#x2F;bin 目录</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114110814408.png"></p>
<p>具体步骤是：</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111042057.png" alt="步骤一：解压缩文件后复制ngrok"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111257463.png" alt="步骤二：前往文件夹"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111332755.png"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111355186.png" alt="步骤三：复制ngrok，双击执行"></p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111451022.png" alt="进程完成"></p>
<h4 id="2-连接服务"><a href="#2-连接服务" class="headerlink" title="2.连接服务"></a>2.连接服务</h4><p>执行ngrok的密钥，连接服务</p>
<pre><code class="ini">ngrok config add-authtoken 2HW491ApRpQILMM3kwW_4T7x8zVrAXpqUEjdSGU4y
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111554074.png"></p>
<p>当出现下面的情况，就说明安装成功了，就可以使用命令了</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111712382.png"></p>
<p>如果提示没有验证邮箱，就先去验证邮箱，要不然服务会中断</p>
<h4 id="3-开启服务端口"><a href="#3-开启服务端口" class="headerlink" title="3.开启服务端口"></a>3.开启服务端口</h4><pre><code class="ini">ngrok http 80
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114111950182.png"></p>
<h4 id="4-修改Drone配置（github）"><a href="#4-修改Drone配置（github）" class="headerlink" title="4.修改Drone配置（github）"></a>4.修改Drone配置（github）</h4><pre><code class="ini">#Homepage URL
https://8313-183-202-88-243.ap.ngrok.io
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114112053258.png"></p>
<p>5.修改docker-compose.yml 和 .env 文件</p>
<pre><code class="ini">vim docker-compose.yml  //配置文件
vim .env
</code></pre>
<pre><code class="javascript">//docker-compose.yml
version: &#39;3.7&#39;

services:

  drone-server:
    image: drone/drone:2.3.1
    ports:
      - 80:80
    volumes:
      - drone-data:/data:rw
      - ./ssl:/etc/certs
    restart: always
    environment:
      - DRONE_SERVER_HOST=$&#123;DRONE_SERVER_HOST:-https://drone.yeasy.com&#125;
      - DRONE_SERVER_PROTO=$&#123;DRONE_SERVER_PROTO:-https&#125;
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_GITHUB_SERVER=https://github.com
      - DRONE_GITHUB_CLIENT_ID=$&#123;DRONE_GITHUB_CLIENT_ID&#125;
      - DRONE_GITHUB_CLIENT_SECRET=$&#123;DRONE_GITHUB_CLIENT_SECRET&#125;

  drone-runner:
    image: drone/drone-runner-docker:1
    restart: always
    depends_on:
      - drone-server
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:rw
    environment:
      - DRONE_RPC_PROTO=http
      - DRONE_RPC_HOST=drone-server
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_RUNNER_NAME=$&#123;HOSTNAME:-demo&#125;
      - DRONE_RUNNER_CAPACITY=2
    dns: 114.114.114.114

volumes:
  drone-data:
</code></pre>
<pre><code class="ini">//.env
# 必填 服务器地址，例如 drone.domain.com
DRONE_SERVER_HOST=8313-183-202-88-243.ap.ngrok.io
DRONE_SERVER_PROTO=https
DRONE_RPC_SECRET=24c08d3d73e59c5d9dd5e26e3256c1f9
HOSTNAME=demo
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_ID=
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_SECRET=
</code></pre>
<h4 id="5-重启Drone"><a href="#5-重启Drone" class="headerlink" title="5.重启Drone"></a>5.重启Drone</h4><pre><code class="ini">docker-compose up -d
</code></pre>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114112748311.png"></p>
<p>这样我们就解决了500的问题，github上的Webhooks就启动了</p>
<p><img src="/2022/11/14/Dokcer%E9%83%A8%E7%BD%B2Drone2/image-20221114113100300.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CI/" rel="tag">CI</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Docker部署Drone"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/"
    >Docker部署Drone</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/" class="article-date">
  <time datetime="2022-11-13T11:43:16.000Z" itemprop="datePublished">2022-11-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CI-CD/">CI/CD</a> / <a class="article-category-link" href="/categories/CI-CD/Docker%E9%83%A8%E7%BD%B2Drone/">Docker部署Drone</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Docker部署Drone"><a href="#Docker部署Drone" class="headerlink" title="Docker部署Drone"></a>Docker部署Drone</h1><h3 id="一、新建-GitHub-应用"><a href="#一、新建-GitHub-应用" class="headerlink" title="一、新建 GitHub 应用"></a>一、新建 GitHub 应用</h3><p>具体顺序Settings-&gt;Developer settings-&gt;OAuth Apps-&gt;New OAuth App</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155624239.png"></p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155447805.png" alt="image-20221113155447805"></p>
<p>新建完成后记住Client ID和Client secrets，后面配置需要</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155825926.png"></p>
<h3 id="二、下载drone"><a href="#二、下载drone" class="headerlink" title="二、下载drone"></a>二、下载drone</h3><pre><code class="ini">docker pull drone/drone //下载drone
</code></pre>
<h3 id="三、配置-Drone"><a href="#三、配置-Drone" class="headerlink" title="三、配置 Drone"></a>三、配置 Drone</h3><p>通过使用 <code>Docker Compose</code> 来启动 <code>Drone</code>，编写 <code>docker-compose.yml</code> 文件（这个文件直接新建就可以了）</p>
<pre><code class="ini">touch docker-compose.yml //新建文件
vim docker-compose.yml  //配置文件
</code></pre>
<pre><code class="javascript">//docker-compose.yml 文件不用修改
version: &#39;3&#39;

services:

  drone-server:
    image: drone/drone:2.3.1
    ports:
      - 443:443
      - 80:80
    volumes:
      - drone-data:/data:rw
      - ./ssl:/etc/certs
    restart: always
    environment:
      - DRONE_SERVER_HOST=$&#123;DRONE_SERVER_HOST:-https://drone.yeasy.com&#125;
      - DRONE_SERVER_PROTO=$&#123;DRONE_SERVER_PROTO:-https&#125;
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_GITHUB_SERVER=https://github.com
      - DRONE_GITHUB_CLIENT_ID=$&#123;DRONE_GITHUB_CLIENT_ID&#125;
      - DRONE_GITHUB_CLIENT_SECRET=$&#123;DRONE_GITHUB_CLIENT_SECRET&#125;

  drone-agent:
    image: drone/drone-runner-docker:1
    restart: always
    depends_on:
      - drone-server
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:rw
    environment:
      - DRONE_RPC_PROTO=http
      - DRONE_RPC_HOST=drone-server
      - DRONE_RPC_SECRET=$&#123;DRONE_RPC_SECRET:-secret&#125;
      - DRONE_RUNNER_NAME=$&#123;HOSTNAME:-demo&#125;
      - DRONE_RUNNER_CAPACITY=2
    dns: 114.114.114.114

volumes:
  drone-data:
</code></pre>
<p>新建 <code>.env</code> 文件，输入变量及其值（上面docker-compose.yml文件配置会默认读取 .env 文件变量）</p>
<pre><code class="ini">touch .env //新建文件
</code></pre>
<pre><code class="ini">//.env
# 必填 服务器地址，例如 drone.domain.com
DRONE_SERVER_HOST=
DRONE_SERVER_PROTO=https
DRONE_RPC_SECRET=secret
HOSTNAME=demo
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_ID=
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_SECRET=
</code></pre>
<pre><code class="ini">#我的配置（参考）
# 必填 服务器地址，例如 drone.domain.com
DRONE_SERVER_HOST=localhost
DRONE_SERVER_PROTO=http
DRONE_RPC_SECRET=secret
HOSTNAME=demo
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_ID=
# 必填 在 GitHub 应用页面查看
DRONE_GITHUB_CLIENT_SECRET=
</code></pre>
<h3 id="四、启动Drone"><a href="#四、启动Drone" class="headerlink" title="四、启动Drone"></a>四、启动Drone</h3><pre><code class="ini">docker-compose up -d
</code></pre>
<p>访问http:localhost:80（我配置的，你和我配置一样就可以打开）就成功了</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113161124001.png"></p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113155240845-8325994.png"></p>
<p>等到验证完成就可以了（如果出现错误，关机重启，重新配置就可以了）</p>
<p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113165243948.png"></p>
<h3 id="五、激活仓库-具体看下一篇"><a href="#五、激活仓库-具体看下一篇" class="headerlink" title="五、激活仓库(具体看下一篇)"></a>五、激活仓库(具体看下一篇)</h3><p><img src="/2022/11/13/Docker%E9%83%A8%E7%BD%B2Drone/image-20221113171114692.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/drone-ci/" rel="tag">drone ci</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-搭建私有的npm仓库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/"
    >搭建私有的npm仓库</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/" class="article-date">
  <time datetime="2022-11-12T05:05:31.000Z" itemprop="datePublished">2022-11-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/npm-yarn/">npm&yarn</a> / <a class="article-category-link" href="/categories/npm-yarn/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/">搭建私有的npm仓库</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="使用docker和verdaccio搭建npm私有库"><a href="#使用docker和verdaccio搭建npm私有库" class="headerlink" title="使用docker和verdaccio搭建npm私有库"></a>使用docker和verdaccio搭建npm私有库</h1><p>本文章docker环境为macos</p>
<h3 id="1-使用-docker-镜像安装verdaccio"><a href="#1-使用-docker-镜像安装verdaccio" class="headerlink" title="1.使用 docker 镜像安装verdaccio"></a>1.使用 docker 镜像安装verdaccio</h3><pre><code class="ini">docker pull verdaccio/verdaccio //安装verdaccio镜像
</code></pre>
<h3 id="2-启动端口映射verdaccio容器"><a href="#2-启动端口映射verdaccio容器" class="headerlink" title="2.启动端口映射verdaccio容器"></a>2.启动端口映射verdaccio容器</h3><pre><code class="ini">docker run -it --name verdaccio -p 4873:4873 verdaccio/verdaccio //运行 verdaccio，使用 docker 命令运行镜像，创建 verdaccio 容器 ，端口4873
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095140709.png"></p>
<h3 id="3-私有部署npm仓库成功"><a href="#3-私有部署npm仓库成功" class="headerlink" title="3.私有部署npm仓库成功"></a>3.私有部署npm仓库成功</h3><p>访问<a target="_blank" rel="noopener" href="http://localhost:4873/">http://localhost:4873/</a></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095258155.png"></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095230480.png"></p>
<h3 id="4-添加权限用户"><a href="#4-添加权限用户" class="headerlink" title="4.添加权限用户"></a>4.添加权限用户</h3><pre><code class="ini">npm adduser --registry http://localhost:4873/ //根据提示添加用户
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095338495.png"></p>
<h3 id="5-登陆"><a href="#5-登陆" class="headerlink" title="5.登陆"></a>5.登陆</h3><p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112095621194.png"></p>
<h3 id="6-发布npm包"><a href="#6-发布npm包" class="headerlink" title="6.发布npm包"></a>6.发布npm包</h3><p>当我们的私有仓库搭建好之后，那么我们就可以向仓库发布npm包了，到我们npm包目录下上传就可以了</p>
<pre><code class="css">1.创建npm-me包目录
2.npm init 初始化目录
3.编写功能文件
4.如果是改版发布，更新版本号
5.登陆私有仓库
6.向私有仓库发布npm包
</code></pre>
<pre><code class="javascript">//ifYes.js
exports.ifYes = function() &#123;
    return &quot;If you&#39;re late, your wages will be docked version new（registry）&quot;
&#125;
</code></pre>
<pre><code class="json">//package.json
&#123;
  &quot;name&quot;: &quot;alan-npm-me&quot;,
  &quot;version&quot;: &quot;1.0.3&quot;,
  &quot;description&quot;: &quot;If you&#39;re late, your wages will be docked&quot;,
  &quot;main&quot;: &quot;ifYes.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [
    &quot;ifYes&quot;
  ],
  &quot;author&quot;: &quot;alan_mf&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<pre><code class="ini">npm version patch  //补丁版本更新
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112101529827.png"></p>
<pre><code class="ini">npm-me % npm publish --registry http://localhost:4873/ //发布
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112102102928.png"></p>
<p>这时候刷新我们的私有仓库页面就可以看到了<a target="_blank" rel="noopener" href="http://localhost:4873/">http://localhost:4873/</a></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112102228314.png"></p>
<h3 id="7-下载私有仓库的包"><a href="#7-下载私有仓库的包" class="headerlink" title="7.下载私有仓库的包"></a>7.下载私有仓库的包</h3><pre><code class="css">1.创建一个文件目录
2.初始化 npm init -y
3.编辑测试代码
4. npm install --registry http://localhost:4873 alan-npm-me //下载私有仓库npm包
5.执行测试代码
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112105324344.png"></p>
<h3 id="8-修改verdaccio权限"><a href="#8-修改verdaccio权限" class="headerlink" title="8.修改verdaccio权限"></a>8.修改verdaccio权限</h3><p>因为我是docker安装的verdaccio，所以查找配置文件路径是这样的</p>
<pre><code class="ini">1. docker exec --user root -it verdaccio sh
2. cd /verdaccio
3. cd conf
4. vi config.yaml
</code></pre>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112125337815.png"></p>
<p><img src="/2022/11/12/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%9A%84npm%E4%BB%93%E5%BA%93/image-20221112125352787.png"></p>
<p>里面就可以配置你们的文件了，重启容器就生效了</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-什么是CI-CD"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/12/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/"
    >什么是CI/CD</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/12/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/" class="article-date">
  <time datetime="2022-11-12T05:05:01.000Z" itemprop="datePublished">2022-11-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CI-CD/">CI/CD</a> / <a class="article-category-link" href="/categories/CI-CD/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/">什么是CI/CD</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="CI-x2F-CD是什么？如何理解持续集成、持续交付和持续部署"><a href="#CI-x2F-CD是什么？如何理解持续集成、持续交付和持续部署" class="headerlink" title="CI&#x2F;CD是什么？如何理解持续集成、持续交付和持续部署"></a>CI&#x2F;CD是什么？如何理解持续集成、持续交付和持续部署</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>CI&#x2F;CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI&#x2F;CD 的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI&#x2F;CD 主要针对在集成新代码时所引发的问题（亦称：”集成地狱”）。</p>
<p>具体而言，CI&#x2F;CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为”CI&#x2F;CD 管道”，由开发和运维团队以敏捷方式协同支持。</p>
<h3 id="CI-是什么？CI-和-CD-有什么区别？"><a href="#CI-是什么？CI-和-CD-有什么区别？" class="headerlink" title="CI 是什么？CI 和 CD 有什么区别？"></a>CI 是什么？CI 和 CD 有什么区别？</h3><p>缩略词 CI &#x2F; CD 具有几个不同的含义。CI&#x2F;CD 中的”CI”始终指持续集成，它属于开发人员的自动化流程。成功的 CI 意味着应用代码的新更改会定期构建、测试并合并到共享存储库中。该解决方案可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题。</p>
<p>CI&#x2F;CD 中的”CD”指的是持续交付和&#x2F;或持续部署，这些相关概念有时会交叉使用。两者都事关管道后续阶段的自动化，但它们有时也会单独使用，用于说明自动化程度。</p>
<p>持续<em>交付</em>通常是指开发人员对应用的更改会自动进行错误测试并上传到存储库（如 GitHub或容器注册表），然后由运维团队将其部署到实时生产环境中。这旨在解决开发和运维团队之间可见性及沟通较差的问题。因此，持续交付的目的就是确保尽可能减少部署新代码时所需的工作量。</p>
<p>持续<em>部署</em>（另一种”CD”）指的是自动将开发人员的更改从存储库发布到生产环境，以供客户使用。它主要为了解决因手动流程降低应用交付速度，从而使运维团队超负荷的问题。持续部署以持续交付的优势为根基，实现了管道后续阶段的自动化。</p>
<p><img src="/2022/11/12/%E4%BB%80%E4%B9%88%E6%98%AFCI-CD/ci-cd-flow-desktop_edited_0.png" alt="CI/CD flow"></p>
<p>CI&#x2F;CD 既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这三项构成的关联环节。更为复杂的是，有时”持续交付”也包含了持续部署流程。</p>
<p>归根结底，我们没必要纠结于这些语义，您只需记得 CI&#x2F;CD 其实就是一个流程（通常形象地表述为管道），用于实现应用开发中的高度持续自动化和持续监控。因案例而异，该术语的具体含义取决于 CI&#x2F;CD 管道的自动化程度。许多企业最开始先添加 CI，然后逐步实现交付和部署的自动化（例如作为云原生应用的一部分）。</p>
<h3 id="CI-持续集成（Continuous-Integration）"><a href="#CI-持续集成（Continuous-Integration）" class="headerlink" title="CI 持续集成（Continuous Integration）"></a>CI 持续集成（Continuous Integration）</h3><p>现代应用开发的目标是让多位开发人员同时处理同一应用的不同功能。但是，如果企业安排在一天内将所有分支源代码合并在一起（称为”合并日”），最终可能造成工作繁琐、耗时，而且需要手动完成。这是因为当一位独立工作的开发人员对应用进行更改时，有可能会与其他开发人员同时进行的更改发生冲突。如果每个开发人员都自定义自己的本地集成开发环境（IDE），而不是让团队就一个基于云的 IDE 达成一致，那么就会让问题更加雪上加霜。</p>
<p>持续集成（CI）可以帮助开发人员更加频繁地（有时甚至每天）将代码更改合并到共享分支或”主干”中。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。这意味着测试内容涵盖了从类和函数到构成整个应用的不同模块。如果自动化测试发现新代码和现有代码之间存在冲突，CI 可以更加轻松地快速修复这些错误。</p>
<h3 id="CD-持续交付（Continuous-Delivery）"><a href="#CD-持续交付（Continuous-Delivery）" class="headerlink" title="CD 持续交付（Continuous Delivery）"></a>CD 持续交付（Continuous Delivery）</h3><p>完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。</p>
<p>在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。</p>
<h3 id="CD-持续部署（Continuous-Deployment）"><a href="#CD-持续部署（Continuous-Deployment）" class="headerlink" title="CD 持续部署（Continuous Deployment）"></a>CD 持续部署（Continuous Deployment）</h3><p>对于一个成熟的 CI&#x2F;CD 管道来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的测试自动化。</p>
<p>实际上，持续部署意味着开发人员对应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI&#x2F;CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。不过，由于还需要编写自动化测试以适应 CI&#x2F;CD 管道中的各种测试和发布阶段，因此前期投资还是会很大。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CI-CD/" rel="tag">CI&#x2F;CD</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-docker入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/11/docker%E5%85%A5%E9%97%A8/"
    >docker入门</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/11/docker%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2022-11-11T04:17:53.000Z" itemprop="datePublished">2022-11-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a> / <a class="article-category-link" href="/categories/Docker/docker%E5%85%A5%E9%97%A8/">docker入门</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="docker入门"><a href="#docker入门" class="headerlink" title="docker入门"></a>docker入门</h1><h3 id="一、docker安装"><a href="#一、docker安装" class="headerlink" title="一、docker安装"></a>一、docker安装</h3><p>目前我们只是基于macos环境下的安装和学习</p>
<p>（很多平台都是windows的）</p>
<h4 id="1-docker下载"><a href="#1-docker下载" class="headerlink" title="1.docker下载"></a>1.docker下载</h4><p>直接去Docker官网去下载对应的版本就可以了（官网地址：<a target="_blank" rel="noopener" href="https://dockerdocs.cn/%EF%BC%89">https://dockerdocs.cn/）</a></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109091347433.png"></p>
<p>选择对应inter芯片或者m1和m2芯片的docker版本就可以</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109091446299.png"></p>
<h4 id="2-设置国内镜像源"><a href="#2-设置国内镜像源" class="headerlink" title="2.设置国内镜像源"></a>2.设置国内镜像源</h4><p>在国内使用docker拉取镜像会非常的慢，所以一定得设置国内镜像源。</p>
<p>设置镜像源在设置里的Docker Engine</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109094123087.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器：点击管理控制台-&gt;登陆账号（淘宝账号）-&gt;右侧镜像工具-&gt;镜像加速器-&gt;拷贝镜像链接</a></p>
<p>网易云加速器：<a target="_blank" rel="noopener" href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></p>
<p>百度云加速器：<a target="_blank" rel="noopener" href="https://mirror.baidubce.com/">https://mirror.baidubce.com</a></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109095852276.png"></p>
<p>配置完成后，查看是否配置成功</p>
<pre><code class="ini">docker info 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109100105080.png"></p>
<p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 Nginx 服务器</p>
<pre><code class="ini">docker run -d -p 80:80 --name webserver nginx
</code></pre>
<p>服务运行后，可以访问 <a target="_blank" rel="noopener" href="http://localhost,如果看到了/">http://localhost，如果看到了</a> “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109101903810.png"></p>
<pre><code class="ini">docker ps -a //查看所有的容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102114729.png"></p>
<pre><code class="ini">docker stop webserver //停止容器服务
docker rm webserver //删除容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102355610.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109102417586.png"></p>
<h3 id="二、docker镜像"><a href="#二、docker镜像" class="headerlink" title="二、docker镜像"></a>二、docker镜像</h3><h4 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1.获取镜像"></a>1.获取镜像</h4><p><a target="_blank" rel="noopener" href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p>
<pre><code class="ini">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] //获取镜像命令格式
docker pull ubuntu:18.04 //具体一点
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103151217.png"></p>
<p>查看下载镜像</p>
<pre><code class="ini">docker images -a //查看所有镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103328637.png"></p>
<p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p>
<pre><code class="ini">docker run -it --rm ubuntu:18.04 bash
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109103803885.png"></p>
<p><code>docker run</code> 就是运行容器的命令，具体格式我们会在容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p>
<p>最后我们通过 <code>exit</code> 退出了这个容器。</p>
<h4 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2.列出镜像"></a>2.列出镜像</h4><pre><code class="ini">docker image ls //列出所有下载的镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109104611497.png"></p>
<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<p><code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<pre><code class="ini">docker system df //便捷的查看镜像、容器、数据卷所占用的空间
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109104851278.png" alt="image-20221109104851278"></p>
<pre><code class="ini">docker image ls ubuntu //列出部分镜像
docker image ls ubuntu:18.04 //列出特定的某个镜像，也就是说指定仓库名和标签
</code></pre>
<p>docker image ls<code>还支持强大的过滤器参数</code>–filter<code>，或者简写 </code>-f，之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>nginx</code> 之后建立的镜像，可以用下面的命令：</p>
<pre><code class="ini">docker image ls -f since=nginx
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105424883.png"></p>
<p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可</p>
<pre><code class="ini">docker image ls -q //以特定格式显示
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105634317.png"></p>
<pre><code class="ini">docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot; //直接列出镜像结果，并且只包含镜像ID和仓库名
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109105755189.png"></p>
<pre><code class="ini">docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot; //以表格等距显示，并且有标题行，和默认一样，不过自己定义列
</code></pre>
<h4 id="3-删除镜像"><a href="#3-删除镜像" class="headerlink" title="3.删除镜像"></a>3.删除镜像</h4><pre><code class="ini">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] //删除镜像命令格式
</code></pre>
<p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code></p>
<p>我们先列出我们下载的所有镜像</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109110129824.png"></p>
<pre><code class="ini">docker image rm afb //删除redis镜像
docker image ls //查看所有镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221109110407331.png"></p>
<p>发现已经删除了指定镜像</p>
<pre><code class="ini">docker image rm $(docker image ls -q redis) //组合命令使用
</code></pre>
<p>充分利用你的想象力和 Linux 命令行的强大</p>
<h3 id="三、docker容器"><a href="#三、docker容器" class="headerlink" title="三、docker容器"></a>三、docker容器</h3><h4 id="1-启动容器"><a href="#1-启动容器" class="headerlink" title="1.启动容器"></a>1.启动容器</h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<pre><code class="ini">docker run ubuntu:18.04 /bin/echo &#39;Hello world&#39; //执行后命令后终止容器
</code></pre>
<pre><code class="ini">docker run -t -i ubuntu:18.04 /bin/bash //保持交互
</code></pre>
<p><code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110081411097.png"></p>
<p>Docker run创建容器时，docker的标准操作</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 registry下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<pre><code class="ini">docker start 9a115164bf87//启动一个终止（exited）的容器
</code></pre>
<pre><code class="ini">docker ps -a//查看所有容器信息
docker logs 9a115164bf87//获取容器输出信息
</code></pre>
<h4 id="2-终止容器"><a href="#2-终止容器" class="headerlink" title="2.终止容器"></a>2.终止容器</h4><pre><code class="ini">docker stop (ID) //终止容器
docker ps //查看启动容器
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110083759963.png"></p>
<h4 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3.进入容器"></a>3.进入容器</h4><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台</p>
<p><code>docker attach</code> 命令或 <code>docker exec</code> 命令都可以进入容器，推荐大家使用 <code>docker exec</code> 命令</p>
<pre><code class="ini">docker attach (ID) //会导致容器的终止
</code></pre>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符</p>
<pre><code class="ini">docker exec -i 4e56f70383c9 /bin/bash 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110084917152.png"></p>
<pre><code class="ini">docker exec -it 4e56f70383c9 /bin/bash //不会导致容器的终止
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110085014483.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110085250397.png"></p>
<pre><code class="ini">docker exec --help //查看更多参数
</code></pre>
<h4 id="4-导入和导出"><a href="#4-导入和导出" class="headerlink" title="4.导入和导出"></a>4.导入和导出</h4><pre><code class="ini">docker export 4e56f70383c9 &gt; ubuntu.tar //导出容器快照到本地文件
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110090757653.png"></p>
<pre><code class="ini">cat nginx.tar | docker import - test/nginx //从容器快照文件中再导入为镜像
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110092840790.png"></p>
<p>用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<h4 id="5-删除容器"><a href="#5-删除容器" class="headerlink" title="5.删除容器"></a>5.删除容器</h4><pre><code class="ini">docker rm (ID or Name) //删除一个处于终止状态的容器
</code></pre>
<p>删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器</p>
<pre><code class="ini">sudo docker rm $(sudo docker ps -a -q) //删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了）
</code></pre>
<h3 id="四、访问仓库"><a href="#四、访问仓库" class="headerlink" title="四、访问仓库"></a>四、访问仓库</h3><h4 id="1-Docker-Hub"><a href="#1-Docker-Hub" class="headerlink" title="1.Docker Hub"></a>1.Docker Hub</h4><p>Docker 官方维护了一个公共仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 <a target="_blank" rel="noopener" href="https://hub.docker.com/search/?type=image">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<p>注册一个docker账号</p>
<blockquote>
<p>在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号</p>
</blockquote>
<p>登陆</p>
<blockquote>
<p>1.可以在docker App上登陆dockr账号（会跳转到 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> ）</p>
<p>2.通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <code>docker logout</code> 退出登录。</p>
</blockquote>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110094750263.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110094815601.png"></p>
<p>拉取镜像</p>
<blockquote>
<p>可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地</p>
</blockquote>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110095756575.png"></p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110095822481.png"></p>
<p>推送镜像</p>
<blockquote>
<p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub</p>
</blockquote>
<pre><code class="ini">docker tag ubuntu:18.04 username/ubuntu:18.04 //username 请替换为你的 Docker 账号用户名
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110100404351.png"></p>
<p>自动化构建</p>
<p>自动构建（<code>Automated Builds</code>）可以自动触发构建镜像，方便升级镜像。</p>
<p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p>
<p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a target="_blank" rel="noopener" href="https://github.com/">GitHub</a> 或 <a target="_blank" rel="noopener" href="https://bitbucket.org/">BitBucket</a>）上的项目，一旦项目发生新的提交 （<code>commit</code>）或者创建了新的标签（<code>tag</code>），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动构建，包括如下的步骤：</p>
<p>- </p>
<p>  登录 Docker Hub；</p>
<p>- </p>
<p>  在 Docker Hub 点击右上角头像，在账号设置（<code>Account Settings</code>）中关联（<code>Linked Accounts</code>）目标网站；</p>
<p>- </p>
<p>  在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</p>
<p>- </p>
<p>  选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</p>
<p>- </p>
<p>  指定 <code>Dockerfile</code> 的位置，并保存。</p>
<p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p>
<p>（‼️这个需要付钱）</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110101243394.png"></p>
<h4 id="2-私有仓库"><a href="#2-私有仓库" class="headerlink" title="2.私有仓库"></a>2.私有仓库</h4><p>安装运行 docker-registry</p>
<pre><code class="ini">docker run -d -p 5000:5000 --restart=always --name registry registry //使用官方 registry 镜像来运行
</code></pre>
<p>如果报错端口不可用</p>
<pre><code class="ini">docker run -d -p 8080:8080 --restart=always --name registry registry //删除原来容器，重新创建
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110104412354.png"></p>
<p>在私有仓库上传、搜索、下载镜像</p>
<pre><code class="ini">docker tag ubuntu:latest alan0924/ubuntu:latest //将 ubuntu:latest 这个镜像标记为 alan0924/ubuntu:latest
docker image ls //查看所有镜像
docker push alan0924/ubuntu:latest //上传私有仓库
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110105039054.png"></p>
<p>删除已有镜像，再尝试从私有仓库中下载这个镜像</p>
<pre><code class="ini">docker image rm alan0924/ubuntu:latest
docker image ls
docker pull  alan0924/ubuntu:latest
docker image ls 
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110110006213.png"></p>
<p>这是我们docker的私有仓库</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110111655879.png"></p>
<h3 id="五、数据管理"><a href="#五、数据管理" class="headerlink" title="五、数据管理"></a>五、数据管理</h3><h4 id="1-数据卷"><a href="#1-数据卷" class="headerlink" title="1.数据卷"></a>1.数据卷</h4><pre><code class="ini">docker volume create my-vol //创建一个数据卷
docker volume ls //查看所有的数据卷
docker volume inspect my-vol //主机里使用以下命令可以查看指定 数据卷 的信息
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110163653187.png"></p>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<pre><code class="ini">//启动一个挂载数据卷的容器
docker run -d -P \
    --name web \
    --mount source=my-vol,target=/usr/share/nginx/html \
    nginx:alpine
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164146345.png"></p>
<pre><code class="ini">docker inspect web //查看数据卷的具体信息
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164302235.png"></p>
<pre><code class="ini">docker volume rm my-vol //删除数据卷
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221110164601907.png"></p>
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令</p>
<p>无主的数据卷可能会占据很多空间,要清理请使用以下命令</p>
<pre><code class="ini">docker volume prune
</code></pre>
<h3 id="六、访问网络"><a href="#六、访问网络" class="headerlink" title="六、访问网络"></a>六、访问网络</h3><h4 id="1-外部访问容器"><a href="#1-外部访问容器" class="headerlink" title="1.外部访问容器"></a>1.外部访问容器</h4><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker ps</code> 可以看到，本地主机的 55000 被映射到了容器的 80 端口。此时访问本机的 55000 端口即可访问容器内 NGINX 默认页面。</p>
<pre><code class="ini">docker run -d -P nginx:alpine // 
docker logs 75bbd0b01745 //查看日志
</code></pre>
<p>-p<code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。</code> </p>
<p> <code>支持的格式有 </code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</p>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111102609943.png"></p>
<p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p>
<pre><code class="ini">docker run -d -p 80:80 nginx:alpine //映射所有接口地址,此时默认会绑定本地所有接口上的所有地址。
</code></pre>
<p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<pre><code class="ini">docker run -d -p 127.0.0.1:80:80 nginx:alpine //映射到指定地址的指定端口,
</code></pre>
<p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<pre><code class="ini">docker run -d -p 127.0.0.1::80 nginx:alpine //映射到指定地址的任意端口
</code></pre>
<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<pre><code class="ini">docker run -d -p 127.0.0.1:80:80/udp nginx:alpine 
</code></pre>
<p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<pre><code class="ini">docker port 75b 80 //查看映射端口配置
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111103203892.png"></p>
<ul>
<li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li>
<li><code>-p</code> 标记可以多次使用来绑定多个端口</li>
</ul>
<pre><code class="ini">docker run -d \
    -p 80:80 \
    -p 443:443 \
    nginx:alpine
</code></pre>
<h4 id="2-容器互联"><a href="#2-容器互联" class="headerlink" title="2.容器互联"></a>2.容器互联</h4><p>新建网络</p>
<pre><code class="ini">docker network create -d bridge my-net //创建一个新的 Docker 网络
</code></pre>
<p>连接容器</p>
<pre><code class="ini">docker run -it --rm --name busybox1 --network my-net busybox sh //运行一个容器并连接到新建的 my-net 网络
</code></pre>
<pre><code class="ini">docker run -it --rm --name busybox2 --network my-net busybox sh //打开新的终端，再运行一个容器并加入到 my-net 网络
</code></pre>
<pre><code class="ini">docker ps //再打开一个新的终端查看容器信息
</code></pre>
<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<pre><code class="ini">/ # ping busybox2
PING busybox2 (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms
64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms
</code></pre>
<p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code></p>
<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到</p>
<pre><code class="ini">/ # ping busybox1
PING busybox1 (172.19.0.2): 56 data bytes
64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms
64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111104242497.png"></p>
<p><code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<h3 id="七、Docker-Compose"><a href="#七、Docker-Compose" class="headerlink" title="七、Docker Compose"></a>七、Docker Compose</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p><code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用</p>
<pre><code class="ini">docker-compose --version
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111110532499.png"></p>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><ul>
<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</li>
</ul>
<p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p>
<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p>
<pre><code class="python">//app.py
from flask import Flask
from redis import Redis

app = Flask(__name__)
redis = Redis(host=&#39;redis&#39;, port=6379)

@app.route(&#39;/&#39;)
def hello():
    count = redis.incr(&#39;hits&#39;)
    return &#39;Hello World! 该页面已被访问 &#123;&#125; 次。\n&#39;.format(count)

if __name__ == &quot;__main__&quot;:
    app.run(host=&quot;0.0.0.0&quot;, debug=True)
</code></pre>
<pre><code class="javascript">//docker-compose.yml
version: &#39;3&#39;
services:

  web:
    build: .
    ports:
     - &quot;5500:5500&quot;

  redis:
    image: &quot;redis:alpine&quot;
</code></pre>
<pre><code class="javascript">//Dockerfile
FROM python:3.6-alpine
ADD . /code
WORKDIR /code
RUN pip install redis flask
CMD [&quot;python&quot;, &quot;app.py&quot;]
</code></pre>
<p><img src="/2022/11/11/docker%E5%85%A5%E9%97%A8/image-20221111112418983.png"></p>
<pre><code class="ini">docker-compose up //运行 compose 项目
</code></pre>
<p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>
<h4 id="3-命令说明"><a href="#3-命令说明" class="headerlink" title="3.命令说明"></a>3.命令说明</h4><p>命令对象与格式</p>
<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<p>docker-compose [-f&#x3D;<arg>…] [options] [COMMAND] [ARGS…]</p>
<p>命令选项</p>
<p>- </p>
<p>  <code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</p>
<p>- </p>
<p>  <code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</p>
<p>- </p>
<p>  <code>--verbose</code> 输出更多调试信息。</p>
<p>- </p>
<p>  <code>-v, --version</code> 打印版本并退出。</p>
<p>命令使用说明</p>
<p><code>build</code></p>
<p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>
<p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p>
<p>选项包括：</p>
<ul>
<li><code>--force-rm</code> 删除构建过程中的临时容器。</li>
<li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li>
<li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li>
</ul>
<p><code>config</code></p>
<p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<p><code>down</code></p>
<p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p>
<p><code>exec</code></p>
<p>进入指定的容器。</p>
<p><code>help</code></p>
<p>获得一个命令的帮助。</p>
<p><code>images</code></p>
<p>列出 Compose 文件中包含的镜像。</p>
<p><code>kill</code></p>
<p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p>
<p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p>
<p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p>
<pre><code class="ini">docker-compose kill -s SIGINT
</code></pre>
<p><code>logs</code></p>
<p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p>
<p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p>
<p>该命令在调试问题的时候十分有用。</p>
<p><code>pause</code></p>
<p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p>
<p>暂停一个服务容器。</p>
<p><code>port</code></p>
<p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p>
<p>打印某个容器端口所映射的公共端口。</p>
<p>选项：</p>
<ul>
<li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li>
<li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li>
</ul>
<p><code>ps</code></p>
<p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<p><code>pull</code></p>
<p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p>
<p>拉取服务依赖的镜像。</p>
<p>选项：</p>
<ul>
<li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li>
</ul>
<p><code>push</code></p>
<p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<p><code>restart</code></p>
<p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<p><code>rm</code></p>
<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<p><code>run</code></p>
<p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p>
<p>在指定服务上执行一个命令。</p>
<p>例如：</p>
<pre><code class="ini">docker-compose run ubuntu ping docker.com
</code></pre>
<p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<ul>
<li>给定命令将会覆盖原有的自动运行命令；</li>
<li>不会自动创建端口，以避免冲突。</li>
</ul>
<p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p>
<pre><code class="ini">docker-compose run --no-deps web python manage.py shell
</code></pre>
<p>将不会启动 web 容器所关联的其它容器。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 后台运行容器。</li>
<li><code>--name NAME</code> 为容器指定一个名字。</li>
<li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li>
<li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li>
<li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li>
<li><code>--no-deps</code> 不自动启动关联的服务容器。</li>
<li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li>
<li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li>
<li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li>
<li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li>
</ul>
<p><code>scale</code></p>
<p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p>
<p>设置指定服务运行的容器个数。</p>
<p>通过 <code>service=num</code> 的参数来设置数量。例如：</p>
<pre><code class="ini">docker-compose scale web=3 db=2
</code></pre>
<p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p>
<p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>start</code></p>
<p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<p><code>stop</code></p>
<p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>top</code></p>
<p>查看各个服务容器内运行的进程。</p>
<p><code>unpause</code></p>
<p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<p><code>up</code></p>
<p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
<p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 在后台运行服务容器。</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像。</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<p><code>version</code></p>
<p>格式为 <code>docker-compose version</code>。</p>
<p>打印版本信息。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-表白爱心biu"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/11/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/"
    >表白爱心biu</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/11/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/" class="article-date">
  <time datetime="2022-11-11T01:57:54.000Z" itemprop="datePublished">2022-11-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/">趣味技术</a> / <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/">表白爱心biu</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="爱心代码（canvas）"><a href="#爱心代码（canvas）" class="headerlink" title="爱心代码（canvas）"></a>爱心代码（canvas）</h1><p>每天浪漫一点点</p>
<p>发给你女朋友，有奖励🥳</p>
<p><img src="/2022/11/11/%E8%A1%A8%E7%99%BD%E7%88%B1%E5%BF%83biu/image-20221111095138378.png"></p>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;玥小公主爱心&lt;/title&gt;

    &lt;style&gt;
      html,
      body &#123;
        height: 100%;
        padding: 0;
        margin: 0;
        background: #000;
      &#125;
      canvas &#123;
        width: 100%;
        height: 100%;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&quot;pinkboard&quot;&gt;&lt;/canvas&gt;
    &lt;script&gt;
      /*
       * 参数配置
       */
      var settings = &#123;
        particles: &#123;
          length: 500, // 最大颗粒量
          duration: 2, // 粒子持续时间（秒）
          velocity: 110, // 粒子范围（像素/秒）
          effect: -1.0, // 内轮廓
          size: 35, // 颗粒大小（像素）
        &#125;,
      &#125;;

      /*
       * Point class
       */
      var Point = (function () &#123;
        function Point(x, y) &#123;
          this.x = typeof x !== &quot;undefined&quot; ? x : 0;
          this.y = typeof y !== &quot;undefined&quot; ? y : 0;
        &#125;
        Point.prototype.clone = function () &#123;
          return new Point(this.x, this.y);
        &#125;;
        Point.prototype.length = function (length) &#123;
          if (typeof length == &quot;undefined&quot;)
            return Math.sqrt(this.x * this.x + this.y * this.y);
          this.normalize();
          this.x *= length;
          this.y *= length;
          return this;
        &#125;;
        Point.prototype.normalize = function () &#123;
          var length = this.length();
          this.x /= length;
          this.y /= length;
          return this;
        &#125;;
        return Point;
      &#125;)();

      /*
       * Particle class
       */
      var Particle = (function () &#123;
        function Particle() &#123;
          this.position = new Point();
          this.velocity = new Point();
          this.acceleration = new Point();
          this.age = 0;
        &#125;
        Particle.prototype.initialize = function (x, y, dx, dy) &#123;
          this.position.x = x;
          this.position.y = y;
          this.velocity.x = dx;
          this.velocity.y = dy;
          this.acceleration.x = dx * settings.particles.effect;
          this.acceleration.y = dy * settings.particles.effect;
          this.age = 0;
        &#125;;
        Particle.prototype.update = function (deltaTime) &#123;
          this.position.x += this.velocity.x * deltaTime;
          this.position.y += this.velocity.y * deltaTime;
          this.velocity.x += this.acceleration.x * deltaTime;
          this.velocity.y += this.acceleration.y * deltaTime;
          this.age += deltaTime;
        &#125;;
        Particle.prototype.draw = function (context, image) &#123;
          function ease(t) &#123;
            return --t * t * t + 1;
          &#125;
          var size = image.width * ease(this.age / settings.particles.duration);
          context.globalAlpha = 1 - this.age / settings.particles.duration;
          context.drawImage(
            image,
            this.position.x - size / 2,
            this.position.y - size / 2,
            size,
            size
          );
        &#125;;
        return Particle;
      &#125;)();

      /*
       * ParticlePool class
       */
      var ParticlePool = (function () &#123;
        var particles,
          firstActive = 0,
          firstFree = 0,
          duration = settings.particles.duration;

        function ParticlePool(length) &#123;
          // create and populate particle pool
          particles = new Array(length);
          for (var i = 0; i &lt; particles.length; i++)
            particles[i] = new Particle();
        &#125;
        ParticlePool.prototype.add = function (x, y, dx, dy) &#123;
          particles[firstFree].initialize(x, y, dx, dy);

          // handle circular queue
          firstFree++;
          if (firstFree == particles.length) firstFree = 0;
          if (firstActive == firstFree) firstActive++;
          if (firstActive == particles.length) firstActive = 0;
        &#125;;
        ParticlePool.prototype.update = function (deltaTime) &#123;
          var i;

          // update active particles
          if (firstActive &lt; firstFree) &#123;
            for (i = firstActive; i &lt; firstFree; i++)
              particles[i].update(deltaTime);
          &#125;
          if (firstFree &lt; firstActive) &#123;
            for (i = firstActive; i &lt; particles.length; i++)
              particles[i].update(deltaTime);
            for (i = 0; i &lt; firstFree; i++) particles[i].update(deltaTime);
          &#125;

          // remove inactive particles
          while (
            particles[firstActive].age &gt;= duration &amp;&amp;
            firstActive != firstFree
          ) &#123;
            firstActive++;
            if (firstActive == particles.length) firstActive = 0;
          &#125;
        &#125;;
        ParticlePool.prototype.draw = function (context, image) &#123;
          // draw active particles
          if (firstActive &lt; firstFree) &#123;
            for (i = firstActive; i &lt; firstFree; i++)
              particles[i].draw(context, image);
          &#125;
          if (firstFree &lt; firstActive) &#123;
            for (i = firstActive; i &lt; particles.length; i++)
              particles[i].draw(context, image);
            for (i = 0; i &lt; firstFree; i++) particles[i].draw(context, image);
          &#125;
        &#125;;
        return ParticlePool;
      &#125;)();

      /*
       * Putting it all together
       */
      (function (canvas) &#123;
        var context = canvas.getContext(&quot;2d&quot;),
          particles = new ParticlePool(settings.particles.length),
          particleRate =
            settings.particles.length / settings.particles.duration, // particles/sec
          time;

        // get point on heart with -PI &lt;= t &lt;= PI
        function pointOnHeart(t) &#123;
          return new Point(
            160 * Math.pow(Math.sin(t), 3),
            130 * Math.cos(t) -
              50 * Math.cos(2 * t) -
              20 * Math.cos(3 * t) -
              10 * Math.cos(4 * t) +
              25
          );
        &#125;

        // 使用虚拟画布创建粒子图像
        var image = (function () &#123;
          var canvas = document.createElement(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;);
          canvas.width = settings.particles.size;
          canvas.height = settings.particles.size;
          // helper function to create the path
          function to(t) &#123;
            var point = pointOnHeart(t);
            point.x =
              settings.particles.size / 2 +
              (point.x * settings.particles.size) / 450;
            point.y =
              settings.particles.size / 2 -
              (point.y * settings.particles.size) / 450;
            return point;
          &#125;
          // create the path
          context.beginPath();
          var t = -Math.PI;
          var point = to(t);
          context.moveTo(point.x, point.y);
          while (t &lt; Math.PI) &#123;
            t += 0.03; // baby steps!
            point = to(t);
            context.lineTo(point.x, point.y);
          &#125;
          context.closePath();
          // create the fill （更换爱心颜色）
          context.fillStyle = &quot;#ea80b0&quot;;
          context.fill();
          // create the image
          var image = new Image();
          image.src = canvas.toDataURL();
          return image;
        &#125;)();

        // render that thing!
        function render() &#123;
          // next animation frame
          requestAnimationFrame(render);

          // update time（粒子速度）
          var newTime = new Date().getTime() / 1000,
            deltaTime = newTime - (time || newTime);
          time = newTime;

          // clear canvas
          context.clearRect(0, 0, canvas.width, canvas.height);

          // create new particles
          var amount = particleRate * deltaTime;
          for (var i = 0; i &lt; amount; i++) &#123;
            var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
            var dir = pos.clone().length(settings.particles.velocity);
            particles.add(
              canvas.width / 2 + pos.x,
              canvas.height / 2 - pos.y,
              dir.x,
              -dir.y
            );
          &#125;

          // update and draw particles
          particles.update(deltaTime);
          particles.draw(context, image);
        &#125;

        // handle (re-)sizing of the canvas
        function onResize() &#123;
          canvas.width = canvas.clientWidth;
          canvas.height = canvas.clientHeight;
        &#125;
        window.onresize = onResize;

        // delay rendering bootstrap
        setTimeout(function () &#123;
          onResize();
          render();
        &#125;, 10);
      &#125;)(document.getElementById(&quot;pinkboard&quot;));
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%AA%E6%BC%AB%E4%BB%A3%E7%A0%81/" rel="tag">浪漫代码</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何上传npm包"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/"
    >如何上传npm包</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/" class="article-date">
  <time datetime="2022-11-10T07:43:07.000Z" itemprop="datePublished">2022-11-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/npm-yarn/">npm&yarn</a> / <a class="article-category-link" href="/categories/npm-yarn/%E4%B8%8A%E4%BC%A0%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85/">上传自己的npm包</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="如何上传自己的npm包"><a href="#如何上传自己的npm包" class="headerlink" title="如何上传自己的npm包"></a>如何上传自己的npm包</h1><h3 id="一、创建自己的npm账号"><a href="#一、创建自己的npm账号" class="headerlink" title="一、创建自己的npm账号"></a>一、创建自己的npm账号</h3><p>[npm官网]: 	“<a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
<h3 id="二、创建npm包目录"><a href="#二、创建npm包目录" class="headerlink" title="二、创建npm包目录"></a>二、创建npm包目录</h3><pre><code class="ini">mkdir npm-me // 在终端输入以下命令，npm-me为包的目录，可以自己任意取名
cd npm-me // 进入包目录
</code></pre>
<h3 id="三、-编写模块"><a href="#三、-编写模块" class="headerlink" title="三、 编写模块"></a>三、 编写模块</h3><p>在npm-me目录下创建 ifYes.js文件</p>
<pre><code class="javascript">//ifYes.js
exports.ifYes = function() &#123;
    return &quot;If you&#39;re late, your wages will be docked&quot;
&#125;
</code></pre>
<h3 id="四、-初始化包描述文件"><a href="#四、-初始化包描述文件" class="headerlink" title="四、 初始化包描述文件"></a>四、 初始化包描述文件</h3><pre><code class="ini">npm init //初始化会生成package.json文件
</code></pre>
<p>初始化的过程会出现一系列的问题，根据我们自己的情况去选择就可以，如果没有其他要求，回车就可哟</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110143318339.png"></p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110143450471.png"></p>
<h3 id="五、注册包仓库账号"><a href="#五、注册包仓库账号" class="headerlink" title="五、注册包仓库账号"></a>五、注册包仓库账号</h3><pre><code class="ini">npm adduser
</code></pre>
<p>当你没有创建npm账户或者输入错误的账户和密码，都会出现下面的error</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110143800873.png"></p>
<p>这是处理正确的结果（确认的时候需要接收验证码：例30466554）</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110144117450.png"></p>
<h3 id="六、上传包"><a href="#六、上传包" class="headerlink" title="六、上传包"></a>六、上传包</h3><pre><code class="ini">npm publish 包文件夹名字 //上传npm命令格式
</code></pre>
<p>1.为了不出现npm命名冲突，第一个方法是在npm官网查一下，如果重复就需要重新修改一下（现在我的npm包就冲突了）</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110144658634.png"></p>
<p>2.当你上传npm包的时候可能才会发现npm命名冲突</p>
<pre><code class="ini">npm publish . //上传npm包
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110145002168.png"></p>
<p>修改后上传</p>
<pre><code class="javascript">//package.json
&#123;
  &quot;name&quot;: &quot;alan-npm-me&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;If you&#39;re late, your wages will be docked&quot;,
  &quot;main&quot;: &quot;ifYes.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [
    &quot;ifYes&quot;
  ],
  &quot;author&quot;: &quot;alan_mf&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110145126857.png"></p>
<p>上传成功啦啦啦</p>
<p>npm账户上可以看到我们上传的包</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110151414170.png"></p>
<h3 id="七、-更新npm包"><a href="#七、-更新npm包" class="headerlink" title="七、 更新npm包"></a>七、 更新npm包</h3><p>npm包修改后，手动把package.json里的version版本号修改了，或者使用以下命令自动更新版本号，再执行npm publish . 命令就可以了。</p>
<ul>
<li>升级补丁版本号(修改bug)：npm version patch</li>
<li>升级小版本号(新增功能)：npm version minor</li>
<li>升级大版本号(较大改版)：npm version major</li>
</ul>
<pre><code class="ini">npm version patch //补丁
npm publish . //更新npm包
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110151715232.png"></p>
<p>更新成功版本1.0.1</p>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110151928908.png"></p>
<h3 id="八、-对上传的npm进行测试"><a href="#八、-对上传的npm进行测试" class="headerlink" title="八、 对上传的npm进行测试"></a>八、 对上传的npm进行测试</h3><pre><code class="ini">mkdir npm-me-test //新建目录
cd  npm-me-test //进入目录
</code></pre>
<p>下载我们上传的npm包</p>
<pre><code class="ini">npm init -y //初始化生成package.json文件
npm install alan-npm-me -D
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110153117681.png"></p>
<p>创建test.js文件并编写代码</p>
<pre><code class="javascript">//test.js
const demo = require(&#39;alan-npm-me&#39;);
const res = demo.ifYes();
console.log(res);
</code></pre>
<p><img src="/2022/11/10/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0npm%E5%8C%85/image-20221110153427301.png"></p>
<p>目前我们所开发的都是共享的npm包，具有一定的安全性风险，如果用于企业，就会具有一定的风险。企业的限制在于，一方面需要享受模块开发带来的低耦合和项目组织上的好处，另一方面却要考虑到模块保密性的问题。所以，通过NPM共享和发布存在潜在的风险。</p>
<p>为了同时能够享受到NPM上众多的包，同时对自己的包进行保密和限制，现有的解决方案就是企业搭建自己的NPM仓库。局域NPM仓库的搭建方法与搭建镜像站的方式几乎一样，与镜像仓库不同的地方在于，企业局域NPM可以选择不同步官方源仓库中的包，即企业可混合使用官方仓库和局域仓库。</p>
<p>对于企业内部而言，私有的可重用模块可以打包到局域NPM仓库中，这样可以保持更新的中心化，不至于让各个小项目各自维护相同功能的模块，杜绝通过复制粘贴实现代码共享的行为。</p>
<p>链接：</p>
<p>[npm官网]: 	“<a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-yarn命令详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/09/yarn%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"
    >yarn命令详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/09/yarn%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-11-09T07:09:37.000Z" itemprop="datePublished">2022-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/npm-yarn/">npm&yarn</a> / <a class="article-category-link" href="/categories/npm-yarn/yarn%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">yarn常用命令</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="yarn命令详解"><a href="#yarn命令详解" class="headerlink" title="yarn命令详解"></a>yarn命令详解</h1><h3 id="一、yarn安装初始化"><a href="#一、yarn安装初始化" class="headerlink" title="一、yarn安装初始化"></a>一、yarn安装初始化</h3><pre><code class="css">npm i yarn -g #yarn安装
yarn -v #查看版本
yarn init ｜ yarn #初始化，创建package.json文件
yarn init --yes #简写 -y 跳过会话，直接通过默认值生成 package.json
</code></pre>
<h3 id="二、yarn安装依赖"><a href="#二、yarn安装依赖" class="headerlink" title="二、yarn安装依赖"></a>二、yarn安装依赖</h3><pre><code class="css">yarn add webpack@2.3.3 # yarn --save 是 yarn 默认的，默认记录在 package.json dependencies 中
</code></pre>
<pre><code class="css">yarn add webpack --dev # yarn 简写 -D  devDependencies 中
</code></pre>
<pre><code class="css">yarn global add webpack # yarn 安装全局依赖
</code></pre>
<h3 id="三、yarn更新依赖"><a href="#三、yarn更新依赖" class="headerlink" title="三、yarn更新依赖"></a>三、yarn更新依赖</h3><pre><code class="css">yarn upgrade # 升级所有依赖项，不记录在 package.json 中
yarn upgrade webpack # 升级指定包
yarn upgrade --latest # 忽略版本规则，升级到最新版本，并且更新 package.json
</code></pre>
<h3 id="四、yarn移除依赖"><a href="#四、yarn移除依赖" class="headerlink" title="四、yarn移除依赖"></a>四、yarn移除依赖</h3><pre><code class="css">yarn remove webpack # yarn
</code></pre>
<h3 id="五、其他命令"><a href="#五、其他命令" class="headerlink" title="五、其他命令"></a>五、其他命令</h3><pre><code class="css">yarn install # 或者 yarn 在 node_modules 目录安装 package.json 中列出的所有依赖
yarn install --force # 强制下载安装
yarn start # yarn  执行 scripts 下 start 对应的脚本

###用来查看某个模块的最新版本信息
yarn info webpack # yarn
yarn info webpack --json # 输出 json 格式
yarn info webpack readme # 输出 README 部分

yarn list # 列出当前项目的依赖
yarn list --depth=0 # 限制依赖的深度
sudo yarn global list # 列出全局安装的模块

###yarn配置文件
yarn config set key value # 设置
yarn config get key # 读取值
yarn config delete key # 删除
yarn config list # 显示当前配置
yarn config set registry [https://registry.npm.taobao.org](https://links.jianshu.com/go?to=https%3A%2F%2Fregistry.npm.taobao.org) # 设置淘宝镜像

###缓存
sudo yarn cache list # 列出已缓存的每个包
sudo yarn cache dir # 返回 全局缓存位置
sudo yarn cache clean # 清除缓存
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/yarn/" rel="tag">yarn</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-npm命令详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/09/npm%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"
    >npm命令详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/09/npm%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-11-09T07:09:15.000Z" itemprop="datePublished">2022-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/npm-yarn/">npm&yarn</a> / <a class="article-category-link" href="/categories/npm-yarn/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">npm常用命令</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="npm命令详解"><a href="#npm命令详解" class="headerlink" title="npm命令详解"></a>npm命令详解</h1><h3 id="一、npm配置命令"><a href="#一、npm配置命令" class="headerlink" title="一、npm配置命令"></a>一、npm配置命令</h3><pre><code class="css">npm install -g cnpm --registry=https://registry.npm.taobao.org  #通过cnpm使用淘宝镜像
npm config set registry https://registry.npm.taobao.org #将npm设置为淘宝镜像
npm config set registry https://registry.npmjs.org #切换回默认全局镜像
npm config get registry #查看npm镜像设置
npm config list #查看npm配置
cnpm config list #查看cnpm配置
npm -v #查看npm版本
</code></pre>
<p>方便统一和阅读，文中全部使用简写方式。</p>
<blockquote>
<p>-g： 为 –global 的缩写，表示安装到全局目录里<br>-S： 为 –save 的缩写，表示安装的包将写入package.json里面的dependencies<br>-D： 为 –save-dev 的缩写，表示将安装的包将写入packege.json里面的devDependencies<br> i： 为install的缩写，表示安装</p>
</blockquote>
<h3 id="二、npm安装命令"><a href="#二、npm安装命令" class="headerlink" title="二、npm安装命令"></a>二、npm安装命令</h3><pre><code class="css">npm init  # npm 初始化当前目录
npm i  # 安装所有依赖
npm i express  # 安装模块到默认dependencies
npm i express -g  # 会安装到配置的全局目录下
npm i express -S  # 安装包信息将加入到dependencies生产依赖
npm i express -D  # 安装包信息将加入到devDependencies开发依赖
npm i jquery@1.8.3  # 安装jquery指定的1.8.3版本
</code></pre>
<h3 id="三、npm更新命令"><a href="#三、npm更新命令" class="headerlink" title="三、npm更新命令"></a>三、npm更新命令</h3><pre><code class="css">npm update jquery  # 更新最新版本的jquery
npm update jquery@2.1.0  # 更新到指定版本号的jquery
npm install jquery@latest  # 可以直接更新到最后一个新版本
</code></pre>
<h3 id="四、npm卸载命令"><a href="#四、npm卸载命令" class="headerlink" title="四、npm卸载命令"></a>四、npm卸载命令</h3><pre><code class="css">npm uninstall express  # 卸载模块，但不卸载模块留在package.json中的对应信息
npm uninstall express -g  # 卸载全局模块
npm uninstall express --save  # 卸载模块，同时卸载留在package.json中dependencies下的信息
npm uninstall express --save-dev  # 卸载模块，同时卸载留在package.json中devDependencies下的信息
</code></pre>
<h3 id="五、npm查看命令"><a href="#五、npm查看命令" class="headerlink" title="五、npm查看命令"></a>五、npm查看命令</h3><pre><code class="css">npm root  # 查看项目中模块所在的目录
npm root -g  # 查看全局安装的模块所在目录
npm list 或者 npm ls  # 查看本地已安装模块的清单列表
npm view jquery dependencies  # 查看某个包对于各种包的依赖关系
npm view jquery version  # 查看jquery最新的版本号
npm view jquery versions  # 查看所有jquery历史版本号（很实用）
npm view jquery  # 查看最新的jquery版本的信息
npm info jquery  # 查看jquery的详细信息，等同于上面的npm view jquery
npm list jquery 或 npm ls jquery  # 查看本地已安装的jquery的详细信息
npm view jquery repository.url  # 查看jquery包的来源地址
</code></pre>
<h3 id="六、其他命令"><a href="#六、其他命令" class="headerlink" title="六、其他命令"></a>六、其他命令</h3><pre><code class="css">npm cache clean  # 清除npm的缓存
npm prune  # 清除项目中没有被使用的包
npm outdated  # 检查模块是否已经过时
npm repo jquery  # 会打开默认浏览器跳转到github中jquery的页面
npm docs jquery  # 会打开默认浏览器跳转到github中jquery的README.MD文件信息
npm home jquery  # 会打开默认浏览器跳转到github中jquery的主页
</code></pre>
<h3 id="七、package-json字段"><a href="#七、package-json字段" class="headerlink" title="七、package.json字段"></a>七、package.json字段</h3><p>[package.json字段详解]: 	“<a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json">https://docs.npmjs.com/cli/v8/configuring-npm/package-json</a> “</p>
<h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p>[npm官网]: 	“<a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>