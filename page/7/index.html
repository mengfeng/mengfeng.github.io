<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端面试大全算法篇"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/"
    >前端面试大全算法篇</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/" class="article-date">
  <time datetime="2022-11-05T02:32:27.000Z" itemprop="datePublished">2022-11-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95%E7%AF%87/">算法篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（算法）"><a href="#前端面试题大全（算法）" class="headerlink" title="前端面试题大全（算法）"></a>前端面试题大全（算法）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-算法中时间复杂度，空间复杂度的理解？如何计算？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-算法中时间复杂度，空间复杂度的理解？如何计算？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 算法中时间复杂度，空间复杂度的理解？如何计算？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 算法中时间复杂度，空间复杂度的理解？如何计算？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别</p>
<p>衡量不同算法之间的优劣主要是通过时间和空间两个维度去考量：</p>
<ul>
<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>
<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述</li>
</ul>
<p>通常会遇到一种情况，时间和空间维度不能够兼顾，需要在两者之间取得一个平衡点是我们需要考虑的</p>
<p>一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况</p>
<p>最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差</p>
<h4 id="二、时间复杂度"><a href="#二、时间复杂度" class="headerlink" title="二、时间复杂度"></a>二、时间复杂度</h4><p>时间复杂度是指执行这个算法所需要的计算工作量，其复杂度反映了程序执行时间「随输入规模增长而增长的量级」，在很大程度上能很好地反映出算法的优劣与否</p>
<p>一个算法花费的时间与算法中语句的「执行次数成正比」，执行次数越多，花费的时间就越多</p>
<p>算法的复杂度通常用大O符号表述，定义为<code>T(n) = O(f(n))</code>，常见的时间复杂度有：O(1)常数型、O(log n)对数型、O(n)线性型、O(nlogn)线性对数型、O(n^2)平方型、O(n^3)立方型、O(n^k)k次方型、O(2^n)指数型，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33336435656266302d313666632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>从上述可以看到，随着问题规模<code>n</code>的不断增大，上述时间复杂度不断增大，算法的执行效率越低，由小到大排序如下：</p>
<pre><code class="ini">Ο(1)＜Ο(log n)＜Ο(n)＜Ο(nlog n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n)＜Ο(n!)
</code></pre>
<p>注意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效，如果常数项过大的时候也会导致算法的执行时间变长</p>
<p>关于如何计算时间复杂度，可以看看如下简单例子：</p>
<pre><code class="javascript">function process(n) &#123;
  let a = 1
  let b = 2
  let sum = a + b
  for(let i = 0; i &lt; n; i++) &#123;
    sum += i
  &#125;
  return sum
&#125;
</code></pre>
<p>该函数算法需要执行的运算次数用输入大小<code>n</code>的函数表示，即 <code>T(n) = 2 + n + 1</code>，那么时间复杂度为<code>O(n + 3)</code>，又因为时间复杂度只关注最高数量级，且与之系数也没有关系，因此上述的时间复杂度为<code>O(n)</code></p>
<p>又比如下面的例子：</p>
<pre><code class="javascript">function process(n) &#123;
 let count = 0
  for(let i = 0; i &lt; n; i++)&#123;
    for(let i = 0; i &lt; n; i++)&#123;
      count += 1
    &#125;
  &#125;
&#125;
</code></pre>
<p>循环里面嵌套循环，外面的循环执行一次，里面的循环执行<code>n</code>次，因此时间复杂度为 <code>O(n*n*1 + 2) = O(n^2)</code></p>
<p>对于顺序执行的语句，总的时间复杂度等于其中最大的时间复杂度，如下：</p>
<pre><code class="javascript">function process(n) &#123;
  let sum = 0
  for(let i = 0; i &lt; n; i++) &#123;
    sum += i
  &#125;
  for(let i = 0; i &lt; n; i++)&#123;
    for(let i = 0; i &lt; n; i++)&#123;
      sum += 1
    &#125;
  &#125;
  return sum
&#125;
</code></pre>
<p>上述第一部分复杂度为<code>O(n)</code>，第二部分复杂度为<code>O(n^2)</code>，总复杂度为<code>max(O(n^2), O(n)) = O(n^2)</code></p>
<p>又如下一个例子：</p>
<pre><code class="javascript">function process(n) &#123;
  let i = 1; // ①
  while (i &lt;= n) &#123;
     i = i * 2; // ②
  &#125;
&#125;
</code></pre>
<p>循环语句中以2的倍数来逼近<code>n</code>，每次都乘以2。如果用公式表示就是1 * 2 * 2 * 2 … * 2 &lt;&#x3D;n，也就是说2的<code>x</code>次方小于等于<code>n</code>时会执行循环体，记作<code>2^x &lt;= n</code>，于是得出<code>x&lt;=logn</code></p>
<p>因此循环在执行<code>logn</code>次之后，便结束，因此时间复杂度为<code>O(logn)</code></p>
<p>同理，如果一个<code>O(n)</code>循环里面嵌套<code>O(logn)</code>的循环，则时间复杂度为<code>O(nlogn)</code>，像<code>O(n^3)</code>无非也就是嵌套了三层<code>O(n)</code>循环</p>
<h4 id="三、空间复杂度"><a href="#三、空间复杂度" class="headerlink" title="三、空间复杂度"></a>三、空间复杂度</h4><p>空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量</p>
<p>除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间</p>
<p>下面给出空间复杂度为<code>O(1)</code>的示例，如下</p>
<pre><code class="javascript">let a = 1
let b = 2
let c = 3
</code></pre>
<p>上述代码的临时空间不会随着<code>n</code>的变化而变化，因此空间复杂度为<code>O(1)</code></p>
<pre><code class="javascript">let arr []
for(i=1; i&lt;=n; ++i)&#123;
  arr.push(i)
&#125;
</code></pre>
<p>上述可以看到，随着<code>n</code>的增加，数组的占用的内存空间越大</p>
<p>通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为<code>O(1)</code>，一个一维数组<code>a[n]</code>，空间复杂度<code>O(n)</code>，二维数组为<code>O(n^2)</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对数据结构的理解？有哪些？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对数据结构的理解？有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对数据结构的理解？有哪些？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对数据结构的理解？有哪些？区别？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合</p>
<p>前面讲到，一个程序 &#x3D; 算法 + 数据结构，数据结构是实现算法的基础，选择合适的数据结构可以带来更高的运行或者存储效率</p>
<p>数据元素相互之间的关系称为结构，根据数据元素之间关系的不同特性，通常有如下四类基本的结构：</p>
<ul>
<li>集合结构：该结构的数据元素间的关系是“属于同一个集合”</li>
<li>线性结构：该结构的数据元素之间存在着一对一的关系</li>
<li>树型结构：该结构的数据元素之间存在着一对多的关系</li>
<li>图形结构：该结构的数据元素之间存在着多对多的关系，也称网状结构</li>
</ul>
<p>由于数据结构种类太多，逻辑结构可以再分成为：</p>
<ul>
<li>线性结构：有序数据元素的集合，其中数据元素之间的关系是一对一的关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的</li>
<li>非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生关联</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/c16cd7ef078a9270d5e13a8eca64d7b5469bf5ba3cfa7b88564c0065ba3ba230/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39616564633564302d316161362d313165632d386536342d3931666465633066303561312e706e67"><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39616564633564302d316161362d313165632d386536342d3931666465633066303561312e706e67.png" alt="img"></a></p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的数据结构有如下：</p>
<ul>
<li>数组</li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>树</li>
<li>图</li>
<li>堆</li>
<li>散列表</li>
</ul>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>在程序设计中，为了处理方便， 一般情况把具有相同类型的若干变量按有序的形式组织起来，这些按序排列的同类数据元素的集合称为数组</p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>一种特殊的线性表，只能在某一端插入和删除的特殊线性表，按照先进后出的特性存储数据</p>
<p>先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>跟栈基本一致，也是一种特殊的线性表，其特性是先进先出，只允许在表的前端进行删除操作，而在表的后端进行插入操作</p>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p>
<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成</p>
<p>一般情况，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><p>树是典型的非线性结构，在树的结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个以上的后继结点</p>
<h5 id="图"><a href="#图" class="headerlink" title="图"></a>图</h5><p>一种非线性结构。在图结结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系</p>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆是一种特殊的树形数据结构，每个结点都有一个值，特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆</p>
<h5 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h5><p>若结构中存在关键字和<code>K</code>相等的记录，则必定在<code>f(K)</code>的存储位置上，不需比较便可直接取得所查记录</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>上述的数据结构，之前的区别可以分成线性结构和非线性结构：</p>
<ul>
<li>线性结构有：数组、栈、队列、链表等</li>
<li>非线性结构有：树、图、堆等</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对栈、队列的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对栈、队列的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对栈、队列的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对栈、队列的理解？应用场景？</h3><h4 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h4><p>栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表</p>
<p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p>
<p>所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p>
<p>关于栈的简单实现，如下：</p>
<pre><code class="javascript">class Stack &#123;
  constructor() &#123;
    this.items = [];
  &#125;

  /**
   * 添加一个（或几个）新元素到栈顶
   * @param &#123;*&#125; element 新元素
   */
  push(element) &#123;
    this.items.push(element)
  &#125;

  /**
   * 移除栈顶的元素，同时返回被移除的元素
   */
  pop() &#123;
    return this.items.pop()
  &#125;

  /**
   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）
   */
  peek() &#123;
    return this.items[this.items.length - 1]
  &#125;

  /**
   * 如果栈里没有任何元素就返回true,否则返回false
   */
  isEmpty() &#123;
    return this.items.length === 0
  &#125;

  /**
   * 移除栈里的所有元素
   */
  clear() &#123;
    this.items = []
  &#125;

  /**
   * 返回栈里的元素个数。这个方法和数组的length属性很类似
   */
  size() &#123;
    return this.items.length
  &#125;
&#125;
</code></pre>
<p>关于栈的操作主要的方法如下：</p>
<ul>
<li>push：入栈操作</li>
<li>pop：出栈操作</li>
</ul>
<h4 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h4><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</p>
<p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p>
<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出</p>
<p>简单实现一个队列的方式，如下：</p>
<pre><code>class Queue &#123;
    constructor() &#123;
        this.list = []
        this.frontIndex = 0
        this.tailIndex = 0
    &#125;
    enqueue(item) &#123;
        this.list[this.tailIndex++] = item
    &#125;
    unqueue() &#123;
        const item  = this.list[this.frontIndex]
        this.frontIndex++        
        return item
    &#125;
&#125;
</code></pre>
<p>上述这种入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用</p>
<p>当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作，出该现象称为”假溢”</p>
<p>在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：</p>
<p>无论插入或删除，一旦<code>rear</code>指针增1或<code>front</code>指针增1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置，这种队列也就是循环队列</p>
<p>下面实现一个循环队列，如下：</p>
<pre><code class="javascript">class Queue &#123;
    constructor(size) &#123;
        this.size = size; // 长度需要限制, 来达到空间的利用, 代表空间的长度
        this.list = [];
        this.font = 0; // 指向首元素
        this.rear = 0;  // 指向准备插入元素的位置
    &#125;
    enQueue() &#123;
        if (this.isFull() == true) &#123;
            return false
        &#125;
        this.rear = this.rear % this.k;
        this._data[this.rear++] = value;
        return true
    &#125;
    deQueue() &#123;
        if(this.isEmpty())&#123;
            return false;
        &#125;
        this.font++;
        this.font = this.font % this.k;
        return true;
    &#125;
    isEmpty() &#123;
        return this.font == this.rear - 1;
    &#125;
    isFull() &#123;
        return this.rear % this.k == this.font;
    &#125;
&#125;
</code></pre>
<p>上述通过求余的形式代表首尾指针增1 时超出了所分配的队列空间</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><h5 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h5><p>借助栈的先进后出的特性，可以简单实现一个逆序数处的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p>
<p>包括编译器的在对输入的语法进行分析的时候，例如<code>&quot;()&quot;</code>、<code>&quot;&#123;&#125;&quot;</code>、<code>&quot;[]&quot;</code>这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>
<p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p>
<p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p>
<h5 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h5><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p>
<p>队列的使用广泛应用在广度优先搜索种，例如层次遍历一个二叉树的节点值（后续将到）</p>
<p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对链表的理解？常见的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对链表的理解？常见的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对链表的理解？常见的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对链表的理解？常见的操作有哪些？</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>链表（Linked List）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，由一系列结点（链表中每一个元素称为结点）组成</p>
<p>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65346539333439302d316337362d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>节点用代码表示，则如下：</p>
<pre><code class="javascript">class Node &#123;
  constructor(val) &#123;
    this.val = val;
    this.next = null;
  &#125;
&#125;
</code></pre>
<ul>
<li>data 表示节点存放的数据</li>
<li>next 表示下一个节点指向的内存空间</li>
</ul>
<p>相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到<code>O(1)</code>的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是<code>O(logn)</code>和<code>O(1)</code></p>
<p>链表的结构也十分多，常见的有四种形式：</p>
<ul>
<li>单链表：除了头节点和尾节点，其他节点只包含一个后继指针</li>
<li>循环链表：跟单链表唯一的区别就在于它的尾结点又指回了链表的头结点，首尾相连，形成了一个环</li>
<li>双向链表：每个结点具有两个方向指针，后继指针(next)指向后面的结点，前驱指针(prev)指向前面的结点，其中节点的前驱指针和尾结点的后继指针均指向空地址NULL</li>
<li>双向循环链表：跟双向链表基本一致，不过头节点前驱指针指向尾迹诶单和尾节点的后继指针指向头节点</li>
</ul>
<h4 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于链表的操作可以主要分成如下：</p>
<ul>
<li>遍历</li>
<li>插入</li>
<li>删除</li>
</ul>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>遍历很好理解，就是根据<code>next</code>指针遍历下去，直到为<code>null</code>，如下：</p>
<pre><code class="javascript">let current = head
while(current)&#123;
 console.log(current.val)
  current = current.next
&#125;
</code></pre>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>向链表中间插入一个元素，可以如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66356665356664302d316337362d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>可以看到，插入节点可以分成如下步骤：</p>
<ul>
<li>存储插入位置的前一个节点</li>
<li>存储插入位置的后一个节点</li>
<li>将插入位置的前一个节点的 next 指向插入节点</li>
<li>将插入节点的 next 指向前面存储的 next 节点</li>
</ul>
<p>相关代码如下所示：</p>
<pre><code class="javascript">let current = head
while (current &lt; position)&#123;
  pervious = current;
  current = current.next;
&#125;
pervious.next = node;
node.next = current;
</code></pre>
<p>如果在头节点进行插入操作的时候，会实现<code>previousNode</code>节点为<code>undefined</code>，不适合上述方式</p>
<p>解放方式可以是在头节点前面添加一个虚拟头节点，保证插入行为一致</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>向链表任意位置删除节点，如下图操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30313630636439302d316337372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>从上图可以看到删除节点的步骤为如下：</p>
<ul>
<li>获取删除节点的前一个节点</li>
<li>获取删除节点的后一个节点</li>
<li>将前一个节点的 next 指向后一个节点</li>
<li>向删除节点的 next 指向为null</li>
</ul>
<p>如果想要删除制定的节点，示意代码如下：</p>
<pre><code class="javascript">while (current != node)&#123;
  pervious = current;
  current = current.next;
  nextNode = current.next;
&#125;
pervious.next = nextNode
</code></pre>
<p>同样如何希望删除节点处理行为一致，可以在头节点前面添加一个虚拟头节点</p>
<h5 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h5><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的<code>CPU</code>缓存、数据库缓存、浏览器缓存等等</p>
<p>当缓存空间被用满时，我们可能会使用<code>LRU</code>最近最好使用策略去清楚，而实现<code>LRU</code>算法的数据结构是链表，思路如下：</p>
<p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表</p>
<ul>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部</li>
<li>如果此数据没在缓存链表中<ul>
<li>如果此时缓存未满，可直接在链表头部插入新节点存储此数据</li>
<li>如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点</li>
</ul>
</li>
</ul>
<p>由于链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据的情况的时候，都可以使用链表</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对集合的理解？常见的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对集合的理解？常见的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对集合的理解？常见的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对集合的理解？常见的操作有哪些？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>集合（Set），指具有某种特定性质的事物的总体，里面的每一项内容称作元素</p>
<p>在数学中，我们经常会遇到集合的概念：</p>
<ul>
<li>有限集合：例如一个班集所有的同学构成的集合</li>
<li>无限集合：例如全体自然数集合</li>
</ul>
<p>在计算机中集合道理也基本一致，具有三大特性：</p>
<ul>
<li>确定性：于一个给定的集合，集合中的元素是确定的。即一个元素，或者属于该集合，或者不属于该集合，两者必居其一</li>
<li>无序性：在一个集合中，不考虑元素之间的顺序，只要元素完全相同，就认为是同一个集合</li>
<li>互异性：集合中任意两个元素都是不同的</li>
</ul>
<h4 id="二、操作-1"><a href="#二、操作-1" class="headerlink" title="二、操作"></a>二、操作</h4><p>在<code>ES6</code>中，集合本身是一个构建函数<code>Set</code>，用来生成 <code>Set</code> 数据结构，如下：</p>
<pre><code class="javascript">const s = new Set();
</code></pre>
<p>关于集合常见的方法有：</p>
<ul>
<li>add()：增</li>
<li>delete()：删</li>
<li>has()：改</li>
<li>clear()：查</li>
</ul>
<h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><p>添加某个值，返回 <code>Set</code> 结构本身</p>
<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>
<pre><code class="javascript">s.add(1).add(2).add(2); // 2只被添加了一次
</code></pre>
<p>体现了集合的互异性特性</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h5><p>删除某个值，返回一个布尔值，表示删除是否成功</p>
<pre><code class="ini">s.delete(1)
</code></pre>
<h5 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h5><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>
<pre><code class="ini">s.has(2)
</code></pre>
<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p>清除所有成员，没有返回值</p>
<pre><code class="ini">s.clear()
</code></pre>
<p>关于多个集合常见的操作有：</p>
<ul>
<li>并集</li>
<li>交集</li>
<li>差集</li>
</ul>
<h5 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h5><p>两个集合的共同元素，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65643936646635302d316433362d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>代码实现方式如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;
</code></pre>
<h5 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h5><p>两个集合<code>A</code> 和 <code>B</code>，即属于<code>A</code>又属于<code>B</code>的元素，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66386139636438302d316433362d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>用代码标识则如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;
</code></pre>
<h5 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h5><p>两个集合<code>A</code> 和 <code>B</code>，属于<code>A</code>的元素但不属于<code>B</code>的元素称为<code>A</code>相对于<code>B</code>的差集，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30313931633536302d316433372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>代码标识则如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>一般情况下，使用数组的概率会比集合概率高很多</p>
<p>使用<code>set</code>集合的场景一般是借助其确定性，其本身只包含不同的元素</p>
<p>所以，可以利用<code>Set</code>的一些原生方法轻松的完成数组去重，查找数组公共元素及不同元素等操作</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对树的理解？相关的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对树的理解？相关的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对树的理解？相关的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对树的理解？相关的操作有哪些？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机领域，树形数据结构是一类重要的非线性数据结构，可以表示数据之间一对多的关系。以树与二叉树最为常用，直观看来，树是以分支关系定义的层次结构</p>
<p>二叉树满足以下两个条件：</p>
<ul>
<li>本身是有序树</li>
<li>树中包含的各个结点的不能超过 2，即只能是 0、1 或者 2</li>
</ul>
<p>如下图，左侧的为二叉树，而右侧的因为头结点的子结点超过2，因此不属于二叉树：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36363735383830302d316466652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>同时，二叉树可以继续进行分类，分成了满二叉树和完成二叉树：</p>
<ul>
<li>满二叉树：如果二叉树中除了叶子结点，每个结点的度都为 2</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353964623035302d316466652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>完成二叉树：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38346165333166302d316466652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h4 id="二、操作-2"><a href="#二、操作-2" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于二叉树的遍历，常见的有：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问根节点</li>
<li>访问当前节点的左子树</li>
<li>若当前节点无左子树，则访问当前节点的右子</li>
</ul>
<p>根据遍历特性，递归版本用代码表示则如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  console.log(root)
  preOrder(root.left)
  preOrder(root.right)
&#125;
</code></pre>
<p>如果不使用递归版本，可以借助栈先进后出的特性实现，先将根节点压入栈，再分别压入右节点和左节点，直到栈中没有元素，如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  const stack = [root]
  while (stack.length) &#123;
    const n = stack.pop()
    console.log(n.val)
    if (n.right) &#123;
      stack.push(n.right)
    &#125;
    if (n.left) &#123;
      stack.push(n.left)
    &#125;
  &#125;
&#125;
</code></pre>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问当前节点的左子树</li>
<li>访问根节点</li>
<li>访问当前节点的右子</li>
</ul>
<p>递归版本很好理解，用代码表示则如下：</p>
<pre><code class="javascript">const inOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  inOrder(root.left)
  console.log(root.val)
  inOrder(root.right)
&#125;
</code></pre>
<p>非递归版本也是借助栈先进后出的特性，可以一直首先一直压入节点的左元素，当左节点没有后，才开始进行出栈操作，压入右节点，然后有依次压入左节点，如下：</p>
<pre><code class="javascript">const inOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  const stack = [root]
  let p = root
  while(stack.length || p)&#123;
    while (p) &#123;
      stack.push(p)
      p = p.left
    &#125;
    const n = stack.pop()
    console.log(n.val)
    p = n.right
  &#125;
&#125;
</code></pre>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问当前节点的左子树</li>
<li>访问当前节点的右子</li>
<li>访问根节点</li>
</ul>
<p>递归版本，用代码表示则如下：</p>
<pre><code class="javascript">const postOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  postOrder(root.left)
  postOrder(root.right)
  console.log(n.val)
 &#125;
</code></pre>
<p>后序遍历非递归版本实际根全序遍历是逆序关系，可以再多创建一个栈用来进行输出，如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  const stack = [root]
  const outPut = []
  while (stack.length) &#123;
    const n = stack.pop()
    outPut.push(n.val)
    if (n.right) &#123;
      stack.push(n.right)
    &#125;
    if (n.left) &#123;
      stack.push(n.left)
    &#125;
  &#125;
  while (outPut.length) &#123;
    const n = outPut.pop()
    console.log(n.val)
  &#125;
&#125;
</code></pre>
<h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>按照二叉树中的层次从左到右依次遍历每层中的结点</p>
<p>借助队列先进先出的特性，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果</p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const levelOrder = (root) =&gt; &#123;
    if (!root) &#123; return [] &#125;
    const queue = [[root, 0]]
    const res = []
    while (queue.length) &#123;
        const n = queue.shift()
        const [node, leval] = n
        if (!res[leval]) &#123;
            res[leval] = [node.val]
        &#125; else &#123;
            res[leval].push(node.val)
        &#125;
        if (node.left) &#123; queue.push([node.left, leval + 1]) &#125;
        if (node.right) &#123; queue.push([node.right, leval + 1]) &#125;
    &#125;
    return res
&#125;;
</code></pre>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>树是一个非常重要的非线性结构，其中二叉树以二叉树最常见，二叉树的遍历方式可以分成前序遍历、中序遍历、后序遍历</p>
<p>同时，二叉树又分成了完成二叉树和满二叉树</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对堆的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对堆的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对堆的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对堆的理解？如何实现？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称</p>
<p>堆通常是一个可以被看做一棵完全二叉树的数组对象，如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613066643166302d316564372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>总是满足下列性质：</p>
<ul>
<li>堆中某个结点的值总是不大于或不小于其父结点的值</li>
<li>堆总是一棵完全二叉树</li>
</ul>
<p>堆又可以分成最大堆和最小堆：</p>
<ul>
<li>最大堆：每个根结点，都有根结点的值大于两个孩子结点的值</li>
<li>最小堆：每个根结点，都有根结点的值小于孩子结点的值</li>
</ul>
<h4 id="二、操作-3"><a href="#二、操作-3" class="headerlink" title="二、操作"></a>二、操作</h4><p>堆的元素存储方式，按照完全二叉树的顺序存储方式存储在一个一维数组中，如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613066643166302d316564372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用一维数组存储则如下：</p>
<pre><code class="javascript">[0, 1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<p>根据完全二叉树的特性，可以得到如下特性：</p>
<ul>
<li>数组零坐标代码的是堆顶元素</li>
<li>一个节点的父亲节点的坐标等于其坐标除以2整数部分</li>
<li>一个节点的左节点等于其本身节点坐标 * 2 + 1</li>
<li>一个节点的右节点等于其本身节点坐标 * 2 + 2</li>
</ul>
<p>根据上述堆的特性，下面构建最小堆的构造函数和对应的属性方法：</p>
<pre><code class="javascript">class MinHeap &#123;
  constructor() &#123;
    // 存储堆元素
    this.heap = []
  &#125;
  // 获取父元素坐标
  getParentIndex(i) &#123;
    return (i - 1) &gt;&gt; 1
  &#125;
  
  // 获取左节点元素坐标
  getLeftIndex(i) &#123;
    return i * 2 + 1
  &#125;
  
 // 获取右节点元素坐标
  getRightIndex(i) &#123;
    return i * 2 + 2
  &#125;
  
  // 交换元素
  swap(i1, i2) &#123;
    const temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp
  &#125;
  
  // 查看堆顶元素
  peek() &#123;
    return this.heap[0]
  &#125;
  
  // 获取堆元素的大小
  size() &#123;
    return this.heap.length
  &#125;
&#125;
</code></pre>
<p>涉及到堆的操作有：</p>
<ul>
<li>插入</li>
<li>删除</li>
</ul>
<h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><p>将值插入堆的底部，即数组的尾部，当插入一个新的元素之后，堆的结构就会被破坏，因此需要堆中一个元素做上移操作</p>
<p>将这个值和它父节点进行交换，直到父节点小于等于这个插入的值，大小为<code>k</code>的堆中插入元素的时间复杂度为<code>O(logk)</code></p>
<p>如下图所示，22节点是新插入的元素，然后进行上移操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30363839336662302d316564382d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>相关代码如下：</p>
<pre><code class="java">// 插入元素
insert(value) &#123;
  this.heap.push(value)
  this.shifUp(this.heap.length - 1)
&#125;

// 上移操作
shiftUp(index) &#123;
  if (index === 0) &#123; return &#125;
  const parentIndex = this.getParentIndex(index)
  if(this.heap[parentIndex] &gt; this.heap[index])&#123;
    this.swap(parentIndex, index)
    this.shiftUp(parentIndex)
  &#125;
&#125;
</code></pre>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>常见操作是用数组尾部元素替换堆顶，这里不直接删除堆顶，因为所有的元素会向前移动一位，会破坏了堆的结构</p>
<p>然后进行下移操作，将新的堆顶和它的子节点进行交换，直到子节点大于等于这个新的堆顶，删除堆顶的时间复杂度为<code>O(logk)</code></p>
<p>整体如下图操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31326132613136302d316564382d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>相关代码如下：</p>
<pre><code class="javascript">// 删除元素
pop() &#123;
  this.heap[0] = this.heap.pop()
  this.shiftDown(0)
&#125;

// 下移操作
shiftDown(index) &#123;
  const leftIndex = this.getLeftIndex(index)
  const rightIndex = this.getRightIndex(index)
  if (this.heap[leftIndex] &lt; this.heap[index])&#123;
    this.swap(leftIndex, index)
    this.shiftDown(leftIndex)
  &#125;
  if (this.heap[rightIndex] &lt; this.heap[index])&#123;
    this.swap(rightIndex, index)
    this.shiftDown(rightIndex)
  &#125;
&#125;
</code></pre>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>关于堆的插入和删除时间复杂度都是<code>Olog(n)</code>，原因在于包含n个节点的完全二叉树，树的高度不会超过<code>log2n</code></p>
<p>堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是<code>Olog(n)</code>，插入数据和删除堆顶元素的主要逻辑就是堆化</p>
<h3 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h3><ul>
<li>堆是一个完全二叉树</li>
<li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值</li>
<li>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”</li>
<li>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“小顶堆”</li>
<li>根据堆的特性，我们可以使用堆来进行排序操作，也可以使用其来求第几大或者第几小的值</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对图的理解？相关操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对图的理解？相关操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对图的理解？相关操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对图的理解？相关操作有哪些？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机科学中，图是一种抽象的数据类型，在图中的数据元素通常称为结点，<code>V</code>是所有顶点的集合，<code>E</code>是所有边的集合</p>
<p>如果两个顶点<code>v</code>,<code> w</code>，只能由<code>v</code>向<code>w</code>，而不能由<code>w</code>向<code>v</code>，那么我们就把这种情况叫做一个从 <code>v</code> 到 <code>w</code> 的有向边。<code>v </code>也被称做初始点，<code>w</code>也被称为终点。这种图就被称做有向图</p>
<p>如果<code>v</code>和<code>w</code>是没有顺序的，从<code>v</code>到达<code>w</code>和从<code>w</code>到达<code>v</code>是完全相同的，这种图就被称为无向图</p>
<p>图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系</p>
<p>常见表达图的方式有如下：</p>
<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
</ul>
<h5 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h5><p>通过使用一个二维数组<code>G[N][N]</code>进行表示<code>N</code>个点到<code>N-1</code>编号，通过邻接矩阵可以立刻看出两顶点之间是否存在一条边，只需要检查邻接矩阵行<code>i</code>和列<code>j</code>是否是非零值，对于无向图，邻接矩阵是对称的</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38383164343330302d323035392d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><p>存储方式如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39343966656464302d323035392d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>在<code>javascript</code>中，可以使用<code>Object</code>进行表示，如下：</p>
<pre><code class="javascript">const graph = &#123;
  A: [2, 3, 5],
  B: [2],
  C: [0, 1, 3],
  D: [0, 2],
  E: [6],
  F: [0, 6],
  G: [4, 5]
&#125;
</code></pre>
<p>图的数据结构还可能包含和每条边相关联的数值（edge value），例如一个标号或一个数值（即权重，weight；表示花费、容量、长度等）</p>
<h4 id="二、操作-4"><a href="#二、操作-4" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于的图的操作常见的有：</p>
<ul>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
</ul>
<p>首先构建一个图的邻接矩阵表示，如下面的图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61313331313739302d323035392d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const graph = &#123;
  0: [1, 4],
  1: [2, 4],
  2: [2, 3],
  3: [],
  4: [3],
&#125;
</code></pre>
<h5 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h5><p>也就是尽可能的往深处的搜索图的分支</p>
<p>实现思路是，首先应该确定一个根节点，然后对根节点的没访问过的相邻节点进行深度优先遍历</p>
<p>确定以 0 为根节点，然后进行深度遍历，然后遍历1，接着遍历 2，然后3，此时完成一条分支<code>0 - 1- 2- 3</code>的遍历，换一条分支，也就是4，4后面因为3已经遍历过了，所以就不访问了</p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const visited = new Set()
const dfs = (n) =&gt; &#123;
  console.log(n)
  visited.add(n) // 访问过添加记录
  graph[n].forEach(c =&gt; &#123;
    if(!visited.has(c))&#123; // 判断是否访问呢过
      dfs(c)
    &#125;
  &#125;)
&#125;
</code></pre>
<h5 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h5><p>先访问离根节点最近的节点，然后进行入队操作，解决思路如下：</p>
<ul>
<li>新建一个队列，把根节点入队</li>
<li>把队头出队并访问</li>
<li>把队头的没访问过的相邻节点入队</li>
<li>重复二、三步骤，知道队列为空</li>
</ul>
<p>用代码标识则如下：</p>
<pre><code class="javascript">const visited = new Set()
const dfs = (n) =&gt; &#123;
  visited.add(n)
  const q = [n]
  while(q.length)&#123;
    const n = q.shift()
    console.log(n)
    graph[n].forEach(c =&gt; &#123;
      if(!visited.has(c))&#123;
        q.push(c)  
        visited.add(c)
      &#125;
    &#125;)
  &#125;
&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面的初步了解，可以看到图就是由顶点的有穷非空集合和顶点之间的边组成的集合，分成了无向图与有向图</p>
<p>图的表达形式可以分成邻接矩阵和邻接表两种形式，在<code>javascript</code>中，则可以通过二维数组和对象的形式进行表达</p>
<p>图实际是很复杂的，后续还可以延伸出无向图和带权图，对应如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62306438383230302d323035392d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-常见的排序算法有哪些？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-常见的排序算法有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 常见的排序算法有哪些？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 常见的排序算法有哪些？区别？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列</p>
<p>排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的</p>
<p>对与排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性</p>
<p>时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义</p>
<p>稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变</p>
<p>即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的</p>
<h4 id="二、有哪些-1"><a href="#二、有哪些-1" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的算法排序算法有：</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来</p>
<p>思路如下：</p>
<ul>
<li>比较相邻的元素，如果第一个比第二个大，就交换它们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>重复上述步骤，直到没有任何一堆数字需要比较</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963342e7a68696d672e636f6d2f76322d33336139343763373161643632623235346361623632653533363464323831335f622e77656270.gif"></p>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法</p>
<p>无论什么数据进去都是 <code>O(n²) </code>的时间复杂度。所以用到它的时候，数据规模越小越好</p>
<p>唯一的好处是不占用额外的内存存储空间</p>
<p>思路如下：</p>
<ul>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963312e7a68696d672e636f6d2f76322d31633765323066333036646463303265623465336135306661373831376666345f622e77656270.gif"></p>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>插入排序是一种简单直观的排序算法</p>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<p>解决思路如下：</p>
<ul>
<li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的</li>
<li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
<li>重复上述过程直到最后一个元素被插入有序子数组中</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d39316237366538653464616239623063616439613031376437646434333165325f622e77656270.gif"></p>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>归并排序是建立在归并操作上的一种有效的排序算法</p>
<p>该算法是采用分治法的一个非常典型的应用</p>
<p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p>
<p>解决思路如下：</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d63646461336631316336656662633031353737663563323961393036363737325f622e6a7067.jpeg"></p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小</p>
<p>再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列</p>
<p>解决思路如下：</p>
<ul>
<li>从数列中挑出一个元素，称为”基准”（pivot）</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963312e7a68696d672e636f6d2f76322d63343131333339623739663932343939646362376235663330346338323666345f622e6a7067.jpeg"></p>
<h2 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h2><p>除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等……</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对冒泡排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对冒泡排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对冒泡排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对冒泡排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法</p>
<p>冒泡排序的思想就是在每次遍历一遍未排序的数列之后，将一个数据元素浮上去（也就是排好了一个数据）</p>
<p>如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”</p>
<p>假如我们要把 12、35、99、18、76 这 5 个数从大到小进行排序，那么数越大，越需要把它放在前面</p>
<p>思路如下：</p>
<ul>
<li>从后开始遍历，首先比较 18 和 76，发现 76 比 18 大，就把两个数交换顺序，得到 12、35、99、76、18</li>
<li>接着比较 76 和 99，发现 76 比 99 小，所以不用交换顺序</li>
<li>接着比较 99 和 35，发现 99 比 35 大，交换顺序</li>
<li>接着比较 99 和 12，发现 99 比 12 大，交换顺序</li>
</ul>
<p>最终第 1 趟排序的结果变成了 99、12、35、76、18，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37613336333737302d323635322d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>上述可以看到，经过第一趟的排序，可以得到最大的元素，接下来第二趟排序则对剩下的的4个元素进行排序，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38346239646466302d323635322d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>经过第 2 趟排序，结果为 99、76、12、35、18</p>
<p>然后开始第3趟的排序，结果为99、76、35、12、18</p>
<p>然后第四趟排序结果为99、76、35、18、12</p>
<p>经过 4 趟排序之后，只剩一个 12 需要排序了，这时已经没有可比较的元素了，这时排序完成</p>
<h4 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>如果要实现一个从小到大的排序，算法原理如下：</p>
<ul>
<li>首先比较相邻的元素，如果第一个元素比第二个元素大，则交换它们</li>
<li>针对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样，最后的元素回事最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li>
</ul>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function bubbleSort(arr) &#123;
    const len = arr.length;
    for (let i = 0; i &lt; len - 1; i++) &#123;
        for (let j = 0; j &lt; len - 1 - i; j++) &#123;
            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
    return arr;
&#125;
</code></pre>
<p>可以看到：冒泡排序在每一轮排序中都会使一个元素排到一趟， 也就是最终需要 n-1 轮这样的排序</p>
<p>而在每轮排序中都需要对相邻的两个元素进行比较，在最坏的情况下，每次比较之后都需要交换位置，此时时间复杂度为<code>O(n^2)</code></p>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>对冒泡排序常见的改进方法是加入一标志性变量<code>exchange</code>，用于标志某一趟排序过程中是否有数据交换</p>
<p>如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程</p>
<p>可以设置一标志性变量<code>pos</code>，用于记录每趟排序中最后一次进行交换的位置，由于<code>pos</code>位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到<code>pos</code>位置即可，如下：</p>
<pre><code class="javascript">function bubbleSort1(arr)&#123;
 const i=arr.length-1;//初始时,最后位置保持不变  
 while(i&gt;0)&#123;
  let pos = 0;//每趟开始时,无记录交换
  for(let j = 0; j &lt; i; j++)&#123;
   if(arr[j] &gt; arr[j+1])&#123;
        let tmp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = tmp;
    pos = j;//记录最后交换的位置  
   &#125;   
  &#125;
  i = pos;//为下一趟排序作准备
 &#125;
 return arr;
&#125;
</code></pre>
<p>在待排序的数列有序的情况下，只需要一轮排序并且不用交换，此时情况最好，时间复杂度为<code>O(n)</code></p>
<p>并且从上述比较中看到，只有后一个元素比前面的元素大（小）时才会对它们交换位置并向上冒出，对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对位置是不会改变的，因此， 冒泡排序是稳定的</p>
<h4 id="三、应用场景-3"><a href="#三、应用场景-3" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>冒泡排的核心部分是双重嵌套循环，<br>时间复杂度是 O(N 2 )，相比其它排序算法，这是一个相对较高的时间复杂度，一般情况不推荐使用，由于冒泡排序的简洁性，通常被用来对于程序设计入门的学生介绍算法的概念</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对选择排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对选择排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对选择排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对选择排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>选择排序（Selection sort）是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²) </code>的时间复杂度，所以用到它的时候，数据规模越小越好</p>
<p>其基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置</p>
<p>然后再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾</p>
<p>以此类推，直到所有元素均排序完毕</p>
<p>举个例子，一个数组为 56、12、80、91、29，其排序过程如下：</p>
<ul>
<li>第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置。此时数组为 12、56、80、91、20</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36306264323035302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置，此时数组为12、20、80、91、56</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36623034636634302d323637312d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<ul>
<li>第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置，此时数组为 12、20、56、91、80</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353766346530302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置，此时排序完成，变成有序数组</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353766346530302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h4 id="二、如何实现-1"><a href="#二、如何实现-1" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>从上面可以看到，对于具有 <code>n</code> 个记录的无序表遍历 <code>n-1</code> 次，第<code> i</code> 次从无序表中第 <code>i</code> 个记录开始，找出后序关键字中最小的记录，然后放置在第 <code>i</code> 的位置上</p>
<p>直至到从第<code>n</code>个和第<code>n-1</code>个元素中选出最小的放在第<code>n-1</code>个位置</p>
<p>如下动画所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f73656c656374696f6e536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function selectionSort(arr) &#123;
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) &#123;
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) &#123;
            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    return arr;
&#125;
</code></pre>
<p>第一次内循环比较<code>N - 1</code>次，然后是<code>N-2</code>次，<code>N-3</code>次，……，最后一次内循环比较1次<br>共比较的次数是 <code>(N - 1) + (N - 2) + ... + 1</code>，求等差数列和，得 <code>(N - 1 + 1)* N / 2 = N^2 / 2</code>，舍去最高项系数，其时间复杂度为 <code>O(N^2)</code></p>
<p>从上述也可以看到，选择排序是一种稳定的排序</p>
<h4 id="三、应用场景-4"><a href="#三、应用场景-4" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>和冒泡排序一致，相比其它排序算法，这也是一个相对较高的时间复杂度，一般情况不推荐使用</p>
<p>但是我们还是要掌握冒泡排序的思想及实现，这对于我们的算法思维是有很大帮助的</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对插入排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对插入排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对插入排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对插入排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-9"><a href="#一、是什么-9" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>插入排序（Insertion Sort），一般也被称为直接插入排序。对于少量元素的排序，它是一个有效、简单的算法</p>
<p>其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据</p>
<p>插入排序的工作方式像许多人排序一手扑克牌，开始时，我们的左手为空并且桌子上的牌面向下</p>
<p>然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置，该正确位置需要从右到左将它与已在手中的每张牌进行比较</p>
<p>例如一个无序数组 3、1、7、5、2、4、9、6，将其升序的结果则如下：</p>
<p>一开始有序表中无数据，直接插入3</p>
<p>从第二个数开始，插入一个元素1，然后和有序表中记录3比较，1&lt;3，所以插入到记录 3 的左侧</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39643234663566302d323637662d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>向有序表插入记录 7 时，同有序表中记录 3 进行比较，3&lt;7，所以插入到记录 3 的右侧</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61366139353465302d323637662d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>向有序表中插入记录 5 时，同有序表中记录 7 进行比较，5&lt;7，同时 5&gt;3，所以插入到 3 和 7 中间</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62313938313934302d323637662d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>照此规律，依次将无序表中的记录 4，9 和 6插入到有序表中</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62633265643239302d323637662d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h4 id="二、如何实现-2"><a href="#二、如何实现-2" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置</p>
<p>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f696e73657274696f6e536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function insertionSort(arr) &#123;
    const len = arr.length;
    let preIndex, current;
    for (let i = 1; i &lt; len; i++) &#123;
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        &#125;
        arr[preIndex+1] = current;
    &#125;
    return arr;
&#125;
</code></pre>
<p>在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较<code>N- 1</code>次，时间复杂度为<code>O(n)</code></p>
<p>最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为<code>O(n^2)</code></p>
<p>通过上面了解，可以看到插入排序是一种稳定的排序方式</p>
<h4 id="三、应用场景-5"><a href="#三、应用场景-5" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>插入排序时间复杂度是 O(n2)，适用于数据量不大，算法稳定性要求高，且数据局部或整体有序的数列排序</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对归并排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对归并排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对归并排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对归并排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-10"><a href="#一、是什么-10" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>归并排序（Merge Sort）是建立归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用</p>
<p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p>
<p>例如对于含有 <code>n</code> 个记录的无序表，首先默认表中每个记录各为一个有序表（只不过表的长度都为 1）</p>
<p>然后进行两两合并，使 <code>n</code> 个有序表变为<code>n/2</code> 个长度为 2 或者 1 的有序表（例如 4 个小有序表合并为 2 个大的有序表）</p>
<p>通过不断地进行两两合并，直到得到一个长度为 <code>n</code> 的有序表为止</p>
<p>例如对无序表{49，38，65，97，76，13，27}进行归并排序分成了分、合两部分：</p>
<p>如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30356631346236302d323661642d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>归并合过程中，每次得到的新的子表本身有序，所以最终得到有序表</p>
<p>上述分成两部分，则称为二路归并，如果分成三个部分则称为三路归并，以此类推</p>
<h4 id="二、如何实现-3"><a href="#二、如何实现-3" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>关于归并排序的算法思路如下：</p>
<ul>
<li>分：把数组分成两半，再递归对子数组进行分操作，直至到一个个单独数字</li>
<li>合：把两个数合成有序数组，再对有序数组进行合并操作，直到全部子数组合成一个完整的数组<ul>
<li>合并操作可以新建一个数组，用于存放排序后的数组</li>
<li>比较两个有序数组的头部，较小者出队并且推入到上述新建的数组中</li>
<li>如果两个数组还有值，则重复上述第二步</li>
<li>如果只有一个数组有值，则将该数组的值出队并推入到上述新建的数组中</li>
</ul>
</li>
</ul>
<p>用代码表示则如下图所示：</p>
<pre><code class="javascript">function mergeSort(arr) &#123;  // 采用自上而下的递归方法
    const len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    let middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    const result = [];

    while (left.length &amp;&amp; right.length) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
&#125;
</code></pre>
<p>上述归并分成了分、合两部分，在处理分过程中递归调用两个分的操作，所花费的时间为2乘<code>T(n/2)</code>，合的操作时间复杂度则为<code>O(n)</code>，因此可以得到以下公式：</p>
<p>总的执行时间 &#x3D; 2 × 输入长度为<code>n/2</code>的<code>sort</code>函数的执行时间 + <code>merge</code>函数的执行时间<code>O(n)</code></p>
<p>当只有一个元素时，<code>T(1) = O(1)</code></p>
<p>如果对<code>T(n) = 2 * T(n/2) + O(n) </code>进行左右 &#x2F; n的操作，得到 <code>T(n) / n = (n / 2) * T(n/2) + O(1)</code></p>
<p>现在令 <code>S(n) = T(n)/n</code>，则<code>S(1) = O(1)</code>，然后利用表达式带入得到<code>S(n) = S(n/2) + O(1)</code></p>
<p>所以可以得到：<code>S(n) = S(n/2) + O(1) = S(n/4) + O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)</code></p>
<p>综上可得，<code>T(n) = n * log(n) = nlogn</code></p>
<p>关于归并排序的稳定性，在进行合并过程，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也不会交换，由此可见归并排序是稳定的排序算法</p>
<h4 id="三、应用场景-6"><a href="#三、应用场景-6" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>在外排序中通常使用排序-归并的策略，外排序是指处理超过内存限度的数据的排序算法，通常将中间结果放在读写较慢的外存储器，如下分成两个阶段：</p>
<ul>
<li>排序阶段：读入能够放进内存中的数据量，将其排序输出到临时文件，一次进行，将带排序数据组织为多个有序的临时文件</li>
<li>归并阶段：将这些临时文件组合为大的有序文件</li>
</ul>
<p>例如，使用100m内存对900m的数据进行排序，过程如下：</p>
<ul>
<li>读入100m数据内存，用常规方式排序</li>
<li>将排序后的数据写入磁盘</li>
<li>重复前两个步骤，得到9个100m的临时文件</li>
<li>将100m的内存划分为10份，将9份为输入缓冲区，第10份为输出缓冲区</li>
<li>进行九路归并排序，将结果输出到缓冲区<ul>
<li>若输出缓冲区满，将数据写到目标文件，清空缓冲区</li>
<li>若缓冲区空，读入相应文件的下一份数据</li>
</ul>
</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对快速排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对快速排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对快速排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对快速排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-11"><a href="#一、是什么-11" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>快速排序（Quick Sort）算法是在冒泡排序的基础上进行改进的一种算法，从名字上看就知道该排序算法的特点是快、效率高，是处理大数据最快的排序算法之一</p>
<p>实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小</p>
<p>然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就变成有序序列</p>
<p>例如，对无序表49，38，65，97，76，13，27，49进行快速排序，大致过程为：</p>
<ul>
<li>首先从表中选取一个记录的关键字作为分割点（称为“枢轴”或者支点，一般选择第一个关键字），例如选取 49</li>
<li>将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：{27，38，13，49，65，97，76，49}</li>
<li>以 49 为支点，将整个无序表分割成了两个部分，分别为{27，38，13}和{65，97，76，49}，继续采用此种方法分别对两个子表进行排序</li>
<li>前部分子表以 27 为支点，排序后的子表为{13，27，38}，此部分已经有序；后部分子表以 65 为支点，排序后的子表为{49，65，97，76}</li>
<li>此时前半部分子表中的数据已完成排序；后部分子表继续以 65 为支点，将其分割为{49}和{97，76}，前者不需排序，后者排序后的结果为{76， 97}</li>
<li>通过以上几步的排序，最后由子表{13，27，38}、{49}、{49}、{65}、{76，97}构成有序表：{13，27，38，49，49，65，76，97}</li>
</ul>
<h4 id="二、如何实现-4"><a href="#二、如何实现-4" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>可以分成以下步骤：</p>
<ul>
<li>分区：从数组中选择任意一个基准，所有比基准小的元素放在基准的左边，比基准大的元素放到基准的右边</li>
<li>递归：递归地对基准前后的子数组进行分区</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f717569636b536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function quickSort (arr) &#123;
  const rec = (arr) =&gt; &#123;
    if (arr.length &lt;= 1) &#123; return arr; &#125;
    const left = [];
    const right = [];
    const mid = arr[0]; // 基准元素
    for (let i = 1; i &lt; arr.length; i++)&#123;
      if (arr[i] &lt; mid) &#123;
        left.push(arr[i]);
      &#125; else &#123;
        right.push(arr[i]);
      &#125;
    &#125;
    return [...rec(left), mid, ...rec(right)]
  &#125;
  return rec(arr)
&#125;;
</code></pre>
<p>快速排序是冒泡排序的升级版，最坏情况下每一次基准元素都是数组中最小或者最大的元素，则快速排序就是冒泡排序</p>
<p>这种情况时间复杂度就是冒泡排序的时间复杂度：<code>T[n] = n * (n-1) = n^2 + n</code>，也就是<code>O(n^2)</code></p>
<p>最好情况下是<code>O(nlogn)</code>，其中递归算法的时间复杂度公式：<code>T[n] = aT[n/b] + f(n)</code>，推导如下所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62363031393534302d326235652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>关于上述代码实现的快速排序，可以看到是稳定的</p>
<h4 id="三、应用场景-7"><a href="#三、应用场景-7" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>快速排序时间复杂度为<code>O(nlogn)</code>，是目前基于比较的内部排序中被认为最好的方法，当数据过大且数据杂乱无章时，则适合采用快速排序</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对二分查找的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对二分查找的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对二分查找的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对二分查找的理解？如何实现？应用场景？</h3><h4 id="一、是什么-12"><a href="#一、是什么-12" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机科学中，二分查找算法，也称折半搜索算法，是一种在有序数组中查找某一特定元素的搜索算法</p>
<p>想要应用二分查找法，则这一堆数应有如下特性：</p>
<ul>
<li>存储在数组中</li>
<li>有序排序</li>
</ul>
<p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束</p>
<p>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较</p>
<p>如果在某一步骤数组为空，则代表找不到</p>
<p>这种搜索算法每一次比较都使搜索范围缩小一半</p>
<p>如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65323130383532302d323938372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>相比普通的顺序查找，除了数据量很少的情况下，二分查找会比顺序查找更快，区别如下所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963322e7a68696d672e636f6d2f76322d34333333396239363364623633623333313037623536353033616436623162355f622e676966.gif"></p>
<h4 id="二、如何实现-5"><a href="#二、如何实现-5" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>基于二分查找的实现，如果数据是有序的，并且不存在重复项，实现代码如下：</p>
<pre><code class="javascript">function BinarySearch(arr, target) &#123;
    if (arr.length &lt;= 1) return -1
    // 低位下标
    let lowIndex = 0
    // 高位下标
    let highIndex = arr.length - 1

    while (lowIndex &lt;= highIndex) &#123;
        // 中间下标
        const midIndex = Math.floor((lowIndex + highIndex) / 2)
        if (target &lt; arr[midIndex]) &#123;
            highIndex = midIndex - 1
        &#125; else if (target &gt; arr[midIndex]) &#123;
            lowIndex = midIndex + 1
        &#125; else &#123;
            // target === arr[midIndex]
            return midIndex
        &#125;
    &#125;
    return -1
&#125;
</code></pre>
<p>如果数组中存在重复项，而我们需要找出第一个制定的值，实现则如下：</p>
<pre><code class="javascript">function BinarySearchFirst(arr, target) &#123;
    if (arr.length &lt;= 1) return -1
    // 低位下标
    let lowIndex = 0
    // 高位下标
    let highIndex = arr.length - 1

    while (lowIndex &lt;= highIndex) &#123;
        // 中间下标
        const midIndex = Math.floor((lowIndex + highIndex) / 2)
        if (target &lt; arr[midIndex]) &#123;
            highIndex = midIndex - 1
        &#125; else if (target &gt; arr[midIndex]) &#123;
            lowIndex = midIndex + 1
        &#125; else &#123;
            // 当 target 与 arr[midIndex] 相等的时候，如果 midIndex 为0或者前一个数比 target 小那么就找到了第一个等于给定值的元素，直接返回
            if (midIndex === 0 || arr[midIndex - 1] &lt; target) return midIndex
            // 否则高位下标为中间下标减1，继续查找
            highIndex = midIndex - 1
        &#125;
    &#125;
    return -1
&#125;
</code></pre>
<p>实际上，除了有序的数组可以使用，还有一种特殊的数组可以应用，那就是轮转后的有序数组</p>
<p>有序数组即一个有序数字以某一个数为轴，将其之前的所有数都轮转到数组的末尾所得</p>
<p>例如，[4, 5, 6, 7, 0, 1, 2]就是一个轮转后的有序数组</p>
<p>该数组的特性是存在一个分界点用来分界两个有序数组，如下：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65656565323133302d323938372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>分界点有如下特性：</p>
<ul>
<li>分界点元素 &gt;&#x3D; 第一个元素</li>
<li>分界点元素 &lt; 第一个元素</li>
</ul>
<p>代码实现如下：</p>
<pre><code class="javascript">function search (nums, target) &#123;
  // 如果为空或者是空数组的情况
  if (nums == null || !nums.length) &#123;
    return -1;
  &#125;
  // 搜索区间是前闭后闭
  let begin = 0,
    end = nums.length - 1;
  while (begin &lt;= end) &#123;
    // 下面这样写是考虑大数情况下避免溢出
    let mid = begin + ((end - begin) &gt;&gt; 1);
    if (nums[mid] == target) &#123;
      return mid;
    &#125;
    // 如果左边是有序的
    if (nums[begin] &lt;= nums[mid]) &#123;
      //同时target在[ nums[begin],nums[mid] ]中，那么就在这段有序区间查找
      if (nums[begin] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;
        end = mid - 1;
      &#125; else &#123;
        //否则去反方向查找
        begin = mid + 1;
      &#125;
      //如果右侧是有序的
    &#125; else &#123;
      //同时target在[ nums[mid],nums[end] ]中，那么就在这段有序区间查找
      if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end]) &#123;
        begin = mid + 1;
      &#125; else &#123;
        end = mid - 1;
      &#125;
    &#125;
  &#125;
  return -1;
&#125;;
</code></pre>
<p>对比普通的二分查找法，为了确定目标数会落在二分后的哪个部分，我们需要更多的判定条件</p>
<h4 id="三、应用场景-8"><a href="#三、应用场景-8" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>二分查找法的<code>O(logn)</code>让它成为十分高效的算法。不过它的缺陷却也是比较明显，就在它的限定之上：</p>
<ul>
<li>有序：我们很难保证我们的数组都是有序的</li>
<li>数组：数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)，并且数组的存储是需要连续的内存空间，不适合大数据的情况</li>
</ul>
<p>关于二分查找的应用场景，主要如下：</p>
<ul>
<li>不适合数据量太小的数列；数列太小，直接顺序遍历说不定更快，也更简单</li>
<li>每次元素与元素的比较是比较耗时的，这个比较操作耗时占整个遍历算法时间的大部分，那么使用二分查找就能有效减少元素比较的次数</li>
<li>不适合数据量太大的数列，二分查找作用的数据结构是顺序表，也就是数组，数组是需要连续的内存空间的，系统并不一定有这么大的连续内存空间可以使用</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对分而治之、动态规划的理解？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对分而治之、动态规划的理解？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对分而治之、动态规划的理解？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对分而治之、动态规划的理解？区别？</h3><h4 id="一、分而治之"><a href="#一、分而治之" class="headerlink" title="一、分而治之"></a>一、分而治之</h4><p>分而治之是算法设计中的一种方法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p>
<p>关于分而治之的实现，都会经历三个步骤：</p>
<ul>
<li>分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题</li>
<li>解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题</li>
<li>合并：将各子问题的解合并为原问题的解</li>
</ul>
<p>实际上，关于分而治之的思想，我们在前面已经使用，例如归并排序的实现，同样经历了实现分而治之的三个步骤：</p>
<ul>
<li>分解：把数组从中间一分为二</li>
<li>解决：递归地对两个子数组进行归并排序</li>
<li>合并：将两个字数组合并称有序数组</li>
</ul>
<p>同样关于快速排序的实现，亦如此：</p>
<ul>
<li>分：选基准，按基准把数组分成两个字数组</li>
<li>解：递归地对两个字数组进行快速排序</li>
<li>合：对两个字数组进行合并</li>
</ul>
<p>同样二分搜索也能使用分而治之的思想去实现，代码如下：</p>
<pre><code class="javascript">function binarySearch(arr,l,r,target)&#123;
    if(l&gt; r)&#123;
        return -1;
    &#125;
    let mid = l + Math.floor((r-l)/2)
    if(arr[mid] === target)&#123;
        return mid;
    &#125;else if(arr[mid] &lt; target )&#123;
        return binarySearch(arr,mid + 1,r,target)
    &#125;else&#123;
        return binarySearch(arr,l,mid - 1,target)
    &#125;
&#125;
</code></pre>
<h4 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h4><p>动态规划，同样是算法设计中的一种方法，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</p>
<p>常常适用于有重叠子问题和最优子结构性质的问题</p>
<p>简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决</p>
<p>然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。</p>
<p>一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2的时候，F(n) &#x3D; F(n-1) + F(n-2) ，</p>
<p>f(10)&#x3D; f(9)+f(8),f(9) &#x3D; f(8) + f(7)…是重叠子问题，当n &#x3D; 1、2的时候，对应的值为2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划</p>
<p>比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景</p>
<p>关于动态规划题目解决的步骤，一般如下：</p>
<ul>
<li>描述最优解的结构</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值</li>
<li>由计算出的结果构造一个最优解</li>
</ul>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</p>
<p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的，而分而治之的子问题是相互独立的</p>
<p>若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次</p>
<p>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间</p>
<p>综上，可得：</p>
<ul>
<li>动态规划：有最优子结构和重叠子问题</li>
<li>分而治之：各子问题独立</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对贪心算法、回溯算法的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对贪心算法、回溯算法的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对贪心算法、回溯算法的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对贪心算法、回溯算法的理解？应用场景？</h3><h4 id="一、贪心算法"><a href="#一、贪心算法" class="headerlink" title="一、贪心算法"></a>一、贪心算法</h4><p>贪心算法，又称贪婪算法，是算法设计中的一种思想</p>
<p>其期待每一个阶段都是局部最优的选择，从而达到全局最优，但是结果并不一定是最优的</p>
<p>举个零钱兑换的例子，如果你有1元、2元、5元的钱币数张，用于兑换一定的金额，但是要求兑换的钱币张数最少</p>
<p>如果现在你要兑换11元，按照贪心算法的思想，先选择面额最大的5元钱币进行兑换，那么就得到11 &#x3D; 5 + 5 + 1 的选择，这种情况是最优的</p>
<p>但是如果你手上钱币的面额为1、3、4，想要兑换6元，按照贪心算法的思路，我们会 6 &#x3D; 4 + 1 + 1这样选择，这种情况结果就不是最优的选择</p>
<p>从上面例子可以看到，贪心算法存在一些弊端，使用到贪心算法的场景，都会存在一个特性：</p>
<p>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法</p>
<p>至于是否选择贪心算法，主要看是否有如下两大特性：</p>
<ul>
<li>贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择</li>
<li>最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在</li>
</ul>
<h4 id="二、回溯算法"><a href="#二、回溯算法" class="headerlink" title="二、回溯算法"></a>二、回溯算法</h4><p>回溯算法，也是算法设计中的一种思想，是一种渐进式寻找并构建问题解决方式的策略</p>
<p>回溯算法会先从一个可能的工作开始解决问题，如果不行，就回溯并选择另一个动作，知道将问题解决</p>
<p>使用回溯算法的问题，有如下特性：</p>
<ul>
<li>有很多路，例如一个矩阵的方向或者树的路径</li>
<li>在这些的路里面，有死路也有生路，思路即不符合题目要求的路，生路则符合</li>
<li>通常使用递归来模拟所有的路</li>
</ul>
<p>常见的伪代码如下：</p>
<pre><code class="javascript">result = []
function backtrack(路径, 选择列表):
  if 满足结束条件:
    result.add(路径)
  return

  for 选择 of 选择列表:
    做选择
    backtrack(路径, 选择列表)
    撤销选择
</code></pre>
<p>重点解决三个问题：</p>
<ul>
<li>路径：也就是已经做出的选择</li>
<li>选择列表</li>
<li>结束条件</li>
</ul>
<p>例如经典使用回溯算法为解决全排列的问题，如下：</p>
<p>一个不含重复数字的数组 <code>nums</code> ，我们要返回其所有可能的全排列，解决这个问题的思路是：</p>
<ul>
<li>用递归模拟所有的情况</li>
<li>遇到包含重复元素的情况则回溯</li>
<li>收集到所有到达递归终点的情况，并返回、</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32613033306630302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">var permute = function(nums) &#123;
    const res = [], path = [];
    backtracking(nums, nums.length, []);
    return res;
    
    function backtracking(n, k, used) &#123;
        if(path.length === k) &#123;
            res.push(Array.from(path));
            return;
        &#125;
        for (let i = 0; i &lt; k; i++ ) &#123;
            if(used[i]) continue;
            path.push(n[i]);
            used[i] = true; // 同支
            backtracking(n, k, used);
            path.pop();
            used[i] = false;
        &#125;
    &#125;
&#125;;
</code></pre>
<h4 id="三、总结-3"><a href="#三、总结-3" class="headerlink" title="三、总结"></a>三、总结</h4><p>前面也初步了解到分而治之、动态规划，现在再了解到贪心算法、回溯算法</p>
<p>其中关于分而治之、动态规划、贪心策略三者的求解思路如下：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35303462353233302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>其中三者对应的经典问题如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36326364633931302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端异常捕获问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/05/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E9%97%AE%E9%A2%98/"
    >前端异常捕获问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/05/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2022-11-05T01:33:35.000Z" itemprop="datePublished">2022-11-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/">前端异常捕获</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（异常捕获）"><a href="#前端面试题大全（异常捕获）" class="headerlink" title="前端面试题大全（异常捕获）"></a>前端面试题大全（异常捕获）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><h4 id="什么是异常数据？"><a href="#什么是异常数据？" class="headerlink" title="什么是异常数据？"></a>什么是异常数据？</h4><p>异常数据，是指前端在操作页面的过程中，触发的执行异常或加载异常，此时浏览器会抛出来报错信息。</p>
<p>比如说你的前端代码用了个未声明的变量，此时控制台会打印出红色错误，告诉你报错原因。或者是接口请求出错了，在网络面板内也能查到异常情况，是请求发送的异常，还是接口响应的异常。</p>
<p>在我们实际的开发场景中，前端捕获的异常主要是分两个大类，接口异常 和 前端异常，我们分别看下这两大类异常怎么捕获。</p>
<h4 id="接口异常"><a href="#接口异常" class="headerlink" title="接口异常"></a>接口异常</h4><p>接口异常一定是在请求的时候触发。前端目前大部分的请求是用 axios 发起的，所以只要获取 axios 可能发生的异常即可。</p>
<p>如果你用 Promise 的写法，则用 .catch 捕获：</p>
<pre><code class="javascript">axios
  .post(&#39;/test&#39;)
  .then((res) =&gt; &#123;
    console.log(res);
  &#125;)
  .catch((err) =&gt; &#123;
    // err 就是捕获到的错误对象
    handleError(err);
  &#125;);
</code></pre>
<p>如果你用 async&#x2F;await 的写法，则用 try..catch.. 捕获：</p>
<pre><code class="javascript">async () =&gt; &#123;
  try &#123;
    let res = await axios.post(&#39;/test&#39;);
    console.log(res);
  &#125; catch (err) &#123;
    // err 就是捕获到的错误对象
    handleError(err);
  &#125;
&#125;;
</code></pre>
<p>当捕获到异常之后，统一交给 handleError 函数处理，这个函数会将接收到的异常进行处理，并调用 上报接口 将异常数据传到服务器，从而完成采集。</p>
<p>上面我们写的异常捕获，逻辑上是没问题的，实操起来就会发现第一道坎：页面这么多，难道每个请求都要包一层 catch 吗？</p>
<p>是啊，如果我们是新开发一个项目，在开始的时候就规定每个请求要包一层 catch 也无可厚非，但是如果是在一个已有的规模还不小的项目中接入前端监控，这时候在每个页面或每个请求 catch 显然是不现实的。</p>
<p>所以，为了最大程度地降低接入成本，减少侵入性，我们是用第二种方案：在 axios 拦截器中捕获异常。</p>
<p>前端项目，为了统一处理请求，比如 401 的跳转，或者全局错误提示，都会在全局写一个 axios 实例，为这个实例添加拦截器，然后在其他页面中直接导入这个实例使用，比如：</p>
<pre><code class="javascript">// 全局请求：src/request/axios.js
const instance = axios.create(&#123;
  baseURL: &#39;https://api.test.com&#39;
  timeout: 15000,
  headers: &#123;
    &#39;Content-Type&#39;: &#39;application/json&#39;,
  &#125;,
&#125;)
export default instance1
</code></pre>
<p>然后在具体的页面中这样发起请求：</p>
<pre><code class="javascript">// a 页面：src/page/a.jsx
import http from &#39;@/src/request/axios.js&#39;;
async () =&gt; &#123;
  let res = await http.post(&#39;/test&#39;);
  console.log(res);
&#125;;
</code></pre>
<p>这样的话，我们发现每个页面的请求都会走全局 axios 实例，所以我们只需要在全局请求的位置捕获异常即可，就不需要在每个页面捕获了，这样接入成本会大大降低。</p>
<p>按照这个方案，接下来我们在 src&#x2F;request&#x2F;axios.js 这个文件中动手实施。</p>
<h4 id="拦截器中捕获异常"><a href="#拦截器中捕获异常" class="headerlink" title="拦截器中捕获异常"></a>拦截器中捕获异常</h4><p>首先我们为 axios 添加响应拦截器：</p>
<pre><code class="javascript">// 响应拦截器
instance.interceptors.response.use(
  (response) =&gt; &#123;
    return response.data;
  &#125;,
  (error) =&gt; &#123;
    // 发生异常会走到这里
    if (error.response) &#123;
      let response = error.response;
      if (response.status &gt;= 400) &#123;
        handleError(response);
      &#125;
    &#125; else &#123;
      handleError(null);
    &#125;
    return Promise.reject(error);
  &#125;,
);
</code></pre>
<p>响应拦截器的第二个参数是在发生错误时执行的函数，参数就是异常。我们首先要判断是否存在 error.response，存在就说明接口有响应，也就是接口通了，但是返回错误；不存在则说明接口没通，请求一直挂起，多数是接口崩溃了。</p>
<p>如果有响应，首先获取状态码，根据状态码来判断什么时候需要收集异常。上面的判断方式简单粗暴，只要状态码大于 400 就视为一个异常，拿到响应数据，并执行上报逻辑。</p>
<p>如果没有响应，可以看作是接口超时异常，调用异常处理函数时传一个 null 即可。</p>
<h3 id="前端异常"><a href="#前端异常" class="headerlink" title="前端异常"></a>前端异常</h3><p>上面我们介绍了在 axios 拦截器中如何捕获接口异常，这部分我们再介绍如何捕获前端异常。</p>
<p>前端代码捕获异常，最常用的方式就是用 try..catch.. 了，任意同步代码块都可以放到 try 块中，只要发生异常就会执行 catch：</p>
<pre><code class="javascript">try &#123;
  // 任意同步代码
&#125; catch (err) &#123;
  console.log(err);
&#125;
</code></pre>
<p>上面说“任意同步代码”而不是“任意代码”，主要是普通的 Promise 写法 try..catch.. 是捕获不到的，只能用 .catch() 捕获，如：</p>
<pre><code class="javascript">try &#123;
  Promise.reject(new Error(&#39;出错了&#39;)).catch((err) =&gt; console.log(&#39;1：&#39;, err));
&#125; catch (err) &#123;
  console.log(&#39;2：&#39;, err);
&#125;
</code></pre>
<p>把这段代码丢进浏览器，打印结果是：</p>
<pre><code class="javascript">1： Error: 出错了1.
</code></pre>
<p>很明显只是 .catch 捕获到了异常。不过与上面接口异常的逻辑一样，这种方式处理当前页面异常没什么问题，但从整个应用来看，这样捕获异常侵入性强，接入成本高，所以我们的思路依然是全局捕获。</p>
<p>全局捕获 js 的异常也比较简单，用 window.addEventLinstener(‘error’) 即可：</p>
<pre><code class="javascript">// js 错误捕获
window.addEventListener(&#39;error&#39;, (error) =&gt; &#123;
  // error 就是js的异常
&#125;);
</code></pre>
<h4 id="为啥不用-window-onerror-？"><a href="#为啥不用-window-onerror-？" class="headerlink" title="为啥不用 window.onerror ？"></a>为啥不用 window.onerror ？</h4><p>这里很多小伙伴有疑问，为什么不用 window.onerror 全局监听呢？window.addEventLinstener(‘error’) 和 window.onerror 有什么区别呢？</p>
<p>首先这两个函数功能基本一致，都可以全局捕获 js 异常。但是有一类异常叫做 资源加载异常，就是在代码中引用了不存在的图片，js，css 等静态资源导致的异常，比如:</p>
<pre><code class="javascript">const loadCss = ()=&gt; &#123;
  let link = document.createElement(&#39;link&#39;)
  link.type = &#39;text/css&#39;
  link.rel = &#39;stylesheet&#39;
  link.href = &#39;https://baidu.com/15.css&#39;
  document.getElementsByTagName(&#39;head&#39;)[10].append(link)
&#125;
render() &#123;
  return &lt;div&gt;
    &lt;img src=&#39;./bbb.png&#39;/&gt;
    &lt;button onClick=&#123;loadCss&#125;&gt;加载样式&lt;button/&gt;
  &lt;/div&gt;
&#125;
</code></pre>
<p>上述代码中的 baidu.com&#x2F;15.css 和 bbb.png 是不存在的，JS 执行到这里肯定会报一个资源找不到的错误。但是默认情况下，上面两种 window 对象上的全局监听函数都监听不到这类异常。</p>
<p>因为资源加载的异常只会在当前元素触发，异常不会冒泡到 window，因此监听 window 上的异常是捕捉不到的。那怎么办呢？</p>
<p>如果你熟悉 DOM 事件你就会明白，既然冒泡阶段监听不到，那么在捕获阶段一定能监听到。</p>
<p>方法就是给 window.addEventListene 函数指定第三个参数，很简单就是 true，表示该监听函数会在捕获阶段执行，这样就能监听到资源加载异常了。</p>
<pre><code class="javascript">// 捕获阶段全局监听
window.addEventListene(
  &#39;error&#39;,
  (error) =&gt; &#123;
    if (error.target != window) &#123;
      console.log(error.target.tagName, error.target.src);
    &#125;
    handleError(error);
  &#125;,
  true,
);
</code></pre>
<p>上述方式可以很轻松的监听到图片加载异常，这就是为什么更推荐 window.addEventListene 的原因。不过要记得，第三个参数设为 true，监听事件捕获，就可以全局捕获到 JS 异常和资源加载异常。</p>
<p>需要特别注意，window.addEventListene 同样不能捕获 Promise 异常。不管是 Promise.then() 写法还是 async&#x2F;await 写法，发生异常时都不能捕获。</p>
<p>因此，我们还需要全局监听一个 unhandledrejection 函数来捕获未处理的 Promise 异常。</p>
<pre><code class="javascript">// promise 错误捕获
window.addEventListener(&#39;unhandledrejection&#39;, (error) =&gt; &#123;
  // 打印异常原因
  console.log(error.reason);
  handleError(error);
  // 阻止控制台打印
  error.preventDefault();
&#125;);
</code></pre>
<p>unhandledrejection 事件会在 Promise 发生异常并且没有指定 catch 的时候触发，相当于一个全局的 Promise 异常兜底方案。这个函数会捕捉到运行时意外发生的 Promise 异常，这对我们排错非常有用。</p>
<p>默认情况下，Promise 发生异常且未被 catch 时，会在控制台打印异常。如果我们想阻止异常打印，可以用上面的 error.preventDefault() 方法。</p>
<h4 id="异常处理函数"><a href="#异常处理函数" class="headerlink" title="异常处理函数"></a>异常处理函数</h4><p>前面我们在捕获到异常时调用了一个异常处理函数 handleError，所有的异常和上报逻辑统一在这个函数内处理，接下来我们实现这个函数。</p>
<pre><code class="javascript">const handleError = (error: any, type: 1 | 2) &#123;
  if(type == 1) &#123;
    // 处理接口异常
  &#125;
  if(type == 2) &#123;
    // 处理前端异常
  &#125;
&#125;
</code></pre>
<p>为了区分异常类型，函数新加了第二个参数 type 表示当前异常属于前端还是接口。在不同的场景中使用如下：</p>
<ul>
<li>处理前端异常：handleError(error, 1)。</li>
<li>处理接口异常：handleError(error, 2)。</li>
</ul>
<h3 id="处理接口异常"><a href="#处理接口异常" class="headerlink" title="处理接口异常"></a>处理接口异常</h3><p>处理接口异常，我们需要将拿到的 error 参数解析，然后取到需要的数据。接口异常一般需要的数据字段如下：</p>
<ul>
<li>code：http 状态码。</li>
<li>url：接口请求地址。</li>
<li>method：接口请求方法。</li>
<li>params：接口请求参数。</li>
<li>error：接口报错信息。</li>
</ul>
<p>这些字段都可以在 error 参数中获取，方法如下：</p>
<pre><code class="javascript">const handleError = (error: any, type: 1 | 2) &#123;
  if(type == 1) &#123;
    // 此时的 error 响应，它的 config 字段中包含请求信息
    let &#123; url, method, params, data &#125; = error.config
    let err_data = &#123;
       url, method,
       params: &#123; query: params, body: data &#125;,
       error: error.data?.message || JSON.stringify(error.data),
    &#125;)
  &#125;
&#125;
</code></pre>
<p>config 对象中的 params 表示 GET 请求的 query 参数，data 表示 POST 请求的 body 参数，所以我在处理参数的时候，将这两个参数合并为一个，用一个属性 params 来表示。</p>
<pre><code class="javascript">params: &#123; query: params, body: data &#125;
</code></pre>
<p>还有一个 error 属性表示错误信息，这个获取方式要根据你的接口返回格式来拿。要避免获取到接口可能返回的超长错误信息，多半是接口没处理，这样可能会导致写入数据失败，要提前与后台规定好。</p>
<h3 id="处理前端异常"><a href="#处理前端异常" class="headerlink" title="处理前端异常"></a>处理前端异常</h3><p>前端异常异常大多数就是 js 异常，异常对应到 js 的 Error 对象，在处理之前，我们先看 Error 有哪几种类型：</p>
<ul>
<li>ReferenceError：引用错误。</li>
<li>RangeError：超出有效范围。</li>
<li>TypeError：类型错误。</li>
<li>URIError：URI 解析错误。</li>
</ul>
<p>这几类异常的引用对象都是 Error，因此可以这样获取：</p>
<pre><code class="javascript">const handleError = (error: any, type: 1 | 2) &#123;
  if(type == 2) &#123;
    let err_data = null
    // 监测 error 是否是标准类型
    if(error instanceof Error) &#123;
      let &#123; name, message &#125; = error
      err_data = &#123;
        type: name,
        error: message
      &#125;
    &#125; else &#123;
      err_data = &#123;
        type: &#39;other&#39;,
        error: JSON.strigify(error)
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>上述判断中，首先判断异常是否是 Error 的实例。事实上绝大部分的代码异常都是标准的 JS Error，但我们这里还是判断一下，如果是的话直接获取异常类型和异常信息，不是的话将异常类型设置为 other 即可。</p>
<p>我们随便写一个异常代码，看一下捕获的结果：</p>
<pre><code class="javascript">function test() &#123;
  console.aaa(&#39;ccc&#39;);
&#125;
test();
</code></pre>
<p>然后捕获到的异常是这样的：</p>
<pre><code class="javascript">const handleError = (error: any) =&gt; &#123;
  if (error instanceof Error) &#123;
    let &#123; name, message &#125; = error;
    console.log(name, message);
    // 打印结果：TypeError console.aaa is not a function
  &#125;
&#125;;
</code></pre>
<h4 id="获取环境数据"><a href="#获取环境数据" class="headerlink" title="获取环境数据"></a>获取环境数据</h4><p>获取环境数据的意思是，不管是接口异常还是前端异常，除了异常本身的数据之外，我们还需要一些其他信息来帮助我们更快更准的定位到哪里出错了。</p>
<p>这类数据我们称之为 “环境数据”，就是触发异常时所在的环境。比如是谁在哪个页面的哪个地方触发的错误，有了这些，我们就能马上找到错误来源，再根据异常信息解决错误。</p>
<p>环境数据至少包括下面这些：</p>
<ul>
<li>app：应用的名称&#x2F;标识。</li>
<li>env：应用环境，一般是开发，测试，生产。</li>
<li>version：应用的版本号。</li>
<li>user_id：触发异常的用户 ID。</li>
<li>user_name：触发异常的用户名。</li>
<li>page_route：异常的页面路由。</li>
<li>page_title：异常的页面名称。</li>
</ul>
<p>app 和 version 都是应用配置，可以判断异常出现在哪个应用的哪个版本。这两个字段我建议直接获取 package.json 下的 name 和 version 属性，在应用升级的时候，及时修改 version 版本号即可。</p>
<h3 id="Vue和React异常处理"><a href="#Vue和React异常处理" class="headerlink" title="Vue和React异常处理"></a>Vue和React异常处理</h3><blockquote>
<p>现在越来越多的项目开始使用前端框架，在MVVM框架中如果你一如既往的想使用window.onerror来捕获异常，那么很可能会竹篮打水一场空，或许根本捕获不到，因为你的异常信息被框架自身的异常机制捕获了。</p>
</blockquote>
<p>比如Vue 2.x中我们应该这样捕获全局异常：</p>
<pre><code class="js">Vue.config.errorHandler = function (err, vm, info) &#123;
    let &#123; 
        message, // 异常信息
        name, // 异常名称
        script,  // 异常脚本url
        line,  // 异常行号
        column,  // 异常列号
        stack  // 异常堆栈信息
    &#125; = err;

    // vm为抛出异常的 Vue 实例
    // info为 Vue 特定的错误信息，比如错误所在的生命周期钩子
&#125;
</code></pre>
<blockquote>
<p>目前script、line、column这3个信息打印出来是undefined，不过这些信息在stack中都可以找到，可以通过正则匹配去进行获取，然后进行上报。</p>
<p>同样的在react也提供了异常处理的方式，在 React 16.x 版本中引入了 Error Boundary：</p>
</blockquote>
<pre><code class="js">class ErrorBoundary extends React.Component &#123;
    constructor(props) &#123;
        super(props);
        this.state = &#123; hasError: false &#125;;
    &#125;

    componentDidCatch(error, info) &#123;
        this.setState(&#123; hasError: true &#125;);

        // 将异常信息上报给服务器
        logErrorToMyService(error, info); 
    &#125;

    render() &#123;
        if (this.state.hasError) &#123;
            return &#39;出错了&#39;;
        &#125;

        return this.props.children;
    &#125;
&#125;
</code></pre>
<p>然后我们就可以这样使用该组件：</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/711309.html">https://www.51cto.com/article/711309.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7072179884247744526">https://juejin.cn/post/7072179884247744526</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试题大全前端工程化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"
    >前端面试题大全前端工程化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" class="article-date">
  <time datetime="2022-11-04T03:25:24.000Z" itemprop="datePublished">2022-11-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（前端工程化）"><a href="#前端面试题大全（前端工程化）" class="headerlink" title="前端面试题大全（前端工程化）"></a>前端面试题大全（前端工程化）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="♥︎-♥︎-♥︎-什么是-bundle-什么是-chunk，什么是module？"><a href="#♥︎-♥︎-♥︎-什么是-bundle-什么是-chunk，什么是module？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是 bundle, 什么是 chunk，什么是module？"></a>♥︎ ♥︎ ♥︎ 什么是 bundle, 什么是 chunk，什么是module？</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>bundle</code>、<code>module</code>、<code>chunk</code> 都是 webpack 中的术语，下面就一个一个介绍他们的定义是什么，怎么产生的。</p>
<h5 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h5><p>Bundle是由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本。 Bundle 分离（Bundle Splitting）:这个流程提供了一个优化 build 的方法，允许 webpack 为应用程序生成多个 bundle。最终效果是，当其他某些 bundle 的改动时，彼此独立的另一些 bundle 都可以不受到影响，减少需要重新发布的代码量，因此由客户端重新下载并利用浏览器缓存。</p>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h5><p>模块（Module）提供比较完整程序接触面（surface area）更小的离散功能块。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。 模块解析（Module Resolution）一个模块可以作为另一个模块的依赖模块，resolver 是一个库（libary）用于帮助找不到模块的绝对路径，模块将在resolve.modules中指定的所有目录内搜索。</p>
<h5 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h5><p>Chunk这是 webpack 特定的术语被用在内部来管理 building 过程。bundle 是由 chunk 组成，其中有几种类型（例如，入口 chunk(entry chunk)和子 chunk(child chunk)）。通常 chunk 会直接对应所输出的 bundle，但是有一些配置并不会产生一对一的关系。 代码分离（Code Splitting）指将代码分离到每个 bundles&#x2F;chunks 里面，你可以按需加载，而不是加载一个包含全部的 bundle。 配置（Configuration）webpack 的配置文件是一个普通的 JavaScript 文件，它导出为一个对象。然后由 webpack 根据这个对象定义的属性进行处理。</p>
<h4 id="Bundle-VS-Chunk-VS-Module"><a href="#Bundle-VS-Chunk-VS-Module" class="headerlink" title="Bundle VS Chunk VS Module"></a>Bundle VS Chunk VS Module</h4><p>我们从定义和时期来说：</p>
<ul>
<li>“模块”<code>(module)</code>的概念大家都比较熟悉，如 <code>CommonJS 模块</code>、<code>AMD</code>、<code>ES6 Modules</code> 模块</li>
<li><code>chunk</code> 表示打包的时候产生得模块，由他来组成 <code>bundle</code></li>
<li>打包完成的源代码</li>
</ul>
<p>我们现在就只创建一个能编译<code>js</code>的<code>webpack</code>配置，步骤如下：</p>
<ol>
<li>创建一个空文件夹，并且在当文件夹中打开 <code>bash or cmd</code>。</li>
<li><code>npm init -y</code> 生成<code>package.json</code>。</li>
<li>如果你安装了<code>cnpm or yarn</code> 就执行 <code>cnpm i webpack webpack-cli -D</code>, 安装<code>webpack</code>的包。</li>
<li>创建<code>src</code>，在<code>src</code>内部创建<code>chunk0.js</code>、<code>chunk1.js</code>、<code>common.js</code>、<code>index.js</code>、<code>style.css</code>，并且编写内部代码</li>
<li>在项目根目录创建 <code>webpack.config.js</code></li>
<li>直接在<code>cmd</code>中运行 <code>webpack</code></li>
</ol>
<p>下面是代码 </p>
<p>chunk0.js</p>
<pre><code class="javascript">export default function add(a, b) &#123;
  return a + b;
&#125;
</code></pre>
<p>chunk1.js</p>
<pre><code class="javascript">export default function flow() &#123;
  return &quot;flow&quot;;
&#125;
</code></pre>
<p>common.js</p>
<pre><code class="javascript">export default function commonJs() &#123;
  return &quot;commonJs&quot;;
&#125;
</code></pre>
<p>index.js</p>
<pre><code class="javascript">import add from &quot;./chunk0.js&quot;;
import commonJs from &quot;./common&quot;;
console.log(add(1, 2));
console.log(commonJs());
</code></pre>
<p>webpack.config.js</p>
<pre><code class="java">module.exports = &#123;
  mode: &quot;production&quot;, // 如果不添加就会警告
  entry: &#123;
    index: &quot;./src/index.js&quot;, // 一个入口文件
    chunk1: &quot;./src/chunk1.js&quot; // 两一个入口文件
  &#125;,
  output: &#123;
    filename: &quot;[name].bundle.js&quot; // 出口文件
  &#125;
&#125;;
</code></pre>
<p>运行的效果如下</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image-20221104082742567.png"></p>
<p>通过上面的代码知道，<code>module</code> 就是没有被编译之前的代码，通过 <code>webpack</code> 的根据文件引用关系生成 <code>chunk</code> 文件，webpack 处理好 <code>chunk</code> 文件后，生成运行在浏览器中的代码 <code>bundle</code>。</p>
<h3 id="♥︎-♥︎-♥︎-hash-chunkhash-contenthash三者区别"><a href="#♥︎-♥︎-♥︎-hash-chunkhash-contenthash三者区别" class="headerlink" title="♥︎ ♥︎ ♥︎ hash chunkhash contenthash三者区别"></a>♥︎ ♥︎ ♥︎ hash chunkhash contenthash三者区别</h3><h4 id="一、Webpack与hash算法"><a href="#一、Webpack与hash算法" class="headerlink" title="一、Webpack与hash算法"></a>一、Webpack与hash算法</h4><p>在使用Webpack对构建的时候，Webpack会根据所有的文件内容计算出一个特殊的字符串。只要有文件的内容变化了，Webpack就会计算出一个新的特殊字符串。</p>
<p>Webpack在根据文件内容计算出一个特殊字符串的时候，使用的就是hash算法，这个特殊字符串一般叫做hash值。</p>
<p>我们一般取计算出的特殊字符串的前八位作为文件名的一部分，因为hash算法计算出的前八位基本可以保证唯一性了。</p>
<p>在Webpack里，我们通常用[hash:8]这种形式表示取hash值的前八位，例如在Webpack配置文件中，我们用 filename: ‘jQuery-[hash:8].js’。</p>
<h4 id="二、webpack中hash、chunkhash和contenthash的区别"><a href="#二、webpack中hash、chunkhash和contenthash的区别" class="headerlink" title="二、webpack中hash、chunkhash和contenthash的区别"></a>二、webpack中hash、chunkhash和contenthash的区别</h4><p>Webpack通过对文件进行hash算法获得的hash值，除了有hash，还有chunkhash和contenthash，那么这三者有什么不同呢？</p>
<p>首先，hash、chunkhash和contenthash这三者都是根据文件内容计算出的hash值，只是它们所计算的文件不一样。</p>
<p>hash是根据打包中所有的文件计算出的hash值。在一次打包中，所有出口文件的filename获得的[hash]都是一样的。</p>
<p>chunkhash是根据打包过程中当前chunk计算出的hash值。如果Webpack配置是多入口配置，那么通常会生成多个chunk，每个chunk对应的出口filename获得的[chunkhash]是不一样的。这样可以保证打包后每一个JS文件名都不一样（这么说不太严谨，但有助于理解）。</p>
<p>Webpack配置文件如下，第一次打包filename取值为’[name]-[hash:8].js’，第二次为’[name]-[chunkhash:8].js’。</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
module.exports = &#123;
    entry: &#123;
        app1: &#39;./a.js&#39;,
        app2: &#39;./b.js&#39;,
        app3: &#39;./c.js&#39;,
&#125;,
output: &#123;
path: path.resolve(__dirname, &#39;&#39;),
filename: &#39;[name]-[hash:8].js&#39;
// filename: &#39;[name]-[chunkhash:8].js&#39;
&#125;,
mode: &#39;none&#39;
&#125;;
</code></pre>
<p>contenthash有点像chunkhash，是根据打包时CSS内容计算出的hash值。一般在使用提取CSS的插件的时候，我们使用contenthash。例如下面的配置，我们生成的CSS文件名可能会是main.3aa2e3c6.css。</p>
<pre><code class="javascript">plugins:[
new miniExtractPlugin(&#123;
        filename: &#39;main.[contenthash:8].css&#39;
&#125;)
]
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Webpack中hash、chunkhash和contenthash主要与浏览器缓存行为有关。浏览器在初次请求服务端资源的时候，服务器给JS、CSS和图片等资源一个较长的缓存时间，我们通过给资源名称增加hash值来控制浏览器是否继续使用本地缓存。hash、chunkhash和contenthash这三者都是根据文件内容计算出的hash值，[hash]是根据全部参与打包的文件计算出来的，[chunkhash]是根据当前打包的chunk计算出来的，[contenthash]是CSS文件的。</p>
<h3 id="♥︎-♥︎-♥︎-你知道什么是脚手架吗？"><a href="#♥︎-♥︎-♥︎-你知道什么是脚手架吗？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你知道什么是脚手架吗？"></a>♥︎ ♥︎ ♥︎ 你知道什么是脚手架吗？</h3><p>脚手架的概念和作用：就是拥有完整的开发环境，帮助我们快速的生成一套既定的项目架构、文件、配置。使用者只需要专注自己的业务代码即可，不需要使用者单独配置 </p>
<p>脚手架的构成：常见的脚手架的开发环境主要分为三种模式：生产模式，开发模式，测试模式。以及需要配置完整的路由系统(vue-router,react-router-dom)，和状态管理系统(vuex,redux)才能保证开发环境的完整性 </p>
<p>常见的脚手架：Vue-cli,Creat-React-app,umi-app</p>
<h3 id="♥︎-♥︎-♥︎-你对webpack的理解？解决了什么问题？"><a href="#♥︎-♥︎-♥︎-你对webpack的理解？解决了什么问题？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你对webpack的理解？解决了什么问题？"></a>♥︎ ♥︎ ♥︎ 你对webpack的理解？解决了什么问题？</h3><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p><code>Webpack</code> 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p>
<h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的<code> JS</code> 文件中</p>
<p>约定每个文件是一个独立的模块，然后再将这些<code>js</code>文件引入到页面，一个<code>script</code>标签对应一个模块，然后调用模块化的成员</p>
<pre><code class="ini">&lt;script src=&quot;module-a.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;module-b.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题</p>
<p>项目一旦变大，上述问题会尤其明显</p>
<p>随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p>
<pre><code class="javascript">window.moduleA = &#123;
  method1: function () &#123;
    console.log(&#39;moduleA#method1&#39;)
  &#125;
&#125;
</code></pre>
<p>这种方式也并没有解决第一种方式的依赖等问题</p>
<p>再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下</p>
<pre><code class="javascript">// module-a.js
(function ($) &#123;
  var name = &#39;module-a&#39;

  function method1 () &#123;
    console.log(name + &#39;#method1&#39;)
    $(&#39;body&#39;).animate(&#123; margin: &#39;200px&#39; &#125;)
  &#125;
    
  window.moduleA = &#123;
    method1: method1
  &#125;
&#125;)(jQuery)
</code></pre>
<p>上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过<code>script</code>标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦</p>
<p>理想的解决方式是，在页面中引入一个<code>JS</code>入口文件，其余用到的模块可以通过代码控制，按需加载进来</p>
<p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS </code>、<code>ES Modules</code></p>
<h4 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h4><p>从后端渲染的<code>JSP</code>、<code>PHP</code>，到前端原生<code>JavaScript</code>，再到<code>jQuery</code>开发，再到目前的三大框架<code>Vue</code>、<code>React</code>、<code>Angular</code></p>
<p>开发方式，也从<code>javascript</code>到后面的<code>es5</code>、<code>es6、7、8、9、10</code>，再到<code>typescript</code>，包括编写<code>CSS</code>的预处理器<code>less</code>、<code>scss</code>等</p>
<p>现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：</p>
<ul>
<li>需要通过模块化的方式来开发</li>
<li>使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码</li>
<li>监听文件的变化来并且反映到浏览器上，提高开发的效率</li>
<li>JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题</li>
<li>开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化</li>
</ul>
<p>而<code>webpack</code>恰巧可以解决以上问题</p>
<h4 id="三、是什么"><a href="#三、是什么" class="headerlink" title="三、是什么"></a>三、是什么</h4><p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具</p>
<ul>
<li>静态模块</li>
</ul>
<p>这里的静态模块指的是开发阶段，可以被 <code>webpack</code> 直接引用的资源（可以直接被获取打包进<code>bundle.js</code>的资源）</p>
<p>当 <code>webpack </code>处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限<code>js</code>文件），并生成一个或多个 <code>bundle</code></p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39636531393461302d613537382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="webpack的能力："><a href="#webpack的能力：" class="headerlink" title="webpack的能力："></a><code>webpack</code>的能力：</h5><p>编译代码能力，提高效率，解决浏览器兼容问题<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63356332643336302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"><br>模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64333036643236302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"><br>万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65336335613034302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-webpack的核心思想是什么"><a href="#♥︎-♥︎-♥︎-webpack的核心思想是什么" class="headerlink" title="♥︎ ♥︎ ♥︎ webpack的核心思想是什么"></a>♥︎ ♥︎ ♥︎ webpack的核心思想是什么</h3><p>万物皆模块：在webpacck的世界中，其他任何资源都可以当做模块的方式引入 </p>
<p>代码分割：webapp 的优化关键在于代码体积，当应用体积增大，实现代码的按需加载是刚需，这也是 webpack 出现的根本原因 </p>
<p>可定制化：任何一个工具都不可能解决所有问题，提供解决方案才是最可行的，webpack基于可定制化的理念构建，通过插件系统，配置文件，可实现大型项目的定制需求</p>
<h3 id="♥︎-♥︎-♥︎-说说webpack的构建流程"><a href="#♥︎-♥︎-♥︎-说说webpack的构建流程" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说webpack的构建流程?"></a>♥︎ ♥︎ ♥︎ 说说webpack的构建流程?</h3><h4 id="一、运行流程"><a href="#一、运行流程" class="headerlink" title="一、运行流程"></a>一、运行流程</h4><p><code>webpack</code> 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来</p>
<p>在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条<code>webpack</code>机制中，去改变<code>webpack</code>的运作，使得整个系统扩展性良好</p>
<p>从启动到结束会依次执行以下三大步骤：</p>
<ul>
<li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li>编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>
<li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li>
</ul>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62353636643430302d613635382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h5><p>从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数</p>
<p>配置文件默认下为<code>webpack.config.js</code>，也或者通过命令的形式指定配置文件，主要作用是用于激活<code>webpack</code>的加载项和插件</p>
<p>关于文件配置内容分析，如下注释：</p>
<pre><code class="javascript">var path = require(&#39;path&#39;);
var node_modules = path.resolve(__dirname, &#39;node_modules&#39;);
var pathToReact = path.resolve(node_modules, &#39;react/dist/react.min.js&#39;);

module.exports = &#123;
  // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。
  entry: &#39;./path/to/my/entry/file.js&#39;，
  // 文件路径指向(可加快打包过程)。
  resolve: &#123;
    alias: &#123;
      &#39;react&#39;: pathToReact
    &#125;
  &#125;,
  // 生成文件，是模块构建的终点，包括输出文件与输出路径。
  output: &#123;
    path: path.resolve(__dirname, &#39;build&#39;),
    filename: &#39;[name].js&#39;
  &#125;,
  // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。
  module: &#123;
    loaders: [
      &#123;
        test: /\.js$/,
        loader: &#39;babel&#39;,
        query: &#123;
          presets: [&#39;es2015&#39;, &#39;react&#39;]
        &#125;
      &#125;
    ],
    noParse: [pathToReact]
  &#125;,
  // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
&#125;;
webpack` 将 `webpack.config.js` 中的各个配置项拷贝到 `options` 对象中，并加载用户配置的 `plugins
</code></pre>
<p>完成上述步骤之后，则开始初始化<code>Compiler</code>编译对象，该对象掌控者<code>webpack</code>声明周期，不执行具体的任务，只是进行一些调度工作</p>
<pre><code class="javascript">class Compiler extends Tapable &#123;
    constructor(context) &#123;
        super();
        this.hooks = &#123;
            beforeCompile: new AsyncSeriesHook([&quot;params&quot;]),
            compile: new SyncHook([&quot;params&quot;]),
            afterCompile: new AsyncSeriesHook([&quot;compilation&quot;]),
            make: new AsyncParallelHook([&quot;compilation&quot;]),
            entryOption: new SyncBailHook([&quot;context&quot;, &quot;entry&quot;])
            // 定义了很多不同类型的钩子
        &#125;;
        // ...
    &#125;
&#125;

function webpack(options) &#123;
  var compiler = new Compiler();
  ...// 检查options,若watch字段为true,则开启watch线程
  return compiler;
&#125;
...
</code></pre>
<p><code>Compiler</code> 对象继承自 <code>Tapable</code>，初始化时定义了很多钩子函数</p>
<h5 id="编译构建流程"><a href="#编译构建流程" class="headerlink" title="编译构建流程"></a>编译构建流程</h5><p>根据配置中的 <code>entry</code> 找出所有的入口文件</p>
<pre><code class="javascript">module.exports = &#123;
  entry: &#39;./src/file.js&#39;
&#125;
</code></pre>
<p>初始化完成后会调用<code>Compiler</code>的<code>run</code>来真正启动<code>webpack</code>编译构建流程，主要流程如下：</p>
<ul>
<li><code>compile</code> 开始编译</li>
<li><code>make</code> 从入口点分析模块及其依赖的模块，创建这些模块对象</li>
<li><code>build-module</code> 构建模块</li>
<li><code>seal</code> 封装构建结果</li>
<li><code>emit</code> 把各个chunk输出到结果文件</li>
</ul>
<h5 id="compile-编译"><a href="#compile-编译" class="headerlink" title="compile 编译"></a>compile 编译</h5><p>执行了<code>run</code>方法后，首先会触发<code>compile</code>，主要是构建一个<code>Compilation</code>对象</p>
<p>该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象</p>
<h5 id="make-编译模块"><a href="#make-编译模块" class="headerlink" title="make 编译模块"></a>make 编译模块</h5><p>当完成了上述的<code>compilation</code>对象后，就开始从<code>Entry</code>入口文件开始读取，主要执行<code>_addModuleChain()</code>函数，如下：</p>
<pre><code class="javascript">_addModuleChain(context, dependency, onModule, callback) &#123;
   ...
   // 根据依赖查找对应的工厂函数
   const Dep = /** @type &#123;DepConstructor&#125; */ (dependency.constructor);
   const moduleFactory = this.dependencyFactories.get(Dep);
   
   // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象
   moduleFactory.create(&#123;
       dependencies: [dependency]
       ...
   &#125;, (err, module) =&gt; &#123;
       ...
       const afterBuild = () =&gt; &#123;
        this.processModuleDependencies(module, err =&gt; &#123;
         if (err) return callback(err);
         callback(null, module);
           &#125;);
    &#125;;
       
       this.buildModule(module, false, null, null, err =&gt; &#123;
           ...
           afterBuild();
       &#125;)
   &#125;)
&#125;
</code></pre>
<p>过程如下：</p>
<p><code>_addModuleChain</code>中接收参数<code>dependency</code>传入的入口依赖，使用对应的工厂函数<code>NormalModuleFactory.create</code>方法生成一个空的<code>module</code>对象</p>
<p>回调中会把此<code>module</code>存入<code>compilation.modules</code>对象和<code>dependencies.module</code>对象中，由于是入口文件，也会存入<code>compilation.entries</code>中</p>
<p>随后执行<code>buildModule</code>进入真正的构建模块<code>module</code>内容的过程</p>
<h5 id="build-module-完成模块编译"><a href="#build-module-完成模块编译" class="headerlink" title="build module 完成模块编译"></a>build module 完成模块编译</h5><p>这里主要调用配置的<code>loaders</code>，将我们的模块转成标准的<code>JS</code>模块</p>
<p>在用<code> Loader</code> 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 <code>Webpack </code>后面对代码的分析</p>
<p>从配置的入口模块开始，分析其 <code>AST</code>，当遇到<code>require</code>等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</p>
<h5 id="输出流程"><a href="#输出流程" class="headerlink" title="输出流程"></a>输出流程</h5><h5 id="seal-输出资源"><a href="#seal-输出资源" class="headerlink" title="seal 输出资源"></a>seal 输出资源</h5><p><code>seal</code>方法主要是要生成<code>chunks</code>，对<code>chunks</code>进行一系列的优化操作，并生成要输出的代码</p>
<p><code>webpack</code> 中的 <code>chunk</code> ，可以理解为配置在 <code>entry</code> 中的模块，或者是动态引入的模块</p>
<p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表</p>
<h5 id="emit-输出完成"><a href="#emit-输出完成" class="headerlink" title="emit 输出完成"></a>emit 输出完成</h5><p>在确定好输出内容后，根据配置确定输出的路径和文件名</p>
<pre><code class="javascript">output: &#123;
    path: path.resolve(__dirname, &#39;build&#39;),
        filename: &#39;[name].js&#39;
&#125;
</code></pre>
<p>在 <code>Compiler</code> 开始生成文件前，钩子 <code>emit</code> 会被执行，这是我们修改最终文件的最后一个机会</p>
<p>从而<code>webpack</code>整个打包过程则结束了</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64373766633536302d613635382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-Loader和Plugin的区别"><a href="#♥︎-♥︎-♥︎-Loader和Plugin的区别" class="headerlink" title="♥︎ ♥︎ ♥︎  Loader和Plugin的区别"></a>♥︎ ♥︎ ♥︎  Loader和Plugin的区别</h3><h4 id="loader是一个转换器"><a href="#loader是一个转换器" class="headerlink" title="loader是一个转换器"></a>loader是一个转换器</h4><p>1、用于对模块源码文件的预编译和转换，，loader描述了webpack如何处理非javascript模块。</p>
<p>2、没有loader，构建的打包过程无法顺利完成</p>
<p>3、loader作用在打包前</p>
<p>4、将A文件转换为B文件，操作的是文件，比如将A.scss转换为A.css，是单纯的文件转换过程</p>
<h4 id="Plugin是插件扩展器"><a href="#Plugin是插件扩展器" class="headerlink" title="Plugin是插件扩展器"></a>Plugin是插件扩展器</h4><p>1、plugin构建过程更完整的补充和优化，如使用new UglifyJsPlugin(),new CssMinimizerPlugin()压缩js和css</p>
<p>2、没有plugin，文件的打包过程可以完成</p>
<p>3、plugin作用于整个打包过程，</p>
<p>4、针对webpack的打包过程，他不直接操作文件，而是基于事件机制工作，会监听webpack打包过程的事件钩子，执行任务，通过事件钩子拦截webpack的执行。</p>
<h3 id="♥︎-♥︎-♥︎-有哪些常见的Loader"><a href="#♥︎-♥︎-♥︎-有哪些常见的Loader" class="headerlink" title="♥︎ ♥︎ ♥︎ 有哪些常见的Loader"></a>♥︎ ♥︎ ♥︎ 有哪些常见的Loader</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>loader</code> 用于对模块的”源代码”进行转换，在 <code>import</code> 或”加载”模块时预处理文件</p>
<p><code>webpack</code>做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。如下图所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37623864393634302d613666662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在<code>webpack</code>内部中，任何文件都是模块，不仅仅只是<code>js</code>文件</p>
<p>默认情况下，在遇到<code>import</code>或者<code>load</code>加载模块的时候，<code>webpack</code>只支持对<code>js</code>文件打包</p>
<p>像<code>css</code>、<code>sass</code>、<code>png</code>等这些类型的文件的时候，<code>webpack</code>则无能为力，这时候就需要配置对应的<code>loader</code>进行文件内容的解析</p>
<p>在加载模块的时候，执行顺序如下：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39633263343362302d613666662d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>当 <code>webpack</code> 碰到不识别的模块的时候，<code>webpack</code> 会在配置的中查找该文件解析规则</p>
<p>关于配置<code>loader</code>的方式有三种：</p>
<ul>
<li>配置方式（推荐）：在 webpack.config.js文件中指定 loader</li>
<li>内联方式：在每个 import 语句中显式指定 loader</li>
<li>CLI 方式：在 shell 命令中指定它们</li>
</ul>
<h5 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h5><p>关于<code>loader</code>的配置，我们是写在<code>module.rules</code>属性中，属性介绍如下：</p>
<ul>
<li><code>rules</code>是一个数组的形式，因此我们可以配置很多个<code>loader</code></li>
<li>每一个<code>loader</code>对应一个对象的形式，对象属性<code>test</code> 为匹配的规则，一般情况为正则表达式</li>
<li>属性<code>use</code>针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</li>
</ul>
<p>代码编写，如下形式：</p>
<pre><code class="javascript">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        test: /\.css$/,
        use: [
          &#123; loader: &#39;style-loader&#39; &#125;,
          &#123;
            loader: &#39;css-loader&#39;,
            options: &#123;
              modules: true
            &#125;
          &#125;,
          &#123; loader: &#39;sass-loader&#39; &#125;
        ]
      &#125;
    ]
  &#125;
&#125;;
</code></pre>
<h4 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h4><p>这里继续拿上述代码，来讲讲<code>loader</code>的特性</p>
<p>从上述代码可以看到，在处理<code>css</code>模块的时候，<code>use</code>属性中配置了三个<code>loader</code>分别处理<code>css</code>文件</p>
<p>因为<code>loader </code>支持链式调用，链中的每个<code>loader</code>会处理之前已处理过的资源，最终变为<code>js</code>代码。顺序为相反的顺序执行，即上述执行方式为<code>sass-loader</code>、<code>css-loader</code>、<code>style-loader</code></p>
<p>除此之外，<code>loader</code>的特性还有如下：</p>
<ul>
<li>loader 可以是同步的，也可以是异步的</li>
<li>loader 运行在 Node.js 中，并且能够执行任何操作</li>
<li>除了常见的通过 <code>package.json</code> 的 <code>main</code> 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 <code>loader</code> 字段直接引用一个模块</li>
<li>插件(plugin)可以为 loader 带来更多特性</li>
<li>loader 能够产生额外的任意文件</li>
</ul>
<p>可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和更多其他特性</p>
<h4 id="三、常见的loader"><a href="#三、常见的loader" class="headerlink" title="三、常见的loader"></a>三、常见的loader</h4><p>在页面开发过程中，我们经常性加载除了<code>js</code>文件以外的内容，这时候我们就需要配置响应的<code>loader</code>进行加载</p>
<p>常见的<code>loader</code>如下：</p>
<ul>
<li>style-loader: 将css添加到DOM的内联样式标签style里</li>
<li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li>
<li>less-loader: 处理less</li>
<li>sass-loader: 处理sass</li>
<li>postcss-loader: 用postcss来处理CSS</li>
<li>autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss</li>
<li>file-loader: 分发文件到output目录并返回相对路径</li>
<li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li>
<li>html-minify-loader: 压缩HTML</li>
<li>babel-loader :用babel来转换ES6文件到ES</li>
</ul>
<p>下面给出一些常见的<code>loader</code>的使用：</p>
<h5 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h5><p>分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p>
<pre><code class="javascript">npm install --save-dev css-loader
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: &#123;
      loader: &quot;css-loader&quot;,
      options: &#123;
     // 启用/禁用 url() 处理
     url: true,
     // 启用/禁用 @import 处理
     import: true,
        // 启用/禁用 Sourcemap
        sourceMap: false
      &#125;
    &#125;
 &#125;
]
</code></pre>
<p>如果只通过<code>css-loader</code>加载文件，这时候页面代码设置的样式并没有生效</p>
<p>原因在于，<code>css-loader</code>只是负责将<code>.css</code>文件进行一个解析，而并不会将解析后的<code>css</code>插入到页面中</p>
<p>如果我们希望再完成插入<code>style</code>的操作，那么我们还需要另外一个<code>loader</code>，就是<code>style-loader</code></p>
<h5 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h5><p>把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到页面的 <code>head</code> 中</p>
<pre><code class="javascript">npm install --save-dev style-loader
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;]
 &#125;
]
</code></pre>
<p>同一个任务的 <code>loader</code> 可以同时挂载多个，处理顺序为：从右到左，从下往上</p>
<h5 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h5><p>开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高，这里需要使用<code>less-loader</code></p>
<pre><code class="javascript">npm install less-loader -D
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;,&quot;less-loader&quot;]
 &#125;
]
</code></pre>
<h5 id="raw-loader"><a href="#raw-loader" class="headerlink" title="raw-loader"></a>raw-loader</h5><p>在 <code>webpack </code>中通过 <code>import </code>方式导入文件内容，该<code>loader </code>并不是内置的，所以首先要安装</p>
<pre><code class="shell">npm install --save-dev raw-loader
</code></pre>
<p>然后在 webpack.config.js 中进行配置</p>
<pre><code class="javascript">module.exports = &#123;  
...,  
module: &#123;      
rules: [      
&#123;        
test: /\.(txt|md)$/,  
use: &#39;raw-loader&#39;   
&#125;   
] &#125;&#125;
</code></pre>
<h5 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h5><p>把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串)</p>
<pre><code class="javascript">npm install --save-dev file-loader
rules: [  ..., &#123;  
test: /\.(png|jpe?g|gif)$/,    
use: &#123;      
loader: &quot;file-loader&quot;,  
options: &#123;       
// placeholder 占位符 [name] 源资源模块的名称        
// [ext] 源资源模块的后缀       
name: &quot;[name]_[hash].[ext]&quot;,        //打包后的存放位置        
outputPath: &quot;./images&quot;,        // 打包后文件的 url        
publicPath: &#39;./images&#39;,      &#125;    &#125; &#125;]
</code></pre>
<h5 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h5><p>可以处理理 <code>file-loader</code> 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code> 格式的字符串，并打包到 <code>js</code> 中，对小体积的图片比较合适，大图片不合适。</p>
<pre><code class="javascript">npm install --save-dev url-loader
rules: [  ..., &#123;  
        test: /\.(png|jpe?g|gif)$/,    
        use: &#123;     
        loader: &quot;url-loader&quot;,      
        options: &#123;        
        // placeholder 占位符 [name] 源资源模块的名称        
        // [ext] 源资源模块的后缀        
        name: &quot;[name]_[hash].[ext]&quot;,        //打包后的存放位置        
        outputPath: &quot;./images&quot;        // 打包后文件的 url        
        publicPath: &#39;./images&#39;,        // 小于 100 字节转成 base64 格式        limit: 100      &#125;    &#125; &#125;]
</code></pre>
<h3 id="♥︎-♥︎-♥︎-有哪些常见的Plugin"><a href="#♥︎-♥︎-♥︎-有哪些常见的Plugin" class="headerlink" title="♥︎ ♥︎ ♥︎ 有哪些常见的Plugin"></a>♥︎ ♥︎ ♥︎ 有哪些常见的Plugin</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>Plugin</code>（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能</p>
<p>是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据</p>
<p><code>webpack</code>中的<code>plugin</code>也是如此，<code>plugin</code>赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 <code>webpack</code> 的不同阶段（钩子 &#x2F; 生命周期），贯穿了<code>webpack</code>整个编译周期</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39613034656334302d613763322d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>目的在于解决<code>loader</code> 无法实现的其他事</p>
<h5 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h5><p>这里讲述文件的配置方式，一般情况，通过配置文件导出对象中<code>plugins</code>属性传入<code>new</code>实例对象。如下所示：</p>
<pre><code class="javascript">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); // 通过 npm 安装
const webpack = require(&#39;webpack&#39;); // 访问内置的插件
module.exports = &#123;
  ...
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin(&#123; template: &#39;./src/index.html&#39; &#125;),
  ],
&#125;;
</code></pre>
<h4 id="二、特性-1"><a href="#二、特性-1" class="headerlink" title="二、特性"></a>二、特性</h4><p>其本质是一个具有<code>apply</code>方法<code>javascript</code>对象</p>
<p><code>apply</code> 方法会被 <code>webpack compiler </code>调用，并且在整个编译生命周期都可以访问 <code>compiler </code>对象</p>
<pre><code class="javascript">const pluginName = &#39;ConsoleLogOnBuildWebpackPlugin&#39;;

class ConsoleLogOnBuildWebpackPlugin &#123;
  apply(compiler) &#123;
    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;
      console.log(&#39;webpack 构建过程开始！&#39;);
    &#125;);
  &#125;
&#125;

module.exports = ConsoleLogOnBuildWebpackPlugin;
</code></pre>
<p><code>compiler hook</code> 的 <code>tap </code>方法的第一个参数，应是驼峰式命名的插件名称</p>
<p>关于整个编译生命周期钩子，有如下：</p>
<ul>
<li>entry-option ：初始化 option</li>
<li>run</li>
<li>compile： 真正开始的编译，在创建 compilation 对象之前</li>
<li>compilation ：生成好了 compilation 对象</li>
<li>make 从 entry 开始递归分析依赖，准备对每个模块进行 build</li>
<li>after-compile： 编译 build 过程结束</li>
<li>emit ：在将内存中 assets 内容写到磁盘文件夹之前</li>
<li>after-emit ：在将内存中 assets 内容写到磁盘文件夹之后</li>
<li>done： 完成所有的编译过程</li>
<li>failed： 编译失败的时候</li>
</ul>
<h4 id="三、常见的Plugin"><a href="#三、常见的Plugin" class="headerlink" title="三、常见的Plugin"></a>三、常见的Plugin</h4><p>常见的<code>plugin</code>有如图所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643734393430302d613763322d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>下面介绍几个常用的插件用法：</p>
<h5 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h5><p>在打包结束后，⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code> js</code> 模块引⼊到该 <code>html</code> 中</p>
<pre><code class="javascript">npm install --save-dev html-webpack-plugin
// webpack.config.js
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
module.exports = &#123;
 ...
  plugins: [
     new HtmlWebpackPlugin(&#123;
       title: &quot;My App&quot;,
       filename: &quot;app.html&quot;,
       template: &quot;./src/html/index.html&quot;
     &#125;) 
  ]
&#125;;
&lt;!--./src/html/index.html--&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;%=htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;html-webpack-plugin&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在 <code>html</code> 模板中，可以通过 <code>&lt;%=htmlWebpackPlugin.options.XXX%&gt;</code> 的方式获取配置的值</p>
<p>更多的配置可以自寻查找</p>
<h5 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h5><p>删除（清理）构建目录</p>
<pre><code class="javascript">npm install --save-dev clean-webpack-plugin
const &#123;CleanWebpackPlugin&#125; = require(&#39;clean-webpack-plugin&#39;);
module.exports = &#123;
 ...
  plugins: [
    ...,
    new CleanWebpackPlugin(),
    ...
  ]
&#125;
</code></pre>
<h5 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h5><p>提取 <code>CSS</code> 到一个单独的文件中</p>
<pre><code class="javascript">npm install --save-dev mini-css-extract-plugin
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
module.exports = &#123; ...,  
                  module: &#123;   
                  rules: [    
                  &#123;     test: /\.s[ac]ss$/,     
                  use: [     
                  &#123;      loader: MiniCssExtractPlugin.loader     &#125;,          
  &#39;css-loader&#39;,          &#39;sass-loader&#39;        ]   &#125;   ] &#125;,  
    plugins: [    ...,    
              new MiniCssExtractPlugin(&#123;     filename: &#39;[name].css&#39;    &#125;),    ...  ]&#125;
</code></pre>
<h5 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h5><p>允许在编译时创建配置的全局对象，是一个<code>webpack</code>内置的插件，不需要安装</p>
<pre><code class="javascript">const &#123; DefinePlugun &#125; = require(&#39;webpack&#39;)module.exports = &#123; ...    plugins:[        new DefinePlugin(&#123;            BASE_URL:&#39;&quot;./&quot;&#39;        &#125;)    ]&#125;
</code></pre>
<p>这时候编译<code>template</code>模块的时候，就能通过下述形式获取全局对象</p>
<pre><code class="javascript">&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL%&gt;favicon.ico&gt;&quot;
</code></pre>
<h5 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h5><p>复制文件或目录到执行区域，如<code>vue</code>的打包过程中，如果我们将一些文件放到<code>public</code>的目录下，那么这个目录会被复制到<code>dist</code>文件夹中</p>
<pre><code class="javascript">npm install copy-webpack-plugin -D
new CopyWebpackPlugin(&#123;    parrerns:[        &#123;            
  from:&quot;public&quot;,            
  globOptions:&#123;                i
               gnore:[                    &#39;**/index.html&#39;                ]            &#125;        &#125;    ]&#125;)
</code></pre>
<p>复制的规则在<code>patterns</code>属性中设置：</p>
<ul>
<li>from：设置从哪一个源中开始复制</li>
<li>to：复制到的位置，可以省略，会默认复制到打包的目录下</li>
<li>globOptions：设置一些额外的选项，其中可以编写需要忽略的文件</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-说一下-Webpack-的热更新原理"><a href="#♥︎-♥︎-♥︎-说一下-Webpack-的热更新原理" class="headerlink" title="♥︎ ♥︎ ♥︎ 说一下 Webpack 的热更新原理"></a>♥︎ ♥︎ ♥︎ 说一下 Webpack 的热更新原理</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>HMR </code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</p>
<p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失</p>
<p>如果使用的是 <code>HMR</code>，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用</p>
<p>在<code>webpack</code>中配置开启热模块也非常的简单，如下代码：</p>
<pre><code class="javascript">const webpack = require(&#39;webpack&#39;)
module.exports = &#123;
  // ...
  devServer: &#123;
    // 开启 HMR 特性
    hot: true
    // hotOnly: true
  &#125;
&#125;
</code></pre>
<p>通过上述这种配置，如果我们修改并保存<code>css</code>文件，确实能够以不刷新的形式更新到页面中</p>
<p>但是，当我们修改并保存<code>js</code>文件之后，页面依旧自动刷新了，这里并没有触发热模块</p>
<p>所以，<code>HMR </code>并不像 <code>Webpack</code> 的其他特性一样可以开箱即用，需要有一些额外的操作</p>
<p>我们需要去指定哪些模块发生更新时进行<code>HRM</code>，如下代码：</p>
<pre><code class="javascript">if(module.hot)&#123;
    module.hot.accept(&#39;./util.js&#39;,()=&gt;&#123;
        console.log(&quot;util.js更新了&quot;)
    &#125;)
&#125;
</code></pre>
<h4 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h4><p>首先来看看一张图，如下：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61646330353738302d616364342d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<ul>
<li>Webpack Compile：将 JS 源代码编译成 bundle.js</li>
<li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li>
<li>Bundle Server：静态资源文件服务器，提供文件访问路径</li>
<li>HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化</li>
<li>bundle.js：构建输出的文件</li>
<li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li>
</ul>
<p>上面图中，可以分成两个阶段：</p>
<ul>
<li>启动阶段为上图 1 - 2 - A - B</li>
</ul>
<p>在编写未经过<code>webpack</code>打包的源代码后，<code>Webpack Compile</code> 将源代码和 <code>HMR Runtime</code> 一起编译成 <code>bundle </code>文件，传输给<code> Bundle Server</code> 静态资源服务器</p>
<ul>
<li>更新阶段为上图 1 - 2 - 3 - 4</li>
</ul>
<p>当某一个文件或者模块发生变化时，<code>webpack </code>监听到文件变化对文件重新编译打包，编译生成唯一的<code>hash</code>值，这个<code>hash </code>值用来作为下一次热更新的标识</p>
<p>根据变化的内容生成两个补丁文件：<code>manifest</code>（包含了 <code>hash</code> 和 <code>chundId </code>，用来说明变化的内容）和<code> chunk.js</code> 模块</p>
<p>由于<code>socket</code>服务器在<code>HMR Runtime</code> 和 <code>HMR Server</code>之间建立 <code>websocket</code>链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的<code>hash</code>值，如下图的<code>h</code>属性，作为下一次热更细的标识</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30356130656466302d616434612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在浏览器接受到这条消息之前，浏览器已经在上一次<code> socket</code> 消息中已经记住了此时的<code> hash</code> 标识，这时候我们会创建一个 <code>ajax</code> 去服务端请求获取到变化内容的 <code>manifest</code> 文件</p>
<p><code>mainfest</code>文件包含重新<code>build</code>生成的<code>hash</code>值，以及变化的模块，对应上图的<code>c</code>属性</p>
<p>浏览器根据 <code>manifest</code> 文件获取模块变化的内容，从而触发<code>render</code>流程，实现局部模块更新</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30653762373835302d616434612d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>关于<code>webpack</code>热模块更新的总结如下：</p>
<ul>
<li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li>
<li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li>
<li>socket server 是一个 websocket 的长连接，双方可以通信</li>
<li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li>
<li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li>
<li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何优化-Webpack-的构建速度"><a href="#♥︎-♥︎-♥︎-如何优化-Webpack-的构建速度" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何优化 Webpack 的构建速度"></a>♥︎ ♥︎ ♥︎ 如何优化 Webpack 的构建速度</h3><h4 id="一、背景-1"><a href="#一、背景-1" class="headerlink" title="一、背景"></a>一、背景</h4><p>随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 <code>webpack</code> 的构建时间也会越来越久</p>
<p>构建时间与我们日常开发效率密切相关，当我们本地开发启动 <code>devServer</code> 或者 <code>build</code> 的时候，如果时间过长，会大大降低我们的工作效率</p>
<p>所以，优化<code>webpack</code> 构建速度是十分重要的环节</p>
<h4 id="二、如何优化"><a href="#二、如何优化" class="headerlink" title="二、如何优化"></a>二、如何优化</h4><p>常见的提升构建速度的手段有如下：</p>
<ul>
<li>优化 loader 配置</li>
<li>合理使用 resolve.extensions</li>
<li>优化 resolve.modules</li>
<li>优化 resolve.alias</li>
<li>使用 DLLPlugin 插件</li>
<li>使用 cache-loader</li>
<li>terser 启动多线程</li>
<li>合理使用 sourceMap</li>
</ul>
<h5 id="优化loader配置"><a href="#优化loader配置" class="headerlink" title="优化loader配置"></a>优化loader配置</h5><p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件，接触<code>include</code>、<code>exclude</code>规定哪些匹配应用<code>loader</code></p>
<p>如采用 ES6 的项目为例，在配置 <code>babel-loader </code>时，可以这样：</p>
<pre><code class="javascript">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        // 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能
        test: /\.js$/,
        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启
        use: [&#39;babel-loader?cacheDirectory&#39;],
        // 只对项目根目录下的 src 目录中的文件采用 babel-loader
        include: path.resolve(__dirname, &#39;src&#39;),
      &#125;,
    ]
  &#125;,
&#125;;
</code></pre>
<h5 id="合理使用-resolve-extensions"><a href="#合理使用-resolve-extensions" class="headerlink" title="合理使用 resolve.extensions"></a>合理使用 resolve.extensions</h5><p>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， <code>resolve</code>可以帮助<code>webpack</code>从每个 <code>require/import</code> 语句中，找到需要引入到合适的模块代码</p>
<p>通过<code>resolve.extensions</code>是解析到文件时自动添加拓展名，默认情况如下：</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    extensions:[&quot;.warm&quot;,&quot;.mjs&quot;,&quot;.js&quot;,&quot;.json&quot;]
&#125;
</code></pre>
<p>当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找</p>
<p>当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度</p>
<h5 id="优化-resolve-modules"><a href="#优化-resolve-modules" class="headerlink" title="优化 resolve.modules"></a>优化 resolve.modules</h5><p><code>resolve.modules</code> 用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。默认值为<code>[&#39;node_modules&#39;]</code>，所以默认会从<code>node_modules</code>中查找文件<br>当安装的第三方模块都放在项目根目录下的 <code>./node_modules </code>目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p>
<pre><code class="javascript">module.exports = &#123;
  resolve: &#123;
    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤
    // 其中 __dirname 表示当前工作目录，也就是项目根目录
    modules: [path.resolve(__dirname, &#39;node_modules&#39;)]
  &#125;,
&#125;;
</code></pre>
<h5 id="优化-resolve-alias"><a href="#优化-resolve-alias" class="headerlink" title="优化 resolve.alias"></a>优化 resolve.alias</h5><p><code>alias</code>给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式</p>
<p>通过配置<code>alias</code>以减少查找过程</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    resolve:&#123;
        alias:&#123;
            &quot;@&quot;:path.resolve(__dirname,&#39;./src&#39;)
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="使用-DLLPlugin-插件"><a href="#使用-DLLPlugin-插件" class="headerlink" title="使用 DLLPlugin 插件"></a>使用 DLLPlugin 插件</h5><p><code>DLL</code>全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中</p>
<p>使用步骤分成两部分：</p>
<ul>
<li>打包一个 DLL 库</li>
<li>引入 DLL 库</li>
</ul>
<h6 id="打包一个-DLL-库"><a href="#打包一个-DLL-库" class="headerlink" title="打包一个 DLL 库"></a>打包一个 DLL 库</h6><p><code>webpack</code>内置了一个<code>DllPlugin</code>可以帮助我们打包一个DLL的库文件</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    plugins:[
        new webpack.DllPlugin(&#123;
            name:&#39;dll_[name]&#39;,
            path:path.resolve(__dirname,&quot;./dll/[name].mainfest.json&quot;)
        &#125;)
    ]
&#125;
</code></pre>
<h6 id="引入-DLL-库"><a href="#引入-DLL-库" class="headerlink" title="引入 DLL 库"></a>引入 DLL 库</h6><p>使用 <code>webpack</code> 自带的 <code>DllReferencePlugin</code> 插件对 <code>mainfest.json</code> 映射文件进行分析，获取要使用的<code>DLL</code>库</p>
<p>然后再通过<code>AddAssetHtmlPlugin</code>插件，将我们打包的<code>DLL</code>库引入到<code>Html</code>模块中</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    new webpack.DllReferencePlugin(&#123;
        context:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;),
        mainfest:path.resolve(__dirname,&quot;./dll/react.mainfest.json&quot;)
    &#125;),
    new AddAssetHtmlPlugin(&#123;
        outputPath:&quot;./auto&quot;,
        filepath:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;)
    &#125;)
&#125;
</code></pre>
<h5 id="使用-cache-loader"><a href="#使用-cache-loader" class="headerlink" title="使用 cache-loader"></a>使用 cache-loader</h5><p>在一些性能开销较大的 <code>loader </code>之前添加 <code>cache-loader</code>，以将结果缓存到磁盘里，显著提升二次构建速度</p>
<p>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code> loader</code></p>
<pre><code class="javascript">module.exports = &#123;
    module: &#123;
        rules: [
            &#123;
                test: /\.ext$/,
                use: [&#39;cache-loader&#39;, ...loaders],
                include: path.resolve(&#39;src&#39;),
            &#125;,
        ],
    &#125;,
&#125;;
</code></pre>
<h5 id="terser-启动多线程"><a href="#terser-启动多线程" class="headerlink" title="terser 启动多线程"></a>terser 启动多线程</h5><p>使用多进程并行运行来提高构建速度</p>
<pre><code class="javascript">module.exports = &#123;
  optimization: &#123;
    minimizer: [
      new TerserPlugin(&#123;
        parallel: true,
      &#125;),
    ],
  &#125;,
&#125;;
</code></pre>
<h5 id="合理使用-sourceMap"><a href="#合理使用-sourceMap" class="headerlink" title="合理使用 sourceMap"></a>合理使用 sourceMap</h5><p>打包生成 <code>sourceMap</code> 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31313634376166302d623031642d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，优化<code>webpack</code>构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手</p>
<h3 id="♥︎-♥︎-♥︎-自己写过Loader和Plugin么"><a href="#♥︎-♥︎-♥︎-自己写过Loader和Plugin么" class="headerlink" title="♥︎ ♥︎ ♥︎ 自己写过Loader和Plugin么"></a>♥︎ ♥︎ ♥︎ 自己写过Loader和Plugin么</h3><h4 id="一、编写loader"><a href="#一、编写loader" class="headerlink" title="一、编写loader"></a>一、编写loader</h4><p>在编写 <code>loader</code> 前，我们首先需要了解 <code>loader</code> 的本质</p>
<p>其本质为函数，函数中的 <code>this</code> 作为上下文会被 <code>webpack</code> 填充，因此我们不能将 <code>loader</code>设为一个箭头函数</p>
<p>函数接受一个参数，为 <code>webpack</code> 传递给 <code>loader</code> 的文件源内容</p>
<p>函数中 <code>this</code> 是由 <code>webpack</code> 提供的对象，能够获取当前 <code>loader</code> 所需要的各种信息</p>
<p>函数中有异步操作或同步操作，异步操作通过 <code>this.callback</code> 返回，返回值要求为 <code>string</code> 或者 <code>Buffer</code></p>
<p>代码如下所示：</p>
<pre><code class="javascript">// 导出一个函数，source为webpack传递给loader的文件源内容
module.exports = function(source) &#123;
    const content = doSomeThing2JsString(source);
    
    // 如果 loader 配置了 options 对象，那么this.query将指向 options
    const options = this.query;
    
    // 可以用作解析其他模块路径的上下文
    console.log(&#39;this.context&#39;);
    
    /*
     * this.callback 参数：
     * error：Error | null，当 loader 出错时向外抛出一个 error
     * content：String | Buffer，经过 loader 编译后需要导出的内容
     * sourceMap：为方便调试生成的编译后内容的 source map
     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程
     */
    this.callback(null, content); // 异步
    return content; // 同步
&#125;
</code></pre>
<p>一般在编写<code>loader</code>的过程中，保持功能单一，避免做多种功能</p>
<p>如<code>less</code>文件转换成 <code>css </code>文件也不是一步到位，而是 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code>几个 <code>loader </code>的链式调用才能完成转换</p>
<h4 id="二、编写plugin"><a href="#二、编写plugin" class="headerlink" title="二、编写plugin"></a>二、编写plugin</h4><p>由于<code>webpack</code>基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务</p>
<p>在之前也了解过，<code>webpack</code>编译会创建两个核心对象：</p>
<ul>
<li>compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子</li>
<li>compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建</li>
</ul>
<p>如果自己要实现<code>plugin</code>，也需要遵循一定的规范：</p>
<ul>
<li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例</li>
<li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，因此不建议修改</li>
<li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住</li>
</ul>
<p>实现<code>plugin</code>的模板如下：</p>
<pre><code class="javascript">class MyPlugin &#123;
    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象
  apply (compiler) &#123;
    // 找到合适的事件钩子，实现自己的插件功能
    compiler.hooks.emit.tap(&#39;MyPlugin&#39;, compilation =&gt; &#123;
        // compilation: 当前打包构建流程的上下文
        console.log(compilation);
        
        // do something...
    &#125;)
  &#125;
&#125;
</code></pre>
<p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容</p>
<h4 id="三、手写一个loader和plugin"><a href="#三、手写一个loader和plugin" class="headerlink" title="三、手写一个loader和plugin"></a>三、手写一个loader和plugin</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903689442820110">手写一个loader和plugin</a></p>
<h3 id="♥︎-♥︎-♥︎-webpack-proxy工作原理？为什么能解决跨域"><a href="#♥︎-♥︎-♥︎-webpack-proxy工作原理？为什么能解决跨域" class="headerlink" title="♥︎ ♥︎ ♥︎ webpack proxy工作原理？为什么能解决跨域?"></a>♥︎ ♥︎ ♥︎ webpack proxy工作原理？为什么能解决跨域?</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p>
<p>基本行为就是接收客户端发送的请求后转发给其他服务器</p>
<p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p>
<p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p>
<h5 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h5><p><code>webpack-dev-server</code>是 <code>webpack</code> 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起</p>
<p>目的是为了提高开发者日常的开发效率，只适用在开发阶段</p>
<p>关于配置方面，在<code>webpack</code>配置对象属性中通过<code>devServer</code>属性提供，如下：</p>
<pre><code class="javascript">// ./webpack.config.js
const path = require(&#39;path&#39;)

module.exports = &#123;
    // ...
    devServer: &#123;
        contentBase: path.join(__dirname, &#39;dist&#39;),
        compress: true,
        port: 9000,
        proxy: &#123;
            &#39;/api&#39;: &#123;
                target: &#39;https://api.github.com&#39;
            &#125;
        &#125;
        // ...
    &#125;
&#125;
</code></pre>
<p><code>devServetr</code>里面<code>proxy</code>则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p>
<p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为<code> /api</code>，值为对应的代理匹配规则，对应如下：</p>
<ul>
<li>target：表示的是代理到的目标地址</li>
<li>pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite</li>
<li>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false</li>
<li>changeOrigin：它表示是否更新代理后请求的 headers 中host地址</li>
</ul>
<h4 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h4><p><code>proxy</code>工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器</p>
<p>举个例子：</p>
<p>在开发阶段，本地地址为<code>http://localhost:3000</code>，该浏览器发送一个前缀带有<code>/api</code>标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p>
<pre><code class="javascript">const express = require(&#39;express&#39;);
const proxy = require(&#39;http-proxy-middleware&#39;);

const app = express();

app.use(&#39;/api&#39;, proxy(&#123;target: &#39;http://www.example.org&#39;, changeOrigin: true&#125;));
app.listen(3000);

// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar
</code></pre>
<h4 id="三、跨域"><a href="#三、跨域" class="headerlink" title="三、跨域"></a>三、跨域</h4><p>在开发阶段， <code>webpack-dev-server</code> 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 <code>localhost </code>的一个端口上，而后端服务又是运行在另外一个地址上</p>
<p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p>
<p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p>
<p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36356235653563302d616365352d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据</p>
<p>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</p>
<h3 id="♥︎-♥︎-♥︎-如何借助webpack来优化前端性能？"><a href="#♥︎-♥︎-♥︎-如何借助webpack来优化前端性能？" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何借助webpack来优化前端性能？"></a>♥︎ ♥︎ ♥︎ 如何借助webpack来优化前端性能？</h3><h4 id="一、背景-2"><a href="#一、背景-2" class="headerlink" title="一、背景"></a>一、背景</h4><p>随着前端的项目逐渐扩大，必然会带来的一个问题就是性能</p>
<p>尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃</p>
<p>一般项目在完成后，会通过<code>webpack</code>进行打包，利用<code>webpack</code>对前端项目性能优化是一个十分重要的环节</p>
<h4 id="二、如何优化-1"><a href="#二、如何优化-1" class="headerlink" title="二、如何优化"></a>二、如何优化</h4><p>通过<code>webpack</code>优化前端的手段有：</p>
<ul>
<li>JS代码压缩</li>
<li>CSS代码压缩</li>
<li>Html文件代码压缩</li>
<li>文件大小压缩</li>
<li>图片压缩</li>
<li>Tree Shaking</li>
<li>代码分离</li>
<li>内联 chunk</li>
</ul>
<h5 id="JS代码压缩"><a href="#JS代码压缩" class="headerlink" title="JS代码压缩"></a>JS代码压缩</h5><p><code>terser</code>是一个<code>JavaScript</code>的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让<code>bundle</code>更小</p>
<p>在<code>production</code>模式下，<code>webpack</code> 默认就是使用 <code>TerserPlugin</code> 来处理我们的代码的。如果想要自定义配置它，配置方法如下：</p>
<pre><code class="javascript">const TerserPlugin = require(&#39;terser-webpack-plugin&#39;)
module.exports = &#123;
    ...
    optimization: &#123;
        minimize: true,
        minimizer: [
            new TerserPlugin(&#123;
                parallel: true // 电脑cpu核数-1
            &#125;)
        ]
    &#125;
&#125;
</code></pre>
<p>属性介绍如下：</p>
<ul>
<li>extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释</li>
<li>parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1</li>
<li>terserOptions：设置我们的terser相关的配置：<ul>
<li>compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true</li>
<li>mangle：设置丑化相关的选项，可以直接设置为true</li>
<li>toplevel：底层变量是否进行转换</li>
<li>keep_classnames：保留类的名称</li>
<li>keep_fnames：保留函数的名称</li>
</ul>
</li>
</ul>
<h5 id="CSS代码压缩"><a href="#CSS代码压缩" class="headerlink" title="CSS代码压缩"></a>CSS代码压缩</h5><p><code>CSS</code>压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等</p>
<p>CSS的压缩我们可以使用另外一个插件：<code>css-minimizer-webpack-plugin</code></p>
<pre><code class="ini">npm install css-minimizer-webpack-plugin -D
</code></pre>
<p>配置方法如下：</p>
<pre><code class="javascript">const CssMinimizerPlugin = require(&#39;css-minimizer-webpack-plugin&#39;)
module.exports = &#123;
    // ...
    optimization: &#123;
        minimize: true,
        minimizer: [
            new CssMinimizerPlugin(&#123;
                parallel: true
            &#125;)
        ]
    &#125;
&#125;
</code></pre>
<h5 id="Html文件代码压缩"><a href="#Html文件代码压缩" class="headerlink" title="Html文件代码压缩"></a>Html文件代码压缩</h5><p>使用<code>HtmlWebpackPlugin</code>插件来生成<code>HTML</code>的模板时候，通过配置属性<code>minify</code>进行<code>html</code>优化</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    plugin:[
        new HtmlwebpackPlugin(&#123;
            ...
            minify:&#123;
                minifyCSS:false, // 是否压缩css
                collapseWhitespace:false, // 是否折叠空格
                removeComments:true // 是否移除注释
            &#125;
        &#125;)
    ]
&#125;
</code></pre>
<p>设置了<code>minify</code>，实际会使用另一个插件<code>html-minifier-terser</code></p>
<h5 id="文件大小压缩"><a href="#文件大小压缩" class="headerlink" title="文件大小压缩"></a>文件大小压缩</h5><p>对文件的大小进行压缩，减少<code>http</code>传输过程中宽带的损耗</p>
<pre><code class="javascript">npm install compression-webpack-plugin -D
new ComepressionPlugin(&#123;
    test:/\.(css|js)$/,  // 哪些文件需要压缩
    threshold:500, // 设置文件多大开始压缩
    minRatio:0.7, // 至少压缩的比例
    algorithm:&quot;gzip&quot;, // 采用的压缩算法
&#125;)
</code></pre>
<h5 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h5><p>一般来说在打包之后，一些图片文件的大小是远远要比 <code>js</code> 或者 <code>css</code> 文件要来的大，所以图片压缩较为重要</p>
<p>配置方法如下：</p>
<pre><code class="javascript">module: &#123;
  rules: [
    &#123;
      test: /\.(png|jpg|gif)$/,
      use: [
        &#123;
          loader: &#39;file-loader&#39;,
          options: &#123;
            name: &#39;[name]_[hash].[ext]&#39;,
            outputPath: &#39;images/&#39;,
          &#125;
        &#125;,
        &#123;
          loader: &#39;image-webpack-loader&#39;,
          options: &#123;
            // 压缩 jpeg 的配置
            mozjpeg: &#123;
              progressive: true,
              quality: 65
            &#125;,
            // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭
            optipng: &#123;
              enabled: false,
            &#125;,
            // 使用 imagemin-pngquant 压缩 png
            pngquant: &#123;
              quality: &#39;65-90&#39;,
              speed: 4
            &#125;,
            // 压缩 gif 的配置
            gifsicle: &#123;
              interlaced: false,
            &#125;,
            // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式
            webp: &#123;
              quality: 75
            &#125;
          &#125;
        &#125;
      ]
    &#125;,
  ]
&#125; 
</code></pre>
<h5 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h5><p><code>Tree Shaking</code> 是一个术语，在计算机中表示消除死代码，依赖于<code>ES Module</code>的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）</p>
<p>在<code>webpack</code>实现<code>Trss shaking</code>有两种不同的方案：</p>
<ul>
<li>usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的</li>
<li>sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用</li>
</ul>
<p>两种不同的配置方案， 有不同的效果</p>
<h5 id="usedExports"><a href="#usedExports" class="headerlink" title="usedExports"></a>usedExports</h5><p>配置方法也很简单，只需要将<code>usedExports</code>设为<code>true</code></p>
<pre><code class="javascript">module.exports = &#123;
    ...
    optimization:&#123;
        usedExports
    &#125;
&#125;
</code></pre>
<p>使用之后，没被用上的代码在<code>webpack</code>打包中会加入<code>unused harmony export mul</code>注释，用来告知 <code>Terser</code> 在优化时，可以删除掉这段代码</p>
<p>如下面<code>sum</code>函数没被用到，<code>webpack</code>打包会添加注释，<code>terser</code>在优化时，则将该函数去掉</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32316232653230302d616565342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h5><p><code>sideEffects</code>用于告知<code>webpack compiler</code>哪些模块时有副作用，配置方法是在<code>package.json</code>中设置<code>sideEffects</code>属性</p>
<p>如果<code>sideEffects</code>设置为false，就是告知<code>webpack</code>可以安全的删除未用到的<code>exports</code></p>
<p>如果有些文件需要保留，可以设置为数组的形式</p>
<pre><code class="javascript">&quot;sideEffecis&quot;:[    &quot;./src/util/format.js&quot;,    &quot;*.css&quot; // 所有的css文件]
</code></pre>
<p>上述都是关于<code>javascript</code>的<code>tree shaking</code>，<code>css</code>同样也能够实现<code>tree shaking</code></p>
<h5 id="css-tree-shaking"><a href="#css-tree-shaking" class="headerlink" title="css tree shaking"></a>css tree shaking</h5><p><code>css</code>进行<code>tree shaking</code>优化可以安装<code>PurgeCss</code>插件</p>
<pre><code class="javascript">npm install purgecss-plugin-webpack -D
const PurgeCssPlugin = require(&#39;purgecss-webpack-plugin&#39;)module.exports = &#123;    ...    plugins:[        new PurgeCssPlugin(&#123;            path:glob.sync(`$&#123;path.resolve(&#39;./src&#39;)&#125;/**/*`), &#123;nodir:true&#125;// src里面的所有文件            satelist:function()&#123;                return &#123;                    standard:[&quot;html&quot;]                &#125;            &#125;        &#125;)    ]&#125;
</code></pre>
<ul>
<li>paths：表示要检测哪些目录下的内容需要被分析，配合使用glob</li>
<li>默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性</li>
</ul>
<h5 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h5><p>将代码分离到不同的<code>bundle</code>中，之后我们可以按需加载，或者并行加载这些文件</p>
<p>默认情况下，所有的<code>JavaScript</code>代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度</p>
<p>代码分离可以分出出更小的<code>bundle</code>，以及控制资源加载优先级，提供代码的加载性能</p>
<p>这里通过<code>splitChunksPlugin</code>来实现，该插件<code>webpack</code>已经默认安装和集成，只需要配置即可</p>
<p>默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all</p>
<pre><code class="javascript">module.exports = &#123;    ...    optimization:&#123;        splitChunks:&#123;            chunks:&quot;all&quot;        &#125;    &#125;&#125;
</code></pre>
<p><code>splitChunks</code>主要属性有如下：</p>
<ul>
<li>Chunks，对同步代码还是异步代码进行处理</li>
<li>minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分</li>
<li>maxSize： 将大于maxSize的包，拆分为不小于minSize的包</li>
<li>minChunks：被引入的次数，默认是1</li>
</ul>
<h5 id="内联chunk"><a href="#内联chunk" class="headerlink" title="内联chunk"></a>内联chunk</h5><p>可以通过<code>InlineChunkHtmlPlugin</code>插件将一些<code>chunk</code>的模块内联到<code>html</code>，如<code>runtime</code>的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的</p>
<pre><code class="javascript">const InlineChunkHtmlPlugin = require(&#39;react-dev-utils/InlineChunkHtmlPlugin&#39;)const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)module.exports = &#123;    ...    plugin:[        new InlineChunkHtmlPlugin(HtmlWebpackPlugin,[/runtime.+\.js/]&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>关于<code>webpack</code>对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化</p>
<h3 id="♥︎-♥︎-♥︎-与webpack类似的工具还有哪些？区别？"><a href="#♥︎-♥︎-♥︎-与webpack类似的工具还有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ 与webpack类似的工具还有哪些？区别？"></a>♥︎ ♥︎ ♥︎ 与webpack类似的工具还有哪些？区别？</h3><h4 id="一、模块化工具"><a href="#一、模块化工具" class="headerlink" title="一、模块化工具"></a>一、模块化工具</h4><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式</p>
<p>可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)</p>
<p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code></p>
<p>通过这些模块打包工具，能够提高我们的开发效率，减少开发成本</p>
<p>这里没有提及<code>gulp</code>、<code>grunt</code>是因为它们只是定义为构建工具，不能类比</p>
<h5 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h5><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup </code>要小巧的多</p>
<p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p>
<p>举个例子：</p>
<pre><code class="javascript">// ./src/messages.js
export default &#123;
  hi: &#39;Hey Guys, I am zce~&#39;
&#125;

// ./src/logger.js
export const log = msg =&gt; &#123;
  console.log(&#39;---------- INFO ----------&#39;)
  console.log(msg)
  console.log(&#39;--------------------------&#39;)
&#125;

export const error = msg =&gt; &#123;
  console.error(&#39;---------- ERROR ----------&#39;)
  console.error(msg)
  console.error(&#39;---------------------------&#39;)
&#125;

// ./src/index.js
import &#123; log &#125; from &#39;./logger&#39;
import messages from &#39;./messages&#39;
log(messages.hi)
</code></pre>
<p>然后通过<code>rollup</code>进行打包</p>
<pre><code class="ini">$ npx rollup ./src/index.js --file ./dist/bundle.js
</code></pre>
<p>打包结果如下图</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38666530373833302d623134332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>可以看到，代码非常简洁，完成不像<code>webpack</code>那样存在大量引导代码和模块函数</p>
<p>并且<code>error</code>方法由于没有被使用，输出的结果中并无<code>error</code>方法，可以看到，<code>rollup</code>默认开始<code>Tree-shaking</code> 优化输出结果</p>
<p>因此，可以看到<code>Rollup</code>的优点：</p>
<ul>
<li>代码效率更简洁、效率更高</li>
<li>默认支持 Tree-shaking</li>
</ul>
<p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup </code>需要使用插件去完成</p>
<p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p>
<p>但是在用于打包<code> JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p>
<h5 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h5><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p>
<p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。如下所示：</p>
<pre><code class="javascript">&lt;!-- ./src/index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Parcel Tutorials&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>main.js文件通过<code>ES Moudle</code>方法导入其他模块成员</p>
<pre><code class="javascript">// ./src/main.js
import &#123; log &#125; from &#39;./logger&#39;
log(&#39;hello parcel&#39;)
// ./src/logger.js
export const log = msg =&gt; &#123;
  console.log(&#39;---------- INFO ----------&#39;)
  console.log(msg)
&#125;
</code></pre>
<p>运行之后，使用命令打包</p>
<pre><code class="ini">npx parcel src/index.html
</code></pre>
<p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个开发服务器，跟<code>webpack Dev Server</code>一样</p>
<p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单</p>
<p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p>
<p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p>
<p>打包命令如下：</p>
<pre><code class="ini">npx parcel src/index.html
</code></pre>
<p>由于打包过程是多进程同时工作，构建速度会比<code>Webpack</code> 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65633137653761302d623161322d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>可以感受到，<code>Parcel </code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决</p>
<h5 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h5><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p>
<p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p>
<p>下图给出<code>webpack</code>与<code>snowpack</code>打包区别：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37393139373833302d623161332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新</p>
<h5 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h5><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p>
<p>它主要由两部分组成：</p>
<ul>
<li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR</li>
<li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li>
</ul>
<p>其作用类似<code>webpack </code>+ <code>webpack-dev-server</code>，其特点如下：</p>
<ul>
<li>快速的冷启动</li>
<li>即时的模块热更新</li>
<li>真正的按需编译</li>
</ul>
<p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p>
<p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p>
<p>原理图如下所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39663265656433302d623134332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p>
<h5 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h5><p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：一切皆模块和按需加载</p>
<p>与其他构建工具相比，有如下优势：</p>
<ul>
<li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li>
<li>万物模块：对 js、css、图片等资源文件都支持打包</li>
<li>开箱即用：HRM、Tree-shaking等功能</li>
<li>代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li>
<li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li>
<li>易于调试：支持 SourceUrls 和 SourceMaps</li>
<li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li>
<li>生态环境好：社区更丰富，出现的问题更容易解决</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-代码分割的本质是什么？有什么意义呢？"><a href="#♥︎-♥︎-♥︎-代码分割的本质是什么？有什么意义呢？" class="headerlink" title="♥︎ ♥︎ ♥︎ 代码分割的本质是什么？有什么意义呢？"></a>♥︎ ♥︎ ♥︎ 代码分割的本质是什么？有什么意义呢？</h3><p>代码分割的本质： 是能够把代码分离到不同的bundle中，避免出现大体积的代码包，然后可以按需加载或并行加载这些文件 </p>
<p>代码分离的意义： 代码分离可以获取更小的bundle，以及控制资源加载优先级，合理使用可以极大的减少加载时间 </p>
<p>代码分割的实现方式有三种： 入口起点：使用entry手动分离代码(不建议) 防止重复加载：</p>
<p>使用optimization.splitChunks配置选项，可以将第三方公共模块和业务代码直接分离 </p>
<p>动态引入：使 用import()方法来分离代码，原理是当 Webpack 解析到该语法时，会自动进行代码分割，分割出不同的chunks  </p>
<p>语法：使用的时候再去下载对应的文件，返回一个Promise，当Promise成功后再去执行回调</p>
<h3 id="♥︎-♥︎-♥︎-说下-tree-shaking-的原理"><a href="#♥︎-♥︎-♥︎-说下-tree-shaking-的原理" class="headerlink" title="♥︎ ♥︎ ♥︎ 说下 tree-shaking 的原理"></a>♥︎ ♥︎ ♥︎ 说下 tree-shaking 的原理</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7002410645316436004">tree-shaking 的原理</a></p>
<h3 id="♥︎-♥︎-♥︎-babel原理"><a href="#♥︎-♥︎-♥︎-babel原理" class="headerlink" title="♥︎ ♥︎ ♥︎  babel原理"></a>♥︎ ♥︎ ♥︎  babel原理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wmaoshu/article/details/119813090">babel原理</a></p>
<h3 id="♥︎-♥︎-♥︎-linux部署和windows-sever服务器区别？"><a href="#♥︎-♥︎-♥︎-linux部署和windows-sever服务器区别？" class="headerlink" title="♥︎ ♥︎ ♥︎  linux部署和windows sever服务器区别？"></a>♥︎ ♥︎ ♥︎  linux部署和windows sever服务器区别？</h3><p>性价比：Linux服务器性价比更高，Linux作为资源管理器和操作系统来说，是开源的，免费的，而正版windows的操作系统是收费的。</p>
<p>性能方面：相同配置的Linux服务器的性能比windows服务器好一些，Linux服务器占用的资源少一点</p>
<p>稳定性方面：Window系统用户量大，因而攻击者多一些，所以暴露了更多的系统安全漏洞。Linux是多用户多进程系统，意味着Linux能够一次性处理大量正在进行的进程，比windows处理的多</p>
<p>安全性方面：Linux系统开源软件的开发方式有助于暴露错误，集众人智慧解决问题，补丁更新更快。这是windows不具备的，Windows的另一个不利因素是其许多应用程序依靠远程过程调用，这就迫使Windows的防火墙没有Linux那样严格。而Linux远程过程调用是限制使用的。</p>
<h3 id="♥︎-♥︎-♥︎-前端资源发布路径怎么实现非覆盖式发布（平滑升级）？"><a href="#♥︎-♥︎-♥︎-前端资源发布路径怎么实现非覆盖式发布（平滑升级）？" class="headerlink" title="♥︎ ♥︎ ♥︎ 前端资源发布路径怎么实现非覆盖式发布（平滑升级）？"></a>♥︎ ♥︎ ♥︎ 前端资源发布路径怎么实现非覆盖式发布（平滑升级）？</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903457984512014">前端资源发布路径怎么实现非覆盖式发布</a></p>
<h3 id="♥︎-♥︎-♥︎-你有发布过自己的npm包吗？流程是怎样的？"><a href="#♥︎-♥︎-♥︎-你有发布过自己的npm包吗？流程是怎样的？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你有发布过自己的npm包吗？流程是怎样的？"></a>♥︎ ♥︎ ♥︎ 你有发布过自己的npm包吗？流程是怎样的？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CapejasmineY/article/details/126251986">npm包发布流程</a></p>
<h3 id="♥︎-♥︎-♥︎-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？"><a href="#♥︎-♥︎-♥︎-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？" class="headerlink" title="♥︎ ♥︎ ♥︎ 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？"></a>♥︎ ♥︎ ♥︎ 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/75786d5c9cac">npm 模块安装机制</a></p>
<h3 id="♥︎-♥︎-♥︎-你会搭建私有的npm仓库吗？怎么搭建？"><a href="#♥︎-♥︎-♥︎-你会搭建私有的npm仓库吗？怎么搭建？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你会搭建私有的npm仓库吗？怎么搭建？"></a>♥︎ ♥︎ ♥︎ 你会搭建私有的npm仓库吗？怎么搭建？</h3><p><a target="_blank" rel="noopener" href="https://zhaomenghuan.js.org/blog/npm-private-repository-verdaccio.html">私有的npm仓库</a></p>
<h3 id="♥︎-♥︎-♥︎-jenkins-上线流程"><a href="#♥︎-♥︎-♥︎-jenkins-上线流程" class="headerlink" title="♥︎ ♥︎ ♥︎  jenkins 上线流程"></a>♥︎ ♥︎ ♥︎  jenkins 上线流程</h3><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/608413">jenkins 上线流程</a></p>
<h3 id="♥︎-♥︎-♥︎-什么是长缓存，在webpack中如何做到长缓存优化？"><a href="#♥︎-♥︎-♥︎-什么是长缓存，在webpack中如何做到长缓存优化？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是长缓存，在webpack中如何做到长缓存优化？"></a>♥︎ ♥︎ ♥︎ 什么是长缓存，在webpack中如何做到长缓存优化？</h3><p>浏览器在用户访问页面的时候，都会对静态资源进行存储，但是每次代码更新或者升级的时候，我们都需要浏览器去重新加载代码，最方便的方法就是以文件名的方式引入，只下载新的代码块，不加载旧的没有变化的代码块，这就是长缓存，</p>
<p>在webpack4中使用SplitChunkPlugin把第三方库和业务代码分离，由于第三方库的chunkHash未改变，所以只会对改变的业务代码的模块进行更新。而第三方库的代码块因为长缓存而不更新。</p>
<h3 id="♥︎-♥︎-♥︎-什么是组件？什么是模块化？有什么区别？"><a href="#♥︎-♥︎-♥︎-什么是组件？什么是模块化？有什么区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是组件？什么是模块化？有什么区别？"></a>♥︎ ♥︎ ♥︎ 什么是组件？什么是模块化？有什么区别？</h3><p>组件化</p>
<p>就是基础库或者基础组件，意思是把代码重复的部分提炼出一个个组件供给功能使用</p>
<p>模块化</p>
<p>就是业务框架或者业务模块，也可以理解为框架，意思是把功能进行划分，将同一类型的代码整合在一起，所以模</p>
<p>块的功能相对复杂，都属于同一个业务。</p>
<p>区别：</p>
<p>使用：组件的使用能在不同项目(模块)重复应用的代码，而模块按照项目功能需求划分成不同类型的业务框架 </p>
<p>目的：组件是复用，解耦，模块是为了隔离、封装 </p>
<p>依赖：组件之间低依赖，比较独立，模块之间的依赖可通过路由进行耦合 </p>
<p>架构定位：组件位于架构底层，被其它层所依赖，模块位于架构业务层</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903935795265549">https://juejin.cn/post/6844903935795265549</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全git"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/"
    >前端面试大全git</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/" class="article-date">
  <time datetime="2022-11-03T02:29:52.000Z" itemprop="datePublished">2022-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/git%E6%93%8D%E4%BD%9C/">git操作</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（git命令）"><a href="#前端面试题大全（git命令）" class="headerlink" title="前端面试题大全（git命令）"></a>前端面试题大全（git命令）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git是什么？"><a href="#git是什么？" class="headerlink" title="git是什么？"></a>git是什么？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>git，是一个分布式版本控制软件，最初目的是为更好地管理<code>Linux</code>内核开发而设计</p>
<p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32393234306634302d663739632d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>项目开始，只有一个原始版仓库，别的机器可以<code>clone</code>这个原始版本库，那么所有<code>clone</code>的机器，它们的版本库其实都是一样的，并没有主次之分</p>
<p>所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库<code>clone</code>一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交</p>
<p><code>github</code>实际就可以充当这个服务器角色，其是一个开源协作社区，提供<code>Git</code>仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目</p>
<h4 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h4><p>当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的</p>
<p><code>Git</code> 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，<code>git</code>能够知道</p>
<p><code>Git </code>用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来，如下：</p>
<pre><code class="ini">24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre>
<p>当我们修改文件的时候，<code>git</code>就会修改文件的状态，可以通过<code>git status</code>进行查询，状态情况如下：</p>
<ul>
<li>已修改（modified）：表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交（committed）：表示数据已经安全的保存在本地数据库中。</li>
</ul>
<p>文件状态对应的，不同状态的文件在<code>Git</code>中处于不同的工作区域，主要分成了四部分：</p>
<ul>
<li>工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本</li>
<li>暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中</li>
<li>本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库</li>
<li>远程仓库：远程的仓库，如 github</li>
</ul>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33323733633961302d663739632d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="三、命令"><a href="#三、命令" class="headerlink" title="三、命令"></a>三、命令</h4><p>从上图可以看到，<code>git</code>日常简单的使用就只有上图6个命令：</p>
<ul>
<li>add</li>
<li>commit</li>
<li>push</li>
<li>pull</li>
<li>clone</li>
<li>checkout</li>
</ul>
<p>但实际上还有很多命令，如果想要熟练使用，还有60个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力</p>
<h3 id="Git中-fork-clone-branch这三个概念，有什么区别"><a href="#Git中-fork-clone-branch这三个概念，有什么区别" class="headerlink" title="Git中 fork, clone,branch这三个概念，有什么区别?"></a>Git中 fork, clone,branch这三个概念，有什么区别?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p><code>fork</code>，英语翻译过来就是叉子，动词形式则是分叉，如下图，从左到右，一条直线变成多条直线</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61643034616465302d663761642d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>转到<code>git</code>仓库中，<code>fork</code>则可以代表分叉、克隆 出一个（仓库的）新拷贝</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62346233313435302d663761642d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>包含了原来的仓库（即upstream repository，上游仓库）所有内容，如分支、Tag、提交</p>
<p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p>
<h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p>
<p>执行<code>clone</code>命令后，会在当前目录下创建一个名为<code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p>
<p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p>
<h5 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h5><p><code>branch</code>，译为分支，其作用简单而言就是开启另一个分支， 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线</p>
<p><code>Git</code> 处理分支的方式十分轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷</p>
<p>在我们开发中，默认只有一条<code>master</code>分支，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37666138653963302d663932332d313165622d393931642d3333346664333166303230312e706e67.png">]</p>
<p>通过<code>git branch </code>可以创建一个分支，但并不会自动切换到新分支中去</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38396566643536302d663932332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>通过<code>git checkout</code>可以切换到另一个<code>testing</code>分支</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39316431636566302d663932332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h4><h5 id="fork-1"><a href="#fork-1" class="headerlink" title="fork"></a>fork</h5><p>当你在<code>github</code>发现感兴趣开源项目的时候，可以通过点击<code>github</code>仓库中右上角<code>fork</code>标识的按钮，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095419097.png"></p>
<p>点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的<code>github</code>仓库中，而你本地仓库是不会存在任何更改</p>
<p>然后你就可以通过<code>git clone</code>对你这个复制的远程仓库进行克隆</p>
<p>后续更改任何东西都可以在本地完成，如<code>git add</code>、<code>git commit</code>一系列的操作，然后通过<code>push</code>命令推到自己的远程仓库</p>
<p>如果希望对方接受你的修改，可以通过发送<code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095452040.png"></p>
<p>整体流程如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63656438636531302d663761642d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="clone-1"><a href="#clone-1" class="headerlink" title="clone"></a>clone</h5><p>在<code>github</code>中，开源项目右侧存在<code>code</code>按钮，点击后则会显示开源项目<code>url</code>信息，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095540516.png"></p>
<p>通过<code>git clone xxx</code>则能完成远程项目的下载</p>
<h5 id="branch-1"><a href="#branch-1" class="headerlink" title="branch"></a>branch</h5><p>可通过<code>git branch</code>进行查看当前的分支状态，</p>
<p>如果给了<code>--list</code>，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号</p>
<p>以及通过<code>git branch</code>创建一个新的分支出来</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>其三者区别如下：</p>
<ul>
<li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li>
<li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li>
<li>branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支</li>
</ul>
<h3 id="Git常用的命令有哪些？"><a href="#Git常用的命令有哪些？" class="headerlink" title="Git常用的命令有哪些？"></a>Git常用的命令有哪些？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p><code>git </code>的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66653135303532302d663761662d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的<code>git </code>命令</p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p><code>Git </code>自带一个 <code>git config</code> 的工具来帮助设置控制 <code>Git </code>外观和行为的配置变量，在我们安装完<code>git</code>之后，第一件事就是设置你的用户名和邮件地址</p>
<p>后续每一个提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改</p>
<p>设置提交代码时的用户信息命令如下：</p>
<ul>
<li>git config [–global] user.name “[name]”</li>
<li>git config [–global] user.email “[email address]”</li>
</ul>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>一个<code>git</code>项目的初始有两个途径，分别是：</p>
<ul>
<li>git init [project-name]：创建或在当前目录初始化一个git代码库</li>
<li>git clone url：下载一个项目和它的整个代码历史</li>
</ul>
<h5 id="日常基本操作"><a href="#日常基本操作" class="headerlink" title="日常基本操作"></a>日常基本操作</h5><p>在日常工作中，代码常用的基本操作如下：</p>
<ul>
<li>git init 初始化仓库，默认为 master 分支</li>
<li>git add . 提交全部文件修改到缓存区</li>
<li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li>
<li>git diff 查看当前代码 add后，会 add 哪些内容</li>
<li>git diff –staged查看现在 commit 提交后，会提交哪些内容</li>
<li>git status 查看当前分支状态</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li>
<li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li>
<li>git commit -v 提交时显示所有diff信息</li>
<li>git commit –amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</li>
</ul>
<p>关于提交信息的格式，可以遵循以下的规则：</p>
<ul>
<li>feat: 新特性，添加功能</li>
<li>fix: 修改 bug</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>style: 代码格式修改, 注意不是 css 修改</li>
<li>test: 测试用例修改</li>
<li>chore: 其他修改, 比如构建流程, 依赖管理</li>
</ul>
<h5 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h5><ul>
<li>git branch 查看本地所有分支</li>
<li>git branch -r 查看远程所有分支</li>
<li>git branch -a 查看本地和远程所有分支</li>
<li>git merge &lt;分支名&gt; 合并分支</li>
<li>git merge –abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li>
<li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li>
<li>git checkout –orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li>
<li>git branch -D &lt;分支名&gt; 删除本地某个分支</li>
<li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li>
<li>git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</li>
<li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li>
<li>git checkout &lt;分支名&gt; 切换到本地某个分支</li>
<li>git checkout &lt;远程库名&gt;&#x2F;&lt;分支名&gt; 切换到线上某个分支</li>
<li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li>
</ul>
<h5 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h5><p>远程操作常见的命令：</p>
<ul>
<li>git fetch [remote] 下载远程仓库的所有变动</li>
<li>git remote -v 显示所有远程仓库</li>
<li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li>
<li>git fetch 获取线上最新版信息记录，不合并</li>
<li>git push [remote] [branch] 上传本地指定分支到远程仓库</li>
<li>git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突</li>
<li>git push [remote] –all 推送所有分支到远程仓库</li>
</ul>
<h5 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h5><ul>
<li>git checkout [file] 恢复暂存区的指定文件到工作区</li>
<li>git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</li>
<li>git checkout . 恢复暂存区的所有文件到工作区</li>
<li>git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</li>
<li>git reset –hard 重置暂存区与工作区，与上一次commit保持一致</li>
<li>git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</li>
<li>git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</li>
</ul>
<blockquote>
<p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p>
<p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p>
</blockquote>
<h5 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h5><p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p>
<ul>
<li>git stash 暂时将未提交的变化移除</li>
<li>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</li>
<li>git stash list 查看所有储藏中的工作</li>
<li>git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</li>
<li>git stash clear 清空所有储藏中的工作</li>
<li>git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</li>
</ul>
<h5 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h5><p><code>git</code>常用命令速查表如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613130663363302d663762302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<h3 id="对git-pull-和-git-fetch-的理解？有什么区别？"><a href="#对git-pull-和-git-fetch-的理解？有什么区别？" class="headerlink" title="对git pull 和 git fetch 的理解？有什么区别？"></a>对git pull 和 git fetch 的理解？有什么区别？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>先回顾两个命令的定义</p>
<ul>
<li>git fetch 命令用于从另一个存储库下载对象和引用</li>
<li>git pull 命令用于从另一个存储库或本地分支获取并集成(整合)</li>
</ul>
<p>再来看一次<code>git</code>的工作流程图，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64353233626136302d666163322d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>可以看到，<code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p>
<p>而<code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p>
<p>在我们本地的<code>git</code>文件中对应也存储了<code>git</code>本地仓库分支的<code>commit ID </code>和 跟踪的远程分支的<code>commit ID</code>，对应文件如下：</p>
<ul>
<li>.git&#x2F;refs&#x2F;head&#x2F;[本地分支]</li>
<li>.git&#x2F;refs&#x2F;remotes&#x2F;[正在跟踪的分支]</li>
</ul>
<p>使用 <code>git fetch</code>更新代码，本地的库中<code>master</code>的<code>commitID</code>不变</p>
<p>但是与<code>git</code>上面关联的那个<code>orign/master</code>的<code>commit ID</code>发生改变</p>
<p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过<code>merge</code>去合并这两个不同的代码版本</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66643233666637302d666231322d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>也就是<code>fetch</code>的时候本地的<code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地<code>merge</code>合并这两个版本号的代码</p>
<p>相比之下，使用<code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30393162383134302d666231332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h4><p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到<code>git pull</code>或者<code>git fetch</code>命令</p>
<h5 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h5><p>用法如下：</p>
<pre><code class="ini">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>例如从远程的<code>origin</code>仓库的<code>master</code>分支下载代码到本地并新建一个<code>temp</code>分支</p>
<pre><code class="ini">git fetch origin master:temp
</code></pre>
<p>如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来到本地当前分支</p>
<p>这里<code>git fetch</code>不会进行合并，执行后需要手动执行<code>git merge</code>合并，如下：</p>
<pre><code class="ini">git merge temp
</code></pre>
<h5 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h5><p>两者的用法十分相似，<code>pull</code>用法如下：</p>
<pre><code class="ini">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>例如将远程主机<code>origin</code>的<code>master</code>分支拉取过来，与本地的<code>branchtest</code>分支合并，命令如下：</p>
<pre><code class="ini">git pull origin master:branchtest
</code></pre>
<p>同样如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来与本地当前分支合并</p>
<h4 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h4><p>相同点：</p>
<ul>
<li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li>
</ul>
<p>不同点：</p>
<ul>
<li>git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull &#x3D; git fetch + git merge</li>
<li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li>
</ul>
<h3 id="Git-中-HEAD、工作树和索引之间的区别？"><a href="#Git-中-HEAD、工作树和索引之间的区别？" class="headerlink" title="Git 中 HEAD、工作树和索引之间的区别？"></a>Git 中 HEAD、工作树和索引之间的区别？</h3><h4 id="一、HEAD"><a href="#一、HEAD" class="headerlink" title="一、HEAD"></a>一、HEAD</h4><p>在<code>git</code>中，可以存在很多分支，其本质上是一个指向<code>commit</code>对象的可变指针，而<code>Head</code>是一个特别的指针，是一个指向你正在工作中的本地分支的指针</p>
<p>简单来讲，就是你现在在哪儿，HEAD 就指向哪儿</p>
<p>例如当前我们处于<code>master</code>分支，所以<code>HEAD</code>这个指针指向了<code>master</code>分支指针</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33366362306461302d666134302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>然后通过调用<code>git checkout test</code>切换到<code>test</code>分支，那么<code>HEAD</code>则指向<code>test</code>分支，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33653836626138302d666134302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>但我们在<code>test</code>分支再一次<code>commit</code>信息的时候，<code>HEAD</code>指针仍然指向了<code>test</code>分支指针，而<code>test</code>分支指针已经指向了最新创建的提交，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34333938333962302d666136362d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这个<code>HEAD</code>存储的位置就在<code>.git/HEAD</code>目录中，查看信息可以看到<code>HEAD</code>指向了另一个文件</p>
<pre><code class="ini">$ cat .git/HEAD
ref: refs/heads/master

$ cat .git/refs/heads/master
7406a10efcc169bbab17827aeda189aa20376f7f
</code></pre>
<p>这个文件的内容是一串哈希码，而这个哈希码正是<code>master</code>分支上最新的提交所对应的哈希码</p>
<p>所以，当我们切换分支的时候，<code>HEAD</code>指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p>
<p>所以，HEAD指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p>
<h4 id="二、工作树和索引"><a href="#二、工作树和索引" class="headerlink" title="二、工作树和索引"></a>二、工作树和索引</h4><p>在<code>Git</code>管理下，大家实际操作的目录被称为工作树，也就是工作区域</p>
<p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34366535616334302d666134302d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>Git</code>在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库</p>
<p>因此，要提交文件，首先需要把文件加入到索引区域中。</p>
<p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交</p>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><p>从所在的位置来看：</p>
<ul>
<li>HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</li>
<li>工作树是查看和编辑的（源）文件的实际内容</li>
<li>索引是放置你想要提交给 git仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过git commit 则将索引区域的文件提交到 git 仓库中</li>
</ul>
<h3 id="对git-stash-的理解？应用场景？"><a href="#对git-stash-的理解？应用场景？" class="headerlink" title="对git stash 的理解？应用场景？"></a>对git stash 的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上</p>
<p>后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码</p>
<p>默认情况下，<code>git stash</code>会缓存下列状态的文件：</p>
<ul>
<li>添加到暂存区的修改（staged changes）</li>
<li>Git跟踪的但并未添加到暂存区的修改（unstaged changes）</li>
</ul>
<p>但以下状态的文件不会缓存：</p>
<ul>
<li>在工作目录中新的文件（untracked files）</li>
<li>被忽略的文件（ignored files）</li>
</ul>
<p>如果想要上述的文件都被缓存，可以使用<code>-u</code>或者<code>--include-untracked</code>可以工作目录新的文件，使用<code>-a</code>或者<code>--all</code>命令可以当前目录下的所有修改</p>
<h4 id="二、如何使用-1"><a href="#二、如何使用-1" class="headerlink" title="二、如何使用"></a>二、如何使用</h4><p>关于<code>git stash</code>常见的命令如下：</p>
<ul>
<li>git stash</li>
<li>git stash save</li>
<li>git stash list</li>
<li>git stash pop</li>
<li>git stash apply</li>
<li>git stash show</li>
<li>git stash drop</li>
<li>git stash clear</li>
</ul>
<h5 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h5><p>保存当前工作进度，会把暂存区和工作区的改动保存起来</p>
<h5 id="git-stash-save"><a href="#git-stash-save" class="headerlink" title="git stash save"></a>git stash save</h5><p><code>git stash save</code>可以用于存储修改.并且将<code>git</code>的工作状态切回到<code>HEAD</code>也就是上一次合法提交上</p>
<p>如果给定具体的文件路径,<code>git stash</code>只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：</p>
<ul>
<li>–keep-index 或者 -k 只会存储为加入 git 管理的文件</li>
<li>–include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态</li>
<li>-a 或者 –all 命令可以当前目录下的所有修改，包括被 git 忽略的文件</li>
</ul>
<h5 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h5><p>显示保存进度的列表。也就意味着，<code>git stash</code>命令可以多次执行，当多次使用<code>git stash</code>命令后，栈里会充满未提交的代码，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35303231366464302d666363662d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>其中，<code>stash@&#123;0&#125;</code>、<code>stash@&#123;1&#125;</code>就是当前<code>stash</code>的名称</p>
<h5 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h5><p><code>git stash pop</code> 从栈中读取最近一次保存的内容，也就是栈顶的<code>stash</code>会恢复到工作区</p>
<p>也可以通过 <code>git stash pop</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>
<p>如果从<code>stash</code>中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突</p>
<h5 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h5><p>将堆栈中的内容应用到当前目录，不同于<code>git stash pop</code>，该命令不会将内容从堆栈中删除</p>
<p>也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况</p>
<p>同样，可以通过<code>git stash apply</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>
<h5 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h5><p>查看堆栈中最新保存的<code>stash</code>和当前目录的差异</p>
<p>通过使用<code>git stash show -p</code>查看详细的不同</p>
<p>通过使用<code>git stash show stash@&#123;1&#125;</code>查看指定的<code>stash</code>和当前目录差异</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/bfc073fa538b45c4d6de871da070f364638cdd751a8c08426794c5dba2230514/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34353836323061302d666363662d313165622d626336662d3366303665313439313636342e706e67"><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34353836323061302d666363662d313165622d626336662d3366303665313439313636342e706e67.png" alt="img"></a></p>
<h5 id="git-stash-drop"><a href="#git-stash-drop" class="headerlink" title="git stash drop"></a>git stash drop</h5><p><code>git stash drop</code> + <code>stash</code>名称表示从堆栈中移除某个指定的stash</p>
<h5 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h5><p>删除所有存储的进度</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情</p>
<p>但是你创建一次未完成的代码的<code>commit</code>提交，这时候就可以使用<code>git stash</code></p>
<p>例如以下场景：</p>
<p>当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过<code>git pull</code>解决</p>
<p>但是如果可能发生冲突怎么办.直接<code>git pull</code>会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：</p>
<ul>
<li>git stash</li>
<li>git pull</li>
<li>git stash pop</li>
</ul>
<p>或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用<code>git stash</code>缓存当前区域的代码</p>
<ul>
<li>git stash：保存开发到一半的代码</li>
<li>git commit -m ‘修改问题’</li>
<li>git stash pop：将代码追加到最新的提交之后</li>
</ul>
<h3 id="对git-rebase-和-git-merge的理解？区别？"><a href="#对git-rebase-和-git-merge的理解？区别？" class="headerlink" title="对git rebase 和 git merge的理解？区别？"></a>对git rebase 和 git merge的理解？区别？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p>
<ul>
<li>git merge</li>
<li>git rebase</li>
</ul>
<p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p>
<p>用法上两者也十分的简单：</p>
<h5 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h5><p>将当前分支合并到指定分支，命令用法如下：</p>
<pre><code class="ini">git merge xxx
</code></pre>
<h5 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h5><p>将当前分支移植到指定分支或指定<code>commit</code>之上，用法如下：</p>
<pre><code class="ini">git rebase -i &lt;commit&gt;
</code></pre>
<p>常见的参数有<code>--continue</code>，用于解决冲突之后，继续执行<code>rebase</code></p>
<pre><code class="ini">git rebase --continue
</code></pre>
<h4 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h4><h5 id="git-merge-1"><a href="#git-merge-1" class="headerlink" title="git merge"></a>git merge</h5><p>通过<code>git merge</code>将当前分支与<code>xxx</code>分支合并，产生的新的<code>commit</code>对象有两个父节点</p>
<p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p>
<p>举个例子，<code>bugfix</code>分支是从<code>maste</code>r分支分叉出来的，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38383431306133302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>合并<code> bugfix</code>分支到<code>master</code>分支时，如果<code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含<code>master</code>分支所有的历史记录</p>
<p>所以通过把<code>master</code>分支的位置移动到<code>bugfix</code>的最新分支上，就完成合并</p>
<p>如果<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39323965623232302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这时候使用<code>git merge</code>的时候，会生成一个新的提交，并且<code>master</code>分支的<code>HEAD</code>会移动到新的分支上，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39666466613365302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p>
<h5 id="git-rebase-1"><a href="#git-rebase-1" class="headerlink" title="git rebase"></a>git rebase</h5><p>同样，<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61623264353132302d666464342d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>通过<code>git rebase</code>，会变成如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62373261656437302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63396261306538302d666464342d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>rebase</code>之后，<code>master</code>的<code>HEAD</code>位置不变。因此，要合并<code>master</code>分支和<code>bugfix</code>分支</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64633636303636302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的<code>B</code></p>
<p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交<code>X</code>和<code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p>
<p>然后将当前分支指向目标最新位置<code>D</code>, 然后将之前另存为临时文件的修改依序应用</p>
<h4 id="三、区别-3"><a href="#三、区别-3" class="headerlink" title="三、区别"></a>三、区别</h4><p>从上面可以看到，<code>merge</code>和<code>rebasea</code>都是合并历史记录，但是各自特性不同：</p>
<h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>通过<code>merge</code>合并分支会新增一个<code>merge commit</code>，然后将两个分支的历史联系起来</p>
<p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p>
<h5 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h5><p><code>rebase </code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p>
<p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p>
<h3 id="git-发生冲突的场景？如何解决？"><a href="#git-发生冲突的场景？如何解决？" class="headerlink" title="git 发生冲突的场景？如何解决？"></a>git 发生冲突的场景？如何解决？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>一般情况下，出现分支的场景有如下：</p>
<ul>
<li>多个分支代码合并到一个分支时</li>
<li>多个分支向同一个远端分支推送</li>
</ul>
<p>具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称</p>
<p>如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可</p>
<p>应用在命令中，就是<code>push</code>、<code>pull</code>、<code>stash</code>、<code>rebase</code>等命令下都有可能产生冲突情况，从本质上来讲，都是<code>merge</code>和<code>patch</code>（应用补丁）时产生冲突</p>
<h4 id="二、分析-1"><a href="#二、分析-1" class="headerlink" title="二、分析"></a>二、分析</h4><p>在本地主分值<code>master</code>创建一个<code>a.txt</code>文件，文件起始位置写上<code>master commit</code>，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39353961646532302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>然后提交到仓库：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m ‘master first commit’</li>
</ul>
<p>创建一个新的分支<code>featurel1</code>分支，并进行切换，如下：</p>
<pre><code class="ini">git checkout -b featurel1
</code></pre>
<p>然后修改<code>a.txt</code>文件首行文字为 <code>featurel commit</code>，然后添加到暂存区，并开始进行提交到仓库：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m ‘featurel first change’</li>
</ul>
<p>然后通过<code>git checkout master</code>切换到主分支，通过<code>git merge</code>进行合并，发现不会冲突</p>
<p>此时<code>a.txt</code>文件的内容变成<code>featurel commit</code>，没有出现冲突情况，这是因为<code>git</code>在内部发生了快速合并</p>
<blockquote>
<p>如果当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作</p>
<p>git 不创建任何新的提交(commit)，只是将当前分支指向合并进来的分支</p>
</blockquote>
<p>如果此时切换到<code>featurel</code>分支，将文件的内容修改成<code>featrue second commit</code>，然后提交到本地仓库</p>
<p>然后切换到主分支，如果此时在<code>a.txt</code>文件再次修改，修改成<code>mastet second commit</code>，然后再次提交到本地仓库</p>
<p>此时，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61303534383863302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这种情况下，无法执行快速合并，只能试图把各自的修改合并起来，但这种合并就可能会有冲突</p>
<p>现在通过<code>git merge featurel</code>进行分支合并，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62303939316439302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>从冲突信息可以看到，<code>a.txt</code>发生冲突，必须手动解决冲突之后再提交</p>
<p>而<code>git status</code>同样可以告知我们冲突的文件：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63353832333433302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>打开<code>a.txt</code>文件，可以看到如下内容：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63653761306139302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容：</p>
<ul>
<li>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 和 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 之间的区域就是当前更改的内容</li>
<li>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 之间的区域就是传入进来更改的内容</li>
</ul>
<p>现在要做的事情就是将冲突的内容进行更改，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，<code>Git </code>就会将它们标记为冲突已解决然后再提交：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m “conflict fixed”</li>
</ul>
<p>此时<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64373432316536302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>使用<code>git log</code>命令可以看到合并的信息：</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65306466643162302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></h4><h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>当<code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p>
<p>解决冲突就是把<code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p>
<h3 id="对git-reset-和-git-revert-的理解？区别？"><a href="#对git-reset-和-git-revert-的理解？区别？" class="headerlink" title="对git reset 和 git revert 的理解？区别？"></a>对git reset 和 git revert 的理解？区别？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><h5 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h5><p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p>
<p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61623464306330302d666637322d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h5><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e14636346aeadfa4f5766d89196355a3ff8fd0edadd8b74bd5803cdab3312e60/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643132633239302d666637322d313165622d393931642d3333346664333166303230312e706e67"><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643132633239302d666637322d313165622d393931642d3333346664333166303230312e706e67.png" alt="img"></a></p>
<h4 id="二、如何用"><a href="#二、如何用" class="headerlink" title="二、如何用"></a>二、如何用</h4><h5 id="git-reset-1"><a href="#git-reset-1" class="headerlink" title="git reset"></a>git reset</h5><p>当没有指定<code>ID</code>的时候，默认使用<code>HEAD</code>，如果指定<code>ID</code>，那么就是基于指向<code>ID</code>去变动暂存区或工作区的内容</p>
<pre><code class="ini">// 没有指定ID, 暂存区的内容会被当前ID版本号的内容覆盖，工作区不变
git reset

// 指定ID，暂存区的内容会被指定ID版本号的内容覆盖，工作区不变
git reset &lt;ID&gt; 
</code></pre>
<p>日志<code>ID</code>可以通过查询，可以<code>git log</code>进行查询，如下：</p>
<pre><code class="ini">commit a7700083ace1204ccdff9f71631fb34c9913f7c5 (HEAD -&gt; master)
Author: linguanghui &lt;linguanghui@baidu.com&gt;
Date:   Tue Aug 17 22:34:40 2021 +0800

    second commit

commit e31118663ce66717edd8a179688a7f3dde5a9393
Author: linguanghui &lt;linguanghui@baidu.com&gt;
Date:   Tue Aug 17 22:20:01 2021 +0800

    first commit
</code></pre>
<p>常见命令如下：</p>
<ul>
<li>–mixed（默认）：默认的时候，只有暂存区变化</li>
<li>–hard参数：如果使用 –hard 参数，那么工作区也会变化</li>
<li>–soft：如果使用 –soft 参数，那么暂存区和工作区都不会变化</li>
</ul>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32323562343165302d666637332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="git-revert-1"><a href="#git-revert-1" class="headerlink" title="git revert"></a>git revert</h5><p>跟<code>git reset</code>用法基本一致，<code>git revert</code> 撤销某次操作，此次操作之前和之后的 <code>commit</code>和<code>history</code>都会保留，并且把这次撤销，作为一次最新的提交，如下：</p>
<pre><code class="ini">git revert &lt;commit_id&gt; 
</code></pre>
<p>如果撤销前一个版本，可以通过如下命令：</p>
<pre><code class="ini">git revert HEAD
</code></pre>
<p>撤销前前一次，如下：</p>
<pre><code class="ini">git revert HEAD^
</code></pre>
<h4 id="三、区别-4"><a href="#三、区别-4" class="headerlink" title="三、区别"></a>三、区别</h4><p>撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，<code>git reset</code>被设计为重设本地更改</p>
<p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p>
<p>两者主要区别如下：</p>
<ul>
<li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li>
<li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容</li>
<li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li>
</ul>
<blockquote>
<p>git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并</p>
<p>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</p>
</blockquote>
<ul>
<li>如果回退分支的代码以后还需要的情况则使用<code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用<code>git reset</code></li>
</ul>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mians/" rel="tag">mians</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" rel="tag">代码版本控制</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全设计模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
    >前端面试大全设计模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-11-03T01:26:38.000Z" itemprop="datePublished">2022-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">常用设计模式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（设计模式）"><a href="#前端面试题大全（设计模式）" class="headerlink" title="前端面试题大全（设计模式）"></a>前端面试题大全（设计模式）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ul>
<li>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</li>
</ul>
<h3 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h3><ul>
<li>看懂源代码：如果你不懂设计模式去看Jdk、Spring、SpringMVC、IO等等等等的源码，你会很迷茫，你会寸步难行</li>
<li>看看前辈的代码：你去个公司难道都是新项目让你接手？很有可能是接盘的，前辈的开发难道不用设计模式？</li>
<li>编写自己的理想中的好代码：我个人反正是这样的，对于我自己开发的项目我会很认真，我对他比对我女朋友还好，把项目当成自己的儿子一样</li>
</ul>
<h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17172acfe20b2d2d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png"></p>
<ul>
<li>创建型模式，共五种：工厂方法模式、抽象工厂模式<strong>、</strong>单例模式、建造者模式、原型模式。</li>
<li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17172acff10be430~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.jpeg"></p>
<h4 id="开放封闭原则（Open-Close-Principle）"><a href="#开放封闭原则（Open-Close-Principle）" class="headerlink" title="开放封闭原则（Open Close Principle）"></a>开放封闭原则（Open Close Principle）</h4><ul>
<li>原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</li>
<li>描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li>
<li>优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。</li>
</ul>
<h4 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h4><ul>
<li>原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。</li>
<li>大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。</li>
<li>优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。</li>
</ul>
<h4 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h4><ul>
<li>依赖倒置原则的核心思想是面向接口编程.</li>
<li>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，</li>
<li>这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。</li>
</ul>
<h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h4><ul>
<li>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</li>
<li>例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口</li>
</ul>
<h4 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h4><ul>
<li>原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦</li>
<li>大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</li>
<li>优点：低耦合，高内聚。</li>
</ul>
<h4 id="单一职责原则（Principle-of-single-responsibility）"><a href="#单一职责原则（Principle-of-single-responsibility）" class="headerlink" title="单一职责原则（Principle of single responsibility）"></a>单一职责原则（Principle of single responsibility）</h4><ul>
<li>原则思想：一个方法只负责一件事情。</li>
<li>描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。</li>
<li>优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>单例模式（Singleton Pattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建</p>
<p>在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66613738393864302d336232632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>从定义上来看，全局变量好像就是单例模式，但是一般情况我们不认为全局变量是一个单例模式，原因是：</p>
<ul>
<li>全局命名污染</li>
<li>不易维护，容易被重写覆盖</li>
</ul>
<h4 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h4><p>在<code>javascript</code>中，实现一个单例模式可以用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可，如下：</p>
<pre><code class="javascript">// 定义一个类
function Singleton(name) &#123;
  this.name = name;
  this.instance = null;
&#125;
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 获取类的实例
Singleton.getInstance = function(name) &#123;
  if(!this.instance) &#123;
      this.instance = new Singleton(name);
  &#125;
  return this.instance
&#125;;

// 获取对象1
const a = Singleton.getInstance(&#39;a&#39;);
// 获取对象2
const b = Singleton.getInstance(&#39;b&#39;);
// 进行比较
console.log(a === b);
</code></pre>
<p>使用闭包也能够实现，如下：</p>
<pre><code class="javascript">function Singleton(name) &#123;
  this.name = name;
&#125;
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 获取类的实例
Singleton.getInstance = (function() &#123;
  var instance = null;
  return function(name) &#123;
      if(!this.instance) &#123;
          this.instance = new Singleton(name);
      &#125;
      return this.instance
  &#125;        
&#125;)();

// 获取对象1
const a = Singleton.getInstance(&#39;a&#39;);
// 获取对象2
const b = Singleton.getInstance(&#39;b&#39;);
// 进行比较
console.log(a === b);
</code></pre>
<p>也可以将上述的方法稍作修改，变成构造函数的形式，如下：</p>
<pre><code class="javascript">// 单例构造函数
function CreateSingleton (name) &#123;
  this.name = name;
  this.getName();
&#125;;

// 获取实例的名字
CreateSingleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 单例对象
const Singleton = (function()&#123;
  var instance;
  return function (name) &#123;
      if(!instance) &#123;
          instance = new CreateSingleton(name);
      &#125;
      return instance;
  &#125;
&#125;)();

// 创建实例对象1
const a = new Singleton(&#39;a&#39;);
// 创建实例对象2
const b = new Singleton(&#39;b&#39;);

console.log(a===b); // true
</code></pre>
<h4 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>在前端中，很多情况都是用到单例模式，例如页面存在一个模态框的时候，只有用户点击的时候才会创建，而不是加载完成之后再创建弹窗和隐藏，并且保证弹窗全局只有一个</p>
<p>可以先创建一个通常的获取对象的方法，如下：</p>
<pre><code class="javascript">const getSingle = function( fn )&#123;
let result;
return function()&#123;
  return result || ( result = fn .apply(this, arguments ) );
&#125;
&#125;; 
</code></pre>
<p>创建弹窗的代码如下：</p>
<pre><code class="javascript">const createLoginLayer = function()&#123;
var div = document.createElement( &#39;div&#39; );
div.innerHTML = &#39;我是浮窗&#39;;
div.style.display = &#39;none&#39;;
document.body.appendChild( div );
return div;
&#125;; 

const createSingleLoginLayer = getSingle( createLoginLayer ); 

document.getElementById( &#39;loginBtn&#39; ).onclick = function()&#123;
var loginLayer = createSingleLoginLayer();
loginLayer.style.display = &#39;block&#39;;
&#125;;
</code></pre>
<p>上述这种实现称为惰性单例，意图解决需要时才创建类实例对象</p>
<p>并且<code>Vuex</code>、<code>redux</code>全局态管理库也应用单例模式的思想，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38626535306638302d336232622d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>现在很多第三方库都是单例模式，多次引用只会使用同一个对象，如<code>jquery</code>、<code>lodash</code>、<code>moment</code>…</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂</p>
<p>其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品</p>
<p>举个例子：</p>
<ul>
<li>编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联（耦合）</li>
<li>后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事；</li>
<li>这种情况下，就需要将创建实例的工作从调用方（A类）中分离，与调用方解耦，也就是使用工厂方法创建实例的工作封装起来（减少代码重复），由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，而降低调用者因为创建逻辑导致的错误；</li>
</ul>
<h4 id="二、实现-1"><a href="#二、实现-1" class="headerlink" title="二、实现"></a>二、实现</h4><p>工厂模式根据抽象程度的不同可以分为：</p>
<ul>
<li>简单工厂模式（Simple Factory）</li>
<li>工厂方法模式（Factory Method）</li>
<li>抽象工厂模式（Abstract Factory）</li>
</ul>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例</p>
<p>假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致</p>
<p>代码如下：</p>
<pre><code class="javascript">function Factory(career) &#123;
    function User(career, work) &#123;
        this.career = career 
        this.work = work
    &#125;
    let work
    switch(career) &#123;
        case &#39;coder&#39;:
            work =  [&#39;写代码&#39;, &#39;修Bug&#39;] 
            return new User(career, work)
            break
        case &#39;hr&#39;:
            work = [&#39;招聘&#39;, &#39;员工信息管理&#39;]
            return new User(career, work)
            break
        case &#39;driver&#39;:
            work = [&#39;开车&#39;]
            return new User(career, work)
            break
        case &#39;boss&#39;:
            work = [&#39;喝茶&#39;, &#39;开会&#39;, &#39;审批文件&#39;]
            return new User(career, work)
            break
    &#125;
&#125;
let coder = new Factory(&#39;coder&#39;)
console.log(coder)
let boss = new Factory(&#39;boss&#39;)
console.log(boss)
</code></pre>
<p><code>Factory</code>就是一个简单工厂。当我们调用工厂函数时，只需要传递name、age、career就可以获取到包含用户工作内容的实例对象</p>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂方法模式跟简单工厂模式差不多，但是把具体的产品放到了工厂函数的<code>prototype</code>中</p>
<p>这样一来，扩展产品种类就不必修改工厂函数了，核心类就变成抽象类，也可以随时重写某种具体的产品</p>
<p>也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产；但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产</p>
<p>如下代码：</p>
<pre><code class="javascript">// 工厂方法
function Factory(career)&#123;
    if(this instanceof Factory)&#123;
        var a = new this[career]();
        return a;
    &#125;else&#123;
        return new Factory(career);
    &#125;
&#125;
// 工厂方法函数的原型中设置所有对象的构造函数
Factory.prototype=&#123;
    &#39;coder&#39;: function()&#123;
        this.careerName = &#39;程序员&#39;
        this.work = [&#39;写代码&#39;, &#39;修Bug&#39;] 
    &#125;,
    &#39;hr&#39;: function()&#123;
        this.careerName = &#39;HR&#39;
        this.work = [&#39;招聘&#39;, &#39;员工信息管理&#39;]
    &#125;,
    &#39;driver&#39;: function () &#123;
        this.careerName = &#39;司机&#39;
        this.work = [&#39;开车&#39;]
    &#125;,
    &#39;boss&#39;: function()&#123;
        this.careerName = &#39;老板&#39;
        this.work = [&#39;喝茶&#39;, &#39;开会&#39;, &#39;审批文件&#39;]
    &#125;
&#125;
let coder = new Factory(&#39;coder&#39;)
console.log(coder)
let hr = new Factory(&#39;hr&#39;)
console.log(hr)
</code></pre>
<p>工厂方法关键核心代码是工厂里面的判断this是否属于工厂，也就是做了分支判断，这个工厂只做我能做的产品</p>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>上述简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建</p>
<p>通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的</p>
<p>由于<code>JavaScript</code>中并没有抽象类的概念，只能模拟，可以分成四部分：</p>
<ul>
<li>用于创建抽象类的函数</li>
<li>抽象类</li>
<li>具体类</li>
<li>实例化具体类</li>
</ul>
<p>上面的例子中有<code>coder</code>、<code>hr</code>、<code>boss</code>、<code>driver</code>四种岗位，其中<code>coder</code>可能使用不同的开发语言进行开发，比如<code>JavaScript</code>、<code>Java</code>等等。那么这两种语言就是对应的类簇</p>
<p>示例代码如下：</p>
<pre><code class="javascript">let CareerAbstractFactory = function(subType, superType) &#123;
  // 判断抽象工厂中是否有该抽象类
  if (typeof CareerAbstractFactory[superType] === &#39;function&#39;) &#123;
    // 缓存类
    function F() &#123;&#125;
    // 继承父类属性和方法
    F.prototype = new CareerAbstractFactory[superType]()
    // 将子类的constructor指向父类
    subType.constructor = subType;
    // 子类原型继承父类
    subType.prototype = new F()
  &#125; else &#123;
    throw new Error(&#39;抽象类不存在&#39;)
  &#125;
&#125;
</code></pre>
<p>上面代码中<code>CareerAbstractFactory</code>就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>从上面可看到，简单简单工厂的优点就是我们只要传递正确的参数，就能获得所需的对象，而不需要关心其创建的具体细节</p>
<p>应用场景也容易识别，有构造函数的地方，就应该考虑简单工厂，但是如果函数构建函数太多与复杂，会导致工厂函数变得复杂，所以不适合复杂的情况</p>
<p>抽象工厂模式一般用于严格要求以面向对象思想进行开发的超大型项目中，我们一般常规的开发的话一般就是简单工厂和工厂方法模式会用的比较多一些</p>
<p>综上，工厂模式适用场景如下：</p>
<ul>
<li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li>
<li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li>
<li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来</p>
<p>一个基于策略模式的程序至少由两部分组成：</p>
<ul>
<li>策略类，策略类封装了具体的算法，并负责具体的计算过程</li>
<li>环境类Context，Context 接受客户的请求，随后 把请求委托给某一个策略类</li>
</ul>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>举个例子，公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍</p>
<p>若使用<code>if</code>来实现，代码则如下：</p>
<pre><code class="javascript">var calculateBouns = function(salary,level) &#123;
    if(level === &#39;A&#39;) &#123;
        return salary * 4;
    &#125;
    if(level === &#39;B&#39;) &#123;
        return salary * 3;
    &#125;
    if(level === &#39;C&#39;) &#123;
        return salary * 2;
    &#125;
&#125;;
// 调用如下：
console.log(calculateBouns(4000,&#39;A&#39;)); // 16000
console.log(calculateBouns(2500,&#39;B&#39;)); // 7500
</code></pre>
<p>从上述可有看到，函数内部包含过多<code>if...else</code>，并且后续改正的时候，需要在函数内部添加逻辑，违反了开放封闭原则</p>
<p>而如果使用策略模式，就是先定义一系列算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，如下：</p>
<pre><code class="javascript">var obj = &#123;
        &quot;A&quot;: function(salary) &#123;
            return salary * 4;
        &#125;,
        &quot;B&quot; : function(salary) &#123;
            return salary * 3;
        &#125;,
        &quot;C&quot; : function(salary) &#123;
            return salary * 2;
        &#125; 
&#125;;
var calculateBouns =function(level,salary) &#123;
    return obj[level](salary);
&#125;;
console.log(calculateBouns(&#39;A&#39;,10000)); // 40000
</code></pre>
<p>上述代码中，<code>obj</code>对应的是策略类，而<code>calculateBouns</code>对应上下通信类</p>
<p>又比如实现一个表单校验的代码，常常会像如下写法：</p>
<pre><code class="javascript">var registerForm = document.getElementById(&quot;registerForm&quot;);
registerForm.onsubmit = function()&#123;
    if(registerForm.userName.value === &#39;&#39;) &#123;
        alert(&#39;用户名不能为空&#39;);
        return;
    &#125;
    if(registerForm.password.value.length &lt; 6) &#123;
        alert(&quot;密码的长度不能小于6位&quot;);
        return;
    &#125;
    if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123;
        alert(&quot;手机号码格式不正确&quot;);
        return;
    &#125;
&#125;
</code></pre>
<p>上述代码包含多处<code>if</code>语句，并且违反了开放封闭原则，如果应用中还有其他的表单，需要重复编写代码</p>
<p>此处也可以使用策略模式进行重构校验，第一步确定不变的内容，即策略规则对象，如下：</p>
<pre><code class="javascript">var strategy = &#123;
    isNotEmpty: function(value,errorMsg) &#123;
        if(value === &#39;&#39;) &#123;
            return errorMsg;
        &#125;
    &#125;,
    // 限制最小长度
    minLength: function(value,length,errorMsg) &#123;
        if(value.length &lt; length) &#123;
            return errorMsg;
        &#125;
    &#125;,
    // 手机号码格式
    mobileFormat: function(value,errorMsg) &#123;
        if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123;
            return errorMsg;
        &#125;
    &#125; 
&#125;;
</code></pre>
<p>然后找出变的地方，作为环境类<code>context</code>，负责接收用户的要求并委托给策略规则对象，如下<code>Validator</code>类：</p>
<pre><code class="javascript">var Validator = function()&#123;
        this.cache = [];  // 保存效验规则
&#125;;
Validator.prototype.add = function(dom,rule,errorMsg) &#123;
    var str = rule.split(&quot;:&quot;);
    this.cache.push(function()&#123;
        // str 返回的是 minLength:6 
        var strategy = str.shift();
        str.unshift(dom.value); // 把input的value添加进参数列表
        str.push(errorMsg);  // 把errorMsg添加进参数列表
        return strategys[strategy].apply(dom,str);
    &#125;);
&#125;;
Validator.prototype.start = function()&#123;
    for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123;
        var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息
        if(msg) &#123;
            return msg;
        &#125;
    &#125;
&#125;;
</code></pre>
<p>通过<code>validator.add</code>方法添加校验规则和错误信息提示，使用如下：</p>
<pre><code class="javascript">var validateFunc = function()&#123;
    var validator = new Validator(); // 创建一个Validator对象
    /* 添加一些效验规则 */
    validator.add(registerForm.userName,&#39;isNotEmpty&#39;,&#39;用户名不能为空&#39;);
    validator.add(registerForm.password,&#39;minLength:6&#39;,&#39;密码长度不能小于6位&#39;);
    validator.add(registerForm.userName,&#39;mobileFormat&#39;,&#39;手机号码格式不正确&#39;);

    var errorMsg = validator.start(); // 获得效验结果
    return errorMsg; // 返回效验结果
&#125;;
var registerForm = document.getElementById(&quot;registerForm&quot;);
registerForm.onsubmit = function()&#123;
    var errorMsg = validateFunc();
    if(errorMsg)&#123;
        alert(errorMsg);
        return false;
    &#125;
&#125;
</code></pre>
<p>上述通过策略模式完成表单的验证，并且可以随时调用，在修改表单验证规则的时候，也非常方便，通过传递参数即可调用</p>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>从上面可以看到，使用策略模式的优点有如下：</p>
<ul>
<li>策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句</li>
<li>策略模式提供了开放-封闭原则，使代码更容易理解和扩展</li>
<li>策略模式中的代码可以复用</li>
</ul>
<p>策略模式不仅仅用来封装算法，在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装 一系列的“业务规则”</p>
<p>只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>代理模式（Proxy Pattern）是为一个对象提供一个代用品或占位符，以便控制对它的访问</p>
<p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39353163393962302d336436612d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>在生活中，代理模式的场景是十分常见的，例如我们现在如果有租房、买房的需求，更多的是去找链家等房屋中介机构，而不是直接寻找想卖房或出租房的人谈。此时，链家起到的作用就是代理的作用</p>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p>在<code>ES6</code>中，存在<code>proxy</code>构建函数能够让我们轻松使用代理模式：</p>
<pre><code class="javascript">const proxy = new Proxy(target, handler);
</code></pre>
<p>关于<code>Proxy</code>的使用可以翻看以前的文章</p>
<p>而按照功能来划分，<code>javascript</code>代理模式常用的有：</p>
<ul>
<li>缓存代理</li>
<li>虚拟代理</li>
</ul>
<h5 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h5><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</p>
<p>如实现一个求积乘的函数，如下：</p>
<pre><code class="javascript">var muti = function () &#123;
  console.log(&quot;开始计算乘积&quot;);
  var a = 1;
  for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;
    a = a * arguments[i];
  &#125;
  return a;
&#125;;
</code></pre>
<p>现在加入缓存代理，如下：</p>
<pre><code class="javascript">var proxyMult = (function () &#123;
  var cache = &#123;&#125;;
  return function () &#123;
    var args = Array.prototype.join.call(arguments, &quot;,&quot;);
    if (args in cache) &#123;
      return cache[args];
    &#125;
    return (cache[args] = mult.apply(this, arguments));
  &#125;;
&#125;)();

proxyMult(1, 2, 3, 4); // 输出:24
proxyMult(1, 2, 3, 4); // 输出:24
</code></pre>
<p>当第二次调用 <code>proxyMult(1, 2, 3, 4)</code> 时，本体 <code>mult</code> 函数并没有被计算，<code>proxyMult</code> 直接返回了之前缓存好的计算结果</p>
<h5 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h5><p>虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建</p>
<p>常见的就是图片预加载功能：</p>
<p>未使用代理模式如下：</p>
<pre><code class="javascript">let MyImage = (function()&#123;
    let imgNode = document.createElement( &#39;img&#39; );
    document.body.appendChild( imgNode );
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;

    img.onload = function()&#123;
        // 监听到图片加载完成后，设置src为加载完成后的图片
        imgNode.src = img.src;
    &#125;;

    return &#123;
        setSrc: function( src )&#123;
            // 设置图片的时候，设置为默认的loading图
            imgNode.src = &#39;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#39;;
            // 把真正需要设置的图片传给Image对象的src属性
            img.src = src;
        &#125;
    &#125;
&#125;)();

MyImage.setSrc( &#39;https://xxx.jpg&#39; );
</code></pre>
<p><code>MyImage</code>对象除了负责给<code>img</code>节点设置<code>src</code>外，还要负责预加载图片，违反了面向对象设计的原则——单一职责原则</p>
<p>上述过程<code>loding</code>则是耦合进<code>MyImage</code>对象里的，如果以后某个时候，我们不需要预加载显示loading这个功能了，就只能在<code>MyImage</code>对象里面改动代码</p>
<p>使用代理模式，代码则如下：</p>
<pre><code class="javascript">// 图片本地对象，负责往页面中创建一个img标签，并且提供一个对外的setSrc接口
let myImage = (function()&#123;
    let imgNode = document.createElement( &#39;img&#39; );
    document.body.appendChild( imgNode );

    return &#123;
        //setSrc接口，外界调用这个接口，便可以给该img标签设置src属性
        setSrc: function( src )&#123;
            imgNode.src = src;
        &#125;
    &#125;
&#125;)();
// 代理对象，负责图片预加载功能
let proxyImage = (function()&#123;
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;
    img.onload = function()&#123;
        // 监听到图片加载完成后，给被代理的图片本地对象设置src为加载完成后的图片
        myImage.setSrc( this.src );
    &#125;
    return &#123;
        setSrc: function( src )&#123;
            // 设置图片时，在图片未被真正加载好时，以这张图作为loading，提示用户图片正在加载
            myImage.setSrc( &#39;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#39; );
            img.src = src;
        &#125;
    &#125;
&#125;)();

proxyImage.setSrc( &#39;https://xxx.jpg&#39; );
</code></pre>
<p>使用代理模式后，图片本地对象负责往页面中创建一个<code>img</code>标签，并且提供一个对外的<code>setSrc</code>接口；</p>
<p>代理对象负责在图片未加载完成之前，引入预加载的<code>loading</code>图，负责了图片预加载的功能</p>
<p>上述并没有改变或者增加<code>MyImage</code>的接口，但是通过代理对象，实际上给系统添加了新的行为</p>
<p>并且上述代理模式可以发现，代理和本体接口的一致性，如果有一天不需要预加载，那么就不需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了 <code>setSrc</code> 方法</p>
<p>‘</p>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>现在的很多前端框架或者状态管理框架都使用代理模式，用与监听变量的变化</p>
<p>使用代理模式代理对象的访问的方式，一般又被称为拦截器，比如我们在项目中经常使用 <code>Axios</code> 的实例来进行 HTTP 的请求，使用拦截器 <code>interceptor</code> 可以提前对 请求前的数据 服务器返回的数据进行一些预处理</p>
<p>以及上述应用到的缓存代理和虚拟代理</p>
<h3 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h3><h4 id="一、观察者模式"><a href="#一、观察者模式" class="headerlink" title="一、观察者模式"></a>一、观察者模式</h4><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p>
<p>观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64336138303032302d336637632d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸</p>
<p>报社和订报纸的客户就形成了一对多的依赖关系</p>
<p>实现代码如下：</p>
<p>被观察者模式</p>
<pre><code class="javascript">class Subject &#123;

  constructor() &#123;
    this.observerList = [];
  &#125;

  addObserver(observer) &#123;
    this.observerList.push(observer);
  &#125;

  removeObserver(observer) &#123;
    const index = this.observerList.findIndex(o =&gt; o.name === observer.name);
    this.observerList.splice(index, 1);
  &#125;

  notifyObservers(message) &#123;
    const observers = this.observeList;
    observers.forEach(observer =&gt; observer.notified(message));
  &#125;

&#125;
</code></pre>
<p>观察者：</p>
<pre><code class="javascript">class Observer &#123;

  constructor(name, subject) &#123;
    this.name = name;
    if (subject) &#123;
      subject.addObserver(this);
    &#125;
  &#125;

  notified(message) &#123;
    console.log(this.name, &#39;got message&#39;, message);
  &#125;
&#125;
</code></pre>
<p>使用代码如下：</p>
<pre><code class="javascript">const subject = new Subject();
const observerA = new Observer(&#39;observerA&#39;, subject);
const observerB = new Observer(&#39;observerB&#39;);
subject.addObserver(observerB);
subject.notifyObservers(&#39;Hello from subject&#39;);
subject.removeObserver(observerA);
subject.notifyObservers(&#39;Hello again&#39;);
</code></pre>
<p>上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表</p>
<h4 id="二、发布订阅模式"><a href="#二、发布订阅模式" class="headerlink" title="二、发布订阅模式"></a>二、发布订阅模式</h4><p>发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在</p>
<p>同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65323464336364302d336637632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>实现代码如下：</p>
<pre><code class="javascript">class PubSub &#123;
  constructor() &#123;
    this.messages = &#123;&#125;;
    this.listeners = &#123;&#125;;
  &#125;
  // 添加发布者
  publish(type, content) &#123;
    const existContent = this.messages[type];
    if (!existContent) &#123;
      this.messages[type] = [];
    &#125;
    this.messages[type].push(content);
  &#125;
  // 添加订阅者
  subscribe(type, cb) &#123;
    const existListener = this.listeners[type];
    if (!existListener) &#123;
      this.listeners[type] = [];
    &#125;
    this.listeners[type].push(cb);
  &#125;
  // 通知
  notify(type) &#123;
    const messages = this.messages[type];
    const subscribers = this.listeners[type] || [];
    subscribers.forEach((cb, index) =&gt; cb(messages[index]));
  &#125;
&#125;
</code></pre>
<p>发布者代码如下：</p>
<pre><code class="javascript">class Publisher &#123;
  constructor(name, context) &#123;
    this.name = name;
    this.context = context;
  &#125;
  publish(type, content) &#123;
    this.context.publish(type, content);
  &#125;
&#125;
</code></pre>
<p>订阅者代码如下：</p>
<pre><code class="javascript">class Subscriber &#123;
  constructor(name, context) &#123;
    this.name = name;
    this.context = context;
  &#125;
  subscribe(type, cb) &#123;
    this.context.subscribe(type, cb);
  &#125;
&#125;
</code></pre>
<p>使用代码如下：</p>
<pre><code class="javascript">const TYPE_A = &#39;music&#39;;
const TYPE_B = &#39;movie&#39;;
const TYPE_C = &#39;novel&#39;;

const pubsub = new PubSub();

const publisherA = new Publisher(&#39;publisherA&#39;, pubsub);
publisherA.publish(TYPE_A, &#39;we are young&#39;);
publisherA.publish(TYPE_B, &#39;the silicon valley&#39;);
const publisherB = new Publisher(&#39;publisherB&#39;, pubsub);
publisherB.publish(TYPE_A, &#39;stronger&#39;);
const publisherC = new Publisher(&#39;publisherC&#39;, pubsub);
publisherC.publish(TYPE_C, &#39;a brief history of time&#39;);

const subscriberA = new Subscriber(&#39;subscriberA&#39;, pubsub);
subscriberA.subscribe(TYPE_A, res =&gt; &#123;
  console.log(&#39;subscriberA received&#39;, res)
&#125;);
const subscriberB = new Subscriber(&#39;subscriberB&#39;, pubsub);
subscriberB.subscribe(TYPE_C, res =&gt; &#123;
  console.log(&#39;subscriberB received&#39;, res)
&#125;);
const subscriberC = new Subscriber(&#39;subscriberC&#39;, pubsub);
subscriberC.subscribe(TYPE_B, res =&gt; &#123;
  console.log(&#39;subscriberC received&#39;, res)
&#125;);

pubsub.notify(TYPE_A);
pubsub.notify(TYPE_B);
pubsub.notify(TYPE_C);
</code></pre>
<p>上述代码，发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>两种设计模式思路是一样的，举个生活例子：</p>
<ul>
<li>观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体</li>
<li>发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决</li>
</ul>
<p>上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的</p>
<p>两者区别如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f3135352f39313431363832632d373338362d346631322d383431322d6662313761316364346266362e706e67.png"></p>
<ul>
<li>在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</li>
<li>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</li>
<li>观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</li>
</ul>
<h3 id="其他完整的设计模式（感兴趣可以看看）"><a href="#其他完整的设计模式（感兴趣可以看看）" class="headerlink" title="其他完整的设计模式（感兴趣可以看看）"></a>其他完整的设计模式（感兴趣可以看看）</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904032826294286">23种设计模式</a></p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全TypeScript"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/"
    >前端面试大全TypeScript</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/" class="article-date">
  <time datetime="2022-11-02T02:27:06.000Z" itemprop="datePublished">2022-11-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/TypeScript/">TypeScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（TypeScript）"><a href="#前端面试题大全（TypeScript）" class="headerlink" title="前端面试题大全（TypeScript）"></a>前端面试题大全（TypeScript）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-typescript-的理解？与-javascript-的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-typescript-的理解？与-javascript-的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 typescript 的理解？与 javascript 的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 typescript 的理解？与 javascript 的区别？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>TypeScript</code> 是 <code>JavaScript</code> 的类型的超集，支持<code>ES6</code>语法，支持面向对象编程的概念，如类、接口、继承、泛型等</p>
<blockquote>
<p>超集，不得不说另外一个概念，子集，怎么理解这两个呢，举个例子，如果一个集合A里面的的所有元素集合B里面都存在，那么我们可以理解集合B是集合A的超集，集合A为集合B的子集</p>
</blockquote>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36316332633166302d303935302d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>其是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误</p>
<p>同时扩展了<code> JavaScript</code> 的语法，所以任何现有的<code> JavaScript</code> 程序可以不加改变的在 <code>TypeScript</code> 下工作</p>
<p>为了保证兼容性，<code>typescript</code>在编译阶段需要编译器编译成纯<code>Javascript</code>来运行，是为大型应用之开发而设计的语言，如下：</p>
<p><code>tsx</code>文件如下：</p>
<pre><code class="typescript">const hello : string = &quot;Hello World!&quot;
console.log(hello)
</code></pre>
<p>编译文件后：</p>
<pre><code class="tsx">const hello = &quot;Hello World!&quot;
console.log(hello)
</code></pre>
<h4 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h4><p><code>typescript</code>的特性主要有如下：</p>
<ul>
<li>类型批注和编译时类型检查 ：在编译时批注变量类型</li>
<li>类型推断：ts中没有批注变量类型会自动推断变量的类型</li>
<li>类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除</li>
<li>接口：ts中用接口来定义对象类型</li>
<li>枚举：用于取值被限定在一定范围内的场景</li>
<li>Mixin：可以接受任意类型的值</li>
<li>泛型编程：写代码时使用一些以后才指定的类型</li>
<li>名字空间：名字只在该区域内有效，其他区域可重复使用该名字而不冲突</li>
<li>元组：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li>
<li>…</li>
</ul>
<h5 id="类型批注"><a href="#类型批注" class="headerlink" title="类型批注"></a>类型批注</h5><p>通过类型批注提供在编译时启动类型检查的静态类型，这是可选的，而且可以忽略而使用<code>JavaScript</code>常规的动态类型</p>
<pre><code class="tsx">function Add(left: number, right: number): number &#123;
 return left + right;
&#125;
</code></pre>
<p>对于基本类型的批注是<code>number</code>、<code>bool</code>和<code>string</code>，而弱或动态类型的结构则是<code>any</code>类型</p>
<h5 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h5><p>当类型没有给出时，TypeScript编译器利用类型推断来推断类型，如下：</p>
<pre><code class="tsx">let str = &#39;string&#39;
</code></pre>
<p>变量<code>str</code>被推断为字符串类型，这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</p>
<p>如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态<code>any</code>类型</p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口简单来说就是用来描述对象的类型 数据的类型有<code>number</code>、<code> null</code>、<code> string</code>等数据格式，对象的类型就是用接口来描述的</p>
<pre><code class="tsx">interface Person &#123;
    name: string;
    age: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25
&#125;;
</code></pre>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><ul>
<li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li>
<li>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译</li>
<li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li>
<li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件</li>
</ul>
<p>更多的区别如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36623534343034302d303935302d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-typescript-的数据类型有哪些"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-typescript-的数据类型有哪些" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ typescript 的数据类型有哪些?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ typescript 的数据类型有哪些?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>typescript</code> 和 <code>javascript</code>几乎一样，拥有相同的数据类型，另外在<code>javascript</code>基础上提供了更加实用的类型供开发使用</p>
<p>在开发阶段，可以为明确的变量定义为某种类型，这样<code>typescript</code>就能在编译阶段进行类型检查，当类型不合符预期结果的时候则会出现错误提示</p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p><code>typescript</code> 的数据类型主要有如下：</p>
<ul>
<li>boolean（布尔类型）</li>
<li>number（数字类型）</li>
<li>string（字符串类型）</li>
<li>array（数组类型）</li>
<li>tuple（元组类型）</li>
<li>enum（枚举类型）</li>
<li>any（任意类型）</li>
<li>null 和 undefined 类型</li>
<li>Symbol 类型</li>
<li>bigint类型</li>
<li>void 类型</li>
<li>never 类型</li>
<li>object 对象类型</li>
<li>unknown</li>
</ul>
<h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><p>布尔类型</p>
<pre><code class="tsx">let flag:boolean = true;
// flag = 123; // 错误
flag = false;  //正确
</code></pre>
<h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><p>数字类型，和<code>javascript</code>一样，<code>typescript</code>的数值类型都是浮点数，可支持二进制、八进制、十进制和十六进制</p>
<pre><code class="tsx">let num:number = 123;
// num = &#39;456&#39;; // 错误
num = 456;  //正确
</code></pre>
<p>进制表示：</p>
<pre><code class="tsx">let decLiteral: number = 6; // 十进制
let hexLiteral: number = 0xf00d; // 十六进制
let binaryLiteral: number = 0b1010; // 二进制
let octalLiteral: number = 0o744; // 八进制
</code></pre>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>字符串类型，和<code>JavaScript</code>一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串</p>
<pre><code class="tsx">let str:string = &#39;this is ts&#39;;
str = &#39;test&#39;;
</code></pre>
<p>作为超集，当然也可以使用模版字符串&#96;&#96;进行包裹，通过 ${} 嵌入变量</p>
<pre><code class="tsx">let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is $&#123; name &#125;
</code></pre>
<h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>数组类型，跟<code>javascript</code>一致，通过<code>[]</code>进行包裹，有两种写法：</p>
<p>方式一：元素类型后面接上 <code>[]</code></p>
<pre><code class="tsx"> let arr:string[] = [&#39;12&#39;, &#39;23&#39;];
 arr = [&#39;45&#39;, &#39;56&#39;];
</code></pre>
<p>方式二：使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<pre><code class="tsx">let arr:Array&lt;number&gt; = [1, 2];
arr = [&#39;45&#39;, &#39;56&#39;];
</code></pre>
<h5 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h5><p>元祖类型，允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p>
<pre><code class="tsx">let tupleArr:[number, string, boolean];
tupleArr = [12, &#39;34&#39;, true]; //ok
typleArr = [12, &#39;34&#39;] // no ok
</code></pre>
<p>赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致</p>
<h5 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h5><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p>
<pre><code class="tsx">enum Color &#123;Red, Green, Blue&#125;
let c: Color = Color.Green;
</code></pre>
<h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><p>可以指定任何类型的值，在编程阶段还不清楚类型的变量指定一个类型，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，这时候可以使用<code>any</code>类型</p>
<p>使用<code>any</code>类型允许被赋值为任意类型，甚至可以调用其属性、方法</p>
<pre><code class="tsx">let num:any = 123;
num = &#39;str&#39;;
num = true;
</code></pre>
<p>定义存储各种类型数据的数组时，示例代码如下：</p>
<pre><code class="tsx">let arrayList: any[] = [1, false, &#39;fine&#39;];
arrayList[1] = 100;
</code></pre>
<h5 id="null-和-和-undefined"><a href="#null-和-和-undefined" class="headerlink" title="null 和 和 undefined"></a>null 和 和 undefined</h5><p>在<code> JavaScript</code> 中 <code>null </code>表示 “什么都没有”，是一个只有一个值的特殊类型，表示一个空对象引用，而<code>undefined</code>表示一个没有设置值的变量</p>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型， 就是说你可以把 <code>null </code>和 <code>undefined </code>赋值给 <code>number </code>类型的变量</p>
<pre><code class="tsx">let num:number | undefined; // 数值类型 或者 undefined
console.log(num); // 正确
num = 123;
console.log(num); // 正确
</code></pre>
<p>但是<code>ts</code>配置了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自</p>
<h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><p>用于标识方法返回值的类型，表示该方法没有返回值。</p>
<pre><code class="tsx">function hello(): void &#123;
    alert(&quot;Hello Runoob&quot;);
&#125;
</code></pre>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>symbol我们平时用的比较少，所以可能了解也不是很多，这里就详细来说说symbol。</p>
<h6 id="（1）symbol-基本使用"><a href="#（1）symbol-基本使用" class="headerlink" title="（1）symbol 基本使用"></a>（1）symbol 基本使用</h6><p>symbol 是 ES6 新增的一种基本数据类型，它用来表示独一无二的值，可以通过 Symbol 构造函数生成。</p>
<pre><code class="typescript">const s = Symbol(); 
typeof s; // symbol
</code></pre>
<p>注意：Symbol 前面不能加 new关键字，直接调用即可创建一个独一无二的 symbol 类型的值。</p>
<p>可以在使用 Symbol 方法创建 symbol 类型值的时候传入一个参数，这个参数需要是一个字符串。如果传入的参数不是字符串，会先自动调用传入参数的 toString 方法转为字符串：</p>
<pre><code class="typescript">const s1 = Symbol(&quot;TypeScript&quot;); 
const s2 = Symbol(&quot;Typescript&quot;); 
console.log(s1 === s2); // false
</code></pre>
<p>上面代码的第三行可能会报一个错误：This condition will always return ‘false’ since the types ‘unique symbol’ and ‘unique symbol’ have no overlap. 这是因为编译器检测到这里的 s1 &#x3D;&#x3D;&#x3D; s2 始终是false，所以编译器提醒这代码写的多余，建议进行优化。</p>
<p>上面使用Symbol创建了两个symbol对象，方法中都传入了相同的字符串，但是两个symbol值仍然是false，这就说明了 Symbol 方法会返回一个独一无二的值。Symbol 方法传入的这个字符串，就是方便我们区分 symbol 值的。可以调用 symbol 值的 toString 方法将它转为字符串：</p>
<pre><code class="typescript">const s1 = Symbol(&quot;Typescript&quot;); 
console.log(s1.toString());  // &#39;Symbol(Typescript)&#39;
console.log(Boolean(s));     // true 
console.log(!s);             // false
</code></pre>
<p>在TypeScript中使用symbol就是指定一个值的类型为symbol类型：</p>
<pre><code class="typescript">let a: symbol = Symbol()
</code></pre>
<p>TypeScript 中还有一个 unique symbol 类型，它是symbol的子类型，这种类型的值只能由<code>Symbol()</code>或<code>Symbol.for()</code>创建，或者通过指定类型来指定变量是这种类型。这种类型的值只能用于常量的定义和用于属性名。需要注意，定义unique symbol类型的值，必须用 const 而不能用let来声明。下面来看在TypeScript中使用Symbol值作为属性名的例子：</p>
<pre><code class="typescript">const key1: unique symbol = Symbol()
let key2: symbol = Symbol()
const obj = &#123;
    [key1]: &#39;value1&#39;,
    [key2]: &#39;value2&#39;
&#125;
console.log(obj[key1]) // value1
console.log(obj[key2]) // error 类型“symbol”不能作为索引类型使用。
</code></pre>
<h6 id="（2）symbol-作为属性名"><a href="#（2）symbol-作为属性名" class="headerlink" title="（2）symbol 作为属性名"></a>（2）symbol 作为属性名</h6><p>在ES6中，对象的属性是支持表达式的，可以使用于一个变量来作为属性名，这对于代码的简化有很多用处，表达式必须放在大括号内：</p>
<pre><code class="typescript">let prop = &quot;name&quot;; 
const obj = &#123; 
  [prop]: &quot;TypeScript&quot; 
&#125;;
console.log(obj.name); // &#39;TypeScript&#39;
</code></pre>
<p>symbol 也可以作为属性名，因为symbol的值是独一无二的，所以当它作为属性名时，不会与其他任何属性名重复。当需要访问这个属性时，只能使用这个symbol值来访问（必须使用方括号形式来访问）：</p>
<pre><code class="typescript">let name = Symbol(); 
let obj = &#123; 
  [name]: &quot;TypeScript&quot; 
&#125;;
console.log(obj); // &#123; Symbol(): &#39;TypeScript&#39; &#125;
console.log(obj[name]); // &#39;TypeScript&#39; 
console.log(obj.name);  // undefined
</code></pre>
<p>在使用obj.name访问时，实际上是字符串name，这和访问普通字符串类型的属性名是一样的，要想访问属性名为symbol类型的属性时，必须使用方括号。方括号中的name才是我们定义的symbol类型的变量name。</p>
<h6 id="（3）symbol-属性名遍历"><a href="#（3）symbol-属性名遍历" class="headerlink" title="（3）symbol 属性名遍历"></a>（3）symbol 属性名遍历</h6><p>使用 Symbol 类型值作为属性名，这个属性是不会被 for…in遍历到的，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 、 JSON.stringify() 等方法获取到：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
for (const key in obj) &#123; 
  console.log(key); 
&#125;  
// =&gt; &#39;age&#39; 
console.log(Object.keys(obj));  // [&#39;age&#39;] 
console.log(Object.getOwnPropertyNames(obj));  // [&#39;age&#39;] 
console.log(JSON.stringify(obj)); // &#39;&#123; &quot;age&quot;: 18 &#125;
</code></pre>
<p>虽然这些方法都不能访问到Symbol类型的属性名，但是Symbol类型的属性并不是私有属性，可以使用 <code>Object.getOwnPropertySymbols</code> 方法获取对象的所有symbol类型的属性名：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
const SymbolPropNames = Object.getOwnPropertySymbols(obj); 
console.log(SymbolPropNames); // [ Symbol(name) ] 
console.log(obj[SymbolPropNames[0]]); // &#39;TypeScript&#39; 
</code></pre>
<p>除了这个方法，还可以使用ES6提供的 Reflect 对象的静态方法 Reflect.ownKeys ，它可以返回所有类型的属性名，Symbol 类型的也会返回：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
console.log(Reflect.ownKeys(obj)); // [ &#39;age&#39;, Symbol(name) ]
</code></pre>
<h6 id="（4）symbol-静态方法"><a href="#（4）symbol-静态方法" class="headerlink" title="（4）symbol 静态方法"></a>（4）symbol 静态方法</h6><p>Symbol 包含两个静态方法， for 和 keyFor 。</p>
<p>1）Symbol.for()</p>
<p>用Symbol创建的symbol类型的值都是独一无二的。使用 Symbol.for 方法传入字符串，会先检查有没有使用该字符串调用 Symbol.for 方法创建的 symbol 值。如果有，返回该值；如果没有，则使用该字符串新创建一个。使用该方法创建 symbol 值后会在全局范围进行注册。</p>
<pre><code class="typescript">const iframe = document.createElement(&quot;iframe&quot;); 
iframe.src = String(window.location); 
document.body.appendChild(iframe); 

iframe.contentWindow.Symbol.for(&quot;TypeScript&quot;) === Symbol.for(&quot;TypeScript&quot;); // true // 注意：如果你在JavaScript环境中这段代码是没有问题的，但是如果在TypeScript开发环境中，可能会报错：类型“Window”上不存在属性“Symbol”。 // 因为这里编译器推断出iframe.contentWindow是Window类型，但是TypeScript的声明文件中，对Window的定义缺少Symbol这个字段，所以会报错，
</code></pre>
<p>上面代码中，创建了一个iframe节点并把它放在body中，通过这个 iframe 对象的 contentWindow 拿到这个 iframe 的 window 对象，在 iframe.contentWindow上添加一个值就相当于在当前页面定义一个全局变量一样。可以看到，在 iframe 中定义的键为 TypeScript 的 symbol 值在和在当前页面定义的键为’TypeScript’的symbol 值相等，说明它们是同一个值。</p>
<p>2）Symbol.keyFor()</p>
<p>该方法传入一个 symbol 值，返回该值在全局注册的键名：</p>
<pre><code class="typescript">const sym = Symbol.for(&quot;TypeScript&quot;); 
console.log(Symbol.keyFor(sym)); // &#39;TypeScript&#39;
</code></pre>
<h5 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h5><p>BigInt是ES6中新引入的数据类型，它是一种内置对象，它提供了一种方法来表示大于 2- 1 的整数，BigInt可以表示任意大的整数。</p>
<p>使用 <code>BigInt</code> 可以安全地存储和操作大整数，即使这个数已经超出了JavaScript构造函数 Number 能够表示的安全整数范围。</p>
<p>我们知道，在 JavaScript 中采用双精度浮点数，这导致精度有限，比如 <code>Number.MAX_SAFE_INTEGER</code> 给出了可以安全递增的最大可能整数，即<code>2- 1</code>，来看一个例子:</p>
<pre><code class="typescript">const max = Number.MAX_SAFE_INTEGER;
const max1 = max + 1
const max2 = max + 2
max1 === max2     // true
</code></pre>
<p>可以看到，最终返回了true，这就是超过精读范围造成的问题，而<code>BigInt</code>正是解决这类问题而生的:</p>
<pre><code class="typescript">const max = BigInt(Number.MAX_SAFE_INTEGER);
const max1 = max + 1n
const max2 = max + 2n
max1 === max2    // false
</code></pre>
<p>这里需要用 <code>BigInt(number)</code> 把 Number 转化为 <code>BigInt</code>，同时如果类型是 <code>BigInt</code> ，那么数字后面需要加 <code>n</code>。</p>
<p>在TypeScript中，<code>number</code> 类型虽然和 <code>BigInt</code> 都表示数字，但是实际上两者类型是完全不同的:</p>
<pre><code class="typescript">declare let foo: number;
declare let bar: bigint;
foo = bar; // error: Type &#39;bigint&#39; is not assignable to type &#39;number&#39;.
bar = foo; // error: Type &#39;number&#39; is not assignable to type &#39;bigint&#39;.
</code></pre>
<h5 id="never"><a href="#never" class="headerlink" title="never"></a>never</h5><p><code>never</code>是其他类型 （包括<code>null</code>和 <code>undefined</code>）的子类型，可以赋值给任何类型，代表从不会出现的值</p>
<p>但是没有类型是 never 的子类型，这意味着声明 <code>never</code> 的变量只能被 <code>never</code> 类型所赋值。</p>
<p><code>never</code> 类型一般用来指定那些总是会抛出异常、无限循环</p>
<pre><code class="tsx">let a:never;
a = 123; // 错误的写法

a = (() =&gt; &#123; // 正确的写法
  throw new Error(&#39;错误&#39;);
&#125;)()

// 返回never的函数必须存在无法达到的终点
function error(message: string): never &#123;
    throw new Error(message);
&#125;
</code></pre>
<h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><p>对象类型，非原始类型，常见的形式通过<code>&#123;&#125;</code>进行包裹</p>
<pre><code class="tsx">let obj:object;
obj = &#123;name: &#39;Wang&#39;, age: 25&#125;;
</code></pre>
<h5 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h5><p>unknown 是TypeScript在3.0版本新增的类型，主要用来描述类型并不确定的变量。它看起来和any很像，但是还是有区别的，unknown相对于any更安全。</p>
<p>对于any，来看一个例子：</p>
<pre><code class="typescript">let value: any
console.log(value.name)
console.log(value.toFixed())
console.log(value.length)
</code></pre>
<p>上面这些语句都不会报错，因为value是any类型，所以后面三个操作都有合法的情况，当value是一个对象时，访问name属性是没问题的；当value是数值类型的时候，调用它的toFixed方法没问题；当value是字符串或数组时获取它的length属性是没问题的。</p>
<p>当指定值为unknown类型的时候，如果没有缩小类型范围的话，是不能对它进行任何操作的。总之，unknown类型的值不能随便操作。那什么是类型范围缩小呢？下面来看一个例子：</p>
<pre><code class="typescript">function getValue(value: unknown): string &#123;
  if (value instanceof Date) &#123; 
    return value.toISOString();
  &#125;
  return String(value);
&#125;
</code></pre>
<p>这里由于把value的类型缩小为Date实例的范围内，所以进行了value.toISOString()，也就是使用ISO标准将 Date 对象转换为字符串。</p>
<p>使用以下方式也可以缩小类型范围：</p>
<pre><code class="typescript">let result: unknown;
if (typeof result === &#39;number&#39;) &#123;
  result.toFixed();
&#125;
</code></pre>
<p>关于 unknown 类型，在使用时需要注意以下几点：</p>
<ul>
<li>任何类型的值都可以赋值给 unknown 类型：</li>
</ul>
<pre><code class="typescript">let value1: unknown;
value1 = &quot;a&quot;;
value1 = 123;
</code></pre>
<ul>
<li>unknown 不可以赋值给其它类型，只能赋值给 unknown 和 any 类型：</li>
</ul>
<pre><code class="typescript">let value2: unknown;
let value3: string = value2; // error 不能将类型“unknown”分配给类型“string”
value1 = value2;
</code></pre>
<ul>
<li>unknown 类型的值不能进行任何操作：</li>
</ul>
<pre><code class="typescript">let value4: unknown;
value4 += 1; // error 对象的类型为 &quot;unknown&quot;
</code></pre>
<ul>
<li>只能对 unknown 进行等或不等操作，不能进行其它操作：</li>
</ul>
<pre><code class="typescript">value1 === value2;
value1 !== value2;
value1 += value2;  // error
</code></pre>
<ul>
<li>unknown 类型的值不能访问其属性、作为函数调用和作为类创建实例：</li>
</ul>
<pre><code class="typescript">let value5: unknown;
value5.age;   // error
value5();     // error
new value5(); // error
</code></pre>
<p>在实际使用中，如果有类型无法确定的情况，要尽量避免使用 any，因为 any 会丢失类型信息，一旦一个类型被指定为 any，那么在它上面进行任何操作都是合法的，所以会有意想不到的情况发生。因此如果遇到无法确定类型的情况，要先考虑使用 unknown。</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>和<code>javascript</code>基本一致，也分成：</p>
<ul>
<li>基本类型</li>
<li>引用类型</li>
</ul>
<p>在基础类型上，<code>typescript</code>增添了<code>void</code>、<code>any</code>、<code>emum</code>等原始类型</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-TypeScript-中枚举类型的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-TypeScript-中枚举类型的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ TypeScript 中枚举类型的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ TypeScript 中枚举类型的理解？应用场景？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型</p>
<p>通俗来说，枚举就是一个对象的所有可能取值的集合</p>
<p>在日常生活中也很常见，例如表示星期的SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY就可以看成是一个枚举</p>
<p>枚举的说明与结构和联合相似，其形式为：</p>
<pre><code class="ini">enum 枚举名&#123;
    标识符①[=整型常数],
    标识符②[=整型常数],
    ...
    标识符N[=整型常数],
&#125;枚举变量;
</code></pre>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>枚举的使用是通过<code>enum</code>关键字进行定义，形式如下：</p>
<pre><code class="tsx">enum xxx &#123; ... &#125;
</code></pre>
<p>声明关键字为枚举类型的方式如下：</p>
<pre><code class="tsx">// 声明d为枚举类型Direction
let d: Direction;
</code></pre>
<p>类型可以分成：</p>
<ul>
<li>数字枚举</li>
<li>字符串枚举</li>
<li>异构枚举</li>
</ul>
<h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><p>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加:</p>
<pre><code class="tsx">enum Direction &#123;
    Up,   // 值默认为 0
    Down, // 值默认为 1
    Left, // 值默认为 2
    Right // 值默认为 3
&#125;

console.log(Direction.Up === 0); // true
console.log(Direction.Down === 1); // true
console.log(Direction.Left === 2); // true
console.log(Direction.Right === 3); // true
</code></pre>
<p>如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加1：</p>
<pre><code class="tsx">enum Direction &#123;
    Up = 10,
    Down,
    Left,
    Right
&#125;

console.log(Direction.Up, Direction.Down, Direction.Left, Direction.Right); // 10 11 12 13
</code></pre>
<h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><pre><code class="tsx">枚举类型的值其实也可以是字符串类型：

enum Direction &#123;
    Up = &#39;Up&#39;,
    Down = &#39;Down&#39;,
    Left = &#39;Left&#39;,
    Right = &#39;Right&#39;
&#125;

console.log(Direction[&#39;Right&#39;], Direction.Up); // Right Up
</code></pre>
<p>如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：</p>
<pre><code class="tsx">enum Direction &#123;
 Up = &#39;UP&#39;,
 Down, // error TS1061: Enum member must have initializer
 Left, // error TS1061: Enum member must have initializer
 Right // error TS1061: Enum member must have initializer
&#125;
</code></pre>
<h4 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h4><p>即将数字枚举和字符串枚举结合起来混合起来使用，如下：</p>
<pre><code class="tsx">enum BooleanLikeHeterogeneousEnum &#123;
    No = 0,
    Yes = &quot;YES&quot;,
&#125;
</code></pre>
<p>通常情况下我们很少会使用异构枚举</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>现在一个枚举的案例如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up,
    Down,
    Left,
    Right
&#125;
</code></pre>
<p>通过编译后，<code>javascript</code>如下：</p>
<pre><code class="tsx">var Direction;
(function (Direction) &#123;
    Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;;
    Direction[Direction[&quot;Down&quot;] = 1] = &quot;Down&quot;;
    Direction[Direction[&quot;Left&quot;] = 2] = &quot;Left&quot;;
    Direction[Direction[&quot;Right&quot;] = 3] = &quot;Right&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
</code></pre>
<p>上述代码可以看到， <code>Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;</code>可以分成</p>
<ul>
<li>Direction[“Up”] &#x3D; 0</li>
<li>Direction[0] &#x3D; “Up”</li>
</ul>
<p>所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up,
    Down,
    Left,
    Right
&#125;

console.log(Direction.Up === 0); // true
console.log(Direction[0]); // Up
</code></pre>
<p>并且多处定义的枚举是可以进行合并操作，如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up = &#39;Up&#39;,
    Down = &#39;Down&#39;,
    Left = &#39;Left&#39;,
    Right = &#39;Right&#39;
&#125;

enum Direction &#123;
    Center = 1
&#125;
</code></pre>
<p>编译后，<code>js</code>代码如下：</p>
<pre><code class="tsx">var Direction;
(function (Direction) &#123;
    Direction[&quot;Up&quot;] = &quot;Up&quot;;
    Direction[&quot;Down&quot;] = &quot;Down&quot;;
    Direction[&quot;Left&quot;] = &quot;Left&quot;;
    Direction[&quot;Right&quot;] = &quot;Right&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
(function (Direction) &#123;
    Direction[Direction[&quot;Center&quot;] = 1] = &quot;Center&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
</code></pre>
<p>可以看到，<code>Direction</code>对象属性回叠加</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：</p>
<pre><code class="tsx">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;

console.log(Days[&quot;Sun&quot;] === 0); // true
console.log(Days[&quot;Mon&quot;] === 1); // true
console.log(Days[&quot;Tue&quot;] === 2); // true
console.log(Days[&quot;Sat&quot;] === 6); // true
</code></pre>
<p>包括后端日常返回0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中接口的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中接口的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中接口的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中接口的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法</p>
<p>简单来讲，一个接口所描述的是一个对象相关的属性和方法，但并不提供具体创建此对象实例的方法</p>
<p><code>typescript</code>的核心功能之一就是对类型做检测，虽然这种检测方式是“鸭式辨型法”，而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定</p>
<h4 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>接口定义如下：</p>
<pre><code class="tsx">interface interface_name &#123;
&#125;
</code></pre>
<p>例如有一个函数，这个函数接受一个 <code>User</code> 对象，然后返回这个 <code>User</code> 对象的 <code>name</code> 属性:</p>
<pre><code class="tsx">const getUserName = (user) =&gt; user.name
</code></pre>
<p>可以看到，参数需要有一个<code>user</code>的<code>name</code>属性，可以通过接口描述<code>user</code>参数的结构</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
&#125;

const getUserName = (user: User) =&gt; user.name
</code></pre>
<p>这些属性并不一定全部实现，上述传入的对象必须拥有<code>name</code>和<code>age</code>属性，否则<code>typescript</code>在编译阶段会报错，如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32356433613739302d306232622d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>如果不想要<code>age</code>属性的话，这时候可以采用可选属性，如下表示：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
&#125;
</code></pre>
<p>这时候<code>age</code>属性则可以是<code>number</code>类型或者<code>undefined</code>类型</p>
<p>有些时候，我们想要一个属性变成只读属性，在<code>typescript</code>只需要使用<code>readonly</code>声明，如下：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
    readonly isMale: boolean
&#125;
</code></pre>
<p>当我们修改属性的时候，就会出现警告，如下所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32663664336333302d306232622d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>这是属性中有一个函数，可以如下表示：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
    readonly isMale: boolean
    say: (words: string) =&gt; string
&#125;
</code></pre>
<p>如果传递的对象不仅仅是上述的属性，这时候可以使用：</p>
<ul>
<li>类型推断</li>
</ul>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
&#125;

const getUserName = (user: User) =&gt; user.name
getUserName(&#123;color: &#39;yellow&#39;&#125; as User)
</code></pre>
<ul>
<li>给接口添加字符串索引签名</li>
</ul>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
    [propName: string]: any;
&#125;
</code></pre>
<p>接口还能实现继承，如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33386134313736302d306232622d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>也可以继承多个，父类通过逗号隔开，如下：</p>
<pre><code class="tsx">interface Father &#123;
    color: String
&#125;

interface Mother &#123;
    height: Number
&#125;

interface Son extends Father,Mother&#123;
    name: string
    age: Number
&#125;
</code></pre>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>例如在<code>javascript</code>中定义一个函数，用来获取用户的姓名和年龄：</p>
<pre><code class="tsx">const getUserInfo = function(user) &#123;
    // ...
    return name: $&#123;user.name&#125;, age: $&#123;user.age&#125;
&#125;
</code></pre>
<p>如果多人开发的都需要用到这个函数的时候，如果没有注释，则可能出现各种运行时的错误，这时候就可以使用接口定义参数变量：</p>
<pre><code class="tsx">// 先定义一个接口
interface IUser &#123;
  name: string;
  age: number;
&#125;

const getUserInfo = (user: IUser): string =&gt; &#123;
  return `name: $&#123;user.name&#125;, age: $&#123;user.age&#125;`;
&#125;;

// 正确的调用
getUserInfo(&#123;name: &quot;koala&quot;, age: 18&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中类的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中类的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中类的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中类的理解？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>
<blockquote>
<p>类是一种用户定义的引用数据类型，也称类类型</p>
</blockquote>
<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本</p>
<p>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多</p>
<p>但是<code> JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类</p>
<p><code>TypeScript</code> 的 <code>class</code> 支持面向对象的所有特性，比如 类、接口等</p>
<h4 id="二、使用方式-1"><a href="#二、使用方式-1" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p>
<ul>
<li>字段： 字段是类里面声明的变量。字段表示对象的有关数据。</li>
<li>构造函数： 类实例化时调用，可以为类的对象分配内存。</li>
<li>方法： 方法为对象要执行的操作</li>
</ul>
<p>如下例子：</p>
<pre><code class="tsx">class Car &#123;
    // 字段
    engine:string;

    // 构造函数
    constructor(engine:string) &#123;
        this.engine = engine
    &#125;

    // 方法
    disp():void &#123;
        console.log(&quot;发动机为 :   &quot;+this.engine)
    &#125;
&#125;
</code></pre>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>类的继承使用过<code>extends</code>的关键字</p>
<pre><code class="tsx">class Animal &#123;
    move(distanceInMeters: number = 0) &#123;
        console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);
    &#125;
&#125;

class Dog extends Animal &#123;
    bark() &#123;
        console.log(&#39;Woof! Woof!&#39;);
    &#125;
&#125;

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
</code></pre>
<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 超类</p>
<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法</p>
<p>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写，通过<code>super</code>关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>
<pre><code class="tsx">class PrinterClass &#123;
   doPrint():void &#123;
      console.log(&quot;父类的 doPrint() 方法。&quot;)
   &#125;
&#125;

class StringPrinter extends PrinterClass &#123;
   doPrint():void &#123;
      super.doPrint() // 调用父类的函数
      console.log(&quot;子类的 doPrint()方法。&quot;)
   &#125;
&#125;
</code></pre>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>可以看到，上述的形式跟<code>ES6</code>十分的相似，<code>typescript</code>在此基础上添加了三种修饰符：</p>
<ul>
<li>公共 public：可以自由的访问类程序里定义的成员</li>
<li>私有 private：只能够在该类的内部进行访问</li>
<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>
</ul>
<h6 id="私有修饰符"><a href="#私有修饰符" class="headerlink" title="私有修饰符"></a>私有修饰符</h6><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66353733363566302d306362342d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>并且继承该类的子类并不能访问，如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30303732636332302d306362352d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h6 id="受保护修饰符"><a href="#受保护修饰符" class="headerlink" title="受保护修饰符"></a>受保护修饰符</h6><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30396537323538302d306362352d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31333766383161302d306362352d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>除了上述修饰符之外，还有只读修饰符</p>
<h6 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h6><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/f0885f89e9d2d9bc7aa7acd9b815cd6f447ab2ed9d3a5c4df4ccd6974599bf53/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31653834386432302d306362352d313165632d386536342d3931666465633066303561312e706e67"><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31653834386432302d306362352d313165632d386536342d3931666465633066303561312e706e67.png" alt="img"></a></p>
<p>除了实例属性之外，同样存在静态属性</p>
<h6 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h6><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示：</p>
<pre><code class="tsx">class Square &#123;
    static width = &#39;100px&#39;
&#125;

console.log(Square.width) // 100px
</code></pre>
<p>上述的类都能发现一个特点就是，都能够被实例化，在 <code>typescript</code>中，还存在一种抽象类</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节</p>
<p><code>abstract </code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>
<pre><code class="tsx">abstract class Animal &#123;
    abstract makeSound(): void;
    move(): void &#123;
        console.log(&#39;roaming the earch...&#39;);
    &#125;
&#125;
</code></pre>
<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>
<pre><code class="tsx">class Cat extends Animal &#123;

    makeSound() &#123;
        console.log(&#39;miao miao&#39;)
    &#125;
&#125;

const cat = new Cat()

cat.makeSound() // miao miao
cat.move() // roaming the earch...
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在 <code>React</code> 工程中是很常用的，如下：</p>
<pre><code class="tsx">export default class Carousel extends React.Component&lt;Props, State&gt; &#123;&#125;
</code></pre>
<p>由于组件需要传入 <code>props</code> 的类型 <code>Props</code> ，同时有需要设置默认 <code>props</code> 即 <code>defaultProps</code>，这时候更加适合使用<code>class</code>作为接口</p>
<p>先声明一个类，这个类包含组件 <code>props</code> 所需的类型和初始值：</p>
<pre><code class="tsx">// props的类型
export default class Props &#123;
  public children: Array&lt;React.ReactElement&lt;any&gt;&gt; | React.ReactElement&lt;any&gt; | never[] = []
  public speed: number = 500
  public height: number = 160
  public animation: string = &#39;easeInOutQuad&#39;
  public isAuto: boolean = true
  public autoPlayInterval: number = 4500
  public afterChange: () =&gt; &#123;&#125;
  public beforeChange: () =&gt; &#123;&#125;
  public selesctedColor: string
  public showDots: boolean = true
&#125;
</code></pre>
<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>
<pre><code class="tsx">public static defaultProps = new Props()
</code></pre>
<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class </code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中函数的理解？与-JavaScript-函数的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中函数的理解？与-JavaScript-函数的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中函数的理解？与 JavaScript 函数的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>函数是<code> JavaScript</code> 应用程序的基础，帮助我们实现抽象层、模拟类、信息隐藏和模块</p>
<p>在<code> TypeScript</code> 里，虽然已经支持类、命名空间和模块，但函数仍然是主要定义行为的方式，<code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，丰富了更多的应用场景</p>
<p>函数类型在 <code>TypeScript</code> 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块</p>
<h4 id="二、使用方式-2"><a href="#二、使用方式-2" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>跟<code>javascript</code> 定义函数十分相似，可以通过<code>funciton</code> 关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>
<pre><code class="tsx">const add = (a: number, b: number) =&gt; a + b
</code></pre>
<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上<code> TypeScript</code> 编译器是能够通过类型推断到这个函数的类型，如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34623334313562302d306434322d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>当鼠标放置在第三行<code>add</code>函数名的时候，会出现完整的函数定义类型，通过<code>:</code> 的形式来定于参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>
<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>
<pre><code class="tsx">// 方式一
type LongHand = &#123;
  (a: number): number;
&#125;;

// 方式二
type ShortHand = (a: number) =&gt; number;
</code></pre>
<p>当存在函数重载时，只能使用方式一的形式</p>
<h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>
<pre><code class="tsx">const add = (a: number, b?: number) =&gt; a + (b ? b : 0)
</code></pre>
<p>这时候参数<code>b</code>可以是<code>number</code>类型或者<code>undefined</code>类型，即可以传一个<code>number</code>类型或者不传都可以</p>
<h5 id="剩余类型"><a href="#剩余类型" class="headerlink" title="剩余类型"></a>剩余类型</h5><p>剩余参数与<code>JavaScript</code>的语法类似，需要用 <code>...</code> 来表示剩余参数</p>
<p>如果剩余参数 <code>rest</code> 是一个由<code>number</code>类型组成的数组，则如下表示：</p>
<pre><code class="tsx">const add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a)
</code></pre>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>
<p>关于<code>typescript</code>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|</code>操作符或者<code>?</code>操作符，把所有可能的输入类型全部包含进去，用于具体实现</p>
<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，<code>typescript</code>并不会真的将你的多个重名 <code>function </code>的函数体进行合并</p>
<p>例如我们有一个add函数，它可以接收 <code>string</code>类型的参数进行拼接，也可以接收 <code>number</code> 类型的参数进行相加，如下：</p>
<pre><code class="tsx">// 上边是声明
function add (arg1: string, arg2: string): string
function add (arg1: number, arg2: number): number
// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字

// 下边是实现
function add (arg1: string | number, arg2: string | number) &#123;
  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2
  if (typeof arg1 === &#39;string&#39; &amp;&amp; typeof arg2 === &#39;string&#39;) &#123;
    return arg1 + arg2
  &#125; else if (typeof arg1 === &#39;number&#39; &amp;&amp; typeof arg2 === &#39;number&#39;) &#123;
    return arg1 + arg2
  &#125;
&#125;
</code></pre>
<h4 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h4><p>从上面可以看到：</p>
<ul>
<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>
<li>typescript 在参数中，添加可选参数供使用者选择</li>
<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中泛型的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中泛型的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中泛型的理解？应用场景？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p>
<p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型<br>在<code>typescript</code>中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性</p>
<p>假设我们用一个函数，它可接受一个 <code>number</code> 参数并返回一个<code> number</code> 参数，如下写法：</p>
<pre><code class="tsx">function returnItem (para: number): number &#123;
    return para
&#125;
</code></pre>
<p>如果我们打算接受一个 <code>string</code> 类型，然后再返回 <code>string</code>类型，则如下写法：</p>
<pre><code class="tsx">function returnItem (para: string): string &#123;
    return para
&#125;
</code></pre>
<p>上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高</p>
<p>虽然可以使用 <code>any</code>类型去替代，但这也并不是很好的方案，因为我们的目的是接收什么类型的参数返回什么类型的参数，即在运行时传入参数我们才能确定类型</p>
<p>这种情况就可以使用泛型，如下所示：</p>
<pre><code class="tsx">function returnItem&lt;T&gt;(para: T): T &#123;
    return para
&#125;
</code></pre>
<p>可以看到，泛型给予开发者创造灵活、可重用代码的能力</p>
<h4 id="二、使用方式-3"><a href="#二、使用方式-3" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明：</p>
<ul>
<li>函数</li>
<li>接口</li>
<li>类</li>
</ul>
<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>声明函数的形式如下：</p>
<pre><code class="tsx">function returnItem&lt;T&gt;(para: T): T &#123;
    return para
&#125;
</code></pre>
<p>定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 <code>T</code> 和 泛型 <code>U</code>：</p>
<pre><code class="tsx">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;
    return [tuple[1], tuple[0]];
&#125;

swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]
</code></pre>
<h5 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h5><p>声明接口的形式如下：</p>
<pre><code class="tsx">interface ReturnItemFn&lt;T&gt; &#123;
    (para: T): T
&#125;
</code></pre>
<p>那么当我们想传入一个number作为参数的时候，就可以这样声明函数:</p>
<pre><code class="tsx">const returnItem: ReturnItemFn&lt;number&gt; = para =&gt; para
</code></pre>
<h5 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h5><p>使用泛型声明类的时候，既可以作用于类本身，也可以作用与类的成员函数</p>
<p>下面简单实现一个元素同类型的栈结构，如下所示：</p>
<pre><code class="tsx">class Stack&lt;T&gt; &#123;
    private arr: T[] = []
    public push(item: T) &#123;
        this.arr.push(item)
    &#125;
    public pop() &#123;
        this.arr.pop()
    &#125;
&#125;
</code></pre>
<p>使用方式如下：</p>
<pre><code class="tsx">const stack = new Stacn&lt;number&gt;()
</code></pre>
<p>如果上述只能传递 <code>string</code> 和 <code>number</code> 类型，这时候就可以使用 <code>&lt;T extends xx&gt;</code> 的方式猜实现约束泛型，如下所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36376432313261302d306531372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>除了上述的形式，泛型更高级的使用如下：</p>
<p>例如要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值</p>
<p>这时候就设计到泛型的索引类型和约束类型共同实现</p>
<h5 id="索引类型、约束类型"><a href="#索引类型、约束类型" class="headerlink" title="索引类型、约束类型"></a>索引类型、约束类型</h5><p>索引类型 <code>keyof T</code> 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，如下所示：</p>
<pre><code class="tsx">function getValue&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) &#123;
  return obj[key] // ok
&#125;
</code></pre>
<p>上述为什么需要使用泛型约束，而不是直接定义第一个参数为 <code>object</code>类型，是因为默认情况 <code>object</code> 指的是<code>&#123;&#125;</code>，而我们接收的对象是各种各样的，一个泛型来表示传入的对象类型，比如 <code>T extends object</code></p>
<p>使用如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37346663626434302d306531372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="多类型约束"><a href="#多类型约束" class="headerlink" title="多类型约束"></a>多类型约束</h5><p>例如如下需要实现两个接口的类型约束：</p>
<pre><code class="tsx">interface FirstInterface &#123;
  doSomething(): number
&#125;

interface SecondInterface &#123;
  doSomethingElse(): string
&#125;
</code></pre>
<p>可以创建一个接口继承上述两个接口，如下：</p>
<pre><code class="tsx">interface ChildInterface extends FirstInterface, SecondInterface &#123;

&#125;
</code></pre>
<p>正确使用如下：</p>
<pre><code class="tsx">class Demo&lt;T extends ChildInterface&gt; &#123;
  private genericProperty: T

  constructor(genericProperty: T) &#123;
    this.genericProperty = genericProperty
  &#125;
  useT() &#123;
    this.genericProperty.doSomething()
    this.genericProperty.doSomethingElse()
  &#125;
&#125;
</code></pre>
<p>通过泛型约束就可以达到多类型约束的目的</p>
<h4 id="三、应用场景-3"><a href="#三、应用场景-3" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>通过上面初步的了解，后述在编写 <code>typescript</code> 的时候，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性的时候，这种情况下就可以使用泛型</p>
<p>灵活的使用泛型定义类型，是掌握<code>typescript</code> 必经之路</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中高级类型的理解？有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中高级类型的理解？有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中高级类型的理解？有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中高级类型的理解？有哪些？</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>除了<code>string</code>、<code>number</code>、<code>boolean</code> 这种基础类型外，在 <code>typescript</code> 类型声明中还存在一些高级的类型应用</p>
<p>这些高级类型，是<code>typescript</code>为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景</p>
<h4 id="二、有哪些-1"><a href="#二、有哪些-1" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的高级类型有如下：</p>
<ul>
<li>交叉类型</li>
<li>联合类型</li>
<li>类型别名</li>
<li>类型索引</li>
<li>类型约束</li>
<li>映射类型</li>
<li>条件类型</li>
</ul>
<h5 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h5><p>通过 <code>&amp;</code> 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作</p>
<p>语法如下：</p>
<pre><code class="ini">T &amp; U
</code></pre>
<p>适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：</p>
<pre><code class="tsx">function extend&lt;T , U&gt;(first: T, second: U) : T &amp; U &#123;
    let result: &lt;T &amp; U&gt; = &#123;&#125;
    for (let key in first) &#123;
        result[key] = first[key]
    &#125;
    for (let key in second) &#123;
        if(!result.hasOwnProperty(key)) &#123;
            result[key] = second[key]
        &#125;
    &#125;
    return result
&#125;
</code></pre>
<h5 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h5><p>联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系</p>
<p>语法如下：</p>
<pre><code class="ini">T | U
</code></pre>
<p>例如 <code>number</code> | <code>string</code> | <code>boolean</code> 的类型只能是这三个的一种，不能共存</p>
<p>如下所示：</p>
<pre><code class="tsx">function formatCommandline(command: string[] | string) &#123;
  let line = &#39;&#39;;
  if (typeof command === &#39;string&#39;) &#123;
    line = command.trim();
  &#125; else &#123;
    line = command.join(&#39; &#39;).trim();
  &#125;
&#125;
</code></pre>
<h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型</p>
<p>可以使用 <code>type SomeName = someValidTypeAnnotation</code>的语法来创建类型别名：</p>
<pre><code class="tsx">type some = boolean | string

const b: some = true // ok
const c: some = &#39;hello&#39; // ok
const d: some = 123 // 不能将类型“123”分配给类型“some”
</code></pre>
<p>此外类型别名可以是泛型:</p>
<pre><code class="tsx">type Container&lt;T&gt; = &#123; value: T &#125;;
</code></pre>
<p>也可以使用类型别名来在属性里引用自己：</p>
<pre><code class="tsx">type Tree&lt;T&gt; = &#123;
    value: T;
    left: Tree&lt;T&gt;;
    right: Tree&lt;T&gt;;
&#125;
</code></pre>
<p>可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数</p>
<p>两者最大的区别在于，<code>interface </code>只能用于定义对象类型，而 <code>type</code> 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛</p>
<h5 id="类型索引"><a href="#类型索引" class="headerlink" title="类型索引"></a>类型索引</h5><p><code>keyof</code> 类似于 <code>Object.keys</code> ，用于获取一个接口中 Key 的联合类型。</p>
<pre><code class="tsx">interface Button &#123;
    type: string
    text: string
&#125;

type ButtonKeys = keyof Button
// 等效于
type ButtonKeys = &quot;type&quot; | &quot;text&quot;
</code></pre>
<h5 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h5><p>通过关键字 <code>extend</code> 进行约束，不同于在 <code>class</code> 后使用 <code>extends</code> 的继承作用，泛型内使用的主要作用是对泛型加以约束</p>
<pre><code class="tsx">type BaseType = string | number | boolean

// 这里表示 copy 的参数
// 只能是字符串、数字、布尔这几种基础类型
function copy&lt;T extends BaseType&gt;(arg: T): T &#123;
  return arg
&#125;
</code></pre>
<p>类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 <code>extends</code> 和 <code>keyof</code> 进行约束。</p>
<pre><code class="tsx">function getValue&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123;
  return obj[key]
&#125;

const obj = &#123; a: 1 &#125;
const a = getValue(obj, &#39;a&#39;)
</code></pre>
<h5 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h5><p>通过 <code>in</code> 关键字做类型的映射，遍历已有接口的 <code>key</code> 或者是遍历联合类型，如下例子：</p>
<pre><code class="tsx">type Readonly&lt;T&gt; = &#123;
    readonly [P in keyof T]: T[P];
&#125;;

interface Obj &#123;
  a: string
  b: string
&#125;

type ReadOnlyObj = Readonly&lt;Obj&gt;
</code></pre>
<p>上述的结构，可以分成这些步骤：</p>
<ul>
<li>keyof T：通过类型索引 keyof 的得到联合类型 ‘a’ | ‘b’</li>
<li>P in keyof T 等同于 p in ‘a’ | ‘b’，相当于执行了一次 forEach 的逻辑，遍历 ‘a’ | ‘b’</li>
</ul>
<p>所以最终<code>ReadOnlyObj</code>的接口为下述：</p>
<pre><code class="tsx">interface ReadOnlyObj &#123;
    readonly a: string;
    readonly b: string;
&#125;
</code></pre>
<h5 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h5><p>条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。</p>
<pre><code class="tsx">T extends U ? X : Y
</code></pre>
<p>上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y</p>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，如果只是掌握了 <code>typeScript</code> 的一些基础类型，可能很难游刃有余的去使用 <code>typeScript</code>，需要了解一些<code>typescript</code>的高阶用法</p>
<p>并且<code>typescript</code>在版本的迭代中新增了很多功能，需要不断学习与掌握</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-装饰器的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-装饰器的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 装饰器的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 装饰器的理解？应用场景？</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上</p>
<p>是一种在不改变原类和使用继承的情况下，动态地扩展对象功能</p>
<p>同样的，本质也不是什么高大上的结构，就是一个普通的函数，<code>@expression</code> 的形式其实是<code>Object.defineProperty</code>的语法糖</p>
<p><code>expression </code>求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p>
<h4 id="二、使用方式-4"><a href="#二、使用方式-4" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>由于<code>typescript</code>是一个实验性特性，若要使用，需要在<code>tsconfig.json</code>文件启动，如下：</p>
<pre><code class="tsx">&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;ES5&quot;,
        &quot;experimentalDecorators&quot;: true
    &#125;
&#125;
</code></pre>
<p><code>typescript</code>装饰器的使用和<code>javascript</code>基本一致</p>
<p>类的装饰器可以装饰：</p>
<ul>
<li>类</li>
<li>方法&#x2F;属性</li>
<li>参数</li>
<li>访问器</li>
</ul>
<h5 id="类装饰"><a href="#类装饰" class="headerlink" title="类装饰"></a>类装饰</h5><p>例如声明一个函数 <code>addAge</code> 去给 Class 的属性 <code>age</code> 添加年龄.</p>
<pre><code class="tsx">function addAge(constructor: Function) &#123;
  constructor.prototype.age = 18;
&#125;

@addAge
class Person&#123;
  name: string;
  age!: number;
  constructor() &#123;
    this.name = &#39;huihui&#39;;
  &#125;
&#125;

let person = new Person();

console.log(person.age); // 18
</code></pre>
<p>上述代码，实际等同于以下形式：</p>
<pre><code class="tsx">Person = addAge(function Person() &#123; ... &#125;);
</code></pre>
<p>上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 <code>constructor.prototype.age</code> 就是在每一个实例化对象上面添加一个 <code>age</code> 属性</p>
<h5 id="方法-x2F-属性装饰"><a href="#方法-x2F-属性装饰" class="headerlink" title="方法&#x2F;属性装饰"></a>方法&#x2F;属性装饰</h5><p>同样，装饰器可以用于修饰类的方法，这时候装饰器函数接收的参数变成了：</p>
<ul>
<li>target：对象的原型</li>
<li>propertyKey：方法的名称</li>
<li>descriptor：方法的属性描述符</li>
</ul>
<p>可以看到，这三个属性实际就是<code>Object.defineProperty</code>的三个参数，如果是类的属性，则没有传递第三个参数</p>
<p>如下例子：</p>
<pre><code class="tsx">// 声明装饰器修饰方法/属性
function method(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;
  console.log(target);
  console.log(&quot;prop &quot; + propertyKey);
  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);
  descriptor.writable = false;
&#125;;

function property(target: any, propertyKey: string) &#123;
  console.log(&quot;target&quot;, target)
  console.log(&quot;propertyKey&quot;, propertyKey)
&#125;

class Person&#123;
 @property
 name: string;
 constructor() &#123;
   this.name = &#39;huihui&#39;;
 &#125;

 @method
 say()&#123;
   return &#39;instance method&#39;;
 &#125;

 @method
 static run()&#123;
   return &#39;static method&#39;;
 &#125;
&#125;

const xmz = new Person();

// 修改实例方法say
xmz.say = function() &#123;
 return &#39;edit&#39;
&#125;
</code></pre>
<p>输出如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65393662633162302d313134642d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h5 id="参数装饰"><a href="#参数装饰" class="headerlink" title="参数装饰"></a>参数装饰</h5><p>接收3个参数，分别是：</p>
<ul>
<li>target ：当前对象的原型</li>
<li>propertyKey ：参数的名称</li>
<li>index：参数数组中的位置</li>
</ul>
<pre><code class="tsx">function logParameter(target: Object, propertyName: string, index: number) &#123;
  console.log(target);
  console.log(propertyName);
  console.log(index);
&#125;

class Employee &#123;
  greet(@logParameter message: string): string &#123;
      return `hello $&#123;message&#125;`;
  &#125;
&#125;
const emp = new Employee();
emp.greet(&#39;hello&#39;);
</code></pre>
<p>输入如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326633326465302d313134642d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="访问器装饰"><a href="#访问器装饰" class="headerlink" title="访问器装饰"></a>访问器装饰</h5><p>使用起来方式与方法装饰一致，如下：</p>
<pre><code class="tsx">function modification(target: Object, propertyKey: string, descriptor: PropertyDescriptor) &#123;
  console.log(target);
  console.log(&quot;prop &quot; + propertyKey);
  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);
&#125;;

class Person&#123;
 _name: string;
 constructor() &#123;
   this._name = &#39;huihui&#39;;
 &#125;

 @modification
 get name() &#123;
   return this._name
 &#125;
&#125;
</code></pre>
<h5 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h5><p>如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：</p>
<pre><code class="tsx">function addAge(age: number) &#123;
  return function(constructor: Function) &#123;
    constructor.prototype.age = age
  &#125;
&#125;

@addAge(10)
class Person&#123;
  name: string;
  age!: number;
  constructor() &#123;
    this.name = &#39;huihui&#39;;
  &#125;
&#125;

let person = new Person();
</code></pre>
<h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><p>当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用，例如如下：</p>
<pre><code class="tsx">function f() &#123;
    console.log(&quot;f(): evaluated&quot;);
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123;
        console.log(&quot;f(): called&quot;);
    &#125;
&#125;

function g() &#123;
    console.log(&quot;g(): evaluated&quot;);
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123;
        console.log(&quot;g(): called&quot;);
    &#125;
&#125;

class C &#123;
    @f()
    @g()
    method() &#123;&#125;
&#125;

// 输出
f(): evaluated
g(): evaluated
g(): called
f(): called
</code></pre>
<h4 id="三、应用场景-4"><a href="#三、应用场景-4" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>可以看到，使用装饰器存在两个显著的优点：</p>
<ul>
<li>代码可读性变强了，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原来功能进行扩展</li>
</ul>
<p>后面的使用场景中，借助装饰器的特性，除了提高可读性之后，针对已经存在的类，可以通过装饰器的特性，在不改变原有代码情况下，对原来功能进行扩展</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中命名空间与模块的理解？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中命名空间与模块的理解？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中命名空间与模块的理解？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中命名空间与模块的理解？区别？</h3><h4 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h4><p><code>TypeScript</code> 与<code> ECMAScript</code> 2015 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块</p>
<p>相反地，如果一个文件不带有顶级的<code>import</code>或者<code>export</code>声明，那么它的内容被视为全局可见的</p>
<p>例如我们在在一个 <code>TypeScript</code> 工程下建立一个文件 <code>1.ts</code>，声明一个变量<code>a</code>，如下：</p>
<pre><code class="tsx">const a = 1
</code></pre>
<p>然后在另一个文件同样声明一个变量<code>a</code>，这时候会出现错误信息</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61323339643937302d313337652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>提示重复声明<code>a</code>变量，但是所处的空间是全局的</p>
<p>如果需要解决这个问题，则通过<code>import</code>或者<code>export</code>引入模块系统即可，如下：</p>
<pre><code class="tsx">const a = 10;

export default a
</code></pre>
<p>在<code>typescript</code>中，<code>export</code>关键字可以导出变量或者类型，用法与<code>es6</code>模块一致，如下：</p>
<pre><code class="tsx">export const a = 1
export type Person = &#123;
    name: String
&#125;
</code></pre>
<p>通过<code>import</code> 引入模块，如下：</p>
<pre><code class="tsx">import &#123; a, Person &#125; from &#39;./export&#39;;
</code></pre>
<h4 id="二、命名空间"><a href="#二、命名空间" class="headerlink" title="二、命名空间"></a>二、命名空间</h4><p>命名空间一个最明确的目的就是解决重名问题</p>
<p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的</p>
<p>这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p>
<p><code>TypeScript</code> 中命名空间使用 <code>namespace</code> 来定义，语法格式如下：</p>
<pre><code class="tsx">namespace SomeNameSpaceName &#123;
   export interface ISomeInterfaceName &#123;      &#125;
   export class SomeClassName &#123;      &#125;
&#125;
</code></pre>
<p>以上定义了一个命名空间 <code>SomeNameSpaceName</code>，如果我们需要在外部可以调用 <code>SomeNameSpaceName</code> 中的类和接口，则需要在类和接口添加 <code>export</code> 关键字</p>
<p>使用方式如下：</p>
<pre><code class="ini">SomeNameSpaceName.SomeClassName
</code></pre>
<p>命名空间本质上是一个对象，作用是将一系列相关的全局变量组织到一个对象的属性，如下：</p>
<pre><code class="tsx">namespace Letter &#123;
  export let a = 1;
  export let b = 2;
  export let c = 3;
  // ...
  export let z = 26;
&#125;
</code></pre>
<p>编译成<code>js</code>如下：</p>
<pre><code class="tsx">var Letter;
(function (Letter) &#123;
    Letter.a = 1;
    Letter.b = 2;
    Letter.c = 3;
    // ...
    Letter.z = 26;
&#125;)(Letter || (Letter = &#123;&#125;));
</code></pre>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><ul>
<li>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中</li>
<li>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖</li>
<li>在正常的TS项目开发过程中并不建议用命名空间，但通常在通过 d.ts 文件标记 js 库类型的时候使用命名空间，主要作用是给编译器编写代码的时候参考使用</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在Vue项目中应用TypeScript？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在Vue项目中应用TypeScript？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Vue项目中应用TypeScript？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Vue项目中应用TypeScript？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>与link类似</p>
<p>在<code>VUE</code>项目中应用<code>typescript</code>，我们需要引入一个库<code>vue-property-decorator</code>，</p>
<p>其是基于<code>vue-class-component</code>库而来，这个库<code>vue</code>官方推出的一个支持使用<code>class</code>方式来开发<code>vue</code>单文件组件的库</p>
<p>主要的功能如下：</p>
<ul>
<li>methods 可以直接声明为类的成员方法</li>
<li>计算属性可以被声明为类的属性访问器</li>
<li>初始化的 data 可以被声明为类属性</li>
<li>data、render 以及所有的 Vue 生命周期钩子可以直接作为类的成员方法</li>
<li>所有其他属性，需要放在装饰器中</li>
</ul>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p>vue-property-decorator 主要提供了多个装饰器和一个函数:</p>
<ul>
<li>@prop</li>
<li>@ProPsync</li>
<li>@model</li>
<li>@watch</li>
<li>@provide</li>
<li>@Inject</li>
<li>@ProvideReactive</li>
<li>@InjectReactive</li>
<li>@emit</li>
<li>@ref</li>
<li>@component (由 vue-class-component 提供)</li>
<li>Mixins (由 vue-class-component 提供)</li>
</ul>
<h5 id="component"><a href="#component" class="headerlink" title="@component"></a><a target="_blank" rel="noopener" href="https://github.com/component">@component</a></h5><p><code>Component</code>装饰器它注明了此类为一个<code>Vue</code>组件，因此即使没有设置选项也不能省略</p>
<p>如果需要定义比如 <code>name</code>、<code>components</code>、<code>filters</code>、<code>directives</code>以及自定义属性，就可以在<code>Component</code>装饰器中定义，如下：</p>
<pre><code class="tsx">import &#123;Component,Vue&#125; from &#39;vue-property-decorator&#39;;
import &#123;componentA,componentB&#125; from &#39;@/components&#39;;

 @Component(&#123;
    components:&#123;
        componentA,
        componentB,
    &#125;,
    directives: &#123;
        focus: &#123;
            // 指令的定义
            inserted: function (el) &#123;
                el.focus()
            &#125;
        &#125;
    &#125;
&#125;)
export default class YourCompoent extends Vue&#123;
   
&#125;
</code></pre>
<h5 id="computed、data、methods"><a href="#computed、data、methods" class="headerlink" title="computed、data、methods"></a>computed、data、methods</h5><p>这里取消了组件的data和methods属性，以往data返回对象中的属性、methods中的方法需要直接定义在Class中，当做类的属性和方法</p>
<pre><code class="tsx">@Component
export default class HelloDecorator extends Vue &#123;
    count: number = 123 // 类属性相当于以前的 data

    add(): number &#123; // 类方法就是以前的方法
        this.count + 1
    &#125;

    // 获取计算属性
    get total(): number &#123;
      return this.count + 1
    &#125;

    // 设置计算属性
    set total(param:number): void &#123;
      this.count = param
    &#125;
&#125;
</code></pre>
<h5 id="props"><a href="#props" class="headerlink" title="@props"></a><a target="_blank" rel="noopener" href="https://github.com/props">@props</a></h5><p>组件接收属性的装饰器，如下使用：</p>
<pre><code class="tsx">import &#123;Component,Vue,Prop&#125; from vue-property-decorator;

@Component
export default class YourComponent extends Vue &#123;
    @Prop(String)
    propA:string;
    
    @Prop([String,Number])
    propB:string|number;
    
    @Prop(&#123;
     type: String, // type: [String , Number]
     default: &#39;default value&#39;, // 一般为String或Number
      //如果是对象或数组的话。默认值从一个工厂函数中返回
      // defatult: () =&gt; &#123;
      //     return [&#39;a&#39;,&#39;b&#39;]
      // &#125;
     required: true,
     validator: (value) =&gt; &#123;
        return [
          &#39;InProcess&#39;,
          &#39;Settled&#39;
        ].indexOf(value) !== -1
     &#125;
    &#125;)
    propC:string;
&#125;
</code></pre>
<h5 id="watch"><a href="#watch" class="headerlink" title="@watch"></a><a target="_blank" rel="noopener" href="https://github.com/watch">@watch</a></h5><p>实际就是<code>Vue</code>中的监听器，如下：</p>
<pre><code class="tsx">import &#123; Vue, Component, Watch &#125; from &#39;vue-property-decorator&#39;

@Component
export default class YourComponent extends Vue &#123;
  @Watch(&#39;child&#39;)
  onChildChanged(val: string, oldVal: string) &#123;&#125;

  @Watch(&#39;person&#39;, &#123; immediate: true, deep: true &#125;)
  onPersonChanged1(val: Person, oldVal: Person) &#123;&#125;

  @Watch(&#39;person&#39;)
  onPersonChanged2(val: Person, oldVal: Person) &#123;&#125;
&#125;
</code></pre>
<h5 id="emit"><a href="#emit" class="headerlink" title="@emit"></a><a target="_blank" rel="noopener" href="https://github.com/emit">@emit</a></h5><p><code>vue-property-decorator</code> 提供的 <code>@Emit</code> 装饰器就是代替<code>Vue </code>中的事件的触发<code>$emit</code>，如下：</p>
<pre><code class="tsx">import &#123;Vue, Component, Emit&#125; from &#39;vue-property-decorator&#39;;
    @Component(&#123;&#125;)
    export default class Some extends Vue&#123;
        mounted()&#123;
            this.$on(&#39;emit-todo&#39;, function(n) &#123;
                console.log(n)
            &#125;)
            this.emitTodo(&#39;world&#39;);
        &#125;
        @Emit()
        emitTodo(n: string)&#123;
            console.log(&#39;hello&#39;);
        &#125;
    &#125;
</code></pre>
<h4 id="三-、总结"><a href="#三-、总结" class="headerlink" title="三 、总结"></a>三 、总结</h4><p>可以看到上述<code>typescript</code>版本的<code>vue class</code>的语法与平时<code>javascript</code>版本使用起来还是有很大的不同，多处用到<code>class</code>与装饰器，但实际上本质是一致的，只有不断编写才会得心应手</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在React项目中应用TypeScript？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在React项目中应用TypeScript？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在React项目中应用TypeScript？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在React项目中应用TypeScript？</h3><h4 id="一、前言-1"><a href="#一、前言-1" class="headerlink" title="一、前言"></a>一、前言</h4><p>单独的使用 <code>TypeScript</code> 并不会导致学习成本很高，但是绝大部分前端开发者的项目都是依赖于框架的</p>
<p>例如与 <code>Vue</code>、<code>React</code> 这些框架结合使用的时候，会有一定的门槛</p>
<p>使用 <code>TypeScript</code> 编写 <code>React</code> 代码，除了需要 <code>TypeScript</code> 这个库之外，还需要安装 <code>@types/react</code>、<code>@types/react-dom</code></p>
<pre><code class="bash">npm i @types/react -s

npm i @types/react-dom -s
</code></pre>
<p>至于上述使用 <code>@types</code> 的库的原因在于，目前非常多的 <code>JavaScript</code> 库并没有提供自己关于 <code>TypeScript</code> 的声明文件</p>
<p>所以，<code>ts</code> 并不知道这些库的类型以及对应导出的内容，这里 <code>@types</code> 实际就是社区中的 <code>DefinitelyTyped</code> 库，定义了目前市面上绝大多数的 <code>JavaScript</code> 库的声明</p>
<p>所以下载相关的 <code>JavaScript</code> 对应的 <code>@types</code> 声明时，就能够使用使用该库对应的类型定义</p>
<h4 id="二、使用方式-5"><a href="#二、使用方式-5" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>在编写 <code>React</code> 项目的时候，最常见的使用的组件就是：</p>
<ul>
<li>无状态组件</li>
<li>有状态组件</li>
<li>受控组件</li>
</ul>
<h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><p>主要作用是用于展示 <code>UI</code>，如果使用 <code>js</code> 声明，则如下所示：</p>
<pre><code class="jsx">import * as React from &quot;React&quot;;

export const Logo = (props) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<p>但这时候 <code>ts</code> 会出现报错提示，原因在于没有定义 <code>porps</code> 类型，这时候就可以使用 <code>interface</code> 接口去定义 <code>porps</code> 即可，如下：</p>
<pre><code class="tsx">import * as React from &quot;React&quot;;

interface IProps &#123;
  logo?: string;
  className?: string;
  alt?: string;
&#125;

export const Logo = (props: IProps) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<p>但是我们都知道 <code>props</code> 里面存在 <code>children</code> 属性，我们不可能每个 <code>porps</code> 接口里面定义多一个 <code>children</code>，如下：</p>
<pre><code class="tsx">interface IProps &#123;
  logo?: string;
  className?: string;
  alt?: string;
  children?: ReactNode;
&#125;
</code></pre>
<p>更加规范的写法是使用 <code>React</code> 里面定义好的 <code>FC</code> 属性，里面已经定义好 <code>children</code> 类型，如下：</p>
<pre><code class="tsx">export const Logo: React.FC&lt;IProps&gt; = (props) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<ul>
<li>React.FC 显式地定义了返回类型，其他方式是隐式推导的</li>
<li>React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全</li>
<li>React.FC 为 children 提供了隐式的类型（ReactElement | null）</li>
</ul>
<h5 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h5><p>可以是一个类组件且存在 <code>props</code> 和 <code>state</code> 属性</p>
<p>如果使用 <code>TypeScript</code> 声明则如下所示：</p>
<pre><code class="tsx">import * as React from &quot;React&quot;;

interface IProps &#123;
  color: string;
  size?: string;
&#125;
interface IState &#123;
  count: number;
&#125;
class App extends React.Component&lt;IProps, IState&gt; &#123;
  public state = &#123;
    count: 1,
  &#125;;
  public render() &#123;
    return &lt;div&gt;Hello world&lt;/div&gt;;
  &#125;
&#125;
</code></pre>
<p>上述通过泛型对 <code>props</code>、<code>state</code> 进行类型定义，然后在使用的时候就可以在编译器中获取更好的智能提示</p>
<p>关于 <code>Component</code> 泛型类的定义，可以参考下 React 的类型定义文件 <code>node_modules/@types/React/index.d.ts</code>，如下所示：</p>
<pre><code class="ts">class Component&lt;P, S&gt; &#123;
  readonly props: Readonly&lt;&#123; children?: ReactNode &#125;&gt; &amp; Readonly&lt;P&gt;;

  state: Readonly&lt;S&gt;;
&#125;
</code></pre>
<p>从上述可以看到，<code>state</code> 属性也定义了可读类型，目的是为了防止直接调用 <code>this.state</code> 更新状态</p>
<h5 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h5><p>受控组件的特性在于元素的内容通过组件的状态 <code>state</code> 进行控制</p>
<p>由于组件内部的事件是合成事件，不等同于原生事件，</p>
<p>例如一个 <code>input</code> 组件修改内部的状态，常见的定义的时候如下所示：</p>
<pre><code class="ts">private updateValue(e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#123;
    this.setState(&#123; itemText: e.target.value &#125;)
&#125;
</code></pre>
<p>常用 <code>Event</code> 事件对象类型：</p>
<ul>
<li>ClipboardEvent&lt;T &#x3D; Element&gt; 剪贴板事件对象</li>
<li>DragEvent&lt;T &#x3D; Element&gt; 拖拽事件对象</li>
<li>ChangeEvent&lt;T &#x3D; Element&gt; Change 事件对象</li>
<li>KeyboardEvent&lt;T &#x3D; Element&gt; 键盘事件对象</li>
<li>MouseEvent&lt;T &#x3D; Element&gt; 鼠标事件对象</li>
<li>TouchEvent&lt;T &#x3D; Element&gt; 触摸事件对象</li>
<li>WheelEvent&lt;T &#x3D; Element&gt; 滚轮事件对象</li>
<li>AnimationEvent&lt;T &#x3D; Element&gt; 动画事件对象</li>
<li>TransitionEvent&lt;T &#x3D; Element&gt; 过渡事件对象</li>
</ul>
<p><code>T</code> 接收一个 <code>DOM</code> 元素类型</p>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>上述只是简单的在 <code>React</code> 项目使用 <code>TypeScript</code>，但在编写 <code>React</code> 项目的时候，还存在 <code>hooks</code>、默认参数、以及 <code>store</code> 等等……</p>
<p><code>TypeScript</code> 在框架中使用的学习成本相对会更高，需要不断编写才能熟练</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-使用-Typescript-有哪些优点和缺点"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-使用-Typescript-有哪些优点和缺点" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 使用 Typescript 有哪些优点和缺点"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 使用 Typescript 有哪些优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h5 id="提供可选的强静态类型"><a href="#提供可选的强静态类型" class="headerlink" title="提供可选的强静态类型"></a>提供可选的强静态类型</h5><p>既然叫 TypeScript，那它的最大亮点自然就是提供静态类型（type）。我们可以对变量设置类型，比如你给 count 变量设置为数字类型（number），如果你从 input 元素提取 value （string 类型）赋予给 count，如果你忘记将其转换为数字，编译是不会通过的。</p>
<p>当然类型不是强求设置的，为了兼容 JavaScript，你也可以设置为 any 类型。所谓 any 类型是一个特殊的类型，任何类型的的值都可以赋予给它。</p>
<h5 id="更早发现-BUG"><a href="#更早发现-BUG" class="headerlink" title="更早发现 BUG"></a>更早发现 BUG</h5><p>TypeScript 要编译后才能使用。所以我们的类型错误会在编译过程中被编译器发现，更早发现 BUG。如果直接用 JavaScript 开发，需要在程序运行时，吭哧吭哧点来点去各种测试来判断行为是否正常，费时费力，开发体验极差。</p>
<p>比如原本应该是两个数字相加的，写错成两个数字形式的字符串相加，结果是差得十万八千里，且不易察觉。TypeScript 在编译时就给你找到了，你不改对别想过我编译。</p>
<h5 id="代码可预测"><a href="#代码可预测" class="headerlink" title="代码可预测"></a>代码可预测</h5><p>声明的变量一旦指定类型，它的类型就再也不能修改。这样变量就具有可预测性。</p>
<p>JavaScript 的变量可以赋予任何类型的值。有时候，我们会看到一个变量在执行的过程中变成各种各样的类型，一会是字符串，一会是对象，非常不好预测，尤其是有复杂条件判断的时候。这其实是并不是好的开发习惯，但在 JavaScript 它就是可以这么干！</p>
<p>但如果你用 TypeScript，就没有这个烦恼，它直接给你一刀切了，你别想将字符串值赋予给一个数字类型变量，一旦声明就再也无法修改。</p>
<p>当然为了兼容，你也是可以将其设置 any 类型，但智能提升就没有了哦。</p>
<h5 id="丰富的-IDE-支持"><a href="#丰富的-IDE-支持" class="headerlink" title="丰富的 IDE 支持"></a>丰富的 IDE 支持</h5><p>因为使用了类型，所以检测某个变量是什么类型、可以使用哪些方法就变得容易，在开发体验上就可以进行改善了。</p>
<p>目前在绝大多数 IDE（集成开发环境）中已经支持 TypeScript 的 智能提示、自动补全、代码导航 等功能，并能在编写时实时反馈类型错误并提供准确的建议，比如可以指出传入函数的对象缺了哪些属性。</p>
<h5 id="方便重构"><a href="#方便重构" class="headerlink" title="方便重构"></a>方便重构</h5><p>重构时，如果函数的参数修改了，调用它时如果不对，TypeScript 会提示你。这对重构代码提供了坚实的后盾。有了 TypeScript，就放心做重构吧，前提你不要到处用 any。</p>
<h5 id="提供面向对象的写法"><a href="#提供面向对象的写法" class="headerlink" title="提供面向对象的写法"></a>提供面向对象的写法</h5><p>面向对象语言在实践中已经被证实是优秀的设计，拥有极高的可读性、可维护性。TypeScript 支持接口、抽象类、枚举等面向对象语言的特性，支持你更好地实现一些设计模式。TypeScript 还支持类型体操，有空多锻炼身体哈。</p>
<p>看了这么多优点，再看看 TypeScript 的缺点。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="不是真正的静态类型"><a href="#不是真正的静态类型" class="headerlink" title="不是真正的静态类型"></a>不是真正的静态类型</h5><p>因为需要兼容 JavaScript 的缘故，TypeScript 的类型是可选的。你可以用 any 类型，也可以进行类型的强制转换，所以如果你在代码中写了太多这样的东西，甚至将其变成 AnyScript。那么实际运行还是可能会出现一些类型上的问题。</p>
<h5 id="有一定的学习成本"><a href="#有一定的学习成本" class="headerlink" title="有一定的学习成本"></a>有一定的学习成本</h5><p>学 TypeScript 其实和学习一门新语言差不多了，还是有不小的学习成本的。但因为兼容 JavaScript 的缘故，对前端开发者来说难度会低一点。</p>
<h5 id="需要写更多的代码"><a href="#需要写更多的代码" class="headerlink" title="需要写更多的代码"></a>需要写更多的代码</h5><p>主要是类型和接口声明的部分，但能够抵消掉你 debug 类型问题的时间，总体看还是物超所值的。另外，编译后类型和接口声明都会被移除，相比直接写 JavaScript，体积不会明显更大。</p>
<h5 id="需要编译"><a href="#需要编译" class="headerlink" title="需要编译"></a>需要编译</h5><p>浏览器和 Nodejs 并不支持 TypeScript，所以多了一步编译操作。对于普通项目来说通常不长，其实还好。但如果你用来写脚本的话，就需要多安装 tsc 编译工具，还要配置好 tsconfig.json 文件，还是有点麻烦。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-Typescript中的内置类型有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-Typescript中的内置类型有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Typescript中的内置类型有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Typescript中的内置类型有哪些？</h3><h4 id="Partial（部分的）"><a href="#Partial（部分的）" class="headerlink" title="Partial（部分的）"></a>Partial（部分的）</h4><pre><code class="typescript">/**
 * Make all properties in T optional
 */
type Partial&lt;T&gt; = &#123;
    [P in keyof T]?: T[P];
&#125;;
</code></pre>
<p>作用是让传入类型中的所有属性变成都是可选的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;&#125;

const student2: Partial&lt;Student&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101152.jpeg"></p>
<p>变量student1的类型是Student，Student默认所有的属性都是不能为空的，所有会报错，student2就不会</p>
<h4 id="Required（必须的）"><a href="#Required（必须的）" class="headerlink" title="Required（必须的）"></a>Required（必须的）</h4><pre><code class="typescript">/**
 * Make all properties in T required
 */
type Required&lt;T&gt; = &#123;
    [P in keyof T]-?: T[P];
&#125;;
</code></pre>
<p>跟Partial的作用是相反的，是让传入类型中的所有属性变成都是必填的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name?: string;
  age?: number;
&#125;

const student1: Student = &#123;&#125;

const student2: Required&lt;Student&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101153.jpeg"></p>
<p>变量student1的类型是Student，Student默认所有的属性都是可以为空的，所有不会报错，student2会报错</p>
<h4 id="Readonly（只读的）"><a href="#Readonly（只读的）" class="headerlink" title="Readonly（只读的）"></a>Readonly（只读的）</h4><pre><code class="typescript">/**
 * Make all properties in T readonly
 */
type Readonly&lt;T&gt; = &#123;
    readonly [P in keyof T]: T[P];
&#125;;
</code></pre>
<p>作用是让传入类型中的所有属性变成都是只读的（不能修改属性）</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;
student1.age = 21

const student2: Readonly&lt;Student&gt; = &#123;
  name: &#39;李四&#39;,
  age: 20
&#125;
student2.age = 21
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101154.jpeg"></p>
<p>给student1的属性age重新赋值不会报错，给student2的属性age重新赋值就会报错，因为student2所有的属性都是只读的</p>
<h4 id="Pick（选择）"><a href="#Pick（选择）" class="headerlink" title="Pick（选择）"></a>Pick（选择）</h4><pre><code class="typescript">/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Pick&lt;T, K extends keyof T&gt; = &#123;
    [P in K]: T[P];
&#125;;
</code></pre>
<p>作用是选择传入类型中的部分属性组成新类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;

const student2: Pick&lt;Student, &#39;name&#39;&gt; = &#123;
  name: &#39;李四&#39;
&#125;

const student3: Pick&lt;Student, &#39;name&#39;&gt; = &#123;
  name: &#39;王五&#39;,
  age: 20
&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101155.jpeg"></p>
<p>变量student1可以有所有属性name和age，变量student2就只能有属性name，变量student3加上属性age就会报错</p>
<h4 id="Record（记录）"><a href="#Record（记录）" class="headerlink" title="Record（记录）"></a>Record（记录）</h4><pre><code class="typescript">/**
 * Construct a type with a set of properties K of type T
 */
type Record&lt;K extends keyof any, T&gt; = &#123;
    [P in K]: T;
&#125;;
</code></pre>
<p>作用是构建一个类型，这个类型用来描述一个对象，这个对象的属性都具有相同的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export const student1: Record&lt;string, any&gt; = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;
</code></pre>
<p>Record应该是日常使用频率较高的内置类型了，主要用来描述对象，一般建议是不用Object来描述对象，而是用Record代替，Record&lt;string, any&gt;几乎可以说是万金油了</p>
<h4 id="Exclude（排除）"><a href="#Exclude（排除）" class="headerlink" title="Exclude（排除）"></a>Exclude（排除）</h4><pre><code class="typescript">/**
 * Exclude from T those types that are assignable to U
 */
type Exclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre>
<p>针对联合类型（interface这种没用），用人话说，排除相同的，留下不同的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Exclude&lt;StudentAttr, PersonAttr&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101156.jpeg"></p>
<p>student1就只能被赋值为’class’ 或者’school’</p>
<h4 id="Extract（取出）"><a href="#Extract（取出）" class="headerlink" title="Extract（取出）"></a>Extract（取出）</h4><pre><code class="typescript">/**
 * Extract from T those types that are assignable to U
 */
type Extract&lt;T, U&gt; = T extends U ? T : never;
</code></pre>
<p>与Exclude相反，针对联合类型，排除不同的的，取出相同的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Extract&lt;StudentAttr, PersonAttr&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101157.jpeg"></p>
<p>student1就只能被赋值为’name’或者’age’</p>
<h4 id="Omit（省略）"><a href="#Omit（省略）" class="headerlink" title="Omit（省略）"></a>Omit（省略）</h4><pre><code class="typescript">/**
 * Construct a type with the properties of T except for those in type K.
 */
type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;
</code></pre>
<p>传入一个类型，和这个类型的几个属性，把传入的属性省略掉，组成一个新类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
  class: string;
  school: string;
&#125;

export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Omit&lt;Student, PersonAttr&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101158.jpeg"></p>
<p>student1报错，提示没有属性’name’、’age’</p>
<h4 id="NonNullable（不能为null）"><a href="#NonNullable（不能为null）" class="headerlink" title="NonNullable（不能为null）"></a>NonNullable（不能为null）</h4><pre><code class="typescript">/**
 * Exclude null and undefined from T
 */
type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;
</code></pre>
<p>字面意思，不能为空</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: NonNullable&lt;Student | undefined | null&gt; = null
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101159.jpeg"></p>
<p>student1赋值为null会报错（在tsconfig.json配置文件中开启类型检查，<code>&quot;skipLibCheck&quot;: false</code>）</p>
<h4 id="Parameters（参数）"><a href="#Parameters（参数）" class="headerlink" title="Parameters（参数）"></a>Parameters（参数）</h4><pre><code class="typescript">/**
 * Obtain the parameters of a function type in a tuple
 */
type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>获取传入函数的参数组成的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentFunc &#123;
  (name: string, age: number): Student
&#125;

const student1: Parameters&lt;StudentFunc&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101160.jpeg"></p>
<p>student1的类型为<code>[name: string, age: number]</code></p>
<h4 id="ConstructorParameters（构造参数）"><a href="#ConstructorParameters（构造参数）" class="headerlink" title="ConstructorParameters（构造参数）"></a>ConstructorParameters（构造参数）</h4><pre><code class="typescript">/**
 * Obtain the parameters of a constructor function type in a tuple
 */
type ConstructorParameters&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>获取传入构造函数的参数组成的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentConstructor &#123;
  new (name: string, age: number): Student
&#125;

const student1: ConstructorParameters&lt;StudentConstructor&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101161.jpeg"></p>
<p>student1的类型为<code>[name: string, age: number]</code></p>
<h4 id="ReturnType（返回类型）"><a href="#ReturnType（返回类型）" class="headerlink" title="ReturnType（返回类型）"></a>ReturnType（返回类型）</h4><pre><code class="typescript">/**
 * Obtain the return type of a function type
 */
type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;
</code></pre>
<p>获取传入函数的返回类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentFunc &#123;
  (name: string, age: number): Student
&#125;

const student1: ReturnType&lt;StudentFunc&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101162.jpeg"></p>
<p>student1的类型为<code>Student</code></p>
<h4 id="InstanceType（构造返回类型、实例类型）"><a href="#InstanceType（构造返回类型、实例类型）" class="headerlink" title="InstanceType（构造返回类型、实例类型）"></a>InstanceType（构造返回类型、实例类型）</h4><pre><code class="typescript">/**
 * Obtain the return type of a constructor function type
 */
type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any;
</code></pre>
<p>获取传入构造函数的返回类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">const Student = class &#123;
  name: string;
  age: number;
  constructor (name: string, age: number) &#123;
    this.name = name
    this.age = age
  &#125;
  showInfo () &#123;
    console.log(&#39;name: &#39;, this.name, &#39;age: &#39;, this.age);
  &#125;
&#125;

const student1: InstanceType&lt;typeof Student&gt; = new Student(&#39;张三&#39;, 20)
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101163.jpeg"></p>
<p>个人认为这是一个非常好用的内置类型，目前在前端项目中，class是用的越来越多了，在TS中，class其实也是可以用作类型声明空间的，用来描述对象类型，但是一般来说好像很少这样用的，一般用interface或者type居多</p>
<pre><code class="typescript">export class Student &#123;
  name: string;
  age: number;
&#125;
</code></pre>
<p>所以一般就是直接把class用作变量声明空间，但是对于 class new 出的实例，怎么描述它的类型呢，就如上文的，直接<code>const student1: Student</code>那是铁定会报错的，因为Student用作变量声明空间，没有用作类型声明空间（听起来好绕），这时候就可以用到InstanceType，完美解决问题</p>
<h4 id="Uppercase（大写）"><a href="#Uppercase（大写）" class="headerlink" title="Uppercase（大写）"></a>Uppercase（大写）</h4><pre><code class="typescript">/**
 * Convert string literal type to uppercase
 */
type Uppercase&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>变大写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;male&#39; | &#39;female&#39;

const studentSex: Uppercase&lt;StudentSexType&gt; = &#39;MALE&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101164.jpeg"></p>
<h4 id="Lowercase（小写）"><a href="#Lowercase（小写）" class="headerlink" title="Lowercase（小写）"></a>Lowercase（小写）</h4><pre><code class="typescript">/**
 * Convert string literal type to lowercase
 */
type Lowercase&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>变小写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;MALE&#39; | &#39;FEMALE&#39;

const studentSex: Lowercase&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101165.jpeg"></p>
<h4 id="Capitalize（首字母大写）"><a href="#Capitalize（首字母大写）" class="headerlink" title="Capitalize（首字母大写）"></a>Capitalize（首字母大写）</h4><pre><code class="typescript">/**
 * Convert first character of string literal type to uppercase
 */
type Capitalize&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>首字母变大写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;male&#39; | &#39;female&#39;

const studentSex: Capitalize&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101166.jpeg"></p>
<h4 id="Uncapitalize（首字母小写）"><a href="#Uncapitalize（首字母小写）" class="headerlink" title="Uncapitalize（首字母小写）"></a>Uncapitalize（首字母小写）</h4><pre><code class="typescript">/**
 * Convert first character of string literal type to lowercase
 */
type Uncapitalize&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>首字母变小写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;MALE&#39; | &#39;FEMALE&#39;

const studentSex: Uncapitalize&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101167.jpeg"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-能否将多个-ts-文件组合成一个-js-文件？-如果是，那么如何？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-能否将多个-ts-文件组合成一个-js-文件？-如果是，那么如何？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 能否将多个 .ts 文件组合成一个 .js 文件？ 如果是，那么如何？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 能否将多个 <code>.ts</code> 文件组合成一个 <code>.js</code> 文件？ 如果是，那么如何？</h3><p>这是可以的。需要添加 —outFILE [OutputJSFileName] 编译选项。</p>
<pre><code class="shell">$ tsc --outFile comman.js file1.ts file2.ts file3.ts
</code></pre>
<p>上述命令将编译所有三个<code>.ts</code>文件，结果将存储到单个<code>comman.js</code>文件中。在这种情况下，当没有像下面的命令那样提供输出文件名时。</p>
<pre><code class="shell">$ tsc --outFile file1.ts file2.ts file3.ts
</code></pre>
<p>然后，<code>file2.ts</code>和<code>file3.ts</code>会被编译，输出会放在<code>file1.ts</code>中。所以现在的 <code>file1.ts</code> 包含 JavaScript 代码。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-是否可以通过-ts-文件中的实时更改自动编译-ts-？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-是否可以通过-ts-文件中的实时更改自动编译-ts-？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 是否可以通过 .ts 文件中的实时更改自动编译 .ts ？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 是否可以通过 <code>.ts</code> 文件中的实时更改自动编译 <code>.ts</code> ？</h3><p>是的，可以通过 <code>.ts</code> 文件中的实时更改自动编译<code>.ts</code>。这可以通过使用 <code>--watch</code> 编译器选项来实现。</p>
<pre><code class="shell">tsc --watch file1.ts
</code></pre>
<p>上面的命令首先编译 <code>file1.js</code> 中的 <code>file1.ts</code> 并观察文件的变化。如果检测到任何更改，它将再次编译该文件。在这里，需要确保在使用 <code>--watch</code> 选项运行时不能关闭命令提示符。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-interface语句和type语句有什么区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-interface语句和type语句有什么区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ interface语句和type语句有什么区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ interface语句和type语句有什么区别？</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>都可以描述一个对象或者函数</p>
<p>interface</p>
<pre><code class="typescript">interface User &#123;
  name: string
  age: number
&#125;

interface SetUser &#123;
  (name: string, age: number): void;
&#125;
</code></pre>
<p>type</p>
<pre><code class="typescript">type User = &#123;
  name: string
  age: number
&#125;;

type SetUser = (name: string, age: number)=&gt; void;
</code></pre>
<p>都允许拓展（extends）</p>
<p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p>
<p>interface extends interface</p>
<pre><code class="typescript">interface Name &#123; 
  name: string; 
&#125;
interface User extends Name &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<p>type extends type</p>
<pre><code class="ini">type Name = &#123; 
  name: string; 
&#125;
type User = Name &amp; &#123; age: number  &#125;;
复制代码
</code></pre>
<p>interface extends type</p>
<pre><code class="typescript">type Name = &#123; 
  name: string; 
&#125;
interface User extends Name &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<p>type extends interface</p>
<pre><code class="ini">interface Name &#123; 
  name: string; 
&#125;
type User = Name &amp; &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>type 可以而 interface 不行</p>
<ul>
<li>type 可以声明基本类型别名，联合类型，元组等类型</li>
</ul>
<pre><code class="go">// 基本类型别名
type Name = string

// 联合类型
interface Dog &#123;
    wong();
&#125;
interface Cat &#123;
    miao();
&#125;

type Pet = Dog | Cat

// 具体定义数组每个位置的类型
type PetList = [Dog, Pet]

复制代码
</code></pre>
<ul>
<li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</li>
</ul>
<pre><code class="ini">// 当你想获取一个变量的类型时，使用 typeof
let div = document.createElement(&#39;div&#39;);
type B = typeof div
复制代码
</code></pre>
<ul>
<li>其他骚操作</li>
</ul>
<pre><code class="ini">type StringOrNumber = string | number;  
type Text = string | &#123; text: string &#125;;  
type NameLookup = Dictionary&lt;string, Person&gt;;  
type Callback&lt;T&gt; = (data: T) =&gt; void;  
type Pair&lt;T&gt; = [T, T];  
type Coordinates = Pair&lt;number&gt;;  
type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;
复制代码
</code></pre>
<p>interface 可以而 type 不行</p>
<p>interface 能够声明合并</p>
<pre><code class="typescript">interface User &#123;
  name: string
  age: number
&#125;

interface User &#123;
  sex: string
&#125;

/*
User 接口为 &#123;
  name: string
  age: number
  sex: string 
&#125;
*/
复制代码
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在Proxy中代理apply方法"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在Proxy中代理apply方法" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Proxy中代理apply方法"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Proxy中代理apply方法</h3><pre><code class="javascript"> &#123;
            var target = function () &#123;
                return &#39;I am the target&#39;;
            &#125;
            var handler = &#123;
                apply: function () &#123;
                    return &#39;I am the proxy&#39;;
                &#125;
            &#125;;
            var p = new Proxy(target,handler);
            console.log(&quot;p&quot;,p());
        &#125;
//上面代码中，变量p是Proxy的实例，当他作为函数调用时（p（））
//,就会被apply方法拦截，返回一个字符串
</code></pre>
<pre><code class="javascript">&#123;
    var twice = &#123;
                    //目标对象，目标对象的上下文对象，目标对象的参数数组
        apply:function (target,ctx,args) &#123;
            //return console.log(&quot;target&quot;,target,&quot;ctx&quot;,ctx,&quot;args&quot;,args);
           return Reflect.apply(...arguments)*2;
        &#125;
    &#125;;
    function sum (left,right) &#123;
         return left*right;
    &#125;;
    var proxy = new Proxy(sum,twice);
    console.log(&quot;proxy1&quot;,proxy(1,2));
    console.log(&quot;proxy.call&quot;,proxy.call(null,5,6));
    console.log(&quot;proxy,apply&quot;,proxy.apply(null,[7,8]));
    console.log(&quot;proxy,apply&quot;,Reflect.apply(proxy,null,[7,8]));

&#125;
//上面的实例执行顺序是当sum（）执行完后再执行twice中的apply()，
//上面代码中每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截
//另外，直接调用Reflect.apply方法，也会被拦截。
</code></pre>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全网络攻防"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"
    >前端面试大全网络攻防</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/" class="article-date">
  <time datetime="2022-11-01T07:16:13.000Z" itemprop="datePublished">2022-11-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/">网络攻击</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（网络攻防）"><a href="#前端面试题大全（网络攻防）" class="headerlink" title="前端面试题大全（网络攻防）"></a>前端面试题大全（网络攻防）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="网络攻防"><a href="#网络攻防" class="headerlink" title="网络攻防"></a>网络攻防</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-XSS攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-XSS攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ XSS攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ XSS攻击</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/09/27/fe-security.html">美团技术谈XSS攻防</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-CSRF攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-CSRF攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ CSRF攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ CSRF攻击</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">美团技术谈CSRF攻击</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-中间人攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-中间人攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 中间人攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 中间人攻击</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1900287">中间人攻击</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-SQL注入"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-SQL注入" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ SQL注入"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ SQL注入</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/github_36032947/article/details/78442189">理解SQL注入</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-DDoS攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-DDoS攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DDoS攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DDoS攻击</h3><p>DDoS攻击——常见的具有破坏性的安全性问题(如果是分布式攻击的话就是DDos攻击)</p>
<p>攻击方式：Ping Flood攻击即利用ping命令不停的发送的数据包到服务器。</p>
<p><a target="_blank" rel="noopener" href="https://www.cloudflare.com/zh-cn/learning/ddos/what-is-a-ddos-attack/">DDoS攻击 </a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-DNS缓存污染"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-DNS缓存污染" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DNS缓存污染"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DNS缓存污染</h3><p>DNS缓存污染——常见的网站不可访问的问题</p>
<p>攻击方式：第三方可信赖的域名服务器缓存了一些DNS解析，但被别人制造一些假域名服务器封包污染了，指向错误网址。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试题大全node"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/"
    >前端面试题大全node</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/" class="article-date">
  <time datetime="2022-11-01T02:53:32.000Z" itemprop="datePublished">2022-11-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/node-js/">node.js</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（node-js）"><a href="#前端面试题大全（node-js）" class="headerlink" title="前端面试题大全（node.js）"></a>前端面试题大全（node.js）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><h3 id="♥︎-♥︎-说说你对Node-js-的理解？优缺点？应用场景？"><a href="#♥︎-♥︎-说说你对Node-js-的理解？优缺点？应用场景？" class="headerlink" title="♥︎ ♥︎ 说说你对Node.js 的理解？优缺点？应用场景？"></a>♥︎ ♥︎ 说说你对Node.js 的理解？优缺点？应用场景？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>Node.js</code> 是一个开源与跨平台的 <code>JavaScript</code> 运行时环境</p>
<p>在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能</p>
<p>可以理解为 <code>Node.js</code> 就是一个服务器端的、非阻塞式I&#x2F;O的、事件驱动的<code>JavaScript</code>运行环境</p>
<h5 id="非阻塞异步"><a href="#非阻塞异步" class="headerlink" title="非阻塞异步"></a>非阻塞异步</h5><p><code>Nodejs</code>采用了非阻塞型<code>I/O</code>机制，在做<code>I/O</code>操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作</p>
<p>例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率</p>
<h5 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h5><p>事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数</p>
<p>比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61373732393539302d633165382d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、优缺点"><a href="#二、优缺点" class="headerlink" title="二、优缺点"></a>二、优缺点</h4><p>优点：</p>
<ul>
<li>处理高并发场景性能更佳</li>
<li>适合I&#x2F;O密集型应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I&#x2F;O硬盘内存读写操作</li>
</ul>
<p>因为<code>Nodejs</code>是单线程，带来的缺点有：</p>
<ul>
<li>不适合CPU密集型应用</li>
<li>只支持单核CPU，不能充分利用CPU</li>
<li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>
</ul>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>借助<code>Nodejs</code>的特点和弊端，其应用场景分类如下：</p>
<ul>
<li>善于<code>I/O</code>，不善于计算。因为Nodejs是一个单线程，如果计算（同步）太多，则会阻塞这个线程</li>
<li>大量并发的I&#x2F;O，应用程序内部并不需要进行非常复杂的处理</li>
<li>与 websocket 配合，开发长连接的实时交互应用程序</li>
</ul>
<p>具体场景可以表现为如下：</p>
<ul>
<li>第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序</li>
<li>第二大类：基于web、canvas等多人联网游戏</li>
<li>第三大类：基于web的多人实时聊天客户端、聊天室、图文直播</li>
<li>第四大类：单页面浏览器应用程序</li>
<li>第五大类：操作数据库、为前端和移动端提供基于<code>json</code>的API</li>
</ul>
<p>其实，<code>Nodejs</code>能实现几乎一切的应用，只考虑适不适合使用它</p>
<h3 id="♥︎-♥︎-为什么-Node-js-是单线程的？"><a href="#♥︎-♥︎-为什么-Node-js-是单线程的？" class="headerlink" title="♥︎ ♥︎ 为什么 Node.js 是单线程的？"></a>♥︎ ♥︎ 为什么 Node.js 是单线程的？</h3><p>回答一：怼：如果不幸遇到面试官问这个问题，你反问他 nodejs 为什么叫做 nodejs.</p>
<p>回答二：苟：您好，贵公司的面试题还挺有深度的，这让我越来越期待加入贵公司了。关于 ndoejs 是单线程的，刚好前段时间阅读过有关 node 的文章。node 的作者在设计之初选择语言时，评估过当时的流行语言，最终选择了存在多年在后端却一直没有市场的 js,正是 js 的不被关注，使得使用 js 没有额外阻力，而 js 在浏览器中有广泛的事件驱动方面的应用，正符合作者的喜好。于是 node 使用了 js 作为开发语言，node 的作者在开发时保持了 js 单线程的特点，所以 nodejs 是单线程的。</p>
<h3 id="♥︎-♥︎-什么是回调函数？"><a href="#♥︎-♥︎-什么是回调函数？" class="headerlink" title="♥︎ ♥︎ 什么是回调函数？"></a>♥︎ ♥︎ 什么是回调函数？</h3><p>概念：</p>
<p>回调就是一种利用函数指针进行函数调用的过程。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。</p>
<p>对普通函数的调用：</p>
<p>调用程序发出对普通函数的调用后，程序执行立即转向被调用函数执行，直到被调用函数执行完毕后，再返回调用程序继续执行。从发出调用的程序的角度看，这个过程为“调用–&gt;等待被调用函数执行完毕–&gt;继续执行”</p>
<p>对回调函数调用：</p>
<p>调用程序发出对回调函数的调用后，不等函数执行完毕，立即返回并继续执行。这样，调用程序执和被调用函数同时在执行。当被调函数执行完毕后，被调函数会反过来调用某个事先指定函数，以通知调用程序：函数调用结束。这个过程称为回调(Callback)，这正是回调函数名称的由来。<br>回调函数机制：</p>
<p>1、定义一个函数（图中的sub&#x2F;mul函数）；</p>
<p>2、将此函数的地址注册给调用者test函数；</p>
<p>3、特定的事件或条件发生时（main主函数），调用者使用函数指针调用回调函数。</p>
<p>回调函数的缺点：</p>
<p>1）回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。</p>
<p>2）回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。</p>
<h3 id="♥︎-♥︎-Node-js-和-ajax-的区别是什么"><a href="#♥︎-♥︎-Node-js-和-ajax-的区别是什么" class="headerlink" title="♥︎ ♥︎  Node.js 和 ajax 的区别是什么?"></a>♥︎ ♥︎  Node.js 和 ajax 的区别是什么?</h3><p>区别一：</p>
<p>Ajax（异步Javascript和XML的简称）是一种客户端技术，通常用于更新页面内容而不刷新它。</p>
<p>而Node.js是服务器端Javascript，是一个基于 Chrome V8 引擎的 JavaScript 运行环境，是一个让 JavaScript 运行在服务端的开发平台。</p>
<p>区别二：</p>
<p>Node.js不在浏览器中执行，而是由服务器执行。而Ajax在浏览器中执行。</p>
<p>区别三：</p>
<p>node主要是提供后台服务，而ajax主要是用来前后台数据的请求与发送数据的。</p>
<h3 id="♥︎-♥︎-请使用-Node-js-原生的-HTTP-模块创建一个-web-Server。"><a href="#♥︎-♥︎-请使用-Node-js-原生的-HTTP-模块创建一个-web-Server。" class="headerlink" title="♥︎ ♥︎ 请使用 Node.js 原生的 HTTP 模块创建一个 web Server。"></a>♥︎ ♥︎ 请使用 Node.js 原生的 HTTP 模块创建一个 web Server。</h3><pre><code class="js">const http = require(&#39;http&#39;)
const port = 3000
const server = http.createServer((req, res) =&gt; &#123;
 res.statusCode = 200
 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;)
 res.end(&#39;Hello World&#39;)
&#125;)
server.listen(port, () =&gt; &#123;
 console.log( Server is running on http://127.0.0.1:$&#123;port&#125;/ )
&#125;)
</code></pre>
<hr>
<h3 id="♥︎-♥︎-♥︎-如何使用原生-Node-js-操做-cookie？"><a href="#♥︎-♥︎-♥︎-如何使用原生-Node-js-操做-cookie？" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何使用原生 Node.js 操做 cookie？"></a>♥︎ ♥︎ ♥︎ 如何使用原生 Node.js 操做 cookie？</h3><p>获取 cookie： req.headers.cookie</p>
<p>设置 cookie： res.writeHead(200, { ‘Set-Cookie’: ‘myCookie&#x3D;test’, ‘Content-Type’: ‘text&#x2F;plain’ }) </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012732909/article/details/119107135">node操作cookie</a>参考请点击</p>
<h3 id="♥︎-♥︎-♥︎-setImmediate-和-setTimeOut-区别在哪里"><a href="#♥︎-♥︎-♥︎-setImmediate-和-setTimeOut-区别在哪里" class="headerlink" title="♥︎ ♥︎ ♥︎ setImmediate 和 setTimeOut 区别在哪里?"></a>♥︎ ♥︎ ♥︎ setImmediate 和 setTimeOut 区别在哪里?</h3><p>setImmediate 和 setTimeOut 都是延迟加载。而当这两个定时器同时运行在主模块时，运行顺序是不一定的。setTimeOut 受进程性能的约束，有可能比 setImmediate 快，也有可能慢于 setImmediate。</p>
<p>而在 I&#x2F;O 事件的回调中，setImmediate 方法的回调永远在 setTimeOut 的回调前执行。</p>
<h3 id="♥︎-♥︎-♥︎-如何更新-Node-js-的版本"><a href="#♥︎-♥︎-♥︎-如何更新-Node-js-的版本" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何更新 Node.js 的版本?"></a>♥︎ ♥︎ ♥︎ 如何更新 Node.js 的版本?</h3><pre><code class="css">npm install npm -g (在命令行中将 npm 在重新安装一遍，如需指定版本需要加上 @版本数字 )
</code></pre>
<h3 id="♥︎-♥︎-♥︎-nextTick-和-setImmediate-的区别是什么？"><a href="#♥︎-♥︎-♥︎-nextTick-和-setImmediate-的区别是什么？" class="headerlink" title="♥︎ ♥︎ ♥︎  nextTick 和 setImmediate 的区别是什么？"></a>♥︎ ♥︎ ♥︎  nextTick 和 setImmediate 的区别是什么？</h3><p>nextTick 和 setImmediate 都是延迟加载。但是 nextTick 是放在当前队列的最后一个执行，</p>
<p>setImmediate 是在下一个队列的队首执行</p>
<h3 id="♥︎-♥︎-♥︎-请使用-Node-js-编写代码实现遍历文件夹并输出所有的文件名"><a href="#♥︎-♥︎-♥︎-请使用-Node-js-编写代码实现遍历文件夹并输出所有的文件名" class="headerlink" title="♥︎ ♥︎ ♥︎ 请使用 Node.js 编写代码实现遍历文件夹并输出所有的文件名"></a>♥︎ ♥︎ ♥︎ 请使用 Node.js 编写代码实现遍历文件夹并输出所有的文件名</h3><pre><code class="js">const fs = require(&#39;fs&#39;)
const path = require(&#39;path&#39;)
const getAllFile = function (dir) &#123;
 function traverse(dir) &#123;
 fs.readdirSync(dir).forEach(file =&gt; &#123;
 const pathname = path.join(dir, file)
 if (fs.statSync(pathname).isDirectory()) &#123;
 traverse(pathname)
 &#125; else &#123;
 console.log(file)
 &#125;
 &#125;)
 &#125;
 traverse(dir)
&#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？"><a href="#♥︎-♥︎-♥︎-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？" class="headerlink" title="♥︎ ♥︎ ♥︎ token 存储在 localStorage 里，当过期时过期的 token 怎么处理？"></a>♥︎ ♥︎ ♥︎ token 存储在 localStorage 里，当过期时过期的 token 怎么处理？</h3><p>当前端进行页面跳转或者需要鉴权的操作时，会发送请求到后台，而 token 会跟随请求头一起发送，后台通过请求头接收到 token 时会进行判断，若是过期了，应该返回一个 401 的状态码给前端，前端接收到以后，应该重定向到登录页要求用户重新登陆。</p>
<h3 id="♥︎-♥︎-♥︎-MySQL-和-MongoDB-的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？"><a href="#♥︎-♥︎-♥︎-MySQL-和-MongoDB-的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？" class="headerlink" title="♥︎ ♥︎ ♥︎ MySQL 和 MongoDB 的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？"></a>♥︎ ♥︎ ♥︎ MySQL 和 MongoDB 的区别，他们都是怎么查询语句的，具体讲讲怎么查询的？</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>数据库模型 mysql 是关系型数据库，现在使用最多的数据存储技术 mongodb 是非关系型数据库，并且是非关系型数据库中最像关系型的数据库</p>
<p>存储方式 mongodb-以类 JSON 的文档的格式存储 mysql-不同引擎有不同的存储方式</p>
<p>数据处理方式 mongodb-基于内存，将热数据存放在物理内存中，从而达到高速读写 mysql-不同引擎有自己的特点</p>
<h4 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h4><p>mongodb 的查询语句类似于 js 使用 api 的场景，通过 . 来调用，并传递参数来进行控制查询内容 如：查询 username 为张三，age 为 27 的数据</p>
<pre><code class="ini">db.users.find(&#123; username: &#39;张三&#39;, age: 27 &#125;)
</code></pre>
<p>而 mysql 则是标准的 sql 语句，同样查询代码如下：</p>
<pre><code class="ini">select * from users where &quot;username&quot; = &quot;张三&quot; and age = 27
</code></pre>
<h3 id="♥︎-♥︎-♥︎-什么是服务端渲染，服务端渲染的优点？"><a href="#♥︎-♥︎-♥︎-什么是服务端渲染，服务端渲染的优点？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是服务端渲染，服务端渲染的优点？"></a>♥︎ ♥︎ ♥︎ 什么是服务端渲染，服务端渲染的优点？</h3><p>服务端渲染：页面渲染过程是在服务端完成，最终的 HTML 字符串，直接通过请求发送给客户端。</p>
<p>服务器端渲染的优势就是利于 SEO 优化，首屏加载快，因为客户端接收到的是完整的 HTML 页面。</p>
<h3 id="♥︎-♥︎-♥︎-如何在-Node-js-中操作-MongoDb-数据库"><a href="#♥︎-♥︎-♥︎-如何在-Node-js-中操作-MongoDb-数据库" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何在 Node.js 中操作 MongoDb 数据库"></a>♥︎ ♥︎ ♥︎ 如何在 Node.js 中操作 MongoDb 数据库</h3><h4 id="一、在-Nodejs-中使用-Mongodb"><a href="#一、在-Nodejs-中使用-Mongodb" class="headerlink" title="一、在 Nodejs 中使用 Mongodb"></a>一、在 Nodejs 中使用 Mongodb</h4><p>Nodejs 操作 mongodb 数据库官方文档：</p>
<p><a target="_blank" rel="noopener" href="http://mongodb.github.io/node-mongodb-native/">http://mongodb.github.io/node-mongodb-native/</a></p>
<pre><code class="ini">npm install mongodb --save 
或者
cnpm install mongodb --save 
或者
yarn add mongodb
</code></pre>
<h4 id="二、Nodejs-操作-MongoDb-数据库"><a href="#二、Nodejs-操作-MongoDb-数据库" class="headerlink" title="二、Nodejs 操作 MongoDb 数据库"></a>二、Nodejs 操作 MongoDb 数据库</h4><pre><code class="javascript">// 1 cnpm install mongodb --save

//2、引入mongodb
const &#123; MongoClient &#125; = require(&#39;mongodb&#39;);

//3、定义数据库连接的地址
const url = &#39;mongodb://127.0.0.1:27017&#39;;

//4、定义要操作的数据库
const dbName = &#39;itying&#39;;

//5、实例化MongoClient 传入数据库连接地址
const client = new MongoClient(url, &#123; useUnifiedTopology: true &#125;);

//6、连接数据库 操作数据

client.connect((err) =&gt; &#123;
    if (err) &#123;
        console.log(err);
        return;
    &#125;
    console.log(&quot;数据库连接成功&quot;);

    let db = client.db(dbName);

    // //1、查找数据
    db.collection(&quot;user&quot;).find(&#123;&quot;age&quot;:13&#125;).toArray((err,data)=&gt;&#123;
       if(err)&#123; 
            console.log(err);
            return;
        &#125;
        console.log(data);       
        //操作数据库完毕以后一定要 关闭数据库连接
        client.close();
    &#125;)


    //2、增加数据

    // db.collection(&quot;user&quot;).insertOne(&#123;&quot;username&quot;:&quot;nodejs操作mongodb&quot;,&quot;age&quot;:10&#125;,(err,result)=&gt;&#123;
    //     if(err)&#123; //增加失败
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;增加成功&quot;);
    //     console.log(result);
    //       //操作数据库完毕以后一定要 关闭数据库连接
    //      client.close();

    // &#125;)


    //3、修改数据

    // db.collection(&quot;user&quot;).updateOne(&#123; &quot;name&quot;: &quot;zhangsan&quot; &#125;, &#123; $set: &#123; &quot;age&quot;: 10 &#125; &#125;, (err, result) =&gt; &#123;
    //     if (err) &#123; //修改失败
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;修改成功&quot;);
    //     console.log(result);
    //     //操作数据库完毕以后一定要 关闭数据库连接
    //     client.close();
    // &#125;)


    //4、删除一条数据

    // db.collection(&quot;user&quot;).deleteOne(&#123; &quot;username&quot;: &quot;nodejs&quot; &#125;, (err)=&gt;&#123;

    //     if (err) &#123; 
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;删除一条数据成功&quot;);
    //     client.close();
    // &#125;)

     //5、删除多条数据

    // db.collection(&quot;user&quot;).deleteMany(&#123; &quot;username&quot;: &quot;nodejs&quot; &#125;, (err)=&gt;&#123;

    //     if (err) &#123; 
    //         console.log(err);
    //         return;
    //     &#125;
    //     console.log(&quot;删除多条数据成功&quot;);
    //     client.close();
    // &#125;)

&#125;)
</code></pre>
<h3 id="♥︎-♥︎-♥︎-谈谈-socket-的三种常见使用方式"><a href="#♥︎-♥︎-♥︎-谈谈-socket-的三种常见使用方式" class="headerlink" title="♥︎ ♥︎ ♥︎ 谈谈 socket 的三种常见使用方式"></a>♥︎ ♥︎ ♥︎ 谈谈 socket 的三种常见使用方式</h3><p>第一种方式是 netSocket，主要使用的是 node 中的 net 模块。服务端通过 new net.createServer() 创建服务，使用 on(‘connection’) 方法建立连接，在回调函数中即可获取到客户端发送的信息。客户端通过 new net.Socket() 创建 Socket，通过 connect 连接指定端口和域名后，即可调用 write 方法发送数据</p>
<p>第二种方式是 webSocket，服务端引入第三方插件 ws 创建 socket 服务，客户端使用 H5 新增 API new WebSocket 连接服务端，通过 send 方法发送数据，onmessage 方法接收数据</p>
<p>第三种方式是 socket.io，服务端引入 socket.io’ 模块创建服务，客户端引入 socket.io.js’ 文件，建立连接后，客户端和服务端都是通过 on 方法接收数据，都是使用 emit 方法发送数据。</p>
<h3 id="♥︎-♥︎-♥︎-前后端数据交互的常见使用方式"><a href="#♥︎-♥︎-♥︎-前后端数据交互的常见使用方式" class="headerlink" title="♥︎ ♥︎ ♥︎ 前后端数据交互的常见使用方式"></a>♥︎ ♥︎ ♥︎ 前后端数据交互的常见使用方式</h3><p>cookie：前端可以直接设置或获取 cookie，后端可以使用 req.set(‘set-cookie’， ‘’)设置 cookie，在前端发送请求时通过 req 的 header 字段中获取 cookie</p>
<p>利用 AJAX，和 JQuery 中已经封装好的 $.ajax、$.post、$.getJSON 通过创建一个 XMLHttpRequest 对象，来进行前后端交互。</p>
<p>服务端渲染，浏览器请求到的内容可以通过后端加工一下，将数据直接渲染好，再返回给浏览器。</p>
<h3 id="♥︎-♥︎-♥︎-Node-js-优缺点以及适用场景"><a href="#♥︎-♥︎-♥︎-Node-js-优缺点以及适用场景" class="headerlink" title="♥︎ ♥︎ ♥︎ Node.js 优缺点以及适用场景"></a>♥︎ ♥︎ ♥︎ Node.js 优缺点以及适用场景</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Node.js 采用事件驱动、异步编程，为网络服务而设计。简单易学，可以很快上手做后端设计。</p>
<p>Node.js 非阻塞模式的 IO 处理给 Node.js 带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它 IO 资源的中间层服务。</p>
<p>Node.js 轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>单线程，可靠性低，一旦这个进程崩掉，那么整个 web 服务就崩掉了。</p>
<p>开源组件库质量参差不齐，更新快，向下不兼容</p>
<p>不适合做企业级应用开发，特别是复杂业务逻辑的，代码不好维护，事务支持不是很好。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>大量 Ajax 请求的应用，例如个性化应用，每个用户看到的页面都不一样，需要在页面加载的时候发起Ajax 请求，NodeJS 能响应大量的并发请求。</p>
<p>实时应用：如在线聊天，实时通知推送等等</p>
<p>工具类应用：海量的工具，小到前端压缩部署，大到桌面图形界面应用程序</p>
<p>总而言之，NodeJS 适合运用在高并发、I&#x2F;O 密集、少量业务逻辑的场景。</p>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-process-的理解？有哪些常用方法？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-process-的理解？有哪些常用方法？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 process 的理解？有哪些常用方法？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 process 的理解？有哪些常用方法？</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>process</code> 对象是一个全局变量，提供了有关当前 <code>Node.js </code>进程的信息并对其进行控制，作为一个全局变量</p>
<p>我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器</p>
<p>当我们启动一个<code>js</code>文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享</p>
<p>由于<code>JavaScript</code>是一个单线程语言，所以通过<code>node xxx</code>启动一个文件后，只有一条主线程</p>
<h4 id="二、属性与方法"><a href="#二、属性与方法" class="headerlink" title="二、属性与方法"></a>二、属性与方法</h4><p>关于<code>process</code>常见的属性有如下：</p>
<ul>
<li>process.env：环境变量，例如通过 &#96;process.env.NODE_ENV 获取不同环境项目配置信息</li>
<li>process.nextTick：这个在谈及 <code>EventLoop</code> 时经常为会提到</li>
<li>process.pid：获取当前进程id</li>
<li>process.ppid：当前进程对应的父进程</li>
<li>process.cwd()：获取当前进程工作目录，</li>
<li>process.platform：获取当前进程运行的操作系统平台</li>
<li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li>
<li>进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</li>
<li>三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li>
<li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li>
</ul>
<p>下面再稍微介绍下某些方法的使用：</p>
<h5 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h5><p>返回当前 <code>Node </code>进程执行的目录</p>
<p>一个<code> Node</code> 模块 <code>A</code> 通过 NPM 发布，项目 <code>B</code> 中使用了模块 <code>A</code>。在 <code>A</code> 中需要操作 <code>B</code> 项目下的文件时，就可以用 <code>process.cwd()</code> 来获取 <code>B</code> 项目的路径</p>
<h5 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h5><p>在终端通过 Node 执行命令的时候，通过 <code>process.argv</code> 可以获取传入的命令行参数，返回值是一个数组：</p>
<ul>
<li>0: Node 路径（一般用不到，直接忽略）</li>
<li>1: 被执行的 JS 文件路径（一般用不到，直接忽略）</li>
<li>2~n: 真实传入命令的参数</li>
</ul>
<p>所以，我们只要从 <code>process.argv[2]</code> 开始获取就好了</p>
<pre><code class="ini">const args = process.argv.slice(2);
</code></pre>
<h5 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h5><p>返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。</p>
<p>一般我们会在 <code>process.env</code> 上挂载一些变量标识当前的环境。比如最常见的用 <code>process.env.NODE_ENV</code> 区分 <code>development</code> 和 <code>production</code></p>
<p>在 <code>vue-cli</code> 的源码中也经常会看到 <code>process.env.VUE_CLI_DEBUG</code> 标识当前是不是 <code>DEBUG</code> 模式</p>
<h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h5><p>我们知道<code>NodeJs</code>是基于事件轮询，在这个过程中，同一时间只会处理一件事情</p>
<p>在这种处理模式下，<code>process.nextTick()</code>就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行</p>
<p>例如下面例子将一个<code>foo</code>函数在下一个时间点调用</p>
<pre><code class="js">function foo() &#123;
    console.error(&#39;foo&#39;);
&#125;

process.nextTick(foo);
console.error(&#39;bar&#39;);
</code></pre>
<p>输出结果为<code>bar</code>、<code>foo</code></p>
<p>虽然下述方式也能实现同样效果：</p>
<pre><code class="javascript">setTimeout(foo, 0);
console.log(&#39;bar&#39;);
</code></pre>
<p>两者区别在于：</p>
<ul>
<li>process.nextTick()会在这一次event loop的call stack清空后（下一次event loop开始前）再调用callback</li>
<li>setTimeout()是并不知道什么时候call stack清空的，所以何时调用callback函数是不确定的</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-fs模块的理解-有哪些常用方法"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-fs模块的理解-有哪些常用方法" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 fs模块的理解? 有哪些常用方法"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 fs模块的理解? 有哪些常用方法</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>fs（filesystem），该模块提供本地文件的读写能力，基本上是<code>POSIX</code>文件操作命令的简单包装</p>
<p>可以说，所有与文件的操作都是通过<code>fs</code>核心模块实现</p>
<p>导入模块如下：</p>
<pre><code class="ini">const fs = require(&#39;fs&#39;);
</code></pre>
<p>这个模块对所有文件系统操作提供异步（不具有<code>sync</code> 后缀）和同步（具有 <code>sync</code> 后缀）两种操作方式，而供开发者选择</p>
<h4 id="二、文件知识"><a href="#二、文件知识" class="headerlink" title="二、文件知识"></a>二、文件知识</h4><p>在计算机中有关于文件的知识：</p>
<ul>
<li>权限位 mode</li>
<li>标识位 flag</li>
<li>文件描述为 fd</li>
</ul>
<h5 id="权限位-mode"><a href="#权限位-mode" class="headerlink" title="权限位 mode"></a>权限位 mode</h5><p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34663464343161302d633436622d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位4、2、1，不具备权限为0</p>
<p>如在<code>linux</code>查看文件权限位：</p>
<pre><code class="javascript">drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core
-rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md
</code></pre>
<p>在开头前十位中，<code>d</code>为文件夹，<code>-</code>为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限</p>
<h5 id="标识位"><a href="#标识位" class="headerlink" title="标识位"></a>标识位</h5><p>标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读取文件，如果文件不存在则抛出异常。</td>
</tr>
<tr>
<td>r+</td>
<td>读取并写入文件，如果文件不存在则抛出异常。</td>
</tr>
<tr>
<td>rs</td>
<td>读取并写入文件，指示操作系统绕开本地文件系统缓存。</td>
</tr>
<tr>
<td>w</td>
<td>写入文件，文件不存在会被创建，存在则清空后写入。</td>
</tr>
<tr>
<td>wx</td>
<td>写入文件，排它方式打开。</td>
</tr>
<tr>
<td>w+</td>
<td>读取并写入文件，文件不存在则创建文件，存在则清空后写入。</td>
</tr>
<tr>
<td>wx+</td>
<td>和 w+ 类似，排他方式打开。</td>
</tr>
<tr>
<td>a</td>
<td>追加写入，文件不存在则创建文件。</td>
</tr>
<tr>
<td>ax</td>
<td>与 a 类似，排他方式打开。</td>
</tr>
<tr>
<td>a+</td>
<td>读取并追加写入，不存在则创建。</td>
</tr>
<tr>
<td>ax+</td>
<td>与 a+ 类似，排他方式打开。</td>
</tr>
</tbody></table>
<h5 id="文件描述为-fd"><a href="#文件描述为-fd" class="headerlink" title="文件描述为 fd"></a>文件描述为 fd</h5><p>操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件</p>
<p><code>Window </code>系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，<code>NodeJS </code>抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符</p>
<p>在 <code>NodeJS </code>中，每操作一个文件，文件描述符是递增的，文件描述符一般从 <code>3</code> 开始，因为前面有 <code>0</code>、<code>1</code>、<code>2</code>三个比较特殊的描述符，分别代表 <code>process.stdin</code>（标准输入）、<code>process.stdout</code>（标准输出）和 <code>process.stderr</code>（错误输出）</p>
<h4 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h4><p>下面针对<code>fs</code>模块常用的方法进行展开：</p>
<ul>
<li>文件读取</li>
<li>文件写入</li>
<li>文件追加写入</li>
<li>文件拷贝</li>
<li>创建目录</li>
</ul>
<h5 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h5><h6 id="fs-readFileSync"><a href="#fs-readFileSync" class="headerlink" title="fs.readFileSync"></a>fs.readFileSync</h6><p>同步读取，参数如下：</p>
<ul>
<li>第一个参数为读取文件的路径或文件描述符</li>
<li>第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding</li>
</ul>
<p>结果为返回文件的内容</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

let buf = fs.readFileSync(&quot;1.txt&quot;);
let data = fs.readFileSync(&quot;1.txt&quot;, &quot;utf8&quot;);

console.log(buf); // &lt;Buffer 48 65 6c 6c 6f&gt;
console.log(data); // Hello
</code></pre>
<h6 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile"></a>fs.readFile</h6><p>异步读取方法 <code>readFile</code> 与 <code>readFileSync</code> 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 <code>err</code>（错误）和 <code>data</code>（数据），该方法没有返回值，回调函数在读取文件成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.readFile(&quot;1.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
   if(!err)&#123;
       console.log(data); // Hello
   &#125;
&#125;);
</code></pre>
<h5 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h5><h6 id="writeFileSync"><a href="#writeFileSync" class="headerlink" title="writeFileSync"></a>writeFileSync</h6><p>同步写入，有三个参数：</p>
<ul>
<li>第一个参数为写入文件的路径或文件描述符</li>
<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>
<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>
</ul>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.writeFileSync(&quot;2.txt&quot;, &quot;Hello world&quot;);
let data = fs.readFileSync(&quot;2.txt&quot;, &quot;utf8&quot;);

console.log(data); // Hello world
</code></pre>
<h6 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h6><p>异步写入，<code>writeFile</code> 与 <code>writeFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件写入数据成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.writeFile(&quot;2.txt&quot;, &quot;Hello world&quot;, err =&gt; &#123;
    if (!err) &#123;
        fs.readFile(&quot;2.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
            console.log(data); // Hello world
        &#125;);
    &#125;
&#125;);
</code></pre>
<h5 id="文件追加写入"><a href="#文件追加写入" class="headerlink" title="文件追加写入"></a>文件追加写入</h5><h6 id="appendFileSync"><a href="#appendFileSync" class="headerlink" title="appendFileSync"></a>appendFileSync</h6><p>参数如下：</p>
<ul>
<li>第一个参数为写入文件的路径或文件描述符</li>
<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>
<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>
</ul>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.appendFileSync(&quot;3.txt&quot;, &quot; world&quot;);
let data = fs.readFileSync(&quot;3.txt&quot;, &quot;utf8&quot;);
</code></pre>
<h6 id="appendFile"><a href="#appendFile" class="headerlink" title="appendFile"></a>appendFile</h6><p>异步追加写入方法 <code>appendFile</code> 与 <code>appendFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件追加写入数据成功后执行</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.appendFile(&quot;3.txt&quot;, &quot; world&quot;, err =&gt; &#123;
    if (!err) &#123;
        fs.readFile(&quot;3.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
            console.log(data); // Hello world
        &#125;);
    &#125;
&#125;);
</code></pre>
<h5 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h5><h6 id="copyFileSync"><a href="#copyFileSync" class="headerlink" title="copyFileSync"></a>copyFileSync</h6><p>同步拷贝</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.copyFileSync(&quot;3.txt&quot;, &quot;4.txt&quot;);
let data = fs.readFileSync(&quot;4.txt&quot;, &quot;utf8&quot;);

console.log(data); // Hello world
</code></pre>
<h6 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h6><p>异步拷贝</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);

fs.copyFile(&quot;3.txt&quot;, &quot;4.txt&quot;, () =&gt; &#123;
    fs.readFile(&quot;4.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;
        console.log(data); // Hello world
    &#125;);
&#125;);
</code></pre>
<h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><h6 id="mkdirSync"><a href="#mkdirSync" class="headerlink" title="mkdirSync"></a>mkdirSync</h6><p>同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常</p>
<pre><code class="javascript">// 假设已经有了 a 文件夹和 a 下的 b 文件夹
fs.mkdirSync(&quot;a/b/c&quot;)
</code></pre>
<h6 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h6><p>异步创建，第二个参数为回调函数</p>
<pre><code class="javascript">fs.mkdir(&quot;a/b/c&quot;, err =&gt; &#123;
    if (!err) console.log(&quot;创建成功&quot;);
&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-Buffer-的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-Buffer-的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 Buffer 的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 Buffer 的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在<code>Node</code>应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而<code>Buffer</code>就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据</p>
<p>在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量</p>
<p>如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理</p>
<p>这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 <code>RAM</code> 中</p>
<p>简单来讲，<code>Nodejs</code>不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在<code>Buffer</code>中，即在<code>RAM</code>中，直至将它们发送完毕</p>
<p>上面讲到了<code>Buffer</code>是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存8位二进制：<code>00000000</code>，也就是一个字节</p>
<p>例如：</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;why&quot;)
</code></pre>
<p>其存储过程如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32303337313235302d633639632d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h4><p><code>Buffer</code> 类在全局作用域中，无须<code>require</code>导入</p>
<p>创建<code>Buffer</code>的方法有很多种，我们讲讲下面的两种常见的形式：</p>
<ul>
<li>Buffer.from()</li>
<li>Buffer.alloc()</li>
</ul>
<h5 id="Buffer-from"><a href="#Buffer-from" class="headerlink" title="Buffer.from()"></a>Buffer.from()</h5><pre><code class="javascript">const b1 = Buffer.from(&#39;10&#39;);
const b2 = Buffer.from(&#39;10&#39;, &#39;utf8&#39;);
const b3 = Buffer.from([10]);
const b4 = Buffer.from(b3);

console.log(b1, b2, b3, b4); // &lt;Buffer 31 30&gt; &lt;Buffer 31 30&gt; &lt;Buffer 0a&gt; &lt;Buffer 0a&gt;
</code></pre>
<h5 id="Buffer-alloc"><a href="#Buffer-alloc" class="headerlink" title="Buffer.alloc()"></a>Buffer.alloc()</h5><pre><code class="javascript">const bAlloc1 = Buffer.alloc(10); // 创建一个大小为 10 个字节的缓冲区
const bAlloc2 = Buffer.alloc(10, 1); // 建一个长度为 10 的 Buffer,其中全部填充了值为 `1` 的字节
console.log(bAlloc1); // &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;
console.log(bAlloc2); // &lt;Buffer 01 01 01 01 01 01 01 01 01 01&gt;
</code></pre>
<p>在上面创建<code>buffer</code>后，则能够<code>toString</code>的形式进行交互，默认情况下采取<code>utf8</code>字符编码形式，如下</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;你好&quot;);
console.log(buffer);
// &lt;Buffer e4 bd a0 e5 a5 bd&gt;
const str = buffer.toString();
console.log(str);
// 你好
</code></pre>
<p>如果编码与解码不是相同的格式则会出现乱码的情况，如下：</p>
<pre><code class="javascript">const buffer = Buffer.from(&quot;你好&quot;,&quot;utf-8 &quot;);
console.log(buffer);
// &lt;Buffer e4 bd a0 e5 a5 bd&gt;
const str = buffer.toString(&quot;ascii&quot;);
console.log(str); 
// d= e%=
</code></pre>
<p>当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下：</p>
<pre><code class="javascript">const buf = Buffer.from(&#39;Node.js 技术栈&#39;, &#39;UTF-8&#39;);

console.log(buf)          // &lt;Buffer 4e 6f 64 65 2e 6a 73 20 e6 8a 80 e6 9c af e6 a0 88&gt;
console.log(buf.length)   // 17

console.log(buf.toString(&#39;UTF-8&#39;, 0, 9))  // Node.js �
console.log(buf.toString(&#39;UTF-8&#39;, 0, 11)) // Node.js 技
</code></pre>
<p>所支持的字符集有如下：</p>
<ul>
<li>ascii：仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的</li>
<li>utf8：多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8</li>
<li>utf16le：2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000至 U+10FFFF）</li>
<li>ucs2，utf16le 的别名</li>
<li>base64：Base64 编码</li>
<li>latin：一种把 Buffer 编码成一字节编码的字符串的方式</li>
<li>binary：latin1 的别名，</li>
<li>hex：将每个字节编码为两个十六进制字符</li>
</ul>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p><code>Buffer</code>的应用场景常常与流的概念联系在一起，例如有如下：</p>
<ul>
<li>I&#x2F;O操作</li>
<li>加密解密</li>
<li>zlib.js</li>
</ul>
<h5 id="I-x2F-O操作"><a href="#I-x2F-O操作" class="headerlink" title="I&#x2F;O操作"></a>I&#x2F;O操作</h5><p>通过流的形式，将一个文件的内容读取到另外一个文件</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;);

const inputStream = fs.createReadStream(&#39;input.txt&#39;); // 创建可读流
const outputStream = fs.createWriteStream(&#39;output.txt&#39;); // 创建可写流

inputStream.pipe(outputStream); // 管道读写
</code></pre>
<h5 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h5><p>在一些加解密算法中会遇到使用 <code>Buffer</code>，例如 <code>crypto.createCipheriv</code> 的第二个参数 <code>key</code> 为 <code>string</code> 或 <code>Buffer</code> 类型</p>
<h5 id="zlib-js"><a href="#zlib-js" class="headerlink" title="zlib.js"></a>zlib.js</h5><p><code>zlib.js</code> 为 <code>Node.js</code> 的核心库之一，其利用了缓冲区（<code>Buffer</code>）的功能来操作二进制数据流，提供了压缩或解压功能</p>
<h3 id="♥︎-♥︎-♥︎-说说对-Node-中的-Stream-的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-说说对-Node-中的-Stream-的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说对 Node 中的 Stream 的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ 说说对 Node 中的 Stream 的理解？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>流（Stream），是一个数据传输手段，是端到端信息交换的一种方式，而且是有顺序的,是逐块读取数据、处理内容，用于顺序读取输入或写入输出</p>
<p><code>Node.js</code>中很多对象都实现了流，总之它是会冒数据（以 <code>Buffer</code> 为单位）</p>
<p>它的独特之处在于，它不像传统的程序那样一次将一个文件读入内存，而是逐块读取数据、处理其内容，而不是将其全部保存在内存中</p>
<p>流可以分成三部分：<code>source</code>、<code>dest</code>、<code>pipe</code></p>
<p>在<code>source</code>和<code>dest</code>之间有一个连接的管道<code>pipe</code>,它的基本语法是<code>source.pipe(dest)</code>，<code>source</code>和<code>dest</code>就是通过pipe连接，让数据从<code>source</code>流向了<code>dest</code>，如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61656330353637302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="二、种类"><a href="#二、种类" class="headerlink" title="二、种类"></a>二、种类</h4><p>在<code>NodeJS</code>，几乎所有的地方都使用到了流的概念，分成四个种类：</p>
<ul>
<li>可写流：可写入数据的流。例如 fs.createWriteStream() 可以使用流将数据写入文件</li>
<li>可读流： 可读取数据的流。例如fs.createReadStream() 可以从文件读取内容</li>
<li>双工流： 既可读又可写的流。例如 net.Socket</li>
<li>转换流： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据</li>
</ul>
<p>在<code>NodeJS</code>中<code>HTTP</code>服务器模块中，<code>request</code> 是可读流，<code>response</code> 是可写流。还有<code>fs</code> 模块，能同时处理可读和可写文件流</p>
<p>可读流和可写流都是单向的，比较容易理解，而另外两个是双向的</p>
<h5 id="双工流"><a href="#双工流" class="headerlink" title="双工流"></a>双工流</h5><p>之前了解过<code>websocket</code>通信，是一个全双工通信，发送方和接受方都是各自独立的方法，发送和接收都没有任何关系</p>
<p>如下图所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62376163366430302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>基本代码如下：</p>
<pre><code class="javascript">const &#123; Duplex &#125; = require(&#39;stream&#39;);

const myDuplex = new Duplex(&#123;
  read(size) &#123;
    // ...
  &#125;,
  write(chunk, encoding, callback) &#123;
    // ...
  &#125;
&#125;);
</code></pre>
<h5 id="双工流-1"><a href="#双工流-1" class="headerlink" title="双工流"></a>双工流</h5><p>双工流的演示图如下所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63303238383362302d633736662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>除了上述压缩包的例子，还比如一个 <code>babel</code>，把<code>es6</code>转换为，我们在左边写入 <code>es6</code>，从右边读取 <code>es5</code></p>
<p>基本代码如下所示：</p>
<pre><code class="javascript">const &#123; Transform &#125; = require(&#39;stream&#39;);

const myTransform = new Transform(&#123;
  transform(chunk, encoding, callback) &#123;
    // ...
  &#125;
&#125;);
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p><code>stream</code>的应用场景主要就是处理<code>IO</code>操作，而<code>http</code>请求和文件操作都属于<code>IO</code>操作</p>
<p>思想一下，如果一次<code>IO</code>操作过大，硬件的开销就过大，而将此次大的<code>IO</code>操作进行分段操作，让数据像水管一样流动，知道流动完成</p>
<p>常见的场景有：</p>
<ul>
<li>get请求返回文件给客户端</li>
<li>文件操作</li>
<li>一些打包工具的底层操作</li>
</ul>
<h5 id="get请求返回文件给客户端"><a href="#get请求返回文件给客户端" class="headerlink" title="get请求返回文件给客户端"></a>get请求返回文件给客户端</h5><p>使用<code>stream</code>流返回文件，<code>res</code>也是一个<code>stream</code>对象，通过<code>pipe</code>管道将文件数据返回</p>
<pre><code class="javascript">const server = http.createServer(function (req, res) &#123;
    const method = req.method; // 获取请求方法
    if (method === &#39;GET&#39;) &#123; // get 请求
        const fileName = path.resolve(__dirname, &#39;data.txt&#39;);
        let stream = fs.createReadStream(fileName);
        stream.pipe(res); // 将 res 作为 stream 的 dest
    &#125;
&#125;);
server.listen(8000);
</code></pre>
<h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><p>创建一个可读数据流<code>readStream</code>，一个可写数据流<code>writeStream</code>，通过<code>pipe</code>管道把数据流转过去</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;)
const path = require(&#39;path&#39;)

// 两个文件名
const fileName1 = path.resolve(__dirname, &#39;data.txt&#39;)
const fileName2 = path.resolve(__dirname, &#39;data-bak.txt&#39;)
// 读取文件的 stream 对象
const readStream = fs.createReadStream(fileName1)
// 写入文件的 stream 对象
const writeStream = fs.createWriteStream(fileName2)
// 通过 pipe执行拷贝，数据流转
readStream.pipe(writeStream)
// 数据读取完成监听，即拷贝完成
readStream.on(&#39;end&#39;, function () &#123;
    console.log(&#39;拷贝完成&#39;)
&#125;)
</code></pre>
<h5 id="一些打包工具的底层操作"><a href="#一些打包工具的底层操作" class="headerlink" title="一些打包工具的底层操作"></a>一些打包工具的底层操作</h5><p>目前一些比较火的前端打包构建工具，都是通过<code>node.js</code>编写的，打包和构建的过程肯定是文件频繁操作的过程，离不来<code>stream</code>，如<code>gulp</code></p>
<h3 id="♥︎-♥︎-♥︎-说说Node中的EventEmitter-如何实现一个EventEmitter"><a href="#♥︎-♥︎-♥︎-说说Node中的EventEmitter-如何实现一个EventEmitter" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说Node中的EventEmitter? 如何实现一个EventEmitter?"></a>♥︎ ♥︎ ♥︎ 说说Node中的EventEmitter? 如何实现一个EventEmitter?</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>我们了解到，<code>Node </code>采用了事件驱动机制，而<code>EventEmitter </code>就是<code>Node</code>实现事件驱动的基础</p>
<p>在<code>EventEmitter</code>的基础上，<code>Node </code>几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作</p>
<p><code>Node.js</code> 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件</p>
<p>这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上</p>
<h4 id="二、使用方法-1"><a href="#二、使用方法-1" class="headerlink" title="二、使用方法"></a>二、使用方法</h4><p><code>Node </code>的<code>events</code>模块只提供了一个<code>EventEmitter</code>类，这个类实现了<code>Node</code>异步事件驱动架构的基本模式——观察者模式</p>
<p>在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们</p>
<p>基本代码如下所示：</p>
<pre><code class="javascript">const EventEmitter = require(&#39;events&#39;)

class MyEmitter extends EventEmitter &#123;&#125;
const myEmitter = new MyEmitter()

function callback() &#123;
    console.log(&#39;触发了event事件！&#39;)
&#125;
myEmitter.on(&#39;event&#39;, callback)
myEmitter.emit(&#39;event&#39;)
myEmitter.removeListener(&#39;event&#39;, callback);
</code></pre>
<p>通过实例对象的<code>on</code>方法注册一个名为<code>event</code>的事件，通过<code>emit</code>方法触发该事件，而<code>removeListener</code>用于取消事件的监听</p>
<p>关于其常见的方法如下：</p>
<ul>
<li>emitter.addListener&#x2F;on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部</li>
<li>emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部</li>
<li>emitter.emit(eventName[, …args])：触发类型为 eventName 的监听事件</li>
<li>emitter.removeListener&#x2F;off(eventName, listener)：移除类型为 eventName 的监听事件</li>
<li>emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除</li>
<li>emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件</li>
</ul>
<h4 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h4><p>通过上面的方法了解，<code>EventEmitter</code>是一个构造函数，内部存在一个包含所有事件的对象</p>
<pre><code class="javascript">class EventEmitter &#123;
    constructor() &#123;
        this.events = &#123;&#125;;
    &#125;
&#125;
</code></pre>
<p>其中<code>events</code>存放的监听事件的函数的结构如下：</p>
<pre><code class="javascript">&#123;
  &quot;event1&quot;: [f1,f2,f3]，
  &quot;event2&quot;: [f4,f5]，
  ...
&#125;
</code></pre>
<p>然后开始一步步实现实例方法，首先是<code>emit</code>，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：</p>
<pre><code class="javascript">emit(type, ...args) &#123;
    this.events[type].forEach((item) =&gt; &#123;
        Reflect.apply(item, this, args);
    &#125;);
&#125;
</code></pre>
<p>当实现了<code>emit</code>方法之后，然后实现<code>on</code>、<code>addListener</code>、<code>prependListener</code>这三个实例方法，都是添加事件监听触发函数，实现也是大同小异</p>
<pre><code class="javascript">on(type, handler) &#123;
    if (!this.events[type]) &#123;
        this.events[type] = [];
    &#125;
    this.events[type].push(handler);
&#125;

addListener(type,handler)&#123;
    this.on(type,handler)
&#125;

prependListener(type, handler) &#123;
    if (!this.events[type]) &#123;
        this.events[type] = [];
    &#125;
    this.events[type].unshift(handler);
&#125;
</code></pre>
<p>紧接着就是实现事件监听的方法<code>removeListener/on</code></p>
<pre><code class="javascript">removeListener(type, handler) &#123;
    if (!this.events[type]) &#123;
        return;
    &#125;
    this.events[type] = this.events[type].filter(item =&gt; item !== handler);
&#125;

off(type,handler)&#123;
    this.removeListener(type,handler)
&#125;
</code></pre>
<p>最后再来实现<code>once</code>方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过<code>fired</code>属性值判断事件函数是否执行过</p>
<pre><code class="javascript">once(type, handler) &#123;
    this.on(type, this._onceWrap(type, handler, this));
  &#125;

  _onceWrap(type, handler, target) &#123;
    const state = &#123; fired: false, handler, type , target&#125;;
    const wrapFn = this._onceWrapper.bind(state);
    state.wrapFn = wrapFn;
    return wrapFn;
  &#125;

  _onceWrapper(...args) &#123;
    if (!this.fired) &#123;
      this.fired = true;
      Reflect.apply(this.handler, this.target, args);
      this.target.off(this.type, this.wrapFn);
    &#125;
 &#125;
</code></pre>
<p>完整代码如下：</p>
<pre><code class="javascript">class EventEmitter &#123;
    constructor() &#123;
        this.events = &#123;&#125;;
    &#125;

    on(type, handler) &#123;
        if (!this.events[type]) &#123;
            this.events[type] = [];
        &#125;
        this.events[type].push(handler);
    &#125;

    addListener(type,handler)&#123;
        this.on(type,handler)
    &#125;

    prependListener(type, handler) &#123;
        if (!this.events[type]) &#123;
            this.events[type] = [];
        &#125;
        this.events[type].unshift(handler);
    &#125;

    removeListener(type, handler) &#123;
        if (!this.events[type]) &#123;
            return;
        &#125;
        this.events[type] = this.events[type].filter(item =&gt; item !== handler);
    &#125;

    off(type,handler)&#123;
        this.removeListener(type,handler)
    &#125;

    emit(type, ...args) &#123;
        this.events[type].forEach((item) =&gt; &#123;
            Reflect.apply(item, this, args);
        &#125;);
    &#125;

    once(type, handler) &#123;
        this.on(type, this._onceWrap(type, handler, this));
    &#125;

    _onceWrap(type, handler, target) &#123;
        const state = &#123; fired: false, handler, type , target&#125;;
        const wrapFn = this._onceWrapper.bind(state);
        state.wrapFn = wrapFn;
        return wrapFn;
    &#125;

    _onceWrapper(...args) &#123;
        if (!this.fired) &#123;
            this.fired = true;
            Reflect.apply(this.handler, this.target, args);
            this.target.off(this.type, this.wrapFn);
        &#125;
    &#125;
&#125;
</code></pre>
<p>测试代码如下：</p>
<pre><code class="javascript">const ee = new EventEmitter();// 注册所有事件ee.once(&#39;wakeUp&#39;, (name) =&gt; &#123; console.log(`$&#123;name&#125; 1`); &#125;);ee.on(&#39;e
</code></pre>
<h3 id="♥︎-♥︎-♥︎-说说-Node-文件查找的优先级以及-Require-方法的文件查找策略"><a href="#♥︎-♥︎-♥︎-说说-Node-文件查找的优先级以及-Require-方法的文件查找策略" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?"></a>♥︎ ♥︎ ♥︎ 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?</h3><h4 id="一、模块规范"><a href="#一、模块规范" class="headerlink" title="一、模块规范"></a>一、模块规范</h4><p><code>NodeJS</code>对<code>CommonJS</code>进行了支持和实现，让我们在开发<code>node</code>的过程中可以方便的进行模块化开发：</p>
<ul>
<li>在Node中每一个js文件都是一个单独的模块</li>
<li>模块中包括CommonJS规范的核心变量：exports、module.exports、require</li>
<li>通过上述变量进行模块化开发</li>
</ul>
<p>而模块化的核心是导出与导入，在<code>Node</code>中通过<code>exports</code>与<code>module.exports</code>负责对模块中的内容进行导出，通过<code>require</code>函数导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</p>
<h4 id="二、查找策略"><a href="#二、查找策略" class="headerlink" title="二、查找策略"></a>二、查找策略</h4><p><code>require</code>方法接收一下几种参数的传递：</p>
<ul>
<li>原生模块：http、fs、path等</li>
<li>相对路径的文件模块：.&#x2F;mod或..&#x2F;mod</li>
<li>绝对路径的文件模块：&#x2F;pathtomodule&#x2F;mod</li>
<li>目录作为模块：.&#x2F;dirname</li>
<li>非原生模块的文件模块：mod</li>
</ul>
<p><code>require</code>参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33336165386566302d633962612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会优先从缓存中加载已经存在的模块</p>
<h5 id="原生模块"><a href="#原生模块" class="headerlink" title="原生模块"></a>原生模块</h5><p>而像原生模块这些，通过<code>require </code>方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载</p>
<h5 id="绝对路径、相对路径"><a href="#绝对路径、相对路径" class="headerlink" title="绝对路径、相对路径"></a>绝对路径、相对路径</h5><p>如果<code>require</code>绝对路径的文件，则直接查找对应的路径，速度最快</p>
<p>相对路径的模块则相对于当前调用<code>require</code>的文件去查找</p>
<p>如果按确切的文件名没有找到模块，则 <code>NodeJs</code> 会尝试带上 <code>.js</code>、<code>.json </code>或 <code>.node </code>拓展名再加载</p>
<h5 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h5><p>默认情况是根据根目录中<code>package.json</code>文件的<code>main</code>来指定目录模块，如：</p>
<pre><code class="javascript">&#123; &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;main.js&quot; &#125;
</code></pre>
<p>如果这是在<code>./some-library node_modules</code>目录中，则 <code>require(&#39;./some-library&#39;)</code> 会试图加载 <code>./some-library/main.js</code></p>
<p>如果目录里没有 <code>package.json</code>文件，或者 <code>main</code>入口不存在或无法解析，则会试图加载目录下的 <code>index.js</code> 或 <code>index.node</code> 文件</p>
<h5 id="非原生模块"><a href="#非原生模块" class="headerlink" title="非原生模块"></a>非原生模块</h5><p>在每个文件中都存在<code>module.paths</code>，表示模块的搜索路径，<code>require</code>就是根据其来寻找文件</p>
<p>在<code>window</code>下输出如下：</p>
<pre><code class="javascript">[ &#39;c:\\nodejs\\node_modules&#39;,
&#39;c:\\node_modules&#39; ]
</code></pre>
<p>可以看出<code>module path</code>的生成规则为：从当前文件目录开始查找<code>node_modules</code>目录；然后依次进入父目录，查找父目录下的<code>node_modules</code>目录，依次迭代，直到根目录下的<code>node_modules</code>目录</p>
<p>当都找不到的时候，则会从系统<code>NODE_PATH</code>环境变量查找</p>
<h5 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h5><p>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ul>
<li>&#x2F;home&#x2F;ry&#x2F;projects&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;home&#x2F;ry&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;home&#x2F;node_modules&#x2F;bar.js</li>
<li>&#x2F;node_modules&#x2F;bar.js</li>
</ul>
<p>这使得程序本地化它们的依赖，避免它们产生冲突</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面模块的文件查找策略之后，总结下文件查找的优先级：</p>
<ul>
<li>缓存的模块优先级最高</li>
<li>如果是内置模块，则直接返回，优先级仅次缓存的模块</li>
<li>如果是绝对路径 &#x2F; 开头，则从根目录找</li>
<li>如果是相对路径 .&#x2F;开头，则从当前require文件相对位置找</li>
<li>如果文件没有携带后缀，先从js、json、node按顺序查找</li>
<li>如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js</li>
<li>如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何实现jwt鉴权机制？说说你的思路"><a href="#♥︎-♥︎-♥︎-如何实现jwt鉴权机制？说说你的思路" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何实现jwt鉴权机制？说说你的思路"></a>♥︎ ♥︎ ♥︎ 如何实现jwt鉴权机制？说说你的思路</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>JWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30353239303463302d636438392d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在目前前后端分离的开发过程中，使用<code>token</code>鉴权机制用于身份验证是最常见的方案，流程如下：</p>
<ul>
<li>服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证</li>
<li>后续访问会根据这个令牌判断用户时候有权限进行访问</li>
</ul>
<p><code>Token</code>，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以<code>.</code>进行拼接。其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31313735663939302d636438392d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="header"><a href="#header" class="headerlink" title="header"></a>header</h5><p>每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为<code>alg</code>，同时还有一个<code>typ</code>的字段，默认<code>JWT</code>即可。以下示例中算法为HS256</p>
<pre><code class="javascript">&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot; &#125; 
</code></pre>
<p>因为JWT是字符串，所以我们还需要对以上内容进行Base64编码，编码后字符串如下：</p>
<pre><code class="ini">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9        
</code></pre>
<h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p>载荷即消息体，这里会存放实际的内容，也就是<code>Token</code>的数据声明，例如用户的<code>id</code>和<code>name</code>，默认情况下也会携带令牌的签发时间<code>iat</code>，通过还可以设置过期时间，如下：</p>
<pre><code class="javascript">&#123;
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;iat&quot;: 1516239022
&#125;
</code></pre>
<p>同样进行Base64编码后，字符串如下：</p>
<pre><code class="ini">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
</code></pre>
<h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>签名是对头部和载荷内容进行签名，一般情况，设置一个<code>secretKey</code>，对前两个的结果进行<code>HMACSHA25</code>算法，公式如下：</p>
<pre><code class="javascript">Signature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)
</code></pre>
<p>一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致</p>
<h4 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p><code>Token</code>的使用分成了两部分：</p>
<ul>
<li>生成token：登录成功的时候，颁发token</li>
<li>验证token：访问某些资源或者接口时，验证token</li>
</ul>
<h5 id="生成-token"><a href="#生成-token" class="headerlink" title="生成 token"></a>生成 token</h5><p>借助第三方库<code>jsonwebtoken</code>，通过<code>jsonwebtoken</code> 的 <code>sign</code> 方法生成一个 <code>token</code>：</p>
<ul>
<li>第一个参数指的是 Payload</li>
<li>第二个是秘钥，服务端特有</li>
<li>第三个参数是 option，可以定义 token 过期时间</li>
</ul>
<pre><code class="javascript">const crypto = require(&quot;crypto&quot;),
  jwt = require(&quot;jsonwebtoken&quot;);
// TODO:使用数据库
// 这里应该是用数据库存储，这里只是演示用
let userList = [];

class UserController &#123;
  // 用户登录
  static async login(ctx) &#123;
    const data = ctx.request.body;
    if (!data.name || !data.password) &#123;
      return ctx.body = &#123;
        code: &quot;000002&quot;, 
        message: &quot;参数不合法&quot;
      &#125;
    &#125;
    const result = userList.find(item =&gt; item.name === data.name &amp;&amp; item.password === crypto.createHash(&#39;md5&#39;).update(data.password).digest(&#39;hex&#39;))
    if (result) &#123;
      // 生成token
      const token = jwt.sign(  
        &#123;
          name: result.name
        &#125;,
        &quot;test_token&quot;, // secret
        &#123; expiresIn: 60 * 60 &#125; // 过期时间：60 * 60 s
      );
      return ctx.body = &#123;
        code: &quot;0&quot;,
        message: &quot;登录成功&quot;,
        data: &#123;
          token
        &#125;
      &#125;;
    &#125; else &#123;
      return ctx.body = &#123;
        code: &quot;000002&quot;,
        message: &quot;用户名或密码错误&quot;
      &#125;;
    &#125;
  &#125;
&#125;

module.exports = UserController;
</code></pre>
<p>在前端接收到<code>token</code>后，一般情况会通过<code>localStorage</code>进行缓存，然后将<code>token</code>放到<code>HTTP </code>请求头<code>Authorization</code> 中，关于<code>Authorization</code> 的设置，前面要加上 Bearer ，注意后面带有空格</p>
<pre><code class="javascript">axios.interceptors.request.use(config =&gt; &#123;
  const token = localStorage.getItem(&#39;token&#39;);
  config.headers.common[&#39;Authorization&#39;] = &#39;Bearer &#39; + token; // 留意这里的 Authorization
  return config;
&#125;)
</code></pre>
<h5 id="校验token"><a href="#校验token" class="headerlink" title="校验token"></a>校验token</h5><p>使用 <code>koa-jwt</code> 中间件进行验证，方式比较简单</p>
<pre><code class="javascript">/ 注意：放在路由前面
app.use(koajwt(&#123;
  secret: &#39;test_token&#39;
&#125;).unless(&#123; // 配置白名单
  path: [/\/api\/register/, /\/api\/login/]
&#125;))
</code></pre>
<ul>
<li>secret 必须和 sign 时候保持一致</li>
<li>可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆&#x2F;注册都可以不用校验</li>
<li>校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验</li>
</ul>
<p>获取<code>token</code>用户的信息方法如下：</p>
<pre><code class="javascript">router.get(&#39;/api/userInfo&#39;,async (ctx,next) =&gt;&#123;    const authorization =  ctx.header.authorization // 获取jwt    const token = authorization.replace(&#39;Beraer &#39;,&#39;&#39;)    const result = jwt.verify(token,&#39;test_token&#39;)    ctx.body = result
</code></pre>
<p>注意：上述的<code>HMA256</code>加密算法为单秘钥的形式，一旦泄露后果非常的危险</p>
<p>在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌</p>
<p>这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择<code>RS256</code></p>
<h4 id="三、优缺点"><a href="#三、优缺点" class="headerlink" title="三、优缺点"></a>三、优缺点</h4><p>优点：</p>
<ul>
<li>json具有通用性，所以可以跨语言</li>
<li>组成简单，字节占用小，便于传输</li>
<li>服务端无需保存会话信息，很容易进行水平扩展</li>
<li>一处生成，多处使用，可以在分布式系统中，解决单点登录问题</li>
<li>可防护CSRF攻击</li>
</ul>
<p>缺点：</p>
<ul>
<li>payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息</li>
<li>需要保护好加密密钥，一旦泄露后果不堪设想</li>
<li>为避免token被劫持，最好使用https协议</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何实现文件上传？说说你的思路"><a href="#♥︎-♥︎-♥︎-如何实现文件上传？说说你的思路" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何实现文件上传？说说你的思路"></a>♥︎ ♥︎ ♥︎ 如何实现文件上传？说说你的思路</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能</p>
<p>因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里</p>
<p>对于文件上传，我们需要设置请求头为<code>content-type:multipart/form-data</code></p>
<blockquote>
<p>multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件</p>
</blockquote>
<p>结构如下：</p>
<pre><code class="http">POST /t2/upload.do HTTP/1.1
User-Agent: SOHUWapRebot
Accept-Language: zh-cn,zh;q=0.5
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Content-Length: 60408
Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Host: w.sohu.com

--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data; name=&quot;city&quot;

Santa colo
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name=&quot;desc&quot;
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
 
...
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name=&quot;pic&quot;; filename=&quot;photo.jpg&quot;
Content-Type: application/octet-stream
Content-Transfer-Encoding: binary
 
... binary data of the jpg ...
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--
</code></pre>
<p><code>boundary</code>表示分隔符，如果要上传多个表单项，就要使用<code>boundary</code>分割，每个表单项由<code>———XXX</code>开始，以<code>———XXX</code>结尾</p>
<p>而<code>xxx</code>是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现</p>
<p>每个表单项必须包含一个 <code>Content-Disposition</code> 头，其他的头信息则为可选项， 比如 <code>Content-Type</code></p>
<p><code>Content-Disposition</code> 包含了 <code>type </code>和 一个名字为<code>name</code>的 <code>parameter</code>，<code>type</code> 是 <code>form-data</code>，<code>name </code>参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 <code>filename </code>参数，值就是文件名</p>
<pre><code class="javascript">Content-Disposition: form-data; name=&quot;user&quot;; filename=&quot;logo.png&quot;
</code></pre>
<p>至于使用<code>multipart/form-data</code>，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高</p>
<h4 id="二、如何实现-1"><a href="#二、如何实现-1" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>关于文件的上传的上传，我们可以分成两步骤：</p>
<ul>
<li>文件的上传</li>
<li>文件的解析</li>
</ul>
<h5 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h5><p>传统前端文件上传的表单结构如下：</p>
<pre><code class="html">&lt;form action=&quot;http://localhost:8080/api/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; value=&quot;&quot; multiple=&quot;multiple&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;
action` 就是我们的提交到的接口，`enctype=&quot;multipart/form-data&quot;` 就是指定上传文件格式，`input` 的 `name` 属性一定要等于`file
</code></pre>
<h5 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h5><p>在服务器中，这里采用<code>koa2</code>中间件的形式解析上传的文件数据，分别有下面两种形式：</p>
<ul>
<li>koa-body</li>
<li>koa-multer</li>
</ul>
<h5 id="koa-body"><a href="#koa-body" class="headerlink" title="koa-body"></a>koa-body</h5><p>安装依赖</p>
<pre><code class="nginx">npm install koa-body
</code></pre>
<p>引入<code>koa-body</code>中间件</p>
<pre><code class="javascript">const koaBody = require(&#39;koa-body&#39;);
app.use(koaBody(&#123;
    multipart: true,
    formidable: &#123;
        maxFileSize: 200*1024*1024    // 设置上传文件大小最大限制，默认2M
    &#125;
&#125;));
</code></pre>
<p>获取上传的文件</p>
<pre><code class="javascript">const file = ctx.request.files.file; // 获取上传文件
</code></pre>
<p>获取文件数据后，可以通过<code>fs</code>模块将文件保存到指定目录</p>
<pre><code class="javascript">router.post(&#39;/uploadfile&#39;, async (ctx, next) =&gt; &#123;
  // 上传单个文件
  const file = ctx.request.files.file; // 获取上传文件
  // 创建可读流
  const reader = fs.createReadStream(file.path);
  let filePath = path.join(__dirname, &#39;public/upload/&#39;) + `/$&#123;file.name&#125;`;
  // 创建可写流
  const upStream = fs.createWriteStream(filePath);
  // 可读流通过管道写入可写流
  reader.pipe(upStream);
  return ctx.body = &quot;上传成功！&quot;;
&#125;);
</code></pre>
<h5 id="koa-multer"><a href="#koa-multer" class="headerlink" title="koa-multer"></a>koa-multer</h5><p>安装依赖：</p>
<pre><code class="ini">npm install koa-multer
</code></pre>
<p>使用 <code>multer</code> 中间件实现文件上传</p>
<pre><code class="javascript">const storage = multer.diskStorage(&#123;  destination: (req, file, cb) =&gt; &#123;    cb(null, &quot;./upload/&quot;)  &#125;,  filename: (req, file, cb) =&gt; &#123;    cb(null, Date.now() + path.extname(file.originalname))  &#125;&#125;)
const upload = multer(&#123;  storage&#125;);
const fileRouter = new Router();
fileRouter.post(&quot;/upload&quot;, upload.single(&#39;file&#39;), (ctx, next) =&gt; &#123;  console.log(ctx.req.file); // 获取文件&#125;)app.use(fileRouter.routes());
</code></pre>
<h3 id="♥︎-♥︎-♥︎-如果让你来设计一个分页功能-你会怎么设计-前后端如何交互"><a href="#♥︎-♥︎-♥︎-如果让你来设计一个分页功能-你会怎么设计-前后端如何交互" class="headerlink" title="♥︎ ♥︎ ♥︎ 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?"></a>♥︎ ♥︎ ♥︎ 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在我们做数据查询的时候，如果数据量很大，比如几万条数据，放在一个页面显示的话显然不友好，这时候就需要采用分页显示的形式，如每次只显示10条数据</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36303730653863302d636631342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>要实现分页功能，实际上就是从结果集中显示第1<del>10条记录作为第1页,显示第11</del>20条记录作为第2页，以此类推</p>
<p>因此，分页实际上就是从结果集中截取出第M~N条记录</p>
<h4 id="二、如何实现-2"><a href="#二、如何实现-2" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>前端实现分页功能，需要后端返回必要的数据，如总的页数，总的数据量，当前页，当前的数据</p>
<pre><code class="javascript">&#123;
 &quot;totalCount&quot;: 1836,   // 总的条数
 &quot;totalPages&quot;: 92,  // 总页数
 &quot;currentPage&quot;: 1   // 当前页数
 &quot;data&quot;: [     // 当前页的数据
   &#123;
 ...
   &#125;
]
</code></pre>
<p>后端采用<code>mysql</code>作为数据的持久性存储</p>
<p>前端向后端发送目标的页码<code>page</code>以及每页显示数据的数量<code>pageSize</code>，默认情况每次取10条数据，则每一条数据的起始位置<code>start</code>为：</p>
<pre><code class="javascript">const start = (page - 1) * pageSize
</code></pre>
<p>当确定了<code>limit</code>和<code>start</code>的值后，就能够确定<code>SQL</code>语句：</p>
<pre><code class="javascript">const sql = `SELECT * FROM record limit $&#123;pageSize&#125; OFFSET $&#123;start&#125;;`
</code></pre>
<p>上诉<code>SQL</code>语句表达的意思为：截取从<code>start</code>到<code>start</code>+<code>pageSize</code>之间（左闭右开）的数据</p>
<p>关于查询数据总数的<code>SQL</code>语句为，<code>record</code>为表名：</p>
<pre><code class="javascript">SELECT COUNT(*) FROM record
</code></pre>
<p>因此后端的处理逻辑为：</p>
<ul>
<li>获取用户参数页码数page和每页显示的数目 pageSize ，其中page 是必须传递的参数，pageSize为可选参数，默认为10</li>
<li>编写 SQL 语句，利用 limit 和 OFFSET 关键字进行分页查询</li>
<li>查询数据库，返回总数据量、总页数、当前页、当前页数据给前端</li>
</ul>
<p>代码如下所示：</p>
<pre><code class="javascript">router.all(&#39;/api&#39;, function (req, res, next) &#123;
  var param = &#39;&#39;;
  // 获取参数
  if (req.method == &quot;POST&quot;) &#123;
    param = req.body;
  &#125; else &#123;
    param = req.query || req.params;
  &#125;
  if (param.page == &#39;&#39; || param.page == null || param.page == undefined) &#123;
    res.end(JSON.stringify(&#123; msg: &#39;请传入参数page&#39;, status: &#39;102&#39; &#125;));
    return;
  &#125;
  const pageSize = param.pageSize || 10;
  const start = (param.page - 1) * pageSize;
  const sql = `SELECT * FROM record limit $&#123;pageSize&#125; OFFSET $&#123;start&#125;;`
  pool.getConnection(function (err, connection) &#123;
    if (err) throw err;
    connection.query(sql, function (err, results) &#123;
      connection.release();
      if (err) &#123;
        throw err
      &#125; else &#123;
        // 计算总页数
        var allCount = results[0][0][&#39;COUNT(*)&#39;];
        var allPage = parseInt(allCount) / 20;
        var pageStr = allPage.toString();
        // 不能被整除
        if (pageStr.indexOf(&#39;.&#39;) &gt; 0) &#123;
          allPage = parseInt(pageStr.split(&#39;.&#39;)[0]) + 1;
        &#125;
        var list = results[1];
        res.end(JSON.stringify(&#123; msg: &#39;操作成功&#39;, status: &#39;200&#39;, totalPages: allPage, currentPage: param.page, totalCount: allCount, data: list &#125;));
      &#125;
    &#125;)
  &#125;)
&#125;);
</code></pre>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面的分析，可以看到分页查询的关键在于，要首先确定每页显示的数量<code>pageSize</code>，然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p>
<ul>
<li>LIMIT 总是设定为 pageSize</li>
<li>OFFSET 计算公式为 pageSize * (pageIndex - 1)</li>
</ul>
<p>确定了这两个值，就能查询出第 <code>N</code>页的数据</p>
<hr>
<h3 id="♥︎-♥︎-♥︎-♥︎-koa-中间件的实现原理"><a href="#♥︎-♥︎-♥︎-♥︎-koa-中间件的实现原理" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎  koa 中间件的实现原理"></a>♥︎ ♥︎ ♥︎ ♥︎  koa 中间件的实现原理</h3><p>每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next 函数。只要调用 next函数，就可以把执行权转交给下一个中间件。</p>
<p>如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。</p>
<p>多个中间件会形成一个栈结构，以“先进后出”的顺序执行。整个过程就像，先是入栈，然后出栈的操作。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-图片上传到服务器的过程"><a href="#♥︎-♥︎-♥︎-♥︎-图片上传到服务器的过程" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 图片上传到服务器的过程"></a>♥︎ ♥︎ ♥︎ ♥︎ 图片上传到服务器的过程</h3><h4 id="前端业务"><a href="#前端业务" class="headerlink" title="前端业务"></a>前端业务</h4><p>根据后台接口发送请求，图片作为参数，需要带上一个 name 字段</p>
<h4 id="后台业务"><a href="#后台业务" class="headerlink" title="后台业务"></a>后台业务</h4><p>后台接收图片可以使用 ndoe 的 fs、path 文件系统加上 multer 的 npm 包实现。主要思想是通过multer 创建一个临时空间用来接收并存储前端发送过来的二进制图片数据。通过 fs 模块读取临时空间的数据，并使用 pipe 方法注入到 fs 模块创建 path 模块指向的服务器文件夹下</p>
<p>后台代码试例，express 环境</p>
<pre><code class="javascript">var express = require(&#39;express&#39;)
var router = express.Router()
var fs = require(&#39;fs&#39;)
var path = require(&#39;path&#39;)
/* 用于处理非表单的文件数据流 */
var multer = require(&#39;multer&#39;)
// 配置数据流向的文件,绝对路径，相对于根目录
var upload = multer(&#123; dest: &#39;upload/&#39; &#125;)
// 创建一个接收为编码的二进制数据流的方法实例 接收 name 为 newimg 字段的上传文件，最大接收
为 1
var cpUpload = upload.fields([&#123; name: &#39;newimg&#39;, maxCount: 1 &#125;])
// 接口
router.post(&#39;/add&#39;, cpUpload, (req, res) =&gt; &#123;
 // 前端发送请求后，服务器已经接受到了前端传递过来的图片数据，保存在 files 对象下
 // 加上 cpUpload，数据就会从这个方法所设置的地址流过来，生成一个本地临时空间，类似于虚拟
DOM
 // 获取这段数据
 var img = req.files.newimg[0]
 
 // fs 模块读取临时空间的数据 
 var readStream = fs.createReadStream(img.path) 
 // 设置图片存入的路径，并给文件名前面加上一个时间轴，防止命名重复 
 var imgpath = `/cdn/$&#123;Date.now()&#125;-$&#123;img.originalname&#125;` 
 // 创建一个写入图片数据的地址 
 var writeStram = fs.createWriteStream( path.resolve(__dirname, `../public$&#123;imgpath&#125;`) )
 // 设置一个 pipe 管道，将读取的数据解析并注入到写入地址 
 readStream.pipe(writeStram) 
 // 监听注入地址的 close 事件，表示注入完毕 
 writeStram.on(&#39;close&#39;, () =&gt; &#123; 
   // 返回给前端一个图片地址 
   res.json(&#123; err: 0, msg: &#39;success&#39;, data: &#123; img: imgpath &#125; &#125;) &#125;)
   &#125;)
module.exports = router
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-koa-和-express-的区别"><a href="#♥︎-♥︎-♥︎-♥︎-koa-和-express-的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ koa 和 express 的区别"></a>♥︎ ♥︎ ♥︎ ♥︎ koa 和 express 的区别</h3><p>最大的区别在于语法，experss 的异步采用的是回调函数的形式，而 koa1 支持 generator + yeild，koa2 支持 await&#x2F;async，无疑更加优雅。</p>
<p>中间件的区别：koa 采用洋葱模型，进行顺序执行，出去反向执行，支持 context 传递数据 。express 本身无洋葱模型，需要引入插件，不支持 context express 的中间件中执行异步函数，执行顺序不会按照洋葱模型，异步的执行结果有可能被放到最后，response 之前。 这是由于，其中间件执行机制，递归回调中没有等待中间件中的异步函数执行完毕，就是没有 await 中间件异步函数</p>
<p>集成度区别：express 内置了很多中间件，集成度高，使用省心， koa 轻量简洁，容易定制</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-了解-eggjs-吗？"><a href="#♥︎-♥︎-♥︎-♥︎-了解-eggjs-吗？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 了解 eggjs 吗？"></a>♥︎ ♥︎ ♥︎ ♥︎ 了解 eggjs 吗？</h3><p>eggjs 的特性 提供基于 Egg 定制上层框架的能力 高度可扩展的插件机制 内置多进程管理 基于 Koa 开发，性能优异 框架稳定，测试覆盖率高 渐进式开发</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-说说对Nodejs中的事件循环机制理解"><a href="#♥︎-♥︎-♥︎-♥︎-说说对Nodejs中的事件循环机制理解" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说说对Nodejs中的事件循环机制理解?"></a>♥︎ ♥︎ ♥︎ ♥︎ 说说对Nodejs中的事件循环机制理解?</h3><h4 id="一、是什么-9"><a href="#一、是什么-9" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在浏览器事件循环中，我们了解到<code>javascript</code>在浏览器中的事件循环机制，其是根据<code>HTML5</code>定义的规范来实现</p>
<p>而在<code>NodeJS</code>中，事件循环是基于<code>libuv</code>实现，<code>libuv</code>是一个多平台的专注于异步IO的库，如下图最右侧所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613639306239302d633930652d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>上图<code>EVENT_QUEUE</code> 给人看起来只有一个队列，但<code>EventLoop</code>存在6个阶段，每个阶段都有对应的一个先进先出的回调队列</p>
<h4 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h4><p>上节讲到事件循环分成了六个阶段，对应如下：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326533346438302d633930652d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<ul>
<li>timers阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li>
<li>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数</li>
<li>I&#x2F;O事件回调阶段(I&#x2F;O callbacks)：执行延迟到下一个循环迭代的 I&#x2F;O 回调，即上一轮循环中未被执行的一些I&#x2F;O回调</li>
<li>闲置阶段(idle, prepare)：仅系统内部使用</li>
<li>轮询阶段(poll)：检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞</li>
<li>检查阶段(check)：setImmediate() 回调函数在这里执行</li>
<li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)</li>
</ul>
<p>每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段</p>
<p>除了上述6个阶段，还存在<code>process.nextTick</code>，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队</p>
<p>流程图如下所示：</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66626537333164302d633930652d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在<code>Node</code>中，同样存在宏任务和微任务，与浏览器中的事件循环相似</p>
<p>微任务对应有：</p>
<ul>
<li>next tick queue：process.nextTick</li>
<li>other queue：Promise的then回调、queueMicrotask</li>
</ul>
<p>宏任务对应有：</p>
<ul>
<li>timer queue：setTimeout、setInterval</li>
<li>poll queue：IO事件</li>
<li>check queue：setImmediate</li>
<li>close queue：close事件</li>
</ul>
<p>其执行顺序为：</p>
<ul>
<li>next tick microtask queue</li>
<li>other microtask queue</li>
<li>timer queue</li>
<li>poll queue</li>
<li>check queue</li>
<li>close queue</li>
</ul>
<h4 id="三、题目"><a href="#三、题目" class="headerlink" title="三、题目"></a>三、题目</h4><p>通过上面的学习，下面开始看看题目</p>
<pre><code class="javascript">async function async1() &#123;
    console.log(&#39;async1 start&#39;)
    await async2()
    console.log(&#39;async1 end&#39;)
&#125;

async function async2() &#123;
    console.log(&#39;async2&#39;)
&#125;

console.log(&#39;script start&#39;)

setTimeout(function () &#123;
    console.log(&#39;setTimeout0&#39;)
&#125;, 0)

setTimeout(function () &#123;
    console.log(&#39;setTimeout2&#39;)
&#125;, 300)

setImmediate(() =&gt; console.log(&#39;setImmediate&#39;));

process.nextTick(() =&gt; console.log(&#39;nextTick1&#39;));

async1();

process.nextTick(() =&gt; console.log(&#39;nextTick2&#39;));

new Promise(function (resolve) &#123;
    console.log(&#39;promise1&#39;)
    resolve();
    console.log(&#39;promise2&#39;)
&#125;).then(function () &#123;
    console.log(&#39;promise3&#39;)
&#125;)

console.log(&#39;script end&#39;)
</code></pre>
<p>分析过程：</p>
<ul>
<li>先找到同步任务，输出script start</li>
<li>遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</li>
<li>遇到第二个 setTimeout，300ms后将里面的回调函数放到 timer 队列中</li>
<li>遇到第一个setImmediate，将里面的回调函数放到 check 队列中</li>
<li>遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</li>
<li>执行 async1函数，输出 async1 start</li>
<li>执行 async2 函数，输出 async2，async2 后面的输出 async1 end进入微任务，等待下一轮的事件循环</li>
<li>遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行</li>
<li>遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</li>
<li>then里面的回调函数进入微任务队列</li>
<li>遇到同步任务，输出 script end</li>
<li>执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</li>
<li>然后执行微任务队列，依次输出 async1 end、promise3</li>
<li>执行timer 队列，依次输出 setTimeout0</li>
<li>接着执行 check 队列，依次输出 setImmediate</li>
<li>300ms后，timer 队列存在任务，执行输出 setTimeout2</li>
</ul>
<p>执行结果如下：</p>
<pre><code class="javascript">script start
async1 start
async2
promise1
promise2
script end
nextTick1
nextTick2
async1 end
promise3
setTimeout0
setImmediate
setTimeout2
</code></pre>
<p>最后有一道是关于<code>setTimeout</code>与<code>setImmediate</code>的输出顺序</p>
<pre><code class="javascript">setTimeout(() =&gt; &#123;
  console.log(&quot;setTimeout&quot;);
&#125;, 0);

setImmediate(() =&gt; &#123;
  console.log(&quot;setImmediate&quot;);
&#125;);
</code></pre>
<p>输出情况如下：</p>
<pre><code class="javascript">情况一：
setTimeout
setImmediate

情况二：
setImmediate
setTimeout
</code></pre>
<p>分析下流程：</p>
<ul>
<li>外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段</li>
<li>遇到<code>setTimeout</code>，虽然设置的是0毫秒触发，但实际上会被强制改成1ms，时间到了然后塞入<code>times</code>阶段</li>
<li>遇到<code>setImmediate</code>塞入<code>check</code>阶段</li>
<li>同步代码执行完毕，进入Event Loop</li>
<li>先进入<code>times</code>阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足<code>setTimeout</code>条件，执行回调，如果没过1毫秒，跳过</li>
<li>跳过空的阶段，进入check阶段，执行<code>setImmediate</code>回调</li>
</ul>
<p>这里的关键在于这1ms，如果同步代码执行时间较长，进入<code>Event Loop</code>的时候1毫秒已经过了，<code>setTimeout</code>先执行，如果1毫秒还没到，就先执行了<code>setImmediate</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-说说对中间件概念的理解，如何封装-node-中间件？"><a href="#♥︎-♥︎-♥︎-♥︎-说说对中间件概念的理解，如何封装-node-中间件？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ 说说对中间件概念的理解，如何封装 node 中间件？"></a>♥︎ ♥︎ ♥︎ ♥︎ 说说对中间件概念的理解，如何封装 node 中间件？</h3><h4 id="一、是什么-10"><a href="#一、是什么-10" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的</p>
<p>在<code>NodeJS</code>中，中间件主要是指封装<code>http</code>请求细节处理的方法</p>
<p>例如在<code>express</code>、<code>koa</code>等<code>web</code>框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数</p>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36613665643366302d636365342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作</p>
<h4 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h4><p><code>koa</code>是基于<code>NodeJS</code>当前比较流行的<code>web</code>框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。通过添加不同的中间件，实现不同的需求，从而构建一个 <code>Koa</code> 应用</p>
<p><code>Koa</code> 中间件采用的是洋葱圈模型，每次执行下一个中间件传入两个参数：</p>
<ul>
<li>ctx ：封装了request 和 response 的变量</li>
<li>next ：进入下一个要执行的中间件的函数</li>
</ul>
<p><img src="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8node/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353037623032302d636365342d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>下面就针对<code>koa</code>进行中间件的封装：</p>
<p><code>Koa </code>的中间件就是函数，可以是<code> async</code> 函数，或是普通函数</p>
<pre><code class="javascript">// async 函数
app.use(async (ctx, next) =&gt; &#123;
  const start = Date.now();
  await next();
  const ms = Date.now() - start;
  console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);
&#125;);

// 普通函数
app.use((ctx, next) =&gt; &#123;
  const start = Date.now();
  return next().then(() =&gt; &#123;
    const ms = Date.now() - start;
    console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);
  &#125;);
&#125;);
</code></pre>
<p>下面则通过中间件封装<code>http</code>请求过程中几个常用的功能：</p>
<h5 id="token校验"><a href="#token校验" class="headerlink" title="token校验"></a>token校验</h5><pre><code class="javascript">module.exports = (options) =&gt; async (ctx, next) &#123;
  try &#123;
    // 获取 token
    const token = ctx.header.authorization
    if (token) &#123;
      try &#123;
          // verify 函数验证 token，并获取用户相关信息
          await verify(token)
      &#125; catch (err) &#123;
        console.log(err)
      &#125;
    &#125;
    // 进入下一个中间件
    await next()
  &#125; catch (err) &#123;
    console.log(err)
  &#125;
&#125;
</code></pre>
<h5 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h5><pre><code class="javascript">const fs = require(&#39;fs&#39;)
module.exports = (options) =&gt; async (ctx, next) =&gt; &#123;
  const startTime = Date.now()
  const requestTime = new Date()
  await next()
  const ms = Date.now() - startTime;
  let logout = `$&#123;ctx.request.ip&#125; -- $&#123;requestTime&#125; -- $&#123;ctx.method&#125; -- $&#123;ctx.url&#125; -- $&#123;ms&#125;ms`;
  // 输出日志文件
  fs.appendFileSync(&#39;./log.txt&#39;, logout + &#39;\n&#39;)
&#125;
</code></pre>
<p><code>Koa</code>存在很多第三方的中间件，如<code>koa-bodyparser</code>、<code>koa-static</code>等</p>
<p>下面再来看看它们的大体的简单实现：</p>
<h5 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h5><p><code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值</p>
<pre><code class="javascript">// 文件：my-koa-bodyparser.js
const querystring = require(&quot;querystring&quot;);

module.exports = function bodyParser() &#123;
    return async (ctx, next) =&gt; &#123;
        await new Promise((resolve, reject) =&gt; &#123;
            // 存储数据的数组
            let dataArr = [];

            // 接收数据
            ctx.req.on(&quot;data&quot;, data =&gt; dataArr.push(data));

            // 整合数据并使用 Promise 成功
            ctx.req.on(&quot;end&quot;, () =&gt; &#123;
                // 获取请求数据的类型 json 或表单
                let contentType = ctx.get(&quot;Content-Type&quot;);

                // 获取数据 Buffer 格式
                let data = Buffer.concat(dataArr).toString();

                if (contentType === &quot;application/x-www-form-urlencoded&quot;) &#123;
                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body
                    ctx.request.body = querystring.parse(data);
                &#125; else if (contentType === &quot;applaction/json&quot;) &#123;
                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body
                    ctx.request.body = JSON.parse(data);
                &#125;

                // 执行成功的回调
                resolve();
            &#125;);
        &#125;);

        // 继续向下执行
        await next();
    &#125;;
&#125;;
</code></pre>
<h5 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h5><p><code>koa-static</code> 中间件的作用是在服务器接到请求时，帮我们处理静态文件</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const mime = require(&quot;mime&quot;);
const &#123; promisify &#125; = require(&quot;util&quot;);

// 将 stat 和 access 转换成 Promise
const stat = promisify(fs.stat);
const access = promisify(fs.access)

module.exports = function (dir) &#123;
    return async (ctx, next) =&gt; &#123;
        // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /
        let realPath = path.join(dir, ctx.path);

        try &#123;
            // 获取 stat 对象
            let statObj = await stat(realPath);

            // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html
            if (statObj.isFile()) &#123;
                ctx.set(&quot;Content-Type&quot;, `$&#123;mime.getType()&#125;;charset=utf8`);
                ctx.body = fs.createReadStream(realPath);
            &#125; else &#123;
                let filename = path.join(realPath, &quot;index.html&quot;);

                // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理
                await access(filename);

                // 存在设置文件类型并响应内容
                ctx.set(&quot;Content-Type&quot;, &quot;text/html;charset=utf8&quot;);
                ctx.body = fs.createReadStream(filename);
            &#125;
        &#125; catch (e) &#123;
            await next();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据</p>
<p><code>koa</code>本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得<code>web</code>应用具备良好的可拓展性和组合性</p>
<p>通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗杂代码，过程就如装饰者模式</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-Node性能如何进行监控以及优化？"><a href="#♥︎-♥︎-♥︎-♥︎-Node性能如何进行监控以及优化？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ Node性能如何进行监控以及优化？"></a>♥︎ ♥︎ ♥︎ ♥︎ Node性能如何进行监控以及优化？</h3><h4 id="一、-是什么"><a href="#一、-是什么" class="headerlink" title="一、 是什么"></a>一、 是什么</h4><p><code>Node</code>作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下：</p>
<ul>
<li>CPU</li>
<li>内存</li>
<li>I&#x2F;O</li>
<li>网络</li>
</ul>
<h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><p>主要分成了两部分：</p>
<ul>
<li>CPU负载：在某个时间段内，占用以及等待CPU的进程总数</li>
<li>CPU使用率：CPU时间占用状况，等于 1 - 空闲CPU时间(idle time) &#x2F; CPU总时间</li>
</ul>
<p>这两个指标都是用来评估系统当前CPU的繁忙程度的量化指标</p>
<p><code>Node</code>应用一般不会消耗很多的<code>CPU</code>，如果<code>CPU</code>占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞</p>
<h5 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h5><p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标</p>
<pre><code class="javascript">// /app/lib/memory.js
const os = require(&#39;os&#39;);
// 获取当前Node内存堆栈情况
const &#123; rss, heapUsed, heapTotal &#125; = process.memoryUsage();
// 获取系统空闲内存
const sysFree = os.freemem();
// 获取系统总内存
const sysTotal = os.totalmem();

module.exports = &#123;
  memory: () =&gt; &#123;
    return &#123;
      sys: 1 - sysFree / sysTotal,  // 系统内存占用率
      heap: heapUsed / headTotal,   // Node堆内存占用率
      node: rss / sysTotal,         // Node占用系统内存的比例
    &#125;
  &#125;
&#125;
</code></pre>
<ul>
<li>rss：表示node进程占用的内存总量。</li>
<li>heapTotal：表示堆内存的总量。</li>
<li>heapUsed：实际堆内存的使用量。</li>
<li>external ：外部程序的内存使用量，包含Node核心的C++程序的内存使用量</li>
</ul>
<p>在<code>Node</code>中，一个进程的最大内存容量为1.5GB。因此我们需要减少内存泄露</p>
<h5 id="磁盘-I-x2F-O"><a href="#磁盘-I-x2F-O" class="headerlink" title="磁盘 I&#x2F;O"></a>磁盘 I&#x2F;O</h5><p>硬盘的<code> IO</code> 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍</p>
<p>内存 <code>IO </code>比磁盘<code> IO</code> 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 <code>redis</code>、<code>memcached </code>等</p>
<p>并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决</p>
<h4 id="二、如何监控"><a href="#二、如何监控" class="headerlink" title="二、如何监控"></a>二、如何监控</h4><p>关于性能方面的监控，一般情况都需要借助工具来实现</p>
<p>这里采用<code>Easy-Monitor 2.0</code>，其是轻量级的 <code>Node.js</code> 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 <code>require</code> 一次，无需改动任何业务代码即可开启内核级别的性能监控分析</p>
<p>使用方法如下：</p>
<p>在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：</p>
<pre><code class="javascript">const easyMonitor = require(&#39;easy-monitor&#39;);
easyMonitor(&#39;你的项目名称&#39;);
</code></pre>
<p>打开你的浏览器，访问 <code>http://localhost:12333</code> ，即可看到进程界面</p>
<p>关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档</p>
<h4 id="三、如何优化"><a href="#三、如何优化" class="headerlink" title="三、如何优化"></a>三、如何优化</h4><p>关于<code>Node</code>的性能优化的方式有：</p>
<ul>
<li>使用最新版本Node.js</li>
<li>正确使用流 Stream</li>
<li>代码层面优化</li>
<li>内存管理优化</li>
</ul>
<h5 id="使用最新版本Node-js"><a href="#使用最新版本Node-js" class="headerlink" title="使用最新版本Node.js"></a>使用最新版本Node.js</h5><p>每个版本的性能提升主要来自于两个方面：</p>
<ul>
<li>V8 的版本更新</li>
<li>Node.js 内部代码的更新优化</li>
</ul>
<h5 id="正确使用流-Stream"><a href="#正确使用流-Stream" class="headerlink" title="正确使用流 Stream"></a>正确使用流 Stream</h5><p>在<code>Node</code>中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存</p>
<pre><code class="javascript">const http = require(&#39;http&#39;);
const fs = require(&#39;fs&#39;);

// bad
http.createServer(function (req, res) &#123;
    fs.readFile(__dirname + &#39;/data.txt&#39;, function (err, data) &#123;
        res.end(data);
    &#125;);
&#125;);

// good
http.createServer(function (req, res) &#123;
    const stream = fs.createReadStream(__dirname + &#39;/data.txt&#39;);
    stream.pipe(res);
&#125;);
</code></pre>
<h5 id="代码层面优化"><a href="#代码层面优化" class="headerlink" title="代码层面优化"></a>代码层面优化</h5><p>合并查询，将多次查询合并一次，减少数据库的查询次数</p>
<pre><code class="javascript">// bad
for user_id in userIds 
     let account = user_account.findOne(user_id)

// good
const user_account_map = &#123;&#125;   // 注意这个对象将会消耗大量内存。
user_account.find(user_id in user_ids).forEach(account)&#123;
    user_account_map[account.user_id] =  account
&#125;
for user_id in userIds 
    var account = user_account_map[user_id]
</code></pre>
<h5 id="内存管理优化"><a href="#内存管理优化" class="headerlink" title="内存管理优化"></a>内存管理优化</h5><p>在 V8 中，主要将内存分为新生代和老生代两代：</p>
<ul>
<li>新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象</li>
<li>老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象</li>
</ul>
<p>若新生代内存空间不够，直接分配到老生代</p>
<p>通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低</p>
<p>如下面情况：</p>
<pre><code class="javascript">const buffer = fs.readFileSync(__dirname + &#39;/source/index.htm&#39;);

app.use(
    mount(&#39;/&#39;, async (ctx) =&gt; &#123;
        ctx.status = 200;
        ctx.type = &#39;html&#39;;
        ctx.body = buffer;
        leak.push(fs.readFileSync(__dirname + &#39;/source/index.htm&#39;));
    &#125;)
);

const leak = [];
</code></pre>
<p><code>leak</code>的内存非常大，造成内存泄露，应当避免这样的操作，通过减少内存使用，是提高服务性能的手段之一</p>
<p>而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作</p>
<p>例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新new这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动</p>
<p>使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中。每次用到该对象时，就取对象池空闲的对象，并对它进行初始化操作，从而提高框架的性能</p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-秋天的第一个烤红薯"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/31/%E7%A7%8B%E5%A4%A9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%83%A4%E7%BA%A2%E8%96%AF/"
    >秋天的第一个烤红薯</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/31/%E7%A7%8B%E5%A4%A9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%83%A4%E7%BA%A2%E8%96%AF/" class="article-date">
  <time datetime="2022-10-31T08:18:44.000Z" itemprop="datePublished">2022-10-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%85%E8%A1%8C/">旅行</a> / <a class="article-category-link" href="/categories/%E6%97%85%E8%A1%8C/%E7%A7%8B%E5%A4%A9/">秋天</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="秋天的第一个烤红薯"><a href="#秋天的第一个烤红薯" class="headerlink" title="秋天的第一个烤红薯"></a>秋天的第一个烤红薯</h1><h2 id="美丽的不只是风景"><a href="#美丽的不只是风景" class="headerlink" title="美丽的不只是风景"></a>美丽的不只是风景</h2><p><img src="/2022/10/31/%E7%A7%8B%E5%A4%A9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%83%A4%E7%BA%A2%E8%96%AF/IMG_20220923_174805.jpg"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A3%E8%8A%82/" rel="tag">季节</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%85%E8%A1%8C/" rel="tag">旅行</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%8B%E5%A4%A9/" rel="tag">秋天</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全ES6"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/"
    >前端面试大全ES6</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/" class="article-date">
  <time datetime="2022-10-31T02:09:48.000Z" itemprop="datePublished">2022-10-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/ES6/">ES6</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（ES6）"><a href="#前端面试题大全（ES6）" class="headerlink" title="前端面试题大全（ES6）"></a>前端面试题大全（ES6）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-var、let、const之间的区别"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-var、let、const之间的区别" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ var、let、const之间的区别"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ var、let、const之间的区别</h3><h4 id="一、var"><a href="#一、var" class="headerlink" title="一、var"></a>一、var</h4><p>在ES5中，顶层对象的属性和全局变量是等价的，用<code>var</code>声明的变量既是全局变量，也是顶层变量</p>
<p>注意：顶层对象，在浏览器环境指的是<code>window</code>对象，在 <code>Node</code> 指的是<code>global</code>对象</p>
<pre><code class="javascript">var a = 10;
console.log(window.a) // 10
</code></pre>
<p>使用<code>var</code>声明的变量存在变量提升的情况</p>
<pre><code class="javascript">console.log(a) // undefined
var a = 20
</code></pre>
<p>在编译阶段，编译器会将其变成以下执行</p>
<pre><code class="javascript">var a
console.log(a)
a = 20
</code></pre>
<p>使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明</p>
<pre><code class="javascript">var a = 20 
var a = 30
console.log(a) // 30
</code></pre>
<p>在函数中使用使用<code>var</code>声明变量时候，该变量是局部的</p>
<pre><code class="javascript">var a = 20
function change()&#123;
    var a = 30
&#125;
change()
console.log(a) // 20 
</code></pre>
<p>而如果在函数内不使用<code>var</code>，该变量是全局的</p>
<pre><code class="javascript">var a = 20
function change()&#123;
   a = 30
&#125;
change()
console.log(a) // 30 
</code></pre>
<h4 id="二、let"><a href="#二、let" class="headerlink" title="二、let"></a>二、let</h4><p><code>let</code>是<code>ES6</code>新增的命令，用来声明变量</p>
<p>用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效</p>
<pre><code class="javascript">&#123;
    let a = 20
&#125;
console.log(a) // ReferenceError: a is not defined.
</code></pre>
<p>不存在变量提升</p>
<pre><code class="javascript">console.log(a) // 报错ReferenceError
let a = 2
</code></pre>
<p>这表示在声明它之前，变量<code>a</code>是不存在的，这时如果用到它，就会抛出一个错误</p>
<p>只要块级作用域内存在<code>let</code>命令，这个区域就不再受外部影响</p>
<pre><code class="javascript">var a = 123
if (true) &#123;
    a = &#39;abc&#39; // ReferenceError
    let a;
&#125;
</code></pre>
<p>使用<code>let</code>声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”</p>
<p>最后，<code>let</code>不允许在相同作用域中重复声明</p>
<pre><code class="javascript">let a = 20
let a = 30
// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared
</code></pre>
<p>注意的是相同作用域，下面这种情况是不会报错的</p>
<pre><code class="javascript">let a = 20
&#123;
    let a = 30
&#125;
</code></pre>
<p>因此，我们不能在函数内部重新声明参数</p>
<pre><code class="javascript">function func(arg) &#123;
  let arg;
&#125;
func()
// Uncaught SyntaxError: Identifier &#39;arg&#39; has already been declared
</code></pre>
<h4 id="三、const"><a href="#三、const" class="headerlink" title="三、const"></a>三、const</h4><p><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变</p>
<pre><code class="javascript">const a = 1
a = 3
// TypeError: Assignment to constant variable.
</code></pre>
<p>这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值</p>
<pre><code class="javascript">const a;
// SyntaxError: Missing initializer in const declaration
</code></pre>
<p>如果之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错</p>
<pre><code class="javascript">var a = 20
let b = 20
const a = 30
const b = 30
// 都会报错
</code></pre>
<p><code>const</code>实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</p>
<p>对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量</p>
<p>对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的，并不能确保改变量的结构不变</p>
<pre><code class="javascript">const foo = &#123;&#125;;

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only
</code></pre>
<p>其它情况，<code>const</code>与<code>let</code>一致</p>
<h4 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h4><p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p>
<ul>
<li>变量提升</li>
<li>暂时性死区</li>
<li>块级作用域</li>
<li>重复声明</li>
<li>修改声明的变量</li>
<li>使用</li>
</ul>
<h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><pre><code class="css">var `声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined
</code></pre>
<p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p>
<pre><code class="javascript">// var
console.log(a)  // undefined
var a = 10

// let 
console.log(b)  // Cannot access &#39;b&#39; before initialization
let b = 10

// const
console.log(c)  // Cannot access &#39;c&#39; before initialization
const c = 10
</code></pre>
<h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><p><code>var</code>不存在暂时性死区</p>
<p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<pre><code class="javascript">// var
console.log(a)  // undefined
var a = 10

// let
console.log(b)  // Cannot access &#39;b&#39; before initialization
let b = 10

// const
console.log(c)  // Cannot access &#39;c&#39; before initialization
const c = 10
</code></pre>
<h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p><code>var</code>不存在块级作用域</p>
<p><code>let</code>和<code>const</code>存在块级作用域</p>
<pre><code class="javascript">// var
&#123;
    var a = 20
&#125;
console.log(a)  // 20

// let
&#123;
    let b = 20
&#125;
console.log(b)  // Uncaught ReferenceError: b is not defined

// const
&#123;
    const c = 20
&#125;
console.log(c)  // Uncaught ReferenceError: c is not defined
</code></pre>
<h5 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h5><p><code>var</code>允许重复声明变量</p>
<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p>
<pre><code class="javascript">// var
var a = 10
var a = 20 // 20

// let
let b = 10
let b = 20 // Identifier &#39;b&#39; has already been declared

// const
const c = 10
const c = 20 // Identifier &#39;c&#39; has already been declared
</code></pre>
<h5 id="修改声明的变量"><a href="#修改声明的变量" class="headerlink" title="修改声明的变量"></a>修改声明的变量</h5><p><code>var</code>和<code>let</code>可以</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p>
<pre><code class="javascript">// var
var a = 10
a = 20
console.log(a)  // 20

//let
let b = 10
b = 20
console.log(b)  // 20

// const
const c = 10
c = 20
console.log(c) // Uncaught TypeError: Assignment to constant variable
</code></pre>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>能用<code>const</code>的情况尽量使用<code>const</code>，其他情况下大多数使用<code>let</code>，避免使用<code>var</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中数组新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中数组新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中数组新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中数组新增了哪些扩展?</h3><h4 id="一、扩展运算符的应用"><a href="#一、扩展运算符的应用" class="headerlink" title="一、扩展运算符的应用"></a>一、扩展运算符的应用</h4><p>ES6通过扩展元素符<code>...</code>，好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<pre><code class="javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre>
<p>主要用于函数调用的时候，将一个数组变为参数序列</p>
<pre><code class="javascript">function push(array, ...items) &#123;
  array.push(...items);
&#125;

function add(x, y) &#123;
  return x + y;
&#125;

const numbers = [4, 38];
add(...numbers) // 42
</code></pre>
<p>可以将某些数据结构转为数组</p>
<pre><code class="javascript">[...document.querySelectorAll(&#39;div&#39;)]
</code></pre>
<p>能够更简单实现数组复制</p>
<pre><code class="javascript">const a1 = [1, 2];
const [...a2] = a1;
// [1,2]
</code></pre>
<p>数组的合并也更为简洁了</p>
<pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;];
const arr2 = [&#39;c&#39;];
const arr3 = [&#39;d&#39;, &#39;e&#39;];
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</code></pre>
<p>注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组</p>
<p>下面看个例子就清楚多了</p>
<pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;,[1,2]];
const arr2 = [&#39;c&#39;];
const arr3  = [...arr1,...arr2]
arr1[2][0] = 9999 // 修改arr1里面数组成员值
console.log(arr3) // 影响到arr3,[&#39;a&#39;,&#39;b&#39;,[9999,2],&#39;c&#39;]
</code></pre>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组</p>
<pre><code class="javascript">const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = [&quot;foo&quot;];
first  // &quot;foo&quot;
rest   // []
</code></pre>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p>
<pre><code class="javascript">const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</code></pre>
<p>可以将字符串转为真正的数组</p>
<pre><code class="javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
<p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p>
<pre><code class="javascript">let nodeList = document.querySelectorAll(&#39;div&#39;);
let array = [...nodeList];

let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]
</code></pre>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错</p>
<pre><code class="javascript">const obj = &#123;a: 1, b: 2&#125;;
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
</code></pre>
<h4 id="二、构造函数新增的方法"><a href="#二、构造函数新增的方法" class="headerlink" title="二、构造函数新增的方法"></a>二、构造函数新增的方法</h4><p>关于构造函数，数组新增的方法有如下：</p>
<ul>
<li>Array.from()</li>
<li>Array.of()</li>
</ul>
<h5 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h5><p>将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>
<pre><code class="javascript">let arrayLike = &#123;
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
&#125;;
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<pre><code class="javascript">Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]
</code></pre>
<h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h5><p>用于将一组值，转换为数组</p>
<pre><code class="javascript">Array.of(3, 11, 8) // [3,11,8]
</code></pre>
<p>没有参数的时候，返回一个空数组</p>
<p>当参数只有一个的时候，实际上是指定数组的长度</p>
<p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p>
<pre><code class="javascript">Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
</code></pre>
<h4 id="三、实例对象新增的方法"><a href="#三、实例对象新增的方法" class="headerlink" title="三、实例对象新增的方法"></a>三、实例对象新增的方法</h4><p>关于数组实例对象新增的方法有如下：</p>
<ul>
<li>copyWithin()</li>
<li>find()、findIndex()</li>
<li>fill()</li>
<li>entries()，keys()，values()</li>
<li>includes()</li>
<li>flat()，flatMap()</li>
</ul>
<h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h5><p>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p>
<p>参数如下：</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<pre><code>[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2
// [4, 5, 3, 4, 5] 
</code></pre>
<h5 id="find-、findIndex"><a href="#find-、findIndex" class="headerlink" title="find()、findIndex()"></a>find()、findIndex()</h5><p><code>find()</code>用于找出第一个符合条件的数组成员</p>
<p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p>
<pre><code class="javascript">[1, 5, 10, 15].find(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 10
findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1
[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 2
</code></pre>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>
<pre><code class="javascript">function f(v)&#123;
  return v &gt; this.age;
&#125;
let person = &#123;name: &#39;John&#39;, age: 20&#125;;
[10, 12, 26, 15].find(f, person);    // 26
</code></pre>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p>使用给定值，填充一个数组</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre>
<p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
</code></pre>
<p>注意，如果填充的类型为对象，则是浅拷贝</p>
<h5 id="entries-，keys-，values"><a href="#entries-，keys-，values" class="headerlink" title="entries()，keys()，values()"></a>entries()，keys()，values()</h5><p><code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历</p>
<pre><code class="javascript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;
  console.log(index);
&#125;
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;
  console.log(elem);
&#125;
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;
  console.log(index, elem);
&#125;
// 0 &quot;a&quot;
</code></pre>
<h5 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h5><p>用于判断数组是否包含给定的值</p>
<pre><code class="javascript">[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
</code></pre>
<p>方法的第二个参数表示搜索的起始位置，默认为<code>0</code></p>
<p>参数为负数则表示倒数的位置</p>
<pre><code class="javascript">[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</code></pre>
<h5 id="flat-，flatMap"><a href="#flat-，flatMap" class="headerlink" title="flat()，flatMap()"></a>flat()，flatMap()</h5><p>将数组扁平化处理，返回一个新数组，对原数据没有影响</p>
<pre><code class="javascript">[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
</code></pre>
<p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1</p>
<pre><code class="javascript">[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
</code></pre>
<p><code>flatMap()</code>方法对原数组的每个成员执行一个函数相当于执行<code>Array.prototype.map()</code>，然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组</p>
<pre><code class="javascript">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) =&gt; [x, x * 2])
// [2, 4, 3, 6, 4, 8]
flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this
</code></pre>
<h4 id="四、数组的空位"><a href="#四、数组的空位" class="headerlink" title="四、数组的空位"></a>四、数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值</p>
<p>ES6 则是明确将空位转为<code>undefined</code>，包括<code>Array.from</code>、扩展运算符、<code>copyWithin()</code>、<code>fill()</code>、<code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code></p>
<p>建议大家在日常书写中，避免出现空位</p>
<h4 id="五、排序稳定性"><a href="#五、排序稳定性" class="headerlink" title="五、排序稳定性"></a>五、排序稳定性</h4><p>将<code>sort()</code>默认设置为稳定的排序算法</p>
<pre><code class="javascript">const arr = [
  &#39;peach&#39;,
  &#39;straw&#39;,
  &#39;apple&#39;,
  &#39;spork&#39;
];

const stableSorting = (s1, s2) =&gt; &#123;
  if (s1[0] &lt; s2[0]) return -1;
  return 1;
&#125;;

arr.sort(stableSorting)
// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]
</code></pre>
<p>排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中对象新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中对象新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中对象新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中对象新增了哪些扩展?</h3><h4 id="一、属性的简写"><a href="#一、属性的简写" class="headerlink" title="一、属性的简写"></a>一、属性的简写</h4><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写</p>
<pre><code class="javascript">const baz = &#123;foo:foo&#125;

// 等同于
const baz = &#123;foo&#125;
</code></pre>
<p>方法也能够进行简写</p>
<pre><code class="javascript">const o = &#123;
  method() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;;

// 等同于

const o = &#123;
  method: function() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;
</code></pre>
<p>在函数内作为返回值，也会变得方便很多</p>
<pre><code class="javascript">function getPoint() &#123;
  const x = 1;
  const y = 10;
  return &#123;x, y&#125;;
&#125;

getPoint()
// &#123;x:1, y:10&#125;
</code></pre>
<p>注意：简写的对象方法不能用作构造函数，否则会报错</p>
<pre><code class="javascript">const obj = &#123;
  f() &#123;
    this.foo = &#39;bar&#39;;
  &#125;
&#125;;

new obj.f() // 报错
</code></pre>
<h4 id="二、属性名表达式"><a href="#二、属性名表达式" class="headerlink" title="二、属性名表达式"></a>二、属性名表达式</h4><p>ES6 允许字面量定义对象时，将表达式放在括号内</p>
<pre><code class="javascript">let lastWord = &#39;last word&#39;;

const a = &#123;
  &#39;first word&#39;: &#39;hello&#39;,
  [lastWord]: &#39;world&#39;
&#125;;

a[&#39;first word&#39;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&#39;last word&#39;] // &quot;world&quot;
</code></pre>
<p>表达式还可以用于定义方法名</p>
<pre><code class="javascript">let obj = &#123;
  [&#39;h&#39; + &#39;ello&#39;]() &#123;
    return &#39;hi&#39;;
  &#125;
&#125;;

obj.hello() // hi
</code></pre>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错</p>
<pre><code class="javascript">// 报错
const foo = &#39;bar&#39;;
const bar = &#39;abc&#39;;
const baz = &#123; [foo] &#125;;

// 正确
const foo = &#39;bar&#39;;
const baz = &#123; [foo]: &#39;abc&#39;&#125;;
</code></pre>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code></p>
<pre><code class="javascript">const keyA = &#123;a: 1&#125;;
const keyB = &#123;b: 2&#125;;

const myObject = &#123;
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
&#125;;

myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;
</code></pre>
<h4 id="三、super关键字"><a href="#三、super关键字" class="headerlink" title="三、super关键字"></a>三、super关键字</h4><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象</p>
<pre><code class="javascript">const proto = &#123;
  foo: &#39;hello&#39;
&#125;;

const obj = &#123;
  foo: &#39;world&#39;,
  find() &#123;
    return super.foo;
  &#125;
&#125;;

Object.setPrototypeOf(obj, proto); // 为obj设置原型对象
obj.find() // &quot;hello&quot;
</code></pre>
<h4 id="四、扩展运算符的应用"><a href="#四、扩展运算符的应用" class="headerlink" title="四、扩展运算符的应用"></a>四、扩展运算符的应用</h4><p>在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面</p>
<pre><code class="javascript">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;
x // 1
y // 2
z // &#123; a: 3, b: 4 &#125;
</code></pre>
<p>注意：解构赋值必须是最后一个参数，否则会报错</p>
<p>解构赋值是浅拷贝</p>
<pre><code class="javascript">let obj = &#123; a: &#123; b: 1 &#125; &#125;;
let &#123; ...x &#125; = obj;
obj.a.b = 2; // 修改obj里面a属性中键值
x.a.b // 2，影响到了结构出来x的值
</code></pre>
<p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法</p>
<h4 id="五、属性的遍历"><a href="#五、属性的遍历" class="headerlink" title="五、属性的遍历"></a>五、属性的遍历</h4><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<ul>
<li>for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li>
<li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li>
<li>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li>
<li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</li>
<li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li>
</ul>
<p>上述遍历，都遵守同样的属性遍历的次序规则：</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排</li>
</ul>
<pre><code class="javascript">Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)
// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]
</code></pre>
<h4 id="六、对象新增的方法"><a href="#六、对象新增的方法" class="headerlink" title="六、对象新增的方法"></a>六、对象新增的方法</h4><p>关于对象新增的方法，分别有以下：</p>
<ul>
<li>Object.is()</li>
<li>Object.assign()</li>
<li>Object.getOwnPropertyDescriptors()</li>
<li>Object.setPrototypeOf()，Object.getPrototypeOf()</li>
<li>Object.keys()，Object.values()，Object.entries()</li>
<li>Object.fromEntries()</li>
</ul>
<h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><p>严格判断两个值是否相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致，不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</p>
<pre><code class="javascript">+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><pre><code class="javascript">Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target
</code></pre>
<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象</p>
<pre><code class="javascript">const target = &#123; a: 1, b: 1 &#125;;

const source1 = &#123; b: 2, c: 2 &#125;;
const source2 = &#123; c: 3 &#125;;

Object.assign(target, source1, source2);
target // &#123;a:1, b:2, c:3&#125;
</code></pre>
<p>注意：<code>Object.assign()</code>方法是浅拷贝，遇到同名属性会进行替换</p>
<h5 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h5><p>返回指定对象所有自身属性（非继承属性）的描述对象</p>
<pre><code class="javascript">const obj = &#123;
  foo: 123,
  get bar() &#123; return &#39;abc&#39; &#125;
&#125;;

Object.getOwnPropertyDescriptors(obj)
// &#123; foo:
//    &#123; value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true &#125;,
//   bar:
//    &#123; get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true &#125; &#125;
</code></pre>
<h5 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h5><p><code>Object.setPrototypeOf</code>方法用来设置一个对象的原型对象</p>
<pre><code class="javascript">Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf(&#123;&#125;, null);
</code></pre>
<h5 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h5><p>用于读取一个对象的原型对象</p>
<pre><code class="javascript">Object.getPrototypeOf(obj);
</code></pre>
<h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组</p>
<pre><code class="javascript">var obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre>
<h5 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h5><p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组</p>
<pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.values(obj)
// [&quot;bar&quot;, 42]
</code></pre>
<h5 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h5><p>返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组</p>
<pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
</code></pre>
<h5 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h5><p>用于将一个键值对数组转为对象</p>
<pre><code class="javascript">Object.fromEntries([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
])
// &#123; foo: &quot;bar&quot;, baz: 42 &#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中函数新增了哪些扩展"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中函数新增了哪些扩展" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中函数新增了哪些扩展?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中函数新增了哪些扩展?</h3><h4 id="一、参数"><a href="#一、参数" class="headerlink" title="一、参数"></a>一、参数</h4><p><code>ES6</code>允许为函数的参数设置默认值</p>
<pre><code class="javascript">function log(x, y = &#39;World&#39;) &#123;
  console.log(x, y);
&#125;

console.log(&#39;Hello&#39;) // Hello World
console.log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
console.log(&#39;Hello&#39;, &#39;&#39;) // Hello
</code></pre>
<p>函数的形参是默认声明的，不能使用<code>let</code>或<code>const</code>再次声明</p>
<pre><code class="javascript">function foo(x = 5) &#123;
    let x = 1; // error
    const x = 2; // error
&#125;
</code></pre>
<p>参数默认值可以与解构赋值的默认值结合起来使用</p>
<pre><code class="javascript">function foo(&#123;x, y = 5&#125;) &#123;
  console.log(x, y);
&#125;

foo(&#123;&#125;) // undefined 5
foo(&#123;x: 1&#125;) // 1 5
foo(&#123;x: 1, y: 2&#125;) // 1 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined
</code></pre>
<p>上面的<code>foo</code>函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量<code>x</code>和<code>y</code>就不会生成，从而报错，这里设置默认值避免</p>
<pre><code class="javascript">function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;
  console.log(x, y);
&#125;

foo() // undefined 5
</code></pre>
<p>参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的</p>
<pre><code class="javascript">function f(x = 1, y) &#123;
  return [x, y];
&#125;

f() // [1, undefined]
f(2) // [2, undefined]
f(, 1) // 报错
f(undefined, 1) // [1, 1]
</code></pre>
<h4 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h4><h5 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h5><p><code>length</code>将返回没有指定默认值的参数个数</p>
<pre><code class="javascript">(function (a) &#123;&#125;).length // 1
(function (a = 5) &#123;&#125;).length // 0
(function (a, b, c = 5) &#123;&#125;).length // 2
</code></pre>
<p><code>rest</code> 参数也不会计入<code>length</code>属性</p>
<pre><code class="javascript">(function(...args) &#123;&#125;).length // 0
</code></pre>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</p>
<pre><code class="javascript">(function (a = 0, b, c) &#123;&#125;).length // 0
(function (a, b = 1, c) &#123;&#125;).length // 1
</code></pre>
<h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><p>返回该函数的函数名</p>
<pre><code class="javascript">var f = function () &#123;&#125;;

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;
</code></pre>
<p>如果将一个具名函数赋值给一个变量，则 <code>name</code>属性都返回这个具名函数原本的名字</p>
<pre><code class="javascript">const bar = function baz() &#123;&#125;;
bar.name // &quot;baz&quot;
Function`构造函数返回的函数实例，`name`属性的值为`anonymous
(new Function).name // &quot;anonymous&quot;
</code></pre>
<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀</p>
<pre><code class="javascript">function foo() &#123;&#125;;
foo.bind(&#123;&#125;).name // &quot;bound foo&quot;

(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;
</code></pre>
<h4 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</p>
<p>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p>
<p>下面例子中，<code>y=x</code>会形成一个单独作用域，<code>x</code>没有被定义，所以指向全局变量<code>x</code></p>
<pre><code class="javascript">let x = 1;

function f(y = x) &#123; 
  // 等同于 let y = x  
  let x = 2; 
  console.log(y);
&#125;

f() // 1
</code></pre>
<h4 id="四、严格模式"><a href="#四、严格模式" class="headerlink" title="四、严格模式"></a>四、严格模式</h4><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p>
<pre><code class="javascript">// 报错
function doSomething(a, b = a) &#123;
  &#39;use strict&#39;;
  // code
&#125;

// 报错
const doSomething = function (&#123;a, b&#125;) &#123;
  &#39;use strict&#39;;
  // code
&#125;;

// 报错
const doSomething = (...a) =&gt; &#123;
  &#39;use strict&#39;;
  // code
&#125;;

const obj = &#123;
  // 报错
  doSomething(&#123;a, b&#125;) &#123;
    &#39;use strict&#39;;
    // code
  &#125;
&#125;;
</code></pre>
<h4 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h4><p>使用“箭头”（<code>=&gt;</code>）定义函数</p>
<pre><code class="javascript">var f = v =&gt; v;

// 等同于
var f = function (v) &#123;
  return v;
&#125;;
</code></pre>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</p>
<pre><code class="javascript">var f = () =&gt; 5;
// 等同于
var f = function () &#123; return 5 &#125;;

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) &#123;
  return num1 + num2;
&#125;;
</code></pre>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回</p>
<pre><code class="javascript">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;
</code></pre>
<p>如果返回对象，需要加括号将对象包裹</p>
<pre><code class="javascript">let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);
</code></pre>
<p>注意点：</p>
<ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-ES6中新增的Set、Map两种数据结构怎么理解"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-ES6中新增的Set、Map两种数据结构怎么理解" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中新增的Set、Map两种数据结构怎么理解?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ ES6中新增的Set、Map两种数据结构怎么理解?</h3><p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p>
<p>什么是集合？什么又是字典？</p>
<ul>
<li>集合<br>是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</li>
<li>字典<br>是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</li>
</ul>
<p>区别？</p>
<ul>
<li>共同点：集合、字典都可以存储不重复的值</li>
<li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li>
</ul>
<h4 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h4><p><code>Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</p>
<pre><code>const s = new Set();
</code></pre>
<h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><p><code>Set</code>的实例关于增删改查的方法：</p>
<ul>
<li>add()</li>
<li>delete()</li>
<li>has()</li>
<li>clear()</li>
</ul>
<h6 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h6><p>添加某个值，返回 <code>Set</code> 结构本身</p>
<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>
<pre><code>s.add(1).add(2).add(2); // 2只被添加了一次
</code></pre>
<h6 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h6><p>删除某个值，返回一个布尔值，表示删除是否成功</p>
<pre><code>s.delete(1)
</code></pre>
<h6 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h6><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>
<pre><code>s.has(2)
</code></pre>
<h6 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h6><p>清除所有成员，没有返回值</p>
<pre><code>s.clear()
</code></pre>
<h6 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h6><p><code>Set</code>实例遍历的方法有如下：</p>
<p>关于遍历的方法，有如下：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<p><code>Set</code>的遍历顺序就是插入顺序</p>
<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象</p>
<pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

for (let item of set.keys()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.values()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.entries()) &#123;
  console.log(item);
&#125;
// [&quot;red&quot;, &quot;red&quot;]
// [&quot;green&quot;, &quot;green&quot;]
// [&quot;blue&quot;, &quot;blue&quot;]
forEach()`用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的`forEach`方法有第二个参数，用于绑定处理函数的`this
let set = new Set([1, 4, 9]);
set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
// 1 : 1
// 4 : 4
// 9 : 9
</code></pre>
<p>扩展运算符和<code> Set</code> 结构相结合实现数组或字符串去重</p>
<pre><code class="javascript">// 数组
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)]; // [3, 5, 2]

// 字符串
let str = &quot;352255&quot;;
let unique = [...new Set(str)].join(&quot;&quot;); // &#39;352&#39;
</code></pre>
<p>实现并集、交集、和差集</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<h4 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h4><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>
<p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p>
<pre><code class="javascript">const m = new Map()
</code></pre>
<h5 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h5><p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p>
<ul>
<li>size 属性</li>
<li>set()</li>
<li>get()</li>
<li>has()</li>
<li>delete()</li>
<li>clear()</li>
</ul>
<h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><p><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="javascript">const map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
</code></pre>
<h6 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h6><p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p>
<p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p>
<p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p>
<pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6)        // 键是字符串
m.set(262, &#39;standard&#39;)     // 键是数值
m.set(undefined, &#39;nah&#39;)    // 键是 undefined
m.set(1, &#39;a&#39;).set(2, &#39;b&#39;).set(3, &#39;c&#39;) // 链式操作
</code></pre>
<h6 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h6><pre><code class="javascript">get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined
const m = new Map();

const hello = function() &#123;console.log(&#39;hello&#39;);&#125;;
m.set(hello, &#39;Hello ES6!&#39;) // 键是函数

m.get(hello)  // Hello ES6!
</code></pre>
<h6 id="has-1"><a href="#has-1" class="headerlink" title="has()"></a>has()</h6><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p>
<pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6);
m.set(262, &#39;standard&#39;);
m.set(undefined, &#39;nah&#39;);

m.has(&#39;edition&#39;)     // true
m.has(&#39;years&#39;)       // false
m.has(262)           // true
m.has(undefined)     // true
</code></pre>
<h6 id="delete-1"><a href="#delete-1" class="headerlink" title="delete()"></a>delete()</h6><pre><code class="javascript">delete`方法删除某个键，返回`true`。如果删除失败，返回`false
const m = new Map();
m.set(undefined, &#39;nah&#39;);
m.has(undefined)     // true

m.delete(undefined)
m.has(undefined)       // false
</code></pre>
<h6 id="clear-1"><a href="#clear-1" class="headerlink" title="clear()"></a>clear()</h6><p><code>clear</code>方法清除所有成员，没有返回值</p>
<pre><code class="javascript">let map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
map.clear()
map.size // 0
</code></pre>
<h6 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h6><p><code>Map </code>结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回所有成员的遍历器</li>
<li>forEach()：遍历 Map 的所有成员</li>
</ul>
<p>遍历顺序就是插入顺序</p>
<pre><code class="javascript">const map = new Map([
  [&#39;F&#39;, &#39;no&#39;],
  [&#39;T&#39;,  &#39;yes&#39;],
]);

for (let key of map.keys()) &#123;
  console.log(key);
&#125;
// &quot;F&quot;
// &quot;T&quot;

for (let value of map.values()) &#123;
  console.log(value);
&#125;
// &quot;no&quot;
// &quot;yes&quot;

for (let item of map.entries()) &#123;
  console.log(item[0], item[1]);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 或者
for (let [key, value] of map.entries()) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 等同于使用map.entries()
for (let [key, value] of map) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

map.forEach(function(value, key, map) &#123;
  console.log(&quot;Key: %s, Value: %s&quot;, key, value);
&#125;);
</code></pre>
<h4 id="三、WeakSet-和-WeakMap"><a href="#三、WeakSet-和-WeakMap" class="headerlink" title="三、WeakSet 和 WeakMap"></a>三、WeakSet 和 WeakMap</h4><h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>创建<code>WeakSet</code>实例</p>
<pre><code class="javascript">const ws = new WeakSet();
</code></pre>
<p><code>WeakSet </code>可以接受一个具有 <code>Iterable </code>接口的对象作为参数</p>
<pre><code class="javascript">const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet &#123;[1, 2], [3, 4]&#125;
</code></pre>
<p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>size</code>属性</li>
</ul>
<p><code>WeackSet</code>只能成员只能是引用类型，而不能是其他类型的值</p>
<pre><code class="javascript">let ws=new WeakSet();

// 成员不是引用类型
let weakSet=new WeakSet([2,3]);
console.log(weakSet) // 报错

// 成员为引用类型
let obj1=&#123;name:1&#125;
let obj2=&#123;name:1&#125;
let ws=new WeakSet([obj1,obj2]); 
console.log(ws) //WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125;
</code></pre>
<p><code>WeakSet </code>里面的引用只要在外部消失，它在 <code>WeakSet </code>里面的引用就会自动消失</p>
<h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p>
<p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>clear</code>清空方法</li>
</ul>
<pre><code class="javascript">// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = &#123;foo: 1&#125;;
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]);
wm2.get(k2) // &quot;bar&quot;
</code></pre>
<p><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p>
<pre><code class="javascript">const map = new WeakMap();
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
</code></pre>
<p><code>WeakMap</code>的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p>
<p>举个场景例子：</p>
<p>在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构，当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除</p>
<pre><code class="javascript">const wm = new WeakMap();
const element = document.getElementById(&#39;example&#39;);
wm.set(element, &#39;some information&#39;);
wm.get(element) // &quot;some information&quot;
</code></pre>
<p>注意：<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用</p>
<p>下面代码中，键值<code>obj</code>会在<code>WeakMap</code>产生新的引用，当你修改<code>obj</code>不会影响到内部</p>
<pre><code class="javascript">const wm = new WeakMap();
let key = &#123;&#125;;
let obj = &#123;foo: 1&#125;;

wm.set(key, obj);
obj = null;
wm.get(key)
// Object &#123;foo: 1&#125;
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-你是怎么理解ES6中-Promise的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-你是怎么理解ES6中-Promise的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 你是怎么理解ES6中 Promise的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 你是怎么理解ES6中 Promise的？使用场景？</h3><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p><code>Promise </code>，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p>
<p>在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码</p>
<pre><code class="javascript">doSomething(function(result) &#123;
  doSomethingElse(result, function(newResult) &#123;
    doThirdThing(newResult, function(finalResult) &#123;
      console.log(&#39;得到最终结果: &#39; + finalResult);
    &#125;, failureCallback);
  &#125;, failureCallback);
&#125;, failureCallback);
</code></pre>
<p>阅读上面代码，是不是很难受，上述形成了经典的回调地狱</p>
<p>现在通过<code>Promise</code>的改写上面的代码</p>
<pre><code class="javascript">doSomething().then(function(result) &#123;
  return doSomethingElse(result);
&#125;)
.then(function(newResult) &#123;
  return doThirdThing(newResult);
&#125;)
.then(function(finalResult) &#123;
  console.log(&#39;得到最终结果: &#39; + finalResult);
&#125;)
.catch(failureCallback);
</code></pre>
<p>瞬间感受到<code>promise</code>解决异步操作的优点：</p>
<ul>
<li>链式操作减低了编码难度</li>
<li>代码可读性明显增强</li>
</ul>
<p>下面我们正式来认识<code>promise</code>：</p>
<h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p><code>promise</code>对象仅有三种状态</p>
<ul>
<li><code>pending</code>（进行中）</li>
<li><code>fulfilled</code>（已成功）</li>
<li><code>rejected</code>（已失败）</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li>
<li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li>
</ul>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>认真阅读下图，我们能够轻松了解<code>promise</code>整个流程</p>
<p><img src="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31623032616539302d353861392d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例</p>
<pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;&#125;);
Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject
</code></pre>
<ul>
<li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li>
<li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”</li>
</ul>
<h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><p><code>Promise</code>构建出来的实例存在以下方法：</p>
<ul>
<li>then()</li>
<li>catch()</li>
<li>finally()</li>
</ul>
<h6 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h6><p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因</p>
<pre><code class="javascript">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  return json.post;
&#125;).then(function(post) &#123;
  // ...
&#125;);
</code></pre>
<h6 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h6><p><code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</p>
<pre><code class="javascript">getJSON(&#39;/posts.json&#39;).then(function(posts) &#123;
  // ...
&#125;).catch(function(error) &#123;
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&#39;发生错误！&#39;, error);
&#125;);
</code></pre>
<p><code>Promise </code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p>
<pre><code class="javascript">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;
  return getJSON(post.commentURL);
&#125;).then(function(comments) &#123;
  // some code
&#125;).catch(function(error) &#123;
  // 处理前面三个Promise产生的错误
&#125;);
</code></pre>
<p>一般来说，使用<code>catch</code>方法代替<code>then()</code>第二个参数</p>
<p><code>Promise </code>对象抛出的错误不会传递到外层代码，即不会有任何反应</p>
<pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;
</code></pre>
<p>浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程</p>
<p><code>catch()</code>方法之中，还能再抛出错误，通过后面<code>catch</code>方法捕获到</p>
<h6 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h6><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p>
<pre><code class="javascript">promise
.then(result =&gt; &#123;···&#125;)
.catch(error =&gt; &#123;···&#125;)
.finally(() =&gt; &#123;···&#125;);
</code></pre>
<h5 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h5><p><code>Promise</code>构造函数存在以下方法：</p>
<ul>
<li>all()</li>
<li>race()</li>
<li>allSettled()</li>
<li>resolve()</li>
<li>reject()</li>
<li>try()</li>
</ul>
<h6 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h6><p><code>Promise.all()</code>方法用于将多个 <code>Promise </code>实例，包装成一个新的 <code>Promise </code>实例</p>
<pre><code class="javascript">const p = Promise.all([p1, p2, p3]);
</code></pre>
<p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p>
<p>实例<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分为两种：</p>
<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li>
</ul>
<p>注意，如果作为参数的 <code>Promise</code> 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法</p>
<pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// Error: 报错了
</code></pre>
<h6 id="race"><a href="#race" class="headerlink" title="race()"></a>race()</h6><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p>
<pre><code class="javascript">const p = Promise.race([p1, p2, p3]);
</code></pre>
<p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变</p>
<p>率先改变的 Promise 实例的返回值则传递给<code>p</code>的回调函数</p>
<pre><code class="javascript">const p = Promise.race([
  fetch(&#39;/resource-that-may-take-a-while&#39;),
  new Promise(function (resolve, reject) &#123;
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)
  &#125;)
]);

p
.then(console.log)
.catch(console.error);
</code></pre>
<h6 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled()"></a>allSettled()</h6><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p>
<p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束</p>
<pre><code class="javascript">const promises = [
  fetch(&#39;/api-1&#39;),
  fetch(&#39;/api-2&#39;),
  fetch(&#39;/api-3&#39;),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
</code></pre>
<h6 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a>resolve()</h6><p>将现有对象转为 <code>Promise </code>对象</p>
<pre><code class="javascript">Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))
</code></pre>
<p>参数可以分成四种情况，分别如下：</p>
<ul>
<li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li>
<li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise </code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li>
<li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li>
<li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li>
</ul>
<h6 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h6><pre><code class="javascript">Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected
const p = Promise.reject(&#39;出错了&#39;);
// 等同于
const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))

p.then(null, function (s) &#123;
  console.log(s)
&#125;);
// 出错了
</code></pre>
<p><code>Promise.reject()</code>方法的参数，会原封不动地变成后续方法的参数</p>
<pre><code class="javascript">Promise.reject(&#39;出错了&#39;)
.catch(e =&gt; &#123;
  console.log(e === &#39;出错了&#39;)
&#125;)
// true
</code></pre>
<h4 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化</p>
<pre><code class="javascript">const preloadImage = function (path) &#123;
  return new Promise(function (resolve, reject) &#123;
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  &#125;);
&#125;;
</code></pre>
<p>通过链式操作，将多个渲染数据分别给个<code>then</code>，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题</p>
<pre><code class="javascript">// 各司其职
getInfo().then(res=&gt;&#123;
    let &#123; bannerList &#125; = res
    //渲染轮播图
    console.log(bannerList)
    return res
&#125;).then(res=&gt;&#123;
    
    let &#123; storeList &#125; = res
    //渲染店铺列表
    console.log(storeList)
    return res
&#125;).then(res=&gt;&#123;
    let &#123; categoryList &#125; = res
    console.log(categoryList)
    //渲染分类列表
    return res
&#125;)
</code></pre>
<p>通过<code>all()</code>实现多个请求合并在一起，汇总所有请求结果，只需设置一个<code>loading</code>即可</p>
<pre><code class="javascript">function initLoad()&#123;
    // loading.show() //加载loading
    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=&gt;&#123;
        console.log(res)
        loading.hide() //关闭loading
    &#125;).catch(err=&gt;&#123;
        console.log(err)
        loading.hide()//关闭loading
    &#125;)
&#125;
//数据初始化    
initLoad()
</code></pre>
<p>通过<code>race</code>可以设置图片请求超时</p>
<pre><code class="javascript">//请求某个图片资源
function requestImg()&#123;
    var p = new Promise(function(resolve, reject)&#123;
        var img = new Image();
        img.onload = function()&#123;
           resolve(img);
        &#125;
        //img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的
        img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;;
    &#125;);
    return p;
&#125;

//延时函数，用于给请求计时
function timeout()&#123;
    var p = new Promise(function(resolve, reject)&#123;
        setTimeout(function()&#123;
            reject(&#39;图片请求超时&#39;);
        &#125;, 5000);
    &#125;);
    return p;
&#125;

Promise
.race([requestImg(), timeout()])
.then(function(results)&#123;
    console.log(results);
&#125;)
.catch(function(reason)&#123;
    console.log(reason);
&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Generator的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Generator的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Generator的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Generator的？使用场景？</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p>回顾下上文提到的解决异步的手段：</p>
<ul>
<li>回调函数</li>
<li>promise</li>
</ul>
<p>那么，上文我们提到<code>promsie</code>已经是一种比较流行的解决异步方案，那么为什么还出现<code>Generator</code>？甚至<code>async/await</code>呢？</p>
<p>该问题我们留在后面再进行分析，下面先认识下<code>Generator</code></p>
<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>执行 <code>Generator</code> 函数会返回一个遍历器对象，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p>
<p>形式上，<code>Generator </code>函数是一个普通函数，但是有两个特征：</p>
<ul>
<li><code>function</code>关键字与函数名之间有一个星号</li>
<li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态</li>
</ul>
<pre><code class="javascript">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
</code></pre>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p><code>Generator</code> 函数会返回一个遍历器对象，即具有<code>Symbol.iterator</code>属性，并且返回给自己</p>
<pre><code class="javascript">function* gen()&#123;
  // some code
&#125;

var g = gen();

g[Symbol.iterator]() === g
// true
</code></pre>
<p>通过<code>yield</code>关键字可以暂停<code>generator</code>函数返回的遍历器对象的状态</p>
<pre><code class="javascript">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
var hw = helloWorldGenerator();
</code></pre>
<p>上述存在三个状态：<code>hello</code>、<code>world</code>、<code>return</code></p>
<p>通过<code>next</code>方法才会遍历到下一个内部状态，其运行逻辑如下：</p>
<ul>
<li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</li>
<li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li>
</ul>
<pre><code class="javascript">hw.next()
// &#123; value: &#39;hello&#39;, done: false &#125;

hw.next()
// &#123; value: &#39;world&#39;, done: false &#125;

hw.next()
// &#123; value: &#39;ending&#39;, done: true &#125;

hw.next()
// &#123; value: undefined, done: true &#125;
</code></pre>
<p><code>done</code>用来判断是否存在下个状态，<code>value</code>对应状态值</p>
<pre><code class="javascript">yield`表达式本身没有返回值，或者说总是返回`undefined
</code></pre>
<p>通过调用<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值</p>
<pre><code class="javascript">function* foo(x) &#123;
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
&#125;

var a = foo(5);
a.next() // Object&#123;value:6, done:false&#125;
a.next() // Object&#123;value:NaN, done:false&#125;
a.next() // Object&#123;value:NaN, done:true&#125;

var b = foo(5);
b.next() // &#123; value:6, done:false &#125;
b.next(12) // &#123; value:8, done:false &#125;
b.next(13) // &#123; value:42, done:true &#125;
</code></pre>
<p>正因为<code>Generator </code>函数返回<code>Iterator</code>对象，因此我们还可以通过<code>for...of</code>进行遍历</p>
<pre><code class="javascript">function* foo() &#123;
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
&#125;

for (let v of foo()) &#123;
  console.log(v);
&#125;
// 1 2 3 4 5
</code></pre>
<p>原生对象没有遍历接口，通过<code>Generator </code>函数为它加上这个接口，就能使用<code>for...of</code>进行遍历了</p>
<pre><code class="javascript">function* objectEntries(obj) &#123;
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) &#123;
    yield [propKey, obj[propKey]];
  &#125;
&#125;

let jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;

for (let [key, value] of objectEntries(jane)) &#123;
  console.log(`$&#123;key&#125;: $&#123;value&#125;`);
&#125;
// first: Jane
// last: Doe
</code></pre>
<h4 id="三、异步解决方案"><a href="#三、异步解决方案" class="headerlink" title="三、异步解决方案"></a>三、异步解决方案</h4><p>回顾之前展开异步解决的方案：</p>
<ul>
<li>回调函数</li>
<li>Promise 对象</li>
<li>generator 函数</li>
<li>async&#x2F;await</li>
</ul>
<p>这里通过文件读取案例，将几种解决异步的方案进行一个比较：</p>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数</p>
<pre><code class="javascript">fs.readFile(&#39;/etc/fstab&#39;, function (err, data) &#123;
  if (err) throw err;
  console.log(data);
  fs.readFile(&#39;/etc/shells&#39;, function (err, data) &#123;
    if (err) throw err;
    console.log(data);
  &#125;);
&#125;);
</code></pre>
<p><code>readFile</code>函数的第三个参数，就是回调函数，等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行</p>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p><code>Promise</code>就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;);

const readFile = function (fileName) &#123;
  return new Promise(function (resolve, reject) &#123;
    fs.readFile(fileName, function(error, data) &#123;
      if (error) return reject(error);
      resolve(data);
    &#125;);
  &#125;);
&#125;;


readFile(&#39;/etc/fstab&#39;).then(data =&gt;&#123;
    console.log(data)
    return readFile(&#39;/etc/shells&#39;)
&#125;).then(data =&gt; &#123;
    console.log(data)
&#125;)
</code></pre>
<p>这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强</p>
<h5 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h5><p><code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化</p>
<pre><code class="javascript">const gen = function* () &#123;
  const f1 = yield readFile(&#39;/etc/fstab&#39;);
  const f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<h5 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h5><p>将上面<code>Generator</code>函数改成<code>async/await</code>形式，更为简洁，语义化更强了</p>
<pre><code class="javascript">const asyncReadFile = async function () &#123;
  const f1 = await readFile(&#39;/etc/fstab&#39;);
  const f2 = await readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><p>通过上述代码进行分析，将<code>promise</code>、<code>Generator</code>、<code>async/await</code>进行比较：</p>
<ul>
<li><code>promise</code>和<code>async/await</code>是专门用于处理异步操作的</li>
<li><code>Generator</code>并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署<code>Interator</code>接口…）</li>
<li><code>promise</code>编写代码相比<code>Generator</code>、<code>async</code>更为复杂化，且可读性也稍差</li>
<li><code>Generator</code>、<code>async</code>需要与<code>promise</code>对象搭配处理异步情况</li>
<li><code>async</code>实质是<code>Generator</code>的语法糖，相当于会自动执行<code>Generator</code>函数</li>
<li><code>async</code>使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案</li>
</ul>
<h4 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h4><p><code>Generator</code>是异步解决的一种方案，最大特点则是将异步操作同步化表达出来</p>
<pre><code class="javascript">function* loadUI() &#123;
  showLoadingScreen();
  yield loadUIDataAsynchronously();
  hideLoadingScreen();
&#125;
var loader = loadUI();
// 加载UI
loader.next()

// 卸载UI
loader.next()
</code></pre>
<p>包括<code>redux-saga </code>中间件也充分利用了<code>Generator</code>特性</p>
<pre><code class="javascript">import &#123; call, put, takeEvery, takeLatest &#125; from &#39;redux-saga/effects&#39;
import Api from &#39;...&#39;

function* fetchUser(action) &#123;
   try &#123;
      const user = yield call(Api.fetchUser, action.payload.userId);
      yield put(&#123;type: &quot;USER_FETCH_SUCCEEDED&quot;, user: user&#125;);
   &#125; catch (e) &#123;
      yield put(&#123;type: &quot;USER_FETCH_FAILED&quot;, message: e.message&#125;);
   &#125;
&#125;

function* mySaga() &#123;
  yield takeEvery(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);
&#125;

function* mySaga() &#123;
  yield takeLatest(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);
&#125;

export default mySaga;
</code></pre>
<p>还能利用<code>Generator</code>函数，在对象上实现<code>Iterator</code>接口</p>
<pre><code class="javascript">function* iterEntries(obj) &#123;
  let keys = Object.keys(obj);
  for (let i=0; i &lt; keys.length; i++) &#123;
    let key = keys[i];
    yield [key, obj[key]];
  &#125;
&#125;

let myObj = &#123; foo: 3, bar: 7 &#125;;

for (let [key, value] of iterEntries(myObj)) &#123;
  console.log(key, value);
&#125;

// foo 3
// bar 7
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Proxy的？使用场景"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Proxy的？使用场景" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Proxy的？使用场景?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Proxy的？使用场景?</h3><p>定义： 用于定义基本操作的自定义行为</p>
<p>本质： 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程<code>(meta programming)</code></p>
<p>元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作</p>
<p>一段代码来理解</p>
<pre><code class="c">#!/bin/bash
# metaprogram
echo &#39;#!/bin/bash&#39; &gt;program
for ((I=1; I&lt;=1024; I++)) do
    echo &quot;echo $I&quot; &gt;&gt;program
done
chmod +x program
</code></pre>
<p>这段程序每执行一次能帮我们生成一个名为<code>program</code>的文件，文件内容为1024行<code>echo</code>，如果我们手动来写1024行代码，效率显然低效</p>
<ul>
<li>元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译</li>
</ul>
<p><code>Proxy</code> 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）</p>
<h4 id="二、用法-1"><a href="#二、用法-1" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Proxy</code>为 构造函数，用来生成 <code>Proxy </code>实例</p>
<pre><code class="javascript">var proxy = new Proxy(target, handler)
</code></pre>
<p>参数</p>
<p><code>target</code>表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））</p>
<p><code>handler</code>通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为</p>
<p>handler解析</p>
<p>关于<code>handler</code>拦截属性，有如下：</p>
<ul>
<li>get(target,propKey,receiver)：拦截对象属性的读取</li>
<li>set(target,propKey,value,receiver)：拦截对象属性的设置</li>
<li>has(target,propKey)：拦截<code>propKey in proxy</code>的操作，返回一个布尔值</li>
<li>deleteProperty(target,propKey)：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值</li>
<li>ownKeys(target)：拦截<code>Object.keys(proxy)</code>、<code>for...in</code>等循环，返回一个数组</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象</li>
<li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>，返回一个布尔值</li>
<li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值</li>
<li>getPrototypeOf(target)：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象</li>
<li>isExtensible(target)：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值</li>
<li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作</li>
</ul>
<p>Reflect</p>
<p>若需要在<code>Proxy</code>内部调用对象的默认行为，建议使用<code>Reflect</code>，其是<code>ES6</code>中操作对象而提供的新 <code>API</code></p>
<p>基本特点：</p>
<ul>
<li>只要<code>Proxy</code>对象具有的代理方法，<code>Reflect</code>对象全部具有，以静态方法的形式存在</li>
<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回<code>false</code>）</li>
<li>让<code>Object</code>操作都变成函数行为</li>
</ul>
<p>下面我们介绍<code>proxy</code>几种用法：</p>
<h5 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h5><p><code>get</code>接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身，最后一个参数可选</p>
<pre><code class="javascript">var person = &#123;
  name: &quot;张三&quot;
&#125;;

var proxy = new Proxy(person, &#123;
  get: function(target, propKey) &#123;
    return Reflect.get(target,propKey)
  &#125;
&#125;);

proxy.name // &quot;张三&quot;
</code></pre>
<p><code>get</code>能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引</p>
<pre><code class="javascript">function createArray(...elements) &#123;
  let handler = &#123;
    get(target, propKey, receiver) &#123;
      let index = Number(propKey);
      if (index &lt; 0) &#123;
        propKey = String(target.length + index);
      &#125;
      return Reflect.get(target, propKey, receiver);
    &#125;
  &#125;;

  let target = [];
  target.push(...elements);
  return new Proxy(target, handler);
&#125;

let arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
arr[-1] // c
</code></pre>
<p>注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错</p>
<pre><code class="javascript">const target = Object.defineProperties(&#123;&#125;, &#123;
  foo: &#123;
    value: 123,
    writable: false,
    configurable: false
  &#125;,
&#125;);

const handler = &#123;
  get(target, propKey) &#123;
    return &#39;abc&#39;;
  &#125;
&#125;;

const proxy = new Proxy(target, handler);

proxy.foo
// TypeError: Invariant check failed
</code></pre>
<h5 id="set-1"><a href="#set-1" class="headerlink" title="set()"></a>set()</h5><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 <code>Proxy</code> 实例本身</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求</p>
<pre><code class="javascript">let validator = &#123;
  set: function(obj, prop, value) &#123;
    if (prop === &#39;age&#39;) &#123;
      if (!Number.isInteger(value)) &#123;
        throw new TypeError(&#39;The age is not an integer&#39;);
      &#125;
      if (value &gt; 200) &#123;
        throw new RangeError(&#39;The age seems invalid&#39;);
      &#125;
    &#125;

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  &#125;
&#125;;

let person = new Proxy(&#123;&#125;, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错
</code></pre>
<p>如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用</p>
<pre><code class="javascript">const obj = &#123;&#125;;
Object.defineProperty(obj, &#39;foo&#39;, &#123;
  value: &#39;bar&#39;,
  writable: false,
&#125;);

const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = &#39;baz&#39;;
  &#125;
&#125;;

const proxy = new Proxy(obj, handler);
proxy.foo = &#39;baz&#39;;
proxy.foo // &quot;bar&quot;
</code></pre>
<p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错</p>
<pre><code class="javascript">&#39;use strict&#39;;
const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;
</code></pre>
<h5 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h5><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除</p>
<pre><code class="javascript">var handler = &#123;
  deleteProperty (target, key) &#123;
    invariant(key, &#39;delete&#39;);
    Reflect.deleteProperty(target,key)
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`无法删除私有属性`);
  &#125;
&#125;

var target = &#123; _prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: 无法删除私有属性
</code></pre>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错</p>
<h5 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h5><pre><code class="javascript">Proxy.revocable(target, handler);
</code></pre>
<h4 id="三、使用场景-1"><a href="#三、使用场景-1" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p><code>Proxy</code>其功能非常类似于设计模式中的代理模式，常用功能如下：</p>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<p>使用 <code>Proxy</code> 保障数据类型的准确性</p>
<pre><code class="javascript">let numericDataStore = &#123; count: 0, amount: 1234, total: 14 &#125;;
numericDataStore = new Proxy(numericDataStore, &#123;
    set(target, key, value, proxy) &#123;
        if (typeof value !== &#39;number&#39;) &#123;
            throw Error(&quot;属性只能是number类型&quot;);
        &#125;
        return Reflect.set(target, key, value, proxy);
    &#125;
&#125;);

numericDataStore.count = &quot;foo&quot;
// Error: 属性只能是number类型

numericDataStore.count = 333
// 赋值成功
</code></pre>
<p>声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></p>
<pre><code class="javascript">let api = &#123;
    _apiKey: &#39;123abc456def&#39;,
    getUsers: function()&#123; &#125;,
    getUser: function(userId)&#123; &#125;,
    setUser: function(userId, config)&#123; &#125;
&#125;;
const RESTRICTED = [&#39;_apiKey&#39;];
api = new Proxy(api, &#123;
    get(target, key, proxy) &#123;
        if(RESTRICTED.indexOf(key) &gt; -1) &#123;
            throw Error(`$&#123;key&#125; 不可访问.`);
        &#125; return Reflect.get(target, key, proxy);
    &#125;,
    set(target, key, value, proxy) &#123;
        if(RESTRICTED.indexOf(key) &gt; -1) &#123;
            throw Error(`$&#123;key&#125; 不可修改`);
        &#125; return Reflect.get(target, key, value, proxy);
    &#125;
&#125;);

console.log(api._apiKey)
api._apiKey = &#39;987654321&#39;
// 上述都抛出错误
</code></pre>
<p>还能通过使用<code>Proxy</code>实现观察者模式</p>
<p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行</p>
<p><code>observable</code>函数返回一个原始对象的 <code>Proxy</code> 代理，拦截赋值操作，触发充当观察者的各个函数</p>
<pre><code class="javascript">const queuedObservers = new Set();

const observe = fn =&gt; queuedObservers.add(fn);
const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);

function set(target, key, value, receiver) &#123;
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer =&gt; observer());
  return result;
&#125;
</code></pre>
<p>观察者函数都放进<code>Set</code>集合，当修改<code>obj</code>的值，在会<code>set</code>函数中拦截，自动执行<code>Set</code>所有的观察者</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Module的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中Module的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Module的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中Module的？使用场景？</h3><h4 id="一、介绍-1"><a href="#一、介绍-1" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>模块，（Module），是能够单独命名并独立地完成一定功能的程序语句集合（即程序代码和数据结构的集合体）。</p>
<p>两个基本的特征：外部特征和内部</p>
<ul>
<li>外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能</li>
<li>内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）</li>
</ul>
<h5 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h5><ul>
<li>代码抽象</li>
<li>代码封装</li>
<li>代码复用</li>
<li>依赖管理</li>
</ul>
<p>如果没有模块化，我们代码会怎样？</p>
<ul>
<li>变量和方法不容易维护，容易污染全局作用域</li>
<li>加载资源的方式通过script标签从上到下。</li>
<li>依赖的环境主观逻辑偏重，代码较多就会比较复杂。</li>
<li>大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃</li>
</ul>
<p>因此，需要一种将<code>JavaScript</code>程序模块化的机制，如</p>
<ul>
<li>CommonJs (典型代表：node.js早期)</li>
<li>AMD (典型代表：require.js)</li>
<li>CMD (典型代表：sea.js)</li>
</ul>
<h5 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h5><p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p>
<p>代表库为<code>require.js</code></p>
<pre><code class="javascript">/** main.js 入口文件/主模块 **/
// 首先用config()指定各模块路径和引用名
require.config(&#123;
  baseUrl: &quot;js/lib&quot;,
  paths: &#123;
    &quot;jquery&quot;: &quot;jquery.min&quot;,  //实际路径为js/lib/jquery.min.js
    &quot;underscore&quot;: &quot;underscore.min&quot;,
  &#125;
&#125;);
// 执行基本操作
require([&quot;jquery&quot;,&quot;underscore&quot;],function($,_)&#123;
  // some code here
&#125;);
</code></pre>
<h5 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h5><p><code>CommonJS</code> 是一套 <code>Javascript</code> 模块规范，用于服务端</p>
<pre><code class="javascript">// a.js
module.exports=&#123; foo , bar&#125;

// b.js
const &#123; foo,bar &#125; = require(&#39;./a.js&#39;)
</code></pre>
<p>其有如下特点：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li>
<li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>
<li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li>
</ul>
<p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p>
<p>ES6 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以取代 <code>CommonJS </code>和 <code>AMD </code>规范，成为浏览器和服务器通用的模块解决方案</p>
<p><code>CommonJS</code> 和<code> AMD</code> 模块，都只能在运行时确定这些东西。比如，<code>CommonJS </code>模块就是对象，输入时必须查找对象属性</p>
<pre><code class="javascript">// CommonJS模块
let &#123; stat, exists, readfile &#125; = require(&#39;fs&#39;);

// 等同于
let _fs = require(&#39;fs&#39;);
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
</code></pre>
<p><code>ES6</code>设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
<pre><code class="javascript">// ES6模块
import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;
</code></pre>
<p>上述代码，只加载3个方法，其他方法不加载，即 <code>ES6</code> 可以在编译时就完成模块加载</p>
<p>由于编译加载，使得静态分析成为可能。包括现在流行的<code>typeScript</code>也是依靠静态分析实现功能</p>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p><code>ES6</code>模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是<code>ES5</code>之前就已经规定好</p>
<p>模块功能主要由两个命令构成：</p>
<ul>
<li><code>export</code>：用于规定模块的对外接口</li>
<li><code>import</code>：用于输入其他模块提供的功能</li>
</ul>
<h5 id="export"><a href="#export" class="headerlink" title="export"></a>export</h5><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p>
<pre><code class="javascript">// profile.js
export var firstName = &#39;Michael&#39;;
export var lastName = &#39;Jackson&#39;;
export var year = 1958;

或 
// 建议使用下面写法，这样能瞬间确定输出了哪些变量
var firstName = &#39;Michael&#39;;
var lastName = &#39;Jackson&#39;;
var year = 1958;

export &#123; firstName, lastName, year &#125;;
</code></pre>
<p>输出函数或类</p>
<pre><code class="javascript">export function multiply(x, y) &#123;
  return x * y;
&#125;;
</code></pre>
<p>通过<code>as</code>可以进行输出变量的重命名</p>
<pre><code class="javascript">function v1() &#123; ... &#125;
function v2() &#123; ... &#125;

export &#123;
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
&#125;;
</code></pre>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块</p>
<pre><code class="javascript">// main.js
import &#123; firstName, lastName, year &#125; from &#39;./profile.js&#39;;

function setName(element) &#123;
  element.textContent = firstName + &#39; &#39; + lastName;
&#125;
</code></pre>
<p>同样如果想要输入变量起别名，通过<code>as</code>关键字</p>
<pre><code class="javascript">import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;
</code></pre>
<p>当加载整个模块的时候，需要用到星号<code>*</code></p>
<pre><code class="javascript">// circle.js
export function area(radius) &#123;
  return Math.PI * radius * radius;
&#125;

export function circumference(radius) &#123;
  return 2 * Math.PI * radius;
&#125;

// main.js
import * as circle from &#39;./circle&#39;;
console.log(circle)   // &#123;area:area,circumference:circumference&#125;
</code></pre>
<p>输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性</p>
<pre><code class="javascript">import &#123;a&#125; from &#39;./xxx.js&#39;

a.foo = &#39;hello&#39;; // 合法操作
a = &#123;&#125;; // Syntax Error : &#39;a&#39; is read-only;
</code></pre>
<p>不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错</p>
<p><code>import</code>后面我们常接着<code>from</code>关键字，<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径</p>
<pre><code class="javascript">import &#123; a &#125; from &#39;./a&#39;;
</code></pre>
<p>如果只有一个模块名，需要有配置文件，告诉引擎模块的位置</p>
<pre><code class="javascript">import &#123; myMethod &#125; from &#39;util&#39;;
</code></pre>
<p>在编译阶段，<code>import</code>会提升到整个模块的头部，首先执行</p>
<pre><code class="javascript">foo();

import &#123; foo &#125; from &#39;my_module&#39;;
</code></pre>
<p>多次重复执行同样的导入，只会执行一次</p>
<pre><code class="javascript">import &#39;lodash&#39;;
import &#39;lodash&#39;;
</code></pre>
<p>上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载</p>
<p>如果不需要知道变量名或函数就完成加载，就要用到<code>export default</code>命令，为模块指定默认输出</p>
<pre><code class="javascript">// export-default.js
export default function () &#123;
    console.log(&#39;foo&#39;);
&#125;
</code></pre>
<p>加载该模块的时候，<code>import</code>命令可以为该函数指定任意名字</p>
<pre><code class="javascript">// import-default.js
import customName from &#39;./export-default&#39;;
customName(); // &#39;foo&#39;
</code></pre>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p>
<p>这个新功能允许您将<code>import()</code>作为函数调用，将其作为参数传递给模块的路径。 它返回一个 <code>promise</code>，它用一个模块对象来实现，让你可以访问该对象的导出</p>
<pre><code class="javascript">import(&#39;/modules/myModule.mjs&#39;)
  .then((module) =&gt; &#123;
    // Do something with the module.
  &#125;);
</code></pre>
<h4 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h4><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起</p>
<pre><code class="javascript">export &#123; foo, bar &#125; from &#39;my_module&#39;;

// 可以简单理解为
import &#123; foo, bar &#125; from &#39;my_module&#39;;
export &#123; foo, bar &#125;;
</code></pre>
<p>同理能够搭配<code>as</code>、<code>*</code>搭配使用</p>
<h4 id="三、使用场景-2"><a href="#三、使用场景-2" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>如今，<code>ES6</code>模块化已经深入我们日常项目开发中，像<code>vue</code>、<code>react</code>项目搭建项目，组件化开发处处可见，其也是依赖模块化实现</p>
<p><code>vue</code>组件</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;App&quot;&gt;
      组件化开发 ---- 模块化
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;HelloWorld&#39;,
  props: &#123;
    msg: String
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p><code>react</code>组件</p>
<pre><code class="javascript">function App() &#123;
  return (
    &lt;div className=&quot;App&quot;&gt;
        组件化开发 ---- 模块化
    &lt;/div&gt;
  );
&#125;

export default App;
</code></pre>
<p>包括完成一些复杂应用的时候，我们也可以拆分成各个模块</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Decorator-的？使用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-怎么理解ES6中-Decorator-的？使用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Decorator 的？使用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 怎么理解ES6中 Decorator 的？使用场景？</h3><h4 id="一、介绍-2"><a href="#一、介绍-2" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>Decorator，即装饰器，从名字上很容易让我们联想到装饰者模式</p>
<p>简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。</p>
<p><code>ES6</code>中<code>Decorator</code>功能亦如此，其本质也不是什么高大上的结构，就是一个普通的函数，用于扩展类属性和类方法</p>
<p>这里定义一个士兵，这时候他什么装备都没有</p>
<pre><code class="javascript">class soldier&#123; 
&#125;
</code></pre>
<p>定义一个得到 AK 装备的函数，即装饰器</p>
<pre><code class="javascript">function strong(target)&#123;
    target.AK = true
&#125;
</code></pre>
<p>使用该装饰器对士兵进行增强</p>
<pre><code class="javascript">@strong
class soldier&#123;
&#125;
</code></pre>
<p>这时候士兵就有武器了</p>
<pre><code class="javascript">soldier.AK // true
</code></pre>
<p>上述代码虽然简单，但也能够清晰看到了使用<code>Decorator</code>两大优点：</p>
<ul>
<li>代码可读性变强了，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原来功能进行扩展</li>
</ul>
<h4 id="二、用法-2"><a href="#二、用法-2" class="headerlink" title="二、用法"></a>二、用法</h4><p><code>Docorator</code>修饰对象为下面两种：</p>
<ul>
<li>类的装饰</li>
<li>类属性的装饰</li>
</ul>
<h5 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h5><p>当对类本身进行装饰的时候，能够接受一个参数，即类本身</p>
<p>将装饰器行为进行分解，大家能够有个更深入的了解</p>
<pre><code class="javascript">@decorator
class A &#123;&#125;

// 等同于

class A &#123;&#125;
A = decorator(A) || A;
</code></pre>
<p>下面<code>@testable</code>就是一个装饰器，<code>target</code>就是传入的类，即<code>MyTestableClass</code>，实现了为类添加静态属性</p>
<pre><code class="javascript">@testable
class MyTestableClass &#123;
  // ...
&#125;

function testable(target) &#123;
  target.isTestable = true;
&#125;

MyTestableClass.isTestable // true
</code></pre>
<p>如果想要传递参数，可以在装饰器外层再封装一层函数</p>
<pre><code class="javascript">function testable(isTestable) &#123;
  return function(target) &#123;
    target.isTestable = isTestable;
  &#125;
&#125;

@testable(true)
class MyTestableClass &#123;&#125;
MyTestableClass.isTestable // true

@testable(false)
class MyClass &#123;&#125;
MyClass.isTestable // false
</code></pre>
<h5 id="类属性的装饰"><a href="#类属性的装饰" class="headerlink" title="类属性的装饰"></a>类属性的装饰</h5><p>当对类属性进行装饰的时候，能够接受三个参数：</p>
<ul>
<li>类的原型对象</li>
<li>需要装饰的属性名</li>
<li>装饰属性名的描述对象</li>
</ul>
<p>首先定义一个<code>readonly</code>装饰器</p>
<pre><code class="javascript">function readonly(target, name, descriptor)&#123;
  descriptor.writable = false; // 将可写属性设为false
  return descriptor;
&#125;
</code></pre>
<p>使用<code>readonly</code>装饰类的<code>name</code>方法</p>
<pre><code class="javascript">class Person &#123;
  @readonly
  name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;
&#125;
</code></pre>
<p>相当于以下调用</p>
<pre><code class="javascript">readonly(Person.prototype, &#39;name&#39;, descriptor);
</code></pre>
<p>如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行</p>
<pre><code class="javascript">function dec(id)&#123;
    console.log(&#39;evaluated&#39;, id);
    return (target, property, descriptor) =&gt;console.log(&#39;executed&#39;, id);
&#125;

class Example &#123;
    @dec(1)
    @dec(2)
    method()&#123;&#125;
&#125;
// evaluated 1
// evaluated 2
// executed 2
// executed 1
</code></pre>
<p>外层装饰器<code>@dec(1)</code>先进入，但是内层装饰器<code>@dec(2)</code>先执行</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>装饰器不能用于修饰函数，因为函数存在变量声明情况</p>
<pre><code class="javascript">var counter = 0;

var add = function () &#123;
  counter++;
&#125;;

@add
function foo() &#123;
&#125;
</code></pre>
<p>编译阶段，变成下面</p>
<pre><code class="javascript">var counter;
var add;

@add
function foo() &#123;
&#125;

counter = 0;

add = function () &#123;
  counter++;
&#125;;
</code></pre>
<p>意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0</p>
<h4 id="三、使用场景-3"><a href="#三、使用场景-3" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>基于<code>Decorator</code>强大的作用，我们能够完成各种场景的需求，下面简单列举几种：</p>
<p>使用<code>react-redux</code>的时候，如果写成下面这种形式，既不雅观也很麻烦</p>
<pre><code class="javascript">class MyReactComponent extends React.Component &#123;&#125;

export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);
</code></pre>
<p>通过装饰器就变得简洁多了</p>
<pre><code class="javascript">@connect(mapStateToProps, mapDispatchToProps)
export default class MyReactComponent extends React.Component &#123;&#125;
</code></pre>
<p>将<code>mixins</code>，也可以写成装饰器，让使用更为简洁了</p>
<pre><code class="javascript">function mixins(...list) &#123;
  return function (target) &#123;
    Object.assign(target.prototype, ...list);
  &#125;;
&#125;

// 使用
const Foo = &#123;
  foo() &#123; console.log(&#39;foo&#39;) &#125;
&#125;;

@mixins(Foo)
class MyClass &#123;&#125;

let obj = new MyClass();
obj.foo() // &quot;foo&quot;
</code></pre>
<p>下面再讲讲<code>core-decorators.js</code>几个常见的装饰器</p>
<h5 id="antobind"><a href="#antobind" class="headerlink" title="@antobind"></a>@antobind</h5><p><code>autobind</code>装饰器使得方法中的<code>this</code>对象，绑定原始对象</p>
<pre><code class="javascript">import &#123; autobind &#125; from &#39;core-decorators&#39;;

class Person &#123;
  @autobind
  getPerson() &#123;
    return this;
  &#125;
&#125;

let person = new Person();
let getPerson = person.getPerson;

getPerson() === person;
// true
</code></pre>
<h5 id="readonly"><a href="#readonly" class="headerlink" title="@readonly"></a>@readonly</h5><p><code>readonly</code>装饰器使得属性或方法不可写</p>
<pre><code class="javascript">import &#123; readonly &#125; from &#39;core-decorators&#39;;

class Meal &#123;
  @readonly
  entree = &#39;steak&#39;;
&#125;

var dinner = new Meal();
dinner.entree = &#39;salmon&#39;;
// Cannot assign to read only property &#39;entree&#39; of [object Object]
</code></pre>
<h4 id="deprecate"><a href="#deprecate" class="headerlink" title="@deprecate"></a>@deprecate</h4><p><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除</p>
<pre><code class="javascript">import &#123; deprecate &#125; from &#39;core-decorators&#39;;

class Person &#123;
  @deprecate
  facepalm() &#123;&#125;

  @deprecate(&#39;功能废除了&#39;)
  facepalmHard() &#123;&#125;
&#125;

let person = new Person();

person.facepalm();
// DEPRECATION Person#facepalm: This function will be removed in future versions.

person.facepalmHard();
// DEPRECATION Person#facepalmHard: 功能废除了
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-Symbol数据类型"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-Symbol数据类型" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Symbol数据类型"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Symbol数据类型</h3><p>ES6引入一种新的原始数据类型为 Symbol ，表示为 独一无二 的值，用来定义独一无二的对象属性名。</p>
<h4 id="Symbol的讲解"><a href="#Symbol的讲解" class="headerlink" title="Symbol的讲解"></a>Symbol的讲解</h4><p>4个方面说说Symbol数据类型：</p>
<ol>
<li>Symbol的定义；</li>
<li>Symbol作为对象属性名；</li>
<li>Symbol使用场景；</li>
<li>Symbol获取。</li>
</ol>
<h4 id="Symbol的定义"><a href="#Symbol的定义" class="headerlink" title="Symbol的定义"></a>Symbol的定义</h4><ul>
<li>一种Symbol类型可以通过使用Symbol()函数来生成；</li>
<li>Symbol()函数可以接收一个字符串作为参数</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let s1 = Symbol(&#39;web&#39;);
let s2 = Symbol(&#39;web&#39;);
console.log(s1 === s2);
console.log(typeof s1);
console.log(typeof s2);
复制代码
</code></pre>
<p>chrome截图：</p>
<p><img src="/2022/10/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8ES6/170563012a3ecec6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p>由图可知：Symbol()函数接收的参数相同，其变量的值也不同，s1和s2是Symbol类型的变量，因为变量的值不同，所以打印的结果为false。使用typeof来获取相应的类型，所以打印的结果都为symbol。</p>
<h4 id="Symbol作为对象属性名"><a href="#Symbol作为对象属性名" class="headerlink" title="Symbol作为对象属性名"></a>Symbol作为对象属性名</h4><p>Symbol可以通过三种方式作为对象属性名。</p>
<ul>
<li>第一种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;&#125;;
a[symbol] = &#39;web&#39;;
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，一个空的对象为a，通过a[symbol]给a对象赋值一个web的字符串。表示symbol作为对象属性名，web作为它的属性值。</p>
<ul>
<li>第二种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;
    [symbol]:&#39;web&#39;
&#125;;
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，接着在声明对象a的同时通过[symbol]给a对象性赋值为web的字符串。</p>
<ul>
<li>第三种：</li>
</ul>
<p>示例代码：</p>
<pre><code class="ini">let symbol = Symbol();
let a = &#123;&#125;;
Object.defineProperty(a, symbol, &#123;value: &#39;web&#39;&#125;);
</code></pre>
<p>由代码可知：首先声明了一个Symbol类型的变量symbol，一个空对象为a，通过Object.defineProperty()方法给a对象赋值为web的字符串。</p>
<blockquote>
<p>Symbol的值作为对象属性名，是不能用点运算符的。</p>
</blockquote>
<h4 id="Symbol使用场景"><a href="#Symbol使用场景" class="headerlink" title="Symbol使用场景"></a>Symbol使用场景</h4><p>一种有两种使用场景：</p>
<ol>
<li>因为Symbol的值是均不相等的，所以Symbol类型的值作为对象属性名，不会出现重复。</li>
<li>代码形成强耦合的某一个具体的字符串。</li>
</ol>
<h4 id="Symbol获取"><a href="#Symbol获取" class="headerlink" title="Symbol获取"></a>Symbol获取</h4><p>通过Object.getOwnPropertySymbols()方法，可以获取指定对象的所有Symbols属性名。:</p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>