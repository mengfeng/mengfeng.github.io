<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-threejs-d-3-0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/30/threejs-d-3-0/"
    >threejs-d-3.0</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/30/threejs-d-3-0/" class="article-date">
  <time datetime="2022-11-30T08:46:30.000Z" itemprop="datePublished">2022-11-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3D/">Web3D</a> / <a class="article-category-link" href="/categories/Web3D/Three-js/">Three.js</a> / <a class="article-category-link" href="/categories/Web3D/Three-js/threejs-d-3-0/">threejs-d-3.0</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="threejs-d-3-0"><a href="#threejs-d-3-0" class="headerlink" title="threejs-d-3.0"></a>threejs-d-3.0</h1><h3 id="一、通过Clock跟踪时间处理动画"><a href="#一、通过Clock跟踪时间处理动画" class="headerlink" title="一、通过Clock跟踪时间处理动画"></a>一、通过Clock跟踪时间处理动画</h3><blockquote>
<p>我们通过时间属性去控制物体动画，我们需要一个对象用于跟踪时间</p>
</blockquote>
<pre><code class="javascript">const clock = THREE.Clock();
const time = clock.getElapsedTime();//获取时钟运行的总时长
const getDelta = clock.getDelta();//获取两次渲染的间隔时长
</code></pre>
<p>Clock( autoStart : Boolean )</p>
<p>autoStart — (可选) 是否要在第一次调用 .getDelta() 时自动开启时钟。默认值是 <strong>true</strong>。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>.autoStart : Boolean</p>
<p>如果设置为 true，则在第一次调用 .getDelta() 时开启时钟。默认值是 <strong>true</strong>。</p>
<p>.startTime : Float</p>
<p>存储时钟最后一次调用 start 方法的时间。默认值是 <strong>0</strong>。</p>
<p>.oldTime : Float</p>
<p>存储时钟最后一次调用 start, .getElapsedTime() 或 .getDelta() 方法的时间。默认值是 <strong>0</strong>。</p>
<p>.elapsedTime : Float</p>
<p>保存时钟运行的总时长。默认值是 <strong>0</strong>。</p>
<p>.running : Boolean</p>
<p>判断时钟是否在运行。默认值是 <strong>false</strong>。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>.start () : undefined</p>
<p>启动时钟。同时将 startTime 和 oldTime 设置为当前时间。 设置 elapsedTime 为 <strong>0</strong>，并且设置 running 为 <strong>true</strong>.</p>
<p>.stop () : undefined</p>
<p>停止时钟。同时将 oldTime 设置为当前时间。</p>
<p>.getElapsedTime () : Float</p>
<p>获取自时钟启动后的秒数，同时将 .oldTime 设置为当前时间。<br>如果 .autoStart 设置为 <strong>true</strong> 且时钟并未运行，则该方法同时启动时钟。</p>
<p>.getDelta () : Float</p>
<p>获取自 .oldTime 设置后到当前的秒数。 同时将 .oldTime 设置为当前时间。<br>如果 .autoStart 设置为 <strong>true</strong> 且时钟并未运行，则该方法同时启动时钟。</p>
<h3 id="二、Gsap动画库的基本使用"><a href="#二、Gsap动画库的基本使用" class="headerlink" title="二、Gsap动画库的基本使用"></a>二、Gsap动画库的基本使用</h3><blockquote>
<p>这个动画库的API都有相关的动画示例，所以即使看不懂文档的同学使用也是可以明白的</p>
</blockquote>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130085026756.png"></p>
<h4 id="1-安装并使用"><a href="#1-安装并使用" class="headerlink" title="1.安装并使用"></a>1.安装并使用</h4><pre><code class="ini">npm install gsap //安装gsap
</code></pre>
<pre><code class="javascript">//main.js
import gsap from &#39;gsap&#39;
gsap.to(cube.position,&#123;x:20,duration:5&#125;)//动画属性，控制物体位置和运动时间（duration）
gsap.to(cube.rotation,&#123;x:Math.PI/4,duration:5&#125;)//动画属性，控制物体旋转和运动时间（duration）
</code></pre>
<p>当然我们的动画运动肯定不只是匀速运动，也是可以配置我们的缓冲器（和<a target="_blank" rel="noopener" href="https://cubic-bezier.com/#.17,.67,.83,.67">贝赛尔曲线</a>差不多）</p>
<pre><code class="javascript">gsap.to(cube.position,&#123;x:20,duration:5,ease: &quot;elastic.out(1, 0.2)&quot;&#125;)
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130085456408.png"></p>
<h4 id="2-其他属性使用"><a href="#2-其他属性使用" class="headerlink" title="2.其他属性使用"></a>2.其他属性使用</h4><blockquote>
<p>我们也可以在动画开始、更新、结束去执行回调</p>
<p>我们<a target="_blank" rel="noopener" href="https://greensock.com/docs/v3/GSAP/gsap.to()">gsap.to()</a>还有其他动画的属性，比如往返运动、定义关键帧、循环等等</p>
</blockquote>
<pre><code class="javascript">//main.js
import gsap from &#39;gsap&#39;
gsap.to(cube.position,&#123;
    x:20,
    duration:5,
    ease: &quot;elastic.out(1, 0.2)&quot;,
    onStart:()=&gt;&#123;console.log(&#39;动画开始&#39;)&#125;,
    onComplete:()=&gt;&#123;console.log(&#39;动画结束&#39;)&#125;,
    onUpdate:()=&gt;&#123;console.log(&#39;更新动画&#39;)&#125;
&#125;)
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130090823212.png"></p>
<p>我们还可以根据返回对象实现对动画的控制</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;threejs&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;nav&quot;&gt;
        &lt;button id=&quot;play&quot;&gt;play()&lt;/button&gt;
        &lt;button id=&quot;pause&quot;&gt;pause()&lt;/button&gt;
        &lt;button id=&quot;resume&quot;&gt;resume()&lt;/button&gt;
        &lt;button id=&quot;reverse&quot;&gt;reverse()&lt;/button&gt;
        &lt;button id=&quot;restart&quot;&gt;restart()&lt;/button&gt;
      &lt;/div&gt;
    &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="javascript">const tween = gsap.to(cube.position,&#123;
    x:20,
    duration:5,
    ease: &quot;elastic.out(1, 0.2)&quot;,
    onStart:()=&gt;&#123;console.log(&#39;动画开始&#39;)&#125;,
    onComplete:()=&gt;&#123;console.log(&#39;动画结束&#39;)&#125;,
    onUpdate:()=&gt;&#123;console.log(&#39;更新动画&#39;)&#125;
&#125;)

document.querySelector(&quot;#play&quot;).onclick = () =&gt; tween.play();//开启动画
document.querySelector(&quot;#pause&quot;).onclick = () =&gt; tween.pause();//暂停动画
document.querySelector(&quot;#resume&quot;).onclick = () =&gt; tween.resume();//继续播放动画
document.querySelector(&quot;#reverse&quot;).onclick = () =&gt; tween.reverse();//反转动画
document.querySelector(&quot;#restart&quot;).onclick = () =&gt; tween.restart();//重新开始
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130092808802.png"></p>
<h3 id="三、自适应更改"><a href="#三、自适应更改" class="headerlink" title="三、自适应更改"></a>三、自适应更改</h3><blockquote>
<p>我们希望我们的画面能够适应我们屏幕的更改</p>
</blockquote>
<pre><code class="javascript">//main.js+
//监听屏幕变化
window.addEventListener(&#39;resize&#39;,()=&gt;&#123;
  //更新摄影机
    camera.aspect = window.innerWidth/window.innerHeight;
  //更新摄影机的投影矩阵
    camera.updateProjectionMatrix();
  //更新渲染器
    renderer.setSize(window.innerWidth,window.innerHeight);
  //更新渲染器的像素比
    renderer.setPixelRatio(window.devicePixelRatio);
&#125;)
</code></pre>
<h3 id="四、可视化调节"><a href="#四、可视化调节" class="headerlink" title="四、可视化调节"></a>四、可视化调节</h3><blockquote>
<p>我们在开发过程中，各种参数比较多，我们需要改一下看一下效果是否符合我们的需要，这样我们的效率就会降低。</p>
<p>所以我们需要一款能快速调节参数的可视化工具<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/dat.gui">dat.gui</a></p>
</blockquote>
<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><pre><code class="ini">npm install --save dat.gui
</code></pre>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><p>修改数值</p>
<pre><code class="javascript">import dat from &#39;dat.gui&#39;//引入
const gui = new dat.GUI();//初始化

gui.add(cube.position,&#39;x&#39;)//添加要控制的属性
.min(0)//最小值
.max(20)//最大值
.name(&#39;移动x坐标&#39;)//控制器名称
.step(0.1)//改变刻度
.onChange(value=&gt;console.log(&#39;x坐标改变了：&#39;+value))//坐标改变触发
.onFinishChange(value=&gt;console.log(&#39;x坐标停止改变了：&#39;+value))//坐标停止改变触发
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130103244105.png"></p>
<p>修改颜色</p>
<pre><code class="javascript">const parm = &#123;
    color:&#39;#ffffff&#39;
&#125;
gui.addColor(parm,&#39;color&#39;)
.name(&#39;物体颜色&#39;)
.onChange(value=&gt;&#123;
    cube.material.color.set(value)
&#125;)
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130105101668.png"></p>
<blockquote>
<p>我们的dat.gui还有许多API可以调用，具体的我们可以看<a target="_blank" rel="noopener" href="https://github.com/dataarts/dat.gui/blob/master/API.md">dat.gui-api</a></p>
</blockquote>
<h3 id="五、BufferGeometry创建顶点创建矩形"><a href="#五、BufferGeometry创建顶点创建矩形" class="headerlink" title="五、BufferGeometry创建顶点创建矩形"></a>五、BufferGeometry创建顶点创建矩形</h3><blockquote>
<p>我们所见的立方体，是由顶点坐标创建的面形成的</p>
<p>也可以看<a href="https://mengfeng.github.io/2022/11/18/webgl/">webgl</a>里有一些基础的知识可以帮助我们理解点与面的关系</p>
<p>官方描述：是面片、线或点几何体的有效表述。包括顶点位置，面片索引、法相量、颜色值、UV 坐标和自定义缓存属性值。使用 BufferGeometry 可以有效减少向 GPU 传输上述数据所需的开销。</p>
</blockquote>
<pre><code class="javascript">//main.js
import * as THREE from &#39;three&#39;
import &#123; OrbitControls &#125; from &#39;three/examples/jsm/controls/OrbitControls&#39; 


const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

const axesHelper = new THREE.AxesHelper( 30 );//轴的线段长度. 默认为 1.
scene.add( axesHelper );//添加到场景

const geometry = new THREE.BufferGeometry();
// 创建一个简单的矩形. 在这里我们左上和右下顶点被复制了两次。
// 因为在两个三角面片里，这两个顶点都需要被用到。
const vertices = new Float32Array( [
    -1.0, -1.0,  1.0,
     1.0, -1.0,  1.0,
     1.0,  1.0,  1.0,

     1.0,  1.0,  1.0,
    -1.0,  1.0,  1.0,
    -1.0, -1.0,  1.0
] );
// itemSize = 3 因为每个顶点都是一个三元组。
geometry.setAttribute( &#39;position&#39;, new THREE.BufferAttribute( vertices, 3 ) );
const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );
const cube = new THREE.Mesh( geometry, material );
console.log(cube)

 
scene.add( cube );
const controls = new OrbitControls( camera,renderer.domElement  );
camera.position.set(0,20,100);
controls.update();
function animate() &#123;
   
    requestAnimationFrame( animate );
    controls.update();
    renderer.render( scene, camera );
&#125;
animate();

window.addEventListener(&#39;resize&#39;,()=&gt;&#123;
    // console.log(&#39;屏幕变化了&#39;)
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
&#125;)
</code></pre>
<p><img src="/2022/11/30/threejs-d-3-0/image-20221130162558717.png"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[GSAP]: 	“<a target="_blank" rel="noopener" href="https://github.com/greensock/GSAP">https://github.com/greensock/GSAP</a> “<br>[gsap]: 	“<a target="_blank" rel="noopener" href="https://greensock.com/gsap/">https://greensock.com/gsap/</a> “<br>[Cubic Bezier]: 	“<a target="_blank" rel="noopener" href="https://cubic-bezier.com/#.17,.67,.83,.67">https://cubic-bezier.com/#.17,.67,.83,.67</a> “<br>[dat.gui]: 	“<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/dat.gui">https://www.npmjs.com/package/dat.gui</a> “<br>[dat.gui-api]: 	“<a target="_blank" rel="noopener" href="https://github.com/dataarts/dat.gui/blob/master/API.md">https://github.com/dataarts/dat.gui/blob/master/API.md</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threejs/" rel="tag">threejs</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-threejs-d-2-0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/29/threejs-d-2-0/"
    >threejs-d-2.0</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/29/threejs-d-2-0/" class="article-date">
  <time datetime="2022-11-29T08:43:31.000Z" itemprop="datePublished">2022-11-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3D/">Web3D</a> / <a class="article-category-link" href="/categories/Web3D/Three-js/">Three.js</a> / <a class="article-category-link" href="/categories/Web3D/Three-js/threejs-d-2-0/">threejs-d-2.0</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="threejs-d-2-0"><a href="#threejs-d-2-0" class="headerlink" title="threejs-d-2.0"></a>threejs-d-2.0</h1><h3 id="一、创建第一个threejs应用"><a href="#一、创建第一个threejs应用" class="headerlink" title="一、创建第一个threejs应用"></a>一、创建第一个threejs应用</h3><p>代码汇总：</p>
<pre><code class="javascript">//main.js
import * as THREE from &#39;three&#39;

const scene = new THREE.Scene();//创建场景
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );//创建透视相机（相机中的一种）
const renderer = new THREE.WebGLRenderer();//创建渲染器
renderer.setSize( window.innerWidth, window.innerHeight );//将输出canvas的大小调整为(width, height)并考虑设备像素比，且将视口从(0, 0)开始调整到适合大小
document.body.appendChild( renderer.domElement );//将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中

const geometry = new THREE.BoxGeometry( 1, 1, 1 );//创建几何体
const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );//创建基础网格材质
const cube = new THREE.Mesh( geometry, material );//使用构造器
scene.add( cube );//将几何体添加到场景
camera.position.z = 5;//调整相机位置（默认0，0，0）

//几何体循环旋转动画
function animate() &#123;
    requestAnimationFrame( animate );
  //旋转坐标变换
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;
  //重新渲染几何体
    renderer.render( scene, camera );
&#125;
animate();
</code></pre>
<h4 id="1-创建场景、相机、渲染器"><a href="#1-创建场景、相机、渲染器" class="headerlink" title="1.创建场景、相机、渲染器"></a>1.创建场景、相机、渲染器</h4><blockquote>
<p>如果我们有玩过三维软件的同学应该不会陌生这几个概念</p>
<p>我们下面以三维软件C4D来简单认识一下吧</p>
</blockquote>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129085326176.png"></p>
<p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。</p>
<pre><code class="javascript">const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
</code></pre>
<p>three.js里有几种不同的相机，在这里，我们使用的是<strong>PerspectiveCamera</strong>（透视摄像机）。</p>
<p>第一个参数是<strong>视野角度（FOV）</strong>。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。</p>
<p>第二个参数是<strong>长宽比（aspect ratio）</strong>。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>
<p>接下来的两个参数是<strong>近截面</strong>（near）和<strong>远截面</strong>（far）。 当物体某些部分比摄像机的<strong>远截面</strong>远或者比<strong>近截面</strong>近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>
<p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。</p>
<p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用<strong>setSize</strong>传入一个较小的值，例如<strong>window.innerWidth&#x2F;2</strong>和<strong>window.innerHeight&#x2F;2</strong>，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p>
<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用<strong>setSize</strong>时，将<strong>updateStyle</strong>（第三个参数）设为false。例如，假设你的<canvas> 标签现在已经具有了100%的宽和高，调用**setSize(window.innerWidth&#x2F;2, window.innerHeight&#x2F;2, false)**将使得你的应用程序以一半的分辨率来进行渲染。</p>
<pre><code class="javascript">document.body.appendChild( renderer.domElement );
</code></pre>
<p>最后一步很重要，我们将<strong>renderer</strong>（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。</p>
<h4 id="2-创建几何体、材质"><a href="#2-创建几何体、材质" class="headerlink" title="2.创建几何体、材质"></a>2.创建几何体、材质</h4><blockquote>
<p>对于材质这块，就是给一个没有任何属性的物体添加属性，玻璃、金属、玉、有颜色的立方体。</p>
</blockquote>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129090339038.png"></p>
<p>要创建一个立方体，我们需要一个<strong>BoxGeometry</strong>（立方体）对象. 这个对象包含了一个立方体中所有的顶点（<strong>vertices</strong>）和面（<strong>faces</strong>）。未来我们将在这方面进行更多的探索。</p>
<pre><code class="javascript">const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
camera.position.z = 5;
</code></pre>
<p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是<strong>MeshBasicMaterial</strong>。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为<strong>0x00ff00</strong>，也就是绿色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(<strong>hex colors</strong>)颜色格式来设置颜色的方式一致。</p>
<p>第三步，我们需要一个<strong>Mesh</strong>（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>
<p>默认情况下，当我们调用**scene.add()<strong>的时候，物体将会被添加到</strong>(0,0,0)**坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p>
<h4 id="3-创建渲染"><a href="#3-创建渲染" class="headerlink" title="3.创建渲染"></a>3.创建渲染</h4><blockquote>
<p>这个就比较好理解了，添加x，y，z方向的位置变化</p>
</blockquote>
<p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用一个被叫做“<strong>渲染循环</strong>”（render loop）或者“<strong>动画循环</strong>”（animate loop）的东西。</p>
<pre><code class="javascript">function animate() &#123; 
requestAnimationFrame( animate ); 
renderer.render( scene, camera ); 
&#125; 
animate();
</code></pre>
<p>在这里我们创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次&#x2F;秒）。如果你是一个浏览器游戏开发的新手，你或许会说<em>“为什么我们不直接用setInterval来实现刷新的功能呢？”</em>当然啦，我们的确可以用setInterval，但是，<strong>requestAnimationFrame</strong>有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。</p>
<p>在开始之前，如果你已经将上面的代码写入到了你所创建的文件中，你可以看到一个绿色的方块。让我们来做一些更加有趣的事 —— 让它旋转起来。</p>
<p>将下列代码添加到animate()函数中<strong>renderer.render</strong>调用的上方：</p>
<pre><code class="javascript">cube.rotation.x += 0.01; 
cube.rotation.y += 0.01;
</code></pre>
<p>这段代码每帧都会执行（正常情况下是60次&#x2F;秒），这就让立方体有了一个看起来很不错的旋转动画。基本上来说，当应用程序运行时，如果你想要移动或者改变任何场景中的东西，都必须要经过这个动画循环。当然，你可以在这个动画循环里调用别的函数，这样你就不会写出有上百行代码的<strong>animate</strong>函数。</p>
<h4 id="效果演示："><a href="#效果演示：" class="headerlink" title="效果演示："></a>效果演示：</h4><p><img src="/2022/11/29/threejs-d-2-0/image-20221129090831716.png"></p>
<h3 id="二、控制器（轨道控制器）"><a href="#二、控制器（轨道控制器）" class="headerlink" title="二、控制器（轨道控制器）"></a>二、控制器（轨道控制器）</h3><blockquote>
<p>控制器有许多，我们这先说这一种</p>
<p>轨道控制器是以物体为中心，对物体做环绕运动</p>
</blockquote>
<p>代码汇总：</p>
<pre><code class="javascript">//main.js
import * as THREE from &#39;three&#39;
import &#123; OrbitControls &#125; from &#39;three/examples/jsm/controls/OrbitControls&#39; //导入轨道控制器

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

const geometry = new THREE.BoxGeometry( 5, 5, 5 );
const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
const controls = new OrbitControls( camera,renderer.domElement  );
camera.position.set(0,20,100);
controls.update();//更新控制器。必须在摄像机的变换发生任何手动改变后调用
function animate() &#123;
    requestAnimationFrame( animate );
    controls.update();//循环更新轨道控制器
    renderer.render( scene, camera );
&#125;
animate();
</code></pre>
<p>OrbitControls( object : Camera, domElement : HTMLDOMElement )</p>
<p>object: （必须）将要被控制的相机。该相机不允许是其他任何对象的子级，除非该对象是场景自身。</p>
<p>domElement: 用于事件监听的HTML元素。</p>
<p>那我们现在就可以移动我们的相机来观察我们的物体了。</p>
<h3 id="三、添加辅助器"><a href="#三、添加辅助器" class="headerlink" title="三、添加辅助器"></a>三、添加辅助器</h3><blockquote>
<p>这个来自与我们help里面的东西，文档里查就可以了</p>
<p>添加辅助器的用处是为了更好的去开发</p>
</blockquote>
<h4 id="1-坐标辅助器"><a href="#1-坐标辅助器" class="headerlink" title="1.坐标辅助器"></a>1.坐标辅助器</h4><blockquote>
<p>用于简单模拟3个坐标轴的对象.<br>红色代表 X 轴. 绿色代表 Y 轴. 蓝色代表 Z 轴.</p>
</blockquote>
<pre><code class="javascript">const axesHelper = new THREE.AxesHelper( 5 );//轴的线段长度. 默认为 1.
scene.add( axesHelper );//添加到场景
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129155031932.png"></p>
<h4 id="2-相机辅助器"><a href="#2-相机辅助器" class="headerlink" title="2.相机辅助器"></a>2.相机辅助器</h4><blockquote>
<p>用于模拟相机视锥体的辅助对象.<br>它使用 LineSegments 来模拟相机视锥体.</p>
</blockquote>
<pre><code class="javascript">const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
const helper = new THREE.CameraHelper( camera );
scene.add( helper );
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129155852737.png"></p>
<p>CameraHelper( camera : Camera )</p>
<p>camera – 被模拟的相机.</p>
<p>为指定相机创建一个新的相机辅助对象 CameraHelper .</p>
<h4 id="3-平面辅助器"><a href="#3-平面辅助器" class="headerlink" title="3.平面辅助器"></a>3.平面辅助器</h4><blockquote>
<p>用于模拟平面 Plane 的辅助对象.</p>
</blockquote>
<pre><code class="javascript">const plane = new THREE.Plane( new THREE.Vector3( 1, 1, 0.2 ), 3 );
const helper = new THREE.PlaneHelper( plane, 100, 0xffff00 );
scene.add( helper );
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129160213446.png"></p>
<p>PlaneHelper( plane : Plane, size : Float, hex : Color )</p>
<p>plane – 被模拟的平面.<br>size – (可选的) 辅助对象的单边长度. 默认为 1.<br>color – (可选的) 辅助对象的颜色. 默认为 0xffff00.</p>
<p>创建一个线框辅助对象来表示指定平面.</p>
<h4 id="终结："><a href="#终结：" class="headerlink" title="终结："></a>终结：</h4><p>其他的辅助器，我们就自己按照需求去加吧，这个就是做一个参照</p>
<h3 id="四、物体的属性"><a href="#四、物体的属性" class="headerlink" title="四、物体的属性"></a>四、物体的属性</h3><blockquote>
<p>物体的属性，那我们要看一下cube是什么了</p>
<p>根据控制台打印，它是个Mesh类，下面有许多属性</p>
</blockquote>
<pre><code class="javascript">const geometry = new THREE.BoxGeometry( 5, 5, 5 );
const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129160944920.png"></p>
<h4 id="1-物体的位移"><a href="#1-物体的位移" class="headerlink" title="1.物体的位移"></a>1.物体的位移</h4><blockquote>
<p>控制物体的位置</p>
</blockquote>
<pre><code class="javascript">cube.position.set(10,0,0)//默认为x，y，z方向
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129161420179.png"></p>
<h4 id="2-物体的旋转"><a href="#2-物体的旋转" class="headerlink" title="2.物体的旋转"></a>2.物体的旋转</h4><blockquote>
<p>控制问题的旋转角度</p>
<p>这个不是单纯的三维向量了</p>
<p>是一个Euler类</p>
</blockquote>
<pre><code class="javascript">cube.rotation.set(Math.PI/4,0,0,&#39;XYZ&#39;)//默认为‘xyz’
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129162730828.png"></p>
<p>Euler( x : Float, y : Float, z : Float, order : String )</p>
<p>x - (optional) 用弧度表示x轴旋转量。 默认值是 <strong>0</strong>。<br>y - (optional) 用弧度表示y轴旋转量。 默认值是 <strong>0</strong>。<br>z - (optional) 用弧度表示z轴旋转量。 默认值是 <strong>0</strong>。<br>order - (optional) 表示旋转顺序的字符串，默认为’XYZ’（必须是大写）。</p>
<h4 id="3-物体的缩放"><a href="#3-物体的缩放" class="headerlink" title="3.物体的缩放"></a>3.物体的缩放</h4><blockquote>
<p>控制物体缩放</p>
</blockquote>
<pre><code class="javascript">cube.scale.set(3,2,1)
</code></pre>
<p><img src="/2022/11/29/threejs-d-2-0/image-20221129161943968.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threejs/" rel="tag">threejs</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-electron-vue3-vite"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/28/electron-vue3-vite/"
    >electron-vue3-vite</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/28/electron-vue3-vite/" class="article-date">
  <time datetime="2022-11-28T04:04:11.000Z" itemprop="datePublished">2022-11-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a> / <a class="article-category-link" href="/categories/Electron/electron-vue3-vite/">electron-vue3-vite</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Electron-Vue3-Vite"><a href="#Electron-Vue3-Vite" class="headerlink" title="Electron-Vue3-Vite"></a>Electron-Vue3-Vite</h1><blockquote>
<p>今天这一篇文章算是electron的一个短暂的结尾，以后我们再更新electron 的知识。</p>
<p>今天的内容是项目的vue3+electron项目搭建和打包部署</p>
</blockquote>
<h3 id="一、Electron-Vue3-Vite搭建"><a href="#一、Electron-Vue3-Vite搭建" class="headerlink" title="一、Electron-Vue3-Vite搭建"></a>一、Electron-Vue3-Vite搭建</h3><h4 id="1-创建模板"><a href="#1-创建模板" class="headerlink" title="1.创建模板"></a>1.创建模板</h4><blockquote>
<p>！！！兼容性注意</p>
<p>Vite 需要 Node.js版本 14.18+，16+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。</p>
</blockquote>
<pre><code class="ini">//使用npm
npm create vite@latest
//使用yarn
yarn create vite
//使用pnpm
pnpm create vite
</code></pre>
<p>使用以下命令启动：</p>
<pre><code class="ini">npm i //安装依赖
npm run dev //启动项目
</code></pre>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221127082439543.png"></p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221127082625854.png"></p>
<h4 id="2-安装electron"><a href="#2-安装electron" class="headerlink" title="2.安装electron"></a>2.安装electron</h4><pre><code class="ini">npm i electron -D 
</code></pre>
<p>目前博主遇到了一个小问题，就是下载electron会一直卡住，这里使用如下方法就可以解决了。</p>
<pre><code class="ini">npm install cnpm -g --registry=https://registry.npm.taobao.org //切换国内镜像源
cnpm isntall electron --save-dev
</code></pre>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128081646599.png"></p>
<h4 id="3-创建入口文件"><a href="#3-创建入口文件" class="headerlink" title="3.创建入口文件"></a>3.创建入口文件</h4><p>根目录下创建</p>
<p>Main.js入口文件</p>
<pre><code class="javascript">//main.js
const &#123; app,BrowserWindow &#125; = require(&#39;electron&#39;)
const path = require(&#39;path&#39;)
const WinState = require(&#39;electron-win-state&#39;).default //保存窗口状态的包（窗口可以保存缩放、位置状态）

const createWindow = () =&gt; &#123;
  const winState = new WinState(&#123; 
    defaultWidth: 1000,
    defaultHeight: 800,
    // other winState options, see below
  &#125;)
    const win = new BrowserWindow(&#123;
      ...winState.winOptions,
      // width: 800,
      // height: 600,
      webPreferences: &#123;
        preload: path.join(__dirname, &#39;preload.js&#39;)
      &#125;
    &#125;)
    win.loadURL(&#39;http://127.0.0.1:5173/&#39;) //加载本地端口，部署的时候可以换成我们的域名
    win.webContents.openDevTools() //打开控制台调试
    winState.manage(win)
  &#125;

  app.whenReady().then(() =&gt; &#123;
    createWindow()
    app.on(&#39;activate&#39;, () =&gt; &#123;
      if (BrowserWindow.getAllWindows().length === 0) createWindow()
    &#125;)
  &#125;) 

  app.on(&#39;window-all-closed&#39;, () =&gt; &#123;
    if (process.platform !== &#39;darwin&#39;) app.quit()
  &#125;)
</code></pre>
<p>Preload.js预加载文件</p>
<pre><code class="javascript">//目前先不写内容，先搭个架子
</code></pre>
<p>配置package.json</p>
<pre><code class="javascript">//package.json
&#123;
  &quot;name&quot;: &quot;vite-project&quot;,
  &quot;private&quot;: true,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;,
    &quot;start&quot;: &quot;nodemon --exec electron . --watch ./ --ext .js,.html,.vue,.css&quot;,
  &#125;,
  &quot;dependencies&quot;: &#123;
    &quot;electron-win-state&quot;: &quot;^1.1.22&quot;,
    &quot;vue&quot;: &quot;^3.2.41&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;@vitejs/plugin-vue&quot;: &quot;^3.2.0&quot;,
    &quot;electron&quot;: &quot;^21.3.1&quot;,
    &quot;electron-builder&quot;: &quot;^23.6.0&quot;,
    &quot;nodemon&quot;: &quot;^2.0.20&quot;,
    &quot;vite&quot;: &quot;^3.2.3&quot;
  &#125;
&#125;

</code></pre>
<h4 id="4-安装其他依赖"><a href="#4-安装其他依赖" class="headerlink" title="4.安装其他依赖"></a>4.安装其他依赖</h4><pre><code class="ini">cnpm install nodemon --save-dev //安装nodemon
cnpm install electron-win-state --save-dev //安装electron-win-state
</code></pre>
<h4 id="5-运行项目"><a href="#5-运行项目" class="headerlink" title="5.运行项目"></a>5.运行项目</h4><pre><code class="ini">npm run dev //启动vue项目
npm start //启动electron
</code></pre>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128085457686.png"></p>
<p>我们现在就可以去开发我们的项目了</p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128085520887.png"></p>
<h3 id="二、打包与部署"><a href="#二、打包与部署" class="headerlink" title="二、打包与部署"></a>二、打包与部署</h3><p>官网推荐我们的是<a target="_blank" rel="noopener" href="https://www.electronjs.org/docs/latest/tutorial/forge-overview">Electron Forge</a>来分发我们的应用程序</p>
<blockquote>
<p>electron-forge 可以自动检测你的系统，然后打包成对应的可执行文件。<br>它可以实现 package 成最终可用的独立项目文件夹，<br>还可以 make 成能够安装的 zip 包</p>
</blockquote>
<p>目前这个方法有一些问题，我们先用另一种方法来进行打包<a target="_blank" rel="noopener" href="https://www.electron.build/">electron-build</a></p>
<p>根据文档我们也可以很快的掌握这种打包方式</p>
<h4 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1.安装依赖"></a>1.安装依赖</h4><pre><code class="ini">cnpm i electron-builder -D //安装依赖
</code></pre>
<p>配置一下package.json</p>
<pre><code class="javascript">//package.json+
&quot;scripts&quot;: &#123;
  ...
  &quot;app:dir&quot;: &quot;electron-builder --dir&quot;,
  &quot;app:dist&quot;: &quot;electron-builder&quot;
  ...
&#125;
</code></pre>
<h4 id="2-打包"><a href="#2-打包" class="headerlink" title="2.打包"></a>2.打包</h4><pre><code class="ini">cnpm run app:dist  //执行打包
</code></pre>
<p>目前我遇到打包错误的问题</p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128115215328.png"></p>
<p>如果我们遇到这种问题，我们切换一下npm镜像源就可以了；</p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128115258224.png"></p>
<p>现在我们打包就成功了</p>
<h4 id="3-运行安装包"><a href="#3-运行安装包" class="headerlink" title="3.运行安装包"></a>3.运行安装包</h4><p>找到我们项目目录下的dist文件的.dmg安装包（我的是mac）</p>
<p>在运行之前，我们应该先将项目 运行 起来（因为我们是本地项目，等部署到服务器就不用了）</p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128115702655.png"></p>
<p>点击执行安装包</p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128115730129.png"></p>
<p><img src="/2022/11/28/electron-vue3-vite/image-20221128115827756.png"></p>
<p>到目前为止，我们的electron的搭建-&gt;开发-&gt;打包就一气呵成了，当然，开发项目中还有许多奇奇怪怪的问题和知识点，就靠各位聪明的脑瓜了。。</p>
<p><img src="/2022/11/28/electron-vue3-vite/tl.webp"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Electron官网]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/docs/latest/tutorial/forge-overview">https://www.electronjs.org/docs/latest/tutorial/forge-overview</a> “<br>[Vite.js官网]: 	“<a target="_blank" rel="noopener" href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a> “<br>[electron-builder]: 	“<a target="_blank" rel="noopener" href="https://github.com/electron-userland/electron-builder">https://github.com/electron-userland/electron-builder</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/electron/" rel="tag">electron</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-threejs-d-1-0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/27/threejs-d-1-0/"
    >threejs-d-1.0</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/27/threejs-d-1-0/" class="article-date">
  <time datetime="2022-11-27T09:51:37.000Z" itemprop="datePublished">2022-11-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3D/">Web3D</a> / <a class="article-category-link" href="/categories/Web3D/Three-js/">Three.js</a> / <a class="article-category-link" href="/categories/Web3D/Three-js/threejs-d-1-0/">threejs-d-1.0</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="threejs-d-1-0"><a href="#threejs-d-1-0" class="headerlink" title="threejs-d-1.0"></a>threejs-d-1.0</h1><blockquote>
<p>d-1.0主要是准备我们开发环境和其他的一些准备，为了我们更好的去进入three的世界</p>
</blockquote>
<h3 id="一、搭建three-js本地网站"><a href="#一、搭建three-js本地网站" class="headerlink" title="一、搭建three.js本地网站"></a>一、搭建three.js本地网站</h3><blockquote>
<p>搭建本地网站的原因，是因为我们访问官网的时候，由于网速限制，导致我们的体验感下降，搭建本地服务器，快很多了。</p>
</blockquote>
<p>我们打开官网<a target="_blank" rel="noopener" href="https://threejs.org/">Three.js</a>点击github就进入了threejs仓库了</p>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127171040581.png"></p>
<p>我们下载仓库的dev开发包</p>
<p>git clone 和 下载压缩包都可以！</p>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127171152583.png"></p>
<p>执行命令运行：</p>
<pre><code class="ini">npm i //安装依赖
npm start //运行项目
</code></pre>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127171346283.png"></p>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127171325067.png"></p>
<p>我们现在访问本地项目就快多了，我们想知道任何一个例子也可以查看其具体的文件了。</p>
<h3 id="二、使用parcel搭建threejs开发环境"><a href="#二、使用parcel搭建threejs开发环境" class="headerlink" title="二、使用parcel搭建threejs开发环境"></a>二、使用<a target="_blank" rel="noopener" href="https://parceljs.org/">parcel</a>搭建threejs开发环境</h3><pre><code class="ini">npm init -y //初始化项目
npm install  parcel-bundler -D //安装parcel
</code></pre>
<p>设置入口文件main.js和index.html</p>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127173957450.png"></p>
<p>配置package.json</p>
<pre><code class="javascript">//package.json
&#123;
  &quot;name&quot;: &quot;threejs&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;dev&quot;: &quot;parcel ./src/index.html&quot;,
    &quot;build&quot;: &quot;parcel build ./src/index.html&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: &#123;
    &quot;parcel-bundler&quot;: &quot;^1.12.5&quot;
  &#125;
&#125;
</code></pre>
<p>下载threejs依赖</p>
<pre><code class="ini">npm install three --save //安装依赖
</code></pre>
<pre><code class="javascript">//main.js
import * as THREE from &#39;three&#39;
console.log(THREE)
</code></pre>
<p>运行项目，打包项目</p>
<pre><code class="ini">npm run dev //运行项目
npm run build //打包项目
</code></pre>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127174654769.png"></p>
<p><img src="/2022/11/27/threejs-d-1-0/image-20221127174742984.png"></p>
<p>运行成功！！！</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Three.js官网]: 	“<a target="_blank" rel="noopener" href="https://threejs.org/">https://threejs.org/</a> “<br>[Three.js-github]: 	“<a target="_blank" rel="noopener" href="https://github.com/mrdoob/three.js/">https://github.com/mrdoob/three.js/</a> “<br>[parcel官网]: 	“<a target="_blank" rel="noopener" href="https://parceljs.org/&quot;">https://parceljs.org/&quot;</a><br>[parcel中文官网]: 	“<a target="_blank" rel="noopener" href="https://www.parceljs.cn/">https://www.parceljs.cn/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/three-js/" rel="tag">three.js</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Electron-d-3-0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/26/Electron-d-3-0/"
    >Electron-d-3.0</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/26/Electron-d-3-0/" class="article-date">
  <time datetime="2022-11-26T02:26:43.000Z" itemprop="datePublished">2022-11-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a> / <a class="article-category-link" href="/categories/Electron/Electron-d-3-0/">Electron-d-3.0</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Electron-d-3-0"><a href="#Electron-d-3-0" class="headerlink" title="Electron-d-3.0"></a>Electron-d-3.0</h1><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><p>上一篇我们讲解了主进程的一些常用API，这一篇我们接着来讲解渲染进程的API</p>
<h3 id="1-剪切板（clipboard）"><a href="#1-剪切板（clipboard）" class="headerlink" title="1.剪切板（clipboard）"></a>1.剪切板（clipboard）</h3><blockquote>
<p>在系统剪贴板上执行复制和粘贴操作。</p>
<p>主进程和渲染进程都可以用。</p>
</blockquote>
<p>（1）<code>clipboard.readText([type])</code></p>
<ul>
<li><code>type</code> string (optional) -可以是 <code>selection</code> 或 <code>clipboard</code>; 默认为 ‘clipboard’. <code>selection</code> 仅在 Linux 中可用。</li>
</ul>
<p>返回 <code>string</code> - 剪贴板中的内容为纯文本。</p>
<pre><code class="javascript">const &#123; clipboard &#125; = require(&#39;electron&#39;)

clipboard.writeText(&#39;hello i am a bit of text!&#39;)

const text = clipboard.readText()
console.log(text)
// hello i am a bit of text!&#39;
</code></pre>
<p>（2）<code>clipboard.writeText(text[, type])</code></p>
<ul>
<li><code>text</code> string</li>
<li><code>type</code> string (optional) -可以是 <code>selection</code> 或 <code>clipboard</code>; 默认为 ‘clipboard’. <code>selection</code> 仅在 Linux 中可用。</li>
</ul>
<p>将 <code>text</code> 作为纯文本写入剪贴板。</p>
<pre><code class="javascript">const &#123; clipboard &#125; = require(&#39;electron&#39;)

const text = &#39;hello i am a bit of text!&#39;
clipboard.writeText(text)
</code></pre>
<p>我们剪切板的API就说这两个读与写。但是我在渲染进程里读不到clipboard。</p>
<p>[clipboard文档]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/clipboard">https://www.electronjs.org/zh/docs/latest/api/clipboard</a> “</p>
<h3 id="2-contextBridge"><a href="#2-contextBridge" class="headerlink" title="2.contextBridge"></a>2.contextBridge</h3><p>在隔离的上下文中创建一个安全的、双向的、同步的桥梁。</p>
<p>如下，是一个从隔离的预加载脚本将 API 暴露给渲染器的示例：（通过预加载脚本暴露API，渲染进程可以读取）</p>
<pre><code class="javascript">// Preload (Isolated World)
const &#123; contextBridge, ipcRenderer &#125; = require(&#39;electron&#39;)

contextBridge.exposeInMainWorld(
  &#39;electron&#39;,
  &#123;
    doThing: () =&gt; ipcRenderer.send(&#39;do-a-thing&#39;)
  &#125;
)
</code></pre>
<pre><code class="javascript">// Renderer (Main World)

window.electron.doThing()
</code></pre>
<p>[contextBridge文档]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/context-bridge">https://www.electronjs.org/zh/docs/latest/api/context-bridge</a> “</p>
<h3 id="3-desktopCapturer"><a href="#3-desktopCapturer" class="headerlink" title="3.desktopCapturer"></a>3.desktopCapturer</h3><p>官方文档给的案例不是特别容易理解，代码有点长。</p>
<blockquote>
<p>虽然官方文档的主进程和渲染进程都有desktopCapturer，但是渲染进程是访问不到的</p>
</blockquote>
<p>我们举一个抓取页面内容的荔枝吧！</p>
<p><img src="/2022/11/26/Electron-d-3-0/image-20221126093410069.png"></p>
<pre><code class="javascript">//main.js+
 ipcMain.handle(&#39;capture-event&#39;,async (event,args)=&gt;&#123;
      return  desktopCapturer.getSources(&#123; types: [&#39;window&#39;, &#39;screen&#39;] &#125;).then( sources =&gt; &#123;
        return sources
      &#125;)
 &#125;)
//解释一下，desktopCapturer.getSources返回的是一个Promise的对象
</code></pre>
<pre><code class="javascript">//preload.js+

  const capture = async ()=&gt;&#123;
    let res = await ipcRenderer.invoke(&#39;capture-event&#39;)
    console.log(res)
  &#125;
  
  contextBridge.exposeInMainWorld(&#39;electronAPI&#39;, &#123;
    capture
&#125;)
</code></pre>
<pre><code class="javascript">//app.js+
const btn = document.getElementById(&#39;btn&#39;)
btn.addEventListener(&#39;click&#39;,()=&gt;&#123;
    window.electronAPI.capture()
&#125;)
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
    &lt;title&gt;capture&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button id=&quot;btn&quot;&gt;capture&lt;/button&gt;
    &lt;script src=&#39;./renderer/app.js&#39;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>当我们点击页面上的按钮的时候，我们就会打印出窗口信息，由下图可以看出sources是一个数组</p>
<p><img src="/2022/11/26/Electron-d-3-0/image-20221126093927866.png"></p>
<p>我们现在就可以根据我们获取到的信息去干一些事情了。</p>
<pre><code class="javascript">//preload.js+
  const capture = async ()=&gt;&#123;
    let sources = await ipcRenderer.invoke(&#39;capture-event&#39;)
    for (const source of sources) &#123;
      if (source.name === &#39;electron&#39;) &#123;
        let str = source.thumbnail.crop(&#123;x:0,y:0,width:300,height:300&#125;)
        let imgUrl = str.toDataURL()
        return imgUrl //返回的是一个Promise
      &#125;
    &#125;
  &#125;

  contextBridge.exposeInMainWorld(&#39;electronAPI&#39;, &#123;
    handleCounter: (callback) =&gt; ipcRenderer.on(&#39;update-counter&#39;, callback),
    capture,
&#125;)
</code></pre>
<pre><code class="javascript">//app.js+
const btn = document.getElementById(&#39;btn&#39;)
btn.addEventListener(&#39;click&#39;,async ()=&gt;&#123;
   let imgUrl = await window.electronAPI.capture()
   console.log(imgUrl)
&#125;)
</code></pre>
<p><img src="/2022/11/26/Electron-d-3-0/image-20221126100006800.png"></p>
<p>我们在渲染进程这就已经拿到了我们的数据</p>
<p>接下来我们就将我们的数据填充到我们的页面之中</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;;img-src * data:&quot;&gt;
    &lt;title&gt;Menu Counter&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- Current value: &lt;strong id=&quot;counter&quot;&gt;0&lt;/strong&gt; --&gt;
    &lt;button id=&quot;btn&quot;&gt;capture&lt;/button&gt;
    &lt;img src=&quot;&quot; alt=&quot;捕获数据&quot; id=&quot;img&quot;&gt;
    &lt;script src=&#39;./renderer/app.js&#39;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="javascript">//app.js+
const btn = document.getElementById(&#39;btn&#39;)

btn.addEventListener(&#39;click&#39;,async ()=&gt;&#123;
   let imgUrl = await window.electronAPI.capture()
   document.getElementById(&#39;img&#39;).src = imgUrl
&#125;)
</code></pre>
<p><img src="/2022/11/26/Electron-d-3-0/image-20221126101223120.png"></p>
<p>恭喜你！！！成功了🥳🥳🥳</p>
<p>[desktopCapturer文档]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/desktop-capturer&quot;">https://www.electronjs.org/zh/docs/latest/api/desktop-capturer&quot;</a></p>
<h3 id="4-nativeImage"><a href="#4-nativeImage" class="headerlink" title="4.nativeImage"></a>4.nativeImage</h3><blockquote>
<p>使用 PNG 或 JPG 文件创建托盘、dock和应用程序图标。</p>
<p>主进程和渲染进程都可以用。</p>
</blockquote>
<p>在 Electron 内, 那些需要图片的 API 可以传递两种参数, 一种是文件路径, 一种是 <code>NativeImage</code> 实例对象。 空的图片对象将被 <code>null</code> 参数替代</p>
<p>例如, 创建托盘或设置窗口图标时, 你可以传递 <code>string</code> 格式的图片路径</p>
<pre><code class="javascript">const &#123; BrowserWindow, Tray &#125; = require(&#39;electron&#39;)

const appIcon = new Tray(&#39;/Users/somebody/images/icon.png&#39;)
const win = new BrowserWindow(&#123; icon: &#39;/Users/somebody/images/window.png&#39; &#125;)
console.log(appIcon, win)
</code></pre>
<p>或者从粘贴板读取图片，将返回 <code>NativeImage</code> 对象：</p>
<pre><code class="javascript">const &#123; clipboard, Tray &#125; = require(&#39;electron&#39;)
const image = clipboard.readImage()
const appIcon = new Tray(image)
console.log(appIcon)
</code></pre>
<p>我们文档里还有其他的一些关于NativeImage对象的属性和方法，我们就哪里需要哪里搬。</p>
<p>[nativeImage文档]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/native-image">https://www.electronjs.org/zh/docs/latest/api/native-image</a> “</p>
<p>到目前为止，我们对于electron的学习先到这，如果我的这几篇文章都认认真真的看完了，那么我们也对electron有了进一步认识。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Electron官网]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/">https://www.electronjs.org/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/electron/" rel="tag">electron</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Electron-d-2-0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/25/Electron-d-2-0/"
    >Electron-d-2.0</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/25/Electron-d-2-0/" class="article-date">
  <time datetime="2022-11-25T09:31:05.000Z" itemprop="datePublished">2022-11-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a> / <a class="article-category-link" href="/categories/Electron/Electron-d-2-0/">Electron-d-2.0</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h1><p>本篇文章接上一篇文章，详细讲解主进程和渲染进程一些常用的API</p>
<h3 id="主进程API"><a href="#主进程API" class="headerlink" title="主进程API"></a>主进程API</h3><h4 id="1-App-BrowserWindow"><a href="#1-App-BrowserWindow" class="headerlink" title="1.App+BrowserWindow"></a>1.App+BrowserWindow</h4><h5 id="App事件："><a href="#App事件：" class="headerlink" title="App事件："></a>App事件：</h5><h6 id="（1）Before-quit"><a href="#（1）Before-quit" class="headerlink" title="（1）Before-quit"></a>（1）Before-quit</h6><ul>
<li><code>event</code> Event #返回</li>
</ul>
<p> 在程序关闭窗口前触发（macOS不是关闭窗口触发，而是关闭程序）</p>
<p>**注:**在 Windows 系统中，如果应用程序因系统关机&#x2F;重启或用户注销而关闭，那么这个事件不会被触发。</p>
<p>代码以及程序演示：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125085755781.png"></p>
<h6 id="（2）browser-window-blur"><a href="#（2）browser-window-blur" class="headerlink" title="（2）browser-window-blur"></a>（2）browser-window-blur</h6><ul>
<li><code>event</code> Event #返回</li>
<li><code>window</code> BrowserWindow #返回</li>
</ul>
<p>当一个 browserWindow （窗口）失去焦点时触发。当我们鼠标点击窗口以外的地方就会失焦。</p>
<p>代码以及程序演示：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125090204480.png"></p>
<h6 id="（3）browser-window-focus"><a href="#（3）browser-window-focus" class="headerlink" title="（3）browser-window-focus"></a>（3）browser-window-focus</h6><ul>
<li><code>event</code> Event #返回</li>
<li><code>window</code> BrowserWindow #返回</li>
</ul>
<p>当一个 browserWindow 获得焦点时触发。</p>
<p>代码以及程序演示：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125090450485.png"></p>
<h6 id="（4）quit"><a href="#（4）quit" class="headerlink" title="（4）quit"></a>（4）quit</h6><ul>
<li><code>event</code> Event #返回</li>
<li><code>exitCode</code> Integer #返回</li>
</ul>
<p>在应用程序退出时发出。</p>
<p>**注:**在 Windows 系统中，如果应用程序因系统关机&#x2F;重启或用户注销而关闭，那么这个事件不会被触发。</p>
<p>代码以及程序演示：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125090654139.png"></p>
<h6 id="（5）window-all-closed"><a href="#（5）window-all-closed" class="headerlink" title="（5）window-all-closed"></a>（5）window-all-closed</h6><p>当所有的窗口都被关闭时触发。</p>
<p>如果你没有监听此事件并且所有窗口都关闭了，默认的行为是控制退出程序；但如果你监听了此事件，你可以控制是否退出程序。 如果用户按下了 <code>Cmd + Q</code>，或者开发者调用了 <code>app.quit()</code>，Electron 会首先关闭所有的窗口然后触发 <code>will-quit</code> 事件，在这种情况下 <code>window-all-closed</code>事件不会被触发。</p>
<p>代码以及程序演示：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125090909458.png"></p>
<h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><p>由于各种app.方法使用频率都差不多，那么我们根据需要看官方文档吧（也比较容易看懂）</p>
<p>[App.方法 文档]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/app#%E6%96%B9%E6%B3%95">https://www.electronjs.org/zh/docs/latest/api/app#方法</a> “</p>
<h5 id="BrowserWindow："><a href="#BrowserWindow：" class="headerlink" title="BrowserWindow："></a>BrowserWindow：</h5><p><code>BrowserWindow</code> 类暴露了各种方法来修改应用窗口的外观和行为</p>
<h6 id="（1）优雅的打开窗口"><a href="#（1）优雅的打开窗口" class="headerlink" title="（1）优雅的打开窗口"></a>（1）优雅的打开窗口</h6><p><code>ready-to-show</code> 事件</p>
<p>在加载页面时，渲染进程第一次完成绘制时，如果窗口还没有被显示，渲染进程会发出 <code>ready-to-show</code> 事件 。 在此事件后显示窗口将没有视觉闪烁：（不会有白屏出现，但如果绘制没有完成，窗口出现的时间也会延长，根据业务需求来选择是否要选择这种优雅的打开窗口方式）</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125093133167.png"></p>
<p>这个事件通常在 <code>did-finish-load</code> 事件之后发出，但是页面有许多远程资源时，它可能会在 <code>did-finish-load</code>之前发出事件。</p>
<p><code>backgroundColor</code>属性</p>
<p>对于一个复杂的应用，<code>ready-to-show</code> 可能发出的太晚，会让应用感觉缓慢。 在这种情况下，建议立刻显示窗口，并使用接近应用程序背景的 <code>backgroundColor</code></p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125093813389.png"></p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125093827541.png"></p>
<p>建议 设置 <code>backgroundColor</code>和 <code>ready-to-show</code> 事件一起用，以使应用感觉更接近原生。</p>
<pre><code class="javascript">//backgroundColor有效值
const win = new BrowserWindow()
win.setBackgroundColor(&#39;hsl(230, 100%, 50%)&#39;)
win.setBackgroundColor(&#39;rgb(255, 145, 145)&#39;)
win.setBackgroundColor(&#39;#ff00a3&#39;)
win.setBackgroundColor(&#39;blueviolet&#39;)
</code></pre>
<h6 id="（2）父子窗口-amp-amp-模态窗口"><a href="#（2）父子窗口-amp-amp-模态窗口" class="headerlink" title="（2）父子窗口&amp;&amp;模态窗口"></a>（2）父子窗口&amp;&amp;模态窗口</h6><p>父子窗口：</p>
<p>通过使用 <code>parent</code> 选项，你可以创建子窗口：</p>
<pre><code class="javascript">const &#123; BrowserWindow &#125; = require(&#39;electron&#39;)

const top = new BrowserWindow()
const child = new BrowserWindow(&#123; parent: top &#125;)
child.show()
top.show()
</code></pre>
<p><code>child</code> 窗口将总是显示在 <code>top</code> 窗口的顶部.</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125094829288.png"></p>
<p>模态窗口</p>
<p>模态窗口是禁用父窗口的子窗口，创建模态窗口必须设置 <code>parent</code> 和 <code>modal</code> 选项：</p>
<pre><code class="javascript">const &#123; BrowserWindow &#125; = require(&#39;electron&#39;)

const child = new BrowserWindow(&#123; parent: top, modal: true, show: false &#125;)
child.loadURL(&#39;https://github.com&#39;)
child.once(&#39;ready-to-show&#39;, () =&gt; &#123;
  child.show()
&#125;)
</code></pre>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125095057232.png"></p>
<h6 id="（3）BrowserWindow属性"><a href="#（3）BrowserWindow属性" class="headerlink" title="（3）BrowserWindow属性"></a>（3）BrowserWindow属性</h6><p>这个BrowserWindow属性 比较多，而且都是设置窗口的一些属性，也是不难理解，我们就对照我们的官方文档来学习吧！</p>
<p>[BrowserWindow属性]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/browser-window#new-browserwindowoptions">https://www.electronjs.org/zh/docs/latest/api/browser-window#new-browserwindowoptions</a> “</p>
<h6 id="（4）webContents"><a href="#（4）webContents" class="headerlink" title="（4）webContents"></a>（4）webContents</h6><p><code>did-finish-load</code> 事件</p>
<p>导航完成时触发，即选项卡的旋转器将停止旋转，并指派<code>onload</code>事件后。</p>
<p>[webContents类实例事件]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/web-contents#%E7%B1%BB-webcontents">https://www.electronjs.org/zh/docs/latest/api/web-contents#类-webcontents</a> “</p>
<h6 id="（5）保存窗口状态"><a href="#（5）保存窗口状态" class="headerlink" title="（5）保存窗口状态"></a>（5）保存窗口状态</h6><p>当我们使用桌面程序的时候，那么我们有时候希望我们关闭程序再次打开程序的时候，程序的界面和状态能够是我们关闭前的样子，不希望再去重新设置。那我们就需要一个包<code>electron-win-state</code> </p>
<p>安装这个包</p>
<pre><code class="ini">npm i electron-win-state -S
</code></pre>
<p>我们可以在npmjs官网上找到这个包，去看它的说明文档</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125101014250.png"></p>
<p>根据使用说明，我们代码如下：</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125101245297.png"></p>
<p>我们发现报错了，WinState is not a constructor</p>
<p>当我们打印一下WinState看看什么情况</p>
<pre><code class="javascript">const WinState = require(&#39;electron-win-state&#39;)
console.log(WinState)
</code></pre>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125101446532.png"></p>
<p>发现没有直接引入WinState，我们修改一下</p>
<pre><code class="javascript">const WinState = require(&#39;electron-win-state&#39;).default 
</code></pre>
<p>现在就没报错了。</p>
<p>但是我们发现，虽然安装了这个包，但是我们程序的状态还是没有改变，这就很奇怪了，其实，是我们自己已经给窗口设置了自定义宽高，覆盖了。我们也缺了一句代码；</p>
<pre><code class="javascript"> winState.manage(win)
</code></pre>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125102737449.png"></p>
<p>现在我们的状态保存就没问题了。当我们关闭窗口再次打开的时候就是关闭之前的样子了。</p>
<h4 id="2-dialog"><a href="#2-dialog" class="headerlink" title="2.dialog"></a>2.dialog</h4><p>这些具体参数请看官方文档，下面几个方法返回一个promise对象</p>
<h6 id="（1）dialog-showOpenDialog-browserWindow-options"><a href="#（1）dialog-showOpenDialog-browserWindow-options" class="headerlink" title="（1）dialog.showOpenDialog([browserWindow, ]options)"></a>（1）<code>dialog.showOpenDialog([browserWindow, ]options)</code></h6><h6 id="（2）dialog-showSaveDialog-browserWindow-options"><a href="#（2）dialog-showSaveDialog-browserWindow-options" class="headerlink" title="（2）dialog.showSaveDialog([browserWindow, ]options)"></a>（2）<code>dialog.showSaveDialog([browserWindow, ]options)</code></h6><h6 id="（3）dialog-showMessageBox-browserWindow-options"><a href="#（3）dialog-showMessageBox-browserWindow-options" class="headerlink" title="（3）dialog.showMessageBox([browserWindow, ]options)"></a>（3）<code>dialog.showMessageBox([browserWindow, ]options)</code></h6><p>[dialog文档]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/dialog#dialogshowopendialogsyncbrowserwindow-options">https://www.electronjs.org/zh/docs/latest/api/dialog#dialogshowopendialogsyncbrowserwindow-options</a> “</p>
<h4 id="3-快捷键（globalShortcut）"><a href="#3-快捷键（globalShortcut）" class="headerlink" title="3.快捷键（globalShortcut）"></a>3.快捷键（globalShortcut）</h4><blockquote>
<p>在应用程序没有键盘焦点时，监听键盘事件。</p>
</blockquote>
<p><code>globalShortcut</code> 模块可以在操作系统中注册&#x2F;注销全局快捷键, 以便可以为操作定制各种快捷键。</p>
<p><strong>注意:</strong> 快捷方式是全局的; 即使应用程序没有键盘焦点, 它也仍然在持续监听键盘事件。 在 app 模块的 <code>ready</code> 事件就绪之前，这个模块不能使用。</p>
<pre><code class="javascript">const &#123; app, globalShortcut &#125; = require(&#39;electron&#39;)

app.whenReady().then(() =&gt; &#123;
  // 注册一个&#39;CommandOrControl+X&#39; 快捷键监听器
  const ret = globalShortcut.register(&#39;CommandOrControl+X&#39;, () =&gt; &#123;
    console.log(&#39;CommandOrControl+X is pressed&#39;)
  &#125;)

  if (!ret) &#123;
    console.log(&#39;registration failed&#39;)
  &#125;

  // 检查快捷键是否注册成功
  console.log(globalShortcut.isRegistered(&#39;CommandOrControl+X&#39;))
&#125;)

app.on(&#39;will-quit&#39;, () =&gt; &#123;
  // 注销快捷键
  globalShortcut.unregister(&#39;CommandOrControl+X&#39;)

  // 注销所有快捷键
  globalShortcut.unregisterAll()
&#125;)
</code></pre>
<p>方法</p>
<p><code>globalShortcut</code> 模块具有以下方法:</p>
<h6 id="（1）globalShortcut-register-accelerator-callback"><a href="#（1）globalShortcut-register-accelerator-callback" class="headerlink" title="（1）globalShortcut.register(accelerator, callback)"></a>（1）<code>globalShortcut.register(accelerator, callback)</code></h6><ul>
<li><code>accelerator</code> Accelerator</li>
<li><code>callback</code> Function</li>
</ul>
<p>返回<code>boolean</code> - 快捷键注册是否成功</p>
<p>注册 <code>accelerator</code> 的全局快捷键。 当用户按下注册快捷键时， <code>callback</code> 会被调用。</p>
<p>如果指定的快捷键已经被其他应用程序注册掉, 调用会默默失败。 该特性由操作系统定义，因为操作系统不希望多个程序的全局快捷键互相冲突。</p>
<p>在 macOS 10.14 Mojave 下面，如果 app 没有被授权为可信任使用的客户端，那么下列快捷键会注册失败：</p>
<ul>
<li>“Media Play&#x2F;Pause”</li>
<li>“Media Next Track”</li>
<li>“Media Previous Track”</li>
<li>“Media Stop”</li>
</ul>
<h6 id="（2）globalShortcut-registerAll-accelerators-callback"><a href="#（2）globalShortcut-registerAll-accelerators-callback" class="headerlink" title="（2）globalShortcut.registerAll(accelerators, callback)"></a>（2）<code>globalShortcut.registerAll(accelerators, callback)</code></h6><ul>
<li><code>accelerators</code> string[] - an array of Accelerators.</li>
<li><code>callback</code> Function</li>
</ul>
<p>注册多个全局快捷键。 当用户按下注册快捷键时， <code>callback</code> 会被调用。</p>
<p>如果定义的快捷键已经被其他应用占用，这个调用会失效。 该特性由操作系统定义，因为操作系统不希望多个程序的全局快捷键互相冲突。</p>
<p>在 macOS 10.14 Mojave 下面，如果 app 没有被授权为可信任使用的客户端，那么下列快捷键会注册失败：</p>
<ul>
<li>“Media Play&#x2F;Pause”</li>
<li>“Media Next Track”</li>
<li>“Media Previous Track”</li>
<li>“Media Stop”</li>
</ul>
<h6 id="（3）globalShortcut-isRegistered-accelerator"><a href="#（3）globalShortcut-isRegistered-accelerator" class="headerlink" title="（3）globalShortcut.isRegistered(accelerator)"></a>（3）<code>globalShortcut.isRegistered(accelerator)</code></h6><ul>
<li><code>accelerator</code> Accelerator</li>
</ul>
<p>Returns <code>boolean</code> - 表示 <code>accelerator</code> 全局快捷键是否注册成功</p>
<p>当快捷键已经被其他应用程序注册时, 此调用依然将返回 <code>false</code>。 该特性由操作系统定义，因为操作系统不希望多个程序的全局快捷键互相冲突。</p>
<h6 id="（4）globalShortcut-unregister-accelerator"><a href="#（4）globalShortcut-unregister-accelerator" class="headerlink" title="（4）globalShortcut.unregister(accelerator)"></a>（4）<code>globalShortcut.unregister(accelerator)</code></h6><ul>
<li><code>accelerator</code> Accelerator</li>
</ul>
<p>注销 <code>accelerator</code> 的全局快捷键。</p>
<h6 id="（5）globalShortcut-unregisterAll"><a href="#（5）globalShortcut-unregisterAll" class="headerlink" title="（5）globalShortcut.unregisterAll()"></a>（5）<code>globalShortcut.unregisterAll()</code></h6><p>注销所有的全局快捷键（清空该应用程序的所有全局快捷键）。</p>
<h4 id="4-菜单（Menu）"><a href="#4-菜单（Menu）" class="headerlink" title="4.菜单（Menu）"></a>4.菜单（Menu）</h4><p>我们这举个例子：</p>
<pre><code class="javascript">//一个简单的菜单模板
const &#123; app, Menu &#125; = require(&#39;electron&#39;)

const isMac = process.platform === &#39;darwin&#39;//判断是不是macOS
//role：菜单选项
const template = [
  // &#123; role: &#39;appMenu&#39; &#125;
  ...(isMac ? [&#123;
    label: app.name,//我们程序名称
    submenu: [
      &#123; role: &#39;about&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;services&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;hide&#39; &#125;,
      &#123; role: &#39;hideOthers&#39; &#125;,
      &#123; role: &#39;unhide&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;quit&#39; &#125;
    ]
  &#125;] : []),
  // &#123; role: &#39;fileMenu&#39; &#125;
  &#123;
    label: &#39;File&#39;,
    submenu: [
      isMac ? &#123; role: &#39;close&#39; &#125; : &#123; role: &#39;quit&#39; &#125;
    ]
  &#125;,
  // &#123; role: &#39;editMenu&#39; &#125;
  &#123;
    label: &#39;Edit&#39;,
    submenu: [
      &#123; role: &#39;undo&#39; &#125;,
      &#123; role: &#39;redo&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;cut&#39; &#125;,
      &#123; role: &#39;copy&#39; &#125;,
      &#123; role: &#39;paste&#39; &#125;,
      ...(isMac ? [
        &#123; role: &#39;pasteAndMatchStyle&#39; &#125;,
        &#123; role: &#39;delete&#39; &#125;,
        &#123; role: &#39;selectAll&#39; &#125;,
        &#123; type: &#39;separator&#39; &#125;,//分割线
        &#123;
          label: &#39;Speech&#39;,
          submenu: [
            &#123; role: &#39;startSpeaking&#39; &#125;,
            &#123; role: &#39;stopSpeaking&#39; &#125;
          ]
        &#125;
      ] : [
        &#123; role: &#39;delete&#39; &#125;,
        &#123; type: &#39;separator&#39; &#125;,//分割线
        &#123; role: &#39;selectAll&#39; &#125;
      ])
    ]
  &#125;,
  // &#123; role: &#39;viewMenu&#39; &#125;
  &#123;
    label: &#39;View&#39;,
    submenu: [
      &#123; role: &#39;reload&#39; &#125;,
      &#123; role: &#39;forceReload&#39; &#125;,
      &#123; role: &#39;toggleDevTools&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;resetZoom&#39; &#125;,
      &#123; role: &#39;zoomIn&#39; &#125;,
      &#123; role: &#39;zoomOut&#39; &#125;,
      &#123; type: &#39;separator&#39; &#125;,//分割线
      &#123; role: &#39;togglefullscreen&#39; &#125;
    ]
  &#125;,
  // &#123; role: &#39;windowMenu&#39; &#125;
  &#123;
    label: &#39;Window&#39;,
    submenu: [
      &#123; role: &#39;minimize&#39; &#125;,
      &#123; role: &#39;zoom&#39; &#125;,
      ...(isMac ? [
        &#123; type: &#39;separator&#39; &#125;,//分割线
        &#123; role: &#39;front&#39; &#125;,
        &#123; type: &#39;separator&#39; &#125;,//分割线
        &#123; role: &#39;window&#39; &#125;
      ] : [
        &#123; role: &#39;close&#39; &#125;
      ])
    ]
  &#125;,
  &#123;
    role: &#39;help&#39;,
    submenu: [
      &#123;
        label: &#39;Learn More&#39;,
        click: async () =&gt; &#123;
          //定义自己的菜单方法
          const &#123; shell &#125; = require(&#39;electron&#39;)
          await shell.openExternal(&#39;https://electronjs.org&#39;)
        &#125;
      &#125;,
      &#123;
        label:&#39;alanmf&#39;,
          click:()=&gt;&#123;console.log(&#39;shift+G&#39;)&#125;,
          accelerator:&#39;shift+G&#39;//定义快捷键
      &#125;
    ]
  &#125;
]

const menu = Menu.buildFromTemplate(template)//一般来说， template是一个options类型的数组，用于构建MenuItem。 使用方法可参考前文。还可以将其他字段附加到template，它们将成为菜单项的属性。
Menu.setApplicationMenu(menu)//在macOS上将 menu设置成应用内菜单 在windows和Linux上，menu 将会被设置成窗口顶部菜单在Windows和Linux中
</code></pre>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125155603331.png"></p>
<p>[Menu菜单文档]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/menu">https://www.electronjs.org/zh/docs/latest/api/menu</a> “<br>[role的属性值]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/menu-item#%E8%A7%92%E8%89%B2">https://www.electronjs.org/zh/docs/latest/api/menu-item#角色</a> “</p>
<h4 id="5-系统托盘（Tray）"><a href="#5-系统托盘（Tray）" class="headerlink" title="5.系统托盘（Tray）"></a>5.系统托盘（Tray）</h4><blockquote>
<p>添加图标和上下文菜单到系统通知区</p>
</blockquote>
<pre><code class="javascript">const &#123; app, Menu, Tray &#125; = require(&#39;electron&#39;)

let tray = null
app.whenReady().then(() =&gt; &#123;
  tray = new Tray(&#39;/path/to/my/icon&#39;) //定义icon的路径
  const contextMenu = Menu.buildFromTemplate([
    &#123; label: &#39;Item1&#39;, type: &#39;radio&#39; &#125;,
    &#123; label: &#39;Item2&#39;, type: &#39;radio&#39; &#125;,
    &#123; label: &#39;Item3&#39;, type: &#39;radio&#39;, checked: true &#125;,
    &#123; label: &#39;Item4&#39;, type: &#39;radio&#39; &#125;
  ])
  tray.setToolTip(&#39;This is my application.&#39;)//设置鼠标指针在托盘图标上悬停时显示的文本
  tray.setContextMenu(contextMenu)//设置上下文菜单到托盘
&#125;)
</code></pre>
<p>其实这个Tray跟Menu是布局差不太多的，所以学习起来也不是很难理解了。具体事件和方法也不是特别多，我们就直接看官方API文档吧！</p>
<p>[Tray文档]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/tray">https://www.electronjs.org/zh/docs/latest/api/tray</a> “</p>
<h4 id="6-触控板（TouchBar）"><a href="#6-触控板（TouchBar）" class="headerlink" title="6.触控板（TouchBar）"></a>6.触控板（TouchBar）</h4><p><strong>注意:</strong> TouchBar API目前为实验性质，可能会更改或删除。</p>
<p>如果官网推荐的TouchBar模拟器下载失败，自己搜索一下即可。（如果下载的打不开，那就在应用程序-&gt;右键显示包内容-&gt;如下）执行就可以了</p>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125172856290.png"></p>
<pre><code class="javascript">//touchbar.js
const &#123; app, BrowserWindow, TouchBar &#125; = require(&#39;electron&#39;)

const &#123; TouchBarLabel, TouchBarButton, TouchBarSpacer &#125; = TouchBar

let spinning = false

// 类似老虎机的滚轴标签
const reel1 = new TouchBarLabel()
const reel2 = new TouchBarLabel()
const reel3 = new TouchBarLabel()

// 旋转结果标签
const result = new TouchBarLabel()

// 旋转按钮
const spin = new TouchBarButton(&#123;
  label: &#39;🎰 Spin&#39;,
  backgroundColor: &#39;#7851A9&#39;,
  click: () =&gt; &#123;
    // Ignore clicks if already spinning
    if (spinning) &#123;
      return
    &#125;

    spinning = true
    result.label = &#39;&#39;

    let timeout = 10
    const spinLength = 4 * 1000 // 4 seconds
    const startTime = Date.now()

    const spinReels = () =&gt; &#123;
      updateReels()

      if ((Date.now() - startTime) &gt;= spinLength) &#123;
        finishSpin()
      &#125; else &#123;
        // Slow down a bit on each spin
        timeout *= 1.1
        setTimeout(spinReels, timeout)
      &#125;
    &#125;

    spinReels()
  &#125;
&#125;)

const getRandomValue = () =&gt; &#123;
  const values = [&#39;🍒&#39;, &#39;💎&#39;, &#39;7️⃣&#39;, &#39;🍊&#39;, &#39;🔔&#39;, &#39;⭐&#39;, &#39;🍇&#39;, &#39;🍀&#39;]
  return values[Math.floor(Math.random() * values.length)]
&#125;

const updateReels = () =&gt; &#123;
  reel1.label = getRandomValue()
  reel2.label = getRandomValue()
  reel3.label = getRandomValue()
&#125;

const finishSpin = () =&gt; &#123;
  const uniqueValues = new Set([reel1.label, reel2.label, reel3.label]).size
  if (uniqueValues === 1) &#123;
    // All 3 values are the same
    result.label = &#39;💰 Jackpot!&#39;
    result.textColor = &#39;#FDFF00&#39;
  &#125; else if (uniqueValues === 2) &#123;
    // 2个值相同
    result.label = &#39;😍 Winner!&#39;
    result.textColor = &#39;#FDFF00&#39;
  &#125; else &#123;
    // 没有值相同
    result.label = &#39;🙁 Spin Again&#39;
    result.textColor = null
  &#125;
  spinning = false
&#125;

const touchBar = new TouchBar(&#123;
  items: [
    spin,
    new TouchBarSpacer(&#123; size: &#39;large&#39; &#125;),
    reel1,
    new TouchBarSpacer(&#123; size: &#39;small&#39; &#125;),
    reel2,
    new TouchBarSpacer(&#123; size: &#39;small&#39; &#125;),
    reel3,
    new TouchBarSpacer(&#123; size: &#39;large&#39; &#125;),
    result
  ]
&#125;)

let window

app.whenReady().then(() =&gt; &#123;
  window = new BrowserWindow(&#123;
    frame: false,
    titleBarStyle: &#39;hiddenInset&#39;,
    width: 200,
    height: 200,
    backgroundColor: &#39;#000&#39;
  &#125;)
  window.loadURL(&#39;about:blank&#39;)
  window.setTouchBar(touchBar)
&#125;)
</code></pre>
<p>运行命令：</p>
<pre><code class="ini">./node_modules/.bin/electron touchbar.js
</code></pre>
<p><img src="/2022/11/25/Electron-d-2-0/image-20221125172447369.png"></p>
<p>[TouchBar文档]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/touch-bar&quot;">https://www.electronjs.org/zh/docs/latest/api/touch-bar&quot;</a></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Electron官方文档]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/app">https://www.electronjs.org/zh/docs/latest/api/app</a> “<br>[npmjs]: 	“<a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/electron/" rel="tag">electron</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Electron-d-1-0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/24/Electron-d-1-0/"
    >Electron-d-1.0</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/24/Electron-d-1-0/" class="article-date">
  <time datetime="2022-11-24T08:27:34.000Z" itemprop="datePublished">2022-11-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a> / <a class="article-category-link" href="/categories/Electron/Electron-d-1-0/">Electron-d-1.0</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h1><h3 id="一、构建第一个electron应用"><a href="#一、构建第一个electron应用" class="headerlink" title="一、构建第一个electron应用"></a>一、构建第一个electron应用</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><pre><code class="ini">npm init -y //初始化项目
npm install --save-dev electron //下载electron到开发依赖
</code></pre>
<h4 id="2-创建入口index-html"><a href="#2-创建入口index-html" class="headerlink" title="2.创建入口index.html"></a>2.创建入口index.html</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World!&lt;/h1&gt;
    We are using Node.js &lt;span id=&quot;node-version&quot;&gt;&lt;/span&gt;,
    Chromium &lt;span id=&quot;chrome-version&quot;&gt;&lt;/span&gt;,
    and Electron &lt;span id=&quot;electron-version&quot;&gt;&lt;/span&gt;.
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="3-创建入口文件"><a href="#3-创建入口文件" class="headerlink" title="3.创建入口文件"></a>3.创建入口文件</h4><pre><code class="javascript">//main.js
const &#123; app,BrowserWindow &#125; = require(&#39;electron&#39;)

const createWindow = () =&gt; &#123;
    const win = new BrowserWindow(&#123;
      width: 800,
      height: 600
    &#125;)
  
    win.loadFile(&#39;index.html&#39;)
  &#125;

app.whenReady().then(() =&gt; &#123;
    createWindow()
  &#125;)
</code></pre>
<h4 id="4-创建窗口应用"><a href="#4-创建窗口应用" class="headerlink" title="4.创建窗口应用"></a>4.创建窗口应用</h4><p>Package.json配置</p>
<pre><code class="javascript">//Package.json
&#123;
  &quot;name&quot;: &quot;electron-app&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;一个处于实验阶段的app&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;start&quot;: &quot;electron .&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;alanmf&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;devDependencies&quot;: &#123;
    &quot;electron&quot;: &quot;^21.3.0&quot;
  &#125;
&#125;
</code></pre>
<pre><code class="ini">npm start //执行 electron .
</code></pre>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221123155226283.png"></p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221123155133707.png"></p>
<p>为了更方便页面更新我们使用nodemon</p>
<p>nodemon是一个自动重启node应用的工具，当监听的文件或监听目录下的文件发生修改时，自动重启应用</p>
<pre><code class="ini">npm i nodemon -D
</code></pre>
<p>更改package.json</p>
<pre><code class="javascript">//Package.json
&#123;
  &quot;name&quot;: &quot;electron-app&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;一个处于实验阶段的app&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;scripts&quot;: &#123;
    &quot;start&quot;: &quot;nodemon --exec electron .&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;alanmf&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;devDependencies&quot;: &#123;
    &quot;electron&quot;: &quot;^21.3.0&quot;
  &#125;
&#125;
</code></pre>
<h3 id="二、electron核心"><a href="#二、electron核心" class="headerlink" title="二、electron核心"></a>二、electron核心</h3><h4 id="1-electron核心概念"><a href="#1-electron核心概念" class="headerlink" title="1.electron核心概念"></a>1.electron核心概念</h4><p><strong>主进程</strong>；启动项目时运行的main.js脚本就是我们说的主进程，在主进程运行的脚步可以创建web页面的形式展示GUI，主进程只有一个。</p>
<p><strong>渲染进程</strong>：每个Electron的页面都在运行着自己的进程，这样的进程称之为渲染进程（基于Chromium的多进程结构）。</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221123160858462.png"></p>
<p>主进程使用BrowserWindow创建实例，主进程销毁后，对应的渲染进程会被终止。主进程与渲染进程通过 IPC 的方式（事件驱动）进行通信。</p>
<h4 id="2-electron窗口控制台"><a href="#2-electron窗口控制台" class="headerlink" title="2.electron窗口控制台"></a>2.electron窗口控制台</h4><pre><code class="javascript">//打开开发者工具
win.webContents.openDevTools();
//暂时关闭安全警告（不推荐）
process.env[&#39;ELECTRON_DISABLE_SECURITY_WARNINGS&#39;] = &#39;true&#39;
</code></pre>
<pre><code class="javascript">//配置CSP（阻挡一部分安全警告）
&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
</code></pre>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221123162757926.png"></p>
<h4 id="3-主进程事件生命周期"><a href="#3-主进程事件生命周期" class="headerlink" title="3.主进程事件生命周期"></a>3.主进程事件生命周期</h4><p>关闭所有窗口时退出应用 <strong>Windows &amp; Linux</strong></p>
<p>在Windows和Linux上，关闭所有窗口通常会完全退出一个应用程序。</p>
<p>为了实现这一点，你需要监听 <code>app</code> 模块的 <code>&#39;window-all-closed&#39;事件。如果用户不是在 macOS(</code>darwin<code>) 上运行程序，则调用 </code>app.quit()&#96;。</p>
<pre><code class="javascript">app.on(&#39;window-all-closed&#39;, () =&gt; &#123;
  //macOS用户在关闭窗口时不会关闭应用
  if (process.platform !== &#39;darwin&#39;) app.quit()
&#125;)
</code></pre>
<p>当 Linux 和 Windows 应用在没有窗口打开时退出了，macOS 应用通常即使在没有打开任何窗口的情况下也继续运行，并且在没有窗口可用的情况下激活应用时会打开新的窗口。</p>
<p>为了实现这一特性，监听 <code>app</code> 模块的 <code>activate</code> 事件。如果没有任何浏览器窗口是打开的，则调用 <code>createWindow()</code> 方法。</p>
<p>因为窗口无法在 <code>ready</code> 事件前创建，你应当在你的应用初始化后仅监听 <code>activate</code> 事件。 通过在您现有的 <code>whenReady()</code> 回调中附上您的事件监听器来完成这个操作。</p>
<pre><code class="javascript">app.whenReady().then(() =&gt; &#123;
  createWindow()
  app.on(&#39;activate&#39;, () =&gt; &#123;
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  &#125;)
&#125;)
</code></pre>
<p>这样，我们的窗口的控件就完整了（实现macOS用户-没有窗口打开时创建新窗口-关闭窗口不关闭应用，点击程序坞应用打开新窗口）</p>
<h4 id="4-通过预加载脚本从渲染器访问Node-js"><a href="#4-通过预加载脚本从渲染器访问Node-js" class="headerlink" title="4.通过预加载脚本从渲染器访问Node.js"></a>4.通过预加载脚本从渲染器访问Node.js</h4><p>现在，最后要做的是输出Electron的版本号和它的依赖项到你的web页面上。</p>
<p>在主进程通过Node的全局 <code>process</code> 对象访问这个信息是微不足道的。 然而，你不能直接在主进程中编辑DOM，因为它无法访问渲染器 <code>文档</code> 上下文。 它们存在于完全不同的进程！</p>
<p>这是将 <strong>预加载</strong> 脚本连接到渲染器时派上用场的地方。 预加载脚本在渲染器进程加载之前加载，并有权访问两个 渲染器全局 (例如 <code>window</code> 和 <code>document</code>) 和 Node.js 环境。</p>
<p>创建一个名为 <code>preload.js</code> 的新脚本:</p>
<pre><code class="javascript">//preload.js
window.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; &#123;
  const replaceText = (selector, text) =&gt; &#123;
    const element = document.getElementById(selector)
    if (element) element.innerText = text
  &#125;

  for (const dependency of [&#39;chrome&#39;, &#39;node&#39;, &#39;electron&#39;]) &#123;
    replaceText(`$&#123;dependency&#125;-version`, process.versions[dependency])
  &#125;
&#125;)
</code></pre>
<p>上面的代码访问 Node.js <code>process.versions</code> 对象，并运行一个基本的 <code>replaceText</code> 辅助函数将版本号插入到 HTML 文档中。</p>
<p>要将此脚本附加到渲染器流程，请在你现有的 <code>BrowserWindow</code> 构造器中将路径中的预加载脚本传入 <code>webPreferences.preload</code> 选项。</p>
<pre><code class="javascript">// include the Node.js &#39;path&#39; module at the top of your file
const path = require(&#39;path&#39;)

// modify your existing createWindow() function
const createWindow = () =&gt; &#123;
  const win = new BrowserWindow(&#123;
    width: 800,
    height: 600,
    webPreferences: &#123;
      preload: path.join(__dirname, &#39;preload.js&#39;)
    &#125;
  &#125;)

  win.loadFile(&#39;index.html&#39;)
&#125;
// ...
</code></pre>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124081539904.png"></p>
<p>这里使用了两个Node.js概念：</p>
<ul>
<li><code>__dirname</code>字符串指向当前正在执行脚本的路径 (在本例中，它指向你的项目的根文件夹)。</li>
<li><code>path.join</code> API 将多个路径联结在一起，创建一个跨平台的路径字符串。</li>
</ul>
<p>我们使用一个相对当前正在执行JavaScript文件的路径，这样相对路径将在开发模式和打包模式中都将有效。</p>
<h4 id="5-contextBridge"><a href="#5-contextBridge" class="headerlink" title="5.contextBridge"></a>5.contextBridge</h4><p><code>contextBridge</code>模块有以下方法:</p>
<p><code>contextBridge.exposeInMainWorld(apiKey, api)</code></p>
<ul>
<li><code>apiKey</code> string - 将 API 注入到 <code>窗口</code> 的键。 API 将可通过 <code>window[apiKey]</code> 访问。</li>
<li><code>api</code> any - 你的 API可以是什么样的以及它是如何工作的相关信息如下。</li>
</ul>
<p>应用开发接口（API）</p>
<p>提供给 <code>exposeInMainWorld</code> 的 <code>api</code> 必须是一个 <code>Function</code>， <code>string</code>， <code>number</code>， <code>Array</code>， <code>boolean</code>；或一个键为字符串，值为一个 <code>Function</code>， <code>string</code>， <code>number</code>， <code>Array</code>， <code>boolean</code>的对象；或其他符合相同条件的嵌套对象。</p>
<p><code>Function</code> 类型的值被代理到其他上下文中，所有其他类型的值都会被 <strong>复制</strong> 并 <strong>冻结</strong>。 在 API 中发送的任何数据 &#x2F;原始数据将不可改变，在桥接器其中一侧的更新不会导致另一侧的更新。</p>
<p>代码应用：</p>
<pre><code class="javascript">//preload.js+
const &#123; contextBridge &#125; = require(&#39;electron&#39;)

contextBridge.exposeInMainWorld(&#39;myApi&#39;,&#123;
    platform:process.platform
  &#125;)
</code></pre>
<p>那我们就可以在页面上去访问window上的方法了</p>
<pre><code class="javascript">//app.js
console.log(window.myApi.platform) //darwin
</code></pre>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124093018081.png"></p>
<h3 id="三、主进程与渲染进程通信"><a href="#三、主进程与渲染进程通信" class="headerlink" title="三、主进程与渲染进程通信"></a>三、主进程与渲染进程通信</h3><p>进程间通信 (IPC) 是在 Electron 中构建功能丰富的桌面应用程序的关键部分之一。 由于主进程和渲染器进程在 Electron 的进程模型具有不同的职责，因此 IPC 是执行许多常见任务的唯一方法，例如从 UI 调用原生 API 或从原生菜单触发 Web 内容的更改。</p>
<p>在 Electron 中，进程使用 <code>ipcMain</code> 和 <code>ipcRenderer</code>模块，通过开发人员定义的“通道”传递消息来进行通信。 这些通道是 <strong>任意</strong> （您可以随意命名它们）和 <strong>双向</strong> （您可以在两个模块中使用相同的通道名称）的。</p>
<h4 id="1-渲染器进程到主进程（单向"><a href="#1-渲染器进程到主进程（单向" class="headerlink" title="1.渲染器进程到主进程（单向 )"></a>1.渲染器进程到主进程（单向 )</h4><p>要将单向 IPC 消息从渲染器进程发送到主进程，您可以使用 <code>ipcRenderer.send</code>API 发送消息，然后使用 <code>ipcMain.on</code>API 接收。</p>
<p>我们下边就按照官网的例子来说吧！</p>
<h5 id="1-使用-ipcMain-on-监听事件"><a href="#1-使用-ipcMain-on-监听事件" class="headerlink" title="(1) 使用 ipcMain.on 监听事件"></a>(1) 使用 <code>ipcMain.on</code> 监听事件</h5><p>在主进程（main.js）中，使用 <code>ipcMain.on</code> API 在 <code>set-title</code> 通道上设置一个 IPC 监听器:</p>
<pre><code class="javascript">//main.js+
const &#123; ipcMain &#125; = require(&#39;electron&#39;)
 ipcMain.on(&#39;set-title&#39;, (event, title) =&gt; &#123;
      const webContents = event.sender
      const win = BrowserWindow.fromWebContents(webContents)
      win.setTitle(title)
    &#125;)
</code></pre>
<h5 id="2-通过预加载脚本暴露-ipcRenderer-send"><a href="#2-通过预加载脚本暴露-ipcRenderer-send" class="headerlink" title="(2) 通过预加载脚本暴露 ipcRenderer.send"></a>(2) 通过预加载脚本暴露 <code>ipcRenderer.send</code></h5><p>要将消息发送到上面创建的 IPC 监听器，可以使用 <code>ipcRenderer.send</code> API。 默认情况下，渲染器进程没有权限访问 Node.js 和 Electron 模块。 作为应用开发者，需要使用 <code>contextBridge</code> API 来选择要从预加载脚本中暴露哪些 API。</p>
<p>在您的预加载脚本中添加以下代码，向渲染器进程暴露一个全局的 <code>window.electronAPI</code> 变量。</p>
<pre><code class="javascript">//preload.js+
const &#123; contextBridge,ipcRenderer &#125; = require(&#39;electron&#39;)
contextBridge.exposeInMainWorld(&#39;electronAPI&#39;, &#123;
    setTitle: (title) =&gt; ipcRenderer.send(&#39;set-title&#39;, title)
&#125;)
</code></pre>
<p>此时，将能够在渲染器进程中使用 <code>window.electronAPI.setTitle()</code> 函数。</p>
<h5 id="3-构建渲染器进程-UI"><a href="#3-构建渲染器进程-UI" class="headerlink" title="(3) 构建渲染器进程 UI"></a>(3) 构建渲染器进程 UI</h5><p>在 BrowserWindow 加载的我们的 HTML 文件中，添加一个由文本输入框和按钮组成的基本用户界面：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Title: &lt;input id=&quot;title&quot;/&gt;
    &lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;Set&lt;/button&gt;
    &lt;script src=&quot;./renderer/app.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>将在导入的 <code>renderer.js</code> 文件中添加几行代码，以利用从预加载脚本中暴露的 <code>window.electronAPI</code> 功能：</p>
<pre><code class="javascript">//app.js
const setButton = document.getElementById(&#39;btn&#39;)
const titleInput = document.getElementById(&#39;title&#39;)
setButton.addEventListener(&#39;click&#39;, () =&gt; &#123;
    const title = titleInput.value
    window.electronAPI.setTitle(title)
&#125;);
</code></pre>
<p>到目前的代码为止，我们的一个渲染进程到主进程的进程通信就已经实现了，我们可以试一试我们的UI界面功能</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124100800847.png"></p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>！！！我们上面有一些地方不理解的方法和API，我们现在讲一下</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124101054114.png"></p>
<p>上面的 回调函数有两个参数：一个 IpcMainEvent 结构和一个 <code>title</code> 字符串。 每当消息通过 <code>set-title</code> 通道传入时，此函数找到附加到消息发送方的 BrowserWindow 实例，并在该实例上使用 <code>win.setTitle</code> API。</p>
<p>我们只是为了更简单的理解进程通信，具体 API 见官方文档吧！</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124101339509.png"></p>
<h4 id="2-渲染器进程到主进程（双向）"><a href="#2-渲染器进程到主进程（双向）" class="headerlink" title="2.渲染器进程到主进程（双向）"></a>2.渲染器进程到主进程（双向）</h4><p>双向 IPC 的一个常见应用是从渲染器进程代码调用主进程模块并等待结果。 这可以通过将 <code>ipcRenderer.invoke</code> 与 <code>ipcMain.handle</code> 搭配使用来完成。</p>
<h5 id="1-使用-ipcMain-handle-监听事件"><a href="#1-使用-ipcMain-handle-监听事件" class="headerlink" title="(1)使用 ipcMain.handle 监听事件"></a>(1)使用 <code>ipcMain.handle</code> 监听事件</h5><p>在主进程(main.js)中，我们将创建一个 <code>handleFileOpen()</code> 函数，它调用 <code>dialog.showOpenDialog</code> 并返回用户选择的文件路径值。 每当渲染器进程通过 <code>dialog:openFile</code> 通道发送 <code>ipcRender.invoke</code> 消息时，此函数被用作一个回调。 然后，返回值将作为一个 Promise 返回到最初的 <code>invoke</code> 调用。</p>
<pre><code class="javascript">//main.js
const &#123; app,BrowserWindow,ipcMain,dialog &#125; = require(&#39;electron&#39;)
const path = require(&#39;path&#39;)

//回调函数
async function handleFileOpen() &#123;
  const &#123; canceled, filePaths &#125; = await dialog.showOpenDialog()
  if (canceled) &#123;
    return
  &#125; else &#123;
    return filePaths[0]
  &#125;
&#125;

const createWindow = () =&gt; &#123;
    const win = new BrowserWindow(&#123;
      width: 800,
      height: 600,
      webPreferences: &#123;
        preload: path.join(__dirname, &#39;preload.js&#39;)
      &#125;
    &#125;)
    win.loadFile(&#39;index.html&#39;) 
    win.webContents.openDevTools()
    
  &#125;

  app.whenReady().then(() =&gt; &#123;
    //监听，执行回调
    ipcMain.handle(&#39;dialog:openFile&#39;, handleFileOpen)
    createWindow()
    app.on(&#39;activate&#39;, () =&gt; &#123;
      if (BrowserWindow.getAllWindows().length === 0) createWindow()
    &#125;)
  &#125;)
  app.on(&#39;window-all-closed&#39;, () =&gt; &#123;
    if (process.platform !== &#39;darwin&#39;) app.quit()
  &#125;)
</code></pre>
<h5 id="2-通过预加载脚本暴露-ipcRenderer-invoke"><a href="#2-通过预加载脚本暴露-ipcRenderer-invoke" class="headerlink" title="(2)通过预加载脚本暴露 ipcRenderer.invoke"></a>(2)通过预加载脚本暴露 <code>ipcRenderer.invoke</code></h5><p>在预加载脚本中，我们暴露了一个单行的 <code>openFile</code> 函数，它调用并返回 <code>ipcRenderer.invoke(&#39;dialog:openFile&#39;)</code> 的值。 我们将在下一步中使用此 API 从渲染器的用户界面调用原生对话框。</p>
<pre><code class="javascript">//preload.js
const &#123; contextBridge,ipcRenderer &#125; = require(&#39;electron&#39;)
 contextBridge.exposeInMainWorld(&#39;electronAPI&#39;, &#123;
    openFile: () =&gt; ipcRenderer.invoke(&#39;dialog:openFile&#39;)
&#125;)
</code></pre>
<h5 id="3-构建渲染器进程-UI-1"><a href="#3-构建渲染器进程-UI-1" class="headerlink" title="(3)构建渲染器进程 UI"></a>(3)构建渲染器进程 UI</h5><p>最后，让我们构建加载到 BrowserWindow 中的 HTML 文件。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
    &lt;title&gt;Dialog&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button type=&quot;button&quot; id=&quot;btn&quot;&gt;Open a File&lt;/button&gt;
    File path: &lt;strong id=&quot;filePath&quot;&gt;&lt;/strong&gt;
    &lt;script src=&#39;./renderer/app.js&#39;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>用户界面包含一个 <code>#btn</code> 按钮元素，将用于触发我们的预加载 API，以及一个 <code>#filePath</code> 元素，将用于显示所选文件的路径。需要在渲染器进程脚本中编写几行代码</p>
<pre><code class="javascript">//app.js
const btn = document.getElementById(&#39;btn&#39;)
const filePathElement = document.getElementById(&#39;filePath&#39;)

btn.addEventListener(&#39;click&#39;, async () =&gt; &#123;
  const filePath = await window.electronAPI.openFile()
  filePathElement.innerText = filePath
&#125;)
</code></pre>
<p>到目前的代码为止，我们的一个渲染进程到主进程的双向进程通信就已经实现了，我们可以试一试我们的UI界面功能</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124103530122.png"></p>
<h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><p><code>ipcRenderer.invoke</code> API （老方法了，但依然好用）是在 Electron 7 中添加的，作为处理渲染器进程中双向 IPC 的一种开发人员友好的方式。 但这种 IPC 模式存在几种替代方法。</p>
<p>使用 <code>ipcRenderer.send</code>我们用于单向通信的 <code>ipcRenderer.send</code> API 也可用于双向通信。 这是在 Electron 7 之前通过 IPC 进行异步双向通信的推荐方式。</p>
<pre><code class="javascript">//preload.js
// 您也可以使用 `contextBridge` API
// 将这段代码暴露给渲染器进程
const &#123; ipcRenderer &#125; = require(&#39;electron&#39;)

ipcRenderer.on(&#39;asynchronous-reply&#39;, (_event, arg) =&gt; &#123;
  console.log(arg) // 在 DevTools 控制台中打印“pong”
&#125;)
ipcRenderer.send(&#39;asynchronous-message&#39;, &#39;ping&#39;)
</code></pre>
<pre><code class="javascript">//main.js
ipcMain.on(&#39;asynchronous-message&#39;, (event, arg) =&gt; &#123;
  console.log(arg) // 在 Node 控制台中打印“ping”
  // 作用如同 `send`，但返回一个消息
  // 到发送原始消息的渲染器
  event.reply(&#39;asynchronous-reply&#39;, &#39;pong&#39;)
&#125;)
</code></pre>
<p>这种方法有几个缺点：</p>
<ul>
<li>您需要设置第二个 <code>ipcRenderer.on</code> 监听器来处理渲染器进程中的响应。 使用 <code>invoke</code>，您将获得作为 Promise 返回到原始 API 调用的响应值。</li>
<li>没有显而易见的方法可以将 <code>asynchronous-reply</code> 消息与原始的 <code>asynchronous-message</code>消息配对。 如果您通过这些通道非常频繁地来回传递消息，则需要添加其他应用代码来单独跟踪每个调用和响应。</li>
</ul>
<p>使用 <code>ipcRenderer.sendSync</code>API也是可以替代的，但不推荐</p>
<p><code>ipcRenderer.sendSync</code> API 向主进程发送消息，并 <em>同步</em> 等待响应。</p>
<pre><code class="javascript">//main.js
const &#123; ipcMain &#125; = require(&#39;electron&#39;)
ipcMain.on(&#39;synchronous-message&#39;, (event, arg) =&gt; &#123;
  console.log(arg) // 在 Node 控制台中打印“ping”
  event.returnValue = &#39;pong&#39;
&#125;)
</code></pre>
<pre><code class="javascript">//perload.js
// 您也可以使用 `contextBridge` API
// 将这段代码暴露给渲染器进程
const &#123; ipcRenderer &#125; = require(&#39;electron&#39;)

const result = ipcRenderer.sendSync(&#39;synchronous-message&#39;, &#39;ping&#39;)
console.log(result) // 在 DevTools 控制台中打印“pong”
</code></pre>
<p>这份代码的结构与 <code>invoke</code> 模型非常相似，但出于性能原因，我们建议<strong>避免使用此 API</strong>。 它的同步特性意味着它将阻塞渲染器进程，直到收到回复为止。(容易阻塞渲染器进程)</p>
<h4 id="3-主进程到渲染器进程"><a href="#3-主进程到渲染器进程" class="headerlink" title="3.主进程到渲染器进程"></a>3.主进程到渲染器进程</h4><p>将消息从主进程发送到渲染器进程时，需要指定是哪一个渲染器接收消息。 消息需要通过其 <code>WebContents</code>实例发送到渲染器进程。 此 WebContents 实例包含一个 <code>send</code> 方法，其使用方式与 <code>ipcRenderer.send</code> 相同。</p>
<h5 id="1-使用-webContents-模块发送消息"><a href="#1-使用-webContents-模块发送消息" class="headerlink" title="(1)使用 webContents 模块发送消息"></a>(1)使用 <code>webContents</code> 模块发送消息</h5><p>我们需要首先使用 Electron 的 <code>Menu</code> 模块在主进程中构建一个自定义菜单，该模块使用 <code>webContents.send</code> API 将 IPC 消息从主进程发送到目标渲染器。</p>
<pre><code class="javascript">//main.js
const &#123; app,BrowserWindow,ipcMain,Menu &#125; = require(&#39;electron&#39;)
const path = require(&#39;path&#39;)

const createWindow = () =&gt; &#123;
    const win = new BrowserWindow(&#123;
      width: 800,
      height: 600,
      webPreferences: &#123;
        preload: path.join(__dirname, &#39;preload.js&#39;)
      &#125;
    &#125;)

    const menu = Menu.buildFromTemplate([
      &#123;
        label: app.name,
        submenu: [
        &#123;
          click: () =&gt; win.webContents.send(&#39;update-counter&#39;, 1),
          label: &#39;Increment&#39;,
        &#125;,
        &#123;
          click: () =&gt; win.webContents.send(&#39;update-counter&#39;, -1),
          label: &#39;Decrement&#39;,
        &#125;
        ]
      &#125;
  
    ])

    Menu.setApplicationMenu(menu)
    win.loadFile(&#39;index.html&#39;) 
    win.webContents.openDevTools()
    
  &#125;

  app.whenReady().then(() =&gt; &#123;
    ipcMain.on(&#39;counter-value&#39;, (_event, value) =&gt; &#123;
      console.log(value) // will print value to Node console
    &#125;)
    createWindow()
    app.on(&#39;activate&#39;, () =&gt; &#123;
      if (BrowserWindow.getAllWindows().length === 0) createWindow()
    &#125;)
  &#125;)

  app.on(&#39;window-all-closed&#39;, () =&gt; &#123;
    if (process.platform !== &#39;darwin&#39;) app.quit()
  &#125;)
</code></pre>
<h5 id="2-通过预加载脚本暴露-ipcRenderer-on"><a href="#2-通过预加载脚本暴露-ipcRenderer-on" class="headerlink" title="(2)通过预加载脚本暴露 ipcRenderer.on"></a>(2)通过预加载脚本暴露 <code>ipcRenderer.on</code></h5><p>与前面的渲染器到主进程的示例一样，我们使用预加载脚本中的 <code>contextBridge</code> 和 <code>ipcRenderer</code> 模块向渲染器进程暴露 IPC 功能：</p>
<pre><code class="javascript">//preload.js
const &#123; contextBridge,ipcRenderer &#125; = require(&#39;electron&#39;)
contextBridge.exposeInMainWorld(&#39;electronAPI&#39;, &#123;
    handleCounter: (callback) =&gt; ipcRenderer.on(&#39;update-counter&#39;, callback)
&#125;)
</code></pre>
<p>加载预加载脚本后，渲染器进程应有权访问 <code>window.electronAPI.handleCounter()</code> 监听器函数。</p>
<h5 id="3-构建渲染器进程-UI-2"><a href="#3-构建渲染器进程-UI-2" class="headerlink" title="(3)构建渲染器进程 UI"></a>(3)构建渲染器进程 UI</h5><p>我们将在加载的 HTML 文件中创建一个接口，其中包含一个 <code>#counter</code>元素，我们将使用该元素来显示值：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&gt;
    &lt;title&gt;Menu Counter&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Current value: &lt;strong id=&quot;counter&quot;&gt;0&lt;/strong&gt;
    &lt;script src=&#39;./renderer/app.js&#39;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>为了更新 HTML 文档中的值，我们将添加几行 DOM 操作的代码，以便在每次触发 <code>update-counter</code> 事件时更新 <code>#counter</code> 元素的值。</p>
<pre><code class="javascript">//app.js
const counter = document.getElementById(&#39;counter&#39;)
window.electronAPI.handleCounter((event, value) =&gt; &#123;
    const oldValue = Number(counter.innerText)
    const newValue = oldValue + value
    counter.innerText = newValue
    event.sender.send(&#39;counter-value&#39;, newValue)
&#125;)
</code></pre>
<p>在上面的代码中，我们将回调传递给从预加载脚本中暴露的 <code>window.electronAPI.onUpdateCounter</code> 函数。 第二个 <code>value</code> 参数对应于我们传入 <code>webContents.send</code> 函数的 <code>1</code> 或 <code>-1</code>，该函数是从原生菜单调用的。</p>
<p>到目前的代码为止，我们的一个主进程到渲染器进程的进程通信就已经实现了，我们可以试一试我们的UI界面功能</p>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124161644112.png"></p>
<h5 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h5><p>对于从主进程到渲染器进程的 IPC，没有与 <code>ipcRenderer.invoke</code> 等效的 API。 不过，可以从 <code>ipcRenderer.on</code> 回调中将回复发送回主进程。</p>
<p>我们可以对前面例子的代码进行略微修改来演示这一点。 在渲染器进程中，使用 <code>event</code> 参数，通过 <code>counter-value</code> 通道将回复发送回主进程。</p>
<pre><code class="javascript">//app.js
const counter = document.getElementById(&#39;counter&#39;)
window.electronAPI.handleCounter((event, value) =&gt; &#123;
    const oldValue = Number(counter.innerText)
    const newValue = oldValue + value
    counter.innerText = newValue
    event.sender.send(&#39;counter-value&#39;, newValue)
&#125;)
</code></pre>
<p>在主进程中，监听 <code>counter-value</code> 事件并适当地处理它们。</p>
<pre><code class="javascript">//main.js
ipcMain.on(&#39;counter-value&#39;, (_event, value) =&gt; &#123;
      console.log(value) // will print value to Node console
  &#125;)
</code></pre>
<p><img src="/2022/11/24/Electron-d-1-0/image-20221124162116311.png"></p>
<h4 id="4-渲染器进程到渲染器进程"><a href="#4-渲染器进程到渲染器进程" class="headerlink" title="4.渲染器进程到渲染器进程"></a>4.渲染器进程到渲染器进程</h4><p>没有直接的方法可以使用 <code>ipcMain</code> 和 <code>ipcRenderer</code> 模块在 Electron 中的渲染器进程之间发送消息。 为此，有两种选择：</p>
<ul>
<li>将主进程作为渲染器之间的消息代理。 这需要将消息从一个渲染器发送到主进程，然后主进程将消息转发到另一个渲染器。</li>
<li>从主进程将一个 MessagePort 传递到两个渲染器。 这将允许在初始设置后渲染器之间直接进行通信。</li>
</ul>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Electron官网]: 	“<a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/tutorial/quick-start">https://www.electronjs.org/zh/docs/latest/tutorial/quick-start</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/electron/" rel="tag">electron</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-pinia"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/23/pinia/"
    >pinia</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/23/pinia/" class="article-date">
  <time datetime="2022-11-23T02:21:26.000Z" itemprop="datePublished">2022-11-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Electron/">Electron</a> / <a class="article-category-link" href="/categories/Electron/Pinia/">Pinia</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h1><h3 id="一、Vuex-与-Pinia-核心思想与用法"><a href="#一、Vuex-与-Pinia-核心思想与用法" class="headerlink" title="一、Vuex 与 Pinia 核心思想与用法"></a>一、Vuex 与 Pinia 核心思想与用法</h3><h4 id="Flux-架构"><a href="#Flux-架构" class="headerlink" title="Flux 架构"></a>Flux 架构</h4><p>Flux 是 Facebook 在构建大型 Web 应用程序时为了解决数据一致性问题而设计出的一种架构，它是一种描述状态管理的设计模式。绝大多数前端领域的状态管理工具都遵循这种架构，或者以它为参考原型。</p>
<p>Flux 架构主要有四个组成部分：</p>
<ul>
<li>📦 <strong>store</strong>：状态数据的存储管理中心，可以有多个，可以接受 action 做出响应。</li>
<li>🖼 <strong>view</strong>：视图，根据 store 中的数据渲染生成页面，与 store 之间存在发布订阅关系。</li>
<li>🛠 <strong>action</strong>：一种描述动作行为的数据对象，通常会包含动作类型 type 和需要传递的参数 payload 等属性。</li>
<li>📮 <strong>dispatcher</strong>：调度器，接收 action 并分发至 store。</li>
</ul>
<p><img src="/2022/11/23/pinia/b55512a3f1be47b2.png"></p>
<p>整个数据流动关系为：</p>
<p>1、view 视图中的交互行为会创建 action，交由 dispatcher 调度器。</p>
<p>2、dispatcher 接收到 action 后会分发至对应的 store。</p>
<p>3、store 接收到 action 后做出响应动作，并触发 change 事件，通知与其关联的 view 重新渲染内容。</p>
<p>这就是 Flux 架构最核心的特点：单向数据流。</p>
<p>与传统的 MVC 架构相比，单向数据流也带来了一个好处：可预测性。</p>
<p>所有对于状态的修改都需要经过 dispatcher 派发的 action 来触发的，每一个 action 都是一个单独的数据对象实体，可序列化，操作记录可追踪，更易于调试。</p>
<p>Vuex 与 Pinia 大体上沿用 Flux 的思想，并针对 Vue 框架单独进行了一些设计上的优化。</p>
<h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p><img src="/2022/11/23/pinia/f9ae36a64955b220.png"></p>
<ul>
<li>📦 <strong>state</strong>：整个应用的状态管理单例，等效于 Vue 组件中的 data，对应了 Flux 架构中的 store。</li>
<li>🧮 <strong>getter</strong>：可以由 state 中的数据派生而成，等效于 Vue 组件中的计算属性。它会自动收集依赖，以实现计算属性的缓存。</li>
<li>🛠 <strong>mutation</strong>：类似于事件，包含一个类型名和对应的回调函数，在回调函数中可以对 state 中的数据进行同步修改。<ul>
<li>Vuex 不允许直接调用该函数，而是需要通过 <code>store.commit</code> 方法提交一个操作，并将参数传入回调函数。</li>
<li>commit 的参数也可以是一个数据对象，正如 Flux 架构中的 action 对象一样，它包含了类型名 <code>type</code> 和负载 <code>payload</code>。</li>
<li>这里要求 mutation 中回调函数的操作一定是同步的，这是因为同步的、可序列化的操作步骤能保证生成唯一的日志记录，才能使得 devtools 能够实现对状态的追踪，实现 time-travel。</li>
</ul>
</li>
<li>🔨 <strong>action</strong>：action 内部的操作不受限制，可以进行任意的异步操作。我们需要通过 <code>dispatch</code> 方法来触发 action 操作，同样的，参数包含了类型名 <code>type</code> 和负载 <code>payload</code>。<ul>
<li>action 的操作本质上已经脱离了 Vuex 本身，假如将它剥离出来，仅仅在用户（开发者）代码中调用 <code>commit</code> 来提交 mutation 也能达到一样的效果。</li>
</ul>
</li>
<li>📁 <strong>module</strong>：store 的分割，每个 module 都具有独立的 state、getter、mutation 和 action。<ul>
<li>可以使用 <code>module.registerModule</code> 动态注册模块。</li>
<li>支持模块相互嵌套，可以通过设置命名空间来进行数据和操作隔离。</li>
</ul>
</li>
</ul>
<h4 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h4><p><img src="/2022/11/23/pinia/image-20221123084525884.png"></p>
<p>保留：</p>
<ul>
<li>📦 <strong>state</strong>：store 的核心，与 Vue 中的 data 一致，可以直接对其中的数据进行读写。</li>
<li>🧮 <strong>getters</strong>：与 Vue 中的计算属性相同，支持缓存。</li>
<li>🔨 <strong>actions</strong>：操作不受限制，可以创建异步任务，可以直接被调用，不再需要 commit、dispatch 等方法。</li>
</ul>
<p>舍弃：</p>
<ul>
<li>🛠 <strong>mutation</strong>：Pinia 并非完全抛弃了 mutation，而是将对 state 中单个数据进行修改的操作封装为一个 mutation，但不对外开放接口。可以在 devtools 中观察到 mutation。</li>
<li>📁 <strong>module</strong>：Pinia 通过在创建 store 时指定 name 来区分不同的 store，不再需要 module。</li>
</ul>
<h3 id="二、使用Pinia"><a href="#二、使用Pinia" class="headerlink" title="二、使用Pinia"></a>二、使用Pinia</h3><h4 id="1-安装pinia"><a href="#1-安装pinia" class="headerlink" title="1.安装pinia"></a>1.安装pinia</h4><pre><code class="ini">npm i pinia -S //安装pinia依赖
</code></pre>
<h4 id="2-main-js组册"><a href="#2-main-js组册" class="headerlink" title="2.main.js组册"></a>2.main.js组册</h4><pre><code class="javascript">//main.js
import &#123; createApp &#125; from &#39;vue&#39;
import &#39;./style.css&#39;
import App from &#39;./App.vue&#39;
import &#123; createPinia &#125; from &#39;pinia&#39;

createApp(App)
.use(createPinia())
.mount(&#39;#app&#39;)
</code></pre>
<h4 id="3-创建store"><a href="#3-创建store" class="headerlink" title="3.创建store"></a>3.创建store</h4><p><img src="/2022/11/23/pinia/image-20221123090656211.png"></p>
<pre><code class="javascript">//countStore.js
import &#123; defineStore &#125; from &#39;pinia&#39;
const useCountStore = defineStore(&#39;countStore&#39;,&#123;
    state()&#123;
        return &#123;
            count:0
        &#125;
    &#125;
&#125; )
export default useCountStore; //导出
</code></pre>
<h4 id="4-新建组件使用state"><a href="#4-新建组件使用state" class="headerlink" title="4.新建组件使用state"></a>4.新建组件使用state</h4><pre><code class="vue">//components/Count.vue
&lt;script setup&gt;
import useCountStore from &#39;../store/countStore&#39;
const countStore = useCountStore();
console.log(countStore)
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;
    &#123;&#123;countStore.count&#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style lang=&quot;css&quot;&gt;
div&#123;
    width: 100px;
    height: 30px;
    border:1px solid black;
    border-radius: 5px;
&#125;
&lt;/style&gt;
</code></pre>
<pre><code class="vue">//App.vue
&lt;script setup&gt;
// This starter template is using Vue 3 &lt;script setup&gt; SFCs
// Check out https://vuejs.org/api/sfc-script-setup.html#script-setup
import Count from &#39;./components/Count.vue&#39;
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;
    &lt;Count/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
.logo &#123;
  height: 6em;
  padding: 1.5em;
  will-change: filter;
&#125;
.logo:hover &#123;
  filter: drop-shadow(0 0 2em #646cffaa);
&#125;
.logo.vue:hover &#123;
  filter: drop-shadow(0 0 2em #42b883aa);
&#125;
&lt;/style&gt;
</code></pre>
<p><img src="/2022/11/23/pinia/image-20221123091224524.png" alt="countStore"></p>
<p>我们可以直接使用就可以了，根据上面控制台输出可以看清楚countStore</p>
<p>到现在已经实现了创建store及使用</p>
<h4 id="5-更新store"><a href="#5-更新store" class="headerlink" title="5.更新store"></a>5.更新store</h4><p>1.我们添加一个action方法</p>
<pre><code class="javascript">//countStore.js
import &#123; defineStore &#125; from &#39;pinia&#39;

const useCountStore = defineStore(&#39;countStore&#39;,&#123;
    //定义state
    state()&#123;
        return &#123;
            count:0
        &#125;
    &#125;,
    //定义action方法
    actions:&#123;
        add()&#123;
            this.count++
        &#125;
    &#125;
&#125; )

export default useCountStore;
</code></pre>
<p>2.解构方法和state</p>
<pre><code class="vue">//Count.vue
&lt;script setup&gt;
import &#123; storeToRefs &#125; from &#39;pinia&#39;
import useCountStore from &#39;../store/countStore&#39;
const &#123;count,add&#125; = storeToRefs(useCountStore());
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;
    &#123;&#123;count&#125;&#125;
  &lt;/div&gt;
  &lt;button @click=&quot;add()&quot;&gt;Add&lt;/button&gt;
&lt;/template&gt;
&lt;style lang=&quot;css&quot;&gt;
div&#123;
    width: 100px;
    height: 30px;
    border:1px solid black;
    border-radius: 5px;
    text-align: center;
&#125;
button&#123;
    position: relative;
    bottom: -30px;
&#125;
&lt;/style&gt; 
</code></pre>
<p>如果我们不使用 storeToRefs 来转发，那么页面将不会有任何响应</p>
<p>但是我们包裹了useCountStore()并且解构了，发现控制台输出错误error</p>
<p><img src="/2022/11/23/pinia/image-20221123094109387.png"></p>
<p>经过修改发现，actions方法不可以通过解构来使用，只能通过另一种方法</p>
<p><img src="/2022/11/23/pinia/image-20221123094416363.png"> </p>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p>[Pinia中文文档]: 	“<a target="_blank" rel="noopener" href="https://pinia.web3doc.top/">https://pinia.web3doc.top/</a> “<br>[Vite中文文档]: 	“<a target="_blank" rel="noopener" href="https://vitejs.cn/">https://vitejs.cn/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pinia/" rel="tag">Pinia</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-vite配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/22/vite%E9%85%8D%E7%BD%AE/"
    >vite配置</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/22/vite%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2022-11-22T01:50:43.000Z" itemprop="datePublished">2022-11-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/vite%E9%85%8D%E7%BD%AE/">vite配置</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="vite配置"><a href="#vite配置" class="headerlink" title="vite配置"></a>vite配置</h1><p>最直观的体验是“快速”、“清爽”，开发效率也得到明显提升（解决掉了webpack开发服务器存在的痛点）。</p>
<p>初始化完成后，工程目录如下：</p>
<p><img src="/2022/11/22/vite%E9%85%8D%E7%BD%AE/image-20221122094453903.png"></p>
<p>VS Code插件：Vite</p>
<p>配置详情：</p>
<p>vite.config.ts</p>
<pre><code class="javascript">import &#123; defineConfig, loadEnv &#125; from &#39;vite&#39;;
import vue from &#39;@vitejs/plugin-vue&#39;;
import vueJSX from &#39;@vitejs/plugin-vue-jsx&#39;;
import Components from &#39;unplugin-vue-components/vite&#39;;
import &#123; AntDesignVueResolver &#125; from &#39;unplugin-vue-components/resolvers&#39;;
import &#123; resolve &#125; from &#39;path&#39;;
import &#123; initDevProxy &#125; from &#39;./http-proxy&#39;;

// https://vitejs.dev/config/
export default defineConfig((&#123; mode &#125;) =&gt; &#123;
  const env = loadEnv(mode, process.cwd(), &#39;&#39;);
  return &#123;
    // 自定义公共基础路径（取自 .env(.*) 文件）
    base: env.VITE_BASE_PATH,
    // 定义全局常量替换方式
    define: &#123;
      // 取消启用Vue.2x中选项式api（这部分不会被打包）
      &#39;__VUE_OPTIONS_API__&#39;: false,
    &#125;,
    // 配置vite插件
    plugins: [
      vue(),
      vueJSX(),
      // 自动化的组件按需引入配置
      Components(&#123;
        extensions: [&#39;vue&#39;, &#39;tsx&#39;],
        resolvers: [
          AntDesignVueResolver(&#123; resolveIcons: true &#125;),
        ],
        include: [/\.vue$/, /\.vue\?vue/, /\.tsx$/],
      &#125;),
    ],
    // 配置解析项
    resolve: &#123;
      // 路径别名
      alias: &#123;
        &#39;@/&#39;: resolve(__dirname, &#39;src&#39;) + &#39;/&#39;,
      &#125;,
    &#125;,
    // 样式处理配置项
    css: &#123;
      // CSS module
      modules: &#123;
        generateScopedName: `_[name]_[local]_[hash:base64:6]_`,
      &#125;,
      // 传递给特定css样式预处理器的配置
      preprocessorOptions: &#123;
        less: &#123;
          javascriptEnabled: true,
        &#125;,
      &#125;,
    &#125;,
    // 配置开发服务器
    server: &#123;
      open: true,
      proxy: initDevProxy(),
    &#125;,
    // 自定义打包项配置
    build: &#123;
      // 大文件告警阈值(kb)
      chunkSizeWarningLimit: 400,
    &#125;,
  &#125;;
&#125;);
</code></pre>
<p>http-proxy.ts</p>
<pre><code class="javascript">import type &#123; ProxyOptions &#125; from &#39;vite&#39;;

/**
 * 初始化开发服务器代理
 */
export const initDevProxy = (): Record&lt;string, string | ProxyOptions&gt; =&gt; &#123;
  return &#123;
    // 临时示例
    &#39;/api&#39;: &#123;
      target: &#39;&#39;,
      changeOrigin: true,
    &#125;,
  &#125;;
&#125;;
</code></pre>
<p>以上的配置是项目配置的一部分，其他所需要的配置按照自己的需要去官网查询就可以，官网基于没个配置都有详细讲解。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Vite中文官网]: 	“<a target="_blank" rel="noopener" href="https://cn.vitejs.dev/guide/">https://cn.vitejs.dev/guide/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vite/" rel="tag">vite</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Vite-Vue3-Ts搭建私有组件库2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/21/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%932/"
    >Vite+Vue3+Ts搭建私有组件库2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/21/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%932/" class="article-date">
  <time datetime="2022-11-21T06:40:38.000Z" itemprop="datePublished">2022-11-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%932/">Vite+Vue3+Ts搭建私有组件库2</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Vite-Vue3-Ts搭建私有组件库2"><a href="#Vite-Vue3-Ts搭建私有组件库2" class="headerlink" title="Vite+Vue3+Ts搭建私有组件库2"></a>Vite+Vue3+Ts搭建私有组件库2</h1><p>本文章只供参考，具体实现可能会有出入（会尽快完善）</p>
<h3 id="一、vite打包"><a href="#一、vite打包" class="headerlink" title="一、vite打包"></a>一、vite打包</h3><p>上一篇末尾的打包还是有缺陷的，打包的组件库只能给js项目使用,在ts项目下运行会出现一些错误，而且使用的时候还会失去代码提示功能，这样的话我们就失去了用ts开发组件库的意义了。所以我们需要在打包的库里加入声明文件(.d.ts)。</p>
<p>那么如何向打包后的库里加入声明文件呢？ 其实很简单，只需要引入 vite-plugin-dts</p>
<pre><code class="css">pnpm i vite-plugin-dts -D -w
</code></pre>
<p>如果pnpm命令一直error，用其他命令下载安装也是一样的（下载到根目录）</p>
<p>然后修改一下我们的vite.config.ts引入这个插件</p>
<pre><code class="javascript">//components/vite.config.ts
import &#123; defineConfig &#125; from &quot;vite&quot;;
import vue from &quot;@vitejs/plugin-vue&quot;
import dts from &#39;vite-plugin-dts&#39;

export default defineConfig(
    &#123;
        build: &#123;...&#125;,
        plugins: [
            vue(),
            dts(&#123;
                //指定使用的tsconfig.json为我们整个项目根目录下掉,如果不配置,你也可以在components下新建tsconfig.json
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;),
            //因为这个插件默认打包到es下，我们想让lib目录下也生成声明文件需要再配置一个
            dts(&#123;
                outputDir:&#39;lib&#39;,
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;)

        ]
    &#125;
)
</code></pre>
<p>执行pnpm run build你就会发现你的es和lib下就有了声明文件</p>
<h3 id="二、组件样式"><a href="#二、组件样式" class="headerlink" title="二、组件样式"></a>二、组件样式</h3><p>首先我们需要做的是将less打包成css然后放到打包后对应的文件目录下,我们在components下新建build文件夹来存放我们的一些打包工具,然后新建buildLess.ts,首先我们需要先安装一些工具cpy和fast-glob</p>
<pre><code class="css">pnpm i cpy fast-glob -D -w
</code></pre>
<p>它可以直接复制我们规定的文件并将我们的文件copy到指定目录,比如buildLess.ts:</p>
<pre><code class="javascript">//build/buildLess.ts
import cpy from &#39;cpy&#39;
import &#123; resolve &#125; from &#39;path&#39;

const sourceDir = resolve(__dirname, &#39;../src&#39;)
//lib文件
const targetLib = resolve(__dirname, &#39;../lib&#39;)
//es文件
const targetEs = resolve(__dirname, &#39;../es&#39;)
console.log(sourceDir);
const buildLess = async () =&gt; &#123;
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetLib)
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetEs)
&#125;
buildLess()
</code></pre>
<p>然后在package.json中新增命令</p>
<pre><code class="erlang">...
&quot;scripts&quot;: &#123;
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;build:less&quot;: &quot;esno build/buildLess&quot;
  &#125;,
...
</code></pre>
<p>终端执行 pnpm run build:less 你就会发现lib和es文件对应目录下就出现了less文件.(如果error，切换node版本)</p>
<p>但是我们最终要的并不是less文件而是css文件,所以我们要将less打包成css,所以我们需要用的less模块.在ts中引入less因为它本身没有声明文件所以会出现类型错误,所以我们要先安装它的 @types&#x2F;less</p>
<pre><code class="css">pnpm i --save-dev @types/less -D -w
</code></pre>
<p>buildLess.ts如下(详细注释都在代码中)</p>
<pre><code class="javascript">import cpy from &#39;cpy&#39;
import &#123; resolve &#125; from &#39;path&#39;
import &#123; promises as fs &#125; from &quot;fs&quot;
import less from &quot;less&quot;
import glob from &quot;fast-glob&quot;
const sourceDir = resolve(__dirname, &#39;../src&#39;)
//lib文件目录
const targetLib = resolve(__dirname, &#39;../lib&#39;)
//es文件目录
const targetEs = resolve(__dirname, &#39;../es&#39;)



const buildLess = async () =&gt; &#123;
    //直接将less文件复制到打包后目录
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetLib)
    await cpy(`$&#123;sourceDir&#125;/**/*.less`, targetEs)

    //获取打包后.less文件目录(lib和es一样)
    const lessFils = await glob(&quot;**/*.less&quot;, &#123; cwd: targetLib, onlyFiles: true &#125;)

    //遍历含有less的目录
    for (let path in lessFils) &#123;
        const lessPathLib = `$&#123;targetLib&#125;/$&#123;lessFils[path]&#125;`
        const lessPathEs = `$&#123;targetEs&#125;/$&#123;lessFils[path]&#125;`

        //获取less文件字符串
        const lessCode = await fs.readFile(lessPathLib, &#39;utf-8&#39;)
        //将less解析成css
        const code = await less.render(lessCode)

        //拿到.css后缀path
        const cssPathLib = lessPathLib.replace(&#39;.less&#39;, &#39;.css&#39;)
        const cssPathEs = lessPathEs.replace(&#39;.less&#39;, &#39;.css&#39;)

        //将css写入对应目录
        await fs.writeFile(cssPathLib, code.css)
        await fs.writeFile(cssPathEs, code.css)
    &#125;



&#125;
buildLess()
</code></pre>
<p>执行打包命令之后你会发现对应文件夹下多了.css文件</p>
<p><img src="/2022/11/21/Vite-Vue3-Ts%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%932/image-20221121092003205.png"></p>
<p>现在我已经将css文件放入对应的目录下了,但是我们的相关组件并没有引入这个css文件;所以我们需要的是每个打包后组件的index.js中出现如:</p>
<pre><code class="cpp">import &quot;xxx/xxx.css&quot;
</code></pre>
<p>之类的代码我们的css才会生效;所以我们需要对vite.config.ts进行相关配置</p>
<p>首先我们先将.less文件忽略external: [‘vue’, &#x2F;.less&#x2F;],这时候打包后的文件中如button&#x2F;index.js就会出现</p>
<pre><code class="cpp">import &quot;./style/index.less&quot;;
</code></pre>
<p>然后我们再将打包后代码的.less换成.css就大功告成了</p>
<pre><code class="typescript">...
plugins: [
            ...

            &#123;
                name: &#39;style&#39;,
                generateBundle(config, bundle) &#123;
                    //这里可以获取打包后的文件目录以及代码code
                    const keys = Object.keys(bundle)

                    for (const key of keys) &#123;
                        const bundler: any = bundle[key as any]
                        //rollup内置方法,将所有输出文件code中的.less换成.css,因为我们当时没有打包less文件

                        this.emitFile(&#123;
                            type: &#39;asset&#39;,
                            fileName: key,//文件名名不变
                            source: bundler.code.replace(/\.less/g, &#39;.css&#39;)
                        &#125;)
                    &#125;
                &#125;
            &#125;
        ...
        ]
...
</code></pre>
<p>我们最终的vite.config.ts如下</p>
<pre><code class="typescript">import &#123; defineConfig &#125; from &quot;vite&quot;;
import vue from &quot;@vitejs/plugin-vue&quot;
import dts from &#39;vite-plugin-dts&#39;

export default defineConfig(
    &#123;
        build: &#123;
            target: &#39;modules&#39;,
            //打包文件目录
            outDir: &quot;es&quot;,
            //压缩
            minify: false,
            //css分离
            //cssCodeSplit: true,
            rollupOptions: &#123;
                //忽略打包vue和.less文件
                external: [&#39;vue&#39;, /\.less/],
                input: [&#39;src/index.ts&#39;],
                output: [
                    &#123;
                        format: &#39;es&#39;,
                        //不用打包成.es.js,这里我们想把它打包成.js
                        entryFileNames: &#39;[name].js&#39;,
                        //让打包目录和我们目录对应
                        preserveModules: true,
                        //配置打包根目录
                        dir: &#39;es&#39;,
                        preserveModulesRoot: &#39;src&#39;
                    &#125;,
                    &#123;
                        format: &#39;cjs&#39;,
                        //不用打包成.mjs
                        entryFileNames: &#39;[name].js&#39;,
                        //让打包目录和我们目录对应
                        preserveModules: true,
                        //配置打包根目录
                        dir: &#39;lib&#39;,
                        preserveModulesRoot: &#39;src&#39;
                    &#125;
                ]
            &#125;,
            lib: &#123;
                entry: &#39;./index.ts&#39;,
                formats: [&#39;es&#39;, &#39;cjs&#39;]
            &#125;
        &#125;,




        plugins: [
            vue(),
            dts(&#123;
                //指定使用的tsconfig.json为我们整个项目根目录下掉,如果不配置,你也可以在components下新建tsconfig.json
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;),
            //因为这个插件默认打包到es下，我们想让lib目录下也生成声明文件需要再配置一个
            dts(&#123;
                outputDir: &#39;lib&#39;,
                tsConfigFilePath: &#39;../../tsconfig.json&#39;
            &#125;),

            &#123;
                name: &#39;style&#39;,
                generateBundle(config, bundle) &#123;
                    //这里可以获取打包后的文件目录以及代码code
                    const keys = Object.keys(bundle)

                    for (const key of keys) &#123;
                        const bundler: any = bundle[key as any]
                        //rollup内置方法,将所有输出文件code中的.less换成.css,因为我们当时没有打包less文件

                        this.emitFile(&#123;
                            type: &#39;asset&#39;,
                            fileName: key,//文件名名不变
                            source: bundler.code.replace(/\.less/g, &#39;.css&#39;)
                        &#125;)
                    &#125;
                &#125;
            &#125;

        ]
    &#125;
)
</code></pre>
<p>最后我们将打包less与打包组件合成一个命令(package.json):</p>
<pre><code class="erlang">...
&quot;scripts&quot;: &#123;
     &quot;build&quot;:&quot;vite build&quot;,
    &quot;build:less&quot;: &quot;esno build/buildLess&quot;
  &#125;,
...
</code></pre>
<p>后续直接执行pnpm run build 即可完成所有打包啦</p>
<h3 id="三、引用ui包"><a href="#三、引用ui包" class="headerlink" title="三、引用ui包"></a>三、引用ui包</h3><p>做了那么多终于到发布的阶段了；其实npm发包是很容易的，就拿我们的组件alanmf举例吧</p>
<p>发布之前记得到<a target="_blank" rel="noopener" href="https://www.npmjs.com/">npm</a>官网注册个账户,如果你要发布@xx&#x2F;xx这种包的话需要在npm新建个组织组织组织名就是@后面的，比如我建的组织就是kitty-ui,注册完之后你就可以发布了</p>
<p>首先要将我们代码提交到git仓库，不然pnpm发布无法通过，后面每次发版记得在对应包下执行 <strong>pnpm version patch</strong>你就会发现这个包的版本号patch(版本号第三个数) +1 了</p>
<p>如果你发布的是公共包的话，在对应包下执行</p>
<pre><code class="cpp">pnpm publish --access public
</code></pre>
<p>输入你的账户和密码（记得输入密码的时候是不显示的，不要以为卡了）正常情况下应该是发布成功了</p>
<p><strong>注意</strong></p>
<p>发布的时候要将npm的源切换到npm的官方地址(<a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>); 如果你使用了其它镜像源的话</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%81%E6%9C%89%E7%BB%84%E4%BB%B6%E5%BA%93/" rel="tag">私有组件库</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>