<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>前端面试大全git |  艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-前端面试大全git"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  前端面试大全git
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/" class="article-date">
  <time datetime="2022-11-03T02:29:52.000Z" itemprop="datePublished">2022-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/git%E6%93%8D%E4%BD%9C/">git操作</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">8.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">30 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（git命令）"><a href="#前端面试题大全（git命令）" class="headerlink" title="前端面试题大全（git命令）"></a>前端面试题大全（git命令）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git是什么？"><a href="#git是什么？" class="headerlink" title="git是什么？"></a>git是什么？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>git，是一个分布式版本控制软件，最初目的是为更好地管理<code>Linux</code>内核开发而设计</p>
<p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32393234306634302d663739632d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>项目开始，只有一个原始版仓库，别的机器可以<code>clone</code>这个原始版本库，那么所有<code>clone</code>的机器，它们的版本库其实都是一样的，并没有主次之分</p>
<p>所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库<code>clone</code>一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交</p>
<p><code>github</code>实际就可以充当这个服务器角色，其是一个开源协作社区，提供<code>Git</code>仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目</p>
<h4 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h4><p>当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的</p>
<p><code>Git</code> 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，<code>git</code>能够知道</p>
<p><code>Git </code>用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来，如下：</p>
<pre><code class="ini">24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre>
<p>当我们修改文件的时候，<code>git</code>就会修改文件的状态，可以通过<code>git status</code>进行查询，状态情况如下：</p>
<ul>
<li>已修改（modified）：表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交（committed）：表示数据已经安全的保存在本地数据库中。</li>
</ul>
<p>文件状态对应的，不同状态的文件在<code>Git</code>中处于不同的工作区域，主要分成了四部分：</p>
<ul>
<li>工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本</li>
<li>暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中</li>
<li>本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库</li>
<li>远程仓库：远程的仓库，如 github</li>
</ul>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33323733633961302d663739632d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="三、命令"><a href="#三、命令" class="headerlink" title="三、命令"></a>三、命令</h4><p>从上图可以看到，<code>git</code>日常简单的使用就只有上图6个命令：</p>
<ul>
<li>add</li>
<li>commit</li>
<li>push</li>
<li>pull</li>
<li>clone</li>
<li>checkout</li>
</ul>
<p>但实际上还有很多命令，如果想要熟练使用，还有60个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力</p>
<h3 id="Git中-fork-clone-branch这三个概念，有什么区别"><a href="#Git中-fork-clone-branch这三个概念，有什么区别" class="headerlink" title="Git中 fork, clone,branch这三个概念，有什么区别?"></a>Git中 fork, clone,branch这三个概念，有什么区别?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p><code>fork</code>，英语翻译过来就是叉子，动词形式则是分叉，如下图，从左到右，一条直线变成多条直线</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61643034616465302d663761642d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>转到<code>git</code>仓库中，<code>fork</code>则可以代表分叉、克隆 出一个（仓库的）新拷贝</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62346233313435302d663761642d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>包含了原来的仓库（即upstream repository，上游仓库）所有内容，如分支、Tag、提交</p>
<p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p>
<h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p>
<p>执行<code>clone</code>命令后，会在当前目录下创建一个名为<code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p>
<p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p>
<h5 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h5><p><code>branch</code>，译为分支，其作用简单而言就是开启另一个分支， 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线</p>
<p><code>Git</code> 处理分支的方式十分轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷</p>
<p>在我们开发中，默认只有一条<code>master</code>分支，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37666138653963302d663932332d313165622d393931642d3333346664333166303230312e706e67.png">]</p>
<p>通过<code>git branch </code>可以创建一个分支，但并不会自动切换到新分支中去</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38396566643536302d663932332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>通过<code>git checkout</code>可以切换到另一个<code>testing</code>分支</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39316431636566302d663932332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h4><h5 id="fork-1"><a href="#fork-1" class="headerlink" title="fork"></a>fork</h5><p>当你在<code>github</code>发现感兴趣开源项目的时候，可以通过点击<code>github</code>仓库中右上角<code>fork</code>标识的按钮，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095419097.png"></p>
<p>点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的<code>github</code>仓库中，而你本地仓库是不会存在任何更改</p>
<p>然后你就可以通过<code>git clone</code>对你这个复制的远程仓库进行克隆</p>
<p>后续更改任何东西都可以在本地完成，如<code>git add</code>、<code>git commit</code>一系列的操作，然后通过<code>push</code>命令推到自己的远程仓库</p>
<p>如果希望对方接受你的修改，可以通过发送<code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095452040.png"></p>
<p>整体流程如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63656438636531302d663761642d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="clone-1"><a href="#clone-1" class="headerlink" title="clone"></a>clone</h5><p>在<code>github</code>中，开源项目右侧存在<code>code</code>按钮，点击后则会显示开源项目<code>url</code>信息，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095540516.png"></p>
<p>通过<code>git clone xxx</code>则能完成远程项目的下载</p>
<h5 id="branch-1"><a href="#branch-1" class="headerlink" title="branch"></a>branch</h5><p>可通过<code>git branch</code>进行查看当前的分支状态，</p>
<p>如果给了<code>--list</code>，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号</p>
<p>以及通过<code>git branch</code>创建一个新的分支出来</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>其三者区别如下：</p>
<ul>
<li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li>
<li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li>
<li>branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支</li>
</ul>
<h3 id="Git常用的命令有哪些？"><a href="#Git常用的命令有哪些？" class="headerlink" title="Git常用的命令有哪些？"></a>Git常用的命令有哪些？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p><code>git </code>的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66653135303532302d663761662d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的<code>git </code>命令</p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p><code>Git </code>自带一个 <code>git config</code> 的工具来帮助设置控制 <code>Git </code>外观和行为的配置变量，在我们安装完<code>git</code>之后，第一件事就是设置你的用户名和邮件地址</p>
<p>后续每一个提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改</p>
<p>设置提交代码时的用户信息命令如下：</p>
<ul>
<li>git config [–global] user.name “[name]”</li>
<li>git config [–global] user.email “[email address]”</li>
</ul>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>一个<code>git</code>项目的初始有两个途径，分别是：</p>
<ul>
<li>git init [project-name]：创建或在当前目录初始化一个git代码库</li>
<li>git clone url：下载一个项目和它的整个代码历史</li>
</ul>
<h5 id="日常基本操作"><a href="#日常基本操作" class="headerlink" title="日常基本操作"></a>日常基本操作</h5><p>在日常工作中，代码常用的基本操作如下：</p>
<ul>
<li>git init 初始化仓库，默认为 master 分支</li>
<li>git add . 提交全部文件修改到缓存区</li>
<li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li>
<li>git diff 查看当前代码 add后，会 add 哪些内容</li>
<li>git diff –staged查看现在 commit 提交后，会提交哪些内容</li>
<li>git status 查看当前分支状态</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li>
<li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li>
<li>git commit -v 提交时显示所有diff信息</li>
<li>git commit –amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</li>
</ul>
<p>关于提交信息的格式，可以遵循以下的规则：</p>
<ul>
<li>feat: 新特性，添加功能</li>
<li>fix: 修改 bug</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>style: 代码格式修改, 注意不是 css 修改</li>
<li>test: 测试用例修改</li>
<li>chore: 其他修改, 比如构建流程, 依赖管理</li>
</ul>
<h5 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h5><ul>
<li>git branch 查看本地所有分支</li>
<li>git branch -r 查看远程所有分支</li>
<li>git branch -a 查看本地和远程所有分支</li>
<li>git merge &lt;分支名&gt; 合并分支</li>
<li>git merge –abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li>
<li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li>
<li>git checkout –orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li>
<li>git branch -D &lt;分支名&gt; 删除本地某个分支</li>
<li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li>
<li>git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</li>
<li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li>
<li>git checkout &lt;分支名&gt; 切换到本地某个分支</li>
<li>git checkout &lt;远程库名&gt;&#x2F;&lt;分支名&gt; 切换到线上某个分支</li>
<li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li>
</ul>
<h5 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h5><p>远程操作常见的命令：</p>
<ul>
<li>git fetch [remote] 下载远程仓库的所有变动</li>
<li>git remote -v 显示所有远程仓库</li>
<li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li>
<li>git fetch 获取线上最新版信息记录，不合并</li>
<li>git push [remote] [branch] 上传本地指定分支到远程仓库</li>
<li>git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突</li>
<li>git push [remote] –all 推送所有分支到远程仓库</li>
</ul>
<h5 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h5><ul>
<li>git checkout [file] 恢复暂存区的指定文件到工作区</li>
<li>git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</li>
<li>git checkout . 恢复暂存区的所有文件到工作区</li>
<li>git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</li>
<li>git reset –hard 重置暂存区与工作区，与上一次commit保持一致</li>
<li>git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</li>
<li>git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</li>
</ul>
<blockquote>
<p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p>
<p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p>
</blockquote>
<h5 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h5><p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p>
<ul>
<li>git stash 暂时将未提交的变化移除</li>
<li>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</li>
<li>git stash list 查看所有储藏中的工作</li>
<li>git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</li>
<li>git stash clear 清空所有储藏中的工作</li>
<li>git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</li>
</ul>
<h5 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h5><p><code>git</code>常用命令速查表如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613130663363302d663762302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<h3 id="对git-pull-和-git-fetch-的理解？有什么区别？"><a href="#对git-pull-和-git-fetch-的理解？有什么区别？" class="headerlink" title="对git pull 和 git fetch 的理解？有什么区别？"></a>对git pull 和 git fetch 的理解？有什么区别？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>先回顾两个命令的定义</p>
<ul>
<li>git fetch 命令用于从另一个存储库下载对象和引用</li>
<li>git pull 命令用于从另一个存储库或本地分支获取并集成(整合)</li>
</ul>
<p>再来看一次<code>git</code>的工作流程图，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64353233626136302d666163322d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>可以看到，<code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p>
<p>而<code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p>
<p>在我们本地的<code>git</code>文件中对应也存储了<code>git</code>本地仓库分支的<code>commit ID </code>和 跟踪的远程分支的<code>commit ID</code>，对应文件如下：</p>
<ul>
<li>.git&#x2F;refs&#x2F;head&#x2F;[本地分支]</li>
<li>.git&#x2F;refs&#x2F;remotes&#x2F;[正在跟踪的分支]</li>
</ul>
<p>使用 <code>git fetch</code>更新代码，本地的库中<code>master</code>的<code>commitID</code>不变</p>
<p>但是与<code>git</code>上面关联的那个<code>orign/master</code>的<code>commit ID</code>发生改变</p>
<p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过<code>merge</code>去合并这两个不同的代码版本</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66643233666637302d666231322d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>也就是<code>fetch</code>的时候本地的<code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地<code>merge</code>合并这两个版本号的代码</p>
<p>相比之下，使用<code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30393162383134302d666231332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h4><p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到<code>git pull</code>或者<code>git fetch</code>命令</p>
<h5 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h5><p>用法如下：</p>
<pre><code class="ini">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>例如从远程的<code>origin</code>仓库的<code>master</code>分支下载代码到本地并新建一个<code>temp</code>分支</p>
<pre><code class="ini">git fetch origin master:temp
</code></pre>
<p>如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来到本地当前分支</p>
<p>这里<code>git fetch</code>不会进行合并，执行后需要手动执行<code>git merge</code>合并，如下：</p>
<pre><code class="ini">git merge temp
</code></pre>
<h5 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h5><p>两者的用法十分相似，<code>pull</code>用法如下：</p>
<pre><code class="ini">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>例如将远程主机<code>origin</code>的<code>master</code>分支拉取过来，与本地的<code>branchtest</code>分支合并，命令如下：</p>
<pre><code class="ini">git pull origin master:branchtest
</code></pre>
<p>同样如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来与本地当前分支合并</p>
<h4 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h4><p>相同点：</p>
<ul>
<li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li>
</ul>
<p>不同点：</p>
<ul>
<li>git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull &#x3D; git fetch + git merge</li>
<li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li>
</ul>
<h3 id="Git-中-HEAD、工作树和索引之间的区别？"><a href="#Git-中-HEAD、工作树和索引之间的区别？" class="headerlink" title="Git 中 HEAD、工作树和索引之间的区别？"></a>Git 中 HEAD、工作树和索引之间的区别？</h3><h4 id="一、HEAD"><a href="#一、HEAD" class="headerlink" title="一、HEAD"></a>一、HEAD</h4><p>在<code>git</code>中，可以存在很多分支，其本质上是一个指向<code>commit</code>对象的可变指针，而<code>Head</code>是一个特别的指针，是一个指向你正在工作中的本地分支的指针</p>
<p>简单来讲，就是你现在在哪儿，HEAD 就指向哪儿</p>
<p>例如当前我们处于<code>master</code>分支，所以<code>HEAD</code>这个指针指向了<code>master</code>分支指针</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33366362306461302d666134302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>然后通过调用<code>git checkout test</code>切换到<code>test</code>分支，那么<code>HEAD</code>则指向<code>test</code>分支，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33653836626138302d666134302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>但我们在<code>test</code>分支再一次<code>commit</code>信息的时候，<code>HEAD</code>指针仍然指向了<code>test</code>分支指针，而<code>test</code>分支指针已经指向了最新创建的提交，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34333938333962302d666136362d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这个<code>HEAD</code>存储的位置就在<code>.git/HEAD</code>目录中，查看信息可以看到<code>HEAD</code>指向了另一个文件</p>
<pre><code class="ini">$ cat .git/HEAD
ref: refs/heads/master

$ cat .git/refs/heads/master
7406a10efcc169bbab17827aeda189aa20376f7f
</code></pre>
<p>这个文件的内容是一串哈希码，而这个哈希码正是<code>master</code>分支上最新的提交所对应的哈希码</p>
<p>所以，当我们切换分支的时候，<code>HEAD</code>指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p>
<p>所以，HEAD指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p>
<h4 id="二、工作树和索引"><a href="#二、工作树和索引" class="headerlink" title="二、工作树和索引"></a>二、工作树和索引</h4><p>在<code>Git</code>管理下，大家实际操作的目录被称为工作树，也就是工作区域</p>
<p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34366535616334302d666134302d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>Git</code>在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库</p>
<p>因此，要提交文件，首先需要把文件加入到索引区域中。</p>
<p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交</p>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><p>从所在的位置来看：</p>
<ul>
<li>HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</li>
<li>工作树是查看和编辑的（源）文件的实际内容</li>
<li>索引是放置你想要提交给 git仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过git commit 则将索引区域的文件提交到 git 仓库中</li>
</ul>
<h3 id="对git-stash-的理解？应用场景？"><a href="#对git-stash-的理解？应用场景？" class="headerlink" title="对git stash 的理解？应用场景？"></a>对git stash 的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上</p>
<p>后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码</p>
<p>默认情况下，<code>git stash</code>会缓存下列状态的文件：</p>
<ul>
<li>添加到暂存区的修改（staged changes）</li>
<li>Git跟踪的但并未添加到暂存区的修改（unstaged changes）</li>
</ul>
<p>但以下状态的文件不会缓存：</p>
<ul>
<li>在工作目录中新的文件（untracked files）</li>
<li>被忽略的文件（ignored files）</li>
</ul>
<p>如果想要上述的文件都被缓存，可以使用<code>-u</code>或者<code>--include-untracked</code>可以工作目录新的文件，使用<code>-a</code>或者<code>--all</code>命令可以当前目录下的所有修改</p>
<h4 id="二、如何使用-1"><a href="#二、如何使用-1" class="headerlink" title="二、如何使用"></a>二、如何使用</h4><p>关于<code>git stash</code>常见的命令如下：</p>
<ul>
<li>git stash</li>
<li>git stash save</li>
<li>git stash list</li>
<li>git stash pop</li>
<li>git stash apply</li>
<li>git stash show</li>
<li>git stash drop</li>
<li>git stash clear</li>
</ul>
<h5 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h5><p>保存当前工作进度，会把暂存区和工作区的改动保存起来</p>
<h5 id="git-stash-save"><a href="#git-stash-save" class="headerlink" title="git stash save"></a>git stash save</h5><p><code>git stash save</code>可以用于存储修改.并且将<code>git</code>的工作状态切回到<code>HEAD</code>也就是上一次合法提交上</p>
<p>如果给定具体的文件路径,<code>git stash</code>只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：</p>
<ul>
<li>–keep-index 或者 -k 只会存储为加入 git 管理的文件</li>
<li>–include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态</li>
<li>-a 或者 –all 命令可以当前目录下的所有修改，包括被 git 忽略的文件</li>
</ul>
<h5 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h5><p>显示保存进度的列表。也就意味着，<code>git stash</code>命令可以多次执行，当多次使用<code>git stash</code>命令后，栈里会充满未提交的代码，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35303231366464302d666363662d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>其中，<code>stash@&#123;0&#125;</code>、<code>stash@&#123;1&#125;</code>就是当前<code>stash</code>的名称</p>
<h5 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h5><p><code>git stash pop</code> 从栈中读取最近一次保存的内容，也就是栈顶的<code>stash</code>会恢复到工作区</p>
<p>也可以通过 <code>git stash pop</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>
<p>如果从<code>stash</code>中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突</p>
<h5 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h5><p>将堆栈中的内容应用到当前目录，不同于<code>git stash pop</code>，该命令不会将内容从堆栈中删除</p>
<p>也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况</p>
<p>同样，可以通过<code>git stash apply</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>
<h5 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h5><p>查看堆栈中最新保存的<code>stash</code>和当前目录的差异</p>
<p>通过使用<code>git stash show -p</code>查看详细的不同</p>
<p>通过使用<code>git stash show stash@&#123;1&#125;</code>查看指定的<code>stash</code>和当前目录差异</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/bfc073fa538b45c4d6de871da070f364638cdd751a8c08426794c5dba2230514/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34353836323061302d666363662d313165622d626336662d3366303665313439313636342e706e67"><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34353836323061302d666363662d313165622d626336662d3366303665313439313636342e706e67.png" alt="img"></a></p>
<h5 id="git-stash-drop"><a href="#git-stash-drop" class="headerlink" title="git stash drop"></a>git stash drop</h5><p><code>git stash drop</code> + <code>stash</code>名称表示从堆栈中移除某个指定的stash</p>
<h5 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h5><p>删除所有存储的进度</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情</p>
<p>但是你创建一次未完成的代码的<code>commit</code>提交，这时候就可以使用<code>git stash</code></p>
<p>例如以下场景：</p>
<p>当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过<code>git pull</code>解决</p>
<p>但是如果可能发生冲突怎么办.直接<code>git pull</code>会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：</p>
<ul>
<li>git stash</li>
<li>git pull</li>
<li>git stash pop</li>
</ul>
<p>或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用<code>git stash</code>缓存当前区域的代码</p>
<ul>
<li>git stash：保存开发到一半的代码</li>
<li>git commit -m ‘修改问题’</li>
<li>git stash pop：将代码追加到最新的提交之后</li>
</ul>
<h3 id="对git-rebase-和-git-merge的理解？区别？"><a href="#对git-rebase-和-git-merge的理解？区别？" class="headerlink" title="对git rebase 和 git merge的理解？区别？"></a>对git rebase 和 git merge的理解？区别？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p>
<ul>
<li>git merge</li>
<li>git rebase</li>
</ul>
<p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p>
<p>用法上两者也十分的简单：</p>
<h5 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h5><p>将当前分支合并到指定分支，命令用法如下：</p>
<pre><code class="ini">git merge xxx
</code></pre>
<h5 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h5><p>将当前分支移植到指定分支或指定<code>commit</code>之上，用法如下：</p>
<pre><code class="ini">git rebase -i &lt;commit&gt;
</code></pre>
<p>常见的参数有<code>--continue</code>，用于解决冲突之后，继续执行<code>rebase</code></p>
<pre><code class="ini">git rebase --continue
</code></pre>
<h4 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h4><h5 id="git-merge-1"><a href="#git-merge-1" class="headerlink" title="git merge"></a>git merge</h5><p>通过<code>git merge</code>将当前分支与<code>xxx</code>分支合并，产生的新的<code>commit</code>对象有两个父节点</p>
<p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p>
<p>举个例子，<code>bugfix</code>分支是从<code>maste</code>r分支分叉出来的，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38383431306133302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>合并<code> bugfix</code>分支到<code>master</code>分支时，如果<code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含<code>master</code>分支所有的历史记录</p>
<p>所以通过把<code>master</code>分支的位置移动到<code>bugfix</code>的最新分支上，就完成合并</p>
<p>如果<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39323965623232302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这时候使用<code>git merge</code>的时候，会生成一个新的提交，并且<code>master</code>分支的<code>HEAD</code>会移动到新的分支上，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39666466613365302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p>
<h5 id="git-rebase-1"><a href="#git-rebase-1" class="headerlink" title="git rebase"></a>git rebase</h5><p>同样，<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61623264353132302d666464342d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>通过<code>git rebase</code>，会变成如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62373261656437302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63396261306538302d666464342d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>rebase</code>之后，<code>master</code>的<code>HEAD</code>位置不变。因此，要合并<code>master</code>分支和<code>bugfix</code>分支</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64633636303636302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的<code>B</code></p>
<p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交<code>X</code>和<code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p>
<p>然后将当前分支指向目标最新位置<code>D</code>, 然后将之前另存为临时文件的修改依序应用</p>
<h4 id="三、区别-3"><a href="#三、区别-3" class="headerlink" title="三、区别"></a>三、区别</h4><p>从上面可以看到，<code>merge</code>和<code>rebasea</code>都是合并历史记录，但是各自特性不同：</p>
<h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>通过<code>merge</code>合并分支会新增一个<code>merge commit</code>，然后将两个分支的历史联系起来</p>
<p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p>
<h5 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h5><p><code>rebase </code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p>
<p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p>
<h3 id="git-发生冲突的场景？如何解决？"><a href="#git-发生冲突的场景？如何解决？" class="headerlink" title="git 发生冲突的场景？如何解决？"></a>git 发生冲突的场景？如何解决？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>一般情况下，出现分支的场景有如下：</p>
<ul>
<li>多个分支代码合并到一个分支时</li>
<li>多个分支向同一个远端分支推送</li>
</ul>
<p>具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称</p>
<p>如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可</p>
<p>应用在命令中，就是<code>push</code>、<code>pull</code>、<code>stash</code>、<code>rebase</code>等命令下都有可能产生冲突情况，从本质上来讲，都是<code>merge</code>和<code>patch</code>（应用补丁）时产生冲突</p>
<h4 id="二、分析-1"><a href="#二、分析-1" class="headerlink" title="二、分析"></a>二、分析</h4><p>在本地主分值<code>master</code>创建一个<code>a.txt</code>文件，文件起始位置写上<code>master commit</code>，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39353961646532302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>然后提交到仓库：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m ‘master first commit’</li>
</ul>
<p>创建一个新的分支<code>featurel1</code>分支，并进行切换，如下：</p>
<pre><code class="ini">git checkout -b featurel1
</code></pre>
<p>然后修改<code>a.txt</code>文件首行文字为 <code>featurel commit</code>，然后添加到暂存区，并开始进行提交到仓库：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m ‘featurel first change’</li>
</ul>
<p>然后通过<code>git checkout master</code>切换到主分支，通过<code>git merge</code>进行合并，发现不会冲突</p>
<p>此时<code>a.txt</code>文件的内容变成<code>featurel commit</code>，没有出现冲突情况，这是因为<code>git</code>在内部发生了快速合并</p>
<blockquote>
<p>如果当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作</p>
<p>git 不创建任何新的提交(commit)，只是将当前分支指向合并进来的分支</p>
</blockquote>
<p>如果此时切换到<code>featurel</code>分支，将文件的内容修改成<code>featrue second commit</code>，然后提交到本地仓库</p>
<p>然后切换到主分支，如果此时在<code>a.txt</code>文件再次修改，修改成<code>mastet second commit</code>，然后再次提交到本地仓库</p>
<p>此时，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61303534383863302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这种情况下，无法执行快速合并，只能试图把各自的修改合并起来，但这种合并就可能会有冲突</p>
<p>现在通过<code>git merge featurel</code>进行分支合并，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62303939316439302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>从冲突信息可以看到，<code>a.txt</code>发生冲突，必须手动解决冲突之后再提交</p>
<p>而<code>git status</code>同样可以告知我们冲突的文件：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63353832333433302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>打开<code>a.txt</code>文件，可以看到如下内容：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63653761306139302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容：</p>
<ul>
<li>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 和 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 之间的区域就是当前更改的内容</li>
<li>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 之间的区域就是传入进来更改的内容</li>
</ul>
<p>现在要做的事情就是将冲突的内容进行更改，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，<code>Git </code>就会将它们标记为冲突已解决然后再提交：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m “conflict fixed”</li>
</ul>
<p>此时<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64373432316536302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>使用<code>git log</code>命令可以看到合并的信息：</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65306466643162302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></h4><h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>当<code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p>
<p>解决冲突就是把<code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p>
<h3 id="对git-reset-和-git-revert-的理解？区别？"><a href="#对git-reset-和-git-revert-的理解？区别？" class="headerlink" title="对git reset 和 git revert 的理解？区别？"></a>对git reset 和 git revert 的理解？区别？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><h5 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h5><p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p>
<p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61623464306330302d666637322d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h5><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e14636346aeadfa4f5766d89196355a3ff8fd0edadd8b74bd5803cdab3312e60/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643132633239302d666637322d313165622d393931642d3333346664333166303230312e706e67"><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643132633239302d666637322d313165622d393931642d3333346664333166303230312e706e67.png" alt="img"></a></p>
<h4 id="二、如何用"><a href="#二、如何用" class="headerlink" title="二、如何用"></a>二、如何用</h4><h5 id="git-reset-1"><a href="#git-reset-1" class="headerlink" title="git reset"></a>git reset</h5><p>当没有指定<code>ID</code>的时候，默认使用<code>HEAD</code>，如果指定<code>ID</code>，那么就是基于指向<code>ID</code>去变动暂存区或工作区的内容</p>
<pre><code class="ini">// 没有指定ID, 暂存区的内容会被当前ID版本号的内容覆盖，工作区不变
git reset

// 指定ID，暂存区的内容会被指定ID版本号的内容覆盖，工作区不变
git reset &lt;ID&gt; 
</code></pre>
<p>日志<code>ID</code>可以通过查询，可以<code>git log</code>进行查询，如下：</p>
<pre><code class="ini">commit a7700083ace1204ccdff9f71631fb34c9913f7c5 (HEAD -&gt; master)
Author: linguanghui &lt;linguanghui@baidu.com&gt;
Date:   Tue Aug 17 22:34:40 2021 +0800

    second commit

commit e31118663ce66717edd8a179688a7f3dde5a9393
Author: linguanghui &lt;linguanghui@baidu.com&gt;
Date:   Tue Aug 17 22:20:01 2021 +0800

    first commit
</code></pre>
<p>常见命令如下：</p>
<ul>
<li>–mixed（默认）：默认的时候，只有暂存区变化</li>
<li>–hard参数：如果使用 –hard 参数，那么工作区也会变化</li>
<li>–soft：如果使用 –soft 参数，那么暂存区和工作区都不会变化</li>
</ul>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32323562343165302d666637332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="git-revert-1"><a href="#git-revert-1" class="headerlink" title="git revert"></a>git revert</h5><p>跟<code>git reset</code>用法基本一致，<code>git revert</code> 撤销某次操作，此次操作之前和之后的 <code>commit</code>和<code>history</code>都会保留，并且把这次撤销，作为一次最新的提交，如下：</p>
<pre><code class="ini">git revert &lt;commit_id&gt; 
</code></pre>
<p>如果撤销前一个版本，可以通过如下命令：</p>
<pre><code class="ini">git revert HEAD
</code></pre>
<p>撤销前前一次，如下：</p>
<pre><code class="ini">git revert HEAD^
</code></pre>
<h4 id="三、区别-4"><a href="#三、区别-4" class="headerlink" title="三、区别"></a>三、区别</h4><p>撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，<code>git reset</code>被设计为重设本地更改</p>
<p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p>
<p>两者主要区别如下：</p>
<ul>
<li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li>
<li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容</li>
<li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li>
</ul>
<blockquote>
<p>git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并</p>
<p>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</p>
</blockquote>
<ul>
<li>如果回退分支的代码以后还需要的情况则使用<code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用<code>git reset</code></li>
</ul>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mengfeng.github.io/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mians/" rel="tag">mians</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" rel="tag">代码版本控制</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            前端面试题大全前端工程化
          
        </div>
      </a>
    
    
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">前端面试大全设计模式</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '6887374e7666a97fd4dc',
    clientSecret: '09a8e143dd4a3f5d11311e1435842321e063157d',
    repo: 'mengfeng.github.io',
    owner: 'mengfeng',
    admin: ['mengfeng'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>