<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-从0到1搭建自己的脚手架react"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/"
    >从0到1搭建自己的脚手架react</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/" class="article-date">
  <time datetime="2022-11-08T09:16:45.000Z" itemprop="datePublished">2022-11-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/">从0到1搭建自己的脚手架react</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="从0到1搭建自己的脚手架react"><a href="#从0到1搭建自己的脚手架react" class="headerlink" title="从0到1搭建自己的脚手架react"></a>从0到1搭建自己的脚手架react</h1><h3 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1.初始化项目"></a>1.初始化项目</h3><pre><code class="ini">npm init -y
</code></pre>
<p>执行初始化命令之后，会出现package.json文件</p>
<h3 id="2-建立项目目录（基础项目目录）"><a href="#2-建立项目目录（基础项目目录）" class="headerlink" title="2.建立项目目录（基础项目目录）"></a>2.建立项目目录（基础项目目录）</h3><p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108085707668.png"></p>
<h3 id="3-下载依赖"><a href="#3-下载依赖" class="headerlink" title="3.下载依赖"></a>3.下载依赖</h3><p>react</p>
<pre><code class="ini">npm i react react-dom 
</code></pre>
<p>下载babel。babel是javascript编辑器，作用如下：</p>
<ol>
<li>负责把ES6、ES7等高版本js编译成低版本js，供浏览器运行。</li>
<li>负责把react语法（jsx）编译成js。</li>
</ol>
<pre><code class="ini"> npm i @babel/core @babel/cli @babel/preset-env @babel/preset-react --save-dev
</code></pre>
<p>集成webpack。webpack是一个现代JavaScript应用程序的静态模块打包器，现代前端应用很多都是用webpack打包。webpack-dev-server用来搭建一个本地服务，可以热加载前端项目</p>
<pre><code class="ini">npm i webpack webpack-dev-server webpack-cli --save-dev
</code></pre>
<p>webpack集成babel还需要babel-loader，加载html文件还需要插件html-webpack-plugin：</p>
<pre><code class="ini">npm i babel-loader html-webpack-plugin --save-dev
</code></pre>
<h3 id="4-编辑index-html、App-js、index-js"><a href="#4-编辑index-html、App-js、index-js" class="headerlink" title="4.编辑index.html、App.js、index.js"></a>4.编辑index.html、App.js、index.js</h3><pre><code class="html">//index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;root&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="javascript">//App.js
import React from &quot;react&quot;;
class App extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                App
            &lt;/div&gt;
          );
    &#125;
&#125;

export default App
</code></pre>
<pre><code class="javascript">//index.js
import React from &#39;react&#39;;
import &#123; createRoot &#125; from &#39;react-dom/client&#39;;
import App from &#39;./App&#39;;

const root = createRoot(document.getElementById(&#39;root&#39;))
root.render(&lt;App /&gt;)
</code></pre>
<h3 id="5-在根目录下添加-babelrc文件、webpack-config-js文件"><a href="#5-在根目录下添加-babelrc文件、webpack-config-js文件" class="headerlink" title="5.在根目录下添加.babelrc文件、webpack.config.js文件"></a>5.在根目录下添加.babelrc文件、webpack.config.js文件</h3><p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108093539451.png"></p>
<h3 id="6-配置-babelrc、webpack-config-js"><a href="#6-配置-babelrc、webpack-config-js" class="headerlink" title="6.配置.babelrc、webpack.config.js"></a>6.配置.babelrc、webpack.config.js</h3><pre><code class="javascript">//.babelrc
&#123;
    &quot;presets&quot;: [&quot;@babel/preset-env&quot;,&quot;@babel/preset-react&quot;]
&#125;
</code></pre>
<pre><code class="javascript">//webpack.config.js
const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.js&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.m?js/,
                use:&#39;babel-loader&#39;,
                exclude:/node_modules/
            &#125;
        ]
    &#125;,
    //webpack加载html文件需要html-webpack-plugin插件处理。
    //启动webpack-dev-server的时候，会把打包好的js文件，css文件，html文件放在内存里
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;

&#125;
</code></pre>
<h3 id="7-当我们配置好上面的项目了，现在我们就可以运行了"><a href="#7-当我们配置好上面的项目了，现在我们就可以运行了" class="headerlink" title="7.当我们配置好上面的项目了，现在我们就可以运行了"></a>7.当我们配置好上面的项目了，现在我们就可以运行了</h3><p>现在我们还得配置一个小细节package,json</p>
<pre><code class="javascript">&#123;
  &quot;name&quot;: &quot;react-app-start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: &#123;
    //--mode=development为开发环境，速度较快，上线可以配置为生产环境，会压缩，优化代码
    //--watch为监听代码变化，只要代码变化，会重新编译
    //build是生产环境的打包
    &quot;serve&quot;: &quot;webpack --mode=development --watch&quot;,
    &quot;build&quot;: &quot;webpack --mode=production&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: &#123;
    &quot;react&quot;: &quot;^18.2.0&quot;,
    &quot;react-dom&quot;: &quot;^18.2.0&quot;,
    &quot;webpack&quot;: &quot;^5.74.0&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;@babel/cli&quot;: &quot;^7.19.3&quot;,
    &quot;@babel/core&quot;: &quot;^7.20.2&quot;,
    &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;,
    &quot;@babel/preset-react&quot;: &quot;^7.18.6&quot;,
    &quot;babel-loader&quot;: &quot;^9.1.0&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,
    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;
  &#125;
&#125;
</code></pre>
<p>这时候就可以执行命令了</p>
<pre><code class="ini">npm run serve
</code></pre>
<p>打包执行命令</p>
<pre><code class="ini">npm run build
</code></pre>
<h3 id="8-如果没有报错的话，你就会看见下面的页面"><a href="#8-如果没有报错的话，你就会看见下面的页面" class="headerlink" title="8.如果没有报错的话，你就会看见下面的页面"></a>8.如果没有报错的话，你就会看见下面的页面</h3><p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108100300240.png"></p>
<h3 id="9-至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server："><a href="#9-至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server：" class="headerlink" title="9.至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server："></a>9.至此webpack简易版配置已经完成。接下来配置热加载功能，下载webpack-dev-server：</h3><pre><code class="ini">npm i webpack-dev-server --save-dev
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108100733217.png"></p>
<p>执行命令：</p>
<pre><code class="ini">npm run start
</code></pre>
<p>项目在3000端口启动，启动后会自动打开浏览器窗口。热加载配置完成，文件修改保存后浏览器直接展示出来。</p>
<p>到此react项目简化版搭建完成。后续继续集成其他工具库即可。</p>
<h3 id="10-react使用ts"><a href="#10-react使用ts" class="headerlink" title="10.react使用ts"></a>10.react使用ts</h3><p>ts对比js最大的特点就是多了类型检查。推荐前端语言使用ts。接下来介绍在webpack中配置ts。</p>
<p>安装typescript、ts-loader。typescript是ts编辑器，把ts代码编译成js，ts-loader是让webpack识别.ts&#x2F;.tsx文件，调用编译器编译，</p>
<pre><code class="ini">npm i typescript ts-loader --save-dev
</code></pre>
<p>添加ts配置文件,在根目录下添加tsconfig.json：</p>
<pre><code class="ini">//tsconfig.json
&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;es5&quot;,
        &quot;lib&quot;:[&quot;es6&quot;,&quot;dom&quot;],
        &quot;module&quot;: &quot;esnext&quot;,
        &quot;moduleResolution&quot;: &quot;node&quot;,
        &quot;jsx&quot;:&quot;react&quot;,
        &quot;sourceMap&quot;: true,
        &quot;strict&quot;: true,
        &quot;importHelpers&quot;: true,
        &quot;skipLibCheck&quot;: true,
        &quot;allowJs&quot;: true,
        &quot;allowSyntheticDefaultImports&quot;: true
    &#125;
&#125;
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108101701100.png"></p>
<p>修改webpack配置</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.tsx&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.m?js|tsx$/,
                use:&#39;ts-loader&#39;,
                exclude:/node_modules/
            &#125;
        ]
    &#125;,
    //增加扩展选项，让webpack可以识别.ts/tsx文件
    resolve:&#123;
        extensions:[&#39;.ts&#39;,&#39;.tsx&#39;,&#39;.js&#39;]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;

&#125;
</code></pre>
<p>目前可能会报错</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108110219148.png"></p>
<p>根据提示，我们缺一些依赖</p>
<pre><code class="ini">npm i --save-dev @types/react
npm i --save-dev @types/react-dom
</code></pre>
<p>这个时候我们还会遇到一个问题</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108111925911.png"></p>
<p>那么这个问题的原因是缺null类型检测</p>
<p>其他人回答说应该添加null检查，但Typescript也有一个非null断言，当您通过添加！运算符添加到语句末尾：</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108112118833.png"></p>
<p>这个时候我们react使用ts的问题就解决了</p>
<p>启动项目，运行成功，ts集成成功了</p>
<h3 id="11-react集成路由"><a href="#11-react集成路由" class="headerlink" title="11.react集成路由"></a>11.react集成路由</h3><p>安装路由库</p>
<pre><code class="ini">npm install react-router-dom@6
</code></pre>
<p>创建项目目录</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108143446498.png"></p>
<p>编辑About.tsx、Home.tsx、index.tsx、App.tsx</p>
<pre><code class="tsx">//About.tsx
import React from &quot;react&quot;;
import &#123; Link &#125; from &quot;react-router-dom&quot;;

class About extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                this is about&lt;br/&gt;
                &lt;Link to=&#123;&#39;/home&#39;&#125;&gt;to home&lt;/Link&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default About;
</code></pre>
<pre><code class="tsx">//Home.tsx
import React from &quot;react&quot;;
import &#123; Link &#125; from &quot;react-router-dom&quot;;

class Home extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                this is home&lt;br/&gt;
                &lt;Link to=&#123;&#39;/about&#39;&#125;&gt;to about&lt;/Link&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default Home;
</code></pre>
<pre><code class="tsx">//App.tsx
import React from &quot;react&quot;;
import &#123; Routes,Route &#125; from &quot;react-router-dom&quot;;
import About from &quot;./compents/About&quot;;
import Home from &quot;./compents/Home&quot;;

class App extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                &lt;Routes&gt;
                    &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;
                &lt;/Routes&gt;
            &lt;/div&gt;
          );
    &#125;
&#125;

export default App
</code></pre>
<pre><code class="tsx">//index.tsx
import React from &#39;react&#39;;
import &#123; createRoot &#125; from &#39;react-dom/client&#39;;
import App from &#39;./App&#39;;
import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;;

const root = createRoot(document.getElementById(&#39;root&#39;)!)
root.render(
    &lt;BrowserRouter&gt;
        &lt;App /&gt;
    &lt;/BrowserRouter&gt;
)
</code></pre>
<p>react路由搭建成功</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108143901241.png"></p>
<h3 id="12-react使用redux"><a href="#12-react使用redux" class="headerlink" title="12.react使用redux"></a>12.react使用redux</h3><p>对于大型项目来说，数据管理工具也是必不可少的。我们简单介绍redux、react-redux的使用。这里使用的是@reduxjs&#x2F;toolkit库，相比redux库使用方法有很大区别，想用redux库的请自行查看redux文档。</p>
<p>下载依赖</p>
<pre><code class="ini">npm i @reduxjs/toolkit react-redux
</code></pre>
<p>创建项目目录</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108151822086.png"></p>
<p>编辑store.ts、countSlice.ts、counter.tsx、index.tsx、App.tsx</p>
<pre><code class="tsx">//store.ts
import &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;;
import counterReducer from &#39;./countSlice&#39;;

export default configureStore(&#123;
    reducer:&#123;
        counter:counterReducer
    &#125;
&#125;)
</code></pre>
<pre><code class="tsx">//countSlice.ts
import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;

export const counterSlice = createSlice(&#123;
    name:&#39;counter&#39;,
    initialState:&#123;
        value:0
    &#125;,
    reducers:&#123;
        increment:(state) =&gt; &#123;
            state.value += 1
        &#125;,
        decrement:(state) =&gt;&#123;
            state.value -= 1
        &#125;,
        incrementByAmount:(state,action) =&gt; &#123;
            state.value += action.payload
        &#125;
    &#125;
&#125;)

export const &#123; increment,decrement,incrementByAmount &#125; = counterSlice.actions
export default counterSlice.reducer
</code></pre>
<pre><code class="tsx">//index.tsx
import React from &#39;react&#39;;
import &#123; createRoot &#125; from &#39;react-dom/client&#39;;
import App from &#39;./App&#39;;
import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;;
import store  from &#39;./store/store&#39;;
import &#123; Provider &#125; from &#39;react-redux&#39;;

const root = createRoot(document.getElementById(&#39;root&#39;)!)
root.render(
    &lt;BrowserRouter&gt;
    &lt;Provider store=&#123;store&#125;&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;  
    &lt;/BrowserRouter&gt;
)
</code></pre>
<pre><code class="tsx">//counter.tsx
import React from &quot;react&quot;;
import &#123; useSelector,useDispatch &#125; from &quot;react-redux&quot;;
import &#123; decrement,increment &#125; from &quot;../store/countSlice&quot;;

function Counter()&#123;
    const count = useSelector((state:any) =&gt; state.counter.value)
    const dispatch = useDispatch()
    
    return (
        &lt;div&gt;
            &lt;div&gt;
                &lt;button 
                aria-label=&quot;Increment value&quot;
                onClick=&#123;() =&gt; dispatch(increment())&#125;
                &gt;
                    increment
                &lt;/button&gt;
                &lt;span&gt;&#123;count&#125;&lt;/span&gt;
                &lt;button
                aria-label=&quot;Decrement value&quot;
                onClick=&#123;() =&gt; dispatch(decrement())&#125;
                &gt;
                    Decrement
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
&#125;

export default Counter;
</code></pre>
<pre><code class="tsx">//App.tsx
import React from &quot;react&quot;;
import &#123; Routes,Route &#125; from &quot;react-router-dom&quot;;
import About from &quot;./compents/About&quot;;
import Home from &quot;./compents/Home&quot;;
import Counter from &quot;./compents/Counter&quot;;

class App extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                &lt;Routes&gt;
                    &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;
                    &lt;Route path=&quot;/counter&quot; element=&#123;&lt;Counter /&gt;&#125;&gt;&lt;/Route&gt;
                &lt;/Routes&gt;
            &lt;/div&gt;
          );
    &#125;
&#125;

export default App
</code></pre>
<p>当我执行命令进入counter组件点击功能按钮就发现redux使用成功了</p>
<pre><code class="ini">npm run start
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108152335825.png"></p>
<h3 id="13-集成UI库"><a href="#13-集成UI库" class="headerlink" title="13.集成UI库"></a>13.集成UI库</h3><p>这里使用的是antd第三方库</p>
<p>安装ui库</p>
<pre><code class="ini">npm i antd
</code></pre>
<p>使用antd还需要引用其样式文件，因此还需要下载css-loader、style-loader。</p>
<pre><code class="ini">npm i style-loader css-loader -D
</code></pre>
<p>修改webpack配置</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.tsx&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.j|tsx$/,
                use:&#39;ts-loader&#39;,
                exclude:/node_modules/
            &#125;,
            &#123;
                test:/.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;
        ]
    &#125;,
    //增加扩展选项，让webpack可以识别.ts/tsx文件
    resolve:&#123;
        extensions:[&#39;.ts&#39;,&#39;.tsx&#39;,&#39;.js&#39;]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;
&#125;
</code></pre>
<p>使用antd的话直接引入使用就可以了</p>
<pre><code class="tsx">//Home.tsx
import React from &quot;react&quot;;
import &#123; Link &#125; from &quot;react-router-dom&quot;;
import &#123; Button &#125; from &quot;antd&quot;;

class Home extends React.PureComponent&#123;
    render()&#123;
        return (
            &lt;div&gt;
                this is home&lt;br/&gt;
                &lt;Link to=&#123;&#39;/about&#39;&#125;&gt;
                    &lt;Button type=&#123;&#39;primary&#39;&#125;&gt;to about&lt;/Button&gt;
                &lt;/Link&gt;
                &lt;Link to=&#123;&#39;/counter&#39;&#125;&gt;
                    &lt;Button type=&#123;&#39;primary&#39;&#125;&gt;to counter&lt;/Button&gt; 
                &lt;/Link&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

export default Home;
</code></pre>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221108153155300.png"></p>
<h3 id="14-跨域问题"><a href="#14-跨域问题" class="headerlink" title="14.跨域问题"></a>14.跨域问题</h3><p>修改webpack.config.js使用proxy</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    //webpack入口文件，webpack从这里开始构建依赖图
    entry:&#123;
        main:&#39;./src/index.tsx&#39;
    &#125;,
    //输出文件 ./dist/bundle.js
    output:&#123;
        path: path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    //webpack只能处理js和json文件，加载别的文件需要loader
    module:&#123;
        rules:[
            &#123;
                test:/.j|tsx$/,
                use:&#39;ts-loader&#39;,
                exclude:/node_modules/
            &#125;,
            &#123;
                test:/.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;
        ]
    &#125;,
    //增加扩展选项，让webpack可以识别.ts/tsx文件
    resolve:&#123;
        extensions:[&#39;.ts&#39;,&#39;.tsx&#39;,&#39;.js&#39;]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./public/index.html&#39;
        &#125;)
    ],
    mode:&#39;development&#39;,
    devServer:&#123;
        proxy:&#123;
            &#39;/api&#39;:&#39;http://localhost:8080&#39;,
        &#125;,
        client:&#123;
            progress:true
        &#125;
    &#125;

&#125;
</code></pre>
<p>配置后，前端请求就会被代理到8080端口，解决跨域问题</p>
<p>15.集成ESLint和prettier</p>
<p>安装ESLint</p>
<pre><code class="ini">//本地安装
npm install eslint --save-dev
//全局安装
npm install -g eslint
</code></pre>
<p>运行eslint –init，选择工程使用了react，自动生成.eslintrc.js文件</p>
<pre><code class="ini">eslint --init
</code></pre>
<p>安装prettier</p>
<pre><code class="ini">//本地
npm i -D --save-exact prettier
//全局
npm i --global prettier
</code></pre>
<p>安装eslint-config-prettier插件（禁用 eslint 风格校验)</p>
<pre><code class="ini">npm i -D eslint-config-prettier
</code></pre>
<p>安装eslint-plugin-prettier插件（使eslint采用prettier的风格校验）</p>
<pre><code class="ini">npm i -D eslint-plugin-prettier
</code></pre>
<p>配置eslintrc.js文件</p>
<pre><code class="javascript">// eslint-disable-next-line no-undef
module.exports = &#123;
    &quot;env&quot;: &#123;
        &quot;browser&quot;: true,
        &quot;es2021&quot;: true,
        &quot;jest&quot;:true
    &#125;,
    &quot;extends&quot;: [
        &quot;eslint:recommended&quot;,
        &quot;plugin:react/recommended&quot;,
        &quot;plugin:@typescript-eslint/recommended&quot;
    ],
    &quot;overrides&quot;: [
    ],
    &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,
    &quot;parserOptions&quot;: &#123;
        &quot;ecmaVersion&quot;: &quot;latest&quot;
    &#125;,
    &quot;plugins&quot;: [
        &quot;react&quot;,
        &quot;@typescript-eslint&quot;
    ],
    &quot;rules&quot;: &#123;
    &quot;no-cond-assign&quot;: 2,
    &quot;no-console&quot;: [
      &quot;error&quot;, &#123;
        &quot;allow&quot;: [&quot;log&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;info&quot;]
      &#125;
    ],
    // 禁止 function 定义中出现重名参数
    &quot;no-dupe-args&quot;: 2,
    // 禁止对象字面量中出现重复的 key
    &quot;no-dupe-keys&quot;: 2,
    // 禁止重复的 case 标签
    &quot;no-duplicate-case&quot;: 2,
    // 禁止对 catch 子句的参数重新赋值
    &quot;no-ex-assign&quot;: 2,
    // 禁止不必要的布尔转换
    &quot;no-extra-boolean-cast&quot;: 2,
    // 禁止不必要的括号 //(a * b) + c;//报错
    &quot;no-extra-parens&quot;: 0,
    // 禁止 catch 子句的参数与外层作用域中的变量同名
    &quot;no-catch-shadow&quot;: 0,
    // 不允许标签与变量同名
    &quot;no-label-var&quot;: 2,
    // 禁用特定的全局变量
    &quot;no-restricted-globals&quot;: 2,
    // 禁止覆盖受限制的标识符
    &quot;no-shadow-restricted-names&quot;: 2,
    // 禁止将变量初始化为 undefined
    
    // 强制使用一致的换行风格
    &quot;linebreak-style&quot;: [2, &quot;unix&quot;],
    //在JSX中强制布尔属性符号
    &quot;react/jsx-boolean-value&quot;: 2,
    //在JSX中验证右括号位置
    // &quot;react/jsx-closing-bracket-location&quot;: 1,
    //在JSX属性和表达式中加强或禁止大括号内的空格。
    &quot;react/jsx-curly-spacing&quot;: [2, &#123;
      &quot;when&quot;: &quot;never&quot;,
      &quot;children&quot;: true
    &#125;],
    //在数组或迭代器中验证JSX具有key属性
    &quot;react/jsx-key&quot;: 2,
    // 限制JSX中单行上的props的最大数量
    &quot;react/jsx-max-props-per-line&quot;: [1, &#123;
      &quot;maximum&quot;: 5
    &#125;],
    //防止在JSX中重复的props
    &quot;react/jsx-no-duplicate-props&quot;: 2,
    //  //防止使用未包装的JSX字符串
    // &quot;react/jsx-no-literals&quot;: 0,
    //在JSX中禁止未声明的变量
    &quot;react/jsx-no-undef&quot;: 2,
    //为用户定义的JSX组件强制使用PascalCase
    &quot;react/jsx-pascal-case&quot;: 0,
    //防止反应被错误地标记为未使用
    &quot;react/jsx-uses-react&quot;: 2,
    //防止在JSX中使用的变量被错误地标记为未使用
    &quot;react/jsx-uses-vars&quot;: 2,
    //防止在componentDidMount中使用setState
    &quot;react/no-did-mount-set-state&quot;: 2,
    //防止在componentDidUpdate中使用setState
    &quot;react/no-did-update-set-state&quot;: 2,
    //防止使用未知的DOM属性
    &quot;react/no-unknown-property&quot;: 2,
    //为React组件强制执行ES5或ES6类
    &quot;react/prefer-es6-class&quot;: 2,
    //防止在React组件定义中丢失props验证
    // &quot;react/prop-types&quot;: 1,
    //使用JSX时防止丢失React
    &quot;react/react-in-jsx-scope&quot;: 2,
    //防止没有children的组件的额外结束标签
    &quot;react/self-closing-comp&quot;: 0,
    //禁止不必要的bool转换
    // &quot;no-extra-boolean-cast&quot;: 0,
    //防止在数组中遍历中使用数组key做索引
    // &quot;react/no-array-index-key&quot;: 0,
    //不使用弃用的方法
    &quot;react/no-deprecated&quot;: 2,
    //在JSX属性中强制或禁止等号周围的空格
    &quot;react/jsx-equals-spacing&quot;: 2,
    &quot;react/jsx-filename-extension&quot;: [2, &#123;
      &quot;extensions&quot;: [&quot;.js&quot;, &quot;.jsx&quot;]
    &#125;],
    // 禁止未使用的变量
    &quot;no-unused-vars&quot;: 0,
    &#125;
&#125;
</code></pre>
<p>当我们代码被eslint检测到不符合规则的代码就会提示，根据eslint指示修改就可以</p>
<p>在根目录下创建.prettierrc 或 prettier.config.js文件</p>
<pre><code class="javascript">module.exports = &#123;
    endOfLine: &#39;auto&#39;, // 不检测检测文件每行结束的格式
    semi: true, // 使用分号, 默认true
    singleQuote: true // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)
 &#125;
</code></pre>
<p>安装vscode插件：Prettier ESLint</p>
<p><img src="/2022/11/08/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6react/image-20221107154026317.png"></p>
<p>该插件会根据工程根目录下的eslintrc.js和prettier.config.js文件格式化代码。可以进一步设置为vscode默认formater和自动格式化。</p>
<p>Prettier配置常用的参数可以根据团队需求制定</p>
<p>该文章只是配置简单的react脚手架，核心流程和方法是如此，其他具体需求可以根据团队客制化定制</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[antd官网]: 	“<a target="_blank" rel="noopener" href="https://ant.design/docs/react/introduce-cn">https://ant.design/docs/react/introduce-cn</a> “<br>[ESLint中文文档]: 	“<a target="_blank" rel="noopener" href="https://eslint.bootcss.com/">https://eslint.bootcss.com</a> “<br>[Prettier中文网]: 	“<a target="_blank" rel="noopener" href="https://www.prettier.cn/">https://www.prettier.cn</a> “</p>
<h3 id="源码仓库地址："><a href="#源码仓库地址：" class="headerlink" title="源码仓库地址："></a>源码仓库地址：</h3><p><a target="_blank" rel="noopener" href="https://github.com/mengfeng/react-app-start.git">https://github.com/mengfeng/react-app-start.git</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-从0到1搭建自己的脚手架vue3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/"
    >从0到1搭建自己的脚手架vue3</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/" class="article-date">
  <time datetime="2022-11-07T08:16:04.000Z" itemprop="datePublished">2022-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/">从0到1搭建自己的脚手架vue3</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="搭建vue项目脚手架"><a href="#搭建vue项目脚手架" class="headerlink" title="搭建vue项目脚手架"></a>搭建vue项目脚手架</h1><h3 id="1-所以的网站都需要一个页面，所以创建第一个-html文件（index-html）"><a href="#1-所以的网站都需要一个页面，所以创建第一个-html文件（index-html）" class="headerlink" title="1.所以的网站都需要一个页面，所以创建第一个.html文件（index.html）"></a>1.所以的网站都需要一个页面，所以创建第一个.html文件（index.html）</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;vue-cli-start&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
   &lt;!-- 引入打包后的js文件 --&gt;
    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="2-创建src和dist文件夹"><a href="#2-创建src和dist文件夹" class="headerlink" title="2.创建src和dist文件夹"></a>2.创建src和dist文件夹</h3><p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107081630590.png"></p>
<p>因为index.html需要引入打包后的bundle.js文件，所以将index.js放到了dist目录下</p>
<h3 id="3-创建入口文件main-js"><a href="#3-创建入口文件main-js" class="headerlink" title="3.创建入口文件main.js"></a>3.创建入口文件main.js</h3><p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107082550022.png"></p>
<p>我们需要引入vue实例，但是现在我们没有vue包，所以要先下载vue</p>
<p>我们也可以一次性下载vue所需要的依赖</p>
<pre><code class="ini">npm i vue element-ui axios
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107083055837.png"></p>
<h3 id="4-安装开发依赖"><a href="#4-安装开发依赖" class="headerlink" title="4.安装开发依赖"></a>4.安装开发依赖</h3><pre><code class="ini">npm i -D webpack webpack-cli vue-loader vue-template-compiler sass sass-loader css-loader style-loader babel-loader @babel/core @babel/preset-env
</code></pre>
<p>如果项目文件没有package.json,那么</p>
<pre><code class="ini">npm init -y
</code></pre>
<h3 id="5-创建webpack-config-js并配置-根目录下和package-json同一目录创建"><a href="#5-创建webpack-config-js并配置-根目录下和package-json同一目录创建" class="headerlink" title="5.创建webpack.config.js并配置(根目录下和package.json同一目录创建)"></a>5.创建webpack.config.js并配置(根目录下和package.json同一目录创建)</h3><pre><code class="javascript">//webpack.config.js基本配置模板
module.exports = &#123;
    //入口，表示从那个文件开始解析
    entry:&#39;&#39;,
    //出口，表示输出文件位置和信息
    output:&#123;
        path:&#39;&#39;,
        filename:&#39;&#39;
    &#125;,
    //模块，定义匹配规则和转换loader
    module:&#123;
        rules:[
            &#123;test:/\.vue$/,use:&#39;vue-loader&#39;&#125;,
            &#123;&#125;
        ]
    &#125;,
    //插件,给予webpack更丰富的功能
    plugins:[
        //实例化
        new PluginA()
    ]

&#125;
</code></pre>
<p>基本配置完成的webpack.config.js</p>
<pre><code class="javascript">const path = require(&#39;path&#39;)
const &#123;VueLoaderPlugin&#125; = require(&#39;vue-loader&#39;)
module.exports = &#123;
    entry:&#39;./src/main.js&#39;,
    output:&#123;
        path:path.resolve(__dirname,&#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;,
    module:&#123;
        rules:[
            &#123;test:/\.vue$/,use:&#39;vue-loader&#39;&#125;,
            &#123;test:/\.s[ca]ss$/,use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;sass-loader&#39;]&#125;,
            &#123;
                test:/\.m?js$/,
                use:&#123;
                    loader:&#39;babel-loader&#39;,
                    options:&#123;
                        presets:[&#39;@babel/preset-env&#39;],
                    &#125;
                &#125;
            &#125;,
            //老语法
            // &#123;test:/\.(png|jpe?g|svg|gif|webp)$/,use:&#123;loader:&#39;file-loader&#39;,options:&#123;esModule:&#39;false&#39;&#125;&#125;&#125;
            &#123;test:/\.(png|jpe?g|svg|gif|webp)$/,type:&#39;asset/resource&#39;&#125;,
        ]
    &#125;,
    plugins:[
        new VueLoaderPlugin()
    ]
&#125;
</code></pre>
<h3 id="6-编辑书写main-js文件和App-vue"><a href="#6-编辑书写main-js文件和App-vue" class="headerlink" title="6.编辑书写main.js文件和App.vue"></a>6.编辑书写main.js文件和App.vue</h3><pre><code class="javascript">//main.js
import &#123; createApp &#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;
createApp(App).mount(&#39;#app&#39;)
</code></pre>
<pre><code class="vue">//App.vue
&lt;template&gt;
    &lt;div&gt;
        艺术码畜博客‘https://mengfeng.github.io/’
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;&#125;
&lt;/script&gt;
&lt;style lang=&quot;scss&quot; scoped&gt;
&lt;/style&gt;
</code></pre>
<h3 id="7-那么我们现在应该可以运行所配置的代码了"><a href="#7-那么我们现在应该可以运行所配置的代码了" class="headerlink" title="7.那么我们现在应该可以运行所配置的代码了"></a>7.那么我们现在应该可以运行所配置的代码了</h3><p>现在出现一个问题，直接执行webpack命令会找不到webpack命令，虽然我们下载了webpack-cli，但是只是存在于.&#x2F;node_modules&#x2F;.bin里面</p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107100606449.png"></p>
<p>那我们执行.&#x2F;node_modules&#x2F;.bin&#x2F;webpack也是可以打包的，但是我们每次执行这么长的命令不是很方便，所以通过配置package.json文件来简化命令</p>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;vue-cli-start&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;:&#123;
    //--mode=development为开发环境，速度较快，上线可以配置为生产环境，会压缩，优化代码
    //--watch为监听代码变化，只要代码变化，会重新编译
    //build是生产环境的打包
    &quot;serve&quot;:&quot;webpack --mode=development --watch&quot;,
    &quot;build&quot;:&quot;webpack --mode=production&quot;
  &#125;,
 &quot;dependencies&quot;: &#123;
    &quot;axios&quot;: &quot;^1.1.3&quot;,
    &quot;element-ui&quot;: &quot;^2.15.10&quot;,
    &quot;vue&quot;: &quot;^3.2.41&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;@babel/core&quot;: &quot;^7.20.2&quot;,
    &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;,
    &quot;babel-loader&quot;: &quot;^9.1.0&quot;,
    &quot;css-loader&quot;: &quot;^6.7.1&quot;,
    &quot;sass&quot;: &quot;^1.56.0&quot;,
    &quot;sass-loader&quot;: &quot;^13.1.0&quot;,
    &quot;style-loader&quot;: &quot;^3.3.1&quot;,
    &quot;vue-loader&quot;: &quot;^17.0.1&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.7.13&quot;,
    &quot;webpack&quot;: &quot;^5.74.0&quot;,
    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;
  &#125;,
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<p>当我们执行npm run serve</p>
<pre><code class="ini">npm run serve
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107110605226.png"></p>
<p>表示我们编译成功了，我们现在可以试着运行一下index.html</p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107110725484.png"></p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107110748068.png"></p>
<p>恭喜，目前为止已经没有什么问题了！！！基础的vue脚手架就完成了（目前只是一个页面）</p>
<h3 id="8-我们需要多个页面的时候，就需要其他依赖了"><a href="#8-我们需要多个页面的时候，就需要其他依赖了" class="headerlink" title="8.我们需要多个页面的时候，就需要其他依赖了"></a>8.我们需要多个页面的时候，就需要其他依赖了</h3><p>根据下面的配置来修改自己的代码，可能下面的代码于上面的不同，但效果是一样的</p>
<pre><code class="ini">npm i vue-router
</code></pre>
<h3 id="9-创建route文件夹和pages文件夹"><a href="#9-创建route文件夹和pages文件夹" class="headerlink" title="9.创建route文件夹和pages文件夹"></a>9.创建route文件夹和pages文件夹</h3><p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107143307837.png"></p>
<h3 id="10-编辑App-vue和route下的index-js文件"><a href="#10-编辑App-vue和route下的index-js文件" class="headerlink" title="10.编辑App.vue和route下的index.js文件"></a>10.编辑App.vue和route下的index.js文件</h3><pre><code class="vue">//App.vue
&lt;template&gt;
    &lt;div id=&quot;nav&quot;&gt;
        &lt;router-link to=&quot;/&quot;&gt; home &lt;/router-link&gt; |
        &lt;router-link to=&quot;/food&quot;&gt; food &lt;/router-link&gt; |
        &lt;router-link to=&quot;/banner&quot;&gt; banner &lt;/router-link&gt;
    &lt;/div&gt;
    &lt;router-view /&gt;
&lt;/template&gt;
</code></pre>
<p>这里我们使用的是history，也可以用hash</p>
<pre><code class="javascript">//route/index.js
import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;
//注册
import home from &#39;../pages/Home.vue&#39;
import food from &#39;../pages/Food.vue&#39;
import banner from &#39;../pages/Banner.vue&#39;

const routes = [
  &#123; path: &quot;/&quot;, redirect: &quot;/home&quot; &#125;,
  &#123;
    path: &quot;/home&quot;,
    name: &quot;home&quot;,
    component: home
  &#125;,
  &#123;
    path: &quot;/food&quot;,
    name: &quot;food&quot;,
    component: food
  &#125;,
  &#123;
    path: &quot;/banner&quot;,
    name: &quot;banner&quot;,
    component: banner
  &#125;
]
//导出
const router = createRouter(&#123;
    history: createWebHashHistory(),
    routes: routes
  &#125;)

  export default router;
</code></pre>
<h3 id="11-需要在main-js里面去注册"><a href="#11-需要在main-js里面去注册" class="headerlink" title="11.需要在main.js里面去注册"></a>11.需要在main.js里面去注册</h3><pre><code class="javascript">import &#123; createApp &#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import router from &#39;./route&#39;

const app = createApp(App)
app.use(router)
app.mount(&#39;#app&#39;)
</code></pre>
<h3 id="12-这个时候再去跑我们的代码就可以了"><a href="#12-这个时候再去跑我们的代码就可以了" class="headerlink" title="12.这个时候再去跑我们的代码就可以了"></a>12.这个时候再去跑我们的代码就可以了</h3><pre><code class="ini">npm run serve
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107143925345.png"></p>
<h3 id="13-页面之间的route跳转"><a href="#13-页面之间的route跳转" class="headerlink" title="13.页面之间的route跳转"></a>13.页面之间的route跳转</h3><pre><code class="vue">//Food.vue
&lt;template&gt;
    &lt;p&gt;food&lt;/p&gt;
    &lt;button @click=&quot;toHome&quot;&gt;toHome&lt;/button&gt;
     &lt;!-- router-link组件跳转 --&gt;
    &lt;router-link to=&quot;/home&quot;&gt;toHome&lt;/router-link&gt;
  &lt;/template&gt;
  &lt;script&gt;
  import &#123; useRouter &#125; from &#39;vue-router&#39;
  export default &#123;
    setup () &#123;
      //编程式跳转
      const router = useRouter()
      const toHome = (() =&gt; &#123;
        router.push(&#123;
          name: &#39;home&#39;
        &#125;)
      &#125;)
      return &#123;
        toHome
      &#125;
    &#125;,
  &#125;
  &lt;/script&gt;
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107145442966.png"></p>
<p>当我们点击toHome按钮就可以跳转到home页了,两种方式都可以跳转</p>
<h3 id="14-配置ESLint和Prettier"><a href="#14-配置ESLint和Prettier" class="headerlink" title="14.配置ESLint和Prettier"></a>14.配置ESLint和Prettier</h3><p>安装ESLint</p>
<pre><code class="ini">//本地安装
npm install eslint --save-dev
//全局安装
npm install -g eslint
</code></pre>
<p>运行eslint –init，选择工程使用了vue，自动生成.eslintrc.js文件</p>
<pre><code class="ini">eslint --init
</code></pre>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107151858584.png"></p>
<p>我们按照需求去选择就可以了</p>
<p>安装prettier</p>
<pre><code class="ini">//本地
npm i -D --save-exact prettier
//全局
npm i --global prettier
</code></pre>
<p>安装eslint-config-prettier插件（禁用 eslint 风格校验)</p>
<pre><code class="ini">npm i -D eslint-config-prettier
</code></pre>
<p>安装eslint-plugin-prettier插件（使eslint采用prettier的风格校验）</p>
<pre><code class="ini">npm i -D eslint-plugin-prettier
</code></pre>
<p>配置eslintrc.js文件</p>
<pre><code class="javascript">module.exports = &#123;
    &quot;env&quot;: &#123;
        &quot;browser&quot;: true,
        &quot;es2021&quot;: true,
        &quot;node&quot;:true,
    &#125;,
    &quot;extends&quot;: [
        &quot;eslint:recommended&quot;,
        &quot;plugin:vue/vue3-essential&quot;
    ],
    &quot;overrides&quot;: [
    ],
    &quot;parserOptions&quot;: &#123;
        &quot;ecmaVersion&quot;: &quot;latest&quot;
    &#125;,
    &quot;plugins&quot;: [
        &quot;vue&quot;
    ],
    &quot;rules&quot;: &#123;
      &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;warn&#39; : &#39;off&#39;,
      &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;warn&#39; : &#39;off&#39;,
       //在rules中添加自定义规则
       //关闭组件命名规则
       &quot;vue/multi-word-component-names&quot;:&quot;off&quot;,
    &#125;
&#125;
</code></pre>
<p>在根目录下创建.prettierrc 或 prettier.config.js文件</p>
<pre><code class="javascript">module.exports = &#123;
    endOfLine: &#39;auto&#39;, // 不检测检测文件每行结束的格式
    semi: true, // 使用分号, 默认true
    singleQuote: true // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)
  &#125;
</code></pre>
<p>安装vscode插件：Prettier ESLint</p>
<p><img src="/2022/11/07/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6vue3/image-20221107154026317.png"></p>
<p>该插件会根据工程根目录下的eslintrc.js和prettier.config.js文件格式化代码。可以进一步设置为vscode默认formater和自动格式化。</p>
<p>Prettier配置常用的参数可以根据团队需求制定</p>
<h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p>[ESLint中文文档]: 	“<a target="_blank" rel="noopener" href="https://eslint.bootcss.com/">https://eslint.bootcss.com</a> “<br>[Prettier中文网]: 	“<a target="_blank" rel="noopener" href="https://www.prettier.cn/">https://www.prettier.cn</a> “</p>
<h3 id="源码仓库地址："><a href="#源码仓库地址：" class="headerlink" title="源码仓库地址："></a>源码仓库地址：</h3><p><a target="_blank" rel="noopener" href="https://github.com/mengfeng/vue-cli-start">https://github.com/mengfeng/vue-cli-start</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/" rel="tag">工程技术</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据埋点监控系统设计"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"
    >数据埋点监控系统设计</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2022-11-06T01:48:56.000Z" itemprop="datePublished">2022-11-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">数据埋点监控系统设计</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="数据监控和数据埋点"><a href="#数据监控和数据埋点" class="headerlink" title="数据监控和数据埋点"></a>数据监控和数据埋点</h1><h3 id="一、数据监控分类"><a href="#一、数据监控分类" class="headerlink" title="一、数据监控分类"></a>一、数据监控分类</h3><h4 id="1-数据监控"><a href="#1-数据监控" class="headerlink" title="(1)数据监控"></a>(1)数据监控</h4><p>数据监控，顾名思义就是监听用户的行为。常见的数据监控包括：</p>
<ul>
<li>PV&#x2F;UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数</li>
<li>用户在每一个页面的停留时间</li>
<li>用户通过什么入口来访问该网页</li>
<li>用户在相应的页面中触发的行为</li>
</ul>
<p>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</p>
<h4 id="2-性能监控"><a href="#2-性能监控" class="headerlink" title="(2)性能监控"></a>(2)性能监控</h4><p>性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：</p>
<ul>
<li>不同用户，不同机型和不同系统下的首屏加载时间</li>
<li>白屏时间</li>
<li>http等请求的响应时间</li>
<li>静态资源整体下载时间</li>
<li>页面渲染时间</li>
<li>页面交互动画完成时间</li>
</ul>
<p>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。</p>
<h4 id="3-异常监控"><a href="#3-异常监控" class="headerlink" title="(3)异常监控"></a>(3)异常监控</h4><p>此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>
<ul>
<li>Javascript的异常监控</li>
<li>样式丢失的异常监控</li>
</ul>
<h3 id="二、常见的埋点方案"><a href="#二、常见的埋点方案" class="headerlink" title="二、常见的埋点方案"></a>二、常见的埋点方案</h3><h4 id="1-代码埋点"><a href="#1-代码埋点" class="headerlink" title="1. 代码埋点"></a>1. 代码埋点</h4><p>代码埋点是最早的埋点方式，根据业务的分析需求，将埋点的采集代码加入到应用端。按照埋点实施方，又分为前端(客户端)埋点和后端(服务端)埋点两种类型。</p>
<h5 id="1）客户端埋点"><a href="#1）客户端埋点" class="headerlink" title="1）客户端埋点"></a>1）客户端埋点</h5><p>由前端开发手动定义数据采集时机、内容等将数据采集的代码代码段加入到前端业务代码中，当用户在前端产生对应行为时，触发数据采集代码。</p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>按需埋点，采集数据更全面，几乎可覆盖所有数据采集场景</li>
<li>行为数据和业务数据可充分联合分析</li>
</ul>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>延迟上报，数据丢失率高(5%-10%)</li>
<li>需要客户端发版，用户端更新App</li>
<li>埋点开发工作量大</li>
<li>埋点流程需要多方协作，容易漏埋、错埋</li>
</ul>
<h6 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h6><p>全面分析用户在客户端的操作行为，对于一些电商交易类的产品，需要把行为和业务数据充分结合分析</p>
<h5 id="2）服务端埋点"><a href="#2）服务端埋点" class="headerlink" title="2）服务端埋点"></a>2）服务端埋点</h5><p>由服务端开发将埋点采集代码加入到后端服务请求中，当用户前端操作请求服务端数据时，按照约定规则触发埋点代码</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>按需埋点，采集数据更全面，几乎可覆盖所有数据采集场景</li>
<li>行为数据和业务数据可充分联合分析</li>
<li>数据采集实时上报，准确性高，丢失率低</li>
<li>服务端更新，不需要客户端发版或用户更新版本</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>纯前端操作不触发服务请求的按钮点击无法采集数据</li>
<li>埋点开发工作量大</li>
<li>埋点流程需要多方协作，容易漏埋、错埋</li>
</ul>
<h6 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h6><p>对于一些非点击、不可见的行为，或者要获取用户身份信息、更多的业务相关的属性信息。如果前后端都可以采集到，优先后端埋点</p>
<h4 id="2-全埋点"><a href="#2-全埋点" class="headerlink" title="2. 全埋点"></a>2. 全埋点</h4><p>全埋点也有称之为无埋点或无痕埋点的，主要是将埋点采集代码封装成标准的SDK，应用端接入后，按照SDK的采集规则自动化地进行数据采集和上报</p>
<h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>接入SDK后，可自动采集数据，无需按需开发，节省开发成本</li>
<li>页面可见元素均可自动采集，数据更全面</li>
<li>埋点流程简单，业务使用埋点系统自助定义事件，新增埋点需求无需业务开发参与</li>
</ul>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>动态页面或页面不可见行为数据无法采集</li>
<li>和业务强相关的属性信息采集困难</li>
<li>数据全部采集，数据存储压力大</li>
</ul>
<h6 id="适用场景：-2"><a href="#适用场景：-2" class="headerlink" title="适用场景："></a>适用场景：</h6><p>业务场景简单，如工具、应用类的产品，或者业务发展初期，产品快速迭代需求比精细化分析优先级更高，只需要分析简单的PV、UV</p>
<h4 id="3-可视化埋点"><a href="#3-可视化埋点" class="headerlink" title="3. 可视化埋点"></a>3. 可视化埋点</h4><p>默认不采集数据，当数据分析人员通过设备连接用户行为分析工具的数据接入管理界面，在页面可视化定义需要采集的位点后下发采集请求，采集代码生效</p>
<h6 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>默认不上报数据，可视化圈选才按需触发埋点，节约存储和传输成本</li>
<li>业务可视化圈选，埋点操作简单方便</li>
</ul>
<h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>数据只在埋点圈选定义之后才有，历史数据无法回溯</li>
<li>只能覆盖基本的点击、展示等用户行为，和业务强相关的属性信息采集困难</li>
</ul>
<h6 id="适用场景：-3"><a href="#适用场景：-3" class="headerlink" title="适用场景："></a>适用场景：</h6><p>业务场景简单，如工具、应用类的产品，或者业务发展初期，产品快速迭代需求比精细化分析优先级更高，只需要分析简单的PV、UV</p>
<h3 id="三、sdk设计"><a href="#三、sdk设计" class="headerlink" title="三、sdk设计"></a>三、sdk设计</h3><h4 id="SDK的设计"><a href="#SDK的设计" class="headerlink" title="SDK的设计"></a>SDK的设计</h4><p>在开始设计之前，先看一下SDK怎么使用。</p>
<pre><code class="javascript">import StatisticSDK from &#39;StatisticSDK&#39;;
// 全局初始化一次
window.insSDK = new StatisticSDK(&#39;uuid-12345&#39;);
&lt;button onClick=&#123;()=&gt;&#123;
  window.insSDK.event(&#39;click&#39;,&#39;confirm&#39;);
  ...// 其他业务代码
&#125;&#125;&gt;确认&lt;/button&gt;
</code></pre>
<p>首先把SDK实例挂载到全局，之后在业务代码中调用，这里的新建实例时需要传入一个id，因为这个埋点监控系统往往是给多个业务去使用的，通过id去区分不同的数据来源。</p>
<p>首先实现实例化部分：</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
  &#125;
&#125;
</code></pre>
<h4 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h4><p>数据发送是一个最基础的api，后面的功能都要基于此进行。通常这种前后端分离的场景会使用AJAX的方式发送数据，但是这里使用图片的src属性。原因有两点：</p>
<ol>
<li>没有跨域的限制，像srcipt标签、img标签都可以直接发送跨域的GET请求，不用做特殊处理。</li>
<li>兼容性好，一些静态页面可能禁用了脚本，这时script标签就不能使用了。</li>
</ol>
<p>但要注意，这个图片不是用来展示的，我们的目的是去「传递数据」，只是借助img标签的的src属性，在其url后面拼接上参数，服务端收到再去解析。</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
  &#125;
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
    let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
    let img = new Image();
    img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
&#125;
</code></pre>
<p>img标签的优点是不需要将其append到文档，只需设置src属性便能成功发起请求。</p>
<p>通常请求的这个url会是一张1X1px的GIF图片，网上的文章对于这里为什么返回图片的是一张GIF都是含糊带过，这里查阅了一些资料并测试了：</p>
<p>1.同样大小，不同格式的的图片中GIF大小是最小的，所以选择返回一张GIF，这样对性能的损耗更小。</p>
<p>2.如果返回204，会走到img的onerror事件，并抛出一个全局错误;如果返回200和一个空对象会有一个CORB的告警。</p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/346cd16826c82e6bd7a2246d22d56fc478dfc3.png"></p>
<p>3.当然如果不在意这个报错可以采取返回空对象，事实上也有一些工具是这样做的。</p>
<p>有一些埋点需要真实的加到页面上，比如垃圾邮件的发送者会添加这样一个隐藏标志来验证邮件是否被打开，如果返回204或者是200空对象会导致一个明显图片占位符。</p>
<pre><code>&lt;img src=&quot;http://www.example.com/logger?event_id=1234&quot;&gt;1.
</code></pre>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/77236ef50e0237529c0080434f48bd20be8ce5.png"></p>
<h4 id="更优雅的web-beacon"><a href="#更优雅的web-beacon" class="headerlink" title="更优雅的web beacon"></a>更优雅的web beacon</h4><p>这种打点标记的方式被称web beacon(网络信标)。除了gif图片，从2014年开始，浏览器逐渐实现专门的API，来更优雅的完成这件事：Navigator.sendBeacon。</p>
<p>使用很简单。</p>
<pre><code class="javascript">Navigator.sendBeacon(url,data)
</code></pre>
<p>相较于图片的src，这种方式的更有优势：</p>
<ul>
<li>不会和主要业务代码抢占资源，而是在浏览器空闲时去做发送。</li>
<li>并且在页面卸载时也能保证请求成功发送，不阻塞页面刷新和跳转。</li>
</ul>
<p>现在的埋点监控工具通常会优先使用sendBeacon，但由于浏览器兼容性，还是需要用图片的src兜底。</p>
<h4 id="用户行为监控"><a href="#用户行为监控" class="headerlink" title="用户行为监控"></a>用户行为监控</h4><p>上面实现了数据发送的api，现在可以基于它去实现用户行为监控的api。</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
  &#125;
  // 数据发送
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
      let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
      let img = new Image();
      img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
  // 自定义事件
  event(key, val=&#123;&#125;) &#123;
    let eventURL = &#39;http://demo/&#39;
    this.send(eventURL,&#123;event:key,...val&#125;)
  &#125;
  // pv曝光
  pv() &#123;
    this.event(&#39;pv&#39;)
  &#125;
&#125;
</code></pre>
<p>用户行为包括自定义事件和pv曝光，也可以把pv曝光看作是一种特殊的自定义行为事件。</p>
<h4 id="页面性能监控"><a href="#页面性能监控" class="headerlink" title="页面性能监控"></a>页面性能监控</h4><p>页面的性能数据可以通过performance.timing这个API获取到，获取的数据是单位为毫秒的时间戳。</p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/272519802405fa2531a97471630d64ab493783.png"></p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/95d45e432d6684cc4ab527d2ac28bddad1a98e.png" alt="img">上面的不需要全部了解，但比较关键的数据有下面几个，根据它们可以计算出FP&#x2F;DCL&#x2F;Load等关键事件的时间点：</p>
<ol>
<li>页面首次渲染时间：FP(firstPaint)&#x3D;domLoading-navigationStart。</li>
<li>DOM加载完成：DCL(DOMContentEventLoad)&#x3D;domContentLoadedEventEnd-navigationStart。</li>
<li>图片、样式等外链资源加载完成：L(Load)&#x3D;loadEventEnd-navigationStart。</li>
</ol>
<p>上面的数值可以跟performance面板里的结果对应。</p>
<p>回到SDK，我们只用实现一个上传所有性能数据的api就可以了：</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
    // 初始化自动调用性能上报
    this.initPerformance()
  &#125;
  // 数据发送
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
      let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
      let img = new Image();
      img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
  // 性能上报
  initPerformance()&#123;
    let performanceURL = &#39;http://performance/&#39;
    this.send(performanceURL,performance.timing)
  &#125;
&#125;
</code></pre>
<p>并且，在构造函数里自动调用，因为性能数据是必须要上传的，就不需要用户每次都手动调用了。</p>
<h4 id="错误告警监控"><a href="#错误告警监控" class="headerlink" title="错误告警监控"></a>错误告警监控</h4><p>错误报警监控分为JS原生错误和React&#x2F;Vue的组件错误的处理。</p>
<h5 id="JS原生错误"><a href="#JS原生错误" class="headerlink" title="JS原生错误"></a>JS原生错误</h5><p>除了try catch中捕获住的错误，我们还需要上报没有被捕获住的错误——通过error事件和unhandledrejection事件去监听。</p>
<h5 id="error"><a href="#error" class="headerlink" title="error"></a>error</h5><p>error事件是用来监听DOM操作错误DOMException和JS错误告警的，具体来说，JS错误分为下面8类：</p>
<ol>
<li>InternalError: 内部错误，比如如递归爆栈。</li>
<li>RangeError: 范围错误，比如new Array(-1)。</li>
<li>EvalError: 使用eval()时错误。</li>
<li>ReferenceError: 引用错误，比如使用未定义变量。</li>
<li>SyntaxError: 语法错误，比如var a &#x3D; 。</li>
<li>TypeError: 类型错误，比如[1,2].split(‘.’)。</li>
<li>URIError: 给 encodeURI或 decodeURl()传递的参数无效，比如decodeURI(‘%2’)。</li>
<li>Error: 上面7种错误的基类，通常是开发者抛出。</li>
</ol>
<p>也就是说，代码运行时发生的上述8类错误，都可以被检测到。</p>
<h5 id="unhandledrejection"><a href="#unhandledrejection" class="headerlink" title="unhandledrejection"></a>unhandledrejection</h5><p>Promise内部抛出的错误是无法被error捕获到的，这时需要用unhandledrejection事件。</p>
<p>回到SDK的实现，处理错误报警的代码如下：</p>
<pre><code class="javascript">class StatisticSDK &#123;
  constructor(productID)&#123;
    this.productID = productID;
    // 初始化错误监控
    this.initError()
  &#125;
  // 数据发送
  send(baseURL,query=&#123;&#125;)&#123;
    query.productID = this.productID;
      let queryStr = Object.entries(query).map(([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;`).join(&#39;&amp;&#39;)
      let img = new Image();
      img.src = `$&#123;baseURL&#125;?$&#123;queryStr&#125;`
  &#125;
  // 自定义错误上报
  error(err, etraInfo=&#123;&#125;) &#123;
    const errorURL = &#39;http://error/&#39;
    const &#123; message, stack &#125; = err;
    this.send(errorURL, &#123; message, stack, ...etraInfo&#125;)
  &#125;
  // 初始化错误监控
  initError()&#123;
    window.addEventListener(&#39;error&#39;, event=&gt;&#123;
      this.error(error);
    &#125;)
    window.addEventListener(&#39;unhandledrejection&#39;, event=&gt;&#123;
      this.error(new Error(event.reason), &#123; type: &#39;unhandledrejection&#39;&#125;)
    &#125;)
  &#125;
&#125;
</code></pre>
<p>和初始化性能监控一样，初始化错误监控也是一定要做的，所以需要在构造函数中调用。后续开发人员只用在业务代码的try catch中调用error方法即可。</p>
<h3 id="React-x2F-Vue组件错误"><a href="#React-x2F-Vue组件错误" class="headerlink" title="React&#x2F;Vue组件错误"></a>React&#x2F;Vue组件错误</h3><p>成熟的框架库都会有错误处理机制，React和Vue也不例外。</p>
<h5 id="React的错误边界"><a href="#React的错误边界" class="headerlink" title="React的错误边界"></a>React的错误边界</h5><p>错误边界是希望当应用内部发生渲染错误时，不会整个页面崩溃。我们提前给它设置一个兜底组件，并且可以细化粒度，只有发生错误的部分被替换成这个「兜底组件」，不至于整个页面都不能正常工作。</p>
<p><img src="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/562c10735609456ff5d155aa6880f7ca2598a4.png"></p>
<p>它的使用很简单，就是一个带有特殊生命周期的类组件，用它把业务组件包裹起来。</p>
<p>这两个生命周期是getDerivedStateFromError和componentDidCatch。</p>
<p>代码如下：</p>
<pre><code class="javascript">// 定义错误边界
class ErrorBoundary extends React.Component &#123;
  state = &#123; error: null &#125;
  static getDerivedStateFromError(error) &#123;
    return &#123; error &#125;
  &#125;
  componentDidCatch(error, errorInfo) &#123;
    // 调用我们实现的SDK实例
    insSDK.error(error, errorInfo)
  &#125;
  render() &#123;
    if (this.state.error) &#123;
      return &lt;h2&gt;Something went wrong.&lt;/h2&gt;
    &#125;
    return this.props.children
  &#125;
&#125;
...
&lt;ErrorBoundary&gt;
  &lt;BuggyCounter /&gt;
&lt;/ErrorBoundary&gt;1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.
</code></pre>
<p>回到SDK的整合上，在生产环境下，被错误边界包裹的组件，如果内部抛出错误，全局的error事件是无法监听到的，因为这个错误边界本身就相当于一个try catch。所以需要在错误边界这个组件内部去做上报处理。也就是上面代码中的componentDidCatch生命周期。</p>
<h3 id="Vue的错误边界"><a href="#Vue的错误边界" class="headerlink" title="Vue的错误边界"></a>Vue的错误边界</h3><p>vue也有一个类似的生命周期来做这件事，不再赘述：errorCaptured。</p>
<pre><code class="javascript">Vue.component(&#39;ErrorBoundary&#39;, &#123;
  data: () =&gt; (&#123; error: null &#125;),
  errorCaptured (err, vm, info) &#123;
    this.error = `$&#123;err.stack&#125;\n\nfound in $&#123;info&#125; of component`
    // 调用我们的SDK，上报错误信息
    insSDK.error(err,info)
    return false
  &#125;,
  render (h) &#123;
    if (this.error) &#123;
      return h(&#39;pre&#39;, &#123; style: &#123; color: &#39;red&#39; &#125;&#125;, this.error)
    &#125;
    return this.$slots.default[0]
  &#125;
&#125;)
...
&lt;error-boundary&gt;
  &lt;buggy-counter /&gt;
&lt;/error-boundary&gt;
</code></pre>
<p>现在我们已经实现了一个完整的SDK的骨架，并且处理了在实际开发时，react&#x2F;vue项目应该怎么接入。</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/706364.html">https://www.51cto.com/article/706364.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/" rel="tag">工程技术</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全算法篇"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/"
    >前端面试大全算法篇</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/" class="article-date">
  <time datetime="2022-11-05T02:32:27.000Z" itemprop="datePublished">2022-11-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95%E7%AF%87/">算法篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（算法）"><a href="#前端面试题大全（算法）" class="headerlink" title="前端面试题大全（算法）"></a>前端面试题大全（算法）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-算法中时间复杂度，空间复杂度的理解？如何计算？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-算法中时间复杂度，空间复杂度的理解？如何计算？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 算法中时间复杂度，空间复杂度的理解？如何计算？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 算法中时间复杂度，空间复杂度的理解？如何计算？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别</p>
<p>衡量不同算法之间的优劣主要是通过时间和空间两个维度去考量：</p>
<ul>
<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>
<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述</li>
</ul>
<p>通常会遇到一种情况，时间和空间维度不能够兼顾，需要在两者之间取得一个平衡点是我们需要考虑的</p>
<p>一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况</p>
<p>最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差</p>
<h4 id="二、时间复杂度"><a href="#二、时间复杂度" class="headerlink" title="二、时间复杂度"></a>二、时间复杂度</h4><p>时间复杂度是指执行这个算法所需要的计算工作量，其复杂度反映了程序执行时间「随输入规模增长而增长的量级」，在很大程度上能很好地反映出算法的优劣与否</p>
<p>一个算法花费的时间与算法中语句的「执行次数成正比」，执行次数越多，花费的时间就越多</p>
<p>算法的复杂度通常用大O符号表述，定义为<code>T(n) = O(f(n))</code>，常见的时间复杂度有：O(1)常数型、O(log n)对数型、O(n)线性型、O(nlogn)线性对数型、O(n^2)平方型、O(n^3)立方型、O(n^k)k次方型、O(2^n)指数型，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33336435656266302d313666632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>从上述可以看到，随着问题规模<code>n</code>的不断增大，上述时间复杂度不断增大，算法的执行效率越低，由小到大排序如下：</p>
<pre><code class="ini">Ο(1)＜Ο(log n)＜Ο(n)＜Ο(nlog n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n)＜Ο(n!)
</code></pre>
<p>注意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效，如果常数项过大的时候也会导致算法的执行时间变长</p>
<p>关于如何计算时间复杂度，可以看看如下简单例子：</p>
<pre><code class="javascript">function process(n) &#123;
  let a = 1
  let b = 2
  let sum = a + b
  for(let i = 0; i &lt; n; i++) &#123;
    sum += i
  &#125;
  return sum
&#125;
</code></pre>
<p>该函数算法需要执行的运算次数用输入大小<code>n</code>的函数表示，即 <code>T(n) = 2 + n + 1</code>，那么时间复杂度为<code>O(n + 3)</code>，又因为时间复杂度只关注最高数量级，且与之系数也没有关系，因此上述的时间复杂度为<code>O(n)</code></p>
<p>又比如下面的例子：</p>
<pre><code class="javascript">function process(n) &#123;
 let count = 0
  for(let i = 0; i &lt; n; i++)&#123;
    for(let i = 0; i &lt; n; i++)&#123;
      count += 1
    &#125;
  &#125;
&#125;
</code></pre>
<p>循环里面嵌套循环，外面的循环执行一次，里面的循环执行<code>n</code>次，因此时间复杂度为 <code>O(n*n*1 + 2) = O(n^2)</code></p>
<p>对于顺序执行的语句，总的时间复杂度等于其中最大的时间复杂度，如下：</p>
<pre><code class="javascript">function process(n) &#123;
  let sum = 0
  for(let i = 0; i &lt; n; i++) &#123;
    sum += i
  &#125;
  for(let i = 0; i &lt; n; i++)&#123;
    for(let i = 0; i &lt; n; i++)&#123;
      sum += 1
    &#125;
  &#125;
  return sum
&#125;
</code></pre>
<p>上述第一部分复杂度为<code>O(n)</code>，第二部分复杂度为<code>O(n^2)</code>，总复杂度为<code>max(O(n^2), O(n)) = O(n^2)</code></p>
<p>又如下一个例子：</p>
<pre><code class="javascript">function process(n) &#123;
  let i = 1; // ①
  while (i &lt;= n) &#123;
     i = i * 2; // ②
  &#125;
&#125;
</code></pre>
<p>循环语句中以2的倍数来逼近<code>n</code>，每次都乘以2。如果用公式表示就是1 * 2 * 2 * 2 … * 2 &lt;&#x3D;n，也就是说2的<code>x</code>次方小于等于<code>n</code>时会执行循环体，记作<code>2^x &lt;= n</code>，于是得出<code>x&lt;=logn</code></p>
<p>因此循环在执行<code>logn</code>次之后，便结束，因此时间复杂度为<code>O(logn)</code></p>
<p>同理，如果一个<code>O(n)</code>循环里面嵌套<code>O(logn)</code>的循环，则时间复杂度为<code>O(nlogn)</code>，像<code>O(n^3)</code>无非也就是嵌套了三层<code>O(n)</code>循环</p>
<h4 id="三、空间复杂度"><a href="#三、空间复杂度" class="headerlink" title="三、空间复杂度"></a>三、空间复杂度</h4><p>空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量</p>
<p>除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间</p>
<p>下面给出空间复杂度为<code>O(1)</code>的示例，如下</p>
<pre><code class="javascript">let a = 1
let b = 2
let c = 3
</code></pre>
<p>上述代码的临时空间不会随着<code>n</code>的变化而变化，因此空间复杂度为<code>O(1)</code></p>
<pre><code class="javascript">let arr []
for(i=1; i&lt;=n; ++i)&#123;
  arr.push(i)
&#125;
</code></pre>
<p>上述可以看到，随着<code>n</code>的增加，数组的占用的内存空间越大</p>
<p>通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为<code>O(1)</code>，一个一维数组<code>a[n]</code>，空间复杂度<code>O(n)</code>，二维数组为<code>O(n^2)</code></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对数据结构的理解？有哪些？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对数据结构的理解？有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对数据结构的理解？有哪些？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对数据结构的理解？有哪些？区别？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合</p>
<p>前面讲到，一个程序 &#x3D; 算法 + 数据结构，数据结构是实现算法的基础，选择合适的数据结构可以带来更高的运行或者存储效率</p>
<p>数据元素相互之间的关系称为结构，根据数据元素之间关系的不同特性，通常有如下四类基本的结构：</p>
<ul>
<li>集合结构：该结构的数据元素间的关系是“属于同一个集合”</li>
<li>线性结构：该结构的数据元素之间存在着一对一的关系</li>
<li>树型结构：该结构的数据元素之间存在着一对多的关系</li>
<li>图形结构：该结构的数据元素之间存在着多对多的关系，也称网状结构</li>
</ul>
<p>由于数据结构种类太多，逻辑结构可以再分成为：</p>
<ul>
<li>线性结构：有序数据元素的集合，其中数据元素之间的关系是一对一的关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的</li>
<li>非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生关联</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/c16cd7ef078a9270d5e13a8eca64d7b5469bf5ba3cfa7b88564c0065ba3ba230/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39616564633564302d316161362d313165632d386536342d3931666465633066303561312e706e67"><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39616564633564302d316161362d313165632d386536342d3931666465633066303561312e706e67.png" alt="img"></a></p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的数据结构有如下：</p>
<ul>
<li>数组</li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>树</li>
<li>图</li>
<li>堆</li>
<li>散列表</li>
</ul>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>在程序设计中，为了处理方便， 一般情况把具有相同类型的若干变量按有序的形式组织起来，这些按序排列的同类数据元素的集合称为数组</p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>一种特殊的线性表，只能在某一端插入和删除的特殊线性表，按照先进后出的特性存储数据</p>
<p>先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>跟栈基本一致，也是一种特殊的线性表，其特性是先进先出，只允许在表的前端进行删除操作，而在表的后端进行插入操作</p>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p>
<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成</p>
<p>一般情况，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<h5 id="树"><a href="#树" class="headerlink" title="树"></a>树</h5><p>树是典型的非线性结构，在树的结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个以上的后继结点</p>
<h5 id="图"><a href="#图" class="headerlink" title="图"></a>图</h5><p>一种非线性结构。在图结结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系</p>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆是一种特殊的树形数据结构，每个结点都有一个值，特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆</p>
<h5 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h5><p>若结构中存在关键字和<code>K</code>相等的记录，则必定在<code>f(K)</code>的存储位置上，不需比较便可直接取得所查记录</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>上述的数据结构，之前的区别可以分成线性结构和非线性结构：</p>
<ul>
<li>线性结构有：数组、栈、队列、链表等</li>
<li>非线性结构有：树、图、堆等</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对栈、队列的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对栈、队列的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对栈、队列的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对栈、队列的理解？应用场景？</h3><h4 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h4><p>栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表</p>
<p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p>
<p>所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p>
<p>关于栈的简单实现，如下：</p>
<pre><code class="javascript">class Stack &#123;
  constructor() &#123;
    this.items = [];
  &#125;

  /**
   * 添加一个（或几个）新元素到栈顶
   * @param &#123;*&#125; element 新元素
   */
  push(element) &#123;
    this.items.push(element)
  &#125;

  /**
   * 移除栈顶的元素，同时返回被移除的元素
   */
  pop() &#123;
    return this.items.pop()
  &#125;

  /**
   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）
   */
  peek() &#123;
    return this.items[this.items.length - 1]
  &#125;

  /**
   * 如果栈里没有任何元素就返回true,否则返回false
   */
  isEmpty() &#123;
    return this.items.length === 0
  &#125;

  /**
   * 移除栈里的所有元素
   */
  clear() &#123;
    this.items = []
  &#125;

  /**
   * 返回栈里的元素个数。这个方法和数组的length属性很类似
   */
  size() &#123;
    return this.items.length
  &#125;
&#125;
</code></pre>
<p>关于栈的操作主要的方法如下：</p>
<ul>
<li>push：入栈操作</li>
<li>pop：出栈操作</li>
</ul>
<h4 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h4><p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</p>
<p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p>
<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出</p>
<p>简单实现一个队列的方式，如下：</p>
<pre><code>class Queue &#123;
    constructor() &#123;
        this.list = []
        this.frontIndex = 0
        this.tailIndex = 0
    &#125;
    enqueue(item) &#123;
        this.list[this.tailIndex++] = item
    &#125;
    unqueue() &#123;
        const item  = this.list[this.frontIndex]
        this.frontIndex++        
        return item
    &#125;
&#125;
</code></pre>
<p>上述这种入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用</p>
<p>当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作，出该现象称为”假溢”</p>
<p>在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：</p>
<p>无论插入或删除，一旦<code>rear</code>指针增1或<code>front</code>指针增1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置，这种队列也就是循环队列</p>
<p>下面实现一个循环队列，如下：</p>
<pre><code class="javascript">class Queue &#123;
    constructor(size) &#123;
        this.size = size; // 长度需要限制, 来达到空间的利用, 代表空间的长度
        this.list = [];
        this.font = 0; // 指向首元素
        this.rear = 0;  // 指向准备插入元素的位置
    &#125;
    enQueue() &#123;
        if (this.isFull() == true) &#123;
            return false
        &#125;
        this.rear = this.rear % this.k;
        this._data[this.rear++] = value;
        return true
    &#125;
    deQueue() &#123;
        if(this.isEmpty())&#123;
            return false;
        &#125;
        this.font++;
        this.font = this.font % this.k;
        return true;
    &#125;
    isEmpty() &#123;
        return this.font == this.rear - 1;
    &#125;
    isFull() &#123;
        return this.rear % this.k == this.font;
    &#125;
&#125;
</code></pre>
<p>上述通过求余的形式代表首尾指针增1 时超出了所分配的队列空间</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><h5 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h5><p>借助栈的先进后出的特性，可以简单实现一个逆序数处的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p>
<p>包括编译器的在对输入的语法进行分析的时候，例如<code>&quot;()&quot;</code>、<code>&quot;&#123;&#125;&quot;</code>、<code>&quot;[]&quot;</code>这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>
<p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p>
<p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p>
<h5 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h5><p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p>
<p>队列的使用广泛应用在广度优先搜索种，例如层次遍历一个二叉树的节点值（后续将到）</p>
<p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对链表的理解？常见的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对链表的理解？常见的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对链表的理解？常见的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对链表的理解？常见的操作有哪些？</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>链表（Linked List）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，由一系列结点（链表中每一个元素称为结点）组成</p>
<p>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65346539333439302d316337362d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>节点用代码表示，则如下：</p>
<pre><code class="javascript">class Node &#123;
  constructor(val) &#123;
    this.val = val;
    this.next = null;
  &#125;
&#125;
</code></pre>
<ul>
<li>data 表示节点存放的数据</li>
<li>next 表示下一个节点指向的内存空间</li>
</ul>
<p>相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到<code>O(1)</code>的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是<code>O(logn)</code>和<code>O(1)</code></p>
<p>链表的结构也十分多，常见的有四种形式：</p>
<ul>
<li>单链表：除了头节点和尾节点，其他节点只包含一个后继指针</li>
<li>循环链表：跟单链表唯一的区别就在于它的尾结点又指回了链表的头结点，首尾相连，形成了一个环</li>
<li>双向链表：每个结点具有两个方向指针，后继指针(next)指向后面的结点，前驱指针(prev)指向前面的结点，其中节点的前驱指针和尾结点的后继指针均指向空地址NULL</li>
<li>双向循环链表：跟双向链表基本一致，不过头节点前驱指针指向尾迹诶单和尾节点的后继指针指向头节点</li>
</ul>
<h4 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于链表的操作可以主要分成如下：</p>
<ul>
<li>遍历</li>
<li>插入</li>
<li>删除</li>
</ul>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>遍历很好理解，就是根据<code>next</code>指针遍历下去，直到为<code>null</code>，如下：</p>
<pre><code class="javascript">let current = head
while(current)&#123;
 console.log(current.val)
  current = current.next
&#125;
</code></pre>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>向链表中间插入一个元素，可以如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66356665356664302d316337362d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>可以看到，插入节点可以分成如下步骤：</p>
<ul>
<li>存储插入位置的前一个节点</li>
<li>存储插入位置的后一个节点</li>
<li>将插入位置的前一个节点的 next 指向插入节点</li>
<li>将插入节点的 next 指向前面存储的 next 节点</li>
</ul>
<p>相关代码如下所示：</p>
<pre><code class="javascript">let current = head
while (current &lt; position)&#123;
  pervious = current;
  current = current.next;
&#125;
pervious.next = node;
node.next = current;
</code></pre>
<p>如果在头节点进行插入操作的时候，会实现<code>previousNode</code>节点为<code>undefined</code>，不适合上述方式</p>
<p>解放方式可以是在头节点前面添加一个虚拟头节点，保证插入行为一致</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>向链表任意位置删除节点，如下图操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30313630636439302d316337372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>从上图可以看到删除节点的步骤为如下：</p>
<ul>
<li>获取删除节点的前一个节点</li>
<li>获取删除节点的后一个节点</li>
<li>将前一个节点的 next 指向后一个节点</li>
<li>向删除节点的 next 指向为null</li>
</ul>
<p>如果想要删除制定的节点，示意代码如下：</p>
<pre><code class="javascript">while (current != node)&#123;
  pervious = current;
  current = current.next;
  nextNode = current.next;
&#125;
pervious.next = nextNode
</code></pre>
<p>同样如何希望删除节点处理行为一致，可以在头节点前面添加一个虚拟头节点</p>
<h5 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h5><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的<code>CPU</code>缓存、数据库缓存、浏览器缓存等等</p>
<p>当缓存空间被用满时，我们可能会使用<code>LRU</code>最近最好使用策略去清楚，而实现<code>LRU</code>算法的数据结构是链表，思路如下：</p>
<p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表</p>
<ul>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部</li>
<li>如果此数据没在缓存链表中<ul>
<li>如果此时缓存未满，可直接在链表头部插入新节点存储此数据</li>
<li>如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点</li>
</ul>
</li>
</ul>
<p>由于链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据的情况的时候，都可以使用链表</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对集合的理解？常见的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对集合的理解？常见的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对集合的理解？常见的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对集合的理解？常见的操作有哪些？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>集合（Set），指具有某种特定性质的事物的总体，里面的每一项内容称作元素</p>
<p>在数学中，我们经常会遇到集合的概念：</p>
<ul>
<li>有限集合：例如一个班集所有的同学构成的集合</li>
<li>无限集合：例如全体自然数集合</li>
</ul>
<p>在计算机中集合道理也基本一致，具有三大特性：</p>
<ul>
<li>确定性：于一个给定的集合，集合中的元素是确定的。即一个元素，或者属于该集合，或者不属于该集合，两者必居其一</li>
<li>无序性：在一个集合中，不考虑元素之间的顺序，只要元素完全相同，就认为是同一个集合</li>
<li>互异性：集合中任意两个元素都是不同的</li>
</ul>
<h4 id="二、操作-1"><a href="#二、操作-1" class="headerlink" title="二、操作"></a>二、操作</h4><p>在<code>ES6</code>中，集合本身是一个构建函数<code>Set</code>，用来生成 <code>Set</code> 数据结构，如下：</p>
<pre><code class="javascript">const s = new Set();
</code></pre>
<p>关于集合常见的方法有：</p>
<ul>
<li>add()：增</li>
<li>delete()：删</li>
<li>has()：改</li>
<li>clear()：查</li>
</ul>
<h5 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h5><p>添加某个值，返回 <code>Set</code> 结构本身</p>
<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>
<pre><code class="javascript">s.add(1).add(2).add(2); // 2只被添加了一次
</code></pre>
<p>体现了集合的互异性特性</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h5><p>删除某个值，返回一个布尔值，表示删除是否成功</p>
<pre><code class="ini">s.delete(1)
</code></pre>
<h5 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h5><p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>
<pre><code class="ini">s.has(2)
</code></pre>
<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p>清除所有成员，没有返回值</p>
<pre><code class="ini">s.clear()
</code></pre>
<p>关于多个集合常见的操作有：</p>
<ul>
<li>并集</li>
<li>交集</li>
<li>差集</li>
</ul>
<h5 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h5><p>两个集合的共同元素，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65643936646635302d316433362d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>代码实现方式如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;
</code></pre>
<h5 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h5><p>两个集合<code>A</code> 和 <code>B</code>，即属于<code>A</code>又属于<code>B</code>的元素，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66386139636438302d316433362d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>用代码标识则如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;
</code></pre>
<h5 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h5><p>两个集合<code>A</code> 和 <code>B</code>，属于<code>A</code>的元素但不属于<code>B</code>的元素称为<code>A</code>相对于<code>B</code>的差集，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30313931633536302d316433372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>代码标识则如下：</p>
<pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>一般情况下，使用数组的概率会比集合概率高很多</p>
<p>使用<code>set</code>集合的场景一般是借助其确定性，其本身只包含不同的元素</p>
<p>所以，可以利用<code>Set</code>的一些原生方法轻松的完成数组去重，查找数组公共元素及不同元素等操作</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对树的理解？相关的操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对树的理解？相关的操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对树的理解？相关的操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对树的理解？相关的操作有哪些？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机领域，树形数据结构是一类重要的非线性数据结构，可以表示数据之间一对多的关系。以树与二叉树最为常用，直观看来，树是以分支关系定义的层次结构</p>
<p>二叉树满足以下两个条件：</p>
<ul>
<li>本身是有序树</li>
<li>树中包含的各个结点的不能超过 2，即只能是 0、1 或者 2</li>
</ul>
<p>如下图，左侧的为二叉树，而右侧的因为头结点的子结点超过2，因此不属于二叉树：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36363735383830302d316466652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>同时，二叉树可以继续进行分类，分成了满二叉树和完成二叉树：</p>
<ul>
<li>满二叉树：如果二叉树中除了叶子结点，每个结点的度都为 2</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353964623035302d316466652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>完成二叉树：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38346165333166302d316466652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h4 id="二、操作-2"><a href="#二、操作-2" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于二叉树的遍历，常见的有：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问根节点</li>
<li>访问当前节点的左子树</li>
<li>若当前节点无左子树，则访问当前节点的右子</li>
</ul>
<p>根据遍历特性，递归版本用代码表示则如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  console.log(root)
  preOrder(root.left)
  preOrder(root.right)
&#125;
</code></pre>
<p>如果不使用递归版本，可以借助栈先进后出的特性实现，先将根节点压入栈，再分别压入右节点和左节点，直到栈中没有元素，如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  const stack = [root]
  while (stack.length) &#123;
    const n = stack.pop()
    console.log(n.val)
    if (n.right) &#123;
      stack.push(n.right)
    &#125;
    if (n.left) &#123;
      stack.push(n.left)
    &#125;
  &#125;
&#125;
</code></pre>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问当前节点的左子树</li>
<li>访问根节点</li>
<li>访问当前节点的右子</li>
</ul>
<p>递归版本很好理解，用代码表示则如下：</p>
<pre><code class="javascript">const inOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  inOrder(root.left)
  console.log(root.val)
  inOrder(root.right)
&#125;
</code></pre>
<p>非递归版本也是借助栈先进后出的特性，可以一直首先一直压入节点的左元素，当左节点没有后，才开始进行出栈操作，压入右节点，然后有依次压入左节点，如下：</p>
<pre><code class="javascript">const inOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  const stack = [root]
  let p = root
  while(stack.length || p)&#123;
    while (p) &#123;
      stack.push(p)
      p = p.left
    &#125;
    const n = stack.pop()
    console.log(n.val)
    p = n.right
  &#125;
&#125;
</code></pre>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>前序遍历的实现思想是：</p>
<ul>
<li>访问当前节点的左子树</li>
<li>访问当前节点的右子</li>
<li>访问根节点</li>
</ul>
<p>递归版本，用代码表示则如下：</p>
<pre><code class="javascript">const postOrder = (root) =&gt; &#123;
  if (!root) &#123; return &#125;
  postOrder(root.left)
  postOrder(root.right)
  console.log(n.val)
 &#125;
</code></pre>
<p>后序遍历非递归版本实际根全序遍历是逆序关系，可以再多创建一个栈用来进行输出，如下：</p>
<pre><code class="javascript">const preOrder = (root) =&gt; &#123;
  if(!root)&#123; return &#125;
  const stack = [root]
  const outPut = []
  while (stack.length) &#123;
    const n = stack.pop()
    outPut.push(n.val)
    if (n.right) &#123;
      stack.push(n.right)
    &#125;
    if (n.left) &#123;
      stack.push(n.left)
    &#125;
  &#125;
  while (outPut.length) &#123;
    const n = outPut.pop()
    console.log(n.val)
  &#125;
&#125;
</code></pre>
<h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>按照二叉树中的层次从左到右依次遍历每层中的结点</p>
<p>借助队列先进先出的特性，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果</p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const levelOrder = (root) =&gt; &#123;
    if (!root) &#123; return [] &#125;
    const queue = [[root, 0]]
    const res = []
    while (queue.length) &#123;
        const n = queue.shift()
        const [node, leval] = n
        if (!res[leval]) &#123;
            res[leval] = [node.val]
        &#125; else &#123;
            res[leval].push(node.val)
        &#125;
        if (node.left) &#123; queue.push([node.left, leval + 1]) &#125;
        if (node.right) &#123; queue.push([node.right, leval + 1]) &#125;
    &#125;
    return res
&#125;;
</code></pre>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>树是一个非常重要的非线性结构，其中二叉树以二叉树最常见，二叉树的遍历方式可以分成前序遍历、中序遍历、后序遍历</p>
<p>同时，二叉树又分成了完成二叉树和满二叉树</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对堆的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对堆的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对堆的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对堆的理解？如何实现？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称</p>
<p>堆通常是一个可以被看做一棵完全二叉树的数组对象，如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613066643166302d316564372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>总是满足下列性质：</p>
<ul>
<li>堆中某个结点的值总是不大于或不小于其父结点的值</li>
<li>堆总是一棵完全二叉树</li>
</ul>
<p>堆又可以分成最大堆和最小堆：</p>
<ul>
<li>最大堆：每个根结点，都有根结点的值大于两个孩子结点的值</li>
<li>最小堆：每个根结点，都有根结点的值小于孩子结点的值</li>
</ul>
<h4 id="二、操作-3"><a href="#二、操作-3" class="headerlink" title="二、操作"></a>二、操作</h4><p>堆的元素存储方式，按照完全二叉树的顺序存储方式存储在一个一维数组中，如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65613066643166302d316564372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用一维数组存储则如下：</p>
<pre><code class="javascript">[0, 1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<p>根据完全二叉树的特性，可以得到如下特性：</p>
<ul>
<li>数组零坐标代码的是堆顶元素</li>
<li>一个节点的父亲节点的坐标等于其坐标除以2整数部分</li>
<li>一个节点的左节点等于其本身节点坐标 * 2 + 1</li>
<li>一个节点的右节点等于其本身节点坐标 * 2 + 2</li>
</ul>
<p>根据上述堆的特性，下面构建最小堆的构造函数和对应的属性方法：</p>
<pre><code class="javascript">class MinHeap &#123;
  constructor() &#123;
    // 存储堆元素
    this.heap = []
  &#125;
  // 获取父元素坐标
  getParentIndex(i) &#123;
    return (i - 1) &gt;&gt; 1
  &#125;
  
  // 获取左节点元素坐标
  getLeftIndex(i) &#123;
    return i * 2 + 1
  &#125;
  
 // 获取右节点元素坐标
  getRightIndex(i) &#123;
    return i * 2 + 2
  &#125;
  
  // 交换元素
  swap(i1, i2) &#123;
    const temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp
  &#125;
  
  // 查看堆顶元素
  peek() &#123;
    return this.heap[0]
  &#125;
  
  // 获取堆元素的大小
  size() &#123;
    return this.heap.length
  &#125;
&#125;
</code></pre>
<p>涉及到堆的操作有：</p>
<ul>
<li>插入</li>
<li>删除</li>
</ul>
<h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><p>将值插入堆的底部，即数组的尾部，当插入一个新的元素之后，堆的结构就会被破坏，因此需要堆中一个元素做上移操作</p>
<p>将这个值和它父节点进行交换，直到父节点小于等于这个插入的值，大小为<code>k</code>的堆中插入元素的时间复杂度为<code>O(logk)</code></p>
<p>如下图所示，22节点是新插入的元素，然后进行上移操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30363839336662302d316564382d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>相关代码如下：</p>
<pre><code class="java">// 插入元素
insert(value) &#123;
  this.heap.push(value)
  this.shifUp(this.heap.length - 1)
&#125;

// 上移操作
shiftUp(index) &#123;
  if (index === 0) &#123; return &#125;
  const parentIndex = this.getParentIndex(index)
  if(this.heap[parentIndex] &gt; this.heap[index])&#123;
    this.swap(parentIndex, index)
    this.shiftUp(parentIndex)
  &#125;
&#125;
</code></pre>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>常见操作是用数组尾部元素替换堆顶，这里不直接删除堆顶，因为所有的元素会向前移动一位，会破坏了堆的结构</p>
<p>然后进行下移操作，将新的堆顶和它的子节点进行交换，直到子节点大于等于这个新的堆顶，删除堆顶的时间复杂度为<code>O(logk)</code></p>
<p>整体如下图操作：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31326132613136302d316564382d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>相关代码如下：</p>
<pre><code class="javascript">// 删除元素
pop() &#123;
  this.heap[0] = this.heap.pop()
  this.shiftDown(0)
&#125;

// 下移操作
shiftDown(index) &#123;
  const leftIndex = this.getLeftIndex(index)
  const rightIndex = this.getRightIndex(index)
  if (this.heap[leftIndex] &lt; this.heap[index])&#123;
    this.swap(leftIndex, index)
    this.shiftDown(leftIndex)
  &#125;
  if (this.heap[rightIndex] &lt; this.heap[index])&#123;
    this.swap(rightIndex, index)
    this.shiftDown(rightIndex)
  &#125;
&#125;
</code></pre>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>关于堆的插入和删除时间复杂度都是<code>Olog(n)</code>，原因在于包含n个节点的完全二叉树，树的高度不会超过<code>log2n</code></p>
<p>堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是<code>Olog(n)</code>，插入数据和删除堆顶元素的主要逻辑就是堆化</p>
<h3 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h3><ul>
<li>堆是一个完全二叉树</li>
<li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值</li>
<li>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”</li>
<li>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“小顶堆”</li>
<li>根据堆的特性，我们可以使用堆来进行排序操作，也可以使用其来求第几大或者第几小的值</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对图的理解？相关操作有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对图的理解？相关操作有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对图的理解？相关操作有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对图的理解？相关操作有哪些？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机科学中，图是一种抽象的数据类型，在图中的数据元素通常称为结点，<code>V</code>是所有顶点的集合，<code>E</code>是所有边的集合</p>
<p>如果两个顶点<code>v</code>,<code> w</code>，只能由<code>v</code>向<code>w</code>，而不能由<code>w</code>向<code>v</code>，那么我们就把这种情况叫做一个从 <code>v</code> 到 <code>w</code> 的有向边。<code>v </code>也被称做初始点，<code>w</code>也被称为终点。这种图就被称做有向图</p>
<p>如果<code>v</code>和<code>w</code>是没有顺序的，从<code>v</code>到达<code>w</code>和从<code>w</code>到达<code>v</code>是完全相同的，这种图就被称为无向图</p>
<p>图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系</p>
<p>常见表达图的方式有如下：</p>
<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
</ul>
<h5 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h5><p>通过使用一个二维数组<code>G[N][N]</code>进行表示<code>N</code>个点到<code>N-1</code>编号，通过邻接矩阵可以立刻看出两顶点之间是否存在一条边，只需要检查邻接矩阵行<code>i</code>和列<code>j</code>是否是非零值，对于无向图，邻接矩阵是对称的</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38383164343330302d323035392d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><p>存储方式如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39343966656464302d323035392d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>在<code>javascript</code>中，可以使用<code>Object</code>进行表示，如下：</p>
<pre><code class="javascript">const graph = &#123;
  A: [2, 3, 5],
  B: [2],
  C: [0, 1, 3],
  D: [0, 2],
  E: [6],
  F: [0, 6],
  G: [4, 5]
&#125;
</code></pre>
<p>图的数据结构还可能包含和每条边相关联的数值（edge value），例如一个标号或一个数值（即权重，weight；表示花费、容量、长度等）</p>
<h4 id="二、操作-4"><a href="#二、操作-4" class="headerlink" title="二、操作"></a>二、操作</h4><p>关于的图的操作常见的有：</p>
<ul>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
</ul>
<p>首先构建一个图的邻接矩阵表示，如下面的图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61313331313739302d323035392d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const graph = &#123;
  0: [1, 4],
  1: [2, 4],
  2: [2, 3],
  3: [],
  4: [3],
&#125;
</code></pre>
<h5 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h5><p>也就是尽可能的往深处的搜索图的分支</p>
<p>实现思路是，首先应该确定一个根节点，然后对根节点的没访问过的相邻节点进行深度优先遍历</p>
<p>确定以 0 为根节点，然后进行深度遍历，然后遍历1，接着遍历 2，然后3，此时完成一条分支<code>0 - 1- 2- 3</code>的遍历，换一条分支，也就是4，4后面因为3已经遍历过了，所以就不访问了</p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">const visited = new Set()
const dfs = (n) =&gt; &#123;
  console.log(n)
  visited.add(n) // 访问过添加记录
  graph[n].forEach(c =&gt; &#123;
    if(!visited.has(c))&#123; // 判断是否访问呢过
      dfs(c)
    &#125;
  &#125;)
&#125;
</code></pre>
<h5 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h5><p>先访问离根节点最近的节点，然后进行入队操作，解决思路如下：</p>
<ul>
<li>新建一个队列，把根节点入队</li>
<li>把队头出队并访问</li>
<li>把队头的没访问过的相邻节点入队</li>
<li>重复二、三步骤，知道队列为空</li>
</ul>
<p>用代码标识则如下：</p>
<pre><code class="javascript">const visited = new Set()
const dfs = (n) =&gt; &#123;
  visited.add(n)
  const q = [n]
  while(q.length)&#123;
    const n = q.shift()
    console.log(n)
    graph[n].forEach(c =&gt; &#123;
      if(!visited.has(c))&#123;
        q.push(c)  
        visited.add(c)
      &#125;
    &#125;)
  &#125;
&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>通过上面的初步了解，可以看到图就是由顶点的有穷非空集合和顶点之间的边组成的集合，分成了无向图与有向图</p>
<p>图的表达形式可以分成邻接矩阵和邻接表两种形式，在<code>javascript</code>中，则可以通过二维数组和对象的形式进行表达</p>
<p>图实际是很复杂的，后续还可以延伸出无向图和带权图，对应如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62306438383230302d323035392d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-常见的排序算法有哪些？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-常见的排序算法有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 常见的排序算法有哪些？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 常见的排序算法有哪些？区别？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列</p>
<p>排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的</p>
<p>对与排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性</p>
<p>时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义</p>
<p>稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变</p>
<p>即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的</p>
<h4 id="二、有哪些-1"><a href="#二、有哪些-1" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的算法排序算法有：</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来</p>
<p>思路如下：</p>
<ul>
<li>比较相邻的元素，如果第一个比第二个大，就交换它们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>重复上述步骤，直到没有任何一堆数字需要比较</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963342e7a68696d672e636f6d2f76322d33336139343763373161643632623235346361623632653533363464323831335f622e77656270.gif"></p>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法</p>
<p>无论什么数据进去都是 <code>O(n²) </code>的时间复杂度。所以用到它的时候，数据规模越小越好</p>
<p>唯一的好处是不占用额外的内存存储空间</p>
<p>思路如下：</p>
<ul>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963312e7a68696d672e636f6d2f76322d31633765323066333036646463303265623465336135306661373831376666345f622e77656270.gif"></p>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>插入排序是一种简单直观的排序算法</p>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>
<p>解决思路如下：</p>
<ul>
<li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的</li>
<li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
<li>重复上述过程直到最后一个元素被插入有序子数组中</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d39316237366538653464616239623063616439613031376437646434333165325f622e77656270.gif"></p>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>归并排序是建立在归并操作上的一种有效的排序算法</p>
<p>该算法是采用分治法的一个非常典型的应用</p>
<p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p>
<p>解决思路如下：</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d63646461336631316336656662633031353737663563323961393036363737325f622e6a7067.jpeg"></p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小</p>
<p>再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列</p>
<p>解决思路如下：</p>
<ul>
<li>从数列中挑出一个元素，称为”基准”（pivot）</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963312e7a68696d672e636f6d2f76322d63343131333339623739663932343939646362376235663330346338323666345f622e6a7067.jpeg"></p>
<h2 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h2><p>除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等……</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对冒泡排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对冒泡排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对冒泡排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对冒泡排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法</p>
<p>冒泡排序的思想就是在每次遍历一遍未排序的数列之后，将一个数据元素浮上去（也就是排好了一个数据）</p>
<p>如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”</p>
<p>假如我们要把 12、35、99、18、76 这 5 个数从大到小进行排序，那么数越大，越需要把它放在前面</p>
<p>思路如下：</p>
<ul>
<li>从后开始遍历，首先比较 18 和 76，发现 76 比 18 大，就把两个数交换顺序，得到 12、35、99、76、18</li>
<li>接着比较 76 和 99，发现 76 比 99 小，所以不用交换顺序</li>
<li>接着比较 99 和 35，发现 99 比 35 大，交换顺序</li>
<li>接着比较 99 和 12，发现 99 比 12 大，交换顺序</li>
</ul>
<p>最终第 1 趟排序的结果变成了 99、12、35、76、18，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37613336333737302d323635322d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>上述可以看到，经过第一趟的排序，可以得到最大的元素，接下来第二趟排序则对剩下的的4个元素进行排序，如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38346239646466302d323635322d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>经过第 2 趟排序，结果为 99、76、12、35、18</p>
<p>然后开始第3趟的排序，结果为99、76、35、12、18</p>
<p>然后第四趟排序结果为99、76、35、18、12</p>
<p>经过 4 趟排序之后，只剩一个 12 需要排序了，这时已经没有可比较的元素了，这时排序完成</p>
<h4 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>如果要实现一个从小到大的排序，算法原理如下：</p>
<ul>
<li>首先比较相邻的元素，如果第一个元素比第二个元素大，则交换它们</li>
<li>针对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样，最后的元素回事最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li>
</ul>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function bubbleSort(arr) &#123;
    const len = arr.length;
    for (let i = 0; i &lt; len - 1; i++) &#123;
        for (let j = 0; j &lt; len - 1 - i; j++) &#123;
            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
    return arr;
&#125;
</code></pre>
<p>可以看到：冒泡排序在每一轮排序中都会使一个元素排到一趟， 也就是最终需要 n-1 轮这样的排序</p>
<p>而在每轮排序中都需要对相邻的两个元素进行比较，在最坏的情况下，每次比较之后都需要交换位置，此时时间复杂度为<code>O(n^2)</code></p>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>对冒泡排序常见的改进方法是加入一标志性变量<code>exchange</code>，用于标志某一趟排序过程中是否有数据交换</p>
<p>如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程</p>
<p>可以设置一标志性变量<code>pos</code>，用于记录每趟排序中最后一次进行交换的位置，由于<code>pos</code>位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到<code>pos</code>位置即可，如下：</p>
<pre><code class="javascript">function bubbleSort1(arr)&#123;
 const i=arr.length-1;//初始时,最后位置保持不变  
 while(i&gt;0)&#123;
  let pos = 0;//每趟开始时,无记录交换
  for(let j = 0; j &lt; i; j++)&#123;
   if(arr[j] &gt; arr[j+1])&#123;
        let tmp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = tmp;
    pos = j;//记录最后交换的位置  
   &#125;   
  &#125;
  i = pos;//为下一趟排序作准备
 &#125;
 return arr;
&#125;
</code></pre>
<p>在待排序的数列有序的情况下，只需要一轮排序并且不用交换，此时情况最好，时间复杂度为<code>O(n)</code></p>
<p>并且从上述比较中看到，只有后一个元素比前面的元素大（小）时才会对它们交换位置并向上冒出，对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对位置是不会改变的，因此， 冒泡排序是稳定的</p>
<h4 id="三、应用场景-3"><a href="#三、应用场景-3" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>冒泡排的核心部分是双重嵌套循环，<br>时间复杂度是 O(N 2 )，相比其它排序算法，这是一个相对较高的时间复杂度，一般情况不推荐使用，由于冒泡排序的简洁性，通常被用来对于程序设计入门的学生介绍算法的概念</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对选择排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对选择排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对选择排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对选择排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>选择排序（Selection sort）是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²) </code>的时间复杂度，所以用到它的时候，数据规模越小越好</p>
<p>其基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置</p>
<p>然后再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾</p>
<p>以此类推，直到所有元素均排序完毕</p>
<p>举个例子，一个数组为 56、12、80、91、29，其排序过程如下：</p>
<ul>
<li>第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置。此时数组为 12、56、80、91、20</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36306264323035302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置，此时数组为12、20、80、91、56</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36623034636634302d323637312d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<ul>
<li>第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置，此时数组为 12、20、56、91、80</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353766346530302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<ul>
<li>第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置，此时排序完成，变成有序数组</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37353766346530302d323637312d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h4 id="二、如何实现-1"><a href="#二、如何实现-1" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>从上面可以看到，对于具有 <code>n</code> 个记录的无序表遍历 <code>n-1</code> 次，第<code> i</code> 次从无序表中第 <code>i</code> 个记录开始，找出后序关键字中最小的记录，然后放置在第 <code>i</code> 的位置上</p>
<p>直至到从第<code>n</code>个和第<code>n-1</code>个元素中选出最小的放在第<code>n-1</code>个位置</p>
<p>如下动画所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f73656c656374696f6e536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function selectionSort(arr) &#123;
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) &#123;
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) &#123;
            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    return arr;
&#125;
</code></pre>
<p>第一次内循环比较<code>N - 1</code>次，然后是<code>N-2</code>次，<code>N-3</code>次，……，最后一次内循环比较1次<br>共比较的次数是 <code>(N - 1) + (N - 2) + ... + 1</code>，求等差数列和，得 <code>(N - 1 + 1)* N / 2 = N^2 / 2</code>，舍去最高项系数，其时间复杂度为 <code>O(N^2)</code></p>
<p>从上述也可以看到，选择排序是一种稳定的排序</p>
<h4 id="三、应用场景-4"><a href="#三、应用场景-4" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>和冒泡排序一致，相比其它排序算法，这也是一个相对较高的时间复杂度，一般情况不推荐使用</p>
<p>但是我们还是要掌握冒泡排序的思想及实现，这对于我们的算法思维是有很大帮助的</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对插入排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对插入排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对插入排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对插入排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-9"><a href="#一、是什么-9" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>插入排序（Insertion Sort），一般也被称为直接插入排序。对于少量元素的排序，它是一个有效、简单的算法</p>
<p>其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据</p>
<p>插入排序的工作方式像许多人排序一手扑克牌，开始时，我们的左手为空并且桌子上的牌面向下</p>
<p>然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置，该正确位置需要从右到左将它与已在手中的每张牌进行比较</p>
<p>例如一个无序数组 3、1、7、5、2、4、9、6，将其升序的结果则如下：</p>
<p>一开始有序表中无数据，直接插入3</p>
<p>从第二个数开始，插入一个元素1，然后和有序表中记录3比较，1&lt;3，所以插入到记录 3 的左侧</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39643234663566302d323637662d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>向有序表插入记录 7 时，同有序表中记录 3 进行比较，3&lt;7，所以插入到记录 3 的右侧</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61366139353465302d323637662d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>向有序表中插入记录 5 时，同有序表中记录 7 进行比较，5&lt;7，同时 5&gt;3，所以插入到 3 和 7 中间</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62313938313934302d323637662d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>照此规律，依次将无序表中的记录 4，9 和 6插入到有序表中</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62633265643239302d323637662d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h4 id="二、如何实现-2"><a href="#二、如何实现-2" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置</p>
<p>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f696e73657274696f6e536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function insertionSort(arr) &#123;
    const len = arr.length;
    let preIndex, current;
    for (let i = 1; i &lt; len; i++) &#123;
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        &#125;
        arr[preIndex+1] = current;
    &#125;
    return arr;
&#125;
</code></pre>
<p>在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较<code>N- 1</code>次，时间复杂度为<code>O(n)</code></p>
<p>最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为<code>O(n^2)</code></p>
<p>通过上面了解，可以看到插入排序是一种稳定的排序方式</p>
<h4 id="三、应用场景-5"><a href="#三、应用场景-5" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>插入排序时间复杂度是 O(n2)，适用于数据量不大，算法稳定性要求高，且数据局部或整体有序的数列排序</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对归并排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对归并排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对归并排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对归并排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-10"><a href="#一、是什么-10" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>归并排序（Merge Sort）是建立归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用</p>
<p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p>
<p>例如对于含有 <code>n</code> 个记录的无序表，首先默认表中每个记录各为一个有序表（只不过表的长度都为 1）</p>
<p>然后进行两两合并，使 <code>n</code> 个有序表变为<code>n/2</code> 个长度为 2 或者 1 的有序表（例如 4 个小有序表合并为 2 个大的有序表）</p>
<p>通过不断地进行两两合并，直到得到一个长度为 <code>n</code> 的有序表为止</p>
<p>例如对无序表{49，38，65，97，76，13，27}进行归并排序分成了分、合两部分：</p>
<p>如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30356631346236302d323661642d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>归并合过程中，每次得到的新的子表本身有序，所以最终得到有序表</p>
<p>上述分成两部分，则称为二路归并，如果分成三个部分则称为三路归并，以此类推</p>
<h4 id="二、如何实现-3"><a href="#二、如何实现-3" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>关于归并排序的算法思路如下：</p>
<ul>
<li>分：把数组分成两半，再递归对子数组进行分操作，直至到一个个单独数字</li>
<li>合：把两个数合成有序数组，再对有序数组进行合并操作，直到全部子数组合成一个完整的数组<ul>
<li>合并操作可以新建一个数组，用于存放排序后的数组</li>
<li>比较两个有序数组的头部，较小者出队并且推入到上述新建的数组中</li>
<li>如果两个数组还有值，则重复上述第二步</li>
<li>如果只有一个数组有值，则将该数组的值出队并推入到上述新建的数组中</li>
</ul>
</li>
</ul>
<p>用代码表示则如下图所示：</p>
<pre><code class="javascript">function mergeSort(arr) &#123;  // 采用自上而下的递归方法
    const len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    let middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    const result = [];

    while (left.length &amp;&amp; right.length) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
&#125;
</code></pre>
<p>上述归并分成了分、合两部分，在处理分过程中递归调用两个分的操作，所花费的时间为2乘<code>T(n/2)</code>，合的操作时间复杂度则为<code>O(n)</code>，因此可以得到以下公式：</p>
<p>总的执行时间 &#x3D; 2 × 输入长度为<code>n/2</code>的<code>sort</code>函数的执行时间 + <code>merge</code>函数的执行时间<code>O(n)</code></p>
<p>当只有一个元素时，<code>T(1) = O(1)</code></p>
<p>如果对<code>T(n) = 2 * T(n/2) + O(n) </code>进行左右 &#x2F; n的操作，得到 <code>T(n) / n = (n / 2) * T(n/2) + O(1)</code></p>
<p>现在令 <code>S(n) = T(n)/n</code>，则<code>S(1) = O(1)</code>，然后利用表达式带入得到<code>S(n) = S(n/2) + O(1)</code></p>
<p>所以可以得到：<code>S(n) = S(n/2) + O(1) = S(n/4) + O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)</code></p>
<p>综上可得，<code>T(n) = n * log(n) = nlogn</code></p>
<p>关于归并排序的稳定性，在进行合并过程，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也不会交换，由此可见归并排序是稳定的排序算法</p>
<h4 id="三、应用场景-6"><a href="#三、应用场景-6" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>在外排序中通常使用排序-归并的策略，外排序是指处理超过内存限度的数据的排序算法，通常将中间结果放在读写较慢的外存储器，如下分成两个阶段：</p>
<ul>
<li>排序阶段：读入能够放进内存中的数据量，将其排序输出到临时文件，一次进行，将带排序数据组织为多个有序的临时文件</li>
<li>归并阶段：将这些临时文件组合为大的有序文件</li>
</ul>
<p>例如，使用100m内存对900m的数据进行排序，过程如下：</p>
<ul>
<li>读入100m数据内存，用常规方式排序</li>
<li>将排序后的数据写入磁盘</li>
<li>重复前两个步骤，得到9个100m的临时文件</li>
<li>将100m的内存划分为10份，将9份为输入缓冲区，第10份为输出缓冲区</li>
<li>进行九路归并排序，将结果输出到缓冲区<ul>
<li>若输出缓冲区满，将数据写到目标文件，清空缓冲区</li>
<li>若缓冲区空，读入相应文件的下一份数据</li>
</ul>
</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对快速排序的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对快速排序的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对快速排序的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对快速排序的理解？如何实现？应用场景？</h3><h4 id="一、是什么-11"><a href="#一、是什么-11" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>快速排序（Quick Sort）算法是在冒泡排序的基础上进行改进的一种算法，从名字上看就知道该排序算法的特点是快、效率高，是处理大数据最快的排序算法之一</p>
<p>实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小</p>
<p>然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就变成有序序列</p>
<p>例如，对无序表49，38，65，97，76，13，27，49进行快速排序，大致过程为：</p>
<ul>
<li>首先从表中选取一个记录的关键字作为分割点（称为“枢轴”或者支点，一般选择第一个关键字），例如选取 49</li>
<li>将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：{27，38，13，49，65，97，76，49}</li>
<li>以 49 为支点，将整个无序表分割成了两个部分，分别为{27，38，13}和{65，97，76，49}，继续采用此种方法分别对两个子表进行排序</li>
<li>前部分子表以 27 为支点，排序后的子表为{13，27，38}，此部分已经有序；后部分子表以 65 为支点，排序后的子表为{49，65，97，76}</li>
<li>此时前半部分子表中的数据已完成排序；后部分子表继续以 65 为支点，将其分割为{49}和{97，76}，前者不需排序，后者排序后的结果为{76， 97}</li>
<li>通过以上几步的排序，最后由子表{13，27，38}、{49}、{49}、{65}、{76，97}构成有序表：{13，27，38，49，49，65，76，97}</li>
</ul>
<h4 id="二、如何实现-4"><a href="#二、如何实现-4" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>可以分成以下步骤：</p>
<ul>
<li>分区：从数组中选择任意一个基准，所有比基准小的元素放在基准的左边，比基准大的元素放到基准的右边</li>
<li>递归：递归地对基准前后的子数组进行分区</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7777772e72756e6f6f622e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f717569636b536f72742e676966.gif"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">function quickSort (arr) &#123;
  const rec = (arr) =&gt; &#123;
    if (arr.length &lt;= 1) &#123; return arr; &#125;
    const left = [];
    const right = [];
    const mid = arr[0]; // 基准元素
    for (let i = 1; i &lt; arr.length; i++)&#123;
      if (arr[i] &lt; mid) &#123;
        left.push(arr[i]);
      &#125; else &#123;
        right.push(arr[i]);
      &#125;
    &#125;
    return [...rec(left), mid, ...rec(right)]
  &#125;
  return rec(arr)
&#125;;
</code></pre>
<p>快速排序是冒泡排序的升级版，最坏情况下每一次基准元素都是数组中最小或者最大的元素，则快速排序就是冒泡排序</p>
<p>这种情况时间复杂度就是冒泡排序的时间复杂度：<code>T[n] = n * (n-1) = n^2 + n</code>，也就是<code>O(n^2)</code></p>
<p>最好情况下是<code>O(nlogn)</code>，其中递归算法的时间复杂度公式：<code>T[n] = aT[n/b] + f(n)</code>，推导如下所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62363031393534302d326235652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>关于上述代码实现的快速排序，可以看到是稳定的</p>
<h4 id="三、应用场景-7"><a href="#三、应用场景-7" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>快速排序时间复杂度为<code>O(nlogn)</code>，是目前基于比较的内部排序中被认为最好的方法，当数据过大且数据杂乱无章时，则适合采用快速排序</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对二分查找的理解？如何实现？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对二分查找的理解？如何实现？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对二分查找的理解？如何实现？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对二分查找的理解？如何实现？应用场景？</h3><h4 id="一、是什么-12"><a href="#一、是什么-12" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在计算机科学中，二分查找算法，也称折半搜索算法，是一种在有序数组中查找某一特定元素的搜索算法</p>
<p>想要应用二分查找法，则这一堆数应有如下特性：</p>
<ul>
<li>存储在数组中</li>
<li>有序排序</li>
</ul>
<p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束</p>
<p>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较</p>
<p>如果在某一步骤数组为空，则代表找不到</p>
<p>这种搜索算法每一次比较都使搜索范围缩小一半</p>
<p>如下图所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65323130383532302d323938372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>相比普通的顺序查找，除了数据量很少的情况下，二分查找会比顺序查找更快，区别如下所示：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f706963322e7a68696d672e636f6d2f76322d34333333396239363364623633623333313037623536353033616436623162355f622e676966.gif"></p>
<h4 id="二、如何实现-5"><a href="#二、如何实现-5" class="headerlink" title="二、如何实现"></a>二、如何实现</h4><p>基于二分查找的实现，如果数据是有序的，并且不存在重复项，实现代码如下：</p>
<pre><code class="javascript">function BinarySearch(arr, target) &#123;
    if (arr.length &lt;= 1) return -1
    // 低位下标
    let lowIndex = 0
    // 高位下标
    let highIndex = arr.length - 1

    while (lowIndex &lt;= highIndex) &#123;
        // 中间下标
        const midIndex = Math.floor((lowIndex + highIndex) / 2)
        if (target &lt; arr[midIndex]) &#123;
            highIndex = midIndex - 1
        &#125; else if (target &gt; arr[midIndex]) &#123;
            lowIndex = midIndex + 1
        &#125; else &#123;
            // target === arr[midIndex]
            return midIndex
        &#125;
    &#125;
    return -1
&#125;
</code></pre>
<p>如果数组中存在重复项，而我们需要找出第一个制定的值，实现则如下：</p>
<pre><code class="javascript">function BinarySearchFirst(arr, target) &#123;
    if (arr.length &lt;= 1) return -1
    // 低位下标
    let lowIndex = 0
    // 高位下标
    let highIndex = arr.length - 1

    while (lowIndex &lt;= highIndex) &#123;
        // 中间下标
        const midIndex = Math.floor((lowIndex + highIndex) / 2)
        if (target &lt; arr[midIndex]) &#123;
            highIndex = midIndex - 1
        &#125; else if (target &gt; arr[midIndex]) &#123;
            lowIndex = midIndex + 1
        &#125; else &#123;
            // 当 target 与 arr[midIndex] 相等的时候，如果 midIndex 为0或者前一个数比 target 小那么就找到了第一个等于给定值的元素，直接返回
            if (midIndex === 0 || arr[midIndex - 1] &lt; target) return midIndex
            // 否则高位下标为中间下标减1，继续查找
            highIndex = midIndex - 1
        &#125;
    &#125;
    return -1
&#125;
</code></pre>
<p>实际上，除了有序的数组可以使用，还有一种特殊的数组可以应用，那就是轮转后的有序数组</p>
<p>有序数组即一个有序数字以某一个数为轴，将其之前的所有数都轮转到数组的末尾所得</p>
<p>例如，[4, 5, 6, 7, 0, 1, 2]就是一个轮转后的有序数组</p>
<p>该数组的特性是存在一个分界点用来分界两个有序数组，如下：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65656565323133302d323938372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>分界点有如下特性：</p>
<ul>
<li>分界点元素 &gt;&#x3D; 第一个元素</li>
<li>分界点元素 &lt; 第一个元素</li>
</ul>
<p>代码实现如下：</p>
<pre><code class="javascript">function search (nums, target) &#123;
  // 如果为空或者是空数组的情况
  if (nums == null || !nums.length) &#123;
    return -1;
  &#125;
  // 搜索区间是前闭后闭
  let begin = 0,
    end = nums.length - 1;
  while (begin &lt;= end) &#123;
    // 下面这样写是考虑大数情况下避免溢出
    let mid = begin + ((end - begin) &gt;&gt; 1);
    if (nums[mid] == target) &#123;
      return mid;
    &#125;
    // 如果左边是有序的
    if (nums[begin] &lt;= nums[mid]) &#123;
      //同时target在[ nums[begin],nums[mid] ]中，那么就在这段有序区间查找
      if (nums[begin] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;
        end = mid - 1;
      &#125; else &#123;
        //否则去反方向查找
        begin = mid + 1;
      &#125;
      //如果右侧是有序的
    &#125; else &#123;
      //同时target在[ nums[mid],nums[end] ]中，那么就在这段有序区间查找
      if (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end]) &#123;
        begin = mid + 1;
      &#125; else &#123;
        end = mid - 1;
      &#125;
    &#125;
  &#125;
  return -1;
&#125;;
</code></pre>
<p>对比普通的二分查找法，为了确定目标数会落在二分后的哪个部分，我们需要更多的判定条件</p>
<h4 id="三、应用场景-8"><a href="#三、应用场景-8" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>二分查找法的<code>O(logn)</code>让它成为十分高效的算法。不过它的缺陷却也是比较明显，就在它的限定之上：</p>
<ul>
<li>有序：我们很难保证我们的数组都是有序的</li>
<li>数组：数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)，并且数组的存储是需要连续的内存空间，不适合大数据的情况</li>
</ul>
<p>关于二分查找的应用场景，主要如下：</p>
<ul>
<li>不适合数据量太小的数列；数列太小，直接顺序遍历说不定更快，也更简单</li>
<li>每次元素与元素的比较是比较耗时的，这个比较操作耗时占整个遍历算法时间的大部分，那么使用二分查找就能有效减少元素比较的次数</li>
<li>不适合数据量太大的数列，二分查找作用的数据结构是顺序表，也就是数组，数组是需要连续的内存空间的，系统并不一定有这么大的连续内存空间可以使用</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对分而治之、动态规划的理解？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对分而治之、动态规划的理解？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对分而治之、动态规划的理解？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对分而治之、动态规划的理解？区别？</h3><h4 id="一、分而治之"><a href="#一、分而治之" class="headerlink" title="一、分而治之"></a>一、分而治之</h4><p>分而治之是算法设计中的一种方法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p>
<p>关于分而治之的实现，都会经历三个步骤：</p>
<ul>
<li>分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题</li>
<li>解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题</li>
<li>合并：将各子问题的解合并为原问题的解</li>
</ul>
<p>实际上，关于分而治之的思想，我们在前面已经使用，例如归并排序的实现，同样经历了实现分而治之的三个步骤：</p>
<ul>
<li>分解：把数组从中间一分为二</li>
<li>解决：递归地对两个子数组进行归并排序</li>
<li>合并：将两个字数组合并称有序数组</li>
</ul>
<p>同样关于快速排序的实现，亦如此：</p>
<ul>
<li>分：选基准，按基准把数组分成两个字数组</li>
<li>解：递归地对两个字数组进行快速排序</li>
<li>合：对两个字数组进行合并</li>
</ul>
<p>同样二分搜索也能使用分而治之的思想去实现，代码如下：</p>
<pre><code class="javascript">function binarySearch(arr,l,r,target)&#123;
    if(l&gt; r)&#123;
        return -1;
    &#125;
    let mid = l + Math.floor((r-l)/2)
    if(arr[mid] === target)&#123;
        return mid;
    &#125;else if(arr[mid] &lt; target )&#123;
        return binarySearch(arr,mid + 1,r,target)
    &#125;else&#123;
        return binarySearch(arr,l,mid - 1,target)
    &#125;
&#125;
</code></pre>
<h4 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h4><p>动态规划，同样是算法设计中的一种方法，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</p>
<p>常常适用于有重叠子问题和最优子结构性质的问题</p>
<p>简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决</p>
<p>然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。</p>
<p>一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2的时候，F(n) &#x3D; F(n-1) + F(n-2) ，</p>
<p>f(10)&#x3D; f(9)+f(8),f(9) &#x3D; f(8) + f(7)…是重叠子问题，当n &#x3D; 1、2的时候，对应的值为2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划</p>
<p>比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景</p>
<p>关于动态规划题目解决的步骤，一般如下：</p>
<ul>
<li>描述最优解的结构</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值</li>
<li>由计算出的结果构造一个最优解</li>
</ul>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</p>
<p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的，而分而治之的子问题是相互独立的</p>
<p>若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次</p>
<p>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间</p>
<p>综上，可得：</p>
<ul>
<li>动态规划：有最优子结构和重叠子问题</li>
<li>分而治之：各子问题独立</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对贪心算法、回溯算法的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对贪心算法、回溯算法的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对贪心算法、回溯算法的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对贪心算法、回溯算法的理解？应用场景？</h3><h4 id="一、贪心算法"><a href="#一、贪心算法" class="headerlink" title="一、贪心算法"></a>一、贪心算法</h4><p>贪心算法，又称贪婪算法，是算法设计中的一种思想</p>
<p>其期待每一个阶段都是局部最优的选择，从而达到全局最优，但是结果并不一定是最优的</p>
<p>举个零钱兑换的例子，如果你有1元、2元、5元的钱币数张，用于兑换一定的金额，但是要求兑换的钱币张数最少</p>
<p>如果现在你要兑换11元，按照贪心算法的思想，先选择面额最大的5元钱币进行兑换，那么就得到11 &#x3D; 5 + 5 + 1 的选择，这种情况是最优的</p>
<p>但是如果你手上钱币的面额为1、3、4，想要兑换6元，按照贪心算法的思路，我们会 6 &#x3D; 4 + 1 + 1这样选择，这种情况结果就不是最优的选择</p>
<p>从上面例子可以看到，贪心算法存在一些弊端，使用到贪心算法的场景，都会存在一个特性：</p>
<p>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法</p>
<p>至于是否选择贪心算法，主要看是否有如下两大特性：</p>
<ul>
<li>贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择</li>
<li>最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在</li>
</ul>
<h4 id="二、回溯算法"><a href="#二、回溯算法" class="headerlink" title="二、回溯算法"></a>二、回溯算法</h4><p>回溯算法，也是算法设计中的一种思想，是一种渐进式寻找并构建问题解决方式的策略</p>
<p>回溯算法会先从一个可能的工作开始解决问题，如果不行，就回溯并选择另一个动作，知道将问题解决</p>
<p>使用回溯算法的问题，有如下特性：</p>
<ul>
<li>有很多路，例如一个矩阵的方向或者树的路径</li>
<li>在这些的路里面，有死路也有生路，思路即不符合题目要求的路，生路则符合</li>
<li>通常使用递归来模拟所有的路</li>
</ul>
<p>常见的伪代码如下：</p>
<pre><code class="javascript">result = []
function backtrack(路径, 选择列表):
  if 满足结束条件:
    result.add(路径)
  return

  for 选择 of 选择列表:
    做选择
    backtrack(路径, 选择列表)
    撤销选择
</code></pre>
<p>重点解决三个问题：</p>
<ul>
<li>路径：也就是已经做出的选择</li>
<li>选择列表</li>
<li>结束条件</li>
</ul>
<p>例如经典使用回溯算法为解决全排列的问题，如下：</p>
<p>一个不含重复数字的数组 <code>nums</code> ，我们要返回其所有可能的全排列，解决这个问题的思路是：</p>
<ul>
<li>用递归模拟所有的情况</li>
<li>遇到包含重复元素的情况则回溯</li>
<li>收集到所有到达递归终点的情况，并返回、</li>
</ul>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32613033306630302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>用代码表示则如下：</p>
<pre><code class="javascript">var permute = function(nums) &#123;
    const res = [], path = [];
    backtracking(nums, nums.length, []);
    return res;
    
    function backtracking(n, k, used) &#123;
        if(path.length === k) &#123;
            res.push(Array.from(path));
            return;
        &#125;
        for (let i = 0; i &lt; k; i++ ) &#123;
            if(used[i]) continue;
            path.push(n[i]);
            used[i] = true; // 同支
            backtracking(n, k, used);
            path.pop();
            used[i] = false;
        &#125;
    &#125;
&#125;;
</code></pre>
<h4 id="三、总结-3"><a href="#三、总结-3" class="headerlink" title="三、总结"></a>三、总结</h4><p>前面也初步了解到分而治之、动态规划，现在再了解到贪心算法、回溯算法</p>
<p>其中关于分而治之、动态规划、贪心策略三者的求解思路如下：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35303462353233302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>其中三者对应的经典问题如下图：</p>
<p><img src="/2022/11/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%AE%97%E6%B3%95%E7%AF%87/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36326364633931302d326538652d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端异常捕获问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/05/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E9%97%AE%E9%A2%98/"
    >前端异常捕获问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/05/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2022-11-05T01:33:35.000Z" itemprop="datePublished">2022-11-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/">前端异常捕获</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（异常捕获）"><a href="#前端面试题大全（异常捕获）" class="headerlink" title="前端面试题大全（异常捕获）"></a>前端面试题大全（异常捕获）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><h4 id="什么是异常数据？"><a href="#什么是异常数据？" class="headerlink" title="什么是异常数据？"></a>什么是异常数据？</h4><p>异常数据，是指前端在操作页面的过程中，触发的执行异常或加载异常，此时浏览器会抛出来报错信息。</p>
<p>比如说你的前端代码用了个未声明的变量，此时控制台会打印出红色错误，告诉你报错原因。或者是接口请求出错了，在网络面板内也能查到异常情况，是请求发送的异常，还是接口响应的异常。</p>
<p>在我们实际的开发场景中，前端捕获的异常主要是分两个大类，接口异常 和 前端异常，我们分别看下这两大类异常怎么捕获。</p>
<h4 id="接口异常"><a href="#接口异常" class="headerlink" title="接口异常"></a>接口异常</h4><p>接口异常一定是在请求的时候触发。前端目前大部分的请求是用 axios 发起的，所以只要获取 axios 可能发生的异常即可。</p>
<p>如果你用 Promise 的写法，则用 .catch 捕获：</p>
<pre><code class="javascript">axios
  .post(&#39;/test&#39;)
  .then((res) =&gt; &#123;
    console.log(res);
  &#125;)
  .catch((err) =&gt; &#123;
    // err 就是捕获到的错误对象
    handleError(err);
  &#125;);
</code></pre>
<p>如果你用 async&#x2F;await 的写法，则用 try..catch.. 捕获：</p>
<pre><code class="javascript">async () =&gt; &#123;
  try &#123;
    let res = await axios.post(&#39;/test&#39;);
    console.log(res);
  &#125; catch (err) &#123;
    // err 就是捕获到的错误对象
    handleError(err);
  &#125;
&#125;;
</code></pre>
<p>当捕获到异常之后，统一交给 handleError 函数处理，这个函数会将接收到的异常进行处理，并调用 上报接口 将异常数据传到服务器，从而完成采集。</p>
<p>上面我们写的异常捕获，逻辑上是没问题的，实操起来就会发现第一道坎：页面这么多，难道每个请求都要包一层 catch 吗？</p>
<p>是啊，如果我们是新开发一个项目，在开始的时候就规定每个请求要包一层 catch 也无可厚非，但是如果是在一个已有的规模还不小的项目中接入前端监控，这时候在每个页面或每个请求 catch 显然是不现实的。</p>
<p>所以，为了最大程度地降低接入成本，减少侵入性，我们是用第二种方案：在 axios 拦截器中捕获异常。</p>
<p>前端项目，为了统一处理请求，比如 401 的跳转，或者全局错误提示，都会在全局写一个 axios 实例，为这个实例添加拦截器，然后在其他页面中直接导入这个实例使用，比如：</p>
<pre><code class="javascript">// 全局请求：src/request/axios.js
const instance = axios.create(&#123;
  baseURL: &#39;https://api.test.com&#39;
  timeout: 15000,
  headers: &#123;
    &#39;Content-Type&#39;: &#39;application/json&#39;,
  &#125;,
&#125;)
export default instance1
</code></pre>
<p>然后在具体的页面中这样发起请求：</p>
<pre><code class="javascript">// a 页面：src/page/a.jsx
import http from &#39;@/src/request/axios.js&#39;;
async () =&gt; &#123;
  let res = await http.post(&#39;/test&#39;);
  console.log(res);
&#125;;
</code></pre>
<p>这样的话，我们发现每个页面的请求都会走全局 axios 实例，所以我们只需要在全局请求的位置捕获异常即可，就不需要在每个页面捕获了，这样接入成本会大大降低。</p>
<p>按照这个方案，接下来我们在 src&#x2F;request&#x2F;axios.js 这个文件中动手实施。</p>
<h4 id="拦截器中捕获异常"><a href="#拦截器中捕获异常" class="headerlink" title="拦截器中捕获异常"></a>拦截器中捕获异常</h4><p>首先我们为 axios 添加响应拦截器：</p>
<pre><code class="javascript">// 响应拦截器
instance.interceptors.response.use(
  (response) =&gt; &#123;
    return response.data;
  &#125;,
  (error) =&gt; &#123;
    // 发生异常会走到这里
    if (error.response) &#123;
      let response = error.response;
      if (response.status &gt;= 400) &#123;
        handleError(response);
      &#125;
    &#125; else &#123;
      handleError(null);
    &#125;
    return Promise.reject(error);
  &#125;,
);
</code></pre>
<p>响应拦截器的第二个参数是在发生错误时执行的函数，参数就是异常。我们首先要判断是否存在 error.response，存在就说明接口有响应，也就是接口通了，但是返回错误；不存在则说明接口没通，请求一直挂起，多数是接口崩溃了。</p>
<p>如果有响应，首先获取状态码，根据状态码来判断什么时候需要收集异常。上面的判断方式简单粗暴，只要状态码大于 400 就视为一个异常，拿到响应数据，并执行上报逻辑。</p>
<p>如果没有响应，可以看作是接口超时异常，调用异常处理函数时传一个 null 即可。</p>
<h3 id="前端异常"><a href="#前端异常" class="headerlink" title="前端异常"></a>前端异常</h3><p>上面我们介绍了在 axios 拦截器中如何捕获接口异常，这部分我们再介绍如何捕获前端异常。</p>
<p>前端代码捕获异常，最常用的方式就是用 try..catch.. 了，任意同步代码块都可以放到 try 块中，只要发生异常就会执行 catch：</p>
<pre><code class="javascript">try &#123;
  // 任意同步代码
&#125; catch (err) &#123;
  console.log(err);
&#125;
</code></pre>
<p>上面说“任意同步代码”而不是“任意代码”，主要是普通的 Promise 写法 try..catch.. 是捕获不到的，只能用 .catch() 捕获，如：</p>
<pre><code class="javascript">try &#123;
  Promise.reject(new Error(&#39;出错了&#39;)).catch((err) =&gt; console.log(&#39;1：&#39;, err));
&#125; catch (err) &#123;
  console.log(&#39;2：&#39;, err);
&#125;
</code></pre>
<p>把这段代码丢进浏览器，打印结果是：</p>
<pre><code class="javascript">1： Error: 出错了1.
</code></pre>
<p>很明显只是 .catch 捕获到了异常。不过与上面接口异常的逻辑一样，这种方式处理当前页面异常没什么问题，但从整个应用来看，这样捕获异常侵入性强，接入成本高，所以我们的思路依然是全局捕获。</p>
<p>全局捕获 js 的异常也比较简单，用 window.addEventLinstener(‘error’) 即可：</p>
<pre><code class="javascript">// js 错误捕获
window.addEventListener(&#39;error&#39;, (error) =&gt; &#123;
  // error 就是js的异常
&#125;);
</code></pre>
<h4 id="为啥不用-window-onerror-？"><a href="#为啥不用-window-onerror-？" class="headerlink" title="为啥不用 window.onerror ？"></a>为啥不用 window.onerror ？</h4><p>这里很多小伙伴有疑问，为什么不用 window.onerror 全局监听呢？window.addEventLinstener(‘error’) 和 window.onerror 有什么区别呢？</p>
<p>首先这两个函数功能基本一致，都可以全局捕获 js 异常。但是有一类异常叫做 资源加载异常，就是在代码中引用了不存在的图片，js，css 等静态资源导致的异常，比如:</p>
<pre><code class="javascript">const loadCss = ()=&gt; &#123;
  let link = document.createElement(&#39;link&#39;)
  link.type = &#39;text/css&#39;
  link.rel = &#39;stylesheet&#39;
  link.href = &#39;https://baidu.com/15.css&#39;
  document.getElementsByTagName(&#39;head&#39;)[10].append(link)
&#125;
render() &#123;
  return &lt;div&gt;
    &lt;img src=&#39;./bbb.png&#39;/&gt;
    &lt;button onClick=&#123;loadCss&#125;&gt;加载样式&lt;button/&gt;
  &lt;/div&gt;
&#125;
</code></pre>
<p>上述代码中的 baidu.com&#x2F;15.css 和 bbb.png 是不存在的，JS 执行到这里肯定会报一个资源找不到的错误。但是默认情况下，上面两种 window 对象上的全局监听函数都监听不到这类异常。</p>
<p>因为资源加载的异常只会在当前元素触发，异常不会冒泡到 window，因此监听 window 上的异常是捕捉不到的。那怎么办呢？</p>
<p>如果你熟悉 DOM 事件你就会明白，既然冒泡阶段监听不到，那么在捕获阶段一定能监听到。</p>
<p>方法就是给 window.addEventListene 函数指定第三个参数，很简单就是 true，表示该监听函数会在捕获阶段执行，这样就能监听到资源加载异常了。</p>
<pre><code class="javascript">// 捕获阶段全局监听
window.addEventListene(
  &#39;error&#39;,
  (error) =&gt; &#123;
    if (error.target != window) &#123;
      console.log(error.target.tagName, error.target.src);
    &#125;
    handleError(error);
  &#125;,
  true,
);
</code></pre>
<p>上述方式可以很轻松的监听到图片加载异常，这就是为什么更推荐 window.addEventListene 的原因。不过要记得，第三个参数设为 true，监听事件捕获，就可以全局捕获到 JS 异常和资源加载异常。</p>
<p>需要特别注意，window.addEventListene 同样不能捕获 Promise 异常。不管是 Promise.then() 写法还是 async&#x2F;await 写法，发生异常时都不能捕获。</p>
<p>因此，我们还需要全局监听一个 unhandledrejection 函数来捕获未处理的 Promise 异常。</p>
<pre><code class="javascript">// promise 错误捕获
window.addEventListener(&#39;unhandledrejection&#39;, (error) =&gt; &#123;
  // 打印异常原因
  console.log(error.reason);
  handleError(error);
  // 阻止控制台打印
  error.preventDefault();
&#125;);
</code></pre>
<p>unhandledrejection 事件会在 Promise 发生异常并且没有指定 catch 的时候触发，相当于一个全局的 Promise 异常兜底方案。这个函数会捕捉到运行时意外发生的 Promise 异常，这对我们排错非常有用。</p>
<p>默认情况下，Promise 发生异常且未被 catch 时，会在控制台打印异常。如果我们想阻止异常打印，可以用上面的 error.preventDefault() 方法。</p>
<h4 id="异常处理函数"><a href="#异常处理函数" class="headerlink" title="异常处理函数"></a>异常处理函数</h4><p>前面我们在捕获到异常时调用了一个异常处理函数 handleError，所有的异常和上报逻辑统一在这个函数内处理，接下来我们实现这个函数。</p>
<pre><code class="javascript">const handleError = (error: any, type: 1 | 2) &#123;
  if(type == 1) &#123;
    // 处理接口异常
  &#125;
  if(type == 2) &#123;
    // 处理前端异常
  &#125;
&#125;
</code></pre>
<p>为了区分异常类型，函数新加了第二个参数 type 表示当前异常属于前端还是接口。在不同的场景中使用如下：</p>
<ul>
<li>处理前端异常：handleError(error, 1)。</li>
<li>处理接口异常：handleError(error, 2)。</li>
</ul>
<h3 id="处理接口异常"><a href="#处理接口异常" class="headerlink" title="处理接口异常"></a>处理接口异常</h3><p>处理接口异常，我们需要将拿到的 error 参数解析，然后取到需要的数据。接口异常一般需要的数据字段如下：</p>
<ul>
<li>code：http 状态码。</li>
<li>url：接口请求地址。</li>
<li>method：接口请求方法。</li>
<li>params：接口请求参数。</li>
<li>error：接口报错信息。</li>
</ul>
<p>这些字段都可以在 error 参数中获取，方法如下：</p>
<pre><code class="javascript">const handleError = (error: any, type: 1 | 2) &#123;
  if(type == 1) &#123;
    // 此时的 error 响应，它的 config 字段中包含请求信息
    let &#123; url, method, params, data &#125; = error.config
    let err_data = &#123;
       url, method,
       params: &#123; query: params, body: data &#125;,
       error: error.data?.message || JSON.stringify(error.data),
    &#125;)
  &#125;
&#125;
</code></pre>
<p>config 对象中的 params 表示 GET 请求的 query 参数，data 表示 POST 请求的 body 参数，所以我在处理参数的时候，将这两个参数合并为一个，用一个属性 params 来表示。</p>
<pre><code class="javascript">params: &#123; query: params, body: data &#125;
</code></pre>
<p>还有一个 error 属性表示错误信息，这个获取方式要根据你的接口返回格式来拿。要避免获取到接口可能返回的超长错误信息，多半是接口没处理，这样可能会导致写入数据失败，要提前与后台规定好。</p>
<h3 id="处理前端异常"><a href="#处理前端异常" class="headerlink" title="处理前端异常"></a>处理前端异常</h3><p>前端异常异常大多数就是 js 异常，异常对应到 js 的 Error 对象，在处理之前，我们先看 Error 有哪几种类型：</p>
<ul>
<li>ReferenceError：引用错误。</li>
<li>RangeError：超出有效范围。</li>
<li>TypeError：类型错误。</li>
<li>URIError：URI 解析错误。</li>
</ul>
<p>这几类异常的引用对象都是 Error，因此可以这样获取：</p>
<pre><code class="javascript">const handleError = (error: any, type: 1 | 2) &#123;
  if(type == 2) &#123;
    let err_data = null
    // 监测 error 是否是标准类型
    if(error instanceof Error) &#123;
      let &#123; name, message &#125; = error
      err_data = &#123;
        type: name,
        error: message
      &#125;
    &#125; else &#123;
      err_data = &#123;
        type: &#39;other&#39;,
        error: JSON.strigify(error)
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<p>上述判断中，首先判断异常是否是 Error 的实例。事实上绝大部分的代码异常都是标准的 JS Error，但我们这里还是判断一下，如果是的话直接获取异常类型和异常信息，不是的话将异常类型设置为 other 即可。</p>
<p>我们随便写一个异常代码，看一下捕获的结果：</p>
<pre><code class="javascript">function test() &#123;
  console.aaa(&#39;ccc&#39;);
&#125;
test();
</code></pre>
<p>然后捕获到的异常是这样的：</p>
<pre><code class="javascript">const handleError = (error: any) =&gt; &#123;
  if (error instanceof Error) &#123;
    let &#123; name, message &#125; = error;
    console.log(name, message);
    // 打印结果：TypeError console.aaa is not a function
  &#125;
&#125;;
</code></pre>
<h4 id="获取环境数据"><a href="#获取环境数据" class="headerlink" title="获取环境数据"></a>获取环境数据</h4><p>获取环境数据的意思是，不管是接口异常还是前端异常，除了异常本身的数据之外，我们还需要一些其他信息来帮助我们更快更准的定位到哪里出错了。</p>
<p>这类数据我们称之为 “环境数据”，就是触发异常时所在的环境。比如是谁在哪个页面的哪个地方触发的错误，有了这些，我们就能马上找到错误来源，再根据异常信息解决错误。</p>
<p>环境数据至少包括下面这些：</p>
<ul>
<li>app：应用的名称&#x2F;标识。</li>
<li>env：应用环境，一般是开发，测试，生产。</li>
<li>version：应用的版本号。</li>
<li>user_id：触发异常的用户 ID。</li>
<li>user_name：触发异常的用户名。</li>
<li>page_route：异常的页面路由。</li>
<li>page_title：异常的页面名称。</li>
</ul>
<p>app 和 version 都是应用配置，可以判断异常出现在哪个应用的哪个版本。这两个字段我建议直接获取 package.json 下的 name 和 version 属性，在应用升级的时候，及时修改 version 版本号即可。</p>
<h3 id="Vue和React异常处理"><a href="#Vue和React异常处理" class="headerlink" title="Vue和React异常处理"></a>Vue和React异常处理</h3><blockquote>
<p>现在越来越多的项目开始使用前端框架，在MVVM框架中如果你一如既往的想使用window.onerror来捕获异常，那么很可能会竹篮打水一场空，或许根本捕获不到，因为你的异常信息被框架自身的异常机制捕获了。</p>
</blockquote>
<p>比如Vue 2.x中我们应该这样捕获全局异常：</p>
<pre><code class="js">Vue.config.errorHandler = function (err, vm, info) &#123;
    let &#123; 
        message, // 异常信息
        name, // 异常名称
        script,  // 异常脚本url
        line,  // 异常行号
        column,  // 异常列号
        stack  // 异常堆栈信息
    &#125; = err;

    // vm为抛出异常的 Vue 实例
    // info为 Vue 特定的错误信息，比如错误所在的生命周期钩子
&#125;
</code></pre>
<blockquote>
<p>目前script、line、column这3个信息打印出来是undefined，不过这些信息在stack中都可以找到，可以通过正则匹配去进行获取，然后进行上报。</p>
<p>同样的在react也提供了异常处理的方式，在 React 16.x 版本中引入了 Error Boundary：</p>
</blockquote>
<pre><code class="js">class ErrorBoundary extends React.Component &#123;
    constructor(props) &#123;
        super(props);
        this.state = &#123; hasError: false &#125;;
    &#125;

    componentDidCatch(error, info) &#123;
        this.setState(&#123; hasError: true &#125;);

        // 将异常信息上报给服务器
        logErrorToMyService(error, info); 
    &#125;

    render() &#123;
        if (this.state.hasError) &#123;
            return &#39;出错了&#39;;
        &#125;

        return this.props.children;
    &#125;
&#125;
</code></pre>
<p>然后我们就可以这样使用该组件：</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/711309.html">https://www.51cto.com/article/711309.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7072179884247744526">https://juejin.cn/post/7072179884247744526</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试题大全前端工程化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"
    >前端面试题大全前端工程化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" class="article-date">
  <time datetime="2022-11-04T03:25:24.000Z" itemprop="datePublished">2022-11-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（前端工程化）"><a href="#前端面试题大全（前端工程化）" class="headerlink" title="前端面试题大全（前端工程化）"></a>前端面试题大全（前端工程化）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="♥︎-♥︎-♥︎-什么是-bundle-什么是-chunk，什么是module？"><a href="#♥︎-♥︎-♥︎-什么是-bundle-什么是-chunk，什么是module？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是 bundle, 什么是 chunk，什么是module？"></a>♥︎ ♥︎ ♥︎ 什么是 bundle, 什么是 chunk，什么是module？</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>bundle</code>、<code>module</code>、<code>chunk</code> 都是 webpack 中的术语，下面就一个一个介绍他们的定义是什么，怎么产生的。</p>
<h5 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h5><p>Bundle是由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本。 Bundle 分离（Bundle Splitting）:这个流程提供了一个优化 build 的方法，允许 webpack 为应用程序生成多个 bundle。最终效果是，当其他某些 bundle 的改动时，彼此独立的另一些 bundle 都可以不受到影响，减少需要重新发布的代码量，因此由客户端重新下载并利用浏览器缓存。</p>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h5><p>模块（Module）提供比较完整程序接触面（surface area）更小的离散功能块。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。 模块解析（Module Resolution）一个模块可以作为另一个模块的依赖模块，resolver 是一个库（libary）用于帮助找不到模块的绝对路径，模块将在resolve.modules中指定的所有目录内搜索。</p>
<h5 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h5><p>Chunk这是 webpack 特定的术语被用在内部来管理 building 过程。bundle 是由 chunk 组成，其中有几种类型（例如，入口 chunk(entry chunk)和子 chunk(child chunk)）。通常 chunk 会直接对应所输出的 bundle，但是有一些配置并不会产生一对一的关系。 代码分离（Code Splitting）指将代码分离到每个 bundles&#x2F;chunks 里面，你可以按需加载，而不是加载一个包含全部的 bundle。 配置（Configuration）webpack 的配置文件是一个普通的 JavaScript 文件，它导出为一个对象。然后由 webpack 根据这个对象定义的属性进行处理。</p>
<h4 id="Bundle-VS-Chunk-VS-Module"><a href="#Bundle-VS-Chunk-VS-Module" class="headerlink" title="Bundle VS Chunk VS Module"></a>Bundle VS Chunk VS Module</h4><p>我们从定义和时期来说：</p>
<ul>
<li>“模块”<code>(module)</code>的概念大家都比较熟悉，如 <code>CommonJS 模块</code>、<code>AMD</code>、<code>ES6 Modules</code> 模块</li>
<li><code>chunk</code> 表示打包的时候产生得模块，由他来组成 <code>bundle</code></li>
<li>打包完成的源代码</li>
</ul>
<p>我们现在就只创建一个能编译<code>js</code>的<code>webpack</code>配置，步骤如下：</p>
<ol>
<li>创建一个空文件夹，并且在当文件夹中打开 <code>bash or cmd</code>。</li>
<li><code>npm init -y</code> 生成<code>package.json</code>。</li>
<li>如果你安装了<code>cnpm or yarn</code> 就执行 <code>cnpm i webpack webpack-cli -D</code>, 安装<code>webpack</code>的包。</li>
<li>创建<code>src</code>，在<code>src</code>内部创建<code>chunk0.js</code>、<code>chunk1.js</code>、<code>common.js</code>、<code>index.js</code>、<code>style.css</code>，并且编写内部代码</li>
<li>在项目根目录创建 <code>webpack.config.js</code></li>
<li>直接在<code>cmd</code>中运行 <code>webpack</code></li>
</ol>
<p>下面是代码 </p>
<p>chunk0.js</p>
<pre><code class="javascript">export default function add(a, b) &#123;
  return a + b;
&#125;
</code></pre>
<p>chunk1.js</p>
<pre><code class="javascript">export default function flow() &#123;
  return &quot;flow&quot;;
&#125;
</code></pre>
<p>common.js</p>
<pre><code class="javascript">export default function commonJs() &#123;
  return &quot;commonJs&quot;;
&#125;
</code></pre>
<p>index.js</p>
<pre><code class="javascript">import add from &quot;./chunk0.js&quot;;
import commonJs from &quot;./common&quot;;
console.log(add(1, 2));
console.log(commonJs());
</code></pre>
<p>webpack.config.js</p>
<pre><code class="java">module.exports = &#123;
  mode: &quot;production&quot;, // 如果不添加就会警告
  entry: &#123;
    index: &quot;./src/index.js&quot;, // 一个入口文件
    chunk1: &quot;./src/chunk1.js&quot; // 两一个入口文件
  &#125;,
  output: &#123;
    filename: &quot;[name].bundle.js&quot; // 出口文件
  &#125;
&#125;;
</code></pre>
<p>运行的效果如下</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/image-20221104082742567.png"></p>
<p>通过上面的代码知道，<code>module</code> 就是没有被编译之前的代码，通过 <code>webpack</code> 的根据文件引用关系生成 <code>chunk</code> 文件，webpack 处理好 <code>chunk</code> 文件后，生成运行在浏览器中的代码 <code>bundle</code>。</p>
<h3 id="♥︎-♥︎-♥︎-hash-chunkhash-contenthash三者区别"><a href="#♥︎-♥︎-♥︎-hash-chunkhash-contenthash三者区别" class="headerlink" title="♥︎ ♥︎ ♥︎ hash chunkhash contenthash三者区别"></a>♥︎ ♥︎ ♥︎ hash chunkhash contenthash三者区别</h3><h4 id="一、Webpack与hash算法"><a href="#一、Webpack与hash算法" class="headerlink" title="一、Webpack与hash算法"></a>一、Webpack与hash算法</h4><p>在使用Webpack对构建的时候，Webpack会根据所有的文件内容计算出一个特殊的字符串。只要有文件的内容变化了，Webpack就会计算出一个新的特殊字符串。</p>
<p>Webpack在根据文件内容计算出一个特殊字符串的时候，使用的就是hash算法，这个特殊字符串一般叫做hash值。</p>
<p>我们一般取计算出的特殊字符串的前八位作为文件名的一部分，因为hash算法计算出的前八位基本可以保证唯一性了。</p>
<p>在Webpack里，我们通常用[hash:8]这种形式表示取hash值的前八位，例如在Webpack配置文件中，我们用 filename: ‘jQuery-[hash:8].js’。</p>
<h4 id="二、webpack中hash、chunkhash和contenthash的区别"><a href="#二、webpack中hash、chunkhash和contenthash的区别" class="headerlink" title="二、webpack中hash、chunkhash和contenthash的区别"></a>二、webpack中hash、chunkhash和contenthash的区别</h4><p>Webpack通过对文件进行hash算法获得的hash值，除了有hash，还有chunkhash和contenthash，那么这三者有什么不同呢？</p>
<p>首先，hash、chunkhash和contenthash这三者都是根据文件内容计算出的hash值，只是它们所计算的文件不一样。</p>
<p>hash是根据打包中所有的文件计算出的hash值。在一次打包中，所有出口文件的filename获得的[hash]都是一样的。</p>
<p>chunkhash是根据打包过程中当前chunk计算出的hash值。如果Webpack配置是多入口配置，那么通常会生成多个chunk，每个chunk对应的出口filename获得的[chunkhash]是不一样的。这样可以保证打包后每一个JS文件名都不一样（这么说不太严谨，但有助于理解）。</p>
<p>Webpack配置文件如下，第一次打包filename取值为’[name]-[hash:8].js’，第二次为’[name]-[chunkhash:8].js’。</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);
module.exports = &#123;
    entry: &#123;
        app1: &#39;./a.js&#39;,
        app2: &#39;./b.js&#39;,
        app3: &#39;./c.js&#39;,
&#125;,
output: &#123;
path: path.resolve(__dirname, &#39;&#39;),
filename: &#39;[name]-[hash:8].js&#39;
// filename: &#39;[name]-[chunkhash:8].js&#39;
&#125;,
mode: &#39;none&#39;
&#125;;
</code></pre>
<p>contenthash有点像chunkhash，是根据打包时CSS内容计算出的hash值。一般在使用提取CSS的插件的时候，我们使用contenthash。例如下面的配置，我们生成的CSS文件名可能会是main.3aa2e3c6.css。</p>
<pre><code class="javascript">plugins:[
new miniExtractPlugin(&#123;
        filename: &#39;main.[contenthash:8].css&#39;
&#125;)
]
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Webpack中hash、chunkhash和contenthash主要与浏览器缓存行为有关。浏览器在初次请求服务端资源的时候，服务器给JS、CSS和图片等资源一个较长的缓存时间，我们通过给资源名称增加hash值来控制浏览器是否继续使用本地缓存。hash、chunkhash和contenthash这三者都是根据文件内容计算出的hash值，[hash]是根据全部参与打包的文件计算出来的，[chunkhash]是根据当前打包的chunk计算出来的，[contenthash]是CSS文件的。</p>
<h3 id="♥︎-♥︎-♥︎-你知道什么是脚手架吗？"><a href="#♥︎-♥︎-♥︎-你知道什么是脚手架吗？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你知道什么是脚手架吗？"></a>♥︎ ♥︎ ♥︎ 你知道什么是脚手架吗？</h3><p>脚手架的概念和作用：就是拥有完整的开发环境，帮助我们快速的生成一套既定的项目架构、文件、配置。使用者只需要专注自己的业务代码即可，不需要使用者单独配置 </p>
<p>脚手架的构成：常见的脚手架的开发环境主要分为三种模式：生产模式，开发模式，测试模式。以及需要配置完整的路由系统(vue-router,react-router-dom)，和状态管理系统(vuex,redux)才能保证开发环境的完整性 </p>
<p>常见的脚手架：Vue-cli,Creat-React-app,umi-app</p>
<h3 id="♥︎-♥︎-♥︎-你对webpack的理解？解决了什么问题？"><a href="#♥︎-♥︎-♥︎-你对webpack的理解？解决了什么问题？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你对webpack的理解？解决了什么问题？"></a>♥︎ ♥︎ ♥︎ 你对webpack的理解？解决了什么问题？</h3><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p><code>Webpack</code> 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p>
<h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的<code> JS</code> 文件中</p>
<p>约定每个文件是一个独立的模块，然后再将这些<code>js</code>文件引入到页面，一个<code>script</code>标签对应一个模块，然后调用模块化的成员</p>
<pre><code class="ini">&lt;script src=&quot;module-a.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;module-b.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题</p>
<p>项目一旦变大，上述问题会尤其明显</p>
<p>随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p>
<pre><code class="javascript">window.moduleA = &#123;
  method1: function () &#123;
    console.log(&#39;moduleA#method1&#39;)
  &#125;
&#125;
</code></pre>
<p>这种方式也并没有解决第一种方式的依赖等问题</p>
<p>再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下</p>
<pre><code class="javascript">// module-a.js
(function ($) &#123;
  var name = &#39;module-a&#39;

  function method1 () &#123;
    console.log(name + &#39;#method1&#39;)
    $(&#39;body&#39;).animate(&#123; margin: &#39;200px&#39; &#125;)
  &#125;
    
  window.moduleA = &#123;
    method1: method1
  &#125;
&#125;)(jQuery)
</code></pre>
<p>上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过<code>script</code>标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦</p>
<p>理想的解决方式是，在页面中引入一个<code>JS</code>入口文件，其余用到的模块可以通过代码控制，按需加载进来</p>
<p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS </code>、<code>ES Modules</code></p>
<h4 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h4><p>从后端渲染的<code>JSP</code>、<code>PHP</code>，到前端原生<code>JavaScript</code>，再到<code>jQuery</code>开发，再到目前的三大框架<code>Vue</code>、<code>React</code>、<code>Angular</code></p>
<p>开发方式，也从<code>javascript</code>到后面的<code>es5</code>、<code>es6、7、8、9、10</code>，再到<code>typescript</code>，包括编写<code>CSS</code>的预处理器<code>less</code>、<code>scss</code>等</p>
<p>现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：</p>
<ul>
<li>需要通过模块化的方式来开发</li>
<li>使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码</li>
<li>监听文件的变化来并且反映到浏览器上，提高开发的效率</li>
<li>JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题</li>
<li>开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化</li>
</ul>
<p>而<code>webpack</code>恰巧可以解决以上问题</p>
<h4 id="三、是什么"><a href="#三、是什么" class="headerlink" title="三、是什么"></a>三、是什么</h4><p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具</p>
<ul>
<li>静态模块</li>
</ul>
<p>这里的静态模块指的是开发阶段，可以被 <code>webpack</code> 直接引用的资源（可以直接被获取打包进<code>bundle.js</code>的资源）</p>
<p>当 <code>webpack </code>处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限<code>js</code>文件），并生成一个或多个 <code>bundle</code></p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39636531393461302d613537382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="webpack的能力："><a href="#webpack的能力：" class="headerlink" title="webpack的能力："></a><code>webpack</code>的能力：</h5><p>编译代码能力，提高效率，解决浏览器兼容问题<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63356332643336302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"><br>模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64333036643236302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"><br>万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制<br><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65336335613034302d613539322d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-webpack的核心思想是什么"><a href="#♥︎-♥︎-♥︎-webpack的核心思想是什么" class="headerlink" title="♥︎ ♥︎ ♥︎ webpack的核心思想是什么"></a>♥︎ ♥︎ ♥︎ webpack的核心思想是什么</h3><p>万物皆模块：在webpacck的世界中，其他任何资源都可以当做模块的方式引入 </p>
<p>代码分割：webapp 的优化关键在于代码体积，当应用体积增大，实现代码的按需加载是刚需，这也是 webpack 出现的根本原因 </p>
<p>可定制化：任何一个工具都不可能解决所有问题，提供解决方案才是最可行的，webpack基于可定制化的理念构建，通过插件系统，配置文件，可实现大型项目的定制需求</p>
<h3 id="♥︎-♥︎-♥︎-说说webpack的构建流程"><a href="#♥︎-♥︎-♥︎-说说webpack的构建流程" class="headerlink" title="♥︎ ♥︎ ♥︎ 说说webpack的构建流程?"></a>♥︎ ♥︎ ♥︎ 说说webpack的构建流程?</h3><h4 id="一、运行流程"><a href="#一、运行流程" class="headerlink" title="一、运行流程"></a>一、运行流程</h4><p><code>webpack</code> 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来</p>
<p>在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条<code>webpack</code>机制中，去改变<code>webpack</code>的运作，使得整个系统扩展性良好</p>
<p>从启动到结束会依次执行以下三大步骤：</p>
<ul>
<li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li>编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>
<li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li>
</ul>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62353636643430302d613635382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h5><p>从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数</p>
<p>配置文件默认下为<code>webpack.config.js</code>，也或者通过命令的形式指定配置文件，主要作用是用于激活<code>webpack</code>的加载项和插件</p>
<p>关于文件配置内容分析，如下注释：</p>
<pre><code class="javascript">var path = require(&#39;path&#39;);
var node_modules = path.resolve(__dirname, &#39;node_modules&#39;);
var pathToReact = path.resolve(node_modules, &#39;react/dist/react.min.js&#39;);

module.exports = &#123;
  // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。
  entry: &#39;./path/to/my/entry/file.js&#39;，
  // 文件路径指向(可加快打包过程)。
  resolve: &#123;
    alias: &#123;
      &#39;react&#39;: pathToReact
    &#125;
  &#125;,
  // 生成文件，是模块构建的终点，包括输出文件与输出路径。
  output: &#123;
    path: path.resolve(__dirname, &#39;build&#39;),
    filename: &#39;[name].js&#39;
  &#125;,
  // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。
  module: &#123;
    loaders: [
      &#123;
        test: /\.js$/,
        loader: &#39;babel&#39;,
        query: &#123;
          presets: [&#39;es2015&#39;, &#39;react&#39;]
        &#125;
      &#125;
    ],
    noParse: [pathToReact]
  &#125;,
  // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ]
&#125;;
webpack` 将 `webpack.config.js` 中的各个配置项拷贝到 `options` 对象中，并加载用户配置的 `plugins
</code></pre>
<p>完成上述步骤之后，则开始初始化<code>Compiler</code>编译对象，该对象掌控者<code>webpack</code>声明周期，不执行具体的任务，只是进行一些调度工作</p>
<pre><code class="javascript">class Compiler extends Tapable &#123;
    constructor(context) &#123;
        super();
        this.hooks = &#123;
            beforeCompile: new AsyncSeriesHook([&quot;params&quot;]),
            compile: new SyncHook([&quot;params&quot;]),
            afterCompile: new AsyncSeriesHook([&quot;compilation&quot;]),
            make: new AsyncParallelHook([&quot;compilation&quot;]),
            entryOption: new SyncBailHook([&quot;context&quot;, &quot;entry&quot;])
            // 定义了很多不同类型的钩子
        &#125;;
        // ...
    &#125;
&#125;

function webpack(options) &#123;
  var compiler = new Compiler();
  ...// 检查options,若watch字段为true,则开启watch线程
  return compiler;
&#125;
...
</code></pre>
<p><code>Compiler</code> 对象继承自 <code>Tapable</code>，初始化时定义了很多钩子函数</p>
<h5 id="编译构建流程"><a href="#编译构建流程" class="headerlink" title="编译构建流程"></a>编译构建流程</h5><p>根据配置中的 <code>entry</code> 找出所有的入口文件</p>
<pre><code class="javascript">module.exports = &#123;
  entry: &#39;./src/file.js&#39;
&#125;
</code></pre>
<p>初始化完成后会调用<code>Compiler</code>的<code>run</code>来真正启动<code>webpack</code>编译构建流程，主要流程如下：</p>
<ul>
<li><code>compile</code> 开始编译</li>
<li><code>make</code> 从入口点分析模块及其依赖的模块，创建这些模块对象</li>
<li><code>build-module</code> 构建模块</li>
<li><code>seal</code> 封装构建结果</li>
<li><code>emit</code> 把各个chunk输出到结果文件</li>
</ul>
<h5 id="compile-编译"><a href="#compile-编译" class="headerlink" title="compile 编译"></a>compile 编译</h5><p>执行了<code>run</code>方法后，首先会触发<code>compile</code>，主要是构建一个<code>Compilation</code>对象</p>
<p>该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象</p>
<h5 id="make-编译模块"><a href="#make-编译模块" class="headerlink" title="make 编译模块"></a>make 编译模块</h5><p>当完成了上述的<code>compilation</code>对象后，就开始从<code>Entry</code>入口文件开始读取，主要执行<code>_addModuleChain()</code>函数，如下：</p>
<pre><code class="javascript">_addModuleChain(context, dependency, onModule, callback) &#123;
   ...
   // 根据依赖查找对应的工厂函数
   const Dep = /** @type &#123;DepConstructor&#125; */ (dependency.constructor);
   const moduleFactory = this.dependencyFactories.get(Dep);
   
   // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象
   moduleFactory.create(&#123;
       dependencies: [dependency]
       ...
   &#125;, (err, module) =&gt; &#123;
       ...
       const afterBuild = () =&gt; &#123;
        this.processModuleDependencies(module, err =&gt; &#123;
         if (err) return callback(err);
         callback(null, module);
           &#125;);
    &#125;;
       
       this.buildModule(module, false, null, null, err =&gt; &#123;
           ...
           afterBuild();
       &#125;)
   &#125;)
&#125;
</code></pre>
<p>过程如下：</p>
<p><code>_addModuleChain</code>中接收参数<code>dependency</code>传入的入口依赖，使用对应的工厂函数<code>NormalModuleFactory.create</code>方法生成一个空的<code>module</code>对象</p>
<p>回调中会把此<code>module</code>存入<code>compilation.modules</code>对象和<code>dependencies.module</code>对象中，由于是入口文件，也会存入<code>compilation.entries</code>中</p>
<p>随后执行<code>buildModule</code>进入真正的构建模块<code>module</code>内容的过程</p>
<h5 id="build-module-完成模块编译"><a href="#build-module-完成模块编译" class="headerlink" title="build module 完成模块编译"></a>build module 完成模块编译</h5><p>这里主要调用配置的<code>loaders</code>，将我们的模块转成标准的<code>JS</code>模块</p>
<p>在用<code> Loader</code> 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 <code>Webpack </code>后面对代码的分析</p>
<p>从配置的入口模块开始，分析其 <code>AST</code>，当遇到<code>require</code>等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</p>
<h5 id="输出流程"><a href="#输出流程" class="headerlink" title="输出流程"></a>输出流程</h5><h5 id="seal-输出资源"><a href="#seal-输出资源" class="headerlink" title="seal 输出资源"></a>seal 输出资源</h5><p><code>seal</code>方法主要是要生成<code>chunks</code>，对<code>chunks</code>进行一系列的优化操作，并生成要输出的代码</p>
<p><code>webpack</code> 中的 <code>chunk</code> ，可以理解为配置在 <code>entry</code> 中的模块，或者是动态引入的模块</p>
<p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表</p>
<h5 id="emit-输出完成"><a href="#emit-输出完成" class="headerlink" title="emit 输出完成"></a>emit 输出完成</h5><p>在确定好输出内容后，根据配置确定输出的路径和文件名</p>
<pre><code class="javascript">output: &#123;
    path: path.resolve(__dirname, &#39;build&#39;),
        filename: &#39;[name].js&#39;
&#125;
</code></pre>
<p>在 <code>Compiler</code> 开始生成文件前，钩子 <code>emit</code> 会被执行，这是我们修改最终文件的最后一个机会</p>
<p>从而<code>webpack</code>整个打包过程则结束了</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64373766633536302d613635382d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-Loader和Plugin的区别"><a href="#♥︎-♥︎-♥︎-Loader和Plugin的区别" class="headerlink" title="♥︎ ♥︎ ♥︎  Loader和Plugin的区别"></a>♥︎ ♥︎ ♥︎  Loader和Plugin的区别</h3><h4 id="loader是一个转换器"><a href="#loader是一个转换器" class="headerlink" title="loader是一个转换器"></a>loader是一个转换器</h4><p>1、用于对模块源码文件的预编译和转换，，loader描述了webpack如何处理非javascript模块。</p>
<p>2、没有loader，构建的打包过程无法顺利完成</p>
<p>3、loader作用在打包前</p>
<p>4、将A文件转换为B文件，操作的是文件，比如将A.scss转换为A.css，是单纯的文件转换过程</p>
<h4 id="Plugin是插件扩展器"><a href="#Plugin是插件扩展器" class="headerlink" title="Plugin是插件扩展器"></a>Plugin是插件扩展器</h4><p>1、plugin构建过程更完整的补充和优化，如使用new UglifyJsPlugin(),new CssMinimizerPlugin()压缩js和css</p>
<p>2、没有plugin，文件的打包过程可以完成</p>
<p>3、plugin作用于整个打包过程，</p>
<p>4、针对webpack的打包过程，他不直接操作文件，而是基于事件机制工作，会监听webpack打包过程的事件钩子，执行任务，通过事件钩子拦截webpack的执行。</p>
<h3 id="♥︎-♥︎-♥︎-有哪些常见的Loader"><a href="#♥︎-♥︎-♥︎-有哪些常见的Loader" class="headerlink" title="♥︎ ♥︎ ♥︎ 有哪些常见的Loader"></a>♥︎ ♥︎ ♥︎ 有哪些常见的Loader</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>loader</code> 用于对模块的”源代码”进行转换，在 <code>import</code> 或”加载”模块时预处理文件</p>
<p><code>webpack</code>做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。如下图所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37623864393634302d613666662d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>在<code>webpack</code>内部中，任何文件都是模块，不仅仅只是<code>js</code>文件</p>
<p>默认情况下，在遇到<code>import</code>或者<code>load</code>加载模块的时候，<code>webpack</code>只支持对<code>js</code>文件打包</p>
<p>像<code>css</code>、<code>sass</code>、<code>png</code>等这些类型的文件的时候，<code>webpack</code>则无能为力，这时候就需要配置对应的<code>loader</code>进行文件内容的解析</p>
<p>在加载模块的时候，执行顺序如下：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39633263343362302d613666662d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>当 <code>webpack</code> 碰到不识别的模块的时候，<code>webpack</code> 会在配置的中查找该文件解析规则</p>
<p>关于配置<code>loader</code>的方式有三种：</p>
<ul>
<li>配置方式（推荐）：在 webpack.config.js文件中指定 loader</li>
<li>内联方式：在每个 import 语句中显式指定 loader</li>
<li>CLI 方式：在 shell 命令中指定它们</li>
</ul>
<h5 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h5><p>关于<code>loader</code>的配置，我们是写在<code>module.rules</code>属性中，属性介绍如下：</p>
<ul>
<li><code>rules</code>是一个数组的形式，因此我们可以配置很多个<code>loader</code></li>
<li>每一个<code>loader</code>对应一个对象的形式，对象属性<code>test</code> 为匹配的规则，一般情况为正则表达式</li>
<li>属性<code>use</code>针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</li>
</ul>
<p>代码编写，如下形式：</p>
<pre><code class="javascript">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        test: /\.css$/,
        use: [
          &#123; loader: &#39;style-loader&#39; &#125;,
          &#123;
            loader: &#39;css-loader&#39;,
            options: &#123;
              modules: true
            &#125;
          &#125;,
          &#123; loader: &#39;sass-loader&#39; &#125;
        ]
      &#125;
    ]
  &#125;
&#125;;
</code></pre>
<h4 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h4><p>这里继续拿上述代码，来讲讲<code>loader</code>的特性</p>
<p>从上述代码可以看到，在处理<code>css</code>模块的时候，<code>use</code>属性中配置了三个<code>loader</code>分别处理<code>css</code>文件</p>
<p>因为<code>loader </code>支持链式调用，链中的每个<code>loader</code>会处理之前已处理过的资源，最终变为<code>js</code>代码。顺序为相反的顺序执行，即上述执行方式为<code>sass-loader</code>、<code>css-loader</code>、<code>style-loader</code></p>
<p>除此之外，<code>loader</code>的特性还有如下：</p>
<ul>
<li>loader 可以是同步的，也可以是异步的</li>
<li>loader 运行在 Node.js 中，并且能够执行任何操作</li>
<li>除了常见的通过 <code>package.json</code> 的 <code>main</code> 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 <code>loader</code> 字段直接引用一个模块</li>
<li>插件(plugin)可以为 loader 带来更多特性</li>
<li>loader 能够产生额外的任意文件</li>
</ul>
<p>可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和更多其他特性</p>
<h4 id="三、常见的loader"><a href="#三、常见的loader" class="headerlink" title="三、常见的loader"></a>三、常见的loader</h4><p>在页面开发过程中，我们经常性加载除了<code>js</code>文件以外的内容，这时候我们就需要配置响应的<code>loader</code>进行加载</p>
<p>常见的<code>loader</code>如下：</p>
<ul>
<li>style-loader: 将css添加到DOM的内联样式标签style里</li>
<li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li>
<li>less-loader: 处理less</li>
<li>sass-loader: 处理sass</li>
<li>postcss-loader: 用postcss来处理CSS</li>
<li>autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss</li>
<li>file-loader: 分发文件到output目录并返回相对路径</li>
<li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li>
<li>html-minify-loader: 压缩HTML</li>
<li>babel-loader :用babel来转换ES6文件到ES</li>
</ul>
<p>下面给出一些常见的<code>loader</code>的使用：</p>
<h5 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h5><p>分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p>
<pre><code class="javascript">npm install --save-dev css-loader
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: &#123;
      loader: &quot;css-loader&quot;,
      options: &#123;
     // 启用/禁用 url() 处理
     url: true,
     // 启用/禁用 @import 处理
     import: true,
        // 启用/禁用 Sourcemap
        sourceMap: false
      &#125;
    &#125;
 &#125;
]
</code></pre>
<p>如果只通过<code>css-loader</code>加载文件，这时候页面代码设置的样式并没有生效</p>
<p>原因在于，<code>css-loader</code>只是负责将<code>.css</code>文件进行一个解析，而并不会将解析后的<code>css</code>插入到页面中</p>
<p>如果我们希望再完成插入<code>style</code>的操作，那么我们还需要另外一个<code>loader</code>，就是<code>style-loader</code></p>
<h5 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h5><p>把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到页面的 <code>head</code> 中</p>
<pre><code class="javascript">npm install --save-dev style-loader
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;]
 &#125;
]
</code></pre>
<p>同一个任务的 <code>loader</code> 可以同时挂载多个，处理顺序为：从右到左，从下往上</p>
<h5 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h5><p>开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高，这里需要使用<code>less-loader</code></p>
<pre><code class="javascript">npm install less-loader -D
rules: [
  ...,
 &#123;
  test: /\.css$/,
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;,&quot;less-loader&quot;]
 &#125;
]
</code></pre>
<h5 id="raw-loader"><a href="#raw-loader" class="headerlink" title="raw-loader"></a>raw-loader</h5><p>在 <code>webpack </code>中通过 <code>import </code>方式导入文件内容，该<code>loader </code>并不是内置的，所以首先要安装</p>
<pre><code class="shell">npm install --save-dev raw-loader
</code></pre>
<p>然后在 webpack.config.js 中进行配置</p>
<pre><code class="javascript">module.exports = &#123;  
...,  
module: &#123;      
rules: [      
&#123;        
test: /\.(txt|md)$/,  
use: &#39;raw-loader&#39;   
&#125;   
] &#125;&#125;
</code></pre>
<h5 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h5><p>把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串)</p>
<pre><code class="javascript">npm install --save-dev file-loader
rules: [  ..., &#123;  
test: /\.(png|jpe?g|gif)$/,    
use: &#123;      
loader: &quot;file-loader&quot;,  
options: &#123;       
// placeholder 占位符 [name] 源资源模块的名称        
// [ext] 源资源模块的后缀       
name: &quot;[name]_[hash].[ext]&quot;,        //打包后的存放位置        
outputPath: &quot;./images&quot;,        // 打包后文件的 url        
publicPath: &#39;./images&#39;,      &#125;    &#125; &#125;]
</code></pre>
<h5 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h5><p>可以处理理 <code>file-loader</code> 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code> 格式的字符串，并打包到 <code>js</code> 中，对小体积的图片比较合适，大图片不合适。</p>
<pre><code class="javascript">npm install --save-dev url-loader
rules: [  ..., &#123;  
        test: /\.(png|jpe?g|gif)$/,    
        use: &#123;     
        loader: &quot;url-loader&quot;,      
        options: &#123;        
        // placeholder 占位符 [name] 源资源模块的名称        
        // [ext] 源资源模块的后缀        
        name: &quot;[name]_[hash].[ext]&quot;,        //打包后的存放位置        
        outputPath: &quot;./images&quot;        // 打包后文件的 url        
        publicPath: &#39;./images&#39;,        // 小于 100 字节转成 base64 格式        limit: 100      &#125;    &#125; &#125;]
</code></pre>
<h3 id="♥︎-♥︎-♥︎-有哪些常见的Plugin"><a href="#♥︎-♥︎-♥︎-有哪些常见的Plugin" class="headerlink" title="♥︎ ♥︎ ♥︎ 有哪些常见的Plugin"></a>♥︎ ♥︎ ♥︎ 有哪些常见的Plugin</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>Plugin</code>（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能</p>
<p>是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据</p>
<p><code>webpack</code>中的<code>plugin</code>也是如此，<code>plugin</code>赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 <code>webpack</code> 的不同阶段（钩子 &#x2F; 生命周期），贯穿了<code>webpack</code>整个编译周期</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39613034656334302d613763322d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<p>目的在于解决<code>loader</code> 无法实现的其他事</p>
<h5 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h5><p>这里讲述文件的配置方式，一般情况，通过配置文件导出对象中<code>plugins</code>属性传入<code>new</code>实例对象。如下所示：</p>
<pre><code class="javascript">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); // 通过 npm 安装
const webpack = require(&#39;webpack&#39;); // 访问内置的插件
module.exports = &#123;
  ...
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin(&#123; template: &#39;./src/index.html&#39; &#125;),
  ],
&#125;;
</code></pre>
<h4 id="二、特性-1"><a href="#二、特性-1" class="headerlink" title="二、特性"></a>二、特性</h4><p>其本质是一个具有<code>apply</code>方法<code>javascript</code>对象</p>
<p><code>apply</code> 方法会被 <code>webpack compiler </code>调用，并且在整个编译生命周期都可以访问 <code>compiler </code>对象</p>
<pre><code class="javascript">const pluginName = &#39;ConsoleLogOnBuildWebpackPlugin&#39;;

class ConsoleLogOnBuildWebpackPlugin &#123;
  apply(compiler) &#123;
    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;
      console.log(&#39;webpack 构建过程开始！&#39;);
    &#125;);
  &#125;
&#125;

module.exports = ConsoleLogOnBuildWebpackPlugin;
</code></pre>
<p><code>compiler hook</code> 的 <code>tap </code>方法的第一个参数，应是驼峰式命名的插件名称</p>
<p>关于整个编译生命周期钩子，有如下：</p>
<ul>
<li>entry-option ：初始化 option</li>
<li>run</li>
<li>compile： 真正开始的编译，在创建 compilation 对象之前</li>
<li>compilation ：生成好了 compilation 对象</li>
<li>make 从 entry 开始递归分析依赖，准备对每个模块进行 build</li>
<li>after-compile： 编译 build 过程结束</li>
<li>emit ：在将内存中 assets 内容写到磁盘文件夹之前</li>
<li>after-emit ：在将内存中 assets 内容写到磁盘文件夹之后</li>
<li>done： 完成所有的编译过程</li>
<li>failed： 编译失败的时候</li>
</ul>
<h4 id="三、常见的Plugin"><a href="#三、常见的Plugin" class="headerlink" title="三、常见的Plugin"></a>三、常见的Plugin</h4><p>常见的<code>plugin</code>有如图所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643734393430302d613763322d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>下面介绍几个常用的插件用法：</p>
<h5 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h5><p>在打包结束后，⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code> js</code> 模块引⼊到该 <code>html</code> 中</p>
<pre><code class="javascript">npm install --save-dev html-webpack-plugin
// webpack.config.js
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
module.exports = &#123;
 ...
  plugins: [
     new HtmlWebpackPlugin(&#123;
       title: &quot;My App&quot;,
       filename: &quot;app.html&quot;,
       template: &quot;./src/html/index.html&quot;
     &#125;) 
  ]
&#125;;
&lt;!--./src/html/index.html--&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;%=htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;html-webpack-plugin&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在 <code>html</code> 模板中，可以通过 <code>&lt;%=htmlWebpackPlugin.options.XXX%&gt;</code> 的方式获取配置的值</p>
<p>更多的配置可以自寻查找</p>
<h5 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h5><p>删除（清理）构建目录</p>
<pre><code class="javascript">npm install --save-dev clean-webpack-plugin
const &#123;CleanWebpackPlugin&#125; = require(&#39;clean-webpack-plugin&#39;);
module.exports = &#123;
 ...
  plugins: [
    ...,
    new CleanWebpackPlugin(),
    ...
  ]
&#125;
</code></pre>
<h5 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h5><p>提取 <code>CSS</code> 到一个单独的文件中</p>
<pre><code class="javascript">npm install --save-dev mini-css-extract-plugin
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
module.exports = &#123; ...,  
                  module: &#123;   
                  rules: [    
                  &#123;     test: /\.s[ac]ss$/,     
                  use: [     
                  &#123;      loader: MiniCssExtractPlugin.loader     &#125;,          
  &#39;css-loader&#39;,          &#39;sass-loader&#39;        ]   &#125;   ] &#125;,  
    plugins: [    ...,    
              new MiniCssExtractPlugin(&#123;     filename: &#39;[name].css&#39;    &#125;),    ...  ]&#125;
</code></pre>
<h5 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h5><p>允许在编译时创建配置的全局对象，是一个<code>webpack</code>内置的插件，不需要安装</p>
<pre><code class="javascript">const &#123; DefinePlugun &#125; = require(&#39;webpack&#39;)module.exports = &#123; ...    plugins:[        new DefinePlugin(&#123;            BASE_URL:&#39;&quot;./&quot;&#39;        &#125;)    ]&#125;
</code></pre>
<p>这时候编译<code>template</code>模块的时候，就能通过下述形式获取全局对象</p>
<pre><code class="javascript">&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL%&gt;favicon.ico&gt;&quot;
</code></pre>
<h5 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h5><p>复制文件或目录到执行区域，如<code>vue</code>的打包过程中，如果我们将一些文件放到<code>public</code>的目录下，那么这个目录会被复制到<code>dist</code>文件夹中</p>
<pre><code class="javascript">npm install copy-webpack-plugin -D
new CopyWebpackPlugin(&#123;    parrerns:[        &#123;            
  from:&quot;public&quot;,            
  globOptions:&#123;                i
               gnore:[                    &#39;**/index.html&#39;                ]            &#125;        &#125;    ]&#125;)
</code></pre>
<p>复制的规则在<code>patterns</code>属性中设置：</p>
<ul>
<li>from：设置从哪一个源中开始复制</li>
<li>to：复制到的位置，可以省略，会默认复制到打包的目录下</li>
<li>globOptions：设置一些额外的选项，其中可以编写需要忽略的文件</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-说一下-Webpack-的热更新原理"><a href="#♥︎-♥︎-♥︎-说一下-Webpack-的热更新原理" class="headerlink" title="♥︎ ♥︎ ♥︎ 说一下 Webpack 的热更新原理"></a>♥︎ ♥︎ ♥︎ 说一下 Webpack 的热更新原理</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>HMR </code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</p>
<p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失</p>
<p>如果使用的是 <code>HMR</code>，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用</p>
<p>在<code>webpack</code>中配置开启热模块也非常的简单，如下代码：</p>
<pre><code class="javascript">const webpack = require(&#39;webpack&#39;)
module.exports = &#123;
  // ...
  devServer: &#123;
    // 开启 HMR 特性
    hot: true
    // hotOnly: true
  &#125;
&#125;
</code></pre>
<p>通过上述这种配置，如果我们修改并保存<code>css</code>文件，确实能够以不刷新的形式更新到页面中</p>
<p>但是，当我们修改并保存<code>js</code>文件之后，页面依旧自动刷新了，这里并没有触发热模块</p>
<p>所以，<code>HMR </code>并不像 <code>Webpack</code> 的其他特性一样可以开箱即用，需要有一些额外的操作</p>
<p>我们需要去指定哪些模块发生更新时进行<code>HRM</code>，如下代码：</p>
<pre><code class="javascript">if(module.hot)&#123;
    module.hot.accept(&#39;./util.js&#39;,()=&gt;&#123;
        console.log(&quot;util.js更新了&quot;)
    &#125;)
&#125;
</code></pre>
<h4 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h4><p>首先来看看一张图，如下：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61646330353738302d616364342d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<ul>
<li>Webpack Compile：将 JS 源代码编译成 bundle.js</li>
<li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li>
<li>Bundle Server：静态资源文件服务器，提供文件访问路径</li>
<li>HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化</li>
<li>bundle.js：构建输出的文件</li>
<li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li>
</ul>
<p>上面图中，可以分成两个阶段：</p>
<ul>
<li>启动阶段为上图 1 - 2 - A - B</li>
</ul>
<p>在编写未经过<code>webpack</code>打包的源代码后，<code>Webpack Compile</code> 将源代码和 <code>HMR Runtime</code> 一起编译成 <code>bundle </code>文件，传输给<code> Bundle Server</code> 静态资源服务器</p>
<ul>
<li>更新阶段为上图 1 - 2 - 3 - 4</li>
</ul>
<p>当某一个文件或者模块发生变化时，<code>webpack </code>监听到文件变化对文件重新编译打包，编译生成唯一的<code>hash</code>值，这个<code>hash </code>值用来作为下一次热更新的标识</p>
<p>根据变化的内容生成两个补丁文件：<code>manifest</code>（包含了 <code>hash</code> 和 <code>chundId </code>，用来说明变化的内容）和<code> chunk.js</code> 模块</p>
<p>由于<code>socket</code>服务器在<code>HMR Runtime</code> 和 <code>HMR Server</code>之间建立 <code>websocket</code>链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的<code>hash</code>值，如下图的<code>h</code>属性，作为下一次热更细的标识</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30356130656466302d616434612d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在浏览器接受到这条消息之前，浏览器已经在上一次<code> socket</code> 消息中已经记住了此时的<code> hash</code> 标识，这时候我们会创建一个 <code>ajax</code> 去服务端请求获取到变化内容的 <code>manifest</code> 文件</p>
<p><code>mainfest</code>文件包含重新<code>build</code>生成的<code>hash</code>值，以及变化的模块，对应上图的<code>c</code>属性</p>
<p>浏览器根据 <code>manifest</code> 文件获取模块变化的内容，从而触发<code>render</code>流程，实现局部模块更新</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30653762373835302d616434612d313165622d616239302d6439616538313462323430642e706e67.png"></p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>关于<code>webpack</code>热模块更新的总结如下：</p>
<ul>
<li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li>
<li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li>
<li>socket server 是一个 websocket 的长连接，双方可以通信</li>
<li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li>
<li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li>
<li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-如何优化-Webpack-的构建速度"><a href="#♥︎-♥︎-♥︎-如何优化-Webpack-的构建速度" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何优化 Webpack 的构建速度"></a>♥︎ ♥︎ ♥︎ 如何优化 Webpack 的构建速度</h3><h4 id="一、背景-1"><a href="#一、背景-1" class="headerlink" title="一、背景"></a>一、背景</h4><p>随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 <code>webpack</code> 的构建时间也会越来越久</p>
<p>构建时间与我们日常开发效率密切相关，当我们本地开发启动 <code>devServer</code> 或者 <code>build</code> 的时候，如果时间过长，会大大降低我们的工作效率</p>
<p>所以，优化<code>webpack</code> 构建速度是十分重要的环节</p>
<h4 id="二、如何优化"><a href="#二、如何优化" class="headerlink" title="二、如何优化"></a>二、如何优化</h4><p>常见的提升构建速度的手段有如下：</p>
<ul>
<li>优化 loader 配置</li>
<li>合理使用 resolve.extensions</li>
<li>优化 resolve.modules</li>
<li>优化 resolve.alias</li>
<li>使用 DLLPlugin 插件</li>
<li>使用 cache-loader</li>
<li>terser 启动多线程</li>
<li>合理使用 sourceMap</li>
</ul>
<h5 id="优化loader配置"><a href="#优化loader配置" class="headerlink" title="优化loader配置"></a>优化loader配置</h5><p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件，接触<code>include</code>、<code>exclude</code>规定哪些匹配应用<code>loader</code></p>
<p>如采用 ES6 的项目为例，在配置 <code>babel-loader </code>时，可以这样：</p>
<pre><code class="javascript">module.exports = &#123;
  module: &#123;
    rules: [
      &#123;
        // 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能
        test: /\.js$/,
        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启
        use: [&#39;babel-loader?cacheDirectory&#39;],
        // 只对项目根目录下的 src 目录中的文件采用 babel-loader
        include: path.resolve(__dirname, &#39;src&#39;),
      &#125;,
    ]
  &#125;,
&#125;;
</code></pre>
<h5 id="合理使用-resolve-extensions"><a href="#合理使用-resolve-extensions" class="headerlink" title="合理使用 resolve.extensions"></a>合理使用 resolve.extensions</h5><p>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， <code>resolve</code>可以帮助<code>webpack</code>从每个 <code>require/import</code> 语句中，找到需要引入到合适的模块代码</p>
<p>通过<code>resolve.extensions</code>是解析到文件时自动添加拓展名，默认情况如下：</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    extensions:[&quot;.warm&quot;,&quot;.mjs&quot;,&quot;.js&quot;,&quot;.json&quot;]
&#125;
</code></pre>
<p>当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找</p>
<p>当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度</p>
<h5 id="优化-resolve-modules"><a href="#优化-resolve-modules" class="headerlink" title="优化 resolve.modules"></a>优化 resolve.modules</h5><p><code>resolve.modules</code> 用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。默认值为<code>[&#39;node_modules&#39;]</code>，所以默认会从<code>node_modules</code>中查找文件<br>当安装的第三方模块都放在项目根目录下的 <code>./node_modules </code>目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p>
<pre><code class="javascript">module.exports = &#123;
  resolve: &#123;
    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤
    // 其中 __dirname 表示当前工作目录，也就是项目根目录
    modules: [path.resolve(__dirname, &#39;node_modules&#39;)]
  &#125;,
&#125;;
</code></pre>
<h5 id="优化-resolve-alias"><a href="#优化-resolve-alias" class="headerlink" title="优化 resolve.alias"></a>优化 resolve.alias</h5><p><code>alias</code>给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式</p>
<p>通过配置<code>alias</code>以减少查找过程</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    resolve:&#123;
        alias:&#123;
            &quot;@&quot;:path.resolve(__dirname,&#39;./src&#39;)
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="使用-DLLPlugin-插件"><a href="#使用-DLLPlugin-插件" class="headerlink" title="使用 DLLPlugin 插件"></a>使用 DLLPlugin 插件</h5><p><code>DLL</code>全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中</p>
<p>使用步骤分成两部分：</p>
<ul>
<li>打包一个 DLL 库</li>
<li>引入 DLL 库</li>
</ul>
<h6 id="打包一个-DLL-库"><a href="#打包一个-DLL-库" class="headerlink" title="打包一个 DLL 库"></a>打包一个 DLL 库</h6><p><code>webpack</code>内置了一个<code>DllPlugin</code>可以帮助我们打包一个DLL的库文件</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    plugins:[
        new webpack.DllPlugin(&#123;
            name:&#39;dll_[name]&#39;,
            path:path.resolve(__dirname,&quot;./dll/[name].mainfest.json&quot;)
        &#125;)
    ]
&#125;
</code></pre>
<h6 id="引入-DLL-库"><a href="#引入-DLL-库" class="headerlink" title="引入 DLL 库"></a>引入 DLL 库</h6><p>使用 <code>webpack</code> 自带的 <code>DllReferencePlugin</code> 插件对 <code>mainfest.json</code> 映射文件进行分析，获取要使用的<code>DLL</code>库</p>
<p>然后再通过<code>AddAssetHtmlPlugin</code>插件，将我们打包的<code>DLL</code>库引入到<code>Html</code>模块中</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    new webpack.DllReferencePlugin(&#123;
        context:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;),
        mainfest:path.resolve(__dirname,&quot;./dll/react.mainfest.json&quot;)
    &#125;),
    new AddAssetHtmlPlugin(&#123;
        outputPath:&quot;./auto&quot;,
        filepath:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;)
    &#125;)
&#125;
</code></pre>
<h5 id="使用-cache-loader"><a href="#使用-cache-loader" class="headerlink" title="使用 cache-loader"></a>使用 cache-loader</h5><p>在一些性能开销较大的 <code>loader </code>之前添加 <code>cache-loader</code>，以将结果缓存到磁盘里，显著提升二次构建速度</p>
<p>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code> loader</code></p>
<pre><code class="javascript">module.exports = &#123;
    module: &#123;
        rules: [
            &#123;
                test: /\.ext$/,
                use: [&#39;cache-loader&#39;, ...loaders],
                include: path.resolve(&#39;src&#39;),
            &#125;,
        ],
    &#125;,
&#125;;
</code></pre>
<h5 id="terser-启动多线程"><a href="#terser-启动多线程" class="headerlink" title="terser 启动多线程"></a>terser 启动多线程</h5><p>使用多进程并行运行来提高构建速度</p>
<pre><code class="javascript">module.exports = &#123;
  optimization: &#123;
    minimizer: [
      new TerserPlugin(&#123;
        parallel: true,
      &#125;),
    ],
  &#125;,
&#125;;
</code></pre>
<h5 id="合理使用-sourceMap"><a href="#合理使用-sourceMap" class="headerlink" title="合理使用 sourceMap"></a>合理使用 sourceMap</h5><p>打包生成 <code>sourceMap</code> 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31313634376166302d623031642d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，优化<code>webpack</code>构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手</p>
<h3 id="♥︎-♥︎-♥︎-自己写过Loader和Plugin么"><a href="#♥︎-♥︎-♥︎-自己写过Loader和Plugin么" class="headerlink" title="♥︎ ♥︎ ♥︎ 自己写过Loader和Plugin么"></a>♥︎ ♥︎ ♥︎ 自己写过Loader和Plugin么</h3><h4 id="一、编写loader"><a href="#一、编写loader" class="headerlink" title="一、编写loader"></a>一、编写loader</h4><p>在编写 <code>loader</code> 前，我们首先需要了解 <code>loader</code> 的本质</p>
<p>其本质为函数，函数中的 <code>this</code> 作为上下文会被 <code>webpack</code> 填充，因此我们不能将 <code>loader</code>设为一个箭头函数</p>
<p>函数接受一个参数，为 <code>webpack</code> 传递给 <code>loader</code> 的文件源内容</p>
<p>函数中 <code>this</code> 是由 <code>webpack</code> 提供的对象，能够获取当前 <code>loader</code> 所需要的各种信息</p>
<p>函数中有异步操作或同步操作，异步操作通过 <code>this.callback</code> 返回，返回值要求为 <code>string</code> 或者 <code>Buffer</code></p>
<p>代码如下所示：</p>
<pre><code class="javascript">// 导出一个函数，source为webpack传递给loader的文件源内容
module.exports = function(source) &#123;
    const content = doSomeThing2JsString(source);
    
    // 如果 loader 配置了 options 对象，那么this.query将指向 options
    const options = this.query;
    
    // 可以用作解析其他模块路径的上下文
    console.log(&#39;this.context&#39;);
    
    /*
     * this.callback 参数：
     * error：Error | null，当 loader 出错时向外抛出一个 error
     * content：String | Buffer，经过 loader 编译后需要导出的内容
     * sourceMap：为方便调试生成的编译后内容的 source map
     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程
     */
    this.callback(null, content); // 异步
    return content; // 同步
&#125;
</code></pre>
<p>一般在编写<code>loader</code>的过程中，保持功能单一，避免做多种功能</p>
<p>如<code>less</code>文件转换成 <code>css </code>文件也不是一步到位，而是 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code>几个 <code>loader </code>的链式调用才能完成转换</p>
<h4 id="二、编写plugin"><a href="#二、编写plugin" class="headerlink" title="二、编写plugin"></a>二、编写plugin</h4><p>由于<code>webpack</code>基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务</p>
<p>在之前也了解过，<code>webpack</code>编译会创建两个核心对象：</p>
<ul>
<li>compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子</li>
<li>compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建</li>
</ul>
<p>如果自己要实现<code>plugin</code>，也需要遵循一定的规范：</p>
<ul>
<li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例</li>
<li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，因此不建议修改</li>
<li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住</li>
</ul>
<p>实现<code>plugin</code>的模板如下：</p>
<pre><code class="javascript">class MyPlugin &#123;
    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象
  apply (compiler) &#123;
    // 找到合适的事件钩子，实现自己的插件功能
    compiler.hooks.emit.tap(&#39;MyPlugin&#39;, compilation =&gt; &#123;
        // compilation: 当前打包构建流程的上下文
        console.log(compilation);
        
        // do something...
    &#125;)
  &#125;
&#125;
</code></pre>
<p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容</p>
<h4 id="三、手写一个loader和plugin"><a href="#三、手写一个loader和plugin" class="headerlink" title="三、手写一个loader和plugin"></a>三、手写一个loader和plugin</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903689442820110">手写一个loader和plugin</a></p>
<h3 id="♥︎-♥︎-♥︎-webpack-proxy工作原理？为什么能解决跨域"><a href="#♥︎-♥︎-♥︎-webpack-proxy工作原理？为什么能解决跨域" class="headerlink" title="♥︎ ♥︎ ♥︎ webpack proxy工作原理？为什么能解决跨域?"></a>♥︎ ♥︎ ♥︎ webpack proxy工作原理？为什么能解决跨域?</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p>
<p>基本行为就是接收客户端发送的请求后转发给其他服务器</p>
<p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p>
<p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p>
<h5 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h5><p><code>webpack-dev-server</code>是 <code>webpack</code> 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起</p>
<p>目的是为了提高开发者日常的开发效率，只适用在开发阶段</p>
<p>关于配置方面，在<code>webpack</code>配置对象属性中通过<code>devServer</code>属性提供，如下：</p>
<pre><code class="javascript">// ./webpack.config.js
const path = require(&#39;path&#39;)

module.exports = &#123;
    // ...
    devServer: &#123;
        contentBase: path.join(__dirname, &#39;dist&#39;),
        compress: true,
        port: 9000,
        proxy: &#123;
            &#39;/api&#39;: &#123;
                target: &#39;https://api.github.com&#39;
            &#125;
        &#125;
        // ...
    &#125;
&#125;
</code></pre>
<p><code>devServetr</code>里面<code>proxy</code>则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p>
<p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为<code> /api</code>，值为对应的代理匹配规则，对应如下：</p>
<ul>
<li>target：表示的是代理到的目标地址</li>
<li>pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite</li>
<li>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false</li>
<li>changeOrigin：它表示是否更新代理后请求的 headers 中host地址</li>
</ul>
<h4 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h4><p><code>proxy</code>工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器</p>
<p>举个例子：</p>
<p>在开发阶段，本地地址为<code>http://localhost:3000</code>，该浏览器发送一个前缀带有<code>/api</code>标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p>
<pre><code class="javascript">const express = require(&#39;express&#39;);
const proxy = require(&#39;http-proxy-middleware&#39;);

const app = express();

app.use(&#39;/api&#39;, proxy(&#123;target: &#39;http://www.example.org&#39;, changeOrigin: true&#125;));
app.listen(3000);

// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar
</code></pre>
<h4 id="三、跨域"><a href="#三、跨域" class="headerlink" title="三、跨域"></a>三、跨域</h4><p>在开发阶段， <code>webpack-dev-server</code> 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 <code>localhost </code>的一个端口上，而后端服务又是运行在另外一个地址上</p>
<p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p>
<p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p>
<p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36356235653563302d616365352d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据</p>
<p>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</p>
<h3 id="♥︎-♥︎-♥︎-如何借助webpack来优化前端性能？"><a href="#♥︎-♥︎-♥︎-如何借助webpack来优化前端性能？" class="headerlink" title="♥︎ ♥︎ ♥︎ 如何借助webpack来优化前端性能？"></a>♥︎ ♥︎ ♥︎ 如何借助webpack来优化前端性能？</h3><h4 id="一、背景-2"><a href="#一、背景-2" class="headerlink" title="一、背景"></a>一、背景</h4><p>随着前端的项目逐渐扩大，必然会带来的一个问题就是性能</p>
<p>尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃</p>
<p>一般项目在完成后，会通过<code>webpack</code>进行打包，利用<code>webpack</code>对前端项目性能优化是一个十分重要的环节</p>
<h4 id="二、如何优化-1"><a href="#二、如何优化-1" class="headerlink" title="二、如何优化"></a>二、如何优化</h4><p>通过<code>webpack</code>优化前端的手段有：</p>
<ul>
<li>JS代码压缩</li>
<li>CSS代码压缩</li>
<li>Html文件代码压缩</li>
<li>文件大小压缩</li>
<li>图片压缩</li>
<li>Tree Shaking</li>
<li>代码分离</li>
<li>内联 chunk</li>
</ul>
<h5 id="JS代码压缩"><a href="#JS代码压缩" class="headerlink" title="JS代码压缩"></a>JS代码压缩</h5><p><code>terser</code>是一个<code>JavaScript</code>的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让<code>bundle</code>更小</p>
<p>在<code>production</code>模式下，<code>webpack</code> 默认就是使用 <code>TerserPlugin</code> 来处理我们的代码的。如果想要自定义配置它，配置方法如下：</p>
<pre><code class="javascript">const TerserPlugin = require(&#39;terser-webpack-plugin&#39;)
module.exports = &#123;
    ...
    optimization: &#123;
        minimize: true,
        minimizer: [
            new TerserPlugin(&#123;
                parallel: true // 电脑cpu核数-1
            &#125;)
        ]
    &#125;
&#125;
</code></pre>
<p>属性介绍如下：</p>
<ul>
<li>extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释</li>
<li>parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1</li>
<li>terserOptions：设置我们的terser相关的配置：<ul>
<li>compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true</li>
<li>mangle：设置丑化相关的选项，可以直接设置为true</li>
<li>toplevel：底层变量是否进行转换</li>
<li>keep_classnames：保留类的名称</li>
<li>keep_fnames：保留函数的名称</li>
</ul>
</li>
</ul>
<h5 id="CSS代码压缩"><a href="#CSS代码压缩" class="headerlink" title="CSS代码压缩"></a>CSS代码压缩</h5><p><code>CSS</code>压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等</p>
<p>CSS的压缩我们可以使用另外一个插件：<code>css-minimizer-webpack-plugin</code></p>
<pre><code class="ini">npm install css-minimizer-webpack-plugin -D
</code></pre>
<p>配置方法如下：</p>
<pre><code class="javascript">const CssMinimizerPlugin = require(&#39;css-minimizer-webpack-plugin&#39;)
module.exports = &#123;
    // ...
    optimization: &#123;
        minimize: true,
        minimizer: [
            new CssMinimizerPlugin(&#123;
                parallel: true
            &#125;)
        ]
    &#125;
&#125;
</code></pre>
<h5 id="Html文件代码压缩"><a href="#Html文件代码压缩" class="headerlink" title="Html文件代码压缩"></a>Html文件代码压缩</h5><p>使用<code>HtmlWebpackPlugin</code>插件来生成<code>HTML</code>的模板时候，通过配置属性<code>minify</code>进行<code>html</code>优化</p>
<pre><code class="javascript">module.exports = &#123;
    ...
    plugin:[
        new HtmlwebpackPlugin(&#123;
            ...
            minify:&#123;
                minifyCSS:false, // 是否压缩css
                collapseWhitespace:false, // 是否折叠空格
                removeComments:true // 是否移除注释
            &#125;
        &#125;)
    ]
&#125;
</code></pre>
<p>设置了<code>minify</code>，实际会使用另一个插件<code>html-minifier-terser</code></p>
<h5 id="文件大小压缩"><a href="#文件大小压缩" class="headerlink" title="文件大小压缩"></a>文件大小压缩</h5><p>对文件的大小进行压缩，减少<code>http</code>传输过程中宽带的损耗</p>
<pre><code class="javascript">npm install compression-webpack-plugin -D
new ComepressionPlugin(&#123;
    test:/\.(css|js)$/,  // 哪些文件需要压缩
    threshold:500, // 设置文件多大开始压缩
    minRatio:0.7, // 至少压缩的比例
    algorithm:&quot;gzip&quot;, // 采用的压缩算法
&#125;)
</code></pre>
<h5 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h5><p>一般来说在打包之后，一些图片文件的大小是远远要比 <code>js</code> 或者 <code>css</code> 文件要来的大，所以图片压缩较为重要</p>
<p>配置方法如下：</p>
<pre><code class="javascript">module: &#123;
  rules: [
    &#123;
      test: /\.(png|jpg|gif)$/,
      use: [
        &#123;
          loader: &#39;file-loader&#39;,
          options: &#123;
            name: &#39;[name]_[hash].[ext]&#39;,
            outputPath: &#39;images/&#39;,
          &#125;
        &#125;,
        &#123;
          loader: &#39;image-webpack-loader&#39;,
          options: &#123;
            // 压缩 jpeg 的配置
            mozjpeg: &#123;
              progressive: true,
              quality: 65
            &#125;,
            // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭
            optipng: &#123;
              enabled: false,
            &#125;,
            // 使用 imagemin-pngquant 压缩 png
            pngquant: &#123;
              quality: &#39;65-90&#39;,
              speed: 4
            &#125;,
            // 压缩 gif 的配置
            gifsicle: &#123;
              interlaced: false,
            &#125;,
            // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式
            webp: &#123;
              quality: 75
            &#125;
          &#125;
        &#125;
      ]
    &#125;,
  ]
&#125; 
</code></pre>
<h5 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h5><p><code>Tree Shaking</code> 是一个术语，在计算机中表示消除死代码，依赖于<code>ES Module</code>的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）</p>
<p>在<code>webpack</code>实现<code>Trss shaking</code>有两种不同的方案：</p>
<ul>
<li>usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的</li>
<li>sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用</li>
</ul>
<p>两种不同的配置方案， 有不同的效果</p>
<h5 id="usedExports"><a href="#usedExports" class="headerlink" title="usedExports"></a>usedExports</h5><p>配置方法也很简单，只需要将<code>usedExports</code>设为<code>true</code></p>
<pre><code class="javascript">module.exports = &#123;
    ...
    optimization:&#123;
        usedExports
    &#125;
&#125;
</code></pre>
<p>使用之后，没被用上的代码在<code>webpack</code>打包中会加入<code>unused harmony export mul</code>注释，用来告知 <code>Terser</code> 在优化时，可以删除掉这段代码</p>
<p>如下面<code>sum</code>函数没被用到，<code>webpack</code>打包会添加注释，<code>terser</code>在优化时，则将该函数去掉</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32316232653230302d616565342d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<h5 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h5><p><code>sideEffects</code>用于告知<code>webpack compiler</code>哪些模块时有副作用，配置方法是在<code>package.json</code>中设置<code>sideEffects</code>属性</p>
<p>如果<code>sideEffects</code>设置为false，就是告知<code>webpack</code>可以安全的删除未用到的<code>exports</code></p>
<p>如果有些文件需要保留，可以设置为数组的形式</p>
<pre><code class="javascript">&quot;sideEffecis&quot;:[    &quot;./src/util/format.js&quot;,    &quot;*.css&quot; // 所有的css文件]
</code></pre>
<p>上述都是关于<code>javascript</code>的<code>tree shaking</code>，<code>css</code>同样也能够实现<code>tree shaking</code></p>
<h5 id="css-tree-shaking"><a href="#css-tree-shaking" class="headerlink" title="css tree shaking"></a>css tree shaking</h5><p><code>css</code>进行<code>tree shaking</code>优化可以安装<code>PurgeCss</code>插件</p>
<pre><code class="javascript">npm install purgecss-plugin-webpack -D
const PurgeCssPlugin = require(&#39;purgecss-webpack-plugin&#39;)module.exports = &#123;    ...    plugins:[        new PurgeCssPlugin(&#123;            path:glob.sync(`$&#123;path.resolve(&#39;./src&#39;)&#125;/**/*`), &#123;nodir:true&#125;// src里面的所有文件            satelist:function()&#123;                return &#123;                    standard:[&quot;html&quot;]                &#125;            &#125;        &#125;)    ]&#125;
</code></pre>
<ul>
<li>paths：表示要检测哪些目录下的内容需要被分析，配合使用glob</li>
<li>默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性</li>
</ul>
<h5 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h5><p>将代码分离到不同的<code>bundle</code>中，之后我们可以按需加载，或者并行加载这些文件</p>
<p>默认情况下，所有的<code>JavaScript</code>代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度</p>
<p>代码分离可以分出出更小的<code>bundle</code>，以及控制资源加载优先级，提供代码的加载性能</p>
<p>这里通过<code>splitChunksPlugin</code>来实现，该插件<code>webpack</code>已经默认安装和集成，只需要配置即可</p>
<p>默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all</p>
<pre><code class="javascript">module.exports = &#123;    ...    optimization:&#123;        splitChunks:&#123;            chunks:&quot;all&quot;        &#125;    &#125;&#125;
</code></pre>
<p><code>splitChunks</code>主要属性有如下：</p>
<ul>
<li>Chunks，对同步代码还是异步代码进行处理</li>
<li>minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分</li>
<li>maxSize： 将大于maxSize的包，拆分为不小于minSize的包</li>
<li>minChunks：被引入的次数，默认是1</li>
</ul>
<h5 id="内联chunk"><a href="#内联chunk" class="headerlink" title="内联chunk"></a>内联chunk</h5><p>可以通过<code>InlineChunkHtmlPlugin</code>插件将一些<code>chunk</code>的模块内联到<code>html</code>，如<code>runtime</code>的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的</p>
<pre><code class="javascript">const InlineChunkHtmlPlugin = require(&#39;react-dev-utils/InlineChunkHtmlPlugin&#39;)const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)module.exports = &#123;    ...    plugin:[        new InlineChunkHtmlPlugin(HtmlWebpackPlugin,[/runtime.+\.js/]&#125;
</code></pre>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>关于<code>webpack</code>对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化</p>
<h3 id="♥︎-♥︎-♥︎-与webpack类似的工具还有哪些？区别？"><a href="#♥︎-♥︎-♥︎-与webpack类似的工具还有哪些？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ 与webpack类似的工具还有哪些？区别？"></a>♥︎ ♥︎ ♥︎ 与webpack类似的工具还有哪些？区别？</h3><h4 id="一、模块化工具"><a href="#一、模块化工具" class="headerlink" title="一、模块化工具"></a>一、模块化工具</h4><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式</p>
<p>可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)</p>
<p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code></p>
<p>通过这些模块打包工具，能够提高我们的开发效率，减少开发成本</p>
<p>这里没有提及<code>gulp</code>、<code>grunt</code>是因为它们只是定义为构建工具，不能类比</p>
<h5 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h5><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup </code>要小巧的多</p>
<p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p>
<p>举个例子：</p>
<pre><code class="javascript">// ./src/messages.js
export default &#123;
  hi: &#39;Hey Guys, I am zce~&#39;
&#125;

// ./src/logger.js
export const log = msg =&gt; &#123;
  console.log(&#39;---------- INFO ----------&#39;)
  console.log(msg)
  console.log(&#39;--------------------------&#39;)
&#125;

export const error = msg =&gt; &#123;
  console.error(&#39;---------- ERROR ----------&#39;)
  console.error(msg)
  console.error(&#39;---------------------------&#39;)
&#125;

// ./src/index.js
import &#123; log &#125; from &#39;./logger&#39;
import messages from &#39;./messages&#39;
log(messages.hi)
</code></pre>
<p>然后通过<code>rollup</code>进行打包</p>
<pre><code class="ini">$ npx rollup ./src/index.js --file ./dist/bundle.js
</code></pre>
<p>打包结果如下图</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38666530373833302d623134332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>可以看到，代码非常简洁，完成不像<code>webpack</code>那样存在大量引导代码和模块函数</p>
<p>并且<code>error</code>方法由于没有被使用，输出的结果中并无<code>error</code>方法，可以看到，<code>rollup</code>默认开始<code>Tree-shaking</code> 优化输出结果</p>
<p>因此，可以看到<code>Rollup</code>的优点：</p>
<ul>
<li>代码效率更简洁、效率更高</li>
<li>默认支持 Tree-shaking</li>
</ul>
<p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup </code>需要使用插件去完成</p>
<p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p>
<p>但是在用于打包<code> JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p>
<h5 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h5><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p>
<p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。如下所示：</p>
<pre><code class="javascript">&lt;!-- ./src/index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Parcel Tutorials&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>main.js文件通过<code>ES Moudle</code>方法导入其他模块成员</p>
<pre><code class="javascript">// ./src/main.js
import &#123; log &#125; from &#39;./logger&#39;
log(&#39;hello parcel&#39;)
// ./src/logger.js
export const log = msg =&gt; &#123;
  console.log(&#39;---------- INFO ----------&#39;)
  console.log(msg)
&#125;
</code></pre>
<p>运行之后，使用命令打包</p>
<pre><code class="ini">npx parcel src/index.html
</code></pre>
<p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个开发服务器，跟<code>webpack Dev Server</code>一样</p>
<p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单</p>
<p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p>
<p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p>
<p>打包命令如下：</p>
<pre><code class="ini">npx parcel src/index.html
</code></pre>
<p>由于打包过程是多进程同时工作，构建速度会比<code>Webpack</code> 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65633137653761302d623161322d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>可以感受到，<code>Parcel </code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决</p>
<h5 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h5><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p>
<p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p>
<p>下图给出<code>webpack</code>与<code>snowpack</code>打包区别：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37393139373833302d623161332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新</p>
<h5 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h5><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p>
<p>它主要由两部分组成：</p>
<ul>
<li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR</li>
<li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li>
</ul>
<p>其作用类似<code>webpack </code>+ <code>webpack-dev-server</code>，其特点如下：</p>
<ul>
<li>快速的冷启动</li>
<li>即时的模块热更新</li>
<li>真正的按需编译</li>
</ul>
<p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p>
<p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p>
<p>原理图如下所示：</p>
<p><img src="/2022/11/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E5%85%A8%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39663265656433302d623134332d313165622d383566362d3666616337376330633962332e706e67.png"></p>
<p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p>
<h5 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h5><p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：一切皆模块和按需加载</p>
<p>与其他构建工具相比，有如下优势：</p>
<ul>
<li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li>
<li>万物模块：对 js、css、图片等资源文件都支持打包</li>
<li>开箱即用：HRM、Tree-shaking等功能</li>
<li>代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li>
<li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li>
<li>易于调试：支持 SourceUrls 和 SourceMaps</li>
<li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li>
<li>生态环境好：社区更丰富，出现的问题更容易解决</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-代码分割的本质是什么？有什么意义呢？"><a href="#♥︎-♥︎-♥︎-代码分割的本质是什么？有什么意义呢？" class="headerlink" title="♥︎ ♥︎ ♥︎ 代码分割的本质是什么？有什么意义呢？"></a>♥︎ ♥︎ ♥︎ 代码分割的本质是什么？有什么意义呢？</h3><p>代码分割的本质： 是能够把代码分离到不同的bundle中，避免出现大体积的代码包，然后可以按需加载或并行加载这些文件 </p>
<p>代码分离的意义： 代码分离可以获取更小的bundle，以及控制资源加载优先级，合理使用可以极大的减少加载时间 </p>
<p>代码分割的实现方式有三种： 入口起点：使用entry手动分离代码(不建议) 防止重复加载：</p>
<p>使用optimization.splitChunks配置选项，可以将第三方公共模块和业务代码直接分离 </p>
<p>动态引入：使 用import()方法来分离代码，原理是当 Webpack 解析到该语法时，会自动进行代码分割，分割出不同的chunks  </p>
<p>语法：使用的时候再去下载对应的文件，返回一个Promise，当Promise成功后再去执行回调</p>
<h3 id="♥︎-♥︎-♥︎-说下-tree-shaking-的原理"><a href="#♥︎-♥︎-♥︎-说下-tree-shaking-的原理" class="headerlink" title="♥︎ ♥︎ ♥︎ 说下 tree-shaking 的原理"></a>♥︎ ♥︎ ♥︎ 说下 tree-shaking 的原理</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7002410645316436004">tree-shaking 的原理</a></p>
<h3 id="♥︎-♥︎-♥︎-babel原理"><a href="#♥︎-♥︎-♥︎-babel原理" class="headerlink" title="♥︎ ♥︎ ♥︎  babel原理"></a>♥︎ ♥︎ ♥︎  babel原理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wmaoshu/article/details/119813090">babel原理</a></p>
<h3 id="♥︎-♥︎-♥︎-linux部署和windows-sever服务器区别？"><a href="#♥︎-♥︎-♥︎-linux部署和windows-sever服务器区别？" class="headerlink" title="♥︎ ♥︎ ♥︎  linux部署和windows sever服务器区别？"></a>♥︎ ♥︎ ♥︎  linux部署和windows sever服务器区别？</h3><p>性价比：Linux服务器性价比更高，Linux作为资源管理器和操作系统来说，是开源的，免费的，而正版windows的操作系统是收费的。</p>
<p>性能方面：相同配置的Linux服务器的性能比windows服务器好一些，Linux服务器占用的资源少一点</p>
<p>稳定性方面：Window系统用户量大，因而攻击者多一些，所以暴露了更多的系统安全漏洞。Linux是多用户多进程系统，意味着Linux能够一次性处理大量正在进行的进程，比windows处理的多</p>
<p>安全性方面：Linux系统开源软件的开发方式有助于暴露错误，集众人智慧解决问题，补丁更新更快。这是windows不具备的，Windows的另一个不利因素是其许多应用程序依靠远程过程调用，这就迫使Windows的防火墙没有Linux那样严格。而Linux远程过程调用是限制使用的。</p>
<h3 id="♥︎-♥︎-♥︎-前端资源发布路径怎么实现非覆盖式发布（平滑升级）？"><a href="#♥︎-♥︎-♥︎-前端资源发布路径怎么实现非覆盖式发布（平滑升级）？" class="headerlink" title="♥︎ ♥︎ ♥︎ 前端资源发布路径怎么实现非覆盖式发布（平滑升级）？"></a>♥︎ ♥︎ ♥︎ 前端资源发布路径怎么实现非覆盖式发布（平滑升级）？</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903457984512014">前端资源发布路径怎么实现非覆盖式发布</a></p>
<h3 id="♥︎-♥︎-♥︎-你有发布过自己的npm包吗？流程是怎样的？"><a href="#♥︎-♥︎-♥︎-你有发布过自己的npm包吗？流程是怎样的？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你有发布过自己的npm包吗？流程是怎样的？"></a>♥︎ ♥︎ ♥︎ 你有发布过自己的npm包吗？流程是怎样的？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CapejasmineY/article/details/126251986">npm包发布流程</a></p>
<h3 id="♥︎-♥︎-♥︎-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？"><a href="#♥︎-♥︎-♥︎-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？" class="headerlink" title="♥︎ ♥︎ ♥︎ 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？"></a>♥︎ ♥︎ ♥︎ 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/75786d5c9cac">npm 模块安装机制</a></p>
<h3 id="♥︎-♥︎-♥︎-你会搭建私有的npm仓库吗？怎么搭建？"><a href="#♥︎-♥︎-♥︎-你会搭建私有的npm仓库吗？怎么搭建？" class="headerlink" title="♥︎ ♥︎ ♥︎ 你会搭建私有的npm仓库吗？怎么搭建？"></a>♥︎ ♥︎ ♥︎ 你会搭建私有的npm仓库吗？怎么搭建？</h3><p><a target="_blank" rel="noopener" href="https://zhaomenghuan.js.org/blog/npm-private-repository-verdaccio.html">私有的npm仓库</a></p>
<h3 id="♥︎-♥︎-♥︎-jenkins-上线流程"><a href="#♥︎-♥︎-♥︎-jenkins-上线流程" class="headerlink" title="♥︎ ♥︎ ♥︎  jenkins 上线流程"></a>♥︎ ♥︎ ♥︎  jenkins 上线流程</h3><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/608413">jenkins 上线流程</a></p>
<h3 id="♥︎-♥︎-♥︎-什么是长缓存，在webpack中如何做到长缓存优化？"><a href="#♥︎-♥︎-♥︎-什么是长缓存，在webpack中如何做到长缓存优化？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是长缓存，在webpack中如何做到长缓存优化？"></a>♥︎ ♥︎ ♥︎ 什么是长缓存，在webpack中如何做到长缓存优化？</h3><p>浏览器在用户访问页面的时候，都会对静态资源进行存储，但是每次代码更新或者升级的时候，我们都需要浏览器去重新加载代码，最方便的方法就是以文件名的方式引入，只下载新的代码块，不加载旧的没有变化的代码块，这就是长缓存，</p>
<p>在webpack4中使用SplitChunkPlugin把第三方库和业务代码分离，由于第三方库的chunkHash未改变，所以只会对改变的业务代码的模块进行更新。而第三方库的代码块因为长缓存而不更新。</p>
<h3 id="♥︎-♥︎-♥︎-什么是组件？什么是模块化？有什么区别？"><a href="#♥︎-♥︎-♥︎-什么是组件？什么是模块化？有什么区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ 什么是组件？什么是模块化？有什么区别？"></a>♥︎ ♥︎ ♥︎ 什么是组件？什么是模块化？有什么区别？</h3><p>组件化</p>
<p>就是基础库或者基础组件，意思是把代码重复的部分提炼出一个个组件供给功能使用</p>
<p>模块化</p>
<p>就是业务框架或者业务模块，也可以理解为框架，意思是把功能进行划分，将同一类型的代码整合在一起，所以模</p>
<p>块的功能相对复杂，都属于同一个业务。</p>
<p>区别：</p>
<p>使用：组件的使用能在不同项目(模块)重复应用的代码，而模块按照项目功能需求划分成不同类型的业务框架 </p>
<p>目的：组件是复用，解耦，模块是为了隔离、封装 </p>
<p>依赖：组件之间低依赖，比较独立，模块之间的依赖可通过路由进行耦合 </p>
<p>架构定位：组件位于架构底层，被其它层所依赖，模块位于架构业务层</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903935795265549">https://juejin.cn/post/6844903935795265549</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全git"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/"
    >前端面试大全git</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/" class="article-date">
  <time datetime="2022-11-03T02:29:52.000Z" itemprop="datePublished">2022-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/git%E6%93%8D%E4%BD%9C/">git操作</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（git命令）"><a href="#前端面试题大全（git命令）" class="headerlink" title="前端面试题大全（git命令）"></a>前端面试题大全（git命令）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git是什么？"><a href="#git是什么？" class="headerlink" title="git是什么？"></a>git是什么？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>git，是一个分布式版本控制软件，最初目的是为更好地管理<code>Linux</code>内核开发而设计</p>
<p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32393234306634302d663739632d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>项目开始，只有一个原始版仓库，别的机器可以<code>clone</code>这个原始版本库，那么所有<code>clone</code>的机器，它们的版本库其实都是一样的，并没有主次之分</p>
<p>所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库<code>clone</code>一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交</p>
<p><code>github</code>实际就可以充当这个服务器角色，其是一个开源协作社区，提供<code>Git</code>仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目</p>
<h4 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h4><p>当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的</p>
<p><code>Git</code> 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，<code>git</code>能够知道</p>
<p><code>Git </code>用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来，如下：</p>
<pre><code class="ini">24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre>
<p>当我们修改文件的时候，<code>git</code>就会修改文件的状态，可以通过<code>git status</code>进行查询，状态情况如下：</p>
<ul>
<li>已修改（modified）：表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交（committed）：表示数据已经安全的保存在本地数据库中。</li>
</ul>
<p>文件状态对应的，不同状态的文件在<code>Git</code>中处于不同的工作区域，主要分成了四部分：</p>
<ul>
<li>工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本</li>
<li>暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中</li>
<li>本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库</li>
<li>远程仓库：远程的仓库，如 github</li>
</ul>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33323733633961302d663739632d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="三、命令"><a href="#三、命令" class="headerlink" title="三、命令"></a>三、命令</h4><p>从上图可以看到，<code>git</code>日常简单的使用就只有上图6个命令：</p>
<ul>
<li>add</li>
<li>commit</li>
<li>push</li>
<li>pull</li>
<li>clone</li>
<li>checkout</li>
</ul>
<p>但实际上还有很多命令，如果想要熟练使用，还有60个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力</p>
<h3 id="Git中-fork-clone-branch这三个概念，有什么区别"><a href="#Git中-fork-clone-branch这三个概念，有什么区别" class="headerlink" title="Git中 fork, clone,branch这三个概念，有什么区别?"></a>Git中 fork, clone,branch这三个概念，有什么区别?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p><code>fork</code>，英语翻译过来就是叉子，动词形式则是分叉，如下图，从左到右，一条直线变成多条直线</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61643034616465302d663761642d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>转到<code>git</code>仓库中，<code>fork</code>则可以代表分叉、克隆 出一个（仓库的）新拷贝</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62346233313435302d663761642d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>包含了原来的仓库（即upstream repository，上游仓库）所有内容，如分支、Tag、提交</p>
<p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p>
<h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p>
<p>执行<code>clone</code>命令后，会在当前目录下创建一个名为<code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p>
<p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p>
<h5 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h5><p><code>branch</code>，译为分支，其作用简单而言就是开启另一个分支， 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线</p>
<p><code>Git</code> 处理分支的方式十分轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷</p>
<p>在我们开发中，默认只有一条<code>master</code>分支，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37666138653963302d663932332d313165622d393931642d3333346664333166303230312e706e67.png">]</p>
<p>通过<code>git branch </code>可以创建一个分支，但并不会自动切换到新分支中去</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38396566643536302d663932332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>通过<code>git checkout</code>可以切换到另一个<code>testing</code>分支</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39316431636566302d663932332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h4><h5 id="fork-1"><a href="#fork-1" class="headerlink" title="fork"></a>fork</h5><p>当你在<code>github</code>发现感兴趣开源项目的时候，可以通过点击<code>github</code>仓库中右上角<code>fork</code>标识的按钮，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095419097.png"></p>
<p>点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的<code>github</code>仓库中，而你本地仓库是不会存在任何更改</p>
<p>然后你就可以通过<code>git clone</code>对你这个复制的远程仓库进行克隆</p>
<p>后续更改任何东西都可以在本地完成，如<code>git add</code>、<code>git commit</code>一系列的操作，然后通过<code>push</code>命令推到自己的远程仓库</p>
<p>如果希望对方接受你的修改，可以通过发送<code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095452040.png"></p>
<p>整体流程如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63656438636531302d663761642d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="clone-1"><a href="#clone-1" class="headerlink" title="clone"></a>clone</h5><p>在<code>github</code>中，开源项目右侧存在<code>code</code>按钮，点击后则会显示开源项目<code>url</code>信息，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/image-20221103095540516.png"></p>
<p>通过<code>git clone xxx</code>则能完成远程项目的下载</p>
<h5 id="branch-1"><a href="#branch-1" class="headerlink" title="branch"></a>branch</h5><p>可通过<code>git branch</code>进行查看当前的分支状态，</p>
<p>如果给了<code>--list</code>，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号</p>
<p>以及通过<code>git branch</code>创建一个新的分支出来</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>其三者区别如下：</p>
<ul>
<li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li>
<li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li>
<li>branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支</li>
</ul>
<h3 id="Git常用的命令有哪些？"><a href="#Git常用的命令有哪些？" class="headerlink" title="Git常用的命令有哪些？"></a>Git常用的命令有哪些？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p><code>git </code>的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66653135303532302d663761662d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的<code>git </code>命令</p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p><code>Git </code>自带一个 <code>git config</code> 的工具来帮助设置控制 <code>Git </code>外观和行为的配置变量，在我们安装完<code>git</code>之后，第一件事就是设置你的用户名和邮件地址</p>
<p>后续每一个提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改</p>
<p>设置提交代码时的用户信息命令如下：</p>
<ul>
<li>git config [–global] user.name “[name]”</li>
<li>git config [–global] user.email “[email address]”</li>
</ul>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>一个<code>git</code>项目的初始有两个途径，分别是：</p>
<ul>
<li>git init [project-name]：创建或在当前目录初始化一个git代码库</li>
<li>git clone url：下载一个项目和它的整个代码历史</li>
</ul>
<h5 id="日常基本操作"><a href="#日常基本操作" class="headerlink" title="日常基本操作"></a>日常基本操作</h5><p>在日常工作中，代码常用的基本操作如下：</p>
<ul>
<li>git init 初始化仓库，默认为 master 分支</li>
<li>git add . 提交全部文件修改到缓存区</li>
<li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li>
<li>git diff 查看当前代码 add后，会 add 哪些内容</li>
<li>git diff –staged查看现在 commit 提交后，会提交哪些内容</li>
<li>git status 查看当前分支状态</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li>
<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li>
<li>git commit -m “&lt;注释&gt;” 提交代码到本地仓库，并写提交注释</li>
<li>git commit -v 提交时显示所有diff信息</li>
<li>git commit –amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</li>
</ul>
<p>关于提交信息的格式，可以遵循以下的规则：</p>
<ul>
<li>feat: 新特性，添加功能</li>
<li>fix: 修改 bug</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>style: 代码格式修改, 注意不是 css 修改</li>
<li>test: 测试用例修改</li>
<li>chore: 其他修改, 比如构建流程, 依赖管理</li>
</ul>
<h5 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h5><ul>
<li>git branch 查看本地所有分支</li>
<li>git branch -r 查看远程所有分支</li>
<li>git branch -a 查看本地和远程所有分支</li>
<li>git merge &lt;分支名&gt; 合并分支</li>
<li>git merge –abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li>
<li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li>
<li>git checkout –orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li>
<li>git branch -D &lt;分支名&gt; 删除本地某个分支</li>
<li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li>
<li>git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</li>
<li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li>
<li>git checkout &lt;分支名&gt; 切换到本地某个分支</li>
<li>git checkout &lt;远程库名&gt;&#x2F;&lt;分支名&gt; 切换到线上某个分支</li>
<li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li>
</ul>
<h5 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h5><p>远程操作常见的命令：</p>
<ul>
<li>git fetch [remote] 下载远程仓库的所有变动</li>
<li>git remote -v 显示所有远程仓库</li>
<li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li>
<li>git fetch 获取线上最新版信息记录，不合并</li>
<li>git push [remote] [branch] 上传本地指定分支到远程仓库</li>
<li>git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突</li>
<li>git push [remote] –all 推送所有分支到远程仓库</li>
</ul>
<h5 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h5><ul>
<li>git checkout [file] 恢复暂存区的指定文件到工作区</li>
<li>git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</li>
<li>git checkout . 恢复暂存区的所有文件到工作区</li>
<li>git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</li>
<li>git reset –hard 重置暂存区与工作区，与上一次commit保持一致</li>
<li>git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</li>
<li>git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</li>
</ul>
<blockquote>
<p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p>
<p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p>
</blockquote>
<h5 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h5><p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p>
<ul>
<li>git stash 暂时将未提交的变化移除</li>
<li>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</li>
<li>git stash list 查看所有储藏中的工作</li>
<li>git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</li>
<li>git stash clear 清空所有储藏中的工作</li>
<li>git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</li>
</ul>
<h5 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h5><p><code>git</code>常用命令速查表如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613130663363302d663762302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<h3 id="对git-pull-和-git-fetch-的理解？有什么区别？"><a href="#对git-pull-和-git-fetch-的理解？有什么区别？" class="headerlink" title="对git pull 和 git fetch 的理解？有什么区别？"></a>对git pull 和 git fetch 的理解？有什么区别？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>先回顾两个命令的定义</p>
<ul>
<li>git fetch 命令用于从另一个存储库下载对象和引用</li>
<li>git pull 命令用于从另一个存储库或本地分支获取并集成(整合)</li>
</ul>
<p>再来看一次<code>git</code>的工作流程图，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64353233626136302d666163322d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>可以看到，<code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p>
<p>而<code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p>
<p>在我们本地的<code>git</code>文件中对应也存储了<code>git</code>本地仓库分支的<code>commit ID </code>和 跟踪的远程分支的<code>commit ID</code>，对应文件如下：</p>
<ul>
<li>.git&#x2F;refs&#x2F;head&#x2F;[本地分支]</li>
<li>.git&#x2F;refs&#x2F;remotes&#x2F;[正在跟踪的分支]</li>
</ul>
<p>使用 <code>git fetch</code>更新代码，本地的库中<code>master</code>的<code>commitID</code>不变</p>
<p>但是与<code>git</code>上面关联的那个<code>orign/master</code>的<code>commit ID</code>发生改变</p>
<p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过<code>merge</code>去合并这两个不同的代码版本</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66643233666637302d666231322d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>也就是<code>fetch</code>的时候本地的<code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地<code>merge</code>合并这两个版本号的代码</p>
<p>相比之下，使用<code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30393162383134302d666231332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h4 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h4><p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到<code>git pull</code>或者<code>git fetch</code>命令</p>
<h5 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h5><p>用法如下：</p>
<pre><code class="ini">git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>例如从远程的<code>origin</code>仓库的<code>master</code>分支下载代码到本地并新建一个<code>temp</code>分支</p>
<pre><code class="ini">git fetch origin master:temp
</code></pre>
<p>如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来到本地当前分支</p>
<p>这里<code>git fetch</code>不会进行合并，执行后需要手动执行<code>git merge</code>合并，如下：</p>
<pre><code class="ini">git merge temp
</code></pre>
<h5 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h5><p>两者的用法十分相似，<code>pull</code>用法如下：</p>
<pre><code class="ini">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>例如将远程主机<code>origin</code>的<code>master</code>分支拉取过来，与本地的<code>branchtest</code>分支合并，命令如下：</p>
<pre><code class="ini">git pull origin master:branchtest
</code></pre>
<p>同样如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来与本地当前分支合并</p>
<h4 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h4><p>相同点：</p>
<ul>
<li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li>
</ul>
<p>不同点：</p>
<ul>
<li>git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull &#x3D; git fetch + git merge</li>
<li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li>
</ul>
<h3 id="Git-中-HEAD、工作树和索引之间的区别？"><a href="#Git-中-HEAD、工作树和索引之间的区别？" class="headerlink" title="Git 中 HEAD、工作树和索引之间的区别？"></a>Git 中 HEAD、工作树和索引之间的区别？</h3><h4 id="一、HEAD"><a href="#一、HEAD" class="headerlink" title="一、HEAD"></a>一、HEAD</h4><p>在<code>git</code>中，可以存在很多分支，其本质上是一个指向<code>commit</code>对象的可变指针，而<code>Head</code>是一个特别的指针，是一个指向你正在工作中的本地分支的指针</p>
<p>简单来讲，就是你现在在哪儿，HEAD 就指向哪儿</p>
<p>例如当前我们处于<code>master</code>分支，所以<code>HEAD</code>这个指针指向了<code>master</code>分支指针</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33366362306461302d666134302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>然后通过调用<code>git checkout test</code>切换到<code>test</code>分支，那么<code>HEAD</code>则指向<code>test</code>分支，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33653836626138302d666134302d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>但我们在<code>test</code>分支再一次<code>commit</code>信息的时候，<code>HEAD</code>指针仍然指向了<code>test</code>分支指针，而<code>test</code>分支指针已经指向了最新创建的提交，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34333938333962302d666136362d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这个<code>HEAD</code>存储的位置就在<code>.git/HEAD</code>目录中，查看信息可以看到<code>HEAD</code>指向了另一个文件</p>
<pre><code class="ini">$ cat .git/HEAD
ref: refs/heads/master

$ cat .git/refs/heads/master
7406a10efcc169bbab17827aeda189aa20376f7f
</code></pre>
<p>这个文件的内容是一串哈希码，而这个哈希码正是<code>master</code>分支上最新的提交所对应的哈希码</p>
<p>所以，当我们切换分支的时候，<code>HEAD</code>指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p>
<p>所以，HEAD指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p>
<h4 id="二、工作树和索引"><a href="#二、工作树和索引" class="headerlink" title="二、工作树和索引"></a>二、工作树和索引</h4><p>在<code>Git</code>管理下，大家实际操作的目录被称为工作树，也就是工作区域</p>
<p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34366535616334302d666134302d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>Git</code>在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库</p>
<p>因此，要提交文件，首先需要把文件加入到索引区域中。</p>
<p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交</p>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><p>从所在的位置来看：</p>
<ul>
<li>HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</li>
<li>工作树是查看和编辑的（源）文件的实际内容</li>
<li>索引是放置你想要提交给 git仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过git commit 则将索引区域的文件提交到 git 仓库中</li>
</ul>
<h3 id="对git-stash-的理解？应用场景？"><a href="#对git-stash-的理解？应用场景？" class="headerlink" title="对git stash 的理解？应用场景？"></a>对git stash 的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上</p>
<p>后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码</p>
<p>默认情况下，<code>git stash</code>会缓存下列状态的文件：</p>
<ul>
<li>添加到暂存区的修改（staged changes）</li>
<li>Git跟踪的但并未添加到暂存区的修改（unstaged changes）</li>
</ul>
<p>但以下状态的文件不会缓存：</p>
<ul>
<li>在工作目录中新的文件（untracked files）</li>
<li>被忽略的文件（ignored files）</li>
</ul>
<p>如果想要上述的文件都被缓存，可以使用<code>-u</code>或者<code>--include-untracked</code>可以工作目录新的文件，使用<code>-a</code>或者<code>--all</code>命令可以当前目录下的所有修改</p>
<h4 id="二、如何使用-1"><a href="#二、如何使用-1" class="headerlink" title="二、如何使用"></a>二、如何使用</h4><p>关于<code>git stash</code>常见的命令如下：</p>
<ul>
<li>git stash</li>
<li>git stash save</li>
<li>git stash list</li>
<li>git stash pop</li>
<li>git stash apply</li>
<li>git stash show</li>
<li>git stash drop</li>
<li>git stash clear</li>
</ul>
<h5 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h5><p>保存当前工作进度，会把暂存区和工作区的改动保存起来</p>
<h5 id="git-stash-save"><a href="#git-stash-save" class="headerlink" title="git stash save"></a>git stash save</h5><p><code>git stash save</code>可以用于存储修改.并且将<code>git</code>的工作状态切回到<code>HEAD</code>也就是上一次合法提交上</p>
<p>如果给定具体的文件路径,<code>git stash</code>只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：</p>
<ul>
<li>–keep-index 或者 -k 只会存储为加入 git 管理的文件</li>
<li>–include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态</li>
<li>-a 或者 –all 命令可以当前目录下的所有修改，包括被 git 忽略的文件</li>
</ul>
<h5 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h5><p>显示保存进度的列表。也就意味着，<code>git stash</code>命令可以多次执行，当多次使用<code>git stash</code>命令后，栈里会充满未提交的代码，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35303231366464302d666363662d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>其中，<code>stash@&#123;0&#125;</code>、<code>stash@&#123;1&#125;</code>就是当前<code>stash</code>的名称</p>
<h5 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h5><p><code>git stash pop</code> 从栈中读取最近一次保存的内容，也就是栈顶的<code>stash</code>会恢复到工作区</p>
<p>也可以通过 <code>git stash pop</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>
<p>如果从<code>stash</code>中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突</p>
<h5 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h5><p>将堆栈中的内容应用到当前目录，不同于<code>git stash pop</code>，该命令不会将内容从堆栈中删除</p>
<p>也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况</p>
<p>同样，可以通过<code>git stash apply</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>
<h5 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h5><p>查看堆栈中最新保存的<code>stash</code>和当前目录的差异</p>
<p>通过使用<code>git stash show -p</code>查看详细的不同</p>
<p>通过使用<code>git stash show stash@&#123;1&#125;</code>查看指定的<code>stash</code>和当前目录差异</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/bfc073fa538b45c4d6de871da070f364638cdd751a8c08426794c5dba2230514/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34353836323061302d666363662d313165622d626336662d3366303665313439313636342e706e67"><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34353836323061302d666363662d313165622d626336662d3366303665313439313636342e706e67.png" alt="img"></a></p>
<h5 id="git-stash-drop"><a href="#git-stash-drop" class="headerlink" title="git stash drop"></a>git stash drop</h5><p><code>git stash drop</code> + <code>stash</code>名称表示从堆栈中移除某个指定的stash</p>
<h5 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h5><p>删除所有存储的进度</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情</p>
<p>但是你创建一次未完成的代码的<code>commit</code>提交，这时候就可以使用<code>git stash</code></p>
<p>例如以下场景：</p>
<p>当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过<code>git pull</code>解决</p>
<p>但是如果可能发生冲突怎么办.直接<code>git pull</code>会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：</p>
<ul>
<li>git stash</li>
<li>git pull</li>
<li>git stash pop</li>
</ul>
<p>或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用<code>git stash</code>缓存当前区域的代码</p>
<ul>
<li>git stash：保存开发到一半的代码</li>
<li>git commit -m ‘修改问题’</li>
<li>git stash pop：将代码追加到最新的提交之后</li>
</ul>
<h3 id="对git-rebase-和-git-merge的理解？区别？"><a href="#对git-rebase-和-git-merge的理解？区别？" class="headerlink" title="对git rebase 和 git merge的理解？区别？"></a>对git rebase 和 git merge的理解？区别？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p>
<ul>
<li>git merge</li>
<li>git rebase</li>
</ul>
<p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p>
<p>用法上两者也十分的简单：</p>
<h5 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h5><p>将当前分支合并到指定分支，命令用法如下：</p>
<pre><code class="ini">git merge xxx
</code></pre>
<h5 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h5><p>将当前分支移植到指定分支或指定<code>commit</code>之上，用法如下：</p>
<pre><code class="ini">git rebase -i &lt;commit&gt;
</code></pre>
<p>常见的参数有<code>--continue</code>，用于解决冲突之后，继续执行<code>rebase</code></p>
<pre><code class="ini">git rebase --continue
</code></pre>
<h4 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h4><h5 id="git-merge-1"><a href="#git-merge-1" class="headerlink" title="git merge"></a>git merge</h5><p>通过<code>git merge</code>将当前分支与<code>xxx</code>分支合并，产生的新的<code>commit</code>对象有两个父节点</p>
<p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p>
<p>举个例子，<code>bugfix</code>分支是从<code>maste</code>r分支分叉出来的，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38383431306133302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>合并<code> bugfix</code>分支到<code>master</code>分支时，如果<code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含<code>master</code>分支所有的历史记录</p>
<p>所以通过把<code>master</code>分支的位置移动到<code>bugfix</code>的最新分支上，就完成合并</p>
<p>如果<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39323965623232302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这时候使用<code>git merge</code>的时候，会生成一个新的提交，并且<code>master</code>分支的<code>HEAD</code>会移动到新的分支上，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39666466613365302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p>
<h5 id="git-rebase-1"><a href="#git-rebase-1" class="headerlink" title="git rebase"></a>git rebase</h5><p>同样，<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61623264353132302d666464342d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>通过<code>git rebase</code>，会变成如下情况：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62373261656437302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63396261306538302d666464342d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>rebase</code>之后，<code>master</code>的<code>HEAD</code>位置不变。因此，要合并<code>master</code>分支和<code>bugfix</code>分支</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64633636303636302d666464342d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的<code>B</code></p>
<p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交<code>X</code>和<code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p>
<p>然后将当前分支指向目标最新位置<code>D</code>, 然后将之前另存为临时文件的修改依序应用</p>
<h4 id="三、区别-3"><a href="#三、区别-3" class="headerlink" title="三、区别"></a>三、区别</h4><p>从上面可以看到，<code>merge</code>和<code>rebasea</code>都是合并历史记录，但是各自特性不同：</p>
<h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>通过<code>merge</code>合并分支会新增一个<code>merge commit</code>，然后将两个分支的历史联系起来</p>
<p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p>
<h5 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h5><p><code>rebase </code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p>
<p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p>
<h3 id="git-发生冲突的场景？如何解决？"><a href="#git-发生冲突的场景？如何解决？" class="headerlink" title="git 发生冲突的场景？如何解决？"></a>git 发生冲突的场景？如何解决？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>一般情况下，出现分支的场景有如下：</p>
<ul>
<li>多个分支代码合并到一个分支时</li>
<li>多个分支向同一个远端分支推送</li>
</ul>
<p>具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称</p>
<p>如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可</p>
<p>应用在命令中，就是<code>push</code>、<code>pull</code>、<code>stash</code>、<code>rebase</code>等命令下都有可能产生冲突情况，从本质上来讲，都是<code>merge</code>和<code>patch</code>（应用补丁）时产生冲突</p>
<h4 id="二、分析-1"><a href="#二、分析-1" class="headerlink" title="二、分析"></a>二、分析</h4><p>在本地主分值<code>master</code>创建一个<code>a.txt</code>文件，文件起始位置写上<code>master commit</code>，如下：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39353961646532302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>然后提交到仓库：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m ‘master first commit’</li>
</ul>
<p>创建一个新的分支<code>featurel1</code>分支，并进行切换，如下：</p>
<pre><code class="ini">git checkout -b featurel1
</code></pre>
<p>然后修改<code>a.txt</code>文件首行文字为 <code>featurel commit</code>，然后添加到暂存区，并开始进行提交到仓库：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m ‘featurel first change’</li>
</ul>
<p>然后通过<code>git checkout master</code>切换到主分支，通过<code>git merge</code>进行合并，发现不会冲突</p>
<p>此时<code>a.txt</code>文件的内容变成<code>featurel commit</code>，没有出现冲突情况，这是因为<code>git</code>在内部发生了快速合并</p>
<blockquote>
<p>如果当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作</p>
<p>git 不创建任何新的提交(commit)，只是将当前分支指向合并进来的分支</p>
</blockquote>
<p>如果此时切换到<code>featurel</code>分支，将文件的内容修改成<code>featrue second commit</code>，然后提交到本地仓库</p>
<p>然后切换到主分支，如果此时在<code>a.txt</code>文件再次修改，修改成<code>mastet second commit</code>，然后再次提交到本地仓库</p>
<p>此时，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61303534383863302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>这种情况下，无法执行快速合并，只能试图把各自的修改合并起来，但这种合并就可能会有冲突</p>
<p>现在通过<code>git merge featurel</code>进行分支合并，如下所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62303939316439302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>从冲突信息可以看到，<code>a.txt</code>发生冲突，必须手动解决冲突之后再提交</p>
<p>而<code>git status</code>同样可以告知我们冲突的文件：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63353832333433302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></p>
<p>打开<code>a.txt</code>文件，可以看到如下内容：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63653761306139302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p><code>git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容：</p>
<ul>
<li>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 和 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 之间的区域就是当前更改的内容</li>
<li>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 之间的区域就是传入进来更改的内容</li>
</ul>
<p>现在要做的事情就是将冲突的内容进行更改，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，<code>Git </code>就会将它们标记为冲突已解决然后再提交：</p>
<ul>
<li>git add a.txt</li>
<li>git commit -m “conflict fixed”</li>
</ul>
<p>此时<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64373432316536302d666462332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<p>使用<code>git log</code>命令可以看到合并的信息：</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65306466643162302d666462332d313165622d393931642d3333346664333166303230312e706e67.png"></h4><h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>当<code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p>
<p>解决冲突就是把<code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p>
<h3 id="对git-reset-和-git-revert-的理解？区别？"><a href="#对git-reset-和-git-revert-的理解？区别？" class="headerlink" title="对git reset 和 git revert 的理解？区别？"></a>对git reset 和 git revert 的理解？区别？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><h5 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h5><p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p>
<p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61623464306330302d666637322d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h5><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e14636346aeadfa4f5766d89196355a3ff8fd0edadd8b74bd5803cdab3312e60/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643132633239302d666637322d313165622d393931642d3333346664333166303230312e706e67"><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f62643132633239302d666637322d313165622d393931642d3333346664333166303230312e706e67.png" alt="img"></a></p>
<h4 id="二、如何用"><a href="#二、如何用" class="headerlink" title="二、如何用"></a>二、如何用</h4><h5 id="git-reset-1"><a href="#git-reset-1" class="headerlink" title="git reset"></a>git reset</h5><p>当没有指定<code>ID</code>的时候，默认使用<code>HEAD</code>，如果指定<code>ID</code>，那么就是基于指向<code>ID</code>去变动暂存区或工作区的内容</p>
<pre><code class="ini">// 没有指定ID, 暂存区的内容会被当前ID版本号的内容覆盖，工作区不变
git reset

// 指定ID，暂存区的内容会被指定ID版本号的内容覆盖，工作区不变
git reset &lt;ID&gt; 
</code></pre>
<p>日志<code>ID</code>可以通过查询，可以<code>git log</code>进行查询，如下：</p>
<pre><code class="ini">commit a7700083ace1204ccdff9f71631fb34c9913f7c5 (HEAD -&gt; master)
Author: linguanghui &lt;linguanghui@baidu.com&gt;
Date:   Tue Aug 17 22:34:40 2021 +0800

    second commit

commit e31118663ce66717edd8a179688a7f3dde5a9393
Author: linguanghui &lt;linguanghui@baidu.com&gt;
Date:   Tue Aug 17 22:20:01 2021 +0800

    first commit
</code></pre>
<p>常见命令如下：</p>
<ul>
<li>–mixed（默认）：默认的时候，只有暂存区变化</li>
<li>–hard参数：如果使用 –hard 参数，那么工作区也会变化</li>
<li>–soft：如果使用 –soft 参数，那么暂存区和工作区都不会变化</li>
</ul>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8git/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32323562343165302d666637332d313165622d626336662d3366303665313439313636342e706e67.png"></p>
<h5 id="git-revert-1"><a href="#git-revert-1" class="headerlink" title="git revert"></a>git revert</h5><p>跟<code>git reset</code>用法基本一致，<code>git revert</code> 撤销某次操作，此次操作之前和之后的 <code>commit</code>和<code>history</code>都会保留，并且把这次撤销，作为一次最新的提交，如下：</p>
<pre><code class="ini">git revert &lt;commit_id&gt; 
</code></pre>
<p>如果撤销前一个版本，可以通过如下命令：</p>
<pre><code class="ini">git revert HEAD
</code></pre>
<p>撤销前前一次，如下：</p>
<pre><code class="ini">git revert HEAD^
</code></pre>
<h4 id="三、区别-4"><a href="#三、区别-4" class="headerlink" title="三、区别"></a>三、区别</h4><p>撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，<code>git reset</code>被设计为重设本地更改</p>
<p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p>
<p>两者主要区别如下：</p>
<ul>
<li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li>
<li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容</li>
<li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li>
</ul>
<blockquote>
<p>git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并</p>
<p>但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</p>
</blockquote>
<ul>
<li>如果回退分支的代码以后还需要的情况则使用<code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用<code>git reset</code></li>
</ul>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mians/" rel="tag">mians</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" rel="tag">代码版本控制</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全设计模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
    >前端面试大全设计模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-11-03T01:26:38.000Z" itemprop="datePublished">2022-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">常用设计模式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（设计模式）"><a href="#前端面试题大全（设计模式）" class="headerlink" title="前端面试题大全（设计模式）"></a>前端面试题大全（设计模式）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ul>
<li>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</li>
</ul>
<h3 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h3><ul>
<li>看懂源代码：如果你不懂设计模式去看Jdk、Spring、SpringMVC、IO等等等等的源码，你会很迷茫，你会寸步难行</li>
<li>看看前辈的代码：你去个公司难道都是新项目让你接手？很有可能是接盘的，前辈的开发难道不用设计模式？</li>
<li>编写自己的理想中的好代码：我个人反正是这样的，对于我自己开发的项目我会很认真，我对他比对我女朋友还好，把项目当成自己的儿子一样</li>
</ul>
<h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17172acfe20b2d2d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png"></p>
<ul>
<li>创建型模式，共五种：工厂方法模式、抽象工厂模式<strong>、</strong>单例模式、建造者模式、原型模式。</li>
<li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17172acff10be430~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.jpeg"></p>
<h4 id="开放封闭原则（Open-Close-Principle）"><a href="#开放封闭原则（Open-Close-Principle）" class="headerlink" title="开放封闭原则（Open Close Principle）"></a>开放封闭原则（Open Close Principle）</h4><ul>
<li>原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</li>
<li>描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li>
<li>优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。</li>
</ul>
<h4 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h4><ul>
<li>原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。</li>
<li>大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。</li>
<li>优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。</li>
</ul>
<h4 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h4><ul>
<li>依赖倒置原则的核心思想是面向接口编程.</li>
<li>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，</li>
<li>这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。</li>
</ul>
<h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h4><ul>
<li>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</li>
<li>例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口</li>
</ul>
<h4 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h4><ul>
<li>原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦</li>
<li>大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</li>
<li>优点：低耦合，高内聚。</li>
</ul>
<h4 id="单一职责原则（Principle-of-single-responsibility）"><a href="#单一职责原则（Principle-of-single-responsibility）" class="headerlink" title="单一职责原则（Principle of single responsibility）"></a>单一职责原则（Principle of single responsibility）</h4><ul>
<li>原则思想：一个方法只负责一件事情。</li>
<li>描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。</li>
<li>优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>单例模式（Singleton Pattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建</p>
<p>在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象，如下图所示：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66613738393864302d336232632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>从定义上来看，全局变量好像就是单例模式，但是一般情况我们不认为全局变量是一个单例模式，原因是：</p>
<ul>
<li>全局命名污染</li>
<li>不易维护，容易被重写覆盖</li>
</ul>
<h4 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h4><p>在<code>javascript</code>中，实现一个单例模式可以用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可，如下：</p>
<pre><code class="javascript">// 定义一个类
function Singleton(name) &#123;
  this.name = name;
  this.instance = null;
&#125;
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 获取类的实例
Singleton.getInstance = function(name) &#123;
  if(!this.instance) &#123;
      this.instance = new Singleton(name);
  &#125;
  return this.instance
&#125;;

// 获取对象1
const a = Singleton.getInstance(&#39;a&#39;);
// 获取对象2
const b = Singleton.getInstance(&#39;b&#39;);
// 进行比较
console.log(a === b);
</code></pre>
<p>使用闭包也能够实现，如下：</p>
<pre><code class="javascript">function Singleton(name) &#123;
  this.name = name;
&#125;
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 获取类的实例
Singleton.getInstance = (function() &#123;
  var instance = null;
  return function(name) &#123;
      if(!this.instance) &#123;
          this.instance = new Singleton(name);
      &#125;
      return this.instance
  &#125;        
&#125;)();

// 获取对象1
const a = Singleton.getInstance(&#39;a&#39;);
// 获取对象2
const b = Singleton.getInstance(&#39;b&#39;);
// 进行比较
console.log(a === b);
</code></pre>
<p>也可以将上述的方法稍作修改，变成构造函数的形式，如下：</p>
<pre><code class="javascript">// 单例构造函数
function CreateSingleton (name) &#123;
  this.name = name;
  this.getName();
&#125;;

// 获取实例的名字
CreateSingleton.prototype.getName = function() &#123;
  console.log(this.name)
&#125;;
// 单例对象
const Singleton = (function()&#123;
  var instance;
  return function (name) &#123;
      if(!instance) &#123;
          instance = new CreateSingleton(name);
      &#125;
      return instance;
  &#125;
&#125;)();

// 创建实例对象1
const a = new Singleton(&#39;a&#39;);
// 创建实例对象2
const b = new Singleton(&#39;b&#39;);

console.log(a===b); // true
</code></pre>
<h4 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h4><p>在前端中，很多情况都是用到单例模式，例如页面存在一个模态框的时候，只有用户点击的时候才会创建，而不是加载完成之后再创建弹窗和隐藏，并且保证弹窗全局只有一个</p>
<p>可以先创建一个通常的获取对象的方法，如下：</p>
<pre><code class="javascript">const getSingle = function( fn )&#123;
let result;
return function()&#123;
  return result || ( result = fn .apply(this, arguments ) );
&#125;
&#125;; 
</code></pre>
<p>创建弹窗的代码如下：</p>
<pre><code class="javascript">const createLoginLayer = function()&#123;
var div = document.createElement( &#39;div&#39; );
div.innerHTML = &#39;我是浮窗&#39;;
div.style.display = &#39;none&#39;;
document.body.appendChild( div );
return div;
&#125;; 

const createSingleLoginLayer = getSingle( createLoginLayer ); 

document.getElementById( &#39;loginBtn&#39; ).onclick = function()&#123;
var loginLayer = createSingleLoginLayer();
loginLayer.style.display = &#39;block&#39;;
&#125;;
</code></pre>
<p>上述这种实现称为惰性单例，意图解决需要时才创建类实例对象</p>
<p>并且<code>Vuex</code>、<code>redux</code>全局态管理库也应用单例模式的思想，如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f38626535306638302d336232622d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>现在很多第三方库都是单例模式，多次引用只会使用同一个对象，如<code>jquery</code>、<code>lodash</code>、<code>moment</code>…</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂</p>
<p>其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品</p>
<p>举个例子：</p>
<ul>
<li>编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联（耦合）</li>
<li>后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事；</li>
<li>这种情况下，就需要将创建实例的工作从调用方（A类）中分离，与调用方解耦，也就是使用工厂方法创建实例的工作封装起来（减少代码重复），由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，而降低调用者因为创建逻辑导致的错误；</li>
</ul>
<h4 id="二、实现-1"><a href="#二、实现-1" class="headerlink" title="二、实现"></a>二、实现</h4><p>工厂模式根据抽象程度的不同可以分为：</p>
<ul>
<li>简单工厂模式（Simple Factory）</li>
<li>工厂方法模式（Factory Method）</li>
<li>抽象工厂模式（Abstract Factory）</li>
</ul>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例</p>
<p>假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致</p>
<p>代码如下：</p>
<pre><code class="javascript">function Factory(career) &#123;
    function User(career, work) &#123;
        this.career = career 
        this.work = work
    &#125;
    let work
    switch(career) &#123;
        case &#39;coder&#39;:
            work =  [&#39;写代码&#39;, &#39;修Bug&#39;] 
            return new User(career, work)
            break
        case &#39;hr&#39;:
            work = [&#39;招聘&#39;, &#39;员工信息管理&#39;]
            return new User(career, work)
            break
        case &#39;driver&#39;:
            work = [&#39;开车&#39;]
            return new User(career, work)
            break
        case &#39;boss&#39;:
            work = [&#39;喝茶&#39;, &#39;开会&#39;, &#39;审批文件&#39;]
            return new User(career, work)
            break
    &#125;
&#125;
let coder = new Factory(&#39;coder&#39;)
console.log(coder)
let boss = new Factory(&#39;boss&#39;)
console.log(boss)
</code></pre>
<p><code>Factory</code>就是一个简单工厂。当我们调用工厂函数时，只需要传递name、age、career就可以获取到包含用户工作内容的实例对象</p>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂方法模式跟简单工厂模式差不多，但是把具体的产品放到了工厂函数的<code>prototype</code>中</p>
<p>这样一来，扩展产品种类就不必修改工厂函数了，核心类就变成抽象类，也可以随时重写某种具体的产品</p>
<p>也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产；但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产</p>
<p>如下代码：</p>
<pre><code class="javascript">// 工厂方法
function Factory(career)&#123;
    if(this instanceof Factory)&#123;
        var a = new this[career]();
        return a;
    &#125;else&#123;
        return new Factory(career);
    &#125;
&#125;
// 工厂方法函数的原型中设置所有对象的构造函数
Factory.prototype=&#123;
    &#39;coder&#39;: function()&#123;
        this.careerName = &#39;程序员&#39;
        this.work = [&#39;写代码&#39;, &#39;修Bug&#39;] 
    &#125;,
    &#39;hr&#39;: function()&#123;
        this.careerName = &#39;HR&#39;
        this.work = [&#39;招聘&#39;, &#39;员工信息管理&#39;]
    &#125;,
    &#39;driver&#39;: function () &#123;
        this.careerName = &#39;司机&#39;
        this.work = [&#39;开车&#39;]
    &#125;,
    &#39;boss&#39;: function()&#123;
        this.careerName = &#39;老板&#39;
        this.work = [&#39;喝茶&#39;, &#39;开会&#39;, &#39;审批文件&#39;]
    &#125;
&#125;
let coder = new Factory(&#39;coder&#39;)
console.log(coder)
let hr = new Factory(&#39;hr&#39;)
console.log(hr)
</code></pre>
<p>工厂方法关键核心代码是工厂里面的判断this是否属于工厂，也就是做了分支判断，这个工厂只做我能做的产品</p>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>上述简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建</p>
<p>通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的</p>
<p>由于<code>JavaScript</code>中并没有抽象类的概念，只能模拟，可以分成四部分：</p>
<ul>
<li>用于创建抽象类的函数</li>
<li>抽象类</li>
<li>具体类</li>
<li>实例化具体类</li>
</ul>
<p>上面的例子中有<code>coder</code>、<code>hr</code>、<code>boss</code>、<code>driver</code>四种岗位，其中<code>coder</code>可能使用不同的开发语言进行开发，比如<code>JavaScript</code>、<code>Java</code>等等。那么这两种语言就是对应的类簇</p>
<p>示例代码如下：</p>
<pre><code class="javascript">let CareerAbstractFactory = function(subType, superType) &#123;
  // 判断抽象工厂中是否有该抽象类
  if (typeof CareerAbstractFactory[superType] === &#39;function&#39;) &#123;
    // 缓存类
    function F() &#123;&#125;
    // 继承父类属性和方法
    F.prototype = new CareerAbstractFactory[superType]()
    // 将子类的constructor指向父类
    subType.constructor = subType;
    // 子类原型继承父类
    subType.prototype = new F()
  &#125; else &#123;
    throw new Error(&#39;抽象类不存在&#39;)
  &#125;
&#125;
</code></pre>
<p>上面代码中<code>CareerAbstractFactory</code>就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>从上面可看到，简单简单工厂的优点就是我们只要传递正确的参数，就能获得所需的对象，而不需要关心其创建的具体细节</p>
<p>应用场景也容易识别，有构造函数的地方，就应该考虑简单工厂，但是如果函数构建函数太多与复杂，会导致工厂函数变得复杂，所以不适合复杂的情况</p>
<p>抽象工厂模式一般用于严格要求以面向对象思想进行开发的超大型项目中，我们一般常规的开发的话一般就是简单工厂和工厂方法模式会用的比较多一些</p>
<p>综上，工厂模式适用场景如下：</p>
<ul>
<li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li>
<li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li>
<li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来</p>
<p>一个基于策略模式的程序至少由两部分组成：</p>
<ul>
<li>策略类，策略类封装了具体的算法，并负责具体的计算过程</li>
<li>环境类Context，Context 接受客户的请求，随后 把请求委托给某一个策略类</li>
</ul>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>举个例子，公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍</p>
<p>若使用<code>if</code>来实现，代码则如下：</p>
<pre><code class="javascript">var calculateBouns = function(salary,level) &#123;
    if(level === &#39;A&#39;) &#123;
        return salary * 4;
    &#125;
    if(level === &#39;B&#39;) &#123;
        return salary * 3;
    &#125;
    if(level === &#39;C&#39;) &#123;
        return salary * 2;
    &#125;
&#125;;
// 调用如下：
console.log(calculateBouns(4000,&#39;A&#39;)); // 16000
console.log(calculateBouns(2500,&#39;B&#39;)); // 7500
</code></pre>
<p>从上述可有看到，函数内部包含过多<code>if...else</code>，并且后续改正的时候，需要在函数内部添加逻辑，违反了开放封闭原则</p>
<p>而如果使用策略模式，就是先定义一系列算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，如下：</p>
<pre><code class="javascript">var obj = &#123;
        &quot;A&quot;: function(salary) &#123;
            return salary * 4;
        &#125;,
        &quot;B&quot; : function(salary) &#123;
            return salary * 3;
        &#125;,
        &quot;C&quot; : function(salary) &#123;
            return salary * 2;
        &#125; 
&#125;;
var calculateBouns =function(level,salary) &#123;
    return obj[level](salary);
&#125;;
console.log(calculateBouns(&#39;A&#39;,10000)); // 40000
</code></pre>
<p>上述代码中，<code>obj</code>对应的是策略类，而<code>calculateBouns</code>对应上下通信类</p>
<p>又比如实现一个表单校验的代码，常常会像如下写法：</p>
<pre><code class="javascript">var registerForm = document.getElementById(&quot;registerForm&quot;);
registerForm.onsubmit = function()&#123;
    if(registerForm.userName.value === &#39;&#39;) &#123;
        alert(&#39;用户名不能为空&#39;);
        return;
    &#125;
    if(registerForm.password.value.length &lt; 6) &#123;
        alert(&quot;密码的长度不能小于6位&quot;);
        return;
    &#125;
    if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123;
        alert(&quot;手机号码格式不正确&quot;);
        return;
    &#125;
&#125;
</code></pre>
<p>上述代码包含多处<code>if</code>语句，并且违反了开放封闭原则，如果应用中还有其他的表单，需要重复编写代码</p>
<p>此处也可以使用策略模式进行重构校验，第一步确定不变的内容，即策略规则对象，如下：</p>
<pre><code class="javascript">var strategy = &#123;
    isNotEmpty: function(value,errorMsg) &#123;
        if(value === &#39;&#39;) &#123;
            return errorMsg;
        &#125;
    &#125;,
    // 限制最小长度
    minLength: function(value,length,errorMsg) &#123;
        if(value.length &lt; length) &#123;
            return errorMsg;
        &#125;
    &#125;,
    // 手机号码格式
    mobileFormat: function(value,errorMsg) &#123;
        if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123;
            return errorMsg;
        &#125;
    &#125; 
&#125;;
</code></pre>
<p>然后找出变的地方，作为环境类<code>context</code>，负责接收用户的要求并委托给策略规则对象，如下<code>Validator</code>类：</p>
<pre><code class="javascript">var Validator = function()&#123;
        this.cache = [];  // 保存效验规则
&#125;;
Validator.prototype.add = function(dom,rule,errorMsg) &#123;
    var str = rule.split(&quot;:&quot;);
    this.cache.push(function()&#123;
        // str 返回的是 minLength:6 
        var strategy = str.shift();
        str.unshift(dom.value); // 把input的value添加进参数列表
        str.push(errorMsg);  // 把errorMsg添加进参数列表
        return strategys[strategy].apply(dom,str);
    &#125;);
&#125;;
Validator.prototype.start = function()&#123;
    for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123;
        var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息
        if(msg) &#123;
            return msg;
        &#125;
    &#125;
&#125;;
</code></pre>
<p>通过<code>validator.add</code>方法添加校验规则和错误信息提示，使用如下：</p>
<pre><code class="javascript">var validateFunc = function()&#123;
    var validator = new Validator(); // 创建一个Validator对象
    /* 添加一些效验规则 */
    validator.add(registerForm.userName,&#39;isNotEmpty&#39;,&#39;用户名不能为空&#39;);
    validator.add(registerForm.password,&#39;minLength:6&#39;,&#39;密码长度不能小于6位&#39;);
    validator.add(registerForm.userName,&#39;mobileFormat&#39;,&#39;手机号码格式不正确&#39;);

    var errorMsg = validator.start(); // 获得效验结果
    return errorMsg; // 返回效验结果
&#125;;
var registerForm = document.getElementById(&quot;registerForm&quot;);
registerForm.onsubmit = function()&#123;
    var errorMsg = validateFunc();
    if(errorMsg)&#123;
        alert(errorMsg);
        return false;
    &#125;
&#125;
</code></pre>
<p>上述通过策略模式完成表单的验证，并且可以随时调用，在修改表单验证规则的时候，也非常方便，通过传递参数即可调用</p>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>从上面可以看到，使用策略模式的优点有如下：</p>
<ul>
<li>策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句</li>
<li>策略模式提供了开放-封闭原则，使代码更容易理解和扩展</li>
<li>策略模式中的代码可以复用</li>
</ul>
<p>策略模式不仅仅用来封装算法，在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装 一系列的“业务规则”</p>
<p>只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>代理模式（Proxy Pattern）是为一个对象提供一个代用品或占位符，以便控制对它的访问</p>
<p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f39353163393962302d336436612d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>在生活中，代理模式的场景是十分常见的，例如我们现在如果有租房、买房的需求，更多的是去找链家等房屋中介机构，而不是直接寻找想卖房或出租房的人谈。此时，链家起到的作用就是代理的作用</p>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p>在<code>ES6</code>中，存在<code>proxy</code>构建函数能够让我们轻松使用代理模式：</p>
<pre><code class="javascript">const proxy = new Proxy(target, handler);
</code></pre>
<p>关于<code>Proxy</code>的使用可以翻看以前的文章</p>
<p>而按照功能来划分，<code>javascript</code>代理模式常用的有：</p>
<ul>
<li>缓存代理</li>
<li>虚拟代理</li>
</ul>
<h5 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h5><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</p>
<p>如实现一个求积乘的函数，如下：</p>
<pre><code class="javascript">var muti = function () &#123;
  console.log(&quot;开始计算乘积&quot;);
  var a = 1;
  for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;
    a = a * arguments[i];
  &#125;
  return a;
&#125;;
</code></pre>
<p>现在加入缓存代理，如下：</p>
<pre><code class="javascript">var proxyMult = (function () &#123;
  var cache = &#123;&#125;;
  return function () &#123;
    var args = Array.prototype.join.call(arguments, &quot;,&quot;);
    if (args in cache) &#123;
      return cache[args];
    &#125;
    return (cache[args] = mult.apply(this, arguments));
  &#125;;
&#125;)();

proxyMult(1, 2, 3, 4); // 输出:24
proxyMult(1, 2, 3, 4); // 输出:24
</code></pre>
<p>当第二次调用 <code>proxyMult(1, 2, 3, 4)</code> 时，本体 <code>mult</code> 函数并没有被计算，<code>proxyMult</code> 直接返回了之前缓存好的计算结果</p>
<h5 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h5><p>虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建</p>
<p>常见的就是图片预加载功能：</p>
<p>未使用代理模式如下：</p>
<pre><code class="javascript">let MyImage = (function()&#123;
    let imgNode = document.createElement( &#39;img&#39; );
    document.body.appendChild( imgNode );
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;

    img.onload = function()&#123;
        // 监听到图片加载完成后，设置src为加载完成后的图片
        imgNode.src = img.src;
    &#125;;

    return &#123;
        setSrc: function( src )&#123;
            // 设置图片的时候，设置为默认的loading图
            imgNode.src = &#39;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#39;;
            // 把真正需要设置的图片传给Image对象的src属性
            img.src = src;
        &#125;
    &#125;
&#125;)();

MyImage.setSrc( &#39;https://xxx.jpg&#39; );
</code></pre>
<p><code>MyImage</code>对象除了负责给<code>img</code>节点设置<code>src</code>外，还要负责预加载图片，违反了面向对象设计的原则——单一职责原则</p>
<p>上述过程<code>loding</code>则是耦合进<code>MyImage</code>对象里的，如果以后某个时候，我们不需要预加载显示loading这个功能了，就只能在<code>MyImage</code>对象里面改动代码</p>
<p>使用代理模式，代码则如下：</p>
<pre><code class="javascript">// 图片本地对象，负责往页面中创建一个img标签，并且提供一个对外的setSrc接口
let myImage = (function()&#123;
    let imgNode = document.createElement( &#39;img&#39; );
    document.body.appendChild( imgNode );

    return &#123;
        //setSrc接口，外界调用这个接口，便可以给该img标签设置src属性
        setSrc: function( src )&#123;
            imgNode.src = src;
        &#125;
    &#125;
&#125;)();
// 代理对象，负责图片预加载功能
let proxyImage = (function()&#123;
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;
    img.onload = function()&#123;
        // 监听到图片加载完成后，给被代理的图片本地对象设置src为加载完成后的图片
        myImage.setSrc( this.src );
    &#125;
    return &#123;
        setSrc: function( src )&#123;
            // 设置图片时，在图片未被真正加载好时，以这张图作为loading，提示用户图片正在加载
            myImage.setSrc( &#39;https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif&#39; );
            img.src = src;
        &#125;
    &#125;
&#125;)();

proxyImage.setSrc( &#39;https://xxx.jpg&#39; );
</code></pre>
<p>使用代理模式后，图片本地对象负责往页面中创建一个<code>img</code>标签，并且提供一个对外的<code>setSrc</code>接口；</p>
<p>代理对象负责在图片未加载完成之前，引入预加载的<code>loading</code>图，负责了图片预加载的功能</p>
<p>上述并没有改变或者增加<code>MyImage</code>的接口，但是通过代理对象，实际上给系统添加了新的行为</p>
<p>并且上述代理模式可以发现，代理和本体接口的一致性，如果有一天不需要预加载，那么就不需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了 <code>setSrc</code> 方法</p>
<p>‘</p>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>现在的很多前端框架或者状态管理框架都使用代理模式，用与监听变量的变化</p>
<p>使用代理模式代理对象的访问的方式，一般又被称为拦截器，比如我们在项目中经常使用 <code>Axios</code> 的实例来进行 HTTP 的请求，使用拦截器 <code>interceptor</code> 可以提前对 请求前的数据 服务器返回的数据进行一些预处理</p>
<p>以及上述应用到的缓存代理和虚拟代理</p>
<h3 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h3><h4 id="一、观察者模式"><a href="#一、观察者模式" class="headerlink" title="一、观察者模式"></a>一、观察者模式</h4><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p>
<p>观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f64336138303032302d336637632d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸</p>
<p>报社和订报纸的客户就形成了一对多的依赖关系</p>
<p>实现代码如下：</p>
<p>被观察者模式</p>
<pre><code class="javascript">class Subject &#123;

  constructor() &#123;
    this.observerList = [];
  &#125;

  addObserver(observer) &#123;
    this.observerList.push(observer);
  &#125;

  removeObserver(observer) &#123;
    const index = this.observerList.findIndex(o =&gt; o.name === observer.name);
    this.observerList.splice(index, 1);
  &#125;

  notifyObservers(message) &#123;
    const observers = this.observeList;
    observers.forEach(observer =&gt; observer.notified(message));
  &#125;

&#125;
</code></pre>
<p>观察者：</p>
<pre><code class="javascript">class Observer &#123;

  constructor(name, subject) &#123;
    this.name = name;
    if (subject) &#123;
      subject.addObserver(this);
    &#125;
  &#125;

  notified(message) &#123;
    console.log(this.name, &#39;got message&#39;, message);
  &#125;
&#125;
</code></pre>
<p>使用代码如下：</p>
<pre><code class="javascript">const subject = new Subject();
const observerA = new Observer(&#39;observerA&#39;, subject);
const observerB = new Observer(&#39;observerB&#39;);
subject.addObserver(observerB);
subject.notifyObservers(&#39;Hello from subject&#39;);
subject.removeObserver(observerA);
subject.notifyObservers(&#39;Hello again&#39;);
</code></pre>
<p>上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表</p>
<h4 id="二、发布订阅模式"><a href="#二、发布订阅模式" class="headerlink" title="二、发布订阅模式"></a>二、发布订阅模式</h4><p>发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在</p>
<p>同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65323464336364302d336637632d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>实现代码如下：</p>
<pre><code class="javascript">class PubSub &#123;
  constructor() &#123;
    this.messages = &#123;&#125;;
    this.listeners = &#123;&#125;;
  &#125;
  // 添加发布者
  publish(type, content) &#123;
    const existContent = this.messages[type];
    if (!existContent) &#123;
      this.messages[type] = [];
    &#125;
    this.messages[type].push(content);
  &#125;
  // 添加订阅者
  subscribe(type, cb) &#123;
    const existListener = this.listeners[type];
    if (!existListener) &#123;
      this.listeners[type] = [];
    &#125;
    this.listeners[type].push(cb);
  &#125;
  // 通知
  notify(type) &#123;
    const messages = this.messages[type];
    const subscribers = this.listeners[type] || [];
    subscribers.forEach((cb, index) =&gt; cb(messages[index]));
  &#125;
&#125;
</code></pre>
<p>发布者代码如下：</p>
<pre><code class="javascript">class Publisher &#123;
  constructor(name, context) &#123;
    this.name = name;
    this.context = context;
  &#125;
  publish(type, content) &#123;
    this.context.publish(type, content);
  &#125;
&#125;
</code></pre>
<p>订阅者代码如下：</p>
<pre><code class="javascript">class Subscriber &#123;
  constructor(name, context) &#123;
    this.name = name;
    this.context = context;
  &#125;
  subscribe(type, cb) &#123;
    this.context.subscribe(type, cb);
  &#125;
&#125;
</code></pre>
<p>使用代码如下：</p>
<pre><code class="javascript">const TYPE_A = &#39;music&#39;;
const TYPE_B = &#39;movie&#39;;
const TYPE_C = &#39;novel&#39;;

const pubsub = new PubSub();

const publisherA = new Publisher(&#39;publisherA&#39;, pubsub);
publisherA.publish(TYPE_A, &#39;we are young&#39;);
publisherA.publish(TYPE_B, &#39;the silicon valley&#39;);
const publisherB = new Publisher(&#39;publisherB&#39;, pubsub);
publisherB.publish(TYPE_A, &#39;stronger&#39;);
const publisherC = new Publisher(&#39;publisherC&#39;, pubsub);
publisherC.publish(TYPE_C, &#39;a brief history of time&#39;);

const subscriberA = new Subscriber(&#39;subscriberA&#39;, pubsub);
subscriberA.subscribe(TYPE_A, res =&gt; &#123;
  console.log(&#39;subscriberA received&#39;, res)
&#125;);
const subscriberB = new Subscriber(&#39;subscriberB&#39;, pubsub);
subscriberB.subscribe(TYPE_C, res =&gt; &#123;
  console.log(&#39;subscriberB received&#39;, res)
&#125;);
const subscriberC = new Subscriber(&#39;subscriberC&#39;, pubsub);
subscriberC.subscribe(TYPE_B, res =&gt; &#123;
  console.log(&#39;subscriberC received&#39;, res)
&#125;);

pubsub.notify(TYPE_A);
pubsub.notify(TYPE_B);
pubsub.notify(TYPE_C);
</code></pre>
<p>上述代码，发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责</p>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><p>两种设计模式思路是一样的，举个生活例子：</p>
<ul>
<li>观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体</li>
<li>发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决</li>
</ul>
<p>上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的</p>
<p>两者区别如下图：</p>
<p><img src="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f3135352f39313431363832632d373338362d346631322d383431322d6662313761316364346266362e706e67.png"></p>
<ul>
<li>在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</li>
<li>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</li>
<li>观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</li>
</ul>
<h3 id="其他完整的设计模式（感兴趣可以看看）"><a href="#其他完整的设计模式（感兴趣可以看看）" class="headerlink" title="其他完整的设计模式（感兴趣可以看看）"></a>其他完整的设计模式（感兴趣可以看看）</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904032826294286">23种设计模式</a></p>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全TypeScript"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/"
    >前端面试大全TypeScript</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/" class="article-date">
  <time datetime="2022-11-02T02:27:06.000Z" itemprop="datePublished">2022-11-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/TypeScript/">TypeScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（TypeScript）"><a href="#前端面试题大全（TypeScript）" class="headerlink" title="前端面试题大全（TypeScript）"></a>前端面试题大全（TypeScript）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-typescript-的理解？与-javascript-的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-typescript-的理解？与-javascript-的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 typescript 的理解？与 javascript 的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 typescript 的理解？与 javascript 的区别？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>TypeScript</code> 是 <code>JavaScript</code> 的类型的超集，支持<code>ES6</code>语法，支持面向对象编程的概念，如类、接口、继承、泛型等</p>
<blockquote>
<p>超集，不得不说另外一个概念，子集，怎么理解这两个呢，举个例子，如果一个集合A里面的的所有元素集合B里面都存在，那么我们可以理解集合B是集合A的超集，集合A为集合B的子集</p>
</blockquote>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36316332633166302d303935302d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>其是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误</p>
<p>同时扩展了<code> JavaScript</code> 的语法，所以任何现有的<code> JavaScript</code> 程序可以不加改变的在 <code>TypeScript</code> 下工作</p>
<p>为了保证兼容性，<code>typescript</code>在编译阶段需要编译器编译成纯<code>Javascript</code>来运行，是为大型应用之开发而设计的语言，如下：</p>
<p><code>tsx</code>文件如下：</p>
<pre><code class="typescript">const hello : string = &quot;Hello World!&quot;
console.log(hello)
</code></pre>
<p>编译文件后：</p>
<pre><code class="tsx">const hello = &quot;Hello World!&quot;
console.log(hello)
</code></pre>
<h4 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h4><p><code>typescript</code>的特性主要有如下：</p>
<ul>
<li>类型批注和编译时类型检查 ：在编译时批注变量类型</li>
<li>类型推断：ts中没有批注变量类型会自动推断变量的类型</li>
<li>类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除</li>
<li>接口：ts中用接口来定义对象类型</li>
<li>枚举：用于取值被限定在一定范围内的场景</li>
<li>Mixin：可以接受任意类型的值</li>
<li>泛型编程：写代码时使用一些以后才指定的类型</li>
<li>名字空间：名字只在该区域内有效，其他区域可重复使用该名字而不冲突</li>
<li>元组：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li>
<li>…</li>
</ul>
<h5 id="类型批注"><a href="#类型批注" class="headerlink" title="类型批注"></a>类型批注</h5><p>通过类型批注提供在编译时启动类型检查的静态类型，这是可选的，而且可以忽略而使用<code>JavaScript</code>常规的动态类型</p>
<pre><code class="tsx">function Add(left: number, right: number): number &#123;
 return left + right;
&#125;
</code></pre>
<p>对于基本类型的批注是<code>number</code>、<code>bool</code>和<code>string</code>，而弱或动态类型的结构则是<code>any</code>类型</p>
<h5 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h5><p>当类型没有给出时，TypeScript编译器利用类型推断来推断类型，如下：</p>
<pre><code class="tsx">let str = &#39;string&#39;
</code></pre>
<p>变量<code>str</code>被推断为字符串类型，这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</p>
<p>如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态<code>any</code>类型</p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口简单来说就是用来描述对象的类型 数据的类型有<code>number</code>、<code> null</code>、<code> string</code>等数据格式，对象的类型就是用接口来描述的</p>
<pre><code class="tsx">interface Person &#123;
    name: string;
    age: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25
&#125;;
</code></pre>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><ul>
<li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li>
<li>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译</li>
<li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li>
<li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件</li>
</ul>
<p>更多的区别如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36623534343034302d303935302d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-typescript-的数据类型有哪些"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-typescript-的数据类型有哪些" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ typescript 的数据类型有哪些?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ typescript 的数据类型有哪些?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>typescript</code> 和 <code>javascript</code>几乎一样，拥有相同的数据类型，另外在<code>javascript</code>基础上提供了更加实用的类型供开发使用</p>
<p>在开发阶段，可以为明确的变量定义为某种类型，这样<code>typescript</code>就能在编译阶段进行类型检查，当类型不合符预期结果的时候则会出现错误提示</p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p><code>typescript</code> 的数据类型主要有如下：</p>
<ul>
<li>boolean（布尔类型）</li>
<li>number（数字类型）</li>
<li>string（字符串类型）</li>
<li>array（数组类型）</li>
<li>tuple（元组类型）</li>
<li>enum（枚举类型）</li>
<li>any（任意类型）</li>
<li>null 和 undefined 类型</li>
<li>Symbol 类型</li>
<li>bigint类型</li>
<li>void 类型</li>
<li>never 类型</li>
<li>object 对象类型</li>
<li>unknown</li>
</ul>
<h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><p>布尔类型</p>
<pre><code class="tsx">let flag:boolean = true;
// flag = 123; // 错误
flag = false;  //正确
</code></pre>
<h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><p>数字类型，和<code>javascript</code>一样，<code>typescript</code>的数值类型都是浮点数，可支持二进制、八进制、十进制和十六进制</p>
<pre><code class="tsx">let num:number = 123;
// num = &#39;456&#39;; // 错误
num = 456;  //正确
</code></pre>
<p>进制表示：</p>
<pre><code class="tsx">let decLiteral: number = 6; // 十进制
let hexLiteral: number = 0xf00d; // 十六进制
let binaryLiteral: number = 0b1010; // 二进制
let octalLiteral: number = 0o744; // 八进制
</code></pre>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>字符串类型，和<code>JavaScript</code>一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串</p>
<pre><code class="tsx">let str:string = &#39;this is ts&#39;;
str = &#39;test&#39;;
</code></pre>
<p>作为超集，当然也可以使用模版字符串&#96;&#96;进行包裹，通过 ${} 嵌入变量</p>
<pre><code class="tsx">let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is $&#123; name &#125;
</code></pre>
<h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>数组类型，跟<code>javascript</code>一致，通过<code>[]</code>进行包裹，有两种写法：</p>
<p>方式一：元素类型后面接上 <code>[]</code></p>
<pre><code class="tsx"> let arr:string[] = [&#39;12&#39;, &#39;23&#39;];
 arr = [&#39;45&#39;, &#39;56&#39;];
</code></pre>
<p>方式二：使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<pre><code class="tsx">let arr:Array&lt;number&gt; = [1, 2];
arr = [&#39;45&#39;, &#39;56&#39;];
</code></pre>
<h5 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h5><p>元祖类型，允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p>
<pre><code class="tsx">let tupleArr:[number, string, boolean];
tupleArr = [12, &#39;34&#39;, true]; //ok
typleArr = [12, &#39;34&#39;] // no ok
</code></pre>
<p>赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致</p>
<h5 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h5><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p>
<pre><code class="tsx">enum Color &#123;Red, Green, Blue&#125;
let c: Color = Color.Green;
</code></pre>
<h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><p>可以指定任何类型的值，在编程阶段还不清楚类型的变量指定一个类型，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，这时候可以使用<code>any</code>类型</p>
<p>使用<code>any</code>类型允许被赋值为任意类型，甚至可以调用其属性、方法</p>
<pre><code class="tsx">let num:any = 123;
num = &#39;str&#39;;
num = true;
</code></pre>
<p>定义存储各种类型数据的数组时，示例代码如下：</p>
<pre><code class="tsx">let arrayList: any[] = [1, false, &#39;fine&#39;];
arrayList[1] = 100;
</code></pre>
<h5 id="null-和-和-undefined"><a href="#null-和-和-undefined" class="headerlink" title="null 和 和 undefined"></a>null 和 和 undefined</h5><p>在<code> JavaScript</code> 中 <code>null </code>表示 “什么都没有”，是一个只有一个值的特殊类型，表示一个空对象引用，而<code>undefined</code>表示一个没有设置值的变量</p>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型， 就是说你可以把 <code>null </code>和 <code>undefined </code>赋值给 <code>number </code>类型的变量</p>
<pre><code class="tsx">let num:number | undefined; // 数值类型 或者 undefined
console.log(num); // 正确
num = 123;
console.log(num); // 正确
</code></pre>
<p>但是<code>ts</code>配置了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自</p>
<h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><p>用于标识方法返回值的类型，表示该方法没有返回值。</p>
<pre><code class="tsx">function hello(): void &#123;
    alert(&quot;Hello Runoob&quot;);
&#125;
</code></pre>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>symbol我们平时用的比较少，所以可能了解也不是很多，这里就详细来说说symbol。</p>
<h6 id="（1）symbol-基本使用"><a href="#（1）symbol-基本使用" class="headerlink" title="（1）symbol 基本使用"></a>（1）symbol 基本使用</h6><p>symbol 是 ES6 新增的一种基本数据类型，它用来表示独一无二的值，可以通过 Symbol 构造函数生成。</p>
<pre><code class="typescript">const s = Symbol(); 
typeof s; // symbol
</code></pre>
<p>注意：Symbol 前面不能加 new关键字，直接调用即可创建一个独一无二的 symbol 类型的值。</p>
<p>可以在使用 Symbol 方法创建 symbol 类型值的时候传入一个参数，这个参数需要是一个字符串。如果传入的参数不是字符串，会先自动调用传入参数的 toString 方法转为字符串：</p>
<pre><code class="typescript">const s1 = Symbol(&quot;TypeScript&quot;); 
const s2 = Symbol(&quot;Typescript&quot;); 
console.log(s1 === s2); // false
</code></pre>
<p>上面代码的第三行可能会报一个错误：This condition will always return ‘false’ since the types ‘unique symbol’ and ‘unique symbol’ have no overlap. 这是因为编译器检测到这里的 s1 &#x3D;&#x3D;&#x3D; s2 始终是false，所以编译器提醒这代码写的多余，建议进行优化。</p>
<p>上面使用Symbol创建了两个symbol对象，方法中都传入了相同的字符串，但是两个symbol值仍然是false，这就说明了 Symbol 方法会返回一个独一无二的值。Symbol 方法传入的这个字符串，就是方便我们区分 symbol 值的。可以调用 symbol 值的 toString 方法将它转为字符串：</p>
<pre><code class="typescript">const s1 = Symbol(&quot;Typescript&quot;); 
console.log(s1.toString());  // &#39;Symbol(Typescript)&#39;
console.log(Boolean(s));     // true 
console.log(!s);             // false
</code></pre>
<p>在TypeScript中使用symbol就是指定一个值的类型为symbol类型：</p>
<pre><code class="typescript">let a: symbol = Symbol()
</code></pre>
<p>TypeScript 中还有一个 unique symbol 类型，它是symbol的子类型，这种类型的值只能由<code>Symbol()</code>或<code>Symbol.for()</code>创建，或者通过指定类型来指定变量是这种类型。这种类型的值只能用于常量的定义和用于属性名。需要注意，定义unique symbol类型的值，必须用 const 而不能用let来声明。下面来看在TypeScript中使用Symbol值作为属性名的例子：</p>
<pre><code class="typescript">const key1: unique symbol = Symbol()
let key2: symbol = Symbol()
const obj = &#123;
    [key1]: &#39;value1&#39;,
    [key2]: &#39;value2&#39;
&#125;
console.log(obj[key1]) // value1
console.log(obj[key2]) // error 类型“symbol”不能作为索引类型使用。
</code></pre>
<h6 id="（2）symbol-作为属性名"><a href="#（2）symbol-作为属性名" class="headerlink" title="（2）symbol 作为属性名"></a>（2）symbol 作为属性名</h6><p>在ES6中，对象的属性是支持表达式的，可以使用于一个变量来作为属性名，这对于代码的简化有很多用处，表达式必须放在大括号内：</p>
<pre><code class="typescript">let prop = &quot;name&quot;; 
const obj = &#123; 
  [prop]: &quot;TypeScript&quot; 
&#125;;
console.log(obj.name); // &#39;TypeScript&#39;
</code></pre>
<p>symbol 也可以作为属性名，因为symbol的值是独一无二的，所以当它作为属性名时，不会与其他任何属性名重复。当需要访问这个属性时，只能使用这个symbol值来访问（必须使用方括号形式来访问）：</p>
<pre><code class="typescript">let name = Symbol(); 
let obj = &#123; 
  [name]: &quot;TypeScript&quot; 
&#125;;
console.log(obj); // &#123; Symbol(): &#39;TypeScript&#39; &#125;
console.log(obj[name]); // &#39;TypeScript&#39; 
console.log(obj.name);  // undefined
</code></pre>
<p>在使用obj.name访问时，实际上是字符串name，这和访问普通字符串类型的属性名是一样的，要想访问属性名为symbol类型的属性时，必须使用方括号。方括号中的name才是我们定义的symbol类型的变量name。</p>
<h6 id="（3）symbol-属性名遍历"><a href="#（3）symbol-属性名遍历" class="headerlink" title="（3）symbol 属性名遍历"></a>（3）symbol 属性名遍历</h6><p>使用 Symbol 类型值作为属性名，这个属性是不会被 for…in遍历到的，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 、 JSON.stringify() 等方法获取到：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
for (const key in obj) &#123; 
  console.log(key); 
&#125;  
// =&gt; &#39;age&#39; 
console.log(Object.keys(obj));  // [&#39;age&#39;] 
console.log(Object.getOwnPropertyNames(obj));  // [&#39;age&#39;] 
console.log(JSON.stringify(obj)); // &#39;&#123; &quot;age&quot;: 18 &#125;
</code></pre>
<p>虽然这些方法都不能访问到Symbol类型的属性名，但是Symbol类型的属性并不是私有属性，可以使用 <code>Object.getOwnPropertySymbols</code> 方法获取对象的所有symbol类型的属性名：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
const SymbolPropNames = Object.getOwnPropertySymbols(obj); 
console.log(SymbolPropNames); // [ Symbol(name) ] 
console.log(obj[SymbolPropNames[0]]); // &#39;TypeScript&#39; 
</code></pre>
<p>除了这个方法，还可以使用ES6提供的 Reflect 对象的静态方法 Reflect.ownKeys ，它可以返回所有类型的属性名，Symbol 类型的也会返回：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
console.log(Reflect.ownKeys(obj)); // [ &#39;age&#39;, Symbol(name) ]
</code></pre>
<h6 id="（4）symbol-静态方法"><a href="#（4）symbol-静态方法" class="headerlink" title="（4）symbol 静态方法"></a>（4）symbol 静态方法</h6><p>Symbol 包含两个静态方法， for 和 keyFor 。</p>
<p>1）Symbol.for()</p>
<p>用Symbol创建的symbol类型的值都是独一无二的。使用 Symbol.for 方法传入字符串，会先检查有没有使用该字符串调用 Symbol.for 方法创建的 symbol 值。如果有，返回该值；如果没有，则使用该字符串新创建一个。使用该方法创建 symbol 值后会在全局范围进行注册。</p>
<pre><code class="typescript">const iframe = document.createElement(&quot;iframe&quot;); 
iframe.src = String(window.location); 
document.body.appendChild(iframe); 

iframe.contentWindow.Symbol.for(&quot;TypeScript&quot;) === Symbol.for(&quot;TypeScript&quot;); // true // 注意：如果你在JavaScript环境中这段代码是没有问题的，但是如果在TypeScript开发环境中，可能会报错：类型“Window”上不存在属性“Symbol”。 // 因为这里编译器推断出iframe.contentWindow是Window类型，但是TypeScript的声明文件中，对Window的定义缺少Symbol这个字段，所以会报错，
</code></pre>
<p>上面代码中，创建了一个iframe节点并把它放在body中，通过这个 iframe 对象的 contentWindow 拿到这个 iframe 的 window 对象，在 iframe.contentWindow上添加一个值就相当于在当前页面定义一个全局变量一样。可以看到，在 iframe 中定义的键为 TypeScript 的 symbol 值在和在当前页面定义的键为’TypeScript’的symbol 值相等，说明它们是同一个值。</p>
<p>2）Symbol.keyFor()</p>
<p>该方法传入一个 symbol 值，返回该值在全局注册的键名：</p>
<pre><code class="typescript">const sym = Symbol.for(&quot;TypeScript&quot;); 
console.log(Symbol.keyFor(sym)); // &#39;TypeScript&#39;
</code></pre>
<h5 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h5><p>BigInt是ES6中新引入的数据类型，它是一种内置对象，它提供了一种方法来表示大于 2- 1 的整数，BigInt可以表示任意大的整数。</p>
<p>使用 <code>BigInt</code> 可以安全地存储和操作大整数，即使这个数已经超出了JavaScript构造函数 Number 能够表示的安全整数范围。</p>
<p>我们知道，在 JavaScript 中采用双精度浮点数，这导致精度有限，比如 <code>Number.MAX_SAFE_INTEGER</code> 给出了可以安全递增的最大可能整数，即<code>2- 1</code>，来看一个例子:</p>
<pre><code class="typescript">const max = Number.MAX_SAFE_INTEGER;
const max1 = max + 1
const max2 = max + 2
max1 === max2     // true
</code></pre>
<p>可以看到，最终返回了true，这就是超过精读范围造成的问题，而<code>BigInt</code>正是解决这类问题而生的:</p>
<pre><code class="typescript">const max = BigInt(Number.MAX_SAFE_INTEGER);
const max1 = max + 1n
const max2 = max + 2n
max1 === max2    // false
</code></pre>
<p>这里需要用 <code>BigInt(number)</code> 把 Number 转化为 <code>BigInt</code>，同时如果类型是 <code>BigInt</code> ，那么数字后面需要加 <code>n</code>。</p>
<p>在TypeScript中，<code>number</code> 类型虽然和 <code>BigInt</code> 都表示数字，但是实际上两者类型是完全不同的:</p>
<pre><code class="typescript">declare let foo: number;
declare let bar: bigint;
foo = bar; // error: Type &#39;bigint&#39; is not assignable to type &#39;number&#39;.
bar = foo; // error: Type &#39;number&#39; is not assignable to type &#39;bigint&#39;.
</code></pre>
<h5 id="never"><a href="#never" class="headerlink" title="never"></a>never</h5><p><code>never</code>是其他类型 （包括<code>null</code>和 <code>undefined</code>）的子类型，可以赋值给任何类型，代表从不会出现的值</p>
<p>但是没有类型是 never 的子类型，这意味着声明 <code>never</code> 的变量只能被 <code>never</code> 类型所赋值。</p>
<p><code>never</code> 类型一般用来指定那些总是会抛出异常、无限循环</p>
<pre><code class="tsx">let a:never;
a = 123; // 错误的写法

a = (() =&gt; &#123; // 正确的写法
  throw new Error(&#39;错误&#39;);
&#125;)()

// 返回never的函数必须存在无法达到的终点
function error(message: string): never &#123;
    throw new Error(message);
&#125;
</code></pre>
<h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><p>对象类型，非原始类型，常见的形式通过<code>&#123;&#125;</code>进行包裹</p>
<pre><code class="tsx">let obj:object;
obj = &#123;name: &#39;Wang&#39;, age: 25&#125;;
</code></pre>
<h5 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h5><p>unknown 是TypeScript在3.0版本新增的类型，主要用来描述类型并不确定的变量。它看起来和any很像，但是还是有区别的，unknown相对于any更安全。</p>
<p>对于any，来看一个例子：</p>
<pre><code class="typescript">let value: any
console.log(value.name)
console.log(value.toFixed())
console.log(value.length)
</code></pre>
<p>上面这些语句都不会报错，因为value是any类型，所以后面三个操作都有合法的情况，当value是一个对象时，访问name属性是没问题的；当value是数值类型的时候，调用它的toFixed方法没问题；当value是字符串或数组时获取它的length属性是没问题的。</p>
<p>当指定值为unknown类型的时候，如果没有缩小类型范围的话，是不能对它进行任何操作的。总之，unknown类型的值不能随便操作。那什么是类型范围缩小呢？下面来看一个例子：</p>
<pre><code class="typescript">function getValue(value: unknown): string &#123;
  if (value instanceof Date) &#123; 
    return value.toISOString();
  &#125;
  return String(value);
&#125;
</code></pre>
<p>这里由于把value的类型缩小为Date实例的范围内，所以进行了value.toISOString()，也就是使用ISO标准将 Date 对象转换为字符串。</p>
<p>使用以下方式也可以缩小类型范围：</p>
<pre><code class="typescript">let result: unknown;
if (typeof result === &#39;number&#39;) &#123;
  result.toFixed();
&#125;
</code></pre>
<p>关于 unknown 类型，在使用时需要注意以下几点：</p>
<ul>
<li>任何类型的值都可以赋值给 unknown 类型：</li>
</ul>
<pre><code class="typescript">let value1: unknown;
value1 = &quot;a&quot;;
value1 = 123;
</code></pre>
<ul>
<li>unknown 不可以赋值给其它类型，只能赋值给 unknown 和 any 类型：</li>
</ul>
<pre><code class="typescript">let value2: unknown;
let value3: string = value2; // error 不能将类型“unknown”分配给类型“string”
value1 = value2;
</code></pre>
<ul>
<li>unknown 类型的值不能进行任何操作：</li>
</ul>
<pre><code class="typescript">let value4: unknown;
value4 += 1; // error 对象的类型为 &quot;unknown&quot;
</code></pre>
<ul>
<li>只能对 unknown 进行等或不等操作，不能进行其它操作：</li>
</ul>
<pre><code class="typescript">value1 === value2;
value1 !== value2;
value1 += value2;  // error
</code></pre>
<ul>
<li>unknown 类型的值不能访问其属性、作为函数调用和作为类创建实例：</li>
</ul>
<pre><code class="typescript">let value5: unknown;
value5.age;   // error
value5();     // error
new value5(); // error
</code></pre>
<p>在实际使用中，如果有类型无法确定的情况，要尽量避免使用 any，因为 any 会丢失类型信息，一旦一个类型被指定为 any，那么在它上面进行任何操作都是合法的，所以会有意想不到的情况发生。因此如果遇到无法确定类型的情况，要先考虑使用 unknown。</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>和<code>javascript</code>基本一致，也分成：</p>
<ul>
<li>基本类型</li>
<li>引用类型</li>
</ul>
<p>在基础类型上，<code>typescript</code>增添了<code>void</code>、<code>any</code>、<code>emum</code>等原始类型</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-TypeScript-中枚举类型的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-TypeScript-中枚举类型的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ TypeScript 中枚举类型的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ TypeScript 中枚举类型的理解？应用场景？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型</p>
<p>通俗来说，枚举就是一个对象的所有可能取值的集合</p>
<p>在日常生活中也很常见，例如表示星期的SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY就可以看成是一个枚举</p>
<p>枚举的说明与结构和联合相似，其形式为：</p>
<pre><code class="ini">enum 枚举名&#123;
    标识符①[=整型常数],
    标识符②[=整型常数],
    ...
    标识符N[=整型常数],
&#125;枚举变量;
</code></pre>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>枚举的使用是通过<code>enum</code>关键字进行定义，形式如下：</p>
<pre><code class="tsx">enum xxx &#123; ... &#125;
</code></pre>
<p>声明关键字为枚举类型的方式如下：</p>
<pre><code class="tsx">// 声明d为枚举类型Direction
let d: Direction;
</code></pre>
<p>类型可以分成：</p>
<ul>
<li>数字枚举</li>
<li>字符串枚举</li>
<li>异构枚举</li>
</ul>
<h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><p>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加:</p>
<pre><code class="tsx">enum Direction &#123;
    Up,   // 值默认为 0
    Down, // 值默认为 1
    Left, // 值默认为 2
    Right // 值默认为 3
&#125;

console.log(Direction.Up === 0); // true
console.log(Direction.Down === 1); // true
console.log(Direction.Left === 2); // true
console.log(Direction.Right === 3); // true
</code></pre>
<p>如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加1：</p>
<pre><code class="tsx">enum Direction &#123;
    Up = 10,
    Down,
    Left,
    Right
&#125;

console.log(Direction.Up, Direction.Down, Direction.Left, Direction.Right); // 10 11 12 13
</code></pre>
<h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><pre><code class="tsx">枚举类型的值其实也可以是字符串类型：

enum Direction &#123;
    Up = &#39;Up&#39;,
    Down = &#39;Down&#39;,
    Left = &#39;Left&#39;,
    Right = &#39;Right&#39;
&#125;

console.log(Direction[&#39;Right&#39;], Direction.Up); // Right Up
</code></pre>
<p>如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：</p>
<pre><code class="tsx">enum Direction &#123;
 Up = &#39;UP&#39;,
 Down, // error TS1061: Enum member must have initializer
 Left, // error TS1061: Enum member must have initializer
 Right // error TS1061: Enum member must have initializer
&#125;
</code></pre>
<h4 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h4><p>即将数字枚举和字符串枚举结合起来混合起来使用，如下：</p>
<pre><code class="tsx">enum BooleanLikeHeterogeneousEnum &#123;
    No = 0,
    Yes = &quot;YES&quot;,
&#125;
</code></pre>
<p>通常情况下我们很少会使用异构枚举</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>现在一个枚举的案例如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up,
    Down,
    Left,
    Right
&#125;
</code></pre>
<p>通过编译后，<code>javascript</code>如下：</p>
<pre><code class="tsx">var Direction;
(function (Direction) &#123;
    Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;;
    Direction[Direction[&quot;Down&quot;] = 1] = &quot;Down&quot;;
    Direction[Direction[&quot;Left&quot;] = 2] = &quot;Left&quot;;
    Direction[Direction[&quot;Right&quot;] = 3] = &quot;Right&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
</code></pre>
<p>上述代码可以看到， <code>Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;</code>可以分成</p>
<ul>
<li>Direction[“Up”] &#x3D; 0</li>
<li>Direction[0] &#x3D; “Up”</li>
</ul>
<p>所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up,
    Down,
    Left,
    Right
&#125;

console.log(Direction.Up === 0); // true
console.log(Direction[0]); // Up
</code></pre>
<p>并且多处定义的枚举是可以进行合并操作，如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up = &#39;Up&#39;,
    Down = &#39;Down&#39;,
    Left = &#39;Left&#39;,
    Right = &#39;Right&#39;
&#125;

enum Direction &#123;
    Center = 1
&#125;
</code></pre>
<p>编译后，<code>js</code>代码如下：</p>
<pre><code class="tsx">var Direction;
(function (Direction) &#123;
    Direction[&quot;Up&quot;] = &quot;Up&quot;;
    Direction[&quot;Down&quot;] = &quot;Down&quot;;
    Direction[&quot;Left&quot;] = &quot;Left&quot;;
    Direction[&quot;Right&quot;] = &quot;Right&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
(function (Direction) &#123;
    Direction[Direction[&quot;Center&quot;] = 1] = &quot;Center&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
</code></pre>
<p>可以看到，<code>Direction</code>对象属性回叠加</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：</p>
<pre><code class="tsx">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;

console.log(Days[&quot;Sun&quot;] === 0); // true
console.log(Days[&quot;Mon&quot;] === 1); // true
console.log(Days[&quot;Tue&quot;] === 2); // true
console.log(Days[&quot;Sat&quot;] === 6); // true
</code></pre>
<p>包括后端日常返回0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中接口的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中接口的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中接口的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中接口的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法</p>
<p>简单来讲，一个接口所描述的是一个对象相关的属性和方法，但并不提供具体创建此对象实例的方法</p>
<p><code>typescript</code>的核心功能之一就是对类型做检测，虽然这种检测方式是“鸭式辨型法”，而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定</p>
<h4 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>接口定义如下：</p>
<pre><code class="tsx">interface interface_name &#123;
&#125;
</code></pre>
<p>例如有一个函数，这个函数接受一个 <code>User</code> 对象，然后返回这个 <code>User</code> 对象的 <code>name</code> 属性:</p>
<pre><code class="tsx">const getUserName = (user) =&gt; user.name
</code></pre>
<p>可以看到，参数需要有一个<code>user</code>的<code>name</code>属性，可以通过接口描述<code>user</code>参数的结构</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
&#125;

const getUserName = (user: User) =&gt; user.name
</code></pre>
<p>这些属性并不一定全部实现，上述传入的对象必须拥有<code>name</code>和<code>age</code>属性，否则<code>typescript</code>在编译阶段会报错，如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32356433613739302d306232622d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>如果不想要<code>age</code>属性的话，这时候可以采用可选属性，如下表示：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
&#125;
</code></pre>
<p>这时候<code>age</code>属性则可以是<code>number</code>类型或者<code>undefined</code>类型</p>
<p>有些时候，我们想要一个属性变成只读属性，在<code>typescript</code>只需要使用<code>readonly</code>声明，如下：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
    readonly isMale: boolean
&#125;
</code></pre>
<p>当我们修改属性的时候，就会出现警告，如下所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32663664336333302d306232622d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>这是属性中有一个函数，可以如下表示：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
    readonly isMale: boolean
    say: (words: string) =&gt; string
&#125;
</code></pre>
<p>如果传递的对象不仅仅是上述的属性，这时候可以使用：</p>
<ul>
<li>类型推断</li>
</ul>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
&#125;

const getUserName = (user: User) =&gt; user.name
getUserName(&#123;color: &#39;yellow&#39;&#125; as User)
</code></pre>
<ul>
<li>给接口添加字符串索引签名</li>
</ul>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
    [propName: string]: any;
&#125;
</code></pre>
<p>接口还能实现继承，如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33386134313736302d306232622d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>也可以继承多个，父类通过逗号隔开，如下：</p>
<pre><code class="tsx">interface Father &#123;
    color: String
&#125;

interface Mother &#123;
    height: Number
&#125;

interface Son extends Father,Mother&#123;
    name: string
    age: Number
&#125;
</code></pre>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>例如在<code>javascript</code>中定义一个函数，用来获取用户的姓名和年龄：</p>
<pre><code class="tsx">const getUserInfo = function(user) &#123;
    // ...
    return name: $&#123;user.name&#125;, age: $&#123;user.age&#125;
&#125;
</code></pre>
<p>如果多人开发的都需要用到这个函数的时候，如果没有注释，则可能出现各种运行时的错误，这时候就可以使用接口定义参数变量：</p>
<pre><code class="tsx">// 先定义一个接口
interface IUser &#123;
  name: string;
  age: number;
&#125;

const getUserInfo = (user: IUser): string =&gt; &#123;
  return `name: $&#123;user.name&#125;, age: $&#123;user.age&#125;`;
&#125;;

// 正确的调用
getUserInfo(&#123;name: &quot;koala&quot;, age: 18&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中类的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中类的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中类的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中类的理解？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>
<blockquote>
<p>类是一种用户定义的引用数据类型，也称类类型</p>
</blockquote>
<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本</p>
<p>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多</p>
<p>但是<code> JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类</p>
<p><code>TypeScript</code> 的 <code>class</code> 支持面向对象的所有特性，比如 类、接口等</p>
<h4 id="二、使用方式-1"><a href="#二、使用方式-1" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p>
<ul>
<li>字段： 字段是类里面声明的变量。字段表示对象的有关数据。</li>
<li>构造函数： 类实例化时调用，可以为类的对象分配内存。</li>
<li>方法： 方法为对象要执行的操作</li>
</ul>
<p>如下例子：</p>
<pre><code class="tsx">class Car &#123;
    // 字段
    engine:string;

    // 构造函数
    constructor(engine:string) &#123;
        this.engine = engine
    &#125;

    // 方法
    disp():void &#123;
        console.log(&quot;发动机为 :   &quot;+this.engine)
    &#125;
&#125;
</code></pre>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>类的继承使用过<code>extends</code>的关键字</p>
<pre><code class="tsx">class Animal &#123;
    move(distanceInMeters: number = 0) &#123;
        console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);
    &#125;
&#125;

class Dog extends Animal &#123;
    bark() &#123;
        console.log(&#39;Woof! Woof!&#39;);
    &#125;
&#125;

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
</code></pre>
<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 超类</p>
<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法</p>
<p>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写，通过<code>super</code>关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>
<pre><code class="tsx">class PrinterClass &#123;
   doPrint():void &#123;
      console.log(&quot;父类的 doPrint() 方法。&quot;)
   &#125;
&#125;

class StringPrinter extends PrinterClass &#123;
   doPrint():void &#123;
      super.doPrint() // 调用父类的函数
      console.log(&quot;子类的 doPrint()方法。&quot;)
   &#125;
&#125;
</code></pre>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>可以看到，上述的形式跟<code>ES6</code>十分的相似，<code>typescript</code>在此基础上添加了三种修饰符：</p>
<ul>
<li>公共 public：可以自由的访问类程序里定义的成员</li>
<li>私有 private：只能够在该类的内部进行访问</li>
<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>
</ul>
<h6 id="私有修饰符"><a href="#私有修饰符" class="headerlink" title="私有修饰符"></a>私有修饰符</h6><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66353733363566302d306362342d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>并且继承该类的子类并不能访问，如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30303732636332302d306362352d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h6 id="受保护修饰符"><a href="#受保护修饰符" class="headerlink" title="受保护修饰符"></a>受保护修饰符</h6><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30396537323538302d306362352d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31333766383161302d306362352d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>除了上述修饰符之外，还有只读修饰符</p>
<h6 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h6><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/f0885f89e9d2d9bc7aa7acd9b815cd6f447ab2ed9d3a5c4df4ccd6974599bf53/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31653834386432302d306362352d313165632d386536342d3931666465633066303561312e706e67"><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31653834386432302d306362352d313165632d386536342d3931666465633066303561312e706e67.png" alt="img"></a></p>
<p>除了实例属性之外，同样存在静态属性</p>
<h6 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h6><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示：</p>
<pre><code class="tsx">class Square &#123;
    static width = &#39;100px&#39;
&#125;

console.log(Square.width) // 100px
</code></pre>
<p>上述的类都能发现一个特点就是，都能够被实例化，在 <code>typescript</code>中，还存在一种抽象类</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节</p>
<p><code>abstract </code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>
<pre><code class="tsx">abstract class Animal &#123;
    abstract makeSound(): void;
    move(): void &#123;
        console.log(&#39;roaming the earch...&#39;);
    &#125;
&#125;
</code></pre>
<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>
<pre><code class="tsx">class Cat extends Animal &#123;

    makeSound() &#123;
        console.log(&#39;miao miao&#39;)
    &#125;
&#125;

const cat = new Cat()

cat.makeSound() // miao miao
cat.move() // roaming the earch...
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在 <code>React</code> 工程中是很常用的，如下：</p>
<pre><code class="tsx">export default class Carousel extends React.Component&lt;Props, State&gt; &#123;&#125;
</code></pre>
<p>由于组件需要传入 <code>props</code> 的类型 <code>Props</code> ，同时有需要设置默认 <code>props</code> 即 <code>defaultProps</code>，这时候更加适合使用<code>class</code>作为接口</p>
<p>先声明一个类，这个类包含组件 <code>props</code> 所需的类型和初始值：</p>
<pre><code class="tsx">// props的类型
export default class Props &#123;
  public children: Array&lt;React.ReactElement&lt;any&gt;&gt; | React.ReactElement&lt;any&gt; | never[] = []
  public speed: number = 500
  public height: number = 160
  public animation: string = &#39;easeInOutQuad&#39;
  public isAuto: boolean = true
  public autoPlayInterval: number = 4500
  public afterChange: () =&gt; &#123;&#125;
  public beforeChange: () =&gt; &#123;&#125;
  public selesctedColor: string
  public showDots: boolean = true
&#125;
</code></pre>
<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>
<pre><code class="tsx">public static defaultProps = new Props()
</code></pre>
<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class </code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中函数的理解？与-JavaScript-函数的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中函数的理解？与-JavaScript-函数的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中函数的理解？与 JavaScript 函数的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>函数是<code> JavaScript</code> 应用程序的基础，帮助我们实现抽象层、模拟类、信息隐藏和模块</p>
<p>在<code> TypeScript</code> 里，虽然已经支持类、命名空间和模块，但函数仍然是主要定义行为的方式，<code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，丰富了更多的应用场景</p>
<p>函数类型在 <code>TypeScript</code> 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块</p>
<h4 id="二、使用方式-2"><a href="#二、使用方式-2" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>跟<code>javascript</code> 定义函数十分相似，可以通过<code>funciton</code> 关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>
<pre><code class="tsx">const add = (a: number, b: number) =&gt; a + b
</code></pre>
<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上<code> TypeScript</code> 编译器是能够通过类型推断到这个函数的类型，如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34623334313562302d306434322d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>当鼠标放置在第三行<code>add</code>函数名的时候，会出现完整的函数定义类型，通过<code>:</code> 的形式来定于参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>
<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>
<pre><code class="tsx">// 方式一
type LongHand = &#123;
  (a: number): number;
&#125;;

// 方式二
type ShortHand = (a: number) =&gt; number;
</code></pre>
<p>当存在函数重载时，只能使用方式一的形式</p>
<h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>
<pre><code class="tsx">const add = (a: number, b?: number) =&gt; a + (b ? b : 0)
</code></pre>
<p>这时候参数<code>b</code>可以是<code>number</code>类型或者<code>undefined</code>类型，即可以传一个<code>number</code>类型或者不传都可以</p>
<h5 id="剩余类型"><a href="#剩余类型" class="headerlink" title="剩余类型"></a>剩余类型</h5><p>剩余参数与<code>JavaScript</code>的语法类似，需要用 <code>...</code> 来表示剩余参数</p>
<p>如果剩余参数 <code>rest</code> 是一个由<code>number</code>类型组成的数组，则如下表示：</p>
<pre><code class="tsx">const add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a)
</code></pre>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>
<p>关于<code>typescript</code>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|</code>操作符或者<code>?</code>操作符，把所有可能的输入类型全部包含进去，用于具体实现</p>
<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，<code>typescript</code>并不会真的将你的多个重名 <code>function </code>的函数体进行合并</p>
<p>例如我们有一个add函数，它可以接收 <code>string</code>类型的参数进行拼接，也可以接收 <code>number</code> 类型的参数进行相加，如下：</p>
<pre><code class="tsx">// 上边是声明
function add (arg1: string, arg2: string): string
function add (arg1: number, arg2: number): number
// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字

// 下边是实现
function add (arg1: string | number, arg2: string | number) &#123;
  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2
  if (typeof arg1 === &#39;string&#39; &amp;&amp; typeof arg2 === &#39;string&#39;) &#123;
    return arg1 + arg2
  &#125; else if (typeof arg1 === &#39;number&#39; &amp;&amp; typeof arg2 === &#39;number&#39;) &#123;
    return arg1 + arg2
  &#125;
&#125;
</code></pre>
<h4 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h4><p>从上面可以看到：</p>
<ul>
<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>
<li>typescript 在参数中，添加可选参数供使用者选择</li>
<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中泛型的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中泛型的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中泛型的理解？应用场景？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p>
<p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型<br>在<code>typescript</code>中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性</p>
<p>假设我们用一个函数，它可接受一个 <code>number</code> 参数并返回一个<code> number</code> 参数，如下写法：</p>
<pre><code class="tsx">function returnItem (para: number): number &#123;
    return para
&#125;
</code></pre>
<p>如果我们打算接受一个 <code>string</code> 类型，然后再返回 <code>string</code>类型，则如下写法：</p>
<pre><code class="tsx">function returnItem (para: string): string &#123;
    return para
&#125;
</code></pre>
<p>上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高</p>
<p>虽然可以使用 <code>any</code>类型去替代，但这也并不是很好的方案，因为我们的目的是接收什么类型的参数返回什么类型的参数，即在运行时传入参数我们才能确定类型</p>
<p>这种情况就可以使用泛型，如下所示：</p>
<pre><code class="tsx">function returnItem&lt;T&gt;(para: T): T &#123;
    return para
&#125;
</code></pre>
<p>可以看到，泛型给予开发者创造灵活、可重用代码的能力</p>
<h4 id="二、使用方式-3"><a href="#二、使用方式-3" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明：</p>
<ul>
<li>函数</li>
<li>接口</li>
<li>类</li>
</ul>
<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>声明函数的形式如下：</p>
<pre><code class="tsx">function returnItem&lt;T&gt;(para: T): T &#123;
    return para
&#125;
</code></pre>
<p>定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 <code>T</code> 和 泛型 <code>U</code>：</p>
<pre><code class="tsx">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;
    return [tuple[1], tuple[0]];
&#125;

swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]
</code></pre>
<h5 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h5><p>声明接口的形式如下：</p>
<pre><code class="tsx">interface ReturnItemFn&lt;T&gt; &#123;
    (para: T): T
&#125;
</code></pre>
<p>那么当我们想传入一个number作为参数的时候，就可以这样声明函数:</p>
<pre><code class="tsx">const returnItem: ReturnItemFn&lt;number&gt; = para =&gt; para
</code></pre>
<h5 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h5><p>使用泛型声明类的时候，既可以作用于类本身，也可以作用与类的成员函数</p>
<p>下面简单实现一个元素同类型的栈结构，如下所示：</p>
<pre><code class="tsx">class Stack&lt;T&gt; &#123;
    private arr: T[] = []
    public push(item: T) &#123;
        this.arr.push(item)
    &#125;
    public pop() &#123;
        this.arr.pop()
    &#125;
&#125;
</code></pre>
<p>使用方式如下：</p>
<pre><code class="tsx">const stack = new Stacn&lt;number&gt;()
</code></pre>
<p>如果上述只能传递 <code>string</code> 和 <code>number</code> 类型，这时候就可以使用 <code>&lt;T extends xx&gt;</code> 的方式猜实现约束泛型，如下所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36376432313261302d306531372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>除了上述的形式，泛型更高级的使用如下：</p>
<p>例如要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值</p>
<p>这时候就设计到泛型的索引类型和约束类型共同实现</p>
<h5 id="索引类型、约束类型"><a href="#索引类型、约束类型" class="headerlink" title="索引类型、约束类型"></a>索引类型、约束类型</h5><p>索引类型 <code>keyof T</code> 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，如下所示：</p>
<pre><code class="tsx">function getValue&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) &#123;
  return obj[key] // ok
&#125;
</code></pre>
<p>上述为什么需要使用泛型约束，而不是直接定义第一个参数为 <code>object</code>类型，是因为默认情况 <code>object</code> 指的是<code>&#123;&#125;</code>，而我们接收的对象是各种各样的，一个泛型来表示传入的对象类型，比如 <code>T extends object</code></p>
<p>使用如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37346663626434302d306531372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="多类型约束"><a href="#多类型约束" class="headerlink" title="多类型约束"></a>多类型约束</h5><p>例如如下需要实现两个接口的类型约束：</p>
<pre><code class="tsx">interface FirstInterface &#123;
  doSomething(): number
&#125;

interface SecondInterface &#123;
  doSomethingElse(): string
&#125;
</code></pre>
<p>可以创建一个接口继承上述两个接口，如下：</p>
<pre><code class="tsx">interface ChildInterface extends FirstInterface, SecondInterface &#123;

&#125;
</code></pre>
<p>正确使用如下：</p>
<pre><code class="tsx">class Demo&lt;T extends ChildInterface&gt; &#123;
  private genericProperty: T

  constructor(genericProperty: T) &#123;
    this.genericProperty = genericProperty
  &#125;
  useT() &#123;
    this.genericProperty.doSomething()
    this.genericProperty.doSomethingElse()
  &#125;
&#125;
</code></pre>
<p>通过泛型约束就可以达到多类型约束的目的</p>
<h4 id="三、应用场景-3"><a href="#三、应用场景-3" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>通过上面初步的了解，后述在编写 <code>typescript</code> 的时候，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性的时候，这种情况下就可以使用泛型</p>
<p>灵活的使用泛型定义类型，是掌握<code>typescript</code> 必经之路</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中高级类型的理解？有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中高级类型的理解？有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中高级类型的理解？有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中高级类型的理解？有哪些？</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>除了<code>string</code>、<code>number</code>、<code>boolean</code> 这种基础类型外，在 <code>typescript</code> 类型声明中还存在一些高级的类型应用</p>
<p>这些高级类型，是<code>typescript</code>为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景</p>
<h4 id="二、有哪些-1"><a href="#二、有哪些-1" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的高级类型有如下：</p>
<ul>
<li>交叉类型</li>
<li>联合类型</li>
<li>类型别名</li>
<li>类型索引</li>
<li>类型约束</li>
<li>映射类型</li>
<li>条件类型</li>
</ul>
<h5 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h5><p>通过 <code>&amp;</code> 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作</p>
<p>语法如下：</p>
<pre><code class="ini">T &amp; U
</code></pre>
<p>适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：</p>
<pre><code class="tsx">function extend&lt;T , U&gt;(first: T, second: U) : T &amp; U &#123;
    let result: &lt;T &amp; U&gt; = &#123;&#125;
    for (let key in first) &#123;
        result[key] = first[key]
    &#125;
    for (let key in second) &#123;
        if(!result.hasOwnProperty(key)) &#123;
            result[key] = second[key]
        &#125;
    &#125;
    return result
&#125;
</code></pre>
<h5 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h5><p>联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系</p>
<p>语法如下：</p>
<pre><code class="ini">T | U
</code></pre>
<p>例如 <code>number</code> | <code>string</code> | <code>boolean</code> 的类型只能是这三个的一种，不能共存</p>
<p>如下所示：</p>
<pre><code class="tsx">function formatCommandline(command: string[] | string) &#123;
  let line = &#39;&#39;;
  if (typeof command === &#39;string&#39;) &#123;
    line = command.trim();
  &#125; else &#123;
    line = command.join(&#39; &#39;).trim();
  &#125;
&#125;
</code></pre>
<h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型</p>
<p>可以使用 <code>type SomeName = someValidTypeAnnotation</code>的语法来创建类型别名：</p>
<pre><code class="tsx">type some = boolean | string

const b: some = true // ok
const c: some = &#39;hello&#39; // ok
const d: some = 123 // 不能将类型“123”分配给类型“some”
</code></pre>
<p>此外类型别名可以是泛型:</p>
<pre><code class="tsx">type Container&lt;T&gt; = &#123; value: T &#125;;
</code></pre>
<p>也可以使用类型别名来在属性里引用自己：</p>
<pre><code class="tsx">type Tree&lt;T&gt; = &#123;
    value: T;
    left: Tree&lt;T&gt;;
    right: Tree&lt;T&gt;;
&#125;
</code></pre>
<p>可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数</p>
<p>两者最大的区别在于，<code>interface </code>只能用于定义对象类型，而 <code>type</code> 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛</p>
<h5 id="类型索引"><a href="#类型索引" class="headerlink" title="类型索引"></a>类型索引</h5><p><code>keyof</code> 类似于 <code>Object.keys</code> ，用于获取一个接口中 Key 的联合类型。</p>
<pre><code class="tsx">interface Button &#123;
    type: string
    text: string
&#125;

type ButtonKeys = keyof Button
// 等效于
type ButtonKeys = &quot;type&quot; | &quot;text&quot;
</code></pre>
<h5 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h5><p>通过关键字 <code>extend</code> 进行约束，不同于在 <code>class</code> 后使用 <code>extends</code> 的继承作用，泛型内使用的主要作用是对泛型加以约束</p>
<pre><code class="tsx">type BaseType = string | number | boolean

// 这里表示 copy 的参数
// 只能是字符串、数字、布尔这几种基础类型
function copy&lt;T extends BaseType&gt;(arg: T): T &#123;
  return arg
&#125;
</code></pre>
<p>类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 <code>extends</code> 和 <code>keyof</code> 进行约束。</p>
<pre><code class="tsx">function getValue&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123;
  return obj[key]
&#125;

const obj = &#123; a: 1 &#125;
const a = getValue(obj, &#39;a&#39;)
</code></pre>
<h5 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h5><p>通过 <code>in</code> 关键字做类型的映射，遍历已有接口的 <code>key</code> 或者是遍历联合类型，如下例子：</p>
<pre><code class="tsx">type Readonly&lt;T&gt; = &#123;
    readonly [P in keyof T]: T[P];
&#125;;

interface Obj &#123;
  a: string
  b: string
&#125;

type ReadOnlyObj = Readonly&lt;Obj&gt;
</code></pre>
<p>上述的结构，可以分成这些步骤：</p>
<ul>
<li>keyof T：通过类型索引 keyof 的得到联合类型 ‘a’ | ‘b’</li>
<li>P in keyof T 等同于 p in ‘a’ | ‘b’，相当于执行了一次 forEach 的逻辑，遍历 ‘a’ | ‘b’</li>
</ul>
<p>所以最终<code>ReadOnlyObj</code>的接口为下述：</p>
<pre><code class="tsx">interface ReadOnlyObj &#123;
    readonly a: string;
    readonly b: string;
&#125;
</code></pre>
<h5 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h5><p>条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。</p>
<pre><code class="tsx">T extends U ? X : Y
</code></pre>
<p>上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y</p>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，如果只是掌握了 <code>typeScript</code> 的一些基础类型，可能很难游刃有余的去使用 <code>typeScript</code>，需要了解一些<code>typescript</code>的高阶用法</p>
<p>并且<code>typescript</code>在版本的迭代中新增了很多功能，需要不断学习与掌握</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-装饰器的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-装饰器的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 装饰器的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 装饰器的理解？应用场景？</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上</p>
<p>是一种在不改变原类和使用继承的情况下，动态地扩展对象功能</p>
<p>同样的，本质也不是什么高大上的结构，就是一个普通的函数，<code>@expression</code> 的形式其实是<code>Object.defineProperty</code>的语法糖</p>
<p><code>expression </code>求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p>
<h4 id="二、使用方式-4"><a href="#二、使用方式-4" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>由于<code>typescript</code>是一个实验性特性，若要使用，需要在<code>tsconfig.json</code>文件启动，如下：</p>
<pre><code class="tsx">&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;ES5&quot;,
        &quot;experimentalDecorators&quot;: true
    &#125;
&#125;
</code></pre>
<p><code>typescript</code>装饰器的使用和<code>javascript</code>基本一致</p>
<p>类的装饰器可以装饰：</p>
<ul>
<li>类</li>
<li>方法&#x2F;属性</li>
<li>参数</li>
<li>访问器</li>
</ul>
<h5 id="类装饰"><a href="#类装饰" class="headerlink" title="类装饰"></a>类装饰</h5><p>例如声明一个函数 <code>addAge</code> 去给 Class 的属性 <code>age</code> 添加年龄.</p>
<pre><code class="tsx">function addAge(constructor: Function) &#123;
  constructor.prototype.age = 18;
&#125;

@addAge
class Person&#123;
  name: string;
  age!: number;
  constructor() &#123;
    this.name = &#39;huihui&#39;;
  &#125;
&#125;

let person = new Person();

console.log(person.age); // 18
</code></pre>
<p>上述代码，实际等同于以下形式：</p>
<pre><code class="tsx">Person = addAge(function Person() &#123; ... &#125;);
</code></pre>
<p>上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 <code>constructor.prototype.age</code> 就是在每一个实例化对象上面添加一个 <code>age</code> 属性</p>
<h5 id="方法-x2F-属性装饰"><a href="#方法-x2F-属性装饰" class="headerlink" title="方法&#x2F;属性装饰"></a>方法&#x2F;属性装饰</h5><p>同样，装饰器可以用于修饰类的方法，这时候装饰器函数接收的参数变成了：</p>
<ul>
<li>target：对象的原型</li>
<li>propertyKey：方法的名称</li>
<li>descriptor：方法的属性描述符</li>
</ul>
<p>可以看到，这三个属性实际就是<code>Object.defineProperty</code>的三个参数，如果是类的属性，则没有传递第三个参数</p>
<p>如下例子：</p>
<pre><code class="tsx">// 声明装饰器修饰方法/属性
function method(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;
  console.log(target);
  console.log(&quot;prop &quot; + propertyKey);
  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);
  descriptor.writable = false;
&#125;;

function property(target: any, propertyKey: string) &#123;
  console.log(&quot;target&quot;, target)
  console.log(&quot;propertyKey&quot;, propertyKey)
&#125;

class Person&#123;
 @property
 name: string;
 constructor() &#123;
   this.name = &#39;huihui&#39;;
 &#125;

 @method
 say()&#123;
   return &#39;instance method&#39;;
 &#125;

 @method
 static run()&#123;
   return &#39;static method&#39;;
 &#125;
&#125;

const xmz = new Person();

// 修改实例方法say
xmz.say = function() &#123;
 return &#39;edit&#39;
&#125;
</code></pre>
<p>输出如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65393662633162302d313134642d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h5 id="参数装饰"><a href="#参数装饰" class="headerlink" title="参数装饰"></a>参数装饰</h5><p>接收3个参数，分别是：</p>
<ul>
<li>target ：当前对象的原型</li>
<li>propertyKey ：参数的名称</li>
<li>index：参数数组中的位置</li>
</ul>
<pre><code class="tsx">function logParameter(target: Object, propertyName: string, index: number) &#123;
  console.log(target);
  console.log(propertyName);
  console.log(index);
&#125;

class Employee &#123;
  greet(@logParameter message: string): string &#123;
      return `hello $&#123;message&#125;`;
  &#125;
&#125;
const emp = new Employee();
emp.greet(&#39;hello&#39;);
</code></pre>
<p>输入如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326633326465302d313134642d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="访问器装饰"><a href="#访问器装饰" class="headerlink" title="访问器装饰"></a>访问器装饰</h5><p>使用起来方式与方法装饰一致，如下：</p>
<pre><code class="tsx">function modification(target: Object, propertyKey: string, descriptor: PropertyDescriptor) &#123;
  console.log(target);
  console.log(&quot;prop &quot; + propertyKey);
  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);
&#125;;

class Person&#123;
 _name: string;
 constructor() &#123;
   this._name = &#39;huihui&#39;;
 &#125;

 @modification
 get name() &#123;
   return this._name
 &#125;
&#125;
</code></pre>
<h5 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h5><p>如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：</p>
<pre><code class="tsx">function addAge(age: number) &#123;
  return function(constructor: Function) &#123;
    constructor.prototype.age = age
  &#125;
&#125;

@addAge(10)
class Person&#123;
  name: string;
  age!: number;
  constructor() &#123;
    this.name = &#39;huihui&#39;;
  &#125;
&#125;

let person = new Person();
</code></pre>
<h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><p>当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用，例如如下：</p>
<pre><code class="tsx">function f() &#123;
    console.log(&quot;f(): evaluated&quot;);
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123;
        console.log(&quot;f(): called&quot;);
    &#125;
&#125;

function g() &#123;
    console.log(&quot;g(): evaluated&quot;);
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123;
        console.log(&quot;g(): called&quot;);
    &#125;
&#125;

class C &#123;
    @f()
    @g()
    method() &#123;&#125;
&#125;

// 输出
f(): evaluated
g(): evaluated
g(): called
f(): called
</code></pre>
<h4 id="三、应用场景-4"><a href="#三、应用场景-4" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>可以看到，使用装饰器存在两个显著的优点：</p>
<ul>
<li>代码可读性变强了，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原来功能进行扩展</li>
</ul>
<p>后面的使用场景中，借助装饰器的特性，除了提高可读性之后，针对已经存在的类，可以通过装饰器的特性，在不改变原有代码情况下，对原来功能进行扩展</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中命名空间与模块的理解？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中命名空间与模块的理解？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中命名空间与模块的理解？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中命名空间与模块的理解？区别？</h3><h4 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h4><p><code>TypeScript</code> 与<code> ECMAScript</code> 2015 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块</p>
<p>相反地，如果一个文件不带有顶级的<code>import</code>或者<code>export</code>声明，那么它的内容被视为全局可见的</p>
<p>例如我们在在一个 <code>TypeScript</code> 工程下建立一个文件 <code>1.ts</code>，声明一个变量<code>a</code>，如下：</p>
<pre><code class="tsx">const a = 1
</code></pre>
<p>然后在另一个文件同样声明一个变量<code>a</code>，这时候会出现错误信息</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61323339643937302d313337652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>提示重复声明<code>a</code>变量，但是所处的空间是全局的</p>
<p>如果需要解决这个问题，则通过<code>import</code>或者<code>export</code>引入模块系统即可，如下：</p>
<pre><code class="tsx">const a = 10;

export default a
</code></pre>
<p>在<code>typescript</code>中，<code>export</code>关键字可以导出变量或者类型，用法与<code>es6</code>模块一致，如下：</p>
<pre><code class="tsx">export const a = 1
export type Person = &#123;
    name: String
&#125;
</code></pre>
<p>通过<code>import</code> 引入模块，如下：</p>
<pre><code class="tsx">import &#123; a, Person &#125; from &#39;./export&#39;;
</code></pre>
<h4 id="二、命名空间"><a href="#二、命名空间" class="headerlink" title="二、命名空间"></a>二、命名空间</h4><p>命名空间一个最明确的目的就是解决重名问题</p>
<p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的</p>
<p>这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p>
<p><code>TypeScript</code> 中命名空间使用 <code>namespace</code> 来定义，语法格式如下：</p>
<pre><code class="tsx">namespace SomeNameSpaceName &#123;
   export interface ISomeInterfaceName &#123;      &#125;
   export class SomeClassName &#123;      &#125;
&#125;
</code></pre>
<p>以上定义了一个命名空间 <code>SomeNameSpaceName</code>，如果我们需要在外部可以调用 <code>SomeNameSpaceName</code> 中的类和接口，则需要在类和接口添加 <code>export</code> 关键字</p>
<p>使用方式如下：</p>
<pre><code class="ini">SomeNameSpaceName.SomeClassName
</code></pre>
<p>命名空间本质上是一个对象，作用是将一系列相关的全局变量组织到一个对象的属性，如下：</p>
<pre><code class="tsx">namespace Letter &#123;
  export let a = 1;
  export let b = 2;
  export let c = 3;
  // ...
  export let z = 26;
&#125;
</code></pre>
<p>编译成<code>js</code>如下：</p>
<pre><code class="tsx">var Letter;
(function (Letter) &#123;
    Letter.a = 1;
    Letter.b = 2;
    Letter.c = 3;
    // ...
    Letter.z = 26;
&#125;)(Letter || (Letter = &#123;&#125;));
</code></pre>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><ul>
<li>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中</li>
<li>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖</li>
<li>在正常的TS项目开发过程中并不建议用命名空间，但通常在通过 d.ts 文件标记 js 库类型的时候使用命名空间，主要作用是给编译器编写代码的时候参考使用</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在Vue项目中应用TypeScript？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在Vue项目中应用TypeScript？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Vue项目中应用TypeScript？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Vue项目中应用TypeScript？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>与link类似</p>
<p>在<code>VUE</code>项目中应用<code>typescript</code>，我们需要引入一个库<code>vue-property-decorator</code>，</p>
<p>其是基于<code>vue-class-component</code>库而来，这个库<code>vue</code>官方推出的一个支持使用<code>class</code>方式来开发<code>vue</code>单文件组件的库</p>
<p>主要的功能如下：</p>
<ul>
<li>methods 可以直接声明为类的成员方法</li>
<li>计算属性可以被声明为类的属性访问器</li>
<li>初始化的 data 可以被声明为类属性</li>
<li>data、render 以及所有的 Vue 生命周期钩子可以直接作为类的成员方法</li>
<li>所有其他属性，需要放在装饰器中</li>
</ul>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p>vue-property-decorator 主要提供了多个装饰器和一个函数:</p>
<ul>
<li>@prop</li>
<li>@ProPsync</li>
<li>@model</li>
<li>@watch</li>
<li>@provide</li>
<li>@Inject</li>
<li>@ProvideReactive</li>
<li>@InjectReactive</li>
<li>@emit</li>
<li>@ref</li>
<li>@component (由 vue-class-component 提供)</li>
<li>Mixins (由 vue-class-component 提供)</li>
</ul>
<h5 id="component"><a href="#component" class="headerlink" title="@component"></a><a target="_blank" rel="noopener" href="https://github.com/component">@component</a></h5><p><code>Component</code>装饰器它注明了此类为一个<code>Vue</code>组件，因此即使没有设置选项也不能省略</p>
<p>如果需要定义比如 <code>name</code>、<code>components</code>、<code>filters</code>、<code>directives</code>以及自定义属性，就可以在<code>Component</code>装饰器中定义，如下：</p>
<pre><code class="tsx">import &#123;Component,Vue&#125; from &#39;vue-property-decorator&#39;;
import &#123;componentA,componentB&#125; from &#39;@/components&#39;;

 @Component(&#123;
    components:&#123;
        componentA,
        componentB,
    &#125;,
    directives: &#123;
        focus: &#123;
            // 指令的定义
            inserted: function (el) &#123;
                el.focus()
            &#125;
        &#125;
    &#125;
&#125;)
export default class YourCompoent extends Vue&#123;
   
&#125;
</code></pre>
<h5 id="computed、data、methods"><a href="#computed、data、methods" class="headerlink" title="computed、data、methods"></a>computed、data、methods</h5><p>这里取消了组件的data和methods属性，以往data返回对象中的属性、methods中的方法需要直接定义在Class中，当做类的属性和方法</p>
<pre><code class="tsx">@Component
export default class HelloDecorator extends Vue &#123;
    count: number = 123 // 类属性相当于以前的 data

    add(): number &#123; // 类方法就是以前的方法
        this.count + 1
    &#125;

    // 获取计算属性
    get total(): number &#123;
      return this.count + 1
    &#125;

    // 设置计算属性
    set total(param:number): void &#123;
      this.count = param
    &#125;
&#125;
</code></pre>
<h5 id="props"><a href="#props" class="headerlink" title="@props"></a><a target="_blank" rel="noopener" href="https://github.com/props">@props</a></h5><p>组件接收属性的装饰器，如下使用：</p>
<pre><code class="tsx">import &#123;Component,Vue,Prop&#125; from vue-property-decorator;

@Component
export default class YourComponent extends Vue &#123;
    @Prop(String)
    propA:string;
    
    @Prop([String,Number])
    propB:string|number;
    
    @Prop(&#123;
     type: String, // type: [String , Number]
     default: &#39;default value&#39;, // 一般为String或Number
      //如果是对象或数组的话。默认值从一个工厂函数中返回
      // defatult: () =&gt; &#123;
      //     return [&#39;a&#39;,&#39;b&#39;]
      // &#125;
     required: true,
     validator: (value) =&gt; &#123;
        return [
          &#39;InProcess&#39;,
          &#39;Settled&#39;
        ].indexOf(value) !== -1
     &#125;
    &#125;)
    propC:string;
&#125;
</code></pre>
<h5 id="watch"><a href="#watch" class="headerlink" title="@watch"></a><a target="_blank" rel="noopener" href="https://github.com/watch">@watch</a></h5><p>实际就是<code>Vue</code>中的监听器，如下：</p>
<pre><code class="tsx">import &#123; Vue, Component, Watch &#125; from &#39;vue-property-decorator&#39;

@Component
export default class YourComponent extends Vue &#123;
  @Watch(&#39;child&#39;)
  onChildChanged(val: string, oldVal: string) &#123;&#125;

  @Watch(&#39;person&#39;, &#123; immediate: true, deep: true &#125;)
  onPersonChanged1(val: Person, oldVal: Person) &#123;&#125;

  @Watch(&#39;person&#39;)
  onPersonChanged2(val: Person, oldVal: Person) &#123;&#125;
&#125;
</code></pre>
<h5 id="emit"><a href="#emit" class="headerlink" title="@emit"></a><a target="_blank" rel="noopener" href="https://github.com/emit">@emit</a></h5><p><code>vue-property-decorator</code> 提供的 <code>@Emit</code> 装饰器就是代替<code>Vue </code>中的事件的触发<code>$emit</code>，如下：</p>
<pre><code class="tsx">import &#123;Vue, Component, Emit&#125; from &#39;vue-property-decorator&#39;;
    @Component(&#123;&#125;)
    export default class Some extends Vue&#123;
        mounted()&#123;
            this.$on(&#39;emit-todo&#39;, function(n) &#123;
                console.log(n)
            &#125;)
            this.emitTodo(&#39;world&#39;);
        &#125;
        @Emit()
        emitTodo(n: string)&#123;
            console.log(&#39;hello&#39;);
        &#125;
    &#125;
</code></pre>
<h4 id="三-、总结"><a href="#三-、总结" class="headerlink" title="三 、总结"></a>三 、总结</h4><p>可以看到上述<code>typescript</code>版本的<code>vue class</code>的语法与平时<code>javascript</code>版本使用起来还是有很大的不同，多处用到<code>class</code>与装饰器，但实际上本质是一致的，只有不断编写才会得心应手</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在React项目中应用TypeScript？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在React项目中应用TypeScript？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在React项目中应用TypeScript？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在React项目中应用TypeScript？</h3><h4 id="一、前言-1"><a href="#一、前言-1" class="headerlink" title="一、前言"></a>一、前言</h4><p>单独的使用 <code>TypeScript</code> 并不会导致学习成本很高，但是绝大部分前端开发者的项目都是依赖于框架的</p>
<p>例如与 <code>Vue</code>、<code>React</code> 这些框架结合使用的时候，会有一定的门槛</p>
<p>使用 <code>TypeScript</code> 编写 <code>React</code> 代码，除了需要 <code>TypeScript</code> 这个库之外，还需要安装 <code>@types/react</code>、<code>@types/react-dom</code></p>
<pre><code class="bash">npm i @types/react -s

npm i @types/react-dom -s
</code></pre>
<p>至于上述使用 <code>@types</code> 的库的原因在于，目前非常多的 <code>JavaScript</code> 库并没有提供自己关于 <code>TypeScript</code> 的声明文件</p>
<p>所以，<code>ts</code> 并不知道这些库的类型以及对应导出的内容，这里 <code>@types</code> 实际就是社区中的 <code>DefinitelyTyped</code> 库，定义了目前市面上绝大多数的 <code>JavaScript</code> 库的声明</p>
<p>所以下载相关的 <code>JavaScript</code> 对应的 <code>@types</code> 声明时，就能够使用使用该库对应的类型定义</p>
<h4 id="二、使用方式-5"><a href="#二、使用方式-5" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>在编写 <code>React</code> 项目的时候，最常见的使用的组件就是：</p>
<ul>
<li>无状态组件</li>
<li>有状态组件</li>
<li>受控组件</li>
</ul>
<h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><p>主要作用是用于展示 <code>UI</code>，如果使用 <code>js</code> 声明，则如下所示：</p>
<pre><code class="jsx">import * as React from &quot;React&quot;;

export const Logo = (props) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<p>但这时候 <code>ts</code> 会出现报错提示，原因在于没有定义 <code>porps</code> 类型，这时候就可以使用 <code>interface</code> 接口去定义 <code>porps</code> 即可，如下：</p>
<pre><code class="tsx">import * as React from &quot;React&quot;;

interface IProps &#123;
  logo?: string;
  className?: string;
  alt?: string;
&#125;

export const Logo = (props: IProps) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<p>但是我们都知道 <code>props</code> 里面存在 <code>children</code> 属性，我们不可能每个 <code>porps</code> 接口里面定义多一个 <code>children</code>，如下：</p>
<pre><code class="tsx">interface IProps &#123;
  logo?: string;
  className?: string;
  alt?: string;
  children?: ReactNode;
&#125;
</code></pre>
<p>更加规范的写法是使用 <code>React</code> 里面定义好的 <code>FC</code> 属性，里面已经定义好 <code>children</code> 类型，如下：</p>
<pre><code class="tsx">export const Logo: React.FC&lt;IProps&gt; = (props) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<ul>
<li>React.FC 显式地定义了返回类型，其他方式是隐式推导的</li>
<li>React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全</li>
<li>React.FC 为 children 提供了隐式的类型（ReactElement | null）</li>
</ul>
<h5 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h5><p>可以是一个类组件且存在 <code>props</code> 和 <code>state</code> 属性</p>
<p>如果使用 <code>TypeScript</code> 声明则如下所示：</p>
<pre><code class="tsx">import * as React from &quot;React&quot;;

interface IProps &#123;
  color: string;
  size?: string;
&#125;
interface IState &#123;
  count: number;
&#125;
class App extends React.Component&lt;IProps, IState&gt; &#123;
  public state = &#123;
    count: 1,
  &#125;;
  public render() &#123;
    return &lt;div&gt;Hello world&lt;/div&gt;;
  &#125;
&#125;
</code></pre>
<p>上述通过泛型对 <code>props</code>、<code>state</code> 进行类型定义，然后在使用的时候就可以在编译器中获取更好的智能提示</p>
<p>关于 <code>Component</code> 泛型类的定义，可以参考下 React 的类型定义文件 <code>node_modules/@types/React/index.d.ts</code>，如下所示：</p>
<pre><code class="ts">class Component&lt;P, S&gt; &#123;
  readonly props: Readonly&lt;&#123; children?: ReactNode &#125;&gt; &amp; Readonly&lt;P&gt;;

  state: Readonly&lt;S&gt;;
&#125;
</code></pre>
<p>从上述可以看到，<code>state</code> 属性也定义了可读类型，目的是为了防止直接调用 <code>this.state</code> 更新状态</p>
<h5 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h5><p>受控组件的特性在于元素的内容通过组件的状态 <code>state</code> 进行控制</p>
<p>由于组件内部的事件是合成事件，不等同于原生事件，</p>
<p>例如一个 <code>input</code> 组件修改内部的状态，常见的定义的时候如下所示：</p>
<pre><code class="ts">private updateValue(e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#123;
    this.setState(&#123; itemText: e.target.value &#125;)
&#125;
</code></pre>
<p>常用 <code>Event</code> 事件对象类型：</p>
<ul>
<li>ClipboardEvent&lt;T &#x3D; Element&gt; 剪贴板事件对象</li>
<li>DragEvent&lt;T &#x3D; Element&gt; 拖拽事件对象</li>
<li>ChangeEvent&lt;T &#x3D; Element&gt; Change 事件对象</li>
<li>KeyboardEvent&lt;T &#x3D; Element&gt; 键盘事件对象</li>
<li>MouseEvent&lt;T &#x3D; Element&gt; 鼠标事件对象</li>
<li>TouchEvent&lt;T &#x3D; Element&gt; 触摸事件对象</li>
<li>WheelEvent&lt;T &#x3D; Element&gt; 滚轮事件对象</li>
<li>AnimationEvent&lt;T &#x3D; Element&gt; 动画事件对象</li>
<li>TransitionEvent&lt;T &#x3D; Element&gt; 过渡事件对象</li>
</ul>
<p><code>T</code> 接收一个 <code>DOM</code> 元素类型</p>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>上述只是简单的在 <code>React</code> 项目使用 <code>TypeScript</code>，但在编写 <code>React</code> 项目的时候，还存在 <code>hooks</code>、默认参数、以及 <code>store</code> 等等……</p>
<p><code>TypeScript</code> 在框架中使用的学习成本相对会更高，需要不断编写才能熟练</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-使用-Typescript-有哪些优点和缺点"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-使用-Typescript-有哪些优点和缺点" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 使用 Typescript 有哪些优点和缺点"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 使用 Typescript 有哪些优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h5 id="提供可选的强静态类型"><a href="#提供可选的强静态类型" class="headerlink" title="提供可选的强静态类型"></a>提供可选的强静态类型</h5><p>既然叫 TypeScript，那它的最大亮点自然就是提供静态类型（type）。我们可以对变量设置类型，比如你给 count 变量设置为数字类型（number），如果你从 input 元素提取 value （string 类型）赋予给 count，如果你忘记将其转换为数字，编译是不会通过的。</p>
<p>当然类型不是强求设置的，为了兼容 JavaScript，你也可以设置为 any 类型。所谓 any 类型是一个特殊的类型，任何类型的的值都可以赋予给它。</p>
<h5 id="更早发现-BUG"><a href="#更早发现-BUG" class="headerlink" title="更早发现 BUG"></a>更早发现 BUG</h5><p>TypeScript 要编译后才能使用。所以我们的类型错误会在编译过程中被编译器发现，更早发现 BUG。如果直接用 JavaScript 开发，需要在程序运行时，吭哧吭哧点来点去各种测试来判断行为是否正常，费时费力，开发体验极差。</p>
<p>比如原本应该是两个数字相加的，写错成两个数字形式的字符串相加，结果是差得十万八千里，且不易察觉。TypeScript 在编译时就给你找到了，你不改对别想过我编译。</p>
<h5 id="代码可预测"><a href="#代码可预测" class="headerlink" title="代码可预测"></a>代码可预测</h5><p>声明的变量一旦指定类型，它的类型就再也不能修改。这样变量就具有可预测性。</p>
<p>JavaScript 的变量可以赋予任何类型的值。有时候，我们会看到一个变量在执行的过程中变成各种各样的类型，一会是字符串，一会是对象，非常不好预测，尤其是有复杂条件判断的时候。这其实是并不是好的开发习惯，但在 JavaScript 它就是可以这么干！</p>
<p>但如果你用 TypeScript，就没有这个烦恼，它直接给你一刀切了，你别想将字符串值赋予给一个数字类型变量，一旦声明就再也无法修改。</p>
<p>当然为了兼容，你也是可以将其设置 any 类型，但智能提升就没有了哦。</p>
<h5 id="丰富的-IDE-支持"><a href="#丰富的-IDE-支持" class="headerlink" title="丰富的 IDE 支持"></a>丰富的 IDE 支持</h5><p>因为使用了类型，所以检测某个变量是什么类型、可以使用哪些方法就变得容易，在开发体验上就可以进行改善了。</p>
<p>目前在绝大多数 IDE（集成开发环境）中已经支持 TypeScript 的 智能提示、自动补全、代码导航 等功能，并能在编写时实时反馈类型错误并提供准确的建议，比如可以指出传入函数的对象缺了哪些属性。</p>
<h5 id="方便重构"><a href="#方便重构" class="headerlink" title="方便重构"></a>方便重构</h5><p>重构时，如果函数的参数修改了，调用它时如果不对，TypeScript 会提示你。这对重构代码提供了坚实的后盾。有了 TypeScript，就放心做重构吧，前提你不要到处用 any。</p>
<h5 id="提供面向对象的写法"><a href="#提供面向对象的写法" class="headerlink" title="提供面向对象的写法"></a>提供面向对象的写法</h5><p>面向对象语言在实践中已经被证实是优秀的设计，拥有极高的可读性、可维护性。TypeScript 支持接口、抽象类、枚举等面向对象语言的特性，支持你更好地实现一些设计模式。TypeScript 还支持类型体操，有空多锻炼身体哈。</p>
<p>看了这么多优点，再看看 TypeScript 的缺点。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="不是真正的静态类型"><a href="#不是真正的静态类型" class="headerlink" title="不是真正的静态类型"></a>不是真正的静态类型</h5><p>因为需要兼容 JavaScript 的缘故，TypeScript 的类型是可选的。你可以用 any 类型，也可以进行类型的强制转换，所以如果你在代码中写了太多这样的东西，甚至将其变成 AnyScript。那么实际运行还是可能会出现一些类型上的问题。</p>
<h5 id="有一定的学习成本"><a href="#有一定的学习成本" class="headerlink" title="有一定的学习成本"></a>有一定的学习成本</h5><p>学 TypeScript 其实和学习一门新语言差不多了，还是有不小的学习成本的。但因为兼容 JavaScript 的缘故，对前端开发者来说难度会低一点。</p>
<h5 id="需要写更多的代码"><a href="#需要写更多的代码" class="headerlink" title="需要写更多的代码"></a>需要写更多的代码</h5><p>主要是类型和接口声明的部分，但能够抵消掉你 debug 类型问题的时间，总体看还是物超所值的。另外，编译后类型和接口声明都会被移除，相比直接写 JavaScript，体积不会明显更大。</p>
<h5 id="需要编译"><a href="#需要编译" class="headerlink" title="需要编译"></a>需要编译</h5><p>浏览器和 Nodejs 并不支持 TypeScript，所以多了一步编译操作。对于普通项目来说通常不长，其实还好。但如果你用来写脚本的话，就需要多安装 tsc 编译工具，还要配置好 tsconfig.json 文件，还是有点麻烦。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-Typescript中的内置类型有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-Typescript中的内置类型有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Typescript中的内置类型有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Typescript中的内置类型有哪些？</h3><h4 id="Partial（部分的）"><a href="#Partial（部分的）" class="headerlink" title="Partial（部分的）"></a>Partial（部分的）</h4><pre><code class="typescript">/**
 * Make all properties in T optional
 */
type Partial&lt;T&gt; = &#123;
    [P in keyof T]?: T[P];
&#125;;
</code></pre>
<p>作用是让传入类型中的所有属性变成都是可选的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;&#125;

const student2: Partial&lt;Student&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101152.jpeg"></p>
<p>变量student1的类型是Student，Student默认所有的属性都是不能为空的，所有会报错，student2就不会</p>
<h4 id="Required（必须的）"><a href="#Required（必须的）" class="headerlink" title="Required（必须的）"></a>Required（必须的）</h4><pre><code class="typescript">/**
 * Make all properties in T required
 */
type Required&lt;T&gt; = &#123;
    [P in keyof T]-?: T[P];
&#125;;
</code></pre>
<p>跟Partial的作用是相反的，是让传入类型中的所有属性变成都是必填的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name?: string;
  age?: number;
&#125;

const student1: Student = &#123;&#125;

const student2: Required&lt;Student&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101153.jpeg"></p>
<p>变量student1的类型是Student，Student默认所有的属性都是可以为空的，所有不会报错，student2会报错</p>
<h4 id="Readonly（只读的）"><a href="#Readonly（只读的）" class="headerlink" title="Readonly（只读的）"></a>Readonly（只读的）</h4><pre><code class="typescript">/**
 * Make all properties in T readonly
 */
type Readonly&lt;T&gt; = &#123;
    readonly [P in keyof T]: T[P];
&#125;;
</code></pre>
<p>作用是让传入类型中的所有属性变成都是只读的（不能修改属性）</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;
student1.age = 21

const student2: Readonly&lt;Student&gt; = &#123;
  name: &#39;李四&#39;,
  age: 20
&#125;
student2.age = 21
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101154.jpeg"></p>
<p>给student1的属性age重新赋值不会报错，给student2的属性age重新赋值就会报错，因为student2所有的属性都是只读的</p>
<h4 id="Pick（选择）"><a href="#Pick（选择）" class="headerlink" title="Pick（选择）"></a>Pick（选择）</h4><pre><code class="typescript">/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Pick&lt;T, K extends keyof T&gt; = &#123;
    [P in K]: T[P];
&#125;;
</code></pre>
<p>作用是选择传入类型中的部分属性组成新类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;

const student2: Pick&lt;Student, &#39;name&#39;&gt; = &#123;
  name: &#39;李四&#39;
&#125;

const student3: Pick&lt;Student, &#39;name&#39;&gt; = &#123;
  name: &#39;王五&#39;,
  age: 20
&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101155.jpeg"></p>
<p>变量student1可以有所有属性name和age，变量student2就只能有属性name，变量student3加上属性age就会报错</p>
<h4 id="Record（记录）"><a href="#Record（记录）" class="headerlink" title="Record（记录）"></a>Record（记录）</h4><pre><code class="typescript">/**
 * Construct a type with a set of properties K of type T
 */
type Record&lt;K extends keyof any, T&gt; = &#123;
    [P in K]: T;
&#125;;
</code></pre>
<p>作用是构建一个类型，这个类型用来描述一个对象，这个对象的属性都具有相同的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export const student1: Record&lt;string, any&gt; = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;
</code></pre>
<p>Record应该是日常使用频率较高的内置类型了，主要用来描述对象，一般建议是不用Object来描述对象，而是用Record代替，Record&lt;string, any&gt;几乎可以说是万金油了</p>
<h4 id="Exclude（排除）"><a href="#Exclude（排除）" class="headerlink" title="Exclude（排除）"></a>Exclude（排除）</h4><pre><code class="typescript">/**
 * Exclude from T those types that are assignable to U
 */
type Exclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre>
<p>针对联合类型（interface这种没用），用人话说，排除相同的，留下不同的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Exclude&lt;StudentAttr, PersonAttr&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101156.jpeg"></p>
<p>student1就只能被赋值为’class’ 或者’school’</p>
<h4 id="Extract（取出）"><a href="#Extract（取出）" class="headerlink" title="Extract（取出）"></a>Extract（取出）</h4><pre><code class="typescript">/**
 * Extract from T those types that are assignable to U
 */
type Extract&lt;T, U&gt; = T extends U ? T : never;
</code></pre>
<p>与Exclude相反，针对联合类型，排除不同的的，取出相同的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Extract&lt;StudentAttr, PersonAttr&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101157.jpeg"></p>
<p>student1就只能被赋值为’name’或者’age’</p>
<h4 id="Omit（省略）"><a href="#Omit（省略）" class="headerlink" title="Omit（省略）"></a>Omit（省略）</h4><pre><code class="typescript">/**
 * Construct a type with the properties of T except for those in type K.
 */
type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;
</code></pre>
<p>传入一个类型，和这个类型的几个属性，把传入的属性省略掉，组成一个新类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
  class: string;
  school: string;
&#125;

export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Omit&lt;Student, PersonAttr&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101158.jpeg"></p>
<p>student1报错，提示没有属性’name’、’age’</p>
<h4 id="NonNullable（不能为null）"><a href="#NonNullable（不能为null）" class="headerlink" title="NonNullable（不能为null）"></a>NonNullable（不能为null）</h4><pre><code class="typescript">/**
 * Exclude null and undefined from T
 */
type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;
</code></pre>
<p>字面意思，不能为空</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: NonNullable&lt;Student | undefined | null&gt; = null
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101159.jpeg"></p>
<p>student1赋值为null会报错（在tsconfig.json配置文件中开启类型检查，<code>&quot;skipLibCheck&quot;: false</code>）</p>
<h4 id="Parameters（参数）"><a href="#Parameters（参数）" class="headerlink" title="Parameters（参数）"></a>Parameters（参数）</h4><pre><code class="typescript">/**
 * Obtain the parameters of a function type in a tuple
 */
type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>获取传入函数的参数组成的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentFunc &#123;
  (name: string, age: number): Student
&#125;

const student1: Parameters&lt;StudentFunc&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101160.jpeg"></p>
<p>student1的类型为<code>[name: string, age: number]</code></p>
<h4 id="ConstructorParameters（构造参数）"><a href="#ConstructorParameters（构造参数）" class="headerlink" title="ConstructorParameters（构造参数）"></a>ConstructorParameters（构造参数）</h4><pre><code class="typescript">/**
 * Obtain the parameters of a constructor function type in a tuple
 */
type ConstructorParameters&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>获取传入构造函数的参数组成的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentConstructor &#123;
  new (name: string, age: number): Student
&#125;

const student1: ConstructorParameters&lt;StudentConstructor&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101161.jpeg"></p>
<p>student1的类型为<code>[name: string, age: number]</code></p>
<h4 id="ReturnType（返回类型）"><a href="#ReturnType（返回类型）" class="headerlink" title="ReturnType（返回类型）"></a>ReturnType（返回类型）</h4><pre><code class="typescript">/**
 * Obtain the return type of a function type
 */
type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;
</code></pre>
<p>获取传入函数的返回类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentFunc &#123;
  (name: string, age: number): Student
&#125;

const student1: ReturnType&lt;StudentFunc&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101162.jpeg"></p>
<p>student1的类型为<code>Student</code></p>
<h4 id="InstanceType（构造返回类型、实例类型）"><a href="#InstanceType（构造返回类型、实例类型）" class="headerlink" title="InstanceType（构造返回类型、实例类型）"></a>InstanceType（构造返回类型、实例类型）</h4><pre><code class="typescript">/**
 * Obtain the return type of a constructor function type
 */
type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any;
</code></pre>
<p>获取传入构造函数的返回类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">const Student = class &#123;
  name: string;
  age: number;
  constructor (name: string, age: number) &#123;
    this.name = name
    this.age = age
  &#125;
  showInfo () &#123;
    console.log(&#39;name: &#39;, this.name, &#39;age: &#39;, this.age);
  &#125;
&#125;

const student1: InstanceType&lt;typeof Student&gt; = new Student(&#39;张三&#39;, 20)
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101163.jpeg"></p>
<p>个人认为这是一个非常好用的内置类型，目前在前端项目中，class是用的越来越多了，在TS中，class其实也是可以用作类型声明空间的，用来描述对象类型，但是一般来说好像很少这样用的，一般用interface或者type居多</p>
<pre><code class="typescript">export class Student &#123;
  name: string;
  age: number;
&#125;
</code></pre>
<p>所以一般就是直接把class用作变量声明空间，但是对于 class new 出的实例，怎么描述它的类型呢，就如上文的，直接<code>const student1: Student</code>那是铁定会报错的，因为Student用作变量声明空间，没有用作类型声明空间（听起来好绕），这时候就可以用到InstanceType，完美解决问题</p>
<h4 id="Uppercase（大写）"><a href="#Uppercase（大写）" class="headerlink" title="Uppercase（大写）"></a>Uppercase（大写）</h4><pre><code class="typescript">/**
 * Convert string literal type to uppercase
 */
type Uppercase&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>变大写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;male&#39; | &#39;female&#39;

const studentSex: Uppercase&lt;StudentSexType&gt; = &#39;MALE&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101164.jpeg"></p>
<h4 id="Lowercase（小写）"><a href="#Lowercase（小写）" class="headerlink" title="Lowercase（小写）"></a>Lowercase（小写）</h4><pre><code class="typescript">/**
 * Convert string literal type to lowercase
 */
type Lowercase&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>变小写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;MALE&#39; | &#39;FEMALE&#39;

const studentSex: Lowercase&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101165.jpeg"></p>
<h4 id="Capitalize（首字母大写）"><a href="#Capitalize（首字母大写）" class="headerlink" title="Capitalize（首字母大写）"></a>Capitalize（首字母大写）</h4><pre><code class="typescript">/**
 * Convert first character of string literal type to uppercase
 */
type Capitalize&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>首字母变大写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;male&#39; | &#39;female&#39;

const studentSex: Capitalize&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101166.jpeg"></p>
<h4 id="Uncapitalize（首字母小写）"><a href="#Uncapitalize（首字母小写）" class="headerlink" title="Uncapitalize（首字母小写）"></a>Uncapitalize（首字母小写）</h4><pre><code class="typescript">/**
 * Convert first character of string literal type to lowercase
 */
type Uncapitalize&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>首字母变小写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;MALE&#39; | &#39;FEMALE&#39;

const studentSex: Uncapitalize&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101167.jpeg"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-能否将多个-ts-文件组合成一个-js-文件？-如果是，那么如何？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-能否将多个-ts-文件组合成一个-js-文件？-如果是，那么如何？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 能否将多个 .ts 文件组合成一个 .js 文件？ 如果是，那么如何？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 能否将多个 <code>.ts</code> 文件组合成一个 <code>.js</code> 文件？ 如果是，那么如何？</h3><p>这是可以的。需要添加 —outFILE [OutputJSFileName] 编译选项。</p>
<pre><code class="shell">$ tsc --outFile comman.js file1.ts file2.ts file3.ts
</code></pre>
<p>上述命令将编译所有三个<code>.ts</code>文件，结果将存储到单个<code>comman.js</code>文件中。在这种情况下，当没有像下面的命令那样提供输出文件名时。</p>
<pre><code class="shell">$ tsc --outFile file1.ts file2.ts file3.ts
</code></pre>
<p>然后，<code>file2.ts</code>和<code>file3.ts</code>会被编译，输出会放在<code>file1.ts</code>中。所以现在的 <code>file1.ts</code> 包含 JavaScript 代码。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-是否可以通过-ts-文件中的实时更改自动编译-ts-？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-是否可以通过-ts-文件中的实时更改自动编译-ts-？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 是否可以通过 .ts 文件中的实时更改自动编译 .ts ？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 是否可以通过 <code>.ts</code> 文件中的实时更改自动编译 <code>.ts</code> ？</h3><p>是的，可以通过 <code>.ts</code> 文件中的实时更改自动编译<code>.ts</code>。这可以通过使用 <code>--watch</code> 编译器选项来实现。</p>
<pre><code class="shell">tsc --watch file1.ts
</code></pre>
<p>上面的命令首先编译 <code>file1.js</code> 中的 <code>file1.ts</code> 并观察文件的变化。如果检测到任何更改，它将再次编译该文件。在这里，需要确保在使用 <code>--watch</code> 选项运行时不能关闭命令提示符。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-interface语句和type语句有什么区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-interface语句和type语句有什么区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ interface语句和type语句有什么区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ interface语句和type语句有什么区别？</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>都可以描述一个对象或者函数</p>
<p>interface</p>
<pre><code class="typescript">interface User &#123;
  name: string
  age: number
&#125;

interface SetUser &#123;
  (name: string, age: number): void;
&#125;
</code></pre>
<p>type</p>
<pre><code class="typescript">type User = &#123;
  name: string
  age: number
&#125;;

type SetUser = (name: string, age: number)=&gt; void;
</code></pre>
<p>都允许拓展（extends）</p>
<p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p>
<p>interface extends interface</p>
<pre><code class="typescript">interface Name &#123; 
  name: string; 
&#125;
interface User extends Name &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<p>type extends type</p>
<pre><code class="ini">type Name = &#123; 
  name: string; 
&#125;
type User = Name &amp; &#123; age: number  &#125;;
复制代码
</code></pre>
<p>interface extends type</p>
<pre><code class="typescript">type Name = &#123; 
  name: string; 
&#125;
interface User extends Name &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<p>type extends interface</p>
<pre><code class="ini">interface Name &#123; 
  name: string; 
&#125;
type User = Name &amp; &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>type 可以而 interface 不行</p>
<ul>
<li>type 可以声明基本类型别名，联合类型，元组等类型</li>
</ul>
<pre><code class="go">// 基本类型别名
type Name = string

// 联合类型
interface Dog &#123;
    wong();
&#125;
interface Cat &#123;
    miao();
&#125;

type Pet = Dog | Cat

// 具体定义数组每个位置的类型
type PetList = [Dog, Pet]

复制代码
</code></pre>
<ul>
<li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</li>
</ul>
<pre><code class="ini">// 当你想获取一个变量的类型时，使用 typeof
let div = document.createElement(&#39;div&#39;);
type B = typeof div
复制代码
</code></pre>
<ul>
<li>其他骚操作</li>
</ul>
<pre><code class="ini">type StringOrNumber = string | number;  
type Text = string | &#123; text: string &#125;;  
type NameLookup = Dictionary&lt;string, Person&gt;;  
type Callback&lt;T&gt; = (data: T) =&gt; void;  
type Pair&lt;T&gt; = [T, T];  
type Coordinates = Pair&lt;number&gt;;  
type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;
复制代码
</code></pre>
<p>interface 可以而 type 不行</p>
<p>interface 能够声明合并</p>
<pre><code class="typescript">interface User &#123;
  name: string
  age: number
&#125;

interface User &#123;
  sex: string
&#125;

/*
User 接口为 &#123;
  name: string
  age: number
  sex: string 
&#125;
*/
复制代码
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在Proxy中代理apply方法"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在Proxy中代理apply方法" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Proxy中代理apply方法"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Proxy中代理apply方法</h3><pre><code class="javascript"> &#123;
            var target = function () &#123;
                return &#39;I am the target&#39;;
            &#125;
            var handler = &#123;
                apply: function () &#123;
                    return &#39;I am the proxy&#39;;
                &#125;
            &#125;;
            var p = new Proxy(target,handler);
            console.log(&quot;p&quot;,p());
        &#125;
//上面代码中，变量p是Proxy的实例，当他作为函数调用时（p（））
//,就会被apply方法拦截，返回一个字符串
</code></pre>
<pre><code class="javascript">&#123;
    var twice = &#123;
                    //目标对象，目标对象的上下文对象，目标对象的参数数组
        apply:function (target,ctx,args) &#123;
            //return console.log(&quot;target&quot;,target,&quot;ctx&quot;,ctx,&quot;args&quot;,args);
           return Reflect.apply(...arguments)*2;
        &#125;
    &#125;;
    function sum (left,right) &#123;
         return left*right;
    &#125;;
    var proxy = new Proxy(sum,twice);
    console.log(&quot;proxy1&quot;,proxy(1,2));
    console.log(&quot;proxy.call&quot;,proxy.call(null,5,6));
    console.log(&quot;proxy,apply&quot;,proxy.apply(null,[7,8]));
    console.log(&quot;proxy,apply&quot;,Reflect.apply(proxy,null,[7,8]));

&#125;
//上面的实例执行顺序是当sum（）执行完后再执行twice中的apply()，
//上面代码中每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截
//另外，直接调用Reflect.apply方法，也会被拦截。
</code></pre>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-前端面试大全网络攻防"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"
    >前端面试大全网络攻防</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/" class="article-date">
  <time datetime="2022-11-01T07:16:13.000Z" itemprop="datePublished">2022-11-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/">网络攻击</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（网络攻防）"><a href="#前端面试题大全（网络攻防）" class="headerlink" title="前端面试题大全（网络攻防）"></a>前端面试题大全（网络攻防）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="网络攻防"><a href="#网络攻防" class="headerlink" title="网络攻防"></a>网络攻防</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-XSS攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-XSS攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ XSS攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ XSS攻击</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/09/27/fe-security.html">美团技术谈XSS攻防</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-CSRF攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-CSRF攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ CSRF攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ CSRF攻击</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">美团技术谈CSRF攻击</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-中间人攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-中间人攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 中间人攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 中间人攻击</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1900287">中间人攻击</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-SQL注入"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-SQL注入" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ SQL注入"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ SQL注入</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/github_36032947/article/details/78442189">理解SQL注入</a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-DDoS攻击"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-DDoS攻击" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DDoS攻击"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DDoS攻击</h3><p>DDoS攻击——常见的具有破坏性的安全性问题(如果是分布式攻击的话就是DDos攻击)</p>
<p>攻击方式：Ping Flood攻击即利用ping命令不停的发送的数据包到服务器。</p>
<p><a target="_blank" rel="noopener" href="https://www.cloudflare.com/zh-cn/learning/ddos/what-is-a-ddos-attack/">DDoS攻击 </a></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-DNS缓存污染"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-DNS缓存污染" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DNS缓存污染"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ DNS缓存污染</h3><p>DNS缓存污染——常见的网站不可访问的问题</p>
<p>攻击方式：第三方可信赖的域名服务器缓存了一些DNS解析，但被别人制造一些假域名服务器封包污染了，指向错误网址。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>