<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>面试手撕代码合集 |  艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-面试手撕代码合集"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  面试手撕代码合集
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/01/05/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/" class="article-date">
  <time datetime="2023-01-05T02:10:45.000Z" itemprop="datePublished">2023-01-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/">面试手撕代码合集</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">8.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">49 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="面试手撕代码合集"><a href="#面试手撕代码合集" class="headerlink" title="面试手撕代码合集"></a>面试手撕代码合集</h1><h2 id="1-柯里化函数"><a href="#1-柯里化函数" class="headerlink" title="1.柯里化函数"></a>1.柯里化函数</h2><pre><code class="javascript">function add() &#123;
    const _args = [...arguments];
    function fn() &#123;
      _args.push(...arguments);
      return fn; //一直重复收集参数
    &#125;
    fn.toString = function() &#123;
      return _args.reduce((sum, cur) =&gt; sum + cur);
    &#125;
    return fn;
  &#125;
console.log(add(1)(2)(3)(4).toString()) //10
console.log(add(1,2)(1, 2, 3)(2).toString()) //11
</code></pre>
<h2 id="2-千位符转换"><a href="#2-千位符转换" class="headerlink" title="2.千位符转换"></a>2.千位符转换</h2><pre><code class="javascript">// 将金额类型转为数字类型
function toNum(str) &#123;
    return str.replace(/\,|\￥/g, &quot;&quot;);
&#125;

// 保留两位小数（四舍五入）
function toPrice(num) &#123;
    num = parseFloat(toNum(num)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);
&#125;

// 保留两位小数（不四舍五入）
function toPrice1(num) &#123;
    num = parseFloat(toNum(num).replace(/(\.\d&#123;2&#125;)\d+$/,&quot;$1&quot;)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);;
&#125;

// 不处理小数部分
function toPrice2(num) &#123;
    var source = toNum(num).split(&quot;.&quot;);
    source[0] = source[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + source.join(&quot;.&quot;)
&#125;

console.log(toPrice(&#39;12312.236&#39;)) //￥12,312.24
console.log(toPrice1(&#39;12312.234&#39;)) //￥12,312.23
console.log(toPrice2(&#39;1232342312.234&#39;)) //￥1,232,342,312.234
</code></pre>
<h2 id="3-用setTimeout实现setInterval-计数器"><a href="#3-用setTimeout实现setInterval-计数器" class="headerlink" title="3.用setTimeout实现setInterval(计数器)"></a>3.用setTimeout实现setInterval(计数器)</h2><pre><code class="javascript">var i = 10;
let fn = () =&gt; &#123;
    console.log(i--);
&#125;
function mySetInterval(fn, delay, times) &#123;
    let timer = setTimeout(function a() &#123;
        fn()
        times--
        timer = setTimeout(a, delay)
        if (times &lt;= 0) &#123;
            clearTimeout(timer)
        &#125;
    &#125;, delay)
&#125;
mySetInterval(fn, 1000, 10)
</code></pre>
<h2 id="4-数组扁平化"><a href="#4-数组扁平化" class="headerlink" title="4.数组扁平化"></a>4.数组扁平化</h2><pre><code class="javascript">//递归实现
var arr = [1,2,[3,4,[5,6]]]
function flatten(arr)&#123;
    let result = []
    arr.forEach(item =&gt; &#123;
        if(Array.isArray(item))&#123;
            result = result.concat(flatten(item))
        &#125;else&#123;
            result.push(item)
        &#125;
    &#125;);
    return result
&#125;
console.log(flatten(arr)) //[ 1, 2, 3, 4, 5, 6 ]

//利用reduce函数迭代
var arr1 = [1,2,[3,4,[5,6]]]
function flatten1(arr)&#123;
    return arr.reduce((res,next) =&gt; &#123;
        return res.concat(Array.isArray(next) ? flatten1(next) : next)
    &#125;,[])
&#125;
console.log(flatten1(arr1)) //[ 1, 2, 3, 4, 5, 6 ]
</code></pre>
<h2 id="5-深拷贝"><a href="#5-深拷贝" class="headerlink" title="5.深拷贝"></a>5.深拷贝</h2><pre><code class="javascript">function deepClone(obj,hash = new WeakMap())&#123;
    if(obj == null) return obj;
    if(obj instanceof Date) return new Date(obj);
    if(obj instanceof RegExp) return new RegExp(obj);
    if(typeof obj !== &#39;object&#39;) return obj;
    if(hash.get(obj)) return hash.get(obj);
    let cloneObj = new obj.constructor;
    hash.set(obj,cloneObj);
    for(let key in obj)&#123;
        if(obj.hasOwnProperty(key))&#123;
            cloneObj[key] = deepClone(obj[key],hash);
        &#125;
    &#125;
    return cloneObj;
&#125;

let obj = &#123;name:1,address:&#123;x:1000&#125;&#125;;
let d = deepClone(obj);
obj.address.x = 200;
console.log(d); //&#123;name:1,address:&#123;x:1000&#125;&#125;
</code></pre>
<h2 id="6-Promise-all"><a href="#6-Promise-all" class="headerlink" title="6.Promise.all"></a>6.Promise.all</h2><pre><code class="javascript">Promise.prototype.all = function(promises)&#123;
    let results = [];
    let promiseCount = 0;
    let promisesLength = promises.length;
    return new Promise(function(resolve,reject)&#123;
        for(let val of promises)&#123;
            Promise.resolve(val).then(function(res)&#123;
                promiseCount++;
                //results.push(res)
                results[i] = res;
                //当所有函数都正确执行了，resolve输出所有返回结果
                if(promiseCount === promisesLength)&#123;
                    return resolve(results);
                &#125;
            &#125;,function(err)&#123;
                return reject(err);
            &#125;)
        &#125;
    &#125;)
&#125;

//测试
let promise1 = new Promise(function(resolve) &#123;
    resolve(1);
  &#125;);
  let promise2 = new Promise(function(resolve) &#123;
    resolve(2);
  &#125;);
  let promise3 = new Promise(function(resolve) &#123;
    resolve(3);
  &#125;);
  
  let promiseAll = Promise.all([promise1, promise2, promise3]);
  promiseAll.then(function(res) &#123;
    console.log(res);
  &#125;);//[1,2,3]
</code></pre>
<h2 id="7-Promise-race"><a href="#7-Promise-race" class="headerlink" title="7.Promise.race"></a>7.Promise.race</h2><pre><code class="javascript">Promise.race = function(promises)&#123;
    //将可迭代对象转换为数组
    promises = Array.from(promises);
    return new Promise((resolve,reject)=&gt;&#123;
        if(promises.length === 0)&#123;
            //空的可迭代对象，用于pending状态
        &#125;else&#123;
            for(let i = 0;i &lt; promises.length;i++)&#123;
                Promise.resolve(promises[i]).then((data)=&gt;&#123;
                    resolve(data);
                &#125;).catch((reason)=&gt;&#123;
                    reject(reason)
                &#125;)
            &#125;
        &#125;
    &#125;)
&#125;

//测试
let p1 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;success&#39;)
    &#125;,1000)
&#125;)
let p2 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;faild&#39;)
    &#125;,500)
&#125;)

Promise.race([p1,p2]).then(result=&gt;&#123;
console.log(result)  //  faild    faild耗时短
&#125;)
</code></pre>
<h2 id="8-instanceof"><a href="#8-instanceof" class="headerlink" title="8.instanceof"></a>8.instanceof</h2><pre><code class="javascript">function new_instance_of(leftValue,rightValue)&#123;
    let rightProto = rightValue.prototype;//取右边表达式的 prototype 值
    leftValue = leftValue.__proto__;//取左表达式的 __proto__ 值
    while(true)&#123;
        if(leftValue == null)&#123;
            return false;
        &#125;
        if(leftValue === rightProto)&#123;
            return true;
        &#125;
        leftValue = leftValue.__proto__;
    &#125;
&#125;
function Foo()&#123;&#125;
console.log(new_instance_of(Foo,Object))//true
</code></pre>
<h2 id="9-js继承"><a href="#9-js继承" class="headerlink" title="9.js继承"></a>9.js继承</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h3><pre><code class="javascript"> // 原型链继承
  function Super()&#123;
    this.color=[&#39;red&#39;,&#39;yellow&#39;,&#39;black&#39;]
  &#125;

  function Sub()&#123;
  &#125;
  //继承了color属性 Sub.prototype.color=[&#39;red&#39;,&#39;yellow&#39;,&#39;black&#39;]
  Sub.prototype=new Super()

  //创建实例 instance1.__proto__.color
  const instance1=new Sub()
  const instance2=new Sub()
  console.log(instance1.__proto__.color===instance2.__proto__.color) //true
</code></pre>
<h3 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2.构造函数继承"></a>2.构造函数继承</h3><pre><code class="javascript">function Super(name,age)&#123;
    this.name = name;
    this.age = age;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;];
    this.sayHi = function()&#123;
        console.log(&#39;hi&#39;)
    &#125;
    console.log(this)
&#125;
function Sub()&#123;
    //改变this指向
    Super.apply(this,arguments)
    this.height = 180;
&#125;

var instance1 = new Sub(&#39;mengfeng&#39;,25);
var instance2 = new Sub(&#39;mengfeng123&#39;,24);
instance1.sayHi();//hi
</code></pre>
<h3 id="3-实例继承"><a href="#3-实例继承" class="headerlink" title="3.实例继承"></a>3.实例继承</h3><pre><code class="javascript">new
</code></pre>
<h3 id="4-拷贝继承"><a href="#4-拷贝继承" class="headerlink" title="4.拷贝继承"></a>4.拷贝继承</h3><pre><code class="javascript">//深拷贝
</code></pre>
<h3 id="5-组合继承"><a href="#5-组合继承" class="headerlink" title="5.组合继承"></a>5.组合继承</h3><pre><code class="javascript">function Super(name,age)&#123;
    this.name = name;
    this.age = age;
    this.color = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;]
&#125;

Super.prototype.sayHi = function()&#123;
    console.log(&#39;hi&#39;)
&#125;

function Sub(name,age,height)&#123;
    Super.apply(this,arguments)
    this.height = height;
&#125;

Sub.prototype = new Super(&#39;w&#39;,22);
Sub.prototype.constructor = Sub;
console.log(Sub.prototype)
Sub.prototype.sayHello = function()&#123;
    console.log(&#39;hello&#39;)
&#125;

var instance1 = new Sub(&#39;mengfeng&#39;,23,180);
var instance2 = new Sub(&#39;mengfeng123&#39;,24,181);
console.log(instance1)
</code></pre>
<h3 id="6-寄生组合继承"><a href="#6-寄生组合继承" class="headerlink" title="6.寄生组合继承"></a>6.寄生组合继承</h3><pre><code class="javascript">function inheritPrototype(Sub,Super)&#123;
    var subPrototype=Object.create(Super.prototype)
    subPrototype.constructor=Sub
    Sub.prototype=subPrototype
    
  &#125;
  function Super(name)&#123;
    this.name=name
  &#125;
  Super.prototype.sayHi=function()&#123;
    console.log(this.name)//ccdida
  &#125;
  function Sub(name)&#123;
    Super.call(this,name)
  &#125;
  inheritPrototype(Sub,Super)

  Sub.prototype.sayHello=function()&#123;
    console.log(&#39;sayHello&#39;)
  &#125;

  var instance1=new Sub(&#39;ccdida&#39;)
  console.log(instance1.__proto__)
  console.log(instance1.__proto__.__proto__)
</code></pre>
<h2 id="10-对象扁平化"><a href="#10-对象扁平化" class="headerlink" title="10.对象扁平化"></a>10.对象扁平化</h2><pre><code class="javascript">//对象扁平化
function flat(obj, key = &quot;&quot;, res = &#123;&#125;, isArray = false) &#123; 
    for (let [k, v] of Object.entries(obj)) &#123; 
      if (Array.isArray(v)) &#123; 
        let tmp = isArray ? key + &quot;[&quot; + k + &quot;]&quot; : key + k 
        flat(v, tmp, res, true) 
      &#125; else if (typeof v === &quot;object&quot;) &#123; 
        let tmp = isArray ? key + &quot;[&quot; + k + &quot;].&quot; : key + k + &quot;.&quot; 
        flat(v, tmp, res) 
      &#125; else &#123; 
        let tmp = isArray ? key + &quot;[&quot; + k + &quot;]&quot; : key + k 
        res[tmp] = v 
      &#125; 
    &#125; 
    return res 
  &#125;
  
  var entryObj = &#123;
    a: &#123;
        b: &#123;
            c: &#123;
                dd: &#39;abcdd&#39;
            &#125;
        &#125;,
        d: &#123;
            xx: &#39;adxx&#39;
        &#125;,
        e: &#39;ae&#39;
    &#125;
&#125;

console.log(flat(entryObj))
</code></pre>
<h2 id="11-发布订阅"><a href="#11-发布订阅" class="headerlink" title="11.发布订阅"></a>11.发布订阅</h2><pre><code class="javascript">class EventEmitter&#123;
    constructor()&#123;
        this._events = &#123;&#125;;
    &#125;

    on(eventName, callback)&#123;
        if(this._events[eventName])&#123;
            if(this.eventName !== &quot;newListener&quot;)&#123;
                this.emit(&quot;newListener&quot;, eventName)
            &#125;
        &#125;
        const callbacks = this._events[eventName] || [];
        callbacks.push(callback);
        this._events[eventName] = callbacks
    &#125;

    emit(eventName, ...args)&#123;
        const callbacks = this._events[eventName] || [];
        callbacks.forEach(cb =&gt; cb(...args))
    &#125;

    once(eventName, callback)&#123;
        const one = (...args)=&gt;&#123;
            callback(...args)
            this.off(eventName, one)
        &#125;
        one.initialCallback = callback;
        this.on(eventName, one)
    &#125;

     off(eventName, callback)&#123;
        const callbacks = this._events[eventName] || []
        const newCallbacks = callbacks.filter(fn =&gt; fn != callback &amp;&amp; fn.initialCallback != callback /* 用于once的取消订阅 */)
        this._events[eventName] = newCallbacks;
    &#125;
&#125;



const events = new EventEmitter()

events.on(&quot;newListener&quot;, function(eventName)&#123;
    console.log(`eventName`, eventName)
&#125;)

events.on(&quot;hello&quot;, function()&#123;
    console.log(&quot;hello&quot;);
&#125;)

let cb = function()&#123;
    console.log(&#39;cb&#39;);
&#125;
events.on(&quot;hello&quot;, cb)

events.off(&quot;hello&quot;, cb)

function once()&#123;
    console.log(&quot;once&quot;);
&#125;
events.once(&quot;hello&quot;, once)

events.off(&quot;hello&quot;, once)
events.emit(&quot;hello&quot;)
events.emit(&quot;hello&quot;)
</code></pre>
<h2 id="12-反柯里化函数"><a href="#12-反柯里化函数" class="headerlink" title="12.反柯里化函数"></a>12.反柯里化函数</h2><pre><code class="javascript">Function.prototype.uncurrying = function() &#123;
    var self = this;   //self为Array.prototype.push
    return function() &#123;
        //obj = &#123;0:1, length: 1&#125;, arguments = [2, callee: ƒ, Symbol(Symbol.iterator): ƒ]
        var obj = Array.prototype.shift.call(arguments); 
        
        //Array.ptototype.push(obj, 2)
        return self.apply(obj, arguments);
    &#125;
&#125;
var testObj = &#123;
    length: 1,
    0: 1
&#125;
var push = Array.prototype.push.uncurrying();
push(testObj, 2);
console.log(testObj);   //&#123;0: 1, 1: 2, length: 2&#125;
</code></pre>
<h2 id="13-防抖"><a href="#13-防抖" class="headerlink" title="13.防抖"></a>13.防抖</h2><pre><code class="javascript">//scroll方法中的do somthing至少间隔500毫秒执行一次
window.addEventListener(&#39;scroll&#39;,function()&#123;
    var timer;//使用闭包，缓存变量
    return function()&#123;
    if(timer) clearTimeout(timer);
    timer = setTimeout(function()&#123;
    console.log(&#39;do somthing&#39;)
&#125;,500)
&#125;
&#125;());//此处()作用 - 立即调用return后面函数，形成闭包
</code></pre>
<h2 id="14-监测数组变化"><a href="#14-监测数组变化" class="headerlink" title="14.监测数组变化"></a>14.监测数组变化</h2><pre><code class="javascript">// 获取Array的原型，并创建一个新的对象指向这个原型
const arrayMethods = Object.create(Array.prototype)
// 创建一个新的原型，这就是改造之后的数组原型
const ArrayProto = []
// 重新构建Array原型里面的虽有方法
Object.getOwnPropertyNames(Array.prototype).forEach(method =&gt; &#123;
    if(typeof arrayMethods[method] === &quot;function&quot;)&#123;
        ArrayProto[method] = function()&#123;
            console.log(&quot;我已经监听到数组触发了&quot;+method+&quot;事件&quot;)
            return arrayMethods[method].apply(this, arguments)
        &#125;
    &#125;else&#123;
        ArrayProto[method] = arrayMethods[method]
    &#125;
&#125;)


let list = [1, 2, 3]
// 将数组的原型链指向新构造的原型
list.__proto__ = ArrayProto
// 执行push事件
list.push(2)
// 输出：
我已经监听到数组触发了push事件 // 这个说明监听成功了
</code></pre>
<h2 id="15-节流"><a href="#15-节流" class="headerlink" title="15.节流"></a>15.节流</h2><pre><code class="javascript">//scroll方法中当间隔时间大于2s，do somthing执行一次
window.addEventListener(&#39;scroll&#39;,function()&#123;
    var timer ;//使用闭包，缓存变量
    var startTime = new Date();
    return function()&#123;
    var curTime = new Date();
    if(curTime - startTime &gt;= 2000)&#123;
    timer = setTimeout(function()&#123;
    console.log(&#39;do somthing&#39;)
    &#125;,500);
    startTime = curTime;
    &#125;
      &#125; &#125;());//此处()作用 - 立即调用return后面函数，形成闭包
</code></pre>
<h2 id="16-拦截全局Promise-reject"><a href="#16-拦截全局Promise-reject" class="headerlink" title="16.拦截全局Promise-reject"></a>16.拦截全局Promise-reject</h2><pre><code class="javascript">// 使用Try catch 只能拦截try语句块里面的
try &#123;
    new Promise((resolve, reject) =&gt; &#123;
      reject(&quot;WTF 123&quot;);
    &#125;);
  &#125; catch (e) &#123;
    console.log(&quot;e&quot;, e);
    throw e;
  &#125;
  
  // 使用 unhandledrejection 来拦截全局错误  （这个是对的）
  window.addEventListener(&quot;unhandledrejection&quot;, (event) =&gt; &#123;
    event &amp;&amp; event.preventDefault();
    console.log(&quot;event&quot;, event);
  &#125;);
</code></pre>
<h2 id="17-千位符"><a href="#17-千位符" class="headerlink" title="17.千位符"></a>17.千位符</h2><pre><code class="javascript">// 将金额类型转为数字类型
function toNum(str) &#123;
    return str.replace(/\,|\￥/g, &quot;&quot;);
&#125;

// 保留两位小数（四舍五入）
function toPrice(num) &#123;
    num = parseFloat(toNum(num)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);
&#125;

// 保留两位小数（不四舍五入）
function toPrice1(num) &#123;
    num = parseFloat(toNum(num).replace(/(\.\d&#123;2&#125;)\d+$/,&quot;$1&quot;)).toFixed(2).toString().split(&quot;.&quot;);
    num[0] = num[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + num.join(&quot;.&quot;);;
&#125;

// 不处理小数部分
function toPrice2(num) &#123;
    var source = toNum(num).split(&quot;.&quot;);
    source[0] = source[0].replace(new RegExp(&#39;(\\d)(?=(\\d&#123;3&#125;)+$)&#39;,&#39;ig&#39;),&quot;$1,&quot;);
    return &quot;￥&quot; + source.join(&quot;.&quot;)
&#125;

console.log(toPrice(&#39;12312.236&#39;)) //￥12,312.24
console.log(toPrice1(&#39;12312.234&#39;)) //￥12,312.23
console.log(toPrice2(&#39;1232342312.234&#39;)) //￥1,232,342,312.234
</code></pre>
<h2 id="18-浅拷贝"><a href="#18-浅拷贝" class="headerlink" title="18.浅拷贝"></a>18.浅拷贝</h2><pre><code class="javascript">let Sclone =(obj)=&gt;&#123;        
    // 方法一        
    // let obj1 = &#123;&#125;        
    // obj1 = Object.assign(&#123;&#125;,obj)        
    // 方法二 
    let obj1 =&#123;...obj&#125;       
    return obj1    
&#125;
</code></pre>
<h2 id="19-数组去重"><a href="#19-数组去重" class="headerlink" title="19.数组去重"></a>19.数组去重</h2><pre><code class="javascript">let arr =  [1,2,2,4,null,null,&#39;3&#39;,&#39;abc&#39;,3,5,4,1,2,2,4,null,null,&#39;3&#39;,&#39;abc&#39;,3,5,4] 

//利用key的唯一
let obj = &#123;&#125;;
for (let i = 0; i &lt; arr.length; i++) &#123;
  let item = arr[i]
  if (obj[item] !== undefined) &#123;
    arr.splice(i, 1);
    i--; // 解决删除元素后，数组塌陷问题
    continue;
  &#125;
  obj[item] = item
&#125;

console.log(arr)
// arr: [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]


// 交换元素位置从而替换调 splice方法
let obj1 = &#123;&#125;;
for (let i = 0; i &lt; arr.length; i++) &#123;
  let item = arr[i]
  if (obj1[item] !== undefined) &#123;
    arr[i] = arr[arr.length-1]
    arr.length--;
    i--; 
    continue;
  &#125;
  obj1[item] = item
&#125;
// arr: [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]


// Array.filter + Array.indexO
let newArr = arr.filter((item, index) =&gt; arr.indexOf(item) === index);  
// [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5


// Array.filter + Object.hasOwnProperty
let obj2 = &#123;&#125;
arr.filter(item =&gt; obj2.hasOwnProperty(typeof item + item) ? false : (obj2[typeof item + item] = true))


// Array.reduce + Array.includes
let newArr1 = arr.reduce((accu, cur) =&gt; &#123;
    return accu.includes(cur) ? accu : accu.concat(cur);  // 1. 拼接方法
    // return accu.includes(cur) ? accu : [...accu, cur]; // 2. 扩展运算
&#125;, [])


// Array.indexOf
let newArr2 = []
for (var i = 0; i &lt; arr.length; i++) &#123;
    if (newArr2.indexOf(arr[i]) === -1) newArr2.push(arr[i])  
&#125;
//等同于 forEach 写法
arr.forEach( item =&gt; newArr2.indexOf(item) === -1 ? newArr2.push(item) : &#39;&#39;)

//Array.includes
let newArr3 = []
for (var i = 0; i &lt; arr.length; i++) &#123;
    if (!newArr3.includes(arr[i]))  newArr3.push(arr[i])
&#125;
//等同于 forEach 写法
arr.forEach( item =&gt; !newArr3.includes(item) ? newArr3.push(item) : &#39;&#39;)


// new Set + 扩展运算符 || Array.from
let newArr5 = [...new Set(arr)];      // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]
let newArr4 = Array.from(new Set(arr));      // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]
let newStr = [...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)  //  &#39;abc&#39;


// new Map
let map = new Map();
let newStr6 = [];

for (let i = 0; i &lt; arr.length; i++) &#123;
    if (!map.has(arr[i])) &#123;
        map.set(arr[i], true);
        newStr6.push(arr[i]);
    &#125;
&#125;
console.log(newArr6)  // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]
</code></pre>
<h2 id="20-数组转为tree"><a href="#20-数组转为tree" class="headerlink" title="20.数组转为tree"></a>20.数组转为tree</h2><pre><code class="javascript">let arr= [
    &#123; id: 1, name: &#39;部门A&#39;, parentId: 0 &#125;,
    &#123; id: 3, name: &#39;部门C&#39;, parentId: 1 &#125;,
    &#123; id: 4, name: &#39;部门D&#39;, parentId: 1 &#125;,
    &#123; id: 5, name: &#39;部门E&#39;, parentId: 2 &#125;,
    &#123; id: 6, name: &#39;部门F&#39;, parentId: 3 &#125;,
    &#123; id: 7, name: &#39;部门G&#39;, parentId: 2 &#125;,
    &#123; id: 8, name: &#39;部门H&#39;, parentId: 4 &#125;,
    &#123; id: 18, name: &#39;部门K&#39;, parentId: 4 &#125;,
    &#123; id: 22, name: &#39;部门zz&#39;, parentId: 21 &#125;
]


function arrToTree(arr) &#123;
  arr=JSON.parse(JSON.stringify(arr))
  const newArr = []
  // 1. 构建一个字典：能够快速根据id找到对象。
  const map = &#123;&#125;
  arr.forEach(item =&gt; &#123;
    // 为了计算方便，统一添加children
    item.children = []
    // 构建一个字典
    map[item.id] = item
  &#125;)
 
  // 2. 对于arr中的每一项
  arr.forEach(item =&gt; &#123;
    const parent = map[item.parentId]
    if (parent) &#123;
      //    如果它有父级，把当前对象添加父级元素的children中
      parent.children.push(item)
    &#125; else &#123;
      //    如果它没有父级（pid:&#39;&#39;）,直接添加到newArr
      newArr.push(item)
    &#125;
  &#125;)
  return newArr
&#125;

console.log(arrToTree(arr))
</code></pre>
<h2 id="21-ajax"><a href="#21-ajax" class="headerlink" title="21.ajax"></a>21.ajax</h2><pre><code class="javascript">function ajax(option) &#123;//type,url,obj,timeout,success,error将所有参数换成一个对象&#123;&#125;
    //  0.将对象转换成字符串
    var str = objToString(option.data);
    //  1.创建一个异步对象xmlhttp；
    var xmlhttp, timer;
    if (window.XMLHttpRequest) &#123;
        xmlhttp = new XMLHttpRequest();
    &#125; else &#123;// code for IE6, IE5 
        xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
    &#125;
    //  2.设置请求方式和请求地址； 
    // 判断请求的类型是POST还是GET
    if (option.type.toLowerCase() === &#39;get&#39;) &#123;
        xmlhttp.open(option.type, option.url + &quot;?t=&quot; + str, true);
        //  3.发送请求；
        xmlhttp.send();
    &#125; else &#123;
        xmlhttp.open(option.type, option.url, true);
        // 注意：在post请求中，必须在open和send之间添加HTTP请求头：setRequestHeader(header,value);
        xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
        //  3.发送请求；
        xmlhttp.send(str);
    &#125;
    //  4.监听状态的变化；
    xmlhttp.onreadystatechange = function () &#123;
        clearInterval(timer);
        if (xmlhttp.readyState === 4) &#123;
            if (xmlhttp.status &gt;= 200 &amp;&amp; xmlhttp.status &lt; 300 || xmlhttp.status == 304) &#123;
                //  5.处理返回的结果；
                option.success(xmlhttp);//成功后回调；
            &#125; else &#123;
                option.error(xmlhttp);//失败后回调；
            &#125;
        &#125;
    &#125;
    //处理obj 
    function objToString(data) &#123;
        data.t = new Date().getTime();
        var res = [];
        for (var key in data) &#123;
            //需要将key和value转成非中文的形式，因为url不能有中文。使用encodeURIComponent();
            res.push(encodeURIComponent(key) + &quot; = &quot; + encodeURIComponent(data[key]));
        &#125;
        return res.join(&quot;&amp;&quot;);
    &#125;
    //判断外界是否传入了超时时间
    if (option.timeout) &#123;
        timer = setInterval(function () &#123;
            xmlhttp.abort();//中断请求
            clearInterval(timer);
        &#125;, timeout);
    &#125;
&#125;
</code></pre>
<h2 id="22-apply"><a href="#22-apply" class="headerlink" title="22.apply"></a>22.apply</h2><pre><code class="javascript">Function.prototype.apply2 = function(obj,arr)&#123;
    obj = obj?Object(obj):window;
    let _fn = &quot;fn&quot;,result;
    while (obj.hasOwnProperty(_fn)) &#123;
      _fn = &quot;fn&quot; + Math.random(); // 循环判断并重新赋值
    &#125;
    obj[_fn] = this;
    if(arr)&#123;
      result = obj[_fn](...arr);
    &#125;else&#123;
      result = obj[_fn]();
    &#125;
    delete obj[_fn];
    return result;
  &#125;
</code></pre>
<h2 id="23-async和await"><a href="#23-async和await" class="headerlink" title="23.async和await"></a>23.async和await</h2><pre><code class="javascript">function asyncToGen(genFunction) &#123;
    return function (...args) &#123;
      const gen = genFunction.apply(this, args);
      return new Promise((resolve, reject) =&gt; &#123;
        function step(key, arg) &#123;
          let genResult;
          try &#123;
            genResult = gen[key](arg);
          &#125; catch (err) &#123;
            return reject(err);
          &#125;
          const &#123; value, done &#125; = genResult;
          if (done) &#123;
            return resolve(value);
          &#125;
          return Promise.resolve(value).then(
            (val) =&gt; &#123;
              step(&#39;next&#39;, val);
            &#125;,
            (err) =&gt; &#123;
              step(&#39;throw&#39;, err);
            &#125;,
          );
        &#125;
        step(&#39;next&#39;);
      &#125;);
    &#125;;
  &#125;
  const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(&#39;data&#39;), 1000));
  function* testG() &#123;
    const data = yield getData();
    console.log(&#39;data: &#39;, data);
    const data2 = yield getData();
    console.log(&#39;data2: &#39;, data2);
    return &#39;success&#39;;
  &#125;
  
  const gen = asyncToGen(testG);
  gen().then(res =&gt; console.log(res));
</code></pre>
<h2 id="24-bind"><a href="#24-bind" class="headerlink" title="24.bind"></a>24.bind</h2><pre><code class="javascript">Function.prototype.bind2 = function (obj) &#123;
    obj = obj ? Object(obj) : window
    let myArguments = arguments
    let self = this
    if (arguments.length &gt; 1) &#123;
      return function () &#123;
        self.apply(obj, [...[...myArguments].slice(1), ...arguments])
      &#125;
    &#125;
    return function () &#123;
      self.apply(obj, [...arguments])
    &#125;
  &#125;
</code></pre>
<h2 id="25-call"><a href="#25-call" class="headerlink" title="25.call"></a>25.call</h2><pre><code class="javascript">Function.prototype.call2 = function(obj)&#123;
    obj = obj?Object(obj):window;
    let _fn = &quot;fn&quot;,result;
    while (obj.hasOwnProperty(_fn)) &#123;
      _fn = &quot;fn&quot; + Math.random(); // 循环判断并重新赋值
    &#125;
    obj[_fn] = this;
    if(arguments.length&gt;1)&#123;
      result = obj[_fn](...([...arguments].slice(1)));
    &#125;else&#123;
      result = obj[_fn]();
    &#125;
    delete obj[_fn];
    return result;
  &#125;
</code></pre>
<h2 id="26-filter"><a href="#26-filter" class="headerlink" title="26.filter"></a>26.filter</h2><pre><code class="javascript">Array.prototype.myFilter = function(callback, thisArg) &#123;
    // 确认调用者必须是个数组
    if (Object.prototype.toString.call(this) !== &#39;[object Array]&#39;) &#123;
      throw new TypeError(&#39;this must be a array&#39;);
    &#125;
    if (typeof callback !== &#39;function&#39;) &#123;
      throw new TypeError(callback + &#39;is not a function&#39;);
    &#125;
    // 返回结果的数组
    const res = [];
    // 让O成为回调函数的对象传递（强制转换对象）
    const O = Object(this);
    console.log(O)
    // &gt;&gt;&gt;0 保证len为number，且为正整数
    // 无符号位移计算符
    const len = O.length &gt;&gt;&gt; 0;
    // 对整个数组进行遍历
    for (let i = 0; i &lt; len; i++) &#123;
        // 遍历回调函数调用传参
        // call是传入（新this指向，参数）
        // thisArg新设置的this，这里无设置就是undefined
        // O[i] 是原数组的当前元素
        // i是当前index
        // O是原数组
        if (callback.call(thisArg, O[i], i, O)) &#123;
          res.push(O[i]);
        &#125;
    &#125;
    // 返回结果
    return res;
  &#125;
  console.log([30,20,16,10].myFilter((num) =&gt; &#123; return num &gt;= 12&#125;));
</code></pre>
<h2 id="27-forEach"><a href="#27-forEach" class="headerlink" title="27.forEach"></a>27.forEach</h2><pre><code class="javascript">Array.prototype.myForEach = function(callback, thisArg) &#123;
    // 判断是否是数组调用，并且传入的是回调函数
    if (this == null) &#123;
      throw new TypeError(&#39;this is null or not defined&#39;);
    &#125;
    if (typeof callback !== &quot;function&quot;) &#123;
      throw new TypeError(callback + &#39; is not a function&#39;);
    &#125;
    const O = Object(this);
    const len = O.length &gt;&gt;&gt; 0;
    let k = 0;
   // 循环所有数据  
   for(let i = 0; i &lt; len; i++) &#123;
    callback.call(thisArg, O[k], k, O);
   &#125;
  &#125;
</code></pre>
<h2 id="28-instanceof"><a href="#28-instanceof" class="headerlink" title="28.instanceof"></a>28.instanceof</h2><pre><code class="javascript">function new_instance_of(leftValue,rightValue)&#123;
    let rightProto = rightValue.prototype;//取右边表达式的 prototype 值
    leftValue = leftValue.__proto__;//取左表达式的 __proto__ 值
    while(true)&#123;
        if(leftValue == null)&#123;
            return false;
        &#125;
        if(leftValue === rightProto)&#123;
            return true;
        &#125;
        leftValue = leftValue.__proto__;
    &#125;
&#125;
function Foo()&#123;&#125;
console.log(new_instance_of(Foo,Object))//true
</code></pre>
<h2 id="29-jsonp"><a href="#29-jsonp" class="headerlink" title="29.jsonp"></a>29.jsonp</h2><pre><code class="javascript">let jsonp=(url,data=&#123;&#125;,callback=&#39;callback&#39;)=&gt;&#123;
    //准备好带有padding的请求url
let dataStr=url.indexOf(&#39;?&#39;)=== -1?&#39;?&#39;:&#39;&amp;&#39;
// console.log(dataStr);
for(let key in data)&#123;
    dataStr +=`$&#123;key&#125;=$&#123;data[key]&#125;&amp;`
&#125;
dataStr +=`callback=`+callback

//构造 script
let oScript=document.createElement(&#39;script&#39;)
oScript.src=url+dataStr
//appendChild () 方法可向节点的子节点列表的末尾添加新的子节点
document.body.appendChild(oScript)

// window[callback]=(data)=&gt;&#123;
//     console.log(data);
// &#125;
return new Promise((resolve,reject)=&gt;&#123;
    window[callback]=(data)=&gt;&#123;
        try&#123;
            resolve(data)
        &#125;catch(e)&#123;
            reject(e)
        &#125;finally&#123;
            oScript.parentNode.removeChild(oScript)// 注意这句代码，OScript移除,细节
        &#125;
    &#125;
&#125;)
&#125;

jsonp(&#39;https://photo.sina.cn/aj/index?a=1&#39;,&#123;
    page:1,
    cate:&#39;recommend&#39;
&#125;).then(response=&gt;&#123;
    console.log(response,&#39;-------then&#39;);
&#125;) 
</code></pre>
<h2 id="30-map"><a href="#30-map" class="headerlink" title="30.map"></a>30.map</h2><pre><code class="javascript">Array.prototype.myMap = function(callback, thisArg) &#123;
    if (this == undefined) &#123;
      throw new TypeError(&#39;this is null or not defined&#39;);
    &#125;
    if (typeof callback !== &#39;function&#39;) &#123;
      throw new TypeError(callback + &#39; is not a function&#39;);
    &#125;
    const res = [];
    const O = Object(this);
    const len = O.length &gt;&gt;&gt; 0;
    for (let i = 0; i &lt; len; i++) &#123;
       // 调用回调函数并传入新数组
       res[i] = callback.call(thisArg, O[i], i, O);
    &#125;
    return res;
  &#125;
</code></pre>
<h2 id="31-new"><a href="#31-new" class="headerlink" title="31.new"></a>31.new</h2><pre><code class="javascript">/**
 * new 使用Js原生实现
 */
function Parent(name, age) &#123;
    this.name = name;
    this.age = age;
    this.sayName = function () &#123;
        console.log(this.name);
    &#125;
&#125;
const _new = function (Parent, ...rest) &#123;
    //1.以构造器Parent的prototype为原型创建新对象
    const child = Object.create(Parent.prototype);
    //2. 将this和调用参数传给构造器执行
    const result = Parent.apply(child, rest);
    return typeof result === &#39;object&#39; ? result : child;
&#125;
const p1 = _new(Parent,&#39;www&#39;,&#39;23&#39;);
console.log(p1);
p1.sayName(); 
</code></pre>
<h2 id="32-object-create"><a href="#32-object-create" class="headerlink" title="32.object-create"></a>32.object-create</h2><pre><code class="javascript">Object.myCreate = function (proto, propertyObject = undefined) &#123;
    if (propertyObject === null) &#123;
      // 这里没有判断propertyObject是否是原始包装对象
      throw &#39;TypeError&#39;
    &#125; else &#123;
      function Fn () &#123;&#125;
      Fn.prototype = proto
      const obj = new Fn()
      if (propertyObject !== undefined) &#123;
        Object.defineProperties(obj, propertyObject)
      &#125;
      if (proto === null) &#123;
        // 创建一个没有原型对象的对象，Object.create(null)
        obj.__proto__ = null
      &#125;
      return obj
    &#125;
  &#125;
  
  // 示例
  // 第二个参数为null时，抛出TypeError
  // const throwErr = Object.myCreate(&#123;a: &#39;aa&#39;&#125;, null)  // Uncaught TypeError
  // 构建一个以
  const obj1 = Object.myCreate(&#123;a: &#39;aa&#39;&#125;)
  console.log(obj1)  // &#123;&#125;, obj1的构造函数的原型对象是&#123;a: &#39;aa&#39;&#125;
  const obj2 = Object.myCreate(&#123;a: &#39;aa&#39;&#125;, &#123;
    b: &#123;
      value: &#39;bb&#39;,
      enumerable: true
    &#125;
  &#125;)
  console.log(obj2)  // &#123;b: &#39;bb&#39;&#125;, obj2的构造函数的原型对象是&#123;a: &#39;aa&#39;&#125;
</code></pre>
<h2 id="33-object-is"><a href="#33-object-is" class="headerlink" title="33.object-is"></a>33.object-is</h2><pre><code class="javascript">Object.is = function(x, y) &#123;
    if (x === y) &#123;
        // 当前情况下，只有一种情况是特殊的，即 +0 -0
        // 如果 x !== 0，则返回true
        // 如果 x === 0，则需要判断+0和-0，则可以直接使用 1/+0 === Infinity 和 1/-0 === -Infinity来进行判断
        return x !== 0 || 1 / x === 1 / y;
    &#125;
    
    // x !== y 的情况下，只需要判断是否为NaN，如果x!==x，则说明x是NaN，同理y也一样
    // x和y同时为NaN时，返回true
    return x !== x &amp;&amp; y !== y;
&#125;
</code></pre>
<h2 id="34-promise-all"><a href="#34-promise-all" class="headerlink" title="34.promise.all"></a>34.promise.all</h2><pre><code class="javascript">Promise.prototype.all = function(promises)&#123;
    let results = [];
    let promiseCount = 0;
    let promisesLength = promises.length;
    return new Promise(function(resolve,reject)&#123;
        for(let val of promises)&#123;
            Promise.resolve(val).then(function(res)&#123;
                promiseCount++;
                results[i] = res;
                if(promiseCount === promisesLength)&#123;
                    return resolve(results);
                &#125;
            &#125;,function(err)&#123;
                return reject(err);
            &#125;)
        &#125;
    &#125;)
&#125;

let promise1 = new Promise(function(resolve) &#123;
    resolve(1);
  &#125;);
  let promise2 = new Promise(function(resolve) &#123;
    resolve(2);
  &#125;);
  let promise3 = new Promise(function(resolve) &#123;
    resolve(3);
  &#125;);
  
  let promiseAll = Promise.all([promise1, promise2, promise3]);
  promiseAll.then(function(res) &#123;
    console.log(res);
  &#125;);
</code></pre>
<h2 id="35-promise"><a href="#35-promise" class="headerlink" title="35.promise"></a>35.promise</h2><pre><code class="javascript">const PENDING = &#39;PENDING&#39;;
const FULFILLED = &#39;FULFILLED&#39;;
const REJECTED = &#39;REJECTED&#39;;

const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;
  // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1
  if (promise2 === x) &#123; 
    return reject(new TypeError(&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;))
  &#125;
  // Promise/A+ 2.3.3.3.3 只能调用一次
  let called;
  // 后续的条件要严格判断 保证代码能和别的库一起使用
  if ((typeof x === &#39;object&#39; &amp;&amp; x != null) || typeof x === &#39;function&#39;) &#123; 
    try &#123;
      // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1
      let then = x.then;
      if (typeof then === &#39;function&#39;) &#123; 
        // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3
        then.call(x, y =&gt; &#123; // 根据 promise 的状态决定是成功还是失败
          if (called) return;
          called = true;
          // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1
          resolvePromise(promise2, y, resolve, reject); 
        &#125;, r =&gt; &#123;
          // 只要失败就失败 Promise/A+ 2.3.3.3.2
          if (called) return;
          called = true;
          reject(r);
        &#125;);
      &#125; else &#123;
        // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4
        resolve(x);
      &#125;
    &#125; catch (e) &#123;
      // Promise/A+ 2.3.3.2
      if (called) return;
      called = true;
      reject(e)
    &#125;
  &#125; else &#123;
    // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4  
    resolve(x)
  &#125;
&#125;

class Promise &#123;
  constructor(executor) &#123;
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks= [];

    let resolve = (value) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125; 

    let reject = (reason) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125;

    try &#123;
      executor(resolve,reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

  then(onFulfilled, onRejected) &#123;
    //解决 onFufilled，onRejected 没有传值的问题
    //Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4
    onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : v =&gt; v;
    //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获
    onRejected = typeof onRejected === &#39;function&#39; ? onRejected : err =&gt; &#123; throw err &#125;;
    // 每次调用 then 都返回一个新的 promise  Promise/A+ 2.2.7
    let promise2 = new Promise((resolve, reject) =&gt; &#123;
      if (this.status === FULFILLED) &#123;
        //Promise/A+ 2.2.2
        //Promise/A+ 2.2.4 --- setTimeout
        setTimeout(() =&gt; &#123;
          try &#123;
            //Promise/A+ 2.2.7.1
            let x = onFulfilled(this.value);
            // x可能是一个proimise
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            //Promise/A+ 2.2.7.2
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === REJECTED) &#123;
        //Promise/A+ 2.2.3
        setTimeout(() =&gt; &#123;
          try &#123;
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === PENDING) &#123;
        this.onResolvedCallbacks.push(() =&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);

        this.onRejectedCallbacks.push(()=&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject)
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);
      &#125;
    &#125;);
  
    return promise2;
  &#125;
&#125;
</code></pre>
<h2 id="36-promise-race"><a href="#36-promise-race" class="headerlink" title="36.promise.race"></a>36.promise.race</h2><pre><code class="javascript">Promise.race = function(promises)&#123;
    //将可迭代对象转换为数组
    promises = Array.from(promises);
    return new Promise((resolve,reject)=&gt;&#123;
        if(promises.length === 0)&#123;
            //空的可迭代对象，用于pending状态
        &#125;else&#123;
            for(let i = 0;i &lt; promises.length;i++)&#123;
                Promise.resolve(promises[i]).then((data)=&gt;&#123;
                    resolve(data);
                &#125;).catch((reason)=&gt;&#123;
                    reject(reason)
                &#125;)
            &#125;
        &#125;
    &#125;)
&#125;

let p1 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;success&#39;)
    &#125;,1000)
&#125;)

let p2 = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
     resolve(&#39;faild&#39;)
    &#125;,500)
&#125;)

Promise.race([p1,p2]).then(result=&gt;&#123;
console.log(result)             //  faild    faild耗时短
&#125;)
</code></pre>
<h2 id="37-reduce"><a href="#37-reduce" class="headerlink" title="37.reduce"></a>37.reduce</h2><pre><code class="javascript">Array.prototype.myReduce = function(callback, initialValue) &#123;
    // 判断调用的是否是数组，以及传入的callback是否是函数
    if (this == undefined) &#123;
      throw new TypeError(&#39;this is null or not defined&#39;);
    &#125;
    if (typeof callback !== &#39;function&#39;) &#123;
      throw new TypeError(callbackfn + &#39; is not a function&#39;);
    &#125;
    // 空数组也是不允许的
    if (this.length == 0) &#123;
     throw new TypeError(&#39;Reduce of empty array with no initial value&#39;);
    &#125;
    // 让O成为回调函数的对象传递（强制转换对象）
    const O = Object(this);
    // &gt;&gt;&gt;0 保证len为number，且为正整数
    const len = this.length &gt;&gt;&gt; 0;
    // 保存初始值，初始值不传的时候为undefined
    let accumulator = initialValue;
    // 标志位
    let k = 0;
    // 如果第二个参数为undefined的情况，则数组的第一个有效值作为累加器的初始值
    if (accumulator === undefined) &#123;
      // 这里是k++，就是赋值完成之后k再加1
      accumulator = O[k++];
    &#125;
    // 此时如果有初始值，k是0，如果无初始值k是1
    for(k;k&lt;len;k++) &#123;
     accumulator = callback.call(this, accumulator, O[k], k, O);
    &#125;
    return accumulator;
  &#125;
  console.log([2,4,6].myReduce((t,n)=&gt;&#123;return t+n&#125;));
  console.log([2,4,6].myReduce((t,n)=&gt;&#123;return t+n&#125;,10));
</code></pre>
<h2 id="38-sleep"><a href="#38-sleep" class="headerlink" title="38.sleep"></a>38.sleep</h2><pre><code class="javascript">//Promise
const sleep = time =&gt; &#123;
    return new Promise(resolve =&gt; setTimeout(resolve,time))
  &#125;
  sleep(1000).then(()=&gt;&#123;
    console.log(1)
  &#125;)
  
  //Generator
  function* sleepGenerator(time) &#123;
    yield new Promise(function(resolve,reject)&#123;
      setTimeout(resolve,time);
    &#125;)
  &#125;
  sleepGenerator(1000).next().value.then(()=&gt;&#123;console.log(1)&#125;)
  
  //async
  function sleep(time) &#123;
    return new Promise(resolve =&gt; setTimeout(resolve,time))
  &#125;
  async function output() &#123;
    let out = await sleep(1000);
    console.log(1);
    return out;
  &#125;
  output();
  
  //ES5
  function sleep(callback,time) &#123;
    if(typeof callback === &#39;function&#39;)
      setTimeout(callback,time)
  &#125;
  
  function output()&#123;
    console.log(1);
  &#125;
  sleep(output,1000);
</code></pre>
<h2 id="39-vue-Reactive"><a href="#39-vue-Reactive" class="headerlink" title="39.vue-Reactive"></a>39.vue-Reactive</h2><pre><code class="javascript">const targetMap = new WeakMap();
let activeEffect = null; // 引入 activeEffect 变量

const effect = eff =&gt; &#123;
    activeEffect = eff; // 1. 将副作用赋值给 activeEffect
  activeEffect();     // 2. 执行 activeEffect
  activeEffect = null;// 3. 重置 activeEffect
&#125;

const track = (target, key) =&gt; &#123;
    if (activeEffect) &#123;  // 1. 判断当前是否有 activeEffect
        let depsMap = targetMap.get(target);
        if (!depsMap) &#123;
            targetMap.set(target, (depsMap = new Map()));
        &#125;
        let dep = depsMap.get(key);
        if (!dep) &#123;
            depsMap.set(key, (dep = new Set()));
        &#125;
        dep.add(activeEffect);  // 2. 添加 activeEffect 依赖
    &#125;
&#125;

const trigger = (target, key) =&gt; &#123;
    const depsMap = targetMap.get(target);
    if (!depsMap) return;
    let dep = depsMap.get(key);
    if (dep) &#123;
        dep.forEach(effect =&gt; effect());
    &#125;
&#125;;

const reactive = (target) =&gt; &#123;
    const handler = &#123;
        get(target, key, receiver) &#123;
            const result = Reflect.get(target, key, receiver);
            track(target, key);
            return result;
        &#125;,
        set(target, key, value, receiver) &#123;
            const oldValue = target[key];
            const result = Reflect.set(target, key, value, receiver);
            if (oldValue != result) &#123;
                trigger(target, key);
            &#125;
            return result;
        &#125;
    &#125;

    return new Proxy(target, handler);
&#125;

let product = reactive(&#123; price: 10, quantity: 2 &#125;);
let total = 0, salePrice = 0;
// 修改 effect 使用方式，将副作用作为参数传给 effect 方法
effect(() =&gt; &#123;
    total = product.price * product.quantity
&#125;);
effect(() =&gt; &#123;
    salePrice = product.price * 0.9
&#125;);
console.log(total, salePrice);  // 20 9
product.quantity = 5;
console.log(total, salePrice);  // 50 9
product.price = 20;
console.log(total, salePrice);  // 100 18
</code></pre>
<h2 id="40-算法笔试"><a href="#40-算法笔试" class="headerlink" title="40.算法笔试"></a>40.算法笔试</h2><h3 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h3><pre><code class="javascript">function insertionSort(arr) &#123;
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) &#123;
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        &#125;
        arr[preIndex+1] = current;
    &#125;
    return arr;
&#125;
const arr1 = [2,6,8,2,3,5,0,1,6,8]
let res = insertionSort(arr1)
console.log(arr1)//[ 0, 1, 2, 2, 3, 5, 6, 6, 8, 8]
</code></pre>
<h3 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2.堆排序"></a>2.堆排序</h3><pre><code class="javascript">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) &#123;   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;
        heapify(arr, i);
    &#125;
&#125;

function heapify(arr, i) &#123;     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;
        largest = left;
    &#125;

    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;
        largest = right;
    &#125;

    if (largest != i) &#123;
        swap(arr, i, largest);
        heapify(arr, largest);
    &#125;
&#125;

function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;

function heapSort(arr) &#123;
    buildMaxHeap(arr);

    for (var i = arr.length-1; i &gt; 0; i--) &#123;
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    &#125;
    return arr;
&#125;

const arr1 = [12,4,6,9,11,0,4,3,7,9]
let res = heapSort(arr1)
console.log(res)//[0, 3, 4,  4,  6, 7, 9, 9, 11, 12]
</code></pre>
<h3 id="3-斐波那契数列"><a href="#3-斐波那契数列" class="headerlink" title="3.斐波那契数列"></a>3.斐波那契数列</h3><pre><code class="javascript">//方法一：使用递归
function fibonacci(n) &#123;
    if (n == 1 || n == 2) &#123;
        return 1
    &#125;;
    return fibonacci(n - 2) + fibonacci(n - 1);
&#125;
console.log(fibonacci(3))//2

//方法二：改进递归-把前两位数字做成参数避免重复计算
function fibonacci(n) &#123;
    function fib(n, v1, v2) &#123;
        if (n == 1)
            return v1;
        if (n == 2)
            return v2;
        else
            return fib(n - 1, v2, v1 + v2)
    &#125;
    return fib(n, 1, 1)
&#125;
fibonacci(30)

//方法三：改进递归-利用闭包特性把运算结果存储在数组里，避免重复计算
var fibonacci = function () &#123;
    let memo = [0, 1];
    let fib = function (n) &#123;
        if (memo[n] == undefined) &#123;
            memo[n] = fib(n - 2) + fib(n - 1)
        &#125;
        return memo[n]
    &#125;
    return fib;
&#125;()
fibonacci(30)


//方法四：改进递归-摘出存储计算结果的功能函数
var memoizer = function (func) &#123;
    let memo = [];
    return function (n) &#123;
        if (memo[n] == undefined) &#123;
            memo[n] = func(n)
        &#125;
        return memo[n]
    &#125;
&#125;;
var fibonacci=memoizer(function(n)&#123;
    if (n == 1 || n == 2) &#123;
        return 1
    &#125;;
    return fibonacci(n - 2) + fibonacci(n - 1);
&#125;)
fibonacci(30)


//方法五：普通for循环
function fibonacci(n) &#123;
    var n1 = 1, n2 = 1, sum;
    for (let i = 2; i &lt; n; i++) &#123;
        sum = n1 + n2
        n1 = n2
        n2 = sum
    &#125;
    return sum
&#125;
fibonacci(30)

//方法六：for循环+解构赋值
var fibonacci = function (n) &#123;
    let n1 = 1; n2 = 1;
    for (let i = 2; i &lt; n; i++) &#123;
        [n1, n2] = [n2, n1 + n2]
    &#125;
    return n2
&#125;
fibonacci(30)
</code></pre>
<h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h3><pre><code class="javascript">function mergeSort(arr) &#123;  // 采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    var result = [];

    while (left.length &amp;&amp; right.length) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
&#125;


const arr1 = [1,4,6,1,0,3,4,2,7,3,1]
let res = mergeSort(arr1)
console.log(res)//[0, 1, 1, 1, 2,3, 3, 4, 4, 6,7]
</code></pre>
<h3 id="5-汉诺塔问题"><a href="#5-汉诺塔问题" class="headerlink" title="5.汉诺塔问题"></a>5.汉诺塔问题</h3><pre><code class="javascript">/** 
 * @param &#123;圆盘数：number&#125; plates 
 * @param &#123;起始柱子 a：string&#125; source 
 * @param &#123;辅助柱子 b：string&#125; helper 
 * @param &#123;目标柱子 c：string&#125; dest 
 * @param &#123;移动步骤集：Array，数组的长度就是移动的次数&#125; moves 
 */
function hanoi(plates, source, helper, dest, moves = []) &#123;
    if (plates &lt;= 0) &#123;
        return moves;
    &#125;
    if (plates === 1) &#123;
        moves.push([source, dest]);
    &#125; else &#123;
        hanoi(plates - 1, source, dest, helper, moves);
        moves.push([source, dest]);
        hanoi(plates - 1, helper, source, dest, moves);
    &#125;
    return moves;
&#125;

// test
console.log(hanoi(4, &#39;source&#39;, &#39;helper&#39;, &#39;dest&#39;)); // 输出结果如下图展示
</code></pre>
<h3 id="6-合并两个有序数组"><a href="#6-合并两个有序数组" class="headerlink" title="6.合并两个有序数组"></a>6.合并两个有序数组</h3><pre><code class="javascript">var merge = function (nums1, m, nums2, n) &#123;
    var p = m + n - 1;//0
    var p1 = m - 1;//-1
    var p2 = n - 1;//0
      // 理论上来说，nums2应该全部填充进去，所以这里以p2作为条件
    while (p2 &gt;= 0) &#123;
        // nums1里面全是0的情况，比如[0], 0, [1], 1
        if (p1 &lt; 0) &#123;
            // 直接用nums2去填补nums1就好了
            nums1[p--] = nums2[p2--]
        // 只有nums2比nums1大才用nus2填补
        &#125; else if (nums2[p2] &gt; nums1[p1]) &#123;
            nums1[p] = nums2[p2];
            p--;
            p2--;
        // 反之用nums1填补
        &#125; else &#123;
            nums1[p] = nums1[p1];
            p--;
            p1--;
        &#125;
    &#125;;
    return nums1;
&#125;;

let nums1 = [1,2,3,0,0,0], m = 3,nums2 = [2,5,6],n = 3
console.log(merge(nums1, m, nums2, n))//[ 1, 2, 2, 3, 5, 6 ]
</code></pre>
<h3 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h3><pre><code class="javascript">function quickSort(arr, left, right) &#123;
    var len = arr.length,
        partitionIndex,
        left = typeof left != &#39;number&#39; ? 0 : left,
        right = typeof right != &#39;number&#39; ? len - 1 : right;

    if (left &lt; right) &#123;
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    &#125;
    return arr;
&#125;

function partition(arr, left ,right) &#123;     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) &#123;
        if (arr[i] &lt; arr[pivot]) &#123;
            swap(arr, i, index);
            index++;
        &#125;        
    &#125;
    swap(arr, pivot, index - 1);
    return index-1;
&#125;

function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;
function partition2(arr, low, high) &#123;
  let pivot = arr[low];
  while (low &lt; high) &#123;
    while (low &lt; high &amp;&amp; arr[high] &gt; pivot) &#123;
      --high;
    &#125;
    arr[low] = arr[high];
    while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;
      ++low;
    &#125;
    arr[high] = arr[low];
  &#125;
  arr[low] = pivot;
  return low;
&#125;

function quickSort2(arr, low, high) &#123;
  if (low &lt; high) &#123;
    let pivot = partition2(arr, low, high);
    quickSort2(arr, low, pivot - 1);
    quickSort2(arr, pivot + 1, high);
  &#125;
  return arr;
&#125;

const arr1 = [1,4,6,1,0,3,4,2,7,3,1]
let res = quickSort(arr1,0,11)
console.log(res)//[ 0, 1, 1, 1, 2, 3, 3, 4, 4, 6,7]
</code></pre>
<h3 id="8-两数之和"><a href="#8-两数之和" class="headerlink" title="8.两数之和"></a>8.两数之和</h3><pre><code class="javascript">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number[]&#125;
 */
const twoSum = (nums, target) =&gt; &#123;
    const prevNums = &#123;&#125;;                    // 存储出现过的数字，和对应的索引               
  
    for (let i = 0; i &lt; nums.length; i++) &#123;       // 遍历元素   
      const curNum = nums[i];                     // 当前元素   
      const targetNum = target - curNum;          // 满足要求的目标元素   
      const targetNumIndex = prevNums[targetNum]; // 在prevNums中获取目标元素的索引
      if (targetNumIndex !== undefined) &#123;         // 如果存在，直接返回 [目标元素的索引,当前索引]
        return [targetNumIndex, i];
      &#125; else &#123;                                    // 如果不存在，说明之前没出现过目标元素
        prevNums[curNum] = i;                     // 存入当前的元素和对应的索引
      &#125;
    &#125;
  &#125;

  let nums = [2,7,11,15], target = 17
  console.log(twoSum(nums,target))//[ 0, 3 ]
</code></pre>
<h3 id="9-冒泡排序"><a href="#9-冒泡排序" class="headerlink" title="9.冒泡排序"></a>9.冒泡排序</h3><pre><code class="javascript"> //双向冒泡排序
 function bubbleSort_twoway(arr) &#123;
    var len = arr.length;    //依次将最大的数放置到数组末尾，将第二大的数放到倒数第二位...
    var flag = false;
    for(var i = 0; i &lt; len/2; i++) &#123;
        flag = false;
        for(var j = i; j &lt; len - 1 - i; j++) &#123;   //从前往后,比较相邻两个数,把大的放在后边.之前已放置成功的可以不再参与比较
            if(arr[j] &gt; arr[j + 1]) &#123;
                var middle = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = middle;
                flag =true;
            &#125;
        &#125;
        if(!flag)&#123;
            break;
        &#125;

        for(var j = len - 1 - i; j &gt; i; j--)&#123;
            if(arr[j] &lt; arr[j - 1]) &#123;
                var middle = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = middle;
                flag = true;
            &#125;
        &#125;
        if(!flag)&#123;
            break;
        &#125;
    &#125;
    return arr;
&#125;

var defaultArr = [3, 5, 32, 15, 7, 26, 10, 55, 45, 12, 28, 88, 18];
var resultArr = bubbleSort_twoway(defaultArr);
console.table(resultArr);
</code></pre>
<h3 id="10-爬台阶"><a href="#10-爬台阶" class="headerlink" title="10.爬台阶"></a>10.爬台阶</h3><pre><code class="javascript">/**
 * @param &#123;number&#125; n
 * @return &#123;number&#125;
 */
var climbStairs = function(n) &#123;
    const sqrt_5 = Math.sqrt(5);
    const fib_n = Math.pow((1 + sqrt_5) / 2, n + 1) - Math.pow((1 - sqrt_5) / 2,n + 1);
    return Math.round(fib_n / sqrt_5);
&#125;;


/**
 * @param &#123;number&#125; n
 * @return &#123;number&#125;
 */
var climbStairs = function(n) &#123;
    const dp = [];
    dp[0] = 1;
    dp[1] = 1;
    for(let i = 2; i &lt;= n; i++) &#123;
        dp[i] = dp[i - 1] + dp[i - 2];
    &#125;
    return dp[n];
&#125;;
</code></pre>
<h3 id="11-数组交集"><a href="#11-数组交集" class="headerlink" title="11.数组交集"></a>11.数组交集</h3><pre><code class="javascript">//数组功能扩展
//数组迭代函数
Array.prototype.each = function(fn)&#123;
    fn = fn || Function.K;
    var a = [];
    var args = Array.prototype.slice.call(arguments, 1);
    for(var i = 0; i &lt; this.length; i++)&#123;
    var res = fn.apply(this,[this[i],i].concat(args));
    if(res != null) a.push(res);
    &#125;
    return a;
   &#125;;
   //数组是否包含指定元素
   Array.prototype.contains = function(suArr)&#123;
    for(var i = 0; i &lt; this.length; i ++)&#123;
    if(this[i] == suArr)&#123;
    return true;
    &#125;
    &#125;
    return false;
   &#125;
   //不重复元素构成的数组
   Array.prototype.uniquelize = function()&#123;
    var ra = new Array();
    for(var i = 0; i &lt; this.length; i ++)&#123;
    if(!ra.contains(this[i]))&#123;
    ra.push(this[i]);
    &#125;
    &#125;
    return ra;
   &#125;;
   //两个数组的交集
   Array.intersect = function(a, b)&#123;
    return a.uniquelize().each(function(o)&#123;return b.contains(o) ? o : null&#125;);
   &#125;;
   //两个数组的差集
   Array.minus = function(a, b)&#123;
    return a.uniquelize().each(function(o)&#123;return b.contains(o) ? null : o&#125;);
   &#125;;
   //两个数组的补集
   Array.complement = function(a, b)&#123;
    return Array.minus(Array.union(a, b),Array.intersect(a, b));
   &#125;;
   //两个数组并集
   Array.union = function(a, b)&#123;
    return a.concat(b).uniquelize();
   &#125;;


var a = [1,2,3,4,5]
var b = [2,4,6,8,10]
console.log(&quot;数组a：&quot;, a);
console.log(&quot;数组b：&quot;, b);
var sa = new Set(a);
var sb = new Set(b);
// 交集
let intersect = a.filter(x =&gt; sb.has(x));
// 差集
let minus = a.filter(x =&gt; !sb.has(x));
// 补集
let complement = [...a.filter(x =&gt; !sb.has(x)), ...b.filter(x =&gt; !sa.has(x))];
// 并集
let unionSet = Array.from(new Set([...a, ...b]));
console.log(&quot;a与b的交集：&quot;, intersect);
console.log(&quot;a与b的差集：&quot;, minus);
console.log(&quot;a与b的补集：&quot;, complement);
console.log(&quot;a与b的并集：&quot;, unionSet);
</code></pre>
<h3 id="12-希尔排序"><a href="#12-希尔排序" class="headerlink" title="12.希尔排序"></a>12.希尔排序</h3><pre><code class="javascript">function shellSort(arr) &#123;
    var len = arr.length,
        temp,
        gap = 1;
    while(gap &lt; len/3) &#123;          //动态定义间隔序列
        gap =gap*3+1;
    &#125;
    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123;
        for (var i = gap; i &lt; len; i++) &#123;
            temp = arr[i];
            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;
                arr[j+gap] = arr[j];
            &#125;
            arr[j+gap] = temp;
        &#125;
    &#125;
    return arr;
&#125;

var defaultArr = [3, 5, 32, 15, 7, 26, 10, 55, 45, 12, 28, 88, 18];
var resultArr = shellSort(defaultArr);
console.table(resultArr);
</code></pre>
<h3 id="13-旋转数组"><a href="#13-旋转数组" class="headerlink" title="13.旋转数组"></a>13.旋转数组</h3><pre><code class="javascript">/**
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
 */

let reverse = function(nums, start, end)&#123;
    while(start &lt; end)&#123;
        [nums[start++], nums[end--]] = [nums[end], nums[start]];
    &#125;
&#125;
let rotate = function(nums, k) &#123;
    k %= nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
    return nums;
&#125;;
</code></pre>
<h3 id="14-选择排序"><a href="#14-选择排序" class="headerlink" title="14.选择排序"></a>14.选择排序</h3><pre><code class="javascript">function selectionSort(arr) &#123;
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) &#123;
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) &#123;
            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    return arr;
&#125;
var defaultArr = [3, 5, 32, 15, 7, 26, 10, 55, 45, 12, 28, 88, 18];
var resultArr = selectionSort(defaultArr);
console.table(resultArr);
</code></pre>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mengfeng.github.io/2023/01/05/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AF%95/" rel="tag">笔试</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2023/01/02/umi-4-0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">umi-4.0</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '6887374e7666a97fd4dc',
    clientSecret: '09a8e143dd4a3f5d11311e1435842321e063157d',
    repo: 'mengfeng.github.io',
    owner: 'mengfeng',
    admin: ['mengfeng'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>