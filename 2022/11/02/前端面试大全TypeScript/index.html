<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>前端面试大全TypeScript |  艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-前端面试大全TypeScript"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  前端面试大全TypeScript
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/" class="article-date">
  <time datetime="2022-11-02T02:27:06.000Z" itemprop="datePublished">2022-11-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/">技术面试</a> / <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95/TypeScript/">TypeScript</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">18.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">75 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前端面试题大全（TypeScript）"><a href="#前端面试题大全（TypeScript）" class="headerlink" title="前端面试题大全（TypeScript）"></a>前端面试题大全（TypeScript）</h1><p>前端面试题类目分类</p>
<ul>
<li>HTML5 + CSS3</li>
<li>JavaScript</li>
<li>Vue + Vue3</li>
<li>React</li>
<li>Webpack</li>
<li>服务端</li>
</ul>
<hr>
<p>考点频率 ：♥︎ 、 ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎、 ♥︎ ♥︎ ♥︎ ♥︎ ♥︎</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-typescript-的理解？与-javascript-的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-typescript-的理解？与-javascript-的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 typescript 的理解？与 javascript 的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 typescript 的理解？与 javascript 的区别？</h3><h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>TypeScript</code> 是 <code>JavaScript</code> 的类型的超集，支持<code>ES6</code>语法，支持面向对象编程的概念，如类、接口、继承、泛型等</p>
<blockquote>
<p>超集，不得不说另外一个概念，子集，怎么理解这两个呢，举个例子，如果一个集合A里面的的所有元素集合B里面都存在，那么我们可以理解集合B是集合A的超集，集合A为集合B的子集</p>
</blockquote>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36316332633166302d303935302d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>其是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误</p>
<p>同时扩展了<code> JavaScript</code> 的语法，所以任何现有的<code> JavaScript</code> 程序可以不加改变的在 <code>TypeScript</code> 下工作</p>
<p>为了保证兼容性，<code>typescript</code>在编译阶段需要编译器编译成纯<code>Javascript</code>来运行，是为大型应用之开发而设计的语言，如下：</p>
<p><code>tsx</code>文件如下：</p>
<pre><code class="typescript">const hello : string = &quot;Hello World!&quot;
console.log(hello)
</code></pre>
<p>编译文件后：</p>
<pre><code class="tsx">const hello = &quot;Hello World!&quot;
console.log(hello)
</code></pre>
<h4 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h4><p><code>typescript</code>的特性主要有如下：</p>
<ul>
<li>类型批注和编译时类型检查 ：在编译时批注变量类型</li>
<li>类型推断：ts中没有批注变量类型会自动推断变量的类型</li>
<li>类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除</li>
<li>接口：ts中用接口来定义对象类型</li>
<li>枚举：用于取值被限定在一定范围内的场景</li>
<li>Mixin：可以接受任意类型的值</li>
<li>泛型编程：写代码时使用一些以后才指定的类型</li>
<li>名字空间：名字只在该区域内有效，其他区域可重复使用该名字而不冲突</li>
<li>元组：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li>
<li>…</li>
</ul>
<h5 id="类型批注"><a href="#类型批注" class="headerlink" title="类型批注"></a>类型批注</h5><p>通过类型批注提供在编译时启动类型检查的静态类型，这是可选的，而且可以忽略而使用<code>JavaScript</code>常规的动态类型</p>
<pre><code class="tsx">function Add(left: number, right: number): number &#123;
 return left + right;
&#125;
</code></pre>
<p>对于基本类型的批注是<code>number</code>、<code>bool</code>和<code>string</code>，而弱或动态类型的结构则是<code>any</code>类型</p>
<h5 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h5><p>当类型没有给出时，TypeScript编译器利用类型推断来推断类型，如下：</p>
<pre><code class="tsx">let str = &#39;string&#39;
</code></pre>
<p>变量<code>str</code>被推断为字符串类型，这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</p>
<p>如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态<code>any</code>类型</p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口简单来说就是用来描述对象的类型 数据的类型有<code>number</code>、<code> null</code>、<code> string</code>等数据格式，对象的类型就是用接口来描述的</p>
<pre><code class="tsx">interface Person &#123;
    name: string;
    age: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25
&#125;;
</code></pre>
<h4 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h4><ul>
<li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li>
<li>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译</li>
<li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li>
<li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件</li>
</ul>
<p>更多的区别如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36623534343034302d303935302d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-typescript-的数据类型有哪些"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-typescript-的数据类型有哪些" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ typescript 的数据类型有哪些?"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ typescript 的数据类型有哪些?</h3><h4 id="一、是什么-1"><a href="#一、是什么-1" class="headerlink" title="一、是什么"></a>一、是什么</h4><p><code>typescript</code> 和 <code>javascript</code>几乎一样，拥有相同的数据类型，另外在<code>javascript</code>基础上提供了更加实用的类型供开发使用</p>
<p>在开发阶段，可以为明确的变量定义为某种类型，这样<code>typescript</code>就能在编译阶段进行类型检查，当类型不合符预期结果的时候则会出现错误提示</p>
<h4 id="二、有哪些"><a href="#二、有哪些" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p><code>typescript</code> 的数据类型主要有如下：</p>
<ul>
<li>boolean（布尔类型）</li>
<li>number（数字类型）</li>
<li>string（字符串类型）</li>
<li>array（数组类型）</li>
<li>tuple（元组类型）</li>
<li>enum（枚举类型）</li>
<li>any（任意类型）</li>
<li>null 和 undefined 类型</li>
<li>Symbol 类型</li>
<li>bigint类型</li>
<li>void 类型</li>
<li>never 类型</li>
<li>object 对象类型</li>
<li>unknown</li>
</ul>
<h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><p>布尔类型</p>
<pre><code class="tsx">let flag:boolean = true;
// flag = 123; // 错误
flag = false;  //正确
</code></pre>
<h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><p>数字类型，和<code>javascript</code>一样，<code>typescript</code>的数值类型都是浮点数，可支持二进制、八进制、十进制和十六进制</p>
<pre><code class="tsx">let num:number = 123;
// num = &#39;456&#39;; // 错误
num = 456;  //正确
</code></pre>
<p>进制表示：</p>
<pre><code class="tsx">let decLiteral: number = 6; // 十进制
let hexLiteral: number = 0xf00d; // 十六进制
let binaryLiteral: number = 0b1010; // 二进制
let octalLiteral: number = 0o744; // 八进制
</code></pre>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>字符串类型，和<code>JavaScript</code>一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串</p>
<pre><code class="tsx">let str:string = &#39;this is ts&#39;;
str = &#39;test&#39;;
</code></pre>
<p>作为超集，当然也可以使用模版字符串&#96;&#96;进行包裹，通过 ${} 嵌入变量</p>
<pre><code class="tsx">let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is $&#123; name &#125;
</code></pre>
<h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>数组类型，跟<code>javascript</code>一致，通过<code>[]</code>进行包裹，有两种写法：</p>
<p>方式一：元素类型后面接上 <code>[]</code></p>
<pre><code class="tsx"> let arr:string[] = [&#39;12&#39;, &#39;23&#39;];
 arr = [&#39;45&#39;, &#39;56&#39;];
</code></pre>
<p>方式二：使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<pre><code class="tsx">let arr:Array&lt;number&gt; = [1, 2];
arr = [&#39;45&#39;, &#39;56&#39;];
</code></pre>
<h5 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h5><p>元祖类型，允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p>
<pre><code class="tsx">let tupleArr:[number, string, boolean];
tupleArr = [12, &#39;34&#39;, true]; //ok
typleArr = [12, &#39;34&#39;] // no ok
</code></pre>
<p>赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致</p>
<h5 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h5><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p>
<pre><code class="tsx">enum Color &#123;Red, Green, Blue&#125;
let c: Color = Color.Green;
</code></pre>
<h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><p>可以指定任何类型的值，在编程阶段还不清楚类型的变量指定一个类型，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，这时候可以使用<code>any</code>类型</p>
<p>使用<code>any</code>类型允许被赋值为任意类型，甚至可以调用其属性、方法</p>
<pre><code class="tsx">let num:any = 123;
num = &#39;str&#39;;
num = true;
</code></pre>
<p>定义存储各种类型数据的数组时，示例代码如下：</p>
<pre><code class="tsx">let arrayList: any[] = [1, false, &#39;fine&#39;];
arrayList[1] = 100;
</code></pre>
<h5 id="null-和-和-undefined"><a href="#null-和-和-undefined" class="headerlink" title="null 和 和 undefined"></a>null 和 和 undefined</h5><p>在<code> JavaScript</code> 中 <code>null </code>表示 “什么都没有”，是一个只有一个值的特殊类型，表示一个空对象引用，而<code>undefined</code>表示一个没有设置值的变量</p>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型， 就是说你可以把 <code>null </code>和 <code>undefined </code>赋值给 <code>number </code>类型的变量</p>
<pre><code class="tsx">let num:number | undefined; // 数值类型 或者 undefined
console.log(num); // 正确
num = 123;
console.log(num); // 正确
</code></pre>
<p>但是<code>ts</code>配置了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自</p>
<h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><p>用于标识方法返回值的类型，表示该方法没有返回值。</p>
<pre><code class="tsx">function hello(): void &#123;
    alert(&quot;Hello Runoob&quot;);
&#125;
</code></pre>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>symbol我们平时用的比较少，所以可能了解也不是很多，这里就详细来说说symbol。</p>
<h6 id="（1）symbol-基本使用"><a href="#（1）symbol-基本使用" class="headerlink" title="（1）symbol 基本使用"></a>（1）symbol 基本使用</h6><p>symbol 是 ES6 新增的一种基本数据类型，它用来表示独一无二的值，可以通过 Symbol 构造函数生成。</p>
<pre><code class="typescript">const s = Symbol(); 
typeof s; // symbol
</code></pre>
<p>注意：Symbol 前面不能加 new关键字，直接调用即可创建一个独一无二的 symbol 类型的值。</p>
<p>可以在使用 Symbol 方法创建 symbol 类型值的时候传入一个参数，这个参数需要是一个字符串。如果传入的参数不是字符串，会先自动调用传入参数的 toString 方法转为字符串：</p>
<pre><code class="typescript">const s1 = Symbol(&quot;TypeScript&quot;); 
const s2 = Symbol(&quot;Typescript&quot;); 
console.log(s1 === s2); // false
</code></pre>
<p>上面代码的第三行可能会报一个错误：This condition will always return ‘false’ since the types ‘unique symbol’ and ‘unique symbol’ have no overlap. 这是因为编译器检测到这里的 s1 &#x3D;&#x3D;&#x3D; s2 始终是false，所以编译器提醒这代码写的多余，建议进行优化。</p>
<p>上面使用Symbol创建了两个symbol对象，方法中都传入了相同的字符串，但是两个symbol值仍然是false，这就说明了 Symbol 方法会返回一个独一无二的值。Symbol 方法传入的这个字符串，就是方便我们区分 symbol 值的。可以调用 symbol 值的 toString 方法将它转为字符串：</p>
<pre><code class="typescript">const s1 = Symbol(&quot;Typescript&quot;); 
console.log(s1.toString());  // &#39;Symbol(Typescript)&#39;
console.log(Boolean(s));     // true 
console.log(!s);             // false
</code></pre>
<p>在TypeScript中使用symbol就是指定一个值的类型为symbol类型：</p>
<pre><code class="typescript">let a: symbol = Symbol()
</code></pre>
<p>TypeScript 中还有一个 unique symbol 类型，它是symbol的子类型，这种类型的值只能由<code>Symbol()</code>或<code>Symbol.for()</code>创建，或者通过指定类型来指定变量是这种类型。这种类型的值只能用于常量的定义和用于属性名。需要注意，定义unique symbol类型的值，必须用 const 而不能用let来声明。下面来看在TypeScript中使用Symbol值作为属性名的例子：</p>
<pre><code class="typescript">const key1: unique symbol = Symbol()
let key2: symbol = Symbol()
const obj = &#123;
    [key1]: &#39;value1&#39;,
    [key2]: &#39;value2&#39;
&#125;
console.log(obj[key1]) // value1
console.log(obj[key2]) // error 类型“symbol”不能作为索引类型使用。
</code></pre>
<h6 id="（2）symbol-作为属性名"><a href="#（2）symbol-作为属性名" class="headerlink" title="（2）symbol 作为属性名"></a>（2）symbol 作为属性名</h6><p>在ES6中，对象的属性是支持表达式的，可以使用于一个变量来作为属性名，这对于代码的简化有很多用处，表达式必须放在大括号内：</p>
<pre><code class="typescript">let prop = &quot;name&quot;; 
const obj = &#123; 
  [prop]: &quot;TypeScript&quot; 
&#125;;
console.log(obj.name); // &#39;TypeScript&#39;
</code></pre>
<p>symbol 也可以作为属性名，因为symbol的值是独一无二的，所以当它作为属性名时，不会与其他任何属性名重复。当需要访问这个属性时，只能使用这个symbol值来访问（必须使用方括号形式来访问）：</p>
<pre><code class="typescript">let name = Symbol(); 
let obj = &#123; 
  [name]: &quot;TypeScript&quot; 
&#125;;
console.log(obj); // &#123; Symbol(): &#39;TypeScript&#39; &#125;
console.log(obj[name]); // &#39;TypeScript&#39; 
console.log(obj.name);  // undefined
</code></pre>
<p>在使用obj.name访问时，实际上是字符串name，这和访问普通字符串类型的属性名是一样的，要想访问属性名为symbol类型的属性时，必须使用方括号。方括号中的name才是我们定义的symbol类型的变量name。</p>
<h6 id="（3）symbol-属性名遍历"><a href="#（3）symbol-属性名遍历" class="headerlink" title="（3）symbol 属性名遍历"></a>（3）symbol 属性名遍历</h6><p>使用 Symbol 类型值作为属性名，这个属性是不会被 for…in遍历到的，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 、 JSON.stringify() 等方法获取到：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
for (const key in obj) &#123; 
  console.log(key); 
&#125;  
// =&gt; &#39;age&#39; 
console.log(Object.keys(obj));  // [&#39;age&#39;] 
console.log(Object.getOwnPropertyNames(obj));  // [&#39;age&#39;] 
console.log(JSON.stringify(obj)); // &#39;&#123; &quot;age&quot;: 18 &#125;
</code></pre>
<p>虽然这些方法都不能访问到Symbol类型的属性名，但是Symbol类型的属性并不是私有属性，可以使用 <code>Object.getOwnPropertySymbols</code> 方法获取对象的所有symbol类型的属性名：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
const SymbolPropNames = Object.getOwnPropertySymbols(obj); 
console.log(SymbolPropNames); // [ Symbol(name) ] 
console.log(obj[SymbolPropNames[0]]); // &#39;TypeScript&#39; 
</code></pre>
<p>除了这个方法，还可以使用ES6提供的 Reflect 对象的静态方法 Reflect.ownKeys ，它可以返回所有类型的属性名，Symbol 类型的也会返回：</p>
<pre><code class="typescript">const name = Symbol(&quot;name&quot;); 
const obj = &#123; 
  [name]: &quot;TypeScript&quot;, 
  age: 18 
&#125;;
console.log(Reflect.ownKeys(obj)); // [ &#39;age&#39;, Symbol(name) ]
</code></pre>
<h6 id="（4）symbol-静态方法"><a href="#（4）symbol-静态方法" class="headerlink" title="（4）symbol 静态方法"></a>（4）symbol 静态方法</h6><p>Symbol 包含两个静态方法， for 和 keyFor 。</p>
<p>1）Symbol.for()</p>
<p>用Symbol创建的symbol类型的值都是独一无二的。使用 Symbol.for 方法传入字符串，会先检查有没有使用该字符串调用 Symbol.for 方法创建的 symbol 值。如果有，返回该值；如果没有，则使用该字符串新创建一个。使用该方法创建 symbol 值后会在全局范围进行注册。</p>
<pre><code class="typescript">const iframe = document.createElement(&quot;iframe&quot;); 
iframe.src = String(window.location); 
document.body.appendChild(iframe); 

iframe.contentWindow.Symbol.for(&quot;TypeScript&quot;) === Symbol.for(&quot;TypeScript&quot;); // true // 注意：如果你在JavaScript环境中这段代码是没有问题的，但是如果在TypeScript开发环境中，可能会报错：类型“Window”上不存在属性“Symbol”。 // 因为这里编译器推断出iframe.contentWindow是Window类型，但是TypeScript的声明文件中，对Window的定义缺少Symbol这个字段，所以会报错，
</code></pre>
<p>上面代码中，创建了一个iframe节点并把它放在body中，通过这个 iframe 对象的 contentWindow 拿到这个 iframe 的 window 对象，在 iframe.contentWindow上添加一个值就相当于在当前页面定义一个全局变量一样。可以看到，在 iframe 中定义的键为 TypeScript 的 symbol 值在和在当前页面定义的键为’TypeScript’的symbol 值相等，说明它们是同一个值。</p>
<p>2）Symbol.keyFor()</p>
<p>该方法传入一个 symbol 值，返回该值在全局注册的键名：</p>
<pre><code class="typescript">const sym = Symbol.for(&quot;TypeScript&quot;); 
console.log(Symbol.keyFor(sym)); // &#39;TypeScript&#39;
</code></pre>
<h5 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h5><p>BigInt是ES6中新引入的数据类型，它是一种内置对象，它提供了一种方法来表示大于 2- 1 的整数，BigInt可以表示任意大的整数。</p>
<p>使用 <code>BigInt</code> 可以安全地存储和操作大整数，即使这个数已经超出了JavaScript构造函数 Number 能够表示的安全整数范围。</p>
<p>我们知道，在 JavaScript 中采用双精度浮点数，这导致精度有限，比如 <code>Number.MAX_SAFE_INTEGER</code> 给出了可以安全递增的最大可能整数，即<code>2- 1</code>，来看一个例子:</p>
<pre><code class="typescript">const max = Number.MAX_SAFE_INTEGER;
const max1 = max + 1
const max2 = max + 2
max1 === max2     // true
</code></pre>
<p>可以看到，最终返回了true，这就是超过精读范围造成的问题，而<code>BigInt</code>正是解决这类问题而生的:</p>
<pre><code class="typescript">const max = BigInt(Number.MAX_SAFE_INTEGER);
const max1 = max + 1n
const max2 = max + 2n
max1 === max2    // false
</code></pre>
<p>这里需要用 <code>BigInt(number)</code> 把 Number 转化为 <code>BigInt</code>，同时如果类型是 <code>BigInt</code> ，那么数字后面需要加 <code>n</code>。</p>
<p>在TypeScript中，<code>number</code> 类型虽然和 <code>BigInt</code> 都表示数字，但是实际上两者类型是完全不同的:</p>
<pre><code class="typescript">declare let foo: number;
declare let bar: bigint;
foo = bar; // error: Type &#39;bigint&#39; is not assignable to type &#39;number&#39;.
bar = foo; // error: Type &#39;number&#39; is not assignable to type &#39;bigint&#39;.
</code></pre>
<h5 id="never"><a href="#never" class="headerlink" title="never"></a>never</h5><p><code>never</code>是其他类型 （包括<code>null</code>和 <code>undefined</code>）的子类型，可以赋值给任何类型，代表从不会出现的值</p>
<p>但是没有类型是 never 的子类型，这意味着声明 <code>never</code> 的变量只能被 <code>never</code> 类型所赋值。</p>
<p><code>never</code> 类型一般用来指定那些总是会抛出异常、无限循环</p>
<pre><code class="tsx">let a:never;
a = 123; // 错误的写法

a = (() =&gt; &#123; // 正确的写法
  throw new Error(&#39;错误&#39;);
&#125;)()

// 返回never的函数必须存在无法达到的终点
function error(message: string): never &#123;
    throw new Error(message);
&#125;
</code></pre>
<h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><p>对象类型，非原始类型，常见的形式通过<code>&#123;&#125;</code>进行包裹</p>
<pre><code class="tsx">let obj:object;
obj = &#123;name: &#39;Wang&#39;, age: 25&#125;;
</code></pre>
<h5 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h5><p>unknown 是TypeScript在3.0版本新增的类型，主要用来描述类型并不确定的变量。它看起来和any很像，但是还是有区别的，unknown相对于any更安全。</p>
<p>对于any，来看一个例子：</p>
<pre><code class="typescript">let value: any
console.log(value.name)
console.log(value.toFixed())
console.log(value.length)
</code></pre>
<p>上面这些语句都不会报错，因为value是any类型，所以后面三个操作都有合法的情况，当value是一个对象时，访问name属性是没问题的；当value是数值类型的时候，调用它的toFixed方法没问题；当value是字符串或数组时获取它的length属性是没问题的。</p>
<p>当指定值为unknown类型的时候，如果没有缩小类型范围的话，是不能对它进行任何操作的。总之，unknown类型的值不能随便操作。那什么是类型范围缩小呢？下面来看一个例子：</p>
<pre><code class="typescript">function getValue(value: unknown): string &#123;
  if (value instanceof Date) &#123; 
    return value.toISOString();
  &#125;
  return String(value);
&#125;
</code></pre>
<p>这里由于把value的类型缩小为Date实例的范围内，所以进行了value.toISOString()，也就是使用ISO标准将 Date 对象转换为字符串。</p>
<p>使用以下方式也可以缩小类型范围：</p>
<pre><code class="typescript">let result: unknown;
if (typeof result === &#39;number&#39;) &#123;
  result.toFixed();
&#125;
</code></pre>
<p>关于 unknown 类型，在使用时需要注意以下几点：</p>
<ul>
<li>任何类型的值都可以赋值给 unknown 类型：</li>
</ul>
<pre><code class="typescript">let value1: unknown;
value1 = &quot;a&quot;;
value1 = 123;
</code></pre>
<ul>
<li>unknown 不可以赋值给其它类型，只能赋值给 unknown 和 any 类型：</li>
</ul>
<pre><code class="typescript">let value2: unknown;
let value3: string = value2; // error 不能将类型“unknown”分配给类型“string”
value1 = value2;
</code></pre>
<ul>
<li>unknown 类型的值不能进行任何操作：</li>
</ul>
<pre><code class="typescript">let value4: unknown;
value4 += 1; // error 对象的类型为 &quot;unknown&quot;
</code></pre>
<ul>
<li>只能对 unknown 进行等或不等操作，不能进行其它操作：</li>
</ul>
<pre><code class="typescript">value1 === value2;
value1 !== value2;
value1 += value2;  // error
</code></pre>
<ul>
<li>unknown 类型的值不能访问其属性、作为函数调用和作为类创建实例：</li>
</ul>
<pre><code class="typescript">let value5: unknown;
value5.age;   // error
value5();     // error
new value5(); // error
</code></pre>
<p>在实际使用中，如果有类型无法确定的情况，要尽量避免使用 any，因为 any 会丢失类型信息，一旦一个类型被指定为 any，那么在它上面进行任何操作都是合法的，所以会有意想不到的情况发生。因此如果遇到无法确定类型的情况，要先考虑使用 unknown。</p>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>和<code>javascript</code>基本一致，也分成：</p>
<ul>
<li>基本类型</li>
<li>引用类型</li>
</ul>
<p>在基础类型上，<code>typescript</code>增添了<code>void</code>、<code>any</code>、<code>emum</code>等原始类型</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-TypeScript-中枚举类型的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-TypeScript-中枚举类型的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ TypeScript 中枚举类型的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ TypeScript 中枚举类型的理解？应用场景？</h3><h4 id="一、是什么-2"><a href="#一、是什么-2" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型</p>
<p>通俗来说，枚举就是一个对象的所有可能取值的集合</p>
<p>在日常生活中也很常见，例如表示星期的SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY就可以看成是一个枚举</p>
<p>枚举的说明与结构和联合相似，其形式为：</p>
<pre><code class="ini">enum 枚举名&#123;
    标识符①[=整型常数],
    标识符②[=整型常数],
    ...
    标识符N[=整型常数],
&#125;枚举变量;
</code></pre>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><p>枚举的使用是通过<code>enum</code>关键字进行定义，形式如下：</p>
<pre><code class="tsx">enum xxx &#123; ... &#125;
</code></pre>
<p>声明关键字为枚举类型的方式如下：</p>
<pre><code class="tsx">// 声明d为枚举类型Direction
let d: Direction;
</code></pre>
<p>类型可以分成：</p>
<ul>
<li>数字枚举</li>
<li>字符串枚举</li>
<li>异构枚举</li>
</ul>
<h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><p>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加:</p>
<pre><code class="tsx">enum Direction &#123;
    Up,   // 值默认为 0
    Down, // 值默认为 1
    Left, // 值默认为 2
    Right // 值默认为 3
&#125;

console.log(Direction.Up === 0); // true
console.log(Direction.Down === 1); // true
console.log(Direction.Left === 2); // true
console.log(Direction.Right === 3); // true
</code></pre>
<p>如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加1：</p>
<pre><code class="tsx">enum Direction &#123;
    Up = 10,
    Down,
    Left,
    Right
&#125;

console.log(Direction.Up, Direction.Down, Direction.Left, Direction.Right); // 10 11 12 13
</code></pre>
<h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><pre><code class="tsx">枚举类型的值其实也可以是字符串类型：

enum Direction &#123;
    Up = &#39;Up&#39;,
    Down = &#39;Down&#39;,
    Left = &#39;Left&#39;,
    Right = &#39;Right&#39;
&#125;

console.log(Direction[&#39;Right&#39;], Direction.Up); // Right Up
</code></pre>
<p>如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：</p>
<pre><code class="tsx">enum Direction &#123;
 Up = &#39;UP&#39;,
 Down, // error TS1061: Enum member must have initializer
 Left, // error TS1061: Enum member must have initializer
 Right // error TS1061: Enum member must have initializer
&#125;
</code></pre>
<h4 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h4><p>即将数字枚举和字符串枚举结合起来混合起来使用，如下：</p>
<pre><code class="tsx">enum BooleanLikeHeterogeneousEnum &#123;
    No = 0,
    Yes = &quot;YES&quot;,
&#125;
</code></pre>
<p>通常情况下我们很少会使用异构枚举</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>现在一个枚举的案例如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up,
    Down,
    Left,
    Right
&#125;
</code></pre>
<p>通过编译后，<code>javascript</code>如下：</p>
<pre><code class="tsx">var Direction;
(function (Direction) &#123;
    Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;;
    Direction[Direction[&quot;Down&quot;] = 1] = &quot;Down&quot;;
    Direction[Direction[&quot;Left&quot;] = 2] = &quot;Left&quot;;
    Direction[Direction[&quot;Right&quot;] = 3] = &quot;Right&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
</code></pre>
<p>上述代码可以看到， <code>Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;</code>可以分成</p>
<ul>
<li>Direction[“Up”] &#x3D; 0</li>
<li>Direction[0] &#x3D; “Up”</li>
</ul>
<p>所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up,
    Down,
    Left,
    Right
&#125;

console.log(Direction.Up === 0); // true
console.log(Direction[0]); // Up
</code></pre>
<p>并且多处定义的枚举是可以进行合并操作，如下：</p>
<pre><code class="tsx">enum Direction &#123;
    Up = &#39;Up&#39;,
    Down = &#39;Down&#39;,
    Left = &#39;Left&#39;,
    Right = &#39;Right&#39;
&#125;

enum Direction &#123;
    Center = 1
&#125;
</code></pre>
<p>编译后，<code>js</code>代码如下：</p>
<pre><code class="tsx">var Direction;
(function (Direction) &#123;
    Direction[&quot;Up&quot;] = &quot;Up&quot;;
    Direction[&quot;Down&quot;] = &quot;Down&quot;;
    Direction[&quot;Left&quot;] = &quot;Left&quot;;
    Direction[&quot;Right&quot;] = &quot;Right&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
(function (Direction) &#123;
    Direction[Direction[&quot;Center&quot;] = 1] = &quot;Center&quot;;
&#125;)(Direction || (Direction = &#123;&#125;));
</code></pre>
<p>可以看到，<code>Direction</code>对象属性回叠加</p>
<h4 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：</p>
<pre><code class="tsx">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;

console.log(Days[&quot;Sun&quot;] === 0); // true
console.log(Days[&quot;Mon&quot;] === 1); // true
console.log(Days[&quot;Tue&quot;] === 2); // true
console.log(Days[&quot;Sat&quot;] === 6); // true
</code></pre>
<p>包括后端日常返回0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中接口的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中接口的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中接口的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中接口的理解？应用场景？</h3><h4 id="一、是什么-3"><a href="#一、是什么-3" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法</p>
<p>简单来讲，一个接口所描述的是一个对象相关的属性和方法，但并不提供具体创建此对象实例的方法</p>
<p><code>typescript</code>的核心功能之一就是对类型做检测，虽然这种检测方式是“鸭式辨型法”，而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定</p>
<h4 id="二、使用方式"><a href="#二、使用方式" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>接口定义如下：</p>
<pre><code class="tsx">interface interface_name &#123;
&#125;
</code></pre>
<p>例如有一个函数，这个函数接受一个 <code>User</code> 对象，然后返回这个 <code>User</code> 对象的 <code>name</code> 属性:</p>
<pre><code class="tsx">const getUserName = (user) =&gt; user.name
</code></pre>
<p>可以看到，参数需要有一个<code>user</code>的<code>name</code>属性，可以通过接口描述<code>user</code>参数的结构</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
&#125;

const getUserName = (user: User) =&gt; user.name
</code></pre>
<p>这些属性并不一定全部实现，上述传入的对象必须拥有<code>name</code>和<code>age</code>属性，否则<code>typescript</code>在编译阶段会报错，如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32356433613739302d306232622d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>如果不想要<code>age</code>属性的话，这时候可以采用可选属性，如下表示：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
&#125;
</code></pre>
<p>这时候<code>age</code>属性则可以是<code>number</code>类型或者<code>undefined</code>类型</p>
<p>有些时候，我们想要一个属性变成只读属性，在<code>typescript</code>只需要使用<code>readonly</code>声明，如下：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
    readonly isMale: boolean
&#125;
</code></pre>
<p>当我们修改属性的时候，就会出现警告，如下所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f32663664336333302d306232622d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>这是属性中有一个函数，可以如下表示：</p>
<pre><code class="tsx">interface User &#123;
    name: string
    age?: number
    readonly isMale: boolean
    say: (words: string) =&gt; string
&#125;
</code></pre>
<p>如果传递的对象不仅仅是上述的属性，这时候可以使用：</p>
<ul>
<li>类型推断</li>
</ul>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
&#125;

const getUserName = (user: User) =&gt; user.name
getUserName(&#123;color: &#39;yellow&#39;&#125; as User)
</code></pre>
<ul>
<li>给接口添加字符串索引签名</li>
</ul>
<pre><code class="tsx">interface User &#123;
    name: string
    age: number
    [propName: string]: any;
&#125;
</code></pre>
<p>接口还能实现继承，如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f33386134313736302d306232622d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>也可以继承多个，父类通过逗号隔开，如下：</p>
<pre><code class="tsx">interface Father &#123;
    color: String
&#125;

interface Mother &#123;
    height: Number
&#125;

interface Son extends Father,Mother&#123;
    name: string
    age: Number
&#125;
</code></pre>
<h4 id="三、应用场景-1"><a href="#三、应用场景-1" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>例如在<code>javascript</code>中定义一个函数，用来获取用户的姓名和年龄：</p>
<pre><code class="tsx">const getUserInfo = function(user) &#123;
    // ...
    return name: $&#123;user.name&#125;, age: $&#123;user.age&#125;
&#125;
</code></pre>
<p>如果多人开发的都需要用到这个函数的时候，如果没有注释，则可能出现各种运行时的错误，这时候就可以使用接口定义参数变量：</p>
<pre><code class="tsx">// 先定义一个接口
interface IUser &#123;
  name: string;
  age: number;
&#125;

const getUserInfo = (user: IUser): string =&gt; &#123;
  return `name: $&#123;user.name&#125;, age: $&#123;user.age&#125;`;
&#125;;

// 正确的调用
getUserInfo(&#123;name: &quot;koala&quot;, age: 18&#125;);
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中类的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中类的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中类的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中类的理解？应用场景？</h3><h4 id="一、是什么-4"><a href="#一、是什么-4" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>
<blockquote>
<p>类是一种用户定义的引用数据类型，也称类类型</p>
</blockquote>
<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本</p>
<p>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多</p>
<p>但是<code> JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类</p>
<p><code>TypeScript</code> 的 <code>class</code> 支持面向对象的所有特性，比如 类、接口等</p>
<h4 id="二、使用方式-1"><a href="#二、使用方式-1" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p>
<ul>
<li>字段： 字段是类里面声明的变量。字段表示对象的有关数据。</li>
<li>构造函数： 类实例化时调用，可以为类的对象分配内存。</li>
<li>方法： 方法为对象要执行的操作</li>
</ul>
<p>如下例子：</p>
<pre><code class="tsx">class Car &#123;
    // 字段
    engine:string;

    // 构造函数
    constructor(engine:string) &#123;
        this.engine = engine
    &#125;

    // 方法
    disp():void &#123;
        console.log(&quot;发动机为 :   &quot;+this.engine)
    &#125;
&#125;
</code></pre>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>类的继承使用过<code>extends</code>的关键字</p>
<pre><code class="tsx">class Animal &#123;
    move(distanceInMeters: number = 0) &#123;
        console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);
    &#125;
&#125;

class Dog extends Animal &#123;
    bark() &#123;
        console.log(&#39;Woof! Woof!&#39;);
    &#125;
&#125;

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
</code></pre>
<p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 超类</p>
<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法</p>
<p>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写，通过<code>super</code>关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>
<pre><code class="tsx">class PrinterClass &#123;
   doPrint():void &#123;
      console.log(&quot;父类的 doPrint() 方法。&quot;)
   &#125;
&#125;

class StringPrinter extends PrinterClass &#123;
   doPrint():void &#123;
      super.doPrint() // 调用父类的函数
      console.log(&quot;子类的 doPrint()方法。&quot;)
   &#125;
&#125;
</code></pre>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>可以看到，上述的形式跟<code>ES6</code>十分的相似，<code>typescript</code>在此基础上添加了三种修饰符：</p>
<ul>
<li>公共 public：可以自由的访问类程序里定义的成员</li>
<li>私有 private：只能够在该类的内部进行访问</li>
<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>
</ul>
<h6 id="私有修饰符"><a href="#私有修饰符" class="headerlink" title="私有修饰符"></a>私有修饰符</h6><p>只能够在该类的内部进行访问，实例对象并不能够访问</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66353733363566302d306362342d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>并且继承该类的子类并不能访问，如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30303732636332302d306362352d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h6 id="受保护修饰符"><a href="#受保护修饰符" class="headerlink" title="受保护修饰符"></a>受保护修饰符</h6><p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30396537323538302d306362352d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31333766383161302d306362352d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>除了上述修饰符之外，还有只读修饰符</p>
<h6 id="只读修饰符"><a href="#只读修饰符" class="headerlink" title="只读修饰符"></a>只读修饰符</h6><p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/f0885f89e9d2d9bc7aa7acd9b815cd6f447ab2ed9d3a5c4df4ccd6974599bf53/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31653834386432302d306362352d313165632d386536342d3931666465633066303561312e706e67"><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f31653834386432302d306362352d313165632d386536342d3931666465633066303561312e706e67.png" alt="img"></a></p>
<p>除了实例属性之外，同样存在静态属性</p>
<h6 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h6><p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示：</p>
<pre><code class="tsx">class Square &#123;
    static width = &#39;100px&#39;
&#125;

console.log(Square.width) // 100px
</code></pre>
<p>上述的类都能发现一个特点就是，都能够被实例化，在 <code>typescript</code>中，还存在一种抽象类</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节</p>
<p><code>abstract </code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>
<pre><code class="tsx">abstract class Animal &#123;
    abstract makeSound(): void;
    move(): void &#123;
        console.log(&#39;roaming the earch...&#39;);
    &#125;
&#125;
</code></pre>
<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>
<pre><code class="tsx">class Cat extends Animal &#123;

    makeSound() &#123;
        console.log(&#39;miao miao&#39;)
    &#125;
&#125;

const cat = new Cat()

cat.makeSound() // miao miao
cat.move() // roaming the earch...
</code></pre>
<h4 id="三、应用场景-2"><a href="#三、应用场景-2" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在 <code>React</code> 工程中是很常用的，如下：</p>
<pre><code class="tsx">export default class Carousel extends React.Component&lt;Props, State&gt; &#123;&#125;
</code></pre>
<p>由于组件需要传入 <code>props</code> 的类型 <code>Props</code> ，同时有需要设置默认 <code>props</code> 即 <code>defaultProps</code>，这时候更加适合使用<code>class</code>作为接口</p>
<p>先声明一个类，这个类包含组件 <code>props</code> 所需的类型和初始值：</p>
<pre><code class="tsx">// props的类型
export default class Props &#123;
  public children: Array&lt;React.ReactElement&lt;any&gt;&gt; | React.ReactElement&lt;any&gt; | never[] = []
  public speed: number = 500
  public height: number = 160
  public animation: string = &#39;easeInOutQuad&#39;
  public isAuto: boolean = true
  public autoPlayInterval: number = 4500
  public afterChange: () =&gt; &#123;&#125;
  public beforeChange: () =&gt; &#123;&#125;
  public selesctedColor: string
  public showDots: boolean = true
&#125;
</code></pre>
<p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>
<pre><code class="tsx">public static defaultProps = new Props()
</code></pre>
<p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class </code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中函数的理解？与-JavaScript-函数的区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中函数的理解？与-JavaScript-函数的区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中函数的理解？与 JavaScript 函数的区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</h3><h4 id="一、是什么-5"><a href="#一、是什么-5" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>函数是<code> JavaScript</code> 应用程序的基础，帮助我们实现抽象层、模拟类、信息隐藏和模块</p>
<p>在<code> TypeScript</code> 里，虽然已经支持类、命名空间和模块，但函数仍然是主要定义行为的方式，<code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，丰富了更多的应用场景</p>
<p>函数类型在 <code>TypeScript</code> 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块</p>
<h4 id="二、使用方式-2"><a href="#二、使用方式-2" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>跟<code>javascript</code> 定义函数十分相似，可以通过<code>funciton</code> 关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>
<pre><code class="tsx">const add = (a: number, b: number) =&gt; a + b
</code></pre>
<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上<code> TypeScript</code> 编译器是能够通过类型推断到这个函数的类型，如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34623334313562302d306434322d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>当鼠标放置在第三行<code>add</code>函数名的时候，会出现完整的函数定义类型，通过<code>:</code> 的形式来定于参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>
<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>
<pre><code class="tsx">// 方式一
type LongHand = &#123;
  (a: number): number;
&#125;;

// 方式二
type ShortHand = (a: number) =&gt; number;
</code></pre>
<p>当存在函数重载时，只能使用方式一的形式</p>
<h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>
<pre><code class="tsx">const add = (a: number, b?: number) =&gt; a + (b ? b : 0)
</code></pre>
<p>这时候参数<code>b</code>可以是<code>number</code>类型或者<code>undefined</code>类型，即可以传一个<code>number</code>类型或者不传都可以</p>
<h5 id="剩余类型"><a href="#剩余类型" class="headerlink" title="剩余类型"></a>剩余类型</h5><p>剩余参数与<code>JavaScript</code>的语法类似，需要用 <code>...</code> 来表示剩余参数</p>
<p>如果剩余参数 <code>rest</code> 是一个由<code>number</code>类型组成的数组，则如下表示：</p>
<pre><code class="tsx">const add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a)
</code></pre>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>
<p>关于<code>typescript</code>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|</code>操作符或者<code>?</code>操作符，把所有可能的输入类型全部包含进去，用于具体实现</p>
<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，<code>typescript</code>并不会真的将你的多个重名 <code>function </code>的函数体进行合并</p>
<p>例如我们有一个add函数，它可以接收 <code>string</code>类型的参数进行拼接，也可以接收 <code>number</code> 类型的参数进行相加，如下：</p>
<pre><code class="tsx">// 上边是声明
function add (arg1: string, arg2: string): string
function add (arg1: number, arg2: number): number
// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字

// 下边是实现
function add (arg1: string | number, arg2: string | number) &#123;
  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2
  if (typeof arg1 === &#39;string&#39; &amp;&amp; typeof arg2 === &#39;string&#39;) &#123;
    return arg1 + arg2
  &#125; else if (typeof arg1 === &#39;number&#39; &amp;&amp; typeof arg2 === &#39;number&#39;) &#123;
    return arg1 + arg2
  &#125;
&#125;
</code></pre>
<h4 id="三、区别-1"><a href="#三、区别-1" class="headerlink" title="三、区别"></a>三、区别</h4><p>从上面可以看到：</p>
<ul>
<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>
<li>typescript 在参数中，添加可选参数供使用者选择</li>
<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中泛型的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中泛型的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中泛型的理解？应用场景？</h3><h4 id="一、是什么-6"><a href="#一、是什么-6" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p>
<p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型<br>在<code>typescript</code>中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性</p>
<p>假设我们用一个函数，它可接受一个 <code>number</code> 参数并返回一个<code> number</code> 参数，如下写法：</p>
<pre><code class="tsx">function returnItem (para: number): number &#123;
    return para
&#125;
</code></pre>
<p>如果我们打算接受一个 <code>string</code> 类型，然后再返回 <code>string</code>类型，则如下写法：</p>
<pre><code class="tsx">function returnItem (para: string): string &#123;
    return para
&#125;
</code></pre>
<p>上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高</p>
<p>虽然可以使用 <code>any</code>类型去替代，但这也并不是很好的方案，因为我们的目的是接收什么类型的参数返回什么类型的参数，即在运行时传入参数我们才能确定类型</p>
<p>这种情况就可以使用泛型，如下所示：</p>
<pre><code class="tsx">function returnItem&lt;T&gt;(para: T): T &#123;
    return para
&#125;
</code></pre>
<p>可以看到，泛型给予开发者创造灵活、可重用代码的能力</p>
<h4 id="二、使用方式-3"><a href="#二、使用方式-3" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明：</p>
<ul>
<li>函数</li>
<li>接口</li>
<li>类</li>
</ul>
<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>声明函数的形式如下：</p>
<pre><code class="tsx">function returnItem&lt;T&gt;(para: T): T &#123;
    return para
&#125;
</code></pre>
<p>定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 <code>T</code> 和 泛型 <code>U</code>：</p>
<pre><code class="tsx">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;
    return [tuple[1], tuple[0]];
&#125;

swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]
</code></pre>
<h5 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h5><p>声明接口的形式如下：</p>
<pre><code class="tsx">interface ReturnItemFn&lt;T&gt; &#123;
    (para: T): T
&#125;
</code></pre>
<p>那么当我们想传入一个number作为参数的时候，就可以这样声明函数:</p>
<pre><code class="tsx">const returnItem: ReturnItemFn&lt;number&gt; = para =&gt; para
</code></pre>
<h5 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h5><p>使用泛型声明类的时候，既可以作用于类本身，也可以作用与类的成员函数</p>
<p>下面简单实现一个元素同类型的栈结构，如下所示：</p>
<pre><code class="tsx">class Stack&lt;T&gt; &#123;
    private arr: T[] = []
    public push(item: T) &#123;
        this.arr.push(item)
    &#125;
    public pop() &#123;
        this.arr.pop()
    &#125;
&#125;
</code></pre>
<p>使用方式如下：</p>
<pre><code class="tsx">const stack = new Stacn&lt;number&gt;()
</code></pre>
<p>如果上述只能传递 <code>string</code> 和 <code>number</code> 类型，这时候就可以使用 <code>&lt;T extends xx&gt;</code> 的方式猜实现约束泛型，如下所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f36376432313261302d306531372d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<p>除了上述的形式，泛型更高级的使用如下：</p>
<p>例如要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值</p>
<p>这时候就设计到泛型的索引类型和约束类型共同实现</p>
<h5 id="索引类型、约束类型"><a href="#索引类型、约束类型" class="headerlink" title="索引类型、约束类型"></a>索引类型、约束类型</h5><p>索引类型 <code>keyof T</code> 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，如下所示：</p>
<pre><code class="tsx">function getValue&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) &#123;
  return obj[key] // ok
&#125;
</code></pre>
<p>上述为什么需要使用泛型约束，而不是直接定义第一个参数为 <code>object</code>类型，是因为默认情况 <code>object</code> 指的是<code>&#123;&#125;</code>，而我们接收的对象是各种各样的，一个泛型来表示传入的对象类型，比如 <code>T extends object</code></p>
<p>使用如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f37346663626434302d306531372d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="多类型约束"><a href="#多类型约束" class="headerlink" title="多类型约束"></a>多类型约束</h5><p>例如如下需要实现两个接口的类型约束：</p>
<pre><code class="tsx">interface FirstInterface &#123;
  doSomething(): number
&#125;

interface SecondInterface &#123;
  doSomethingElse(): string
&#125;
</code></pre>
<p>可以创建一个接口继承上述两个接口，如下：</p>
<pre><code class="tsx">interface ChildInterface extends FirstInterface, SecondInterface &#123;

&#125;
</code></pre>
<p>正确使用如下：</p>
<pre><code class="tsx">class Demo&lt;T extends ChildInterface&gt; &#123;
  private genericProperty: T

  constructor(genericProperty: T) &#123;
    this.genericProperty = genericProperty
  &#125;
  useT() &#123;
    this.genericProperty.doSomething()
    this.genericProperty.doSomethingElse()
  &#125;
&#125;
</code></pre>
<p>通过泛型约束就可以达到多类型约束的目的</p>
<h4 id="三、应用场景-3"><a href="#三、应用场景-3" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>通过上面初步的了解，后述在编写 <code>typescript</code> 的时候，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性的时候，这种情况下就可以使用泛型</p>
<p>灵活的使用泛型定义类型，是掌握<code>typescript</code> 必经之路</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中高级类型的理解？有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中高级类型的理解？有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中高级类型的理解？有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中高级类型的理解？有哪些？</h3><h4 id="一、是什么-7"><a href="#一、是什么-7" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>除了<code>string</code>、<code>number</code>、<code>boolean</code> 这种基础类型外，在 <code>typescript</code> 类型声明中还存在一些高级的类型应用</p>
<p>这些高级类型，是<code>typescript</code>为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景</p>
<h4 id="二、有哪些-1"><a href="#二、有哪些-1" class="headerlink" title="二、有哪些"></a>二、有哪些</h4><p>常见的高级类型有如下：</p>
<ul>
<li>交叉类型</li>
<li>联合类型</li>
<li>类型别名</li>
<li>类型索引</li>
<li>类型约束</li>
<li>映射类型</li>
<li>条件类型</li>
</ul>
<h5 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h5><p>通过 <code>&amp;</code> 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作</p>
<p>语法如下：</p>
<pre><code class="ini">T &amp; U
</code></pre>
<p>适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：</p>
<pre><code class="tsx">function extend&lt;T , U&gt;(first: T, second: U) : T &amp; U &#123;
    let result: &lt;T &amp; U&gt; = &#123;&#125;
    for (let key in first) &#123;
        result[key] = first[key]
    &#125;
    for (let key in second) &#123;
        if(!result.hasOwnProperty(key)) &#123;
            result[key] = second[key]
        &#125;
    &#125;
    return result
&#125;
</code></pre>
<h5 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h5><p>联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系</p>
<p>语法如下：</p>
<pre><code class="ini">T | U
</code></pre>
<p>例如 <code>number</code> | <code>string</code> | <code>boolean</code> 的类型只能是这三个的一种，不能共存</p>
<p>如下所示：</p>
<pre><code class="tsx">function formatCommandline(command: string[] | string) &#123;
  let line = &#39;&#39;;
  if (typeof command === &#39;string&#39;) &#123;
    line = command.trim();
  &#125; else &#123;
    line = command.join(&#39; &#39;).trim();
  &#125;
&#125;
</code></pre>
<h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型</p>
<p>可以使用 <code>type SomeName = someValidTypeAnnotation</code>的语法来创建类型别名：</p>
<pre><code class="tsx">type some = boolean | string

const b: some = true // ok
const c: some = &#39;hello&#39; // ok
const d: some = 123 // 不能将类型“123”分配给类型“some”
</code></pre>
<p>此外类型别名可以是泛型:</p>
<pre><code class="tsx">type Container&lt;T&gt; = &#123; value: T &#125;;
</code></pre>
<p>也可以使用类型别名来在属性里引用自己：</p>
<pre><code class="tsx">type Tree&lt;T&gt; = &#123;
    value: T;
    left: Tree&lt;T&gt;;
    right: Tree&lt;T&gt;;
&#125;
</code></pre>
<p>可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数</p>
<p>两者最大的区别在于，<code>interface </code>只能用于定义对象类型，而 <code>type</code> 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛</p>
<h5 id="类型索引"><a href="#类型索引" class="headerlink" title="类型索引"></a>类型索引</h5><p><code>keyof</code> 类似于 <code>Object.keys</code> ，用于获取一个接口中 Key 的联合类型。</p>
<pre><code class="tsx">interface Button &#123;
    type: string
    text: string
&#125;

type ButtonKeys = keyof Button
// 等效于
type ButtonKeys = &quot;type&quot; | &quot;text&quot;
</code></pre>
<h5 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h5><p>通过关键字 <code>extend</code> 进行约束，不同于在 <code>class</code> 后使用 <code>extends</code> 的继承作用，泛型内使用的主要作用是对泛型加以约束</p>
<pre><code class="tsx">type BaseType = string | number | boolean

// 这里表示 copy 的参数
// 只能是字符串、数字、布尔这几种基础类型
function copy&lt;T extends BaseType&gt;(arg: T): T &#123;
  return arg
&#125;
</code></pre>
<p>类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 <code>extends</code> 和 <code>keyof</code> 进行约束。</p>
<pre><code class="tsx">function getValue&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123;
  return obj[key]
&#125;

const obj = &#123; a: 1 &#125;
const a = getValue(obj, &#39;a&#39;)
</code></pre>
<h5 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h5><p>通过 <code>in</code> 关键字做类型的映射，遍历已有接口的 <code>key</code> 或者是遍历联合类型，如下例子：</p>
<pre><code class="tsx">type Readonly&lt;T&gt; = &#123;
    readonly [P in keyof T]: T[P];
&#125;;

interface Obj &#123;
  a: string
  b: string
&#125;

type ReadOnlyObj = Readonly&lt;Obj&gt;
</code></pre>
<p>上述的结构，可以分成这些步骤：</p>
<ul>
<li>keyof T：通过类型索引 keyof 的得到联合类型 ‘a’ | ‘b’</li>
<li>P in keyof T 等同于 p in ‘a’ | ‘b’，相当于执行了一次 forEach 的逻辑，遍历 ‘a’ | ‘b’</li>
</ul>
<p>所以最终<code>ReadOnlyObj</code>的接口为下述：</p>
<pre><code class="tsx">interface ReadOnlyObj &#123;
    readonly a: string;
    readonly b: string;
&#125;
</code></pre>
<h5 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h5><p>条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。</p>
<pre><code class="tsx">T extends U ? X : Y
</code></pre>
<p>上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y</p>
<h4 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h4><p>可以看到，如果只是掌握了 <code>typeScript</code> 的一些基础类型，可能很难游刃有余的去使用 <code>typeScript</code>，需要了解一些<code>typescript</code>的高阶用法</p>
<p>并且<code>typescript</code>在版本的迭代中新增了很多功能，需要不断学习与掌握</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-装饰器的理解？应用场景？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-装饰器的理解？应用场景？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 装饰器的理解？应用场景？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 装饰器的理解？应用场景？</h3><h4 id="一、是什么-8"><a href="#一、是什么-8" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上</p>
<p>是一种在不改变原类和使用继承的情况下，动态地扩展对象功能</p>
<p>同样的，本质也不是什么高大上的结构，就是一个普通的函数，<code>@expression</code> 的形式其实是<code>Object.defineProperty</code>的语法糖</p>
<p><code>expression </code>求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p>
<h4 id="二、使用方式-4"><a href="#二、使用方式-4" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>由于<code>typescript</code>是一个实验性特性，若要使用，需要在<code>tsconfig.json</code>文件启动，如下：</p>
<pre><code class="tsx">&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;ES5&quot;,
        &quot;experimentalDecorators&quot;: true
    &#125;
&#125;
</code></pre>
<p><code>typescript</code>装饰器的使用和<code>javascript</code>基本一致</p>
<p>类的装饰器可以装饰：</p>
<ul>
<li>类</li>
<li>方法&#x2F;属性</li>
<li>参数</li>
<li>访问器</li>
</ul>
<h5 id="类装饰"><a href="#类装饰" class="headerlink" title="类装饰"></a>类装饰</h5><p>例如声明一个函数 <code>addAge</code> 去给 Class 的属性 <code>age</code> 添加年龄.</p>
<pre><code class="tsx">function addAge(constructor: Function) &#123;
  constructor.prototype.age = 18;
&#125;

@addAge
class Person&#123;
  name: string;
  age!: number;
  constructor() &#123;
    this.name = &#39;huihui&#39;;
  &#125;
&#125;

let person = new Person();

console.log(person.age); // 18
</code></pre>
<p>上述代码，实际等同于以下形式：</p>
<pre><code class="tsx">Person = addAge(function Person() &#123; ... &#125;);
</code></pre>
<p>上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 <code>constructor.prototype.age</code> 就是在每一个实例化对象上面添加一个 <code>age</code> 属性</p>
<h5 id="方法-x2F-属性装饰"><a href="#方法-x2F-属性装饰" class="headerlink" title="方法&#x2F;属性装饰"></a>方法&#x2F;属性装饰</h5><p>同样，装饰器可以用于修饰类的方法，这时候装饰器函数接收的参数变成了：</p>
<ul>
<li>target：对象的原型</li>
<li>propertyKey：方法的名称</li>
<li>descriptor：方法的属性描述符</li>
</ul>
<p>可以看到，这三个属性实际就是<code>Object.defineProperty</code>的三个参数，如果是类的属性，则没有传递第三个参数</p>
<p>如下例子：</p>
<pre><code class="tsx">// 声明装饰器修饰方法/属性
function method(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;
  console.log(target);
  console.log(&quot;prop &quot; + propertyKey);
  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);
  descriptor.writable = false;
&#125;;

function property(target: any, propertyKey: string) &#123;
  console.log(&quot;target&quot;, target)
  console.log(&quot;propertyKey&quot;, propertyKey)
&#125;

class Person&#123;
 @property
 name: string;
 constructor() &#123;
   this.name = &#39;huihui&#39;;
 &#125;

 @method
 say()&#123;
   return &#39;instance method&#39;;
 &#125;

 @method
 static run()&#123;
   return &#39;static method&#39;;
 &#125;
&#125;

const xmz = new Person();

// 修改实例方法say
xmz.say = function() &#123;
 return &#39;edit&#39;
&#125;
</code></pre>
<p>输出如下图所示：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f65393662633162302d313134642d313165632d386536342d3931666465633066303561312e706e67.png"></p>
<h5 id="参数装饰"><a href="#参数装饰" class="headerlink" title="参数装饰"></a>参数装饰</h5><p>接收3个参数，分别是：</p>
<ul>
<li>target ：当前对象的原型</li>
<li>propertyKey ：参数的名称</li>
<li>index：参数数组中的位置</li>
</ul>
<pre><code class="tsx">function logParameter(target: Object, propertyName: string, index: number) &#123;
  console.log(target);
  console.log(propertyName);
  console.log(index);
&#125;

class Employee &#123;
  greet(@logParameter message: string): string &#123;
      return `hello $&#123;message&#125;`;
  &#125;
&#125;
const emp = new Employee();
emp.greet(&#39;hello&#39;);
</code></pre>
<p>输入如下图：</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66326633326465302d313134642d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<h5 id="访问器装饰"><a href="#访问器装饰" class="headerlink" title="访问器装饰"></a>访问器装饰</h5><p>使用起来方式与方法装饰一致，如下：</p>
<pre><code class="tsx">function modification(target: Object, propertyKey: string, descriptor: PropertyDescriptor) &#123;
  console.log(target);
  console.log(&quot;prop &quot; + propertyKey);
  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\n\n&quot;);
&#125;;

class Person&#123;
 _name: string;
 constructor() &#123;
   this._name = &#39;huihui&#39;;
 &#125;

 @modification
 get name() &#123;
   return this._name
 &#125;
&#125;
</code></pre>
<h5 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h5><p>如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：</p>
<pre><code class="tsx">function addAge(age: number) &#123;
  return function(constructor: Function) &#123;
    constructor.prototype.age = age
  &#125;
&#125;

@addAge(10)
class Person&#123;
  name: string;
  age!: number;
  constructor() &#123;
    this.name = &#39;huihui&#39;;
  &#125;
&#125;

let person = new Person();
</code></pre>
<h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><p>当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用，例如如下：</p>
<pre><code class="tsx">function f() &#123;
    console.log(&quot;f(): evaluated&quot;);
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123;
        console.log(&quot;f(): called&quot;);
    &#125;
&#125;

function g() &#123;
    console.log(&quot;g(): evaluated&quot;);
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123;
        console.log(&quot;g(): called&quot;);
    &#125;
&#125;

class C &#123;
    @f()
    @g()
    method() &#123;&#125;
&#125;

// 输出
f(): evaluated
g(): evaluated
g(): called
f(): called
</code></pre>
<h4 id="三、应用场景-4"><a href="#三、应用场景-4" class="headerlink" title="三、应用场景"></a>三、应用场景</h4><p>可以看到，使用装饰器存在两个显著的优点：</p>
<ul>
<li>代码可读性变强了，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原来功能进行扩展</li>
</ul>
<p>后面的使用场景中，借助装饰器的特性，除了提高可读性之后，针对已经存在的类，可以通过装饰器的特性，在不改变原有代码情况下，对原来功能进行扩展</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中命名空间与模块的理解？区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-对-TypeScript-中命名空间与模块的理解？区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中命名空间与模块的理解？区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 对 TypeScript 中命名空间与模块的理解？区别？</h3><h4 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h4><p><code>TypeScript</code> 与<code> ECMAScript</code> 2015 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块</p>
<p>相反地，如果一个文件不带有顶级的<code>import</code>或者<code>export</code>声明，那么它的内容被视为全局可见的</p>
<p>例如我们在在一个 <code>TypeScript</code> 工程下建立一个文件 <code>1.ts</code>，声明一个变量<code>a</code>，如下：</p>
<pre><code class="tsx">const a = 1
</code></pre>
<p>然后在另一个文件同样声明一个变量<code>a</code>，这时候会出现错误信息</p>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f61323339643937302d313337652d313165632d613735322d3735373233613634653866352e706e67.png"></p>
<p>提示重复声明<code>a</code>变量，但是所处的空间是全局的</p>
<p>如果需要解决这个问题，则通过<code>import</code>或者<code>export</code>引入模块系统即可，如下：</p>
<pre><code class="tsx">const a = 10;

export default a
</code></pre>
<p>在<code>typescript</code>中，<code>export</code>关键字可以导出变量或者类型，用法与<code>es6</code>模块一致，如下：</p>
<pre><code class="tsx">export const a = 1
export type Person = &#123;
    name: String
&#125;
</code></pre>
<p>通过<code>import</code> 引入模块，如下：</p>
<pre><code class="tsx">import &#123; a, Person &#125; from &#39;./export&#39;;
</code></pre>
<h4 id="二、命名空间"><a href="#二、命名空间" class="headerlink" title="二、命名空间"></a>二、命名空间</h4><p>命名空间一个最明确的目的就是解决重名问题</p>
<p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的</p>
<p>这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p>
<p><code>TypeScript</code> 中命名空间使用 <code>namespace</code> 来定义，语法格式如下：</p>
<pre><code class="tsx">namespace SomeNameSpaceName &#123;
   export interface ISomeInterfaceName &#123;      &#125;
   export class SomeClassName &#123;      &#125;
&#125;
</code></pre>
<p>以上定义了一个命名空间 <code>SomeNameSpaceName</code>，如果我们需要在外部可以调用 <code>SomeNameSpaceName</code> 中的类和接口，则需要在类和接口添加 <code>export</code> 关键字</p>
<p>使用方式如下：</p>
<pre><code class="ini">SomeNameSpaceName.SomeClassName
</code></pre>
<p>命名空间本质上是一个对象，作用是将一系列相关的全局变量组织到一个对象的属性，如下：</p>
<pre><code class="tsx">namespace Letter &#123;
  export let a = 1;
  export let b = 2;
  export let c = 3;
  // ...
  export let z = 26;
&#125;
</code></pre>
<p>编译成<code>js</code>如下：</p>
<pre><code class="tsx">var Letter;
(function (Letter) &#123;
    Letter.a = 1;
    Letter.b = 2;
    Letter.c = 3;
    // ...
    Letter.z = 26;
&#125;)(Letter || (Letter = &#123;&#125;));
</code></pre>
<h4 id="三、区别-2"><a href="#三、区别-2" class="headerlink" title="三、区别"></a>三、区别</h4><ul>
<li>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中</li>
<li>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖</li>
<li>在正常的TS项目开发过程中并不建议用命名空间，但通常在通过 d.ts 文件标记 js 库类型的时候使用命名空间，主要作用是给编译器编写代码的时候参考使用</li>
</ul>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在Vue项目中应用TypeScript？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在Vue项目中应用TypeScript？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Vue项目中应用TypeScript？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Vue项目中应用TypeScript？</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>与link类似</p>
<p>在<code>VUE</code>项目中应用<code>typescript</code>，我们需要引入一个库<code>vue-property-decorator</code>，</p>
<p>其是基于<code>vue-class-component</code>库而来，这个库<code>vue</code>官方推出的一个支持使用<code>class</code>方式来开发<code>vue</code>单文件组件的库</p>
<p>主要的功能如下：</p>
<ul>
<li>methods 可以直接声明为类的成员方法</li>
<li>计算属性可以被声明为类的属性访问器</li>
<li>初始化的 data 可以被声明为类属性</li>
<li>data、render 以及所有的 Vue 生命周期钩子可以直接作为类的成员方法</li>
<li>所有其他属性，需要放在装饰器中</li>
</ul>
<h4 id="二、使用-1"><a href="#二、使用-1" class="headerlink" title="二、使用"></a>二、使用</h4><p>vue-property-decorator 主要提供了多个装饰器和一个函数:</p>
<ul>
<li>@prop</li>
<li>@ProPsync</li>
<li>@model</li>
<li>@watch</li>
<li>@provide</li>
<li>@Inject</li>
<li>@ProvideReactive</li>
<li>@InjectReactive</li>
<li>@emit</li>
<li>@ref</li>
<li>@component (由 vue-class-component 提供)</li>
<li>Mixins (由 vue-class-component 提供)</li>
</ul>
<h5 id="component"><a href="#component" class="headerlink" title="@component"></a><a target="_blank" rel="noopener" href="https://github.com/component">@component</a></h5><p><code>Component</code>装饰器它注明了此类为一个<code>Vue</code>组件，因此即使没有设置选项也不能省略</p>
<p>如果需要定义比如 <code>name</code>、<code>components</code>、<code>filters</code>、<code>directives</code>以及自定义属性，就可以在<code>Component</code>装饰器中定义，如下：</p>
<pre><code class="tsx">import &#123;Component,Vue&#125; from &#39;vue-property-decorator&#39;;
import &#123;componentA,componentB&#125; from &#39;@/components&#39;;

 @Component(&#123;
    components:&#123;
        componentA,
        componentB,
    &#125;,
    directives: &#123;
        focus: &#123;
            // 指令的定义
            inserted: function (el) &#123;
                el.focus()
            &#125;
        &#125;
    &#125;
&#125;)
export default class YourCompoent extends Vue&#123;
   
&#125;
</code></pre>
<h5 id="computed、data、methods"><a href="#computed、data、methods" class="headerlink" title="computed、data、methods"></a>computed、data、methods</h5><p>这里取消了组件的data和methods属性，以往data返回对象中的属性、methods中的方法需要直接定义在Class中，当做类的属性和方法</p>
<pre><code class="tsx">@Component
export default class HelloDecorator extends Vue &#123;
    count: number = 123 // 类属性相当于以前的 data

    add(): number &#123; // 类方法就是以前的方法
        this.count + 1
    &#125;

    // 获取计算属性
    get total(): number &#123;
      return this.count + 1
    &#125;

    // 设置计算属性
    set total(param:number): void &#123;
      this.count = param
    &#125;
&#125;
</code></pre>
<h5 id="props"><a href="#props" class="headerlink" title="@props"></a><a target="_blank" rel="noopener" href="https://github.com/props">@props</a></h5><p>组件接收属性的装饰器，如下使用：</p>
<pre><code class="tsx">import &#123;Component,Vue,Prop&#125; from vue-property-decorator;

@Component
export default class YourComponent extends Vue &#123;
    @Prop(String)
    propA:string;
    
    @Prop([String,Number])
    propB:string|number;
    
    @Prop(&#123;
     type: String, // type: [String , Number]
     default: &#39;default value&#39;, // 一般为String或Number
      //如果是对象或数组的话。默认值从一个工厂函数中返回
      // defatult: () =&gt; &#123;
      //     return [&#39;a&#39;,&#39;b&#39;]
      // &#125;
     required: true,
     validator: (value) =&gt; &#123;
        return [
          &#39;InProcess&#39;,
          &#39;Settled&#39;
        ].indexOf(value) !== -1
     &#125;
    &#125;)
    propC:string;
&#125;
</code></pre>
<h5 id="watch"><a href="#watch" class="headerlink" title="@watch"></a><a target="_blank" rel="noopener" href="https://github.com/watch">@watch</a></h5><p>实际就是<code>Vue</code>中的监听器，如下：</p>
<pre><code class="tsx">import &#123; Vue, Component, Watch &#125; from &#39;vue-property-decorator&#39;

@Component
export default class YourComponent extends Vue &#123;
  @Watch(&#39;child&#39;)
  onChildChanged(val: string, oldVal: string) &#123;&#125;

  @Watch(&#39;person&#39;, &#123; immediate: true, deep: true &#125;)
  onPersonChanged1(val: Person, oldVal: Person) &#123;&#125;

  @Watch(&#39;person&#39;)
  onPersonChanged2(val: Person, oldVal: Person) &#123;&#125;
&#125;
</code></pre>
<h5 id="emit"><a href="#emit" class="headerlink" title="@emit"></a><a target="_blank" rel="noopener" href="https://github.com/emit">@emit</a></h5><p><code>vue-property-decorator</code> 提供的 <code>@Emit</code> 装饰器就是代替<code>Vue </code>中的事件的触发<code>$emit</code>，如下：</p>
<pre><code class="tsx">import &#123;Vue, Component, Emit&#125; from &#39;vue-property-decorator&#39;;
    @Component(&#123;&#125;)
    export default class Some extends Vue&#123;
        mounted()&#123;
            this.$on(&#39;emit-todo&#39;, function(n) &#123;
                console.log(n)
            &#125;)
            this.emitTodo(&#39;world&#39;);
        &#125;
        @Emit()
        emitTodo(n: string)&#123;
            console.log(&#39;hello&#39;);
        &#125;
    &#125;
</code></pre>
<h4 id="三-、总结"><a href="#三-、总结" class="headerlink" title="三 、总结"></a>三 、总结</h4><p>可以看到上述<code>typescript</code>版本的<code>vue class</code>的语法与平时<code>javascript</code>版本使用起来还是有很大的不同，多处用到<code>class</code>与装饰器，但实际上本质是一致的，只有不断编写才会得心应手</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在React项目中应用TypeScript？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在React项目中应用TypeScript？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在React项目中应用TypeScript？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在React项目中应用TypeScript？</h3><h4 id="一、前言-1"><a href="#一、前言-1" class="headerlink" title="一、前言"></a>一、前言</h4><p>单独的使用 <code>TypeScript</code> 并不会导致学习成本很高，但是绝大部分前端开发者的项目都是依赖于框架的</p>
<p>例如与 <code>Vue</code>、<code>React</code> 这些框架结合使用的时候，会有一定的门槛</p>
<p>使用 <code>TypeScript</code> 编写 <code>React</code> 代码，除了需要 <code>TypeScript</code> 这个库之外，还需要安装 <code>@types/react</code>、<code>@types/react-dom</code></p>
<pre><code class="bash">npm i @types/react -s

npm i @types/react-dom -s
</code></pre>
<p>至于上述使用 <code>@types</code> 的库的原因在于，目前非常多的 <code>JavaScript</code> 库并没有提供自己关于 <code>TypeScript</code> 的声明文件</p>
<p>所以，<code>ts</code> 并不知道这些库的类型以及对应导出的内容，这里 <code>@types</code> 实际就是社区中的 <code>DefinitelyTyped</code> 库，定义了目前市面上绝大多数的 <code>JavaScript</code> 库的声明</p>
<p>所以下载相关的 <code>JavaScript</code> 对应的 <code>@types</code> 声明时，就能够使用使用该库对应的类型定义</p>
<h4 id="二、使用方式-5"><a href="#二、使用方式-5" class="headerlink" title="二、使用方式"></a>二、使用方式</h4><p>在编写 <code>React</code> 项目的时候，最常见的使用的组件就是：</p>
<ul>
<li>无状态组件</li>
<li>有状态组件</li>
<li>受控组件</li>
</ul>
<h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><p>主要作用是用于展示 <code>UI</code>，如果使用 <code>js</code> 声明，则如下所示：</p>
<pre><code class="jsx">import * as React from &quot;React&quot;;

export const Logo = (props) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<p>但这时候 <code>ts</code> 会出现报错提示，原因在于没有定义 <code>porps</code> 类型，这时候就可以使用 <code>interface</code> 接口去定义 <code>porps</code> 即可，如下：</p>
<pre><code class="tsx">import * as React from &quot;React&quot;;

interface IProps &#123;
  logo?: string;
  className?: string;
  alt?: string;
&#125;

export const Logo = (props: IProps) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<p>但是我们都知道 <code>props</code> 里面存在 <code>children</code> 属性，我们不可能每个 <code>porps</code> 接口里面定义多一个 <code>children</code>，如下：</p>
<pre><code class="tsx">interface IProps &#123;
  logo?: string;
  className?: string;
  alt?: string;
  children?: ReactNode;
&#125;
</code></pre>
<p>更加规范的写法是使用 <code>React</code> 里面定义好的 <code>FC</code> 属性，里面已经定义好 <code>children</code> 类型，如下：</p>
<pre><code class="tsx">export const Logo: React.FC&lt;IProps&gt; = (props) =&gt; &#123;
  const &#123; logo, className, alt &#125; = props;

  return &lt;img src=&#123;logo&#125; className=&#123;className&#125; alt=&#123;alt&#125; /&gt;;
&#125;;
</code></pre>
<ul>
<li>React.FC 显式地定义了返回类型，其他方式是隐式推导的</li>
<li>React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全</li>
<li>React.FC 为 children 提供了隐式的类型（ReactElement | null）</li>
</ul>
<h5 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h5><p>可以是一个类组件且存在 <code>props</code> 和 <code>state</code> 属性</p>
<p>如果使用 <code>TypeScript</code> 声明则如下所示：</p>
<pre><code class="tsx">import * as React from &quot;React&quot;;

interface IProps &#123;
  color: string;
  size?: string;
&#125;
interface IState &#123;
  count: number;
&#125;
class App extends React.Component&lt;IProps, IState&gt; &#123;
  public state = &#123;
    count: 1,
  &#125;;
  public render() &#123;
    return &lt;div&gt;Hello world&lt;/div&gt;;
  &#125;
&#125;
</code></pre>
<p>上述通过泛型对 <code>props</code>、<code>state</code> 进行类型定义，然后在使用的时候就可以在编译器中获取更好的智能提示</p>
<p>关于 <code>Component</code> 泛型类的定义，可以参考下 React 的类型定义文件 <code>node_modules/@types/React/index.d.ts</code>，如下所示：</p>
<pre><code class="ts">class Component&lt;P, S&gt; &#123;
  readonly props: Readonly&lt;&#123; children?: ReactNode &#125;&gt; &amp; Readonly&lt;P&gt;;

  state: Readonly&lt;S&gt;;
&#125;
</code></pre>
<p>从上述可以看到，<code>state</code> 属性也定义了可读类型，目的是为了防止直接调用 <code>this.state</code> 更新状态</p>
<h5 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h5><p>受控组件的特性在于元素的内容通过组件的状态 <code>state</code> 进行控制</p>
<p>由于组件内部的事件是合成事件，不等同于原生事件，</p>
<p>例如一个 <code>input</code> 组件修改内部的状态，常见的定义的时候如下所示：</p>
<pre><code class="ts">private updateValue(e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#123;
    this.setState(&#123; itemText: e.target.value &#125;)
&#125;
</code></pre>
<p>常用 <code>Event</code> 事件对象类型：</p>
<ul>
<li>ClipboardEvent&lt;T &#x3D; Element&gt; 剪贴板事件对象</li>
<li>DragEvent&lt;T &#x3D; Element&gt; 拖拽事件对象</li>
<li>ChangeEvent&lt;T &#x3D; Element&gt; Change 事件对象</li>
<li>KeyboardEvent&lt;T &#x3D; Element&gt; 键盘事件对象</li>
<li>MouseEvent&lt;T &#x3D; Element&gt; 鼠标事件对象</li>
<li>TouchEvent&lt;T &#x3D; Element&gt; 触摸事件对象</li>
<li>WheelEvent&lt;T &#x3D; Element&gt; 滚轮事件对象</li>
<li>AnimationEvent&lt;T &#x3D; Element&gt; 动画事件对象</li>
<li>TransitionEvent&lt;T &#x3D; Element&gt; 过渡事件对象</li>
</ul>
<p><code>T</code> 接收一个 <code>DOM</code> 元素类型</p>
<h4 id="三、总结-2"><a href="#三、总结-2" class="headerlink" title="三、总结"></a>三、总结</h4><p>上述只是简单的在 <code>React</code> 项目使用 <code>TypeScript</code>，但在编写 <code>React</code> 项目的时候，还存在 <code>hooks</code>、默认参数、以及 <code>store</code> 等等……</p>
<p><code>TypeScript</code> 在框架中使用的学习成本相对会更高，需要不断编写才能熟练</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-使用-Typescript-有哪些优点和缺点"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-使用-Typescript-有哪些优点和缺点" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 使用 Typescript 有哪些优点和缺点"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 使用 Typescript 有哪些优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h5 id="提供可选的强静态类型"><a href="#提供可选的强静态类型" class="headerlink" title="提供可选的强静态类型"></a>提供可选的强静态类型</h5><p>既然叫 TypeScript，那它的最大亮点自然就是提供静态类型（type）。我们可以对变量设置类型，比如你给 count 变量设置为数字类型（number），如果你从 input 元素提取 value （string 类型）赋予给 count，如果你忘记将其转换为数字，编译是不会通过的。</p>
<p>当然类型不是强求设置的，为了兼容 JavaScript，你也可以设置为 any 类型。所谓 any 类型是一个特殊的类型，任何类型的的值都可以赋予给它。</p>
<h5 id="更早发现-BUG"><a href="#更早发现-BUG" class="headerlink" title="更早发现 BUG"></a>更早发现 BUG</h5><p>TypeScript 要编译后才能使用。所以我们的类型错误会在编译过程中被编译器发现，更早发现 BUG。如果直接用 JavaScript 开发，需要在程序运行时，吭哧吭哧点来点去各种测试来判断行为是否正常，费时费力，开发体验极差。</p>
<p>比如原本应该是两个数字相加的，写错成两个数字形式的字符串相加，结果是差得十万八千里，且不易察觉。TypeScript 在编译时就给你找到了，你不改对别想过我编译。</p>
<h5 id="代码可预测"><a href="#代码可预测" class="headerlink" title="代码可预测"></a>代码可预测</h5><p>声明的变量一旦指定类型，它的类型就再也不能修改。这样变量就具有可预测性。</p>
<p>JavaScript 的变量可以赋予任何类型的值。有时候，我们会看到一个变量在执行的过程中变成各种各样的类型，一会是字符串，一会是对象，非常不好预测，尤其是有复杂条件判断的时候。这其实是并不是好的开发习惯，但在 JavaScript 它就是可以这么干！</p>
<p>但如果你用 TypeScript，就没有这个烦恼，它直接给你一刀切了，你别想将字符串值赋予给一个数字类型变量，一旦声明就再也无法修改。</p>
<p>当然为了兼容，你也是可以将其设置 any 类型，但智能提升就没有了哦。</p>
<h5 id="丰富的-IDE-支持"><a href="#丰富的-IDE-支持" class="headerlink" title="丰富的 IDE 支持"></a>丰富的 IDE 支持</h5><p>因为使用了类型，所以检测某个变量是什么类型、可以使用哪些方法就变得容易，在开发体验上就可以进行改善了。</p>
<p>目前在绝大多数 IDE（集成开发环境）中已经支持 TypeScript 的 智能提示、自动补全、代码导航 等功能，并能在编写时实时反馈类型错误并提供准确的建议，比如可以指出传入函数的对象缺了哪些属性。</p>
<h5 id="方便重构"><a href="#方便重构" class="headerlink" title="方便重构"></a>方便重构</h5><p>重构时，如果函数的参数修改了，调用它时如果不对，TypeScript 会提示你。这对重构代码提供了坚实的后盾。有了 TypeScript，就放心做重构吧，前提你不要到处用 any。</p>
<h5 id="提供面向对象的写法"><a href="#提供面向对象的写法" class="headerlink" title="提供面向对象的写法"></a>提供面向对象的写法</h5><p>面向对象语言在实践中已经被证实是优秀的设计，拥有极高的可读性、可维护性。TypeScript 支持接口、抽象类、枚举等面向对象语言的特性，支持你更好地实现一些设计模式。TypeScript 还支持类型体操，有空多锻炼身体哈。</p>
<p>看了这么多优点，再看看 TypeScript 的缺点。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="不是真正的静态类型"><a href="#不是真正的静态类型" class="headerlink" title="不是真正的静态类型"></a>不是真正的静态类型</h5><p>因为需要兼容 JavaScript 的缘故，TypeScript 的类型是可选的。你可以用 any 类型，也可以进行类型的强制转换，所以如果你在代码中写了太多这样的东西，甚至将其变成 AnyScript。那么实际运行还是可能会出现一些类型上的问题。</p>
<h5 id="有一定的学习成本"><a href="#有一定的学习成本" class="headerlink" title="有一定的学习成本"></a>有一定的学习成本</h5><p>学 TypeScript 其实和学习一门新语言差不多了，还是有不小的学习成本的。但因为兼容 JavaScript 的缘故，对前端开发者来说难度会低一点。</p>
<h5 id="需要写更多的代码"><a href="#需要写更多的代码" class="headerlink" title="需要写更多的代码"></a>需要写更多的代码</h5><p>主要是类型和接口声明的部分，但能够抵消掉你 debug 类型问题的时间，总体看还是物超所值的。另外，编译后类型和接口声明都会被移除，相比直接写 JavaScript，体积不会明显更大。</p>
<h5 id="需要编译"><a href="#需要编译" class="headerlink" title="需要编译"></a>需要编译</h5><p>浏览器和 Nodejs 并不支持 TypeScript，所以多了一步编译操作。对于普通项目来说通常不长，其实还好。但如果你用来写脚本的话，就需要多安装 tsc 编译工具，还要配置好 tsconfig.json 文件，还是有点麻烦。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-Typescript中的内置类型有哪些？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-Typescript中的内置类型有哪些？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Typescript中的内置类型有哪些？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ Typescript中的内置类型有哪些？</h3><h4 id="Partial（部分的）"><a href="#Partial（部分的）" class="headerlink" title="Partial（部分的）"></a>Partial（部分的）</h4><pre><code class="typescript">/**
 * Make all properties in T optional
 */
type Partial&lt;T&gt; = &#123;
    [P in keyof T]?: T[P];
&#125;;
</code></pre>
<p>作用是让传入类型中的所有属性变成都是可选的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;&#125;

const student2: Partial&lt;Student&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101152.jpeg"></p>
<p>变量student1的类型是Student，Student默认所有的属性都是不能为空的，所有会报错，student2就不会</p>
<h4 id="Required（必须的）"><a href="#Required（必须的）" class="headerlink" title="Required（必须的）"></a>Required（必须的）</h4><pre><code class="typescript">/**
 * Make all properties in T required
 */
type Required&lt;T&gt; = &#123;
    [P in keyof T]-?: T[P];
&#125;;
</code></pre>
<p>跟Partial的作用是相反的，是让传入类型中的所有属性变成都是必填的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name?: string;
  age?: number;
&#125;

const student1: Student = &#123;&#125;

const student2: Required&lt;Student&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101153.jpeg"></p>
<p>变量student1的类型是Student，Student默认所有的属性都是可以为空的，所有不会报错，student2会报错</p>
<h4 id="Readonly（只读的）"><a href="#Readonly（只读的）" class="headerlink" title="Readonly（只读的）"></a>Readonly（只读的）</h4><pre><code class="typescript">/**
 * Make all properties in T readonly
 */
type Readonly&lt;T&gt; = &#123;
    readonly [P in keyof T]: T[P];
&#125;;
</code></pre>
<p>作用是让传入类型中的所有属性变成都是只读的（不能修改属性）</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;
student1.age = 21

const student2: Readonly&lt;Student&gt; = &#123;
  name: &#39;李四&#39;,
  age: 20
&#125;
student2.age = 21
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101154.jpeg"></p>
<p>给student1的属性age重新赋值不会报错，给student2的属性age重新赋值就会报错，因为student2所有的属性都是只读的</p>
<h4 id="Pick（选择）"><a href="#Pick（选择）" class="headerlink" title="Pick（选择）"></a>Pick（选择）</h4><pre><code class="typescript">/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Pick&lt;T, K extends keyof T&gt; = &#123;
    [P in K]: T[P];
&#125;;
</code></pre>
<p>作用是选择传入类型中的部分属性组成新类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: Student = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;

const student2: Pick&lt;Student, &#39;name&#39;&gt; = &#123;
  name: &#39;李四&#39;
&#125;

const student3: Pick&lt;Student, &#39;name&#39;&gt; = &#123;
  name: &#39;王五&#39;,
  age: 20
&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101155.jpeg"></p>
<p>变量student1可以有所有属性name和age，变量student2就只能有属性name，变量student3加上属性age就会报错</p>
<h4 id="Record（记录）"><a href="#Record（记录）" class="headerlink" title="Record（记录）"></a>Record（记录）</h4><pre><code class="typescript">/**
 * Construct a type with a set of properties K of type T
 */
type Record&lt;K extends keyof any, T&gt; = &#123;
    [P in K]: T;
&#125;;
</code></pre>
<p>作用是构建一个类型，这个类型用来描述一个对象，这个对象的属性都具有相同的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export const student1: Record&lt;string, any&gt; = &#123;
  name: &#39;张三&#39;,
  age: 20
&#125;
</code></pre>
<p>Record应该是日常使用频率较高的内置类型了，主要用来描述对象，一般建议是不用Object来描述对象，而是用Record代替，Record&lt;string, any&gt;几乎可以说是万金油了</p>
<h4 id="Exclude（排除）"><a href="#Exclude（排除）" class="headerlink" title="Exclude（排除）"></a>Exclude（排除）</h4><pre><code class="typescript">/**
 * Exclude from T those types that are assignable to U
 */
type Exclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre>
<p>针对联合类型（interface这种没用），用人话说，排除相同的，留下不同的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Exclude&lt;StudentAttr, PersonAttr&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101156.jpeg"></p>
<p>student1就只能被赋值为’class’ 或者’school’</p>
<h4 id="Extract（取出）"><a href="#Extract（取出）" class="headerlink" title="Extract（取出）"></a>Extract（取出）</h4><pre><code class="typescript">/**
 * Extract from T those types that are assignable to U
 */
type Extract&lt;T, U&gt; = T extends U ? T : never;
</code></pre>
<p>与Exclude相反，针对联合类型，排除不同的的，取出相同的</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Extract&lt;StudentAttr, PersonAttr&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101157.jpeg"></p>
<p>student1就只能被赋值为’name’或者’age’</p>
<h4 id="Omit（省略）"><a href="#Omit（省略）" class="headerlink" title="Omit（省略）"></a>Omit（省略）</h4><pre><code class="typescript">/**
 * Construct a type with the properties of T except for those in type K.
 */
type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;
</code></pre>
<p>传入一个类型，和这个类型的几个属性，把传入的属性省略掉，组成一个新类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
  class: string;
  school: string;
&#125;

export type PersonAttr = &#39;name&#39; | &#39;age&#39;

export type StudentAttr = &#39;name&#39; | &#39;age&#39; | &#39;class&#39; | &#39;school&#39;

const student1: Omit&lt;Student, PersonAttr&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101158.jpeg"></p>
<p>student1报错，提示没有属性’name’、’age’</p>
<h4 id="NonNullable（不能为null）"><a href="#NonNullable（不能为null）" class="headerlink" title="NonNullable（不能为null）"></a>NonNullable（不能为null）</h4><pre><code class="typescript">/**
 * Exclude null and undefined from T
 */
type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;
</code></pre>
<p>字面意思，不能为空</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

const student1: NonNullable&lt;Student | undefined | null&gt; = null
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101159.jpeg"></p>
<p>student1赋值为null会报错（在tsconfig.json配置文件中开启类型检查，<code>&quot;skipLibCheck&quot;: false</code>）</p>
<h4 id="Parameters（参数）"><a href="#Parameters（参数）" class="headerlink" title="Parameters（参数）"></a>Parameters（参数）</h4><pre><code class="typescript">/**
 * Obtain the parameters of a function type in a tuple
 */
type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>获取传入函数的参数组成的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentFunc &#123;
  (name: string, age: number): Student
&#125;

const student1: Parameters&lt;StudentFunc&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101160.jpeg"></p>
<p>student1的类型为<code>[name: string, age: number]</code></p>
<h4 id="ConstructorParameters（构造参数）"><a href="#ConstructorParameters（构造参数）" class="headerlink" title="ConstructorParameters（构造参数）"></a>ConstructorParameters（构造参数）</h4><pre><code class="typescript">/**
 * Obtain the parameters of a constructor function type in a tuple
 */
type ConstructorParameters&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>获取传入构造函数的参数组成的类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentConstructor &#123;
  new (name: string, age: number): Student
&#125;

const student1: ConstructorParameters&lt;StudentConstructor&gt;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101161.jpeg"></p>
<p>student1的类型为<code>[name: string, age: number]</code></p>
<h4 id="ReturnType（返回类型）"><a href="#ReturnType（返回类型）" class="headerlink" title="ReturnType（返回类型）"></a>ReturnType（返回类型）</h4><pre><code class="typescript">/**
 * Obtain the return type of a function type
 */
type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;
</code></pre>
<p>获取传入函数的返回类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export interface Student &#123;
  name: string;
  age: number;
&#125;

export interface StudentFunc &#123;
  (name: string, age: number): Student
&#125;

const student1: ReturnType&lt;StudentFunc&gt; = &#123;&#125;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101162.jpeg"></p>
<p>student1的类型为<code>Student</code></p>
<h4 id="InstanceType（构造返回类型、实例类型）"><a href="#InstanceType（构造返回类型、实例类型）" class="headerlink" title="InstanceType（构造返回类型、实例类型）"></a>InstanceType（构造返回类型、实例类型）</h4><pre><code class="typescript">/**
 * Obtain the return type of a constructor function type
 */
type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any;
</code></pre>
<p>获取传入构造函数的返回类型</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">const Student = class &#123;
  name: string;
  age: number;
  constructor (name: string, age: number) &#123;
    this.name = name
    this.age = age
  &#125;
  showInfo () &#123;
    console.log(&#39;name: &#39;, this.name, &#39;age: &#39;, this.age);
  &#125;
&#125;

const student1: InstanceType&lt;typeof Student&gt; = new Student(&#39;张三&#39;, 20)
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101163.jpeg"></p>
<p>个人认为这是一个非常好用的内置类型，目前在前端项目中，class是用的越来越多了，在TS中，class其实也是可以用作类型声明空间的，用来描述对象类型，但是一般来说好像很少这样用的，一般用interface或者type居多</p>
<pre><code class="typescript">export class Student &#123;
  name: string;
  age: number;
&#125;
</code></pre>
<p>所以一般就是直接把class用作变量声明空间，但是对于 class new 出的实例，怎么描述它的类型呢，就如上文的，直接<code>const student1: Student</code>那是铁定会报错的，因为Student用作变量声明空间，没有用作类型声明空间（听起来好绕），这时候就可以用到InstanceType，完美解决问题</p>
<h4 id="Uppercase（大写）"><a href="#Uppercase（大写）" class="headerlink" title="Uppercase（大写）"></a>Uppercase（大写）</h4><pre><code class="typescript">/**
 * Convert string literal type to uppercase
 */
type Uppercase&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>变大写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;male&#39; | &#39;female&#39;

const studentSex: Uppercase&lt;StudentSexType&gt; = &#39;MALE&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101164.jpeg"></p>
<h4 id="Lowercase（小写）"><a href="#Lowercase（小写）" class="headerlink" title="Lowercase（小写）"></a>Lowercase（小写）</h4><pre><code class="typescript">/**
 * Convert string literal type to lowercase
 */
type Lowercase&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>变小写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;MALE&#39; | &#39;FEMALE&#39;

const studentSex: Lowercase&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101165.jpeg"></p>
<h4 id="Capitalize（首字母大写）"><a href="#Capitalize（首字母大写）" class="headerlink" title="Capitalize（首字母大写）"></a>Capitalize（首字母大写）</h4><pre><code class="typescript">/**
 * Convert first character of string literal type to uppercase
 */
type Capitalize&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>首字母变大写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;male&#39; | &#39;female&#39;

const studentSex: Capitalize&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101166.jpeg"></p>
<h4 id="Uncapitalize（首字母小写）"><a href="#Uncapitalize（首字母小写）" class="headerlink" title="Uncapitalize（首字母小写）"></a>Uncapitalize（首字母小写）</h4><pre><code class="typescript">/**
 * Convert first character of string literal type to lowercase
 */
type Uncapitalize&lt;S extends string&gt; = intrinsic;
</code></pre>
<p>首字母变小写</p>
<blockquote>
<p>使用举例</p>
</blockquote>
<pre><code class="typescript">export type StudentSexType = &#39;MALE&#39; | &#39;FEMALE&#39;

const studentSex: Uncapitalize&lt;StudentSexType&gt; = &#39;&#39;
</code></pre>
<p><img src="/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/1460000041101167.jpeg"></p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-能否将多个-ts-文件组合成一个-js-文件？-如果是，那么如何？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-能否将多个-ts-文件组合成一个-js-文件？-如果是，那么如何？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 能否将多个 .ts 文件组合成一个 .js 文件？ 如果是，那么如何？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 能否将多个 <code>.ts</code> 文件组合成一个 <code>.js</code> 文件？ 如果是，那么如何？</h3><p>这是可以的。需要添加 —outFILE [OutputJSFileName] 编译选项。</p>
<pre><code class="shell">$ tsc --outFile comman.js file1.ts file2.ts file3.ts
</code></pre>
<p>上述命令将编译所有三个<code>.ts</code>文件，结果将存储到单个<code>comman.js</code>文件中。在这种情况下，当没有像下面的命令那样提供输出文件名时。</p>
<pre><code class="shell">$ tsc --outFile file1.ts file2.ts file3.ts
</code></pre>
<p>然后，<code>file2.ts</code>和<code>file3.ts</code>会被编译，输出会放在<code>file1.ts</code>中。所以现在的 <code>file1.ts</code> 包含 JavaScript 代码。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-是否可以通过-ts-文件中的实时更改自动编译-ts-？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-是否可以通过-ts-文件中的实时更改自动编译-ts-？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 是否可以通过 .ts 文件中的实时更改自动编译 .ts ？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 是否可以通过 <code>.ts</code> 文件中的实时更改自动编译 <code>.ts</code> ？</h3><p>是的，可以通过 <code>.ts</code> 文件中的实时更改自动编译<code>.ts</code>。这可以通过使用 <code>--watch</code> 编译器选项来实现。</p>
<pre><code class="shell">tsc --watch file1.ts
</code></pre>
<p>上面的命令首先编译 <code>file1.js</code> 中的 <code>file1.ts</code> 并观察文件的变化。如果检测到任何更改，它将再次编译该文件。在这里，需要确保在使用 <code>--watch</code> 选项运行时不能关闭命令提示符。</p>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-interface语句和type语句有什么区别？"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-interface语句和type语句有什么区别？" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ interface语句和type语句有什么区别？"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ interface语句和type语句有什么区别？</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>都可以描述一个对象或者函数</p>
<p>interface</p>
<pre><code class="typescript">interface User &#123;
  name: string
  age: number
&#125;

interface SetUser &#123;
  (name: string, age: number): void;
&#125;
</code></pre>
<p>type</p>
<pre><code class="typescript">type User = &#123;
  name: string
  age: number
&#125;;

type SetUser = (name: string, age: number)=&gt; void;
</code></pre>
<p>都允许拓展（extends）</p>
<p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p>
<p>interface extends interface</p>
<pre><code class="typescript">interface Name &#123; 
  name: string; 
&#125;
interface User extends Name &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<p>type extends type</p>
<pre><code class="ini">type Name = &#123; 
  name: string; 
&#125;
type User = Name &amp; &#123; age: number  &#125;;
复制代码
</code></pre>
<p>interface extends type</p>
<pre><code class="typescript">type Name = &#123; 
  name: string; 
&#125;
interface User extends Name &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<p>type extends interface</p>
<pre><code class="ini">interface Name &#123; 
  name: string; 
&#125;
type User = Name &amp; &#123; 
  age: number; 
&#125;
复制代码
</code></pre>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>type 可以而 interface 不行</p>
<ul>
<li>type 可以声明基本类型别名，联合类型，元组等类型</li>
</ul>
<pre><code class="go">// 基本类型别名
type Name = string

// 联合类型
interface Dog &#123;
    wong();
&#125;
interface Cat &#123;
    miao();
&#125;

type Pet = Dog | Cat

// 具体定义数组每个位置的类型
type PetList = [Dog, Pet]

复制代码
</code></pre>
<ul>
<li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</li>
</ul>
<pre><code class="ini">// 当你想获取一个变量的类型时，使用 typeof
let div = document.createElement(&#39;div&#39;);
type B = typeof div
复制代码
</code></pre>
<ul>
<li>其他骚操作</li>
</ul>
<pre><code class="ini">type StringOrNumber = string | number;  
type Text = string | &#123; text: string &#125;;  
type NameLookup = Dictionary&lt;string, Person&gt;;  
type Callback&lt;T&gt; = (data: T) =&gt; void;  
type Pair&lt;T&gt; = [T, T];  
type Coordinates = Pair&lt;number&gt;;  
type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;
复制代码
</code></pre>
<p>interface 可以而 type 不行</p>
<p>interface 能够声明合并</p>
<pre><code class="typescript">interface User &#123;
  name: string
  age: number
&#125;

interface User &#123;
  sex: string
&#125;

/*
User 接口为 &#123;
  name: string
  age: number
  sex: string 
&#125;
*/
复制代码
</code></pre>
<h3 id="♥︎-♥︎-♥︎-♥︎-♥︎-如何在Proxy中代理apply方法"><a href="#♥︎-♥︎-♥︎-♥︎-♥︎-如何在Proxy中代理apply方法" class="headerlink" title="♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Proxy中代理apply方法"></a>♥︎ ♥︎ ♥︎ ♥︎ ♥︎ 如何在Proxy中代理apply方法</h3><pre><code class="javascript"> &#123;
            var target = function () &#123;
                return &#39;I am the target&#39;;
            &#125;
            var handler = &#123;
                apply: function () &#123;
                    return &#39;I am the proxy&#39;;
                &#125;
            &#125;;
            var p = new Proxy(target,handler);
            console.log(&quot;p&quot;,p());
        &#125;
//上面代码中，变量p是Proxy的实例，当他作为函数调用时（p（））
//,就会被apply方法拦截，返回一个字符串
</code></pre>
<pre><code class="javascript">&#123;
    var twice = &#123;
                    //目标对象，目标对象的上下文对象，目标对象的参数数组
        apply:function (target,ctx,args) &#123;
            //return console.log(&quot;target&quot;,target,&quot;ctx&quot;,ctx,&quot;args&quot;,args);
           return Reflect.apply(...arguments)*2;
        &#125;
    &#125;;
    function sum (left,right) &#123;
         return left*right;
    &#125;;
    var proxy = new Proxy(sum,twice);
    console.log(&quot;proxy1&quot;,proxy(1,2));
    console.log(&quot;proxy.call&quot;,proxy.call(null,5,6));
    console.log(&quot;proxy,apply&quot;,proxy.apply(null,[7,8]));
    console.log(&quot;proxy,apply&quot;,Reflect.apply(proxy,null,[7,8]));

&#125;
//上面的实例执行顺序是当sum（）执行完后再执行twice中的apply()，
//上面代码中每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截
//另外，直接调用Reflect.apply方法，也会被拦截。
</code></pre>
<p>参考文献：</p>
<p>[语音仓库]: 	“<a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a> “</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://mengfeng.github.io/2022/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8TypeScript/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/11/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            前端面试大全设计模式
          
        </div>
      </a>
    
    
      <a href="/2022/11/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%A7%E5%85%A8%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">前端面试大全网络攻防</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '6887374e7666a97fd4dc',
    clientSecret: '09a8e143dd4a3f5d11311e1435842321e063157d',
    repo: 'mengfeng.github.io',
    owner: 'mengfeng',
    admin: ['mengfeng'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>