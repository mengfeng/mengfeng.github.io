<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 艺术码畜</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G16F14RTRN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-G16F14RTRN');
</script>

 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?f5e6c5b5d28b6bff1c9eb1fcf7f6862b";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="艺术码畜" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/mengfeng/mengfeng.github.io.git"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">艺术码畜</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">艺术码畜的生活瞬间</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-chatGPT注册"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/"
    >chatGPT注册</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/" class="article-date">
  <time datetime="2022-12-14T00:37:52.000Z" itemprop="datePublished">2022-12-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/">趣味技术</a> / <a class="article-category-link" href="/categories/%E8%B6%A3%E5%91%B3%E6%8A%80%E6%9C%AF/chatGPT%E6%B3%A8%E5%86%8C/">chatGPT注册</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="chatGPT注册、登陆具体流程"><a href="#chatGPT注册、登陆具体流程" class="headerlink" title="chatGPT注册、登陆具体流程"></a>chatGPT注册、登陆具体流程</h1><blockquote>
<p>需要科学上网</p>
<p>由于目前推广期间，chatGPT只要注册openai就可以免费使用chatGPT</p>
</blockquote>
<h3 id="一、进入chatGPT的注册页面"><a href="#一、进入chatGPT的注册页面" class="headerlink" title="一、进入chatGPT的注册页面"></a>一、进入chatGPT的注册页面</h3><p>[chatGPT]: 	“<a target="_blank" rel="noopener" href="https://chat.openai.com/auth/login">https://chat.openai.com/auth/login</a> “</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081000882.png"></p>
<h3 id="二、点击Sign-up注册"><a href="#二、点击Sign-up注册" class="headerlink" title="二、点击Sign up注册"></a>二、点击Sign up注册</h3><p>我注册的时候用的谷歌邮箱</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081235003.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081250319.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081403723.png"></p>
<h3 id="三、进入了电话号码验证环节"><a href="#三、进入了电话号码验证环节" class="headerlink" title="三、进入了电话号码验证环节"></a>三、进入了电话号码验证环节</h3><p>一个号码模拟平台 <a target="_blank" rel="noopener" href="https://sms-activate.org/cn?ref=2780512">https://sms-activate.org/cn?ref=2780512</a></p>
<p>第一步去注册登陆（这一步没什么问题）</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081608840.png"></p>
<p>第二步需要存钱了哈哈哈</p>
<p>当然，充多少一般都可以，如果只用这一次的话可以充少一点，0.2-0.5美元</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081921982.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214081825615.png"></p>
<p>我们可以选择支付宝来充值，很方便</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082059408.png"></p>
<p>等到充值到账（大概几分钟）</p>
<p>我们就可以购买服务了，点击购物车（这个便宜）</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082407157.png"></p>
<p>然后，可以在激活区看到待使用的临时号码，将此号码复制到 OpenAI 的验证码接收区里面。</p>
<p>先选择对应国家，再填号码，然后发送电话号码，激活区就可以看见验证码了。</p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214083118069.png"></p>
<p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214082913264.png"></p>
<p>电话验证完，注册完毕</p>
<h3 id="四、登陆chatGPT"><a href="#四、登陆chatGPT" class="headerlink" title="四、登陆chatGPT"></a>四、登陆chatGPT</h3><p><img src="/2022/12/14/chatGPT%E6%B3%A8%E5%86%8C/image-20221214083525980.png"></p>
<p>这时候我们就可以开始和它愉快的聊天了</p>
<p>我们下一篇会介绍它是什么？</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/chatGPT/" rel="tag">chatGPT</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-响应式设计"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/"
    >响应式设计</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2022-12-13T06:45:26.000Z" itemprop="datePublished">2022-12-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/">响应式设计</a> / <a class="article-category-link" href="/categories/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/">响应式设计</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h1><blockquote>
<p>自适应、响应式、弹性布局、屏幕适配，这是四个独立不同的概念。</p>
</blockquote>
<h3 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h3><p>自适应：多端请求时返回不同的页面，服务端需要准备多套程序或者多套模板。</p>
<p>响应式：主要是利用css媒体查询使得在不同屏幕大小下，页面有不同表现，主要是元素布局等变化。</p>
<p>弹性布局：主要是利用百分比设置元素宽度，浮动还有flex设置元素布局等等。</p>
<p>屏幕适配：主要是应用于对完美还原设计稿尺寸有要求的页面，主要是利用 rem、vm等技术。（类似于750px的设计稿是一张图片，这张图片无论怎么缩放，都能显示很好的效果，现在我们的网页也需要图片这种等比缩放的效果，这么说你应该能体会到了。当然了，这里还需要顺便解决高清屏显示的问题。）</p>
<h3 id="二、技术方案怎么选"><a href="#二、技术方案怎么选" class="headerlink" title="二、技术方案怎么选"></a>二、技术方案怎么选</h3><ol>
<li>简单 &amp; 对速度不敏感和对代码精简没要求 &amp; 预算紧张</li>
</ol>
<p>​      响应式，一套代码解决多端</p>
<p>​     展示阅读类 交互逻辑简单且少，且移动端与pc端内容差异不大，如新闻站，企业官网</p>
<ol start="2">
<li>复杂 &amp; 对精简代码和速度有要求 预算充足</li>
</ol>
<p>​      做两套 根据请求头自适应返回 web端 手机端 （后端可共用，也可不共用，如不同模块或者部署不同应用）</p>
<p>​     功能类，交互逻辑复杂且多，如电商，社交类</p>
<ol start="3">
<li>复杂 &amp; 有多终端适配要求 &amp; 对细节有一定要求 追求用户体验 &amp; 预算豪华</li>
</ol>
<p>​       做两套 移动端用适配做以满足不同移动终端</p>
<ol start="4">
<li>复杂 &amp; 细节要求和技术追求极高 &amp; 追求极致完美的用户体验 &amp; 不差钱 （艺术家、哲学家）</li>
</ol>
<p>​      多端 多套 响应式 适配 多技术相结合</p>
<h3 id="三、各种方案的详细讲解"><a href="#三、各种方案的详细讲解" class="headerlink" title="三、各种方案的详细讲解"></a>三、各种方案的详细讲解</h3><h4 id="1-媒体查询"><a href="#1-媒体查询" class="headerlink" title="1.媒体查询"></a>1.媒体查询</h4><p>要想实现css屏幕大小自适应，首先得引入 CSS3 @media 媒体查询器：</p>
<p>media的使用和规则：</p>
<p>　　①被链接文档将显示在什么设备上。</p>
<p>　　②用于为不同的媒介类型规定不同的样式。</p>
<p>语法： </p>
<pre><code class="css">@media 设备名 only （选取条件） not （选取条件） and（设备选取条件），设备二&#123;sRules&#125;
</code></pre>
<p>实例：</p>
<pre><code class="css">/* 这是匹配横屏的状态，横屏时的css代码 */

@media all and (orientation :landscape)&#123;&#125;

/* 这是匹配竖屏的状态，竖屏时的css代码 */

@media all and (orientation :portrait)&#123;&#125;

@media X and (min-width:200px)&#123;&#125;
/*X为媒体类型---&gt;比如print/screen/TV等等*/

/* 宽度大于600px小于960之间时，隐藏footer结构 */

@media all and (min-height:640px) and (max-height:960px)&#123;
   　　　footer&#123;display:none;&#125;
&#125;
</code></pre>
<p>在实际应用的时候，首先得在HTML的头文件<head>里上加入以下代码：</p>
<pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;
</code></pre>
<p>解释：　　　</p>
<p>width &#x3D; device-width：宽度等于当前设备的宽度</p>
<p>initial-scale：初始的缩放比例（默认设置为1.0） </p>
<p>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）  </p>
<p>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） </p>
<p>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）</p>
<p>因为media的类型很多，这里就发MDN的对应链接了：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media</a></p>
<p>下面是media类型的screen（用于电脑屏幕，平板电脑，智能手机等）：</p>
<p><strong>css自适应屏幕大小大方法：</strong></p>
<pre><code class="css">@media screen and (min-width: 320px) and (max-width: 1156px)&#123;

              .site-bg-dl &#123;
              position: fixed;
              height: 100%;
              width: 100%;
              z-index: 0;
              background-image: url(bjxzfwzx/images/bj1.png);
              background-size: cover;
              background-repeat: no-repeat;
              background-attachment: fixed;
              background-size:100% 100%;
              -moz-background-size:100% 100%;
            &#125;
&#125;
</code></pre>
<p>解释：</p>
<p>告诉浏览器当屏幕大于320px，并小于1156px下执行此代码；</p>
<p>在css中添加如下内容 可以分别定制不同屏幕的显示样式：</p>
<pre><code class="css">/* 大屏幕 ：大于等于1200px*/
@media (min-width: 1200px) &#123; ... &#125;

/*默认*/
@media (min-width: 980px)&#123;...&#125;

/* 平板电脑和小屏电脑之间的分辨率 */
@media (min-width: 768px) and (max-width: 979px) &#123; ... &#125;

/* 横向放置的手机和竖向放置的平板之间的分辨率 */
@media (max-width: 767px) &#123; ... &#125;

/* 横向放置的手机及分辨率更小的设备 */
@media (max-width: 480px) &#123; ... &#125;
</code></pre>
<p>Media Queries Level 4 引入了一种新的范围语法，在测试接受范围的任何特性时允许更简洁的媒体查询，如下面的示例所示：</p>
<pre><code class="css">@media (height &gt; 600px) &#123;
  body &#123;
    line-height: 1.4;
  &#125;
&#125;

@media (400px &lt;= width &lt;= 700px) &#123;
  body &#123;
    line-height: 1.4;
  &#125;
&#125;
</code></pre>
<h4 id="2-如何选择屏幕大小分割点"><a href="#2-如何选择屏幕大小分割点" class="headerlink" title="2.如何选择屏幕大小分割点"></a>2.如何选择屏幕大小分割点</h4><p>如何确定媒体查询的分割点也是一个开发中会遇到的问题，下面是市场上的移动设备和电脑屏幕分辨率的分布情况，可以发现不同品牌和型号的设备屏幕分辨率一般都不一样</p>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213140505623.png"></p>
<p>如果我们选择<code>600px</code>,<code>900px</code>,<code>1200px</code>,<code>1800px</code>作为分割点，可以适配到常见的14个机型：</p>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213140556282.png"></p>
<p>而作为曾经典型的响应式布局框架，<code>Bootstrap</code>是怎么进行断点的呢？</p>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213140637166.png"></p>
<p>上面的分割方案不一定满足项目中的实际需求，我们可以先用跨度大的分割点进行分割，如果出现不适配的情况可以再根据实际情况增加新的分割点。</p>
<h4 id="3-移动优先-or-PC优先"><a href="#3-移动优先-or-PC优先" class="headerlink" title="3.移动优先 or PC优先"></a>3.移动优先 or PC优先</h4><p>不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是<code>min-width</code>，PC端优先使用的<code>max-width</code>。</p>
<p>移动优先：</p>
<pre><code class="css">/* iphone6 7 8 */
body &#123;
    background-color: yellow;
&#125;
/* iphone 5 */
@media screen and (max-width: 320px) &#123;
    body &#123;
      background-color: red;
    &#125;
&#125;
/* iphoneX */
@media screen and (min-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    body &#123;
      background-color: #0FF000;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (min-width: 414px) &#123;
    body &#123;
      background-color: blue;
    &#125;
&#125;
/* ipad */
@media screen and (min-width: 768px) &#123;
    body &#123;
      background-color: green;
    &#125;
&#125;
/* ipad pro */
@media screen and (min-width: 1024px) &#123;
    body &#123;
      background-color: #FF00FF;
    &#125;
&#125;
/* pc */
@media screen and (min-width: 1100px) &#123;
    body &#123;
      background-color: black;
    &#125;
&#125;
</code></pre>
<p>pc优先：</p>
<pre><code class="css">/* pc width &gt; 1024px */
    body &#123;
        background-color: yellow;
    &#125;
/* ipad pro */
@media screen and (max-width: 1024px) &#123;
    body &#123;
        background-color: #FF00FF;
    &#125;
&#125;
/* ipad */
@media screen and (max-width: 768px) &#123;
    body &#123;
        background-color: green;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (max-width: 414px) &#123;
    body &#123;
        background-color: blue;
    &#125;
&#125;
/* iphoneX */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    body &#123;
        background-color: #0FF000;
    &#125;
&#125;
/* iphone6 7 8 */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123;
    body &#123;
        background-color: #0FF000;
    &#125;
&#125;
/* iphone5 */
@media screen and (max-width: 320px) &#123;
    body &#123;
        background-color: #0FF000;
    &#125;
&#125;
</code></pre>
<h4 id="4-百分比布局"><a href="#4-百分比布局" class="headerlink" title="4.百分比布局"></a>4.百分比布局</h4><p>通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap里面的栅格系统就是利用百分比来定义元素的宽高，<code>CSS3</code>支持最大最小高，可以将百分比和<code>max(min)</code>一起结合使用来定义元素在不同设备下的宽高。</p>
<pre><code class="css">/* pc width &gt; 1100px */
html, body &#123; margin: 0;padding: 0;width: 100%;height: 100%;&#125;
aside &#123;
    width: 10%;
    height: 100%;
    background-color: red;
    float: left;
&#125;
main &#123;
    height: 100%;
    background-color: blue;
    overflow: hidden;
&#125;
/* ipad pro */
@media screen and (max-width: 1024px) &#123;
    aside &#123;
      width: 8%;
      background-color: yellow;
    &#125;
&#125;
/* ipad */
@media screen and (max-width: 768px) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 10%;
      background-color: green;
    &#125;
    main &#123;
      height: calc(100vh - 10%);
      background-color: red;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (max-width: 414px) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 5%;
      background-color: yellow;
    &#125;
    main &#123;
      height: calc(100vh - 5%);
      background-color: red;
    &#125;
&#125;
/* iphoneX */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 10%;
      background-color: blue;
    &#125;
    main &#123;
      height: calc(100vh - 10%);
      background-color: red;
    &#125;
&#125;
/* iphone6 7 8 */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 3%;
      background-color: black;
    &#125;
    main &#123;
      height: calc(100vh - 3%);
      background-color: red;
    &#125;
&#125;
/* iphone5 */
@media screen and (max-width: 320px) &#123;
    aside &#123;
      float: none;
      width: 100%;
      height: 7%;
      background-color: green;
    &#125;
    main &#123;
      height: calc(100vh - 7%);
      background-color: red;
    &#125;
&#125;
</code></pre>
<p>但是我们必须要弄清楚css中子元素的百分比到底是相对谁的百分比。</p>
<p>子元素的<code>height</code>或<code>width</code>中使用百分比，是相对于子元素的直接父元素，<code>width</code>相对于父元素的<code>width</code>，<code>height</code>相对于父元素的<code>height</code>；子元素的<code>top</code>和<code>bottom</code>如果设置百分比，则相对于直接非<code>static</code>定位(默认定位)的父元素的高度，同样子元素的<code>left</code>和<code>right</code>如果设置百分比，则相对于直接非<code>static</code>定位(默认定位的)父元素的宽度；子元素的<code>padding</code>如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的<code>width</code>，而与父元素的<code>height</code>无关。跟<code>padding</code>一样，<code>margin</code>也是如此，子元素的<code>margin</code>如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的<code>width</code>；<code>border-radius</code>不一样，如果设置<code>border-radius</code>为百分比，则是相对于自身的宽度，除了<code>border-radius</code>外，还有比如<code>translate</code>、<code>background-size</code>等都是相对于自身的；</p>
<p>从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：</p>
<ul>
<li>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。</li>
<li>可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如<code>width</code>和<code>height</code>相对于父元素的<code>width</code>和<code>height</code>，而<code>margin</code>、<code>padding</code>不管垂直还是水平方向都相对比父元素的宽度、<code>border-radius</code>则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。</li>
</ul>
<h4 id="5-rem布局"><a href="#5-rem布局" class="headerlink" title="5.rem布局"></a>5.rem布局</h4><p><code>REM</code>是<code>CSS3</code>新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。<code>rem</code>单位都是相对于根元素html的<code>font-size</code>来决定大小的,根元素的<code>font-size</code>相当于提供了一个基准，当页面的size发生变化时，只需要改变<code>font-size</code>的值，那么以<code>rem</code>为固定单位的元素的大小也会发生响应的变化。 因此，如果通过<code>rem</code>来实现响应式的布局，只需要根据视图容器的大小，动态的改变<code>font-size</code>即可（而<code>em</code>是相对于父元素的）。</p>
<p><strong>rem响应式的布局思想：</strong></p>
<ul>
<li>一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值</li>
<li>高度值可以设置固定值，设计稿有多大，我们就严格有多大</li>
<li>所有设置的固定值都用<code>rem</code>做单位（首先在HTML总设置一个基准值：<code>px</code>和<code>rem</code>的对应比例，然后在效果图上获取<code>px</code>值，布局的时候转化为<code>rem</code>值)</li>
<li>js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了。</li>
</ul>
<p><strong>rem布局的缺点：</strong></p>
<p>在响应式布局中，必须通过js来动态控制根元素<code>font-size</code>的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变<code>font-size</code>的代码放在<code>css</code>样式之前</p>
<pre><code class="javascript">/*上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/
function refreshRem() &#123;
    var docEl = doc.documentElement;
    var width = docEl.getBoundingClientRect().width;
    var rem = width / 10;
    docEl.style.fontSize = rem + &#39;px&#39;;
    flexible.rem = win.rem = rem;
&#125;
win.addEventListener(&#39;resize&#39;, refreshRem);
</code></pre>
<p><code>REM</code>布局也是目前多屏幕适配的最佳方式。默认情况下我们html标签的<code>font-size</code>为16px,我们利用媒体查询，设置在不同设备下的字体大小。</p>
<pre><code class="css">/* pc width &gt; 1100px */
html&#123; font-size: 100%;&#125;
body &#123;
    background-color: yellow;
    font-size: 1.5rem;
&#125;
/* ipad pro */
@media screen and (max-width: 1024px) &#123;
    body &#123;
      background-color: #FF00FF;
      font-size: 1.4rem;
    &#125;
&#125;
/* ipad */
@media screen and (max-width: 768px) &#123;
    body &#123;
      background-color: green;
      font-size: 1.3rem;
    &#125;
&#125;
/* iphone6 7 8 plus */
@media screen and (max-width: 414px) &#123;
    body &#123;
      background-color: blue;
      font-size: 1.25rem;
    &#125;
&#125;
/* iphoneX */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123;
    body &#123;
      background-color: #0FF000;
      font-size: 1.125rem;
    &#125;
&#125;
/* iphone6 7 8 */
@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123;
    body &#123;
      background-color: #0FF000;
      font-size: 1rem;
    &#125;
&#125;
/* iphone5 */
@media screen and (max-width: 320px) &#123;
    body &#123;
      background-color: #0FF000;
      font-size: 0.75rem;
    &#125;
&#125;
</code></pre>
<h4 id="6-视口单位"><a href="#6-视口单位" class="headerlink" title="6.视口单位"></a>6.视口单位</h4><p><code>css3</code>中引入了一个新的单位<code>vw/vh</code>，与视图窗口有关，<code>vw</code>表示相对于视图窗口的宽度，<code>vh</code>表示相对于视图窗口高度，除了<code>vw</code>和<code>vh</code>外，还有<code>vmin</code>和<code>vmax</code>两个相关的单位。各个单位具体的含义如下：</p>
<table>
<thead>
<tr>
<th align="center">单位</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vw</td>
<td align="center">相对于视窗的宽度，1vw 等于视口宽度的1%，即视窗宽度是100vw</td>
</tr>
<tr>
<td align="center">vh</td>
<td align="center">相对于视窗的高度，1vh 等于视口高度的1%，即视窗高度是100vh</td>
</tr>
<tr>
<td align="center">vmin</td>
<td align="center">vw和vh中的较小值</td>
</tr>
<tr>
<td align="center">vmax</td>
<td align="center">vw和vh中的较大值</td>
</tr>
</tbody></table>
<p><img src="/2022/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20221213142123454.png"></p>
<p>用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况）。例如，在桌面端浏览器视口尺寸为650px，那么 1vw &#x3D; 650 * 1% &#x3D; 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。</p>
<p>那么vw或者vh很类似百分比单位。vw和%的区别为：</p>
<table>
<thead>
<tr>
<th align="center">单位</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%</td>
<td align="center">大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</td>
</tr>
<tr>
<td align="center">vw&#x2F;vh</td>
<td align="center">相对于视窗的尺寸</td>
</tr>
</tbody></table>
<p>从对比中我们可以发现，<code>vw</code>单位与百分比类似，单确有区别，前面我们介绍了百分比单位的换算困难，这里的<code>vw</code>更像”理想的百分比单位”。任意层级元素，在使用<code>vw</code>单位的情况下，1vw都等于视图宽度的百分之一。</p>
<p>使用视口单位来实现响应式有两种做法：</p>
<h5 id="1-仅使用vw作为CSS单位"><a href="#1-仅使用vw作为CSS单位" class="headerlink" title="1.仅使用vw作为CSS单位"></a>1.仅使用vw作为CSS单位</h5><ul>
<li><p>对于设计稿的尺寸转换为为单位，我们使用<code>Sass</code>函数编译</p>
<pre><code class="css">//iPhone 6尺寸作为设计稿基准
$vm_base: 375; 
@function vw($px) &#123;
    @return ($px / 375) * 100vw;
&#125;
</code></pre>
</li>
<li><p>无论是文本还是布局宽度、间距等都使用<code>vw</code>作为单位</p>
<pre><code class="css">.mod_nav &#123;
    background-color: #fff;
    &amp;_list &#123;
        display: flex;
        padding: vm(15) vm(10) vm(10); // 内间距
        &amp;_item &#123;
            flex: 1;
            text-align: center;
            font-size: vm(10); // 字体大小
            &amp;_logo &#123;
                display: block;
                margin: 0 auto;
                width: vm(40); // 宽度
                height: vm(40); // 高度
                img &#123;
                    display: block;
                    margin: 0 auto;
                    max-width: 100%;
                &#125;
            &#125;
            &amp;_name &#123;
                margin-top: vm(2);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>1物理像素线（也就是普通屏幕下1px,高清屏幕下0.5px的情况）采用<code>transform</code>属性<code>scale</code>实现</p>
<pre><code class="css">.mod_grid &#123;
    position: relative;
    &amp;::after &#123;
        // 实现1物理像素的下边框线
        content: &#39;&#39;;
        position: absolute;
        z-index: 1;
        pointer-events: none;
        background-color: #ddd;
        height: 1px;
        left: 0;
        right: 0;
        top: 0;
        @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123;
            -webkit-transform: scaleY(0.5);
            -webkit-transform-origin: 50% 0%;
        &#125;
    &#125;
    ...
&#125;
</code></pre>
</li>
<li><p>对于需要保持宽高比的图，应该用<code>padding-top</code>实现</p>
<pre><code class="css">.mod_banner &#123;
    position: relative;
    padding-top: percentage(100/700); // 使用padding-top
    height: 0;
    overflow: hidden;
    img &#123;
        width: 100%;
        height: auto;
        position: absolute;
        left: 0;
        top: 0; 
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h5 id="2-搭配vw和rem"><a href="#2-搭配vw和rem" class="headerlink" title="2.搭配vw和rem"></a>2.搭配vw和rem</h5><p>虽然采用<code>vw</code>适配后的页面效果很好，但是它是利用视口单位实现的布局，依赖视口大小而自动缩放，无论视口过大还是过小，它也随着时候过大或者过小，失去了最大最小宽度的限制，此时我们可以结合<code>rem</code>来实现布局</p>
<ul>
<li><p>给根元素大小设置随着视口变化而变化的<code>vw</code>单位，这样就可以实现动态改变其大小</p>
</li>
<li><p>限制根元素字体大小的最大最小值，配合<code>body</code>加上最大宽度和最小宽度</p>
<pre><code class="scss">// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推
$vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值
@function rem($px) &#123;
     @return ($px / $vm_fontsize ) * 1rem;
&#125;
// 根元素大小使用 vw 单位
$vm_design: 750;
html &#123;
    font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; 
    // 同时，通过Media Queries 限制根元素最大最小值
    @media screen and (max-width: 320px) &#123;
        font-size: 64px;
    &#125;
    @media screen and (min-width: 540px) &#123;
        font-size: 108px;
    &#125;
&#125;
// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小
body &#123;
    max-width: 540px;
    min-width: 320px;
&#125;
</code></pre>
</li>
</ul>
<h4 id="7-图片响应式"><a href="#7-图片响应式" class="headerlink" title="7.图片响应式"></a>7.图片响应式</h4><p>这里的图片响应式包括两个方面，一个就是大小自适应，这样能够保证图片在不同的屏幕分辨率下出现压缩、拉伸的情况；一个就是根据不同的屏幕分辨率和设备像素比来尽可能选择高分辨率的图片，也就是当在小屏幕上不需要高清图或大图，这样我们用小图代替，就可以减少网络带宽了。</p>
<h5 id="1-使用max-width（图片自适应）"><a href="#1-使用max-width（图片自适应）" class="headerlink" title="1.使用max-width（图片自适应）:"></a>1.使用max-width（图片自适应）:</h5><p>图片自适应意思就是图片能随着容器的大小进行缩放，可以采用如下代码：</p>
<pre><code class="css">img &#123;
    display: inline-block;
    max-width: 100%;
    height: auto;
&#125;
</code></pre>
<p><code>inline-block</code> 元素相对于它周围的内容以内联形式呈现，但与内联不同的是，这种情况下我们可以设置宽度和高度。 <code>max-width</code>保证了图片能够随着容器的进行等宽扩充（即保证所有图片最大显示为其自身的 100%。此时，如果包含图片的元素比图片固有宽度小，图片会缩放占满最大可用空间），而<code>height</code>为<code>auto</code>可以保证图片进行等比缩放而不至于失真。如果是背景图片的话要灵活运用<code>background-size</code>属性。</p>
<p>那么为什么不能用<code>width：100%</code>呢？因为这条规则会导致它显示得跟它的容器一样宽。在容器比图片宽得多的情况下，图片会被无谓地拉伸。</p>
<h5 id="2-使用srcset"><a href="#2-使用srcset" class="headerlink" title="2.使用srcset"></a>2.使用srcset</h5><pre><code class="ini">&lt;img srcset=&quot;photo_w350.jpg 1x, photo_w640.jpg 2x&quot; src=&quot;photo_w350.jpg&quot; alt=&quot;&quot;&gt;
</code></pre>
<p>如果屏幕的dpi &#x3D; 1的话则加载1倍图，而dpi &#x3D; 2则加载2倍图，手机和mac基本上dpi都达到了2以上，这样子对于普通屏幕来说不会浪费流量，而对于视网膜屏来说又有高清的体验。</p>
<p>如果浏览器不支持<code>srcset</code>，则默认加载src里面的图片。</p>
<p>但是你会发现实际情况并不是如此，在Mac上的Chrome它会同时加载<code>srcset</code>里面的那张2x的，还会再去加载src里面的那张，加载两张图片。顺序是先把所有<code>srcset</code>里面的加载完了，再去加载src的。这个策略比较奇怪，它居然会加载两张图片，如果不写src，则不会加载两张，但是兼容性就没那么好。这个可能是因为浏览器认为，既然有<code>srcset</code>就不用写src了，如果写了src，用户可能是有用的。而使用<code>picture</code>就不会加载两张</p>
<h5 id="3-使用background-image"><a href="#3-使用background-image" class="headerlink" title="3.使用background-image"></a>3.使用background-image</h5><pre><code class="css">.banner&#123;
  background-image: url(/static/large.jpg);
&#125;

@media screen and (max-width: 767px)&#123;
  background-image: url(/static/small.jpg);
&#125;
</code></pre>
<h5 id="4-使用picture标签"><a href="#4-使用picture标签" class="headerlink" title="4.使用picture标签"></a>4.使用picture标签</h5><p><a href="https://link.juejin.im/?target=https://scottjehl.github.io/picturefill/">picturefill.min.js</a> ：解决IE等浏览器不支持 的问题</p>
<pre><code class="xml">&lt;picture&gt;
    &lt;source srcset=&quot;banner_w1000.jpg&quot; media=&quot;(min-width: 801px)&quot;&gt;
    &lt;source srcset=&quot;banner_w800.jpg&quot; media=&quot;(max-width: 800px)&quot;&gt;
    &lt;img src=&quot;banner_w800.jpg&quot; alt=&quot;&quot;&gt;
&lt;/picture&gt;

&lt;!-- picturefill.min.js 解决IE等浏览器不支持 &lt;picture&gt; 的问题 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/vendor/picturefill.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><code>picture</code>必须要写img标签，否则无法显示，对<code>pictur</code>e的操作最后都是在img上面，例如onload事件是在img标签触发的，<code>picture</code>和<code>source</code>是不会进行layout的，它们的宽和高都是0。</p>
<p>另外使用<code>source</code>，还可以对图片格式做一些兼容处理：</p>
<pre><code class="ini">&lt;picture&gt;
    &lt;source type=&quot;image/webp&quot; srcset=&quot;banner.webp&quot;&gt;
    &lt;img src=&quot;banner.jpg&quot; alt=&quot;&quot;&gt;
&lt;/picture&gt;
</code></pre>
<p><strong>总结</strong>：响应式布局的实现可以通过媒体查询+<code>px</code>,媒体查询+百分比，媒体查询+<code>rem</code>+<code>js</code>,<code>vm/vh</code>,<code>vm/vh</code> +<code>rem</code>这几种方式来实现。但每一种方式都是有缺点的，媒体查询需要选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配，另外用户体验也不友好，布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。通过百分比来适配首先是计算麻烦，第二各个属性中如果使用百分比，其相对的元素的属性并不是唯一的，这样就造成我们使用百分比单位容易使布局问题变得复杂。通过采用<code>rem</code>单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得<code>CSS</code>与<code>JS</code> 耦合了在一起。通过利用纯<code>css</code>视口单位实现适配的页面，是既能解决响应式断层问题，又能解决脚本依赖的问题的，但是兼容性还没有完全能结构接受。</p>
<h3 id="四、响应式布局的成型方案"><a href="#四、响应式布局的成型方案" class="headerlink" title="四、响应式布局的成型方案"></a>四、响应式布局的成型方案</h3><p>现在的css，UI框架等都已经考虑到了适配不同屏幕分辨率的问题，实际项目中我们可以直接使用这些新特性和框架来实现响应式布局。可以有以下选择方案：</p>
<ul>
<li>利用上面的方法自己来实现，比如CSS3 Media Query,rem，vw等</li>
<li>Flex弹性布局，兼容性较差</li>
<li>Grid网格布局，兼容性较差</li>
<li>Columns栅格系统，往往需要依赖某个UI库，如Bootstrap</li>
</ul>
<h3 id="五、响应式布局的要点"><a href="#五、响应式布局的要点" class="headerlink" title="五、响应式布局的要点"></a>五、响应式布局的要点</h3><p>在实际项目中，我们可能需要综合上面的方案，比如用<code>rem</code>来做字体的适配，用<code>srcset</code>来做图片的响应式，宽度可以用<code>rem</code>，<code>flex</code>，栅格系统等来实现响应式，然后可能还需要利用媒体查询来作为响应式布局的基础，因此综合上面的实现方案，项目中实现响应式布局需要注意下面几点：</p>
<ul>
<li>设置viewport</li>
<li>媒体查询</li>
<li>字体的适配（字体单位）</li>
<li>百分比布局</li>
<li>图片的适配（图片的响应式）</li>
<li>结合flex，grid，BFC，栅格系统等已经成型的方案</li>
</ul>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[响应式设计]: 	“<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903814332432397">https://juejin.cn/post/6844903814332432397</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/" rel="tag">响应式</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何设计一个组件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/09/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/"
    >如何设计一个组件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/09/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/" class="article-date">
  <time datetime="2022-12-09T02:06:22.000Z" itemprop="datePublished">2022-12-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/">如何设计一个组件</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="如何设计一个组件"><a href="#如何设计一个组件" class="headerlink" title="如何设计一个组件"></a>如何设计一个组件</h1><blockquote>
<p>在开发过程中，我们经常会遇到现有组件库无法满足需求，需要自己设计和实现组件的情况。那么，如何才能设计一个既满足产品需求，又易于开发人员使用的组件呢？本文就以一个级联组件的设计为例，探讨一下如何设计一个优质组件。</p>
</blockquote>
<h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>开发这个组件的原因是来自工作中遇到的一个需求。</p>
<p>产品提出的业务需求是实现一个地区的级联选择，并且应设计师要求，不能使用 Ant Design 的Cascader 级联选择，因此需要自己实现一个级联选择。</p>
<p>通常需要从 4 个角度对需求进行分析：</p>
<ol>
<li>业务需求角度</li>
<li>UI 设计角度</li>
<li>开发人员角度</li>
<li>与其他组件配合角度</li>
</ol>
<h4 id="业务需求角度"><a href="#业务需求角度" class="headerlink" title="业务需求角度"></a>业务需求角度</h4><p>在拿到一个需求之后，我们不应当直接考虑如何实现，而要先思考一下，这个需求是不是真正的需求。或者说，这个需求背后，是否还有更加基础和核心的需求。</p>
<p>现在，我们拿到了一个<strong>地区级联选择</strong>的需求，那么我们应该<strong>仅仅实现</strong>地区级联选择吗？我认为不是的，今天我们拿到的是地区选择的需求，明天就可能变成职业选择。</p>
<p>因此，我们实际需要实现的，应该是一个支持<strong>N 级</strong>的级联选择框。</p>
<h4 id="UI-设计角度"><a href="#UI-设计角度" class="headerlink" title="UI 设计角度"></a>UI 设计角度</h4><p>既然已经确定了要实现 N 级级联选择框，就需要考虑其在各个屏幕尺寸的兼容情况，于是我在组件中引入了 Grid 栅格 。并默认设置了 3 级级联的样式，同时为使用者提供了相应的配置选项，如下：</p>
<pre><code class="yaml">&lt;Cascade
  rowProps=&#123;&#123;
    gutter: 10,
  &#125;&#125;
  colProps=&#123;&#123;
    xs: 24,
    sm: 24,
    md: 8,
    lg: 8,
    xl: 8,
  &#125;&#125;
/&gt;
</code></pre>
<h4 id="开发人员角度"><a href="#开发人员角度" class="headerlink" title="开发人员角度"></a>开发人员角度</h4><p>我们开发的组件，不止会被我们的团队成员使用，甚至会开源给其他开发者使用。那么，提供给开发者更好的体验就尤为重要。</p>
<p>为了节省开发人员的学习成本，我们可以按照以下思路考虑：</p>
<ol>
<li>在满足基本需求的前提下，提供尽量少的 API。</li>
<li>为 API 选项提供尽量少的配置项。</li>
<li>为代码，特别是 API 提供尽量好的文档或注释。</li>
</ol>
<p>定义的 <code>Cascade</code> 组件 <code>Props</code> 示例如下：</p>
<pre><code class="less">interface Props&lt;T&gt; &#123;
  cascadeKeys?: CascadeKeys; // 自定义 dataSource 中 value label children 的字段
  value?: T[]; // 指定当前选中的条目
  onChange?: (value: T[], level: number) =&gt; void; // 选中选项时，调用此函数
  rowProps?: RowProps; // 行排列方式，可参考https://ant.design/components/grid-cn/
  colProps?: ColProps; // 列排列方式
  loading?: boolean[]; // 选择框loading装填
  dataSource?: T[] | CascadeData&lt;T&gt; | T[][]; // 可选项数据源
&#125;
</code></pre>
<p>可以看到， <code>Props</code> 中只有 <code>dataSource</code> 是必须的。也就是说，如果你对配置项并不了解，组件也只需要最简单的配置，就可以正常工作了，例如：</p>
<pre><code class="ini">&lt;Cascade
  dataSource=&#123;pcaCascadeData&#125;
/&gt;
</code></pre>
<ol>
<li><p>在使用 TypeScript 时，还需要特别考虑类型匹配的问题。例如可以在使用组件时，传入一个类型，并且在 <code>onChange</code> 事件中如果使用了其他类型， TypeScript 检查就会提示错误，如下面例子中的 <code>PCAItem</code> 。</p>
<pre><code class="ini">&lt;Cascade&lt;PCAItem&gt;
  dataSource=&#123;pcaCascadeData&#125;
  cascadeKeys=&#123;pcaCascadeKeys&#125;
  onChange=&#123;async (value: PCAItem[], level: number) =&gt; &#123;
    setPCAData(value);
    setPCAIndex(level);
  &#125;&#125;
/&gt;
</code></pre>
</li>
<li><p>对于级联组件，我们还需要考虑 dataSource 的数据来源可能有两种。</p>
<ul>
<li>组件初始化时，就传入了所有的级联数据，例如 省&#x2F;地&#x2F;县&#x2F;乡层级数据 。对应 Demo 中的“同步级联数据”，以及 <code>Props</code> 中 <code>dataSource</code> 类型定义的 <code>CascadeData&lt;T&gt; | T[][]</code> 。<ul>
<li>在某些场景下，虽然没有级联选择框存在，但也需要处理树形数据，包括数据的查询和校验等功能，因此将该方法封装到 <code>CascadeData</code> 类中。</li>
<li>考虑到树的数据量可能非常庞大，如果在每次选择时都在树中搜索效率较低。因此设计成在组件创建时，直接遍历树中的所有节点，然后将每个层级所有节点的数据都存储在相应的 <code>Map</code> 中，之后就能很方便地查询数据。</li>
<li>虽然在组件初始化时遍历所有节点比较耗时，但考虑到用户从进入页面到操作组件有一定时间差，因此我认为这个问题可以忽略。</li>
<li>基于以上考虑，你在 <code>Props</code> 中 <code>dataSource</code> 类型中看到的 <code>CascadeData&lt;T&gt;</code> ，就表示直接传入了一个 <code>new CascadeData(treeData)</code> 。而<code>T[][]</code>就表示直接传入树形数据，由组件内部进行 <code>new CascadeData(treeData) </code> 。</li>
</ul>
</li>
<li>组件初始化时，只传入了第一级的选项，之后每级的选项通过前一级所选择的参数，从服务端获取。对应 Demo 中的“异步级联数据”，对应 <code>dataSource</code> 类型中的 <code>T[]</code> 。<ul>
<li>组件初始化时，只传入第一级的数据，其他级别传入空数组，如：<code>[[&#123;&quot;code&quot;:110000,&quot;name&quot;:&quot;北京市&quot;&#125;],[],[]]</code>，组件会渲染出 3 层级联选项。</li>
<li>当进行选择时，需要使用者通过 <code>onChange</code> 事件自行更新下一级的数据。也就是说，组件完全放弃了对数据的控制。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="与其他组件配合角度"><a href="#与其他组件配合角度" class="headerlink" title="与其他组件配合角度"></a>与其他组件配合角度</h4><p>由于该组件需要与 Ant Design 其他组件配合使用，如前面讨论过的 UI 部分，该组件就结合了 Grid 栅格 组件。既保证了该组件在各屏幕宽度下正常显示，又保证了与其他组件的显示一致。</p>
<p>除此之外，还需要考虑与 Form 表单 组件的配合，特别是兼容表单校验功能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过一个级联组件的设计案例，探讨了如何从四个角度分析，进而设计一个优秀的组件。这 4 个角度分别是：</p>
<ol>
<li>业务需求角度</li>
<li>UI 设计角度</li>
<li>开发人员角度</li>
<li>与其他组件配合角度</li>
</ol>
<p>我认为很多时候组件的设计并没有最优解，总是需要根据需求在各种方案中取舍。但只要按照本文提到的 4 个角度进行分析，就能设计出优秀的组件。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/" rel="tag">组件设计</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-react-native环境搭建"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"
    >react-native环境搭建</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="article-date">
  <time datetime="2022-12-08T00:29:43.000Z" itemprop="datePublished">2022-12-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/">工程技术</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">react-native环境搭建</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="react-native环境搭建（Mac-M1）"><a href="#react-native环境搭建（Mac-M1）" class="headerlink" title="react-native环境搭建（Mac M1）"></a>react-native环境搭建（Mac M1）</h1><h3 id="一、本机安装环境"><a href="#一、本机安装环境" class="headerlink" title="一、本机安装环境"></a>一、本机安装环境</h3><p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221207175048319.png"></p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221207175217956.png"></p>
<p>安装官方的说法，需要具备的环境条件</p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221207175323650.png"></p>
<p>node和npm的安装就不说了</p>
<p>下载yarn：</p>
<pre><code class="ini">npm install -g yarn
</code></pre>
<p>react-native：</p>
<pre><code class="ini">yarn add react-native --exact
</code></pre>
<pre><code class="ini">//Mac m1 安装 Homebrew
/bin/bash -c &quot;$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)&quot;

环境变量：
 echo &#39;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#39; &gt;&gt; /Users/mengfeng/.zprofile
   eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;
</code></pre>
<blockquote>
<p>建议同学们早上去下载（网好），当然，不可避免的还是要出现一系列的问题，我们根据错误提示去查询相应的解决方案就行（因为每个同学的问题都不太一样）</p>
</blockquote>
<p>下载watchman：</p>
<pre><code class="ini">brew install watchman
</code></pre>
<p>下载pod（cocoapods）：</p>
<pre><code class="ini">brew install cocoapods
</code></pre>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208082020782.png"></p>
<p>到目前为止，我们已经安装了 Node、Homebrew、watchman、cocoapods</p>
<p>下面我们来安装xcode</p>
<h3 id="二、xcode安装模拟器"><a href="#二、xcode安装模拟器" class="headerlink" title="二、xcode安装模拟器"></a>二、xcode安装模拟器</h3><p>我们在app store下载就可以，当然版本历史记录可以查看以前的xcode版本</p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208082606954.png"></p>
<p>当我们创建了一个项目，点击小三角，模拟器完美运行</p>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208083302861.png"></p>
<h3 id="三、react-native创建项目"><a href="#三、react-native创建项目" class="headerlink" title="三、react-native创建项目"></a>三、react-native创建项目</h3><p>创建项目</p>
<pre><code class="ini">npx react-native init testapp
</code></pre>
<blockquote>
<p>出现报错</p>
</blockquote>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208084024802.png"></p>
<blockquote>
<p>解决以上问题的第一个error</p>
<p>报了一个警告，大概意思是不安全的写权限，目录是 &#x2F;opt&#x2F;homebrew&#x2F;bin<br>于是我们把这个目录的写权限去掉</p>
<pre><code class="ini">sudo chmod -R go-w /opt/homebrew/bin
sudo chmod -R go-w /opt/homebrew
</code></pre>
</blockquote>
<p><img src="/2022/12/08/react-native%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20221208085035978.png"></p>
<blockquote>
<p>解决第一个问题</p>
<p>我们需要下载ruby 2.7.5并将ruby版本指向2.7.5</p>
</blockquote>
<p>如果你有条件的话请试试<a target="_blank" rel="noopener" href="https://www.rubyonmac.dev/?utm_campaign=install-ruby-guide">macruby</a>109美元终身，ruby不太友好</p>
<p>下篇文章继续</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[Mac下的环境搭建]: 	“<a target="_blank" rel="noopener" href="https://juejin.cn/post/7119039164074426375">https://juejin.cn/post/7119039164074426375</a> “<br>[rbenv下载缓慢解决]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/shine_a/article/details/103927374">https://blog.csdn.net/shine_a/article/details/103927374</a> “<br>[mac下载rbenv]: 	“<a target="_blank" rel="noopener" href="https://juejin.cn/post/6899650892313100302">https://juejin.cn/post/6899650892313100302</a> “<br>[CocoaPods安装方法]: 	“<a target="_blank" rel="noopener" href="https://blog.csdn.net/Wulitc/article/details/115682720&quot;">https://blog.csdn.net/Wulitc/article/details/115682720&quot;</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-c4d及其oc的安装和初始化设置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/"
    >c4d及其oc的安装和初始化设置</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/" class="article-date">
  <time datetime="2022-12-06T08:06:49.000Z" itemprop="datePublished">2022-12-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3D/">Web3D</a> / <a class="article-category-link" href="/categories/Web3D/C4d/">C4d</a> / <a class="article-category-link" href="/categories/Web3D/C4d/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/">c4d及其oc的安装和初始化设置</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="C4d-amp-amp-OC"><a href="#C4d-amp-amp-OC" class="headerlink" title="C4d &amp;&amp; OC"></a>C4d &amp;&amp; OC</h1><p>我们这篇文章是基于Mac Book Pro M1 Max芯片条件下运行的</p>
<p>（建议玩三维oc的同学还是再拥有一台windows比较好）</p>
<blockquote>
<p>今天我们来学习另一款三维软件C4d，我们上面的文章介绍了blender，也说了C4d和blender的区别。</p>
<p>C4d触及到了版权问题和付费服务，但是还是有许多人热衷于C4d和我们大名鼎鼎的oc渲染器。</p>
<p>blender（开源免费功能全）</p>
<p>下面我们就来讲讲C4d和oc的安装初始化设置</p>
</blockquote>
<p>我们先来看一下oc渲染器输出的效果</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/WechatIMG113.jpeg"></p>
<h3 id="一、软件的安装"><a href="#一、软件的安装" class="headerlink" title="一、软件的安装"></a>一、软件的安装</h3><blockquote>
<p>C4D软件下载方式二选一<br>网页不限速下载地址01：<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/42f77525-e323-4343-8b75-947b896f9b99#">https://www.yuque.com/docs/share/42f77525-e323-4343-8b75-947b896f9b99?#</a></p>
<p>百度网盘下载地址02：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/14HfYqsok_VNNTpqgM2lisg">https://pan.baidu.com/s/14HfYqsok_VNNTpqgM2lisg</a><br>提取码：ocye</p>
</blockquote>
<p>不要下载到有中文目录的地方</p>
<p>下载完成之后里面有安装的教学视频，我简单的表述一下</p>
<p>1.点进链接，选择我们需要的版本下载即可</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206150700879.png"></p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206150832632.png"></p>
<p>2.安装软件</p>
<p>打开之后，双击安装Cinema 4D Installer即可（按照引导安装，安装完要打开一次）</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/wps1.jpg"></p>
<p>按Quit即可</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/wps2.jpg"></p>
<h3 id="二、软件的汉化"><a href="#二、软件的汉化" class="headerlink" title="二、软件的汉化"></a>二、软件的汉化</h3><p>将汉化补丁拖进C4的界面就可以了（记得拖动的时候需要按住shift）</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/wps3.jpg"></p>
<p>如果需要更新软件</p>
<p>将Chinese_26010_202204041.c4dupdate拖到界面更新即可</p>
<p>点击进入软件</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206151636591.png"></p>
<p>软件安装及其汉化完成</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206151746346.png"></p>
<h3 id="三、oc渲染器的下载和安装"><a href="#三、oc渲染器的下载和安装" class="headerlink" title="三、oc渲染器的下载和安装"></a>三、oc渲染器的下载和安装</h3><p>进入这一步我们首先需要科学上网（你懂的）</p>
<p>1.账户注册</p>
<p>我们先要注册一个<a target="_blank" rel="noopener" href="https://home.otoy.com/render/octane-render/">oc官网</a>的账户</p>
<p>这个我们根据提示填写信息和邮箱验证就可以了</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206152135014.png"></p>
<p>2.下载oc（正版的哈，需要花钱的）</p>
<p>我们点击Downloads，进入下载界面，我们可以根据我们所使用的软件和系统来选择下载我们的软件</p>
<p>（目前好像M1可以试用一年）如果不行需要你登录，那你就交钱吧哈哈哈</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206152728362.png"></p>
<p>下载之后解压文件</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206153213703.png"></p>
<p>3.安装oc</p>
<p>mac用户使用这个建议使用一个稳定的软件版本，要不然会经常崩溃</p>
<p>这个oc是个插件，我们以后安装插件差不多都是这个流程</p>
<p>找到我们的安装目录，如果里面没有plugins就新建一个</p>
<p>将我们解压好的oc文件夹复制到我们的plugins里面</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206153420489.png"></p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206153443318.png"></p>
<p>oc的文件夹里面有适配的c4d版本</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206153650012.png"></p>
<p>重新打开我们的c4d软件，我们就可以看见oc了</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206153951543.png"></p>
<h3 id="四、oc渲染器的订阅流程"><a href="#四、oc渲染器的订阅流程" class="headerlink" title="四、oc渲染器的订阅流程"></a>四、oc渲染器的订阅流程</h3><p>登陆进我们的官网，点击导航栏的shop，我们就看到了购买界面，有按年来算的，和按月来算，如果你是要长期使用oc</p>
<p>那么年度订阅那肯定是便宜的（一个月现在涨价了，以前是150多，现在170多）可以使用支付宝支付</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206154143787.png"></p>
<p>然后购买完成，我们返回我们的软件界面，登陆账号，就可以使用oc了</p>
<p>有条件的再配个屏幕吧，这个太小了</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206155104428.png"></p>
<h3 id="五、oc渲染器的初始化设置"><a href="#五、oc渲染器的初始化设置" class="headerlink" title="五、oc渲染器的初始化设置"></a>五、oc渲染器的初始化设置</h3><p>实时渲染的设置就这些，其他的可以看<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1944y1Q7zY/?spm_id_from=333.999.0.0&amp;vd_source=e6ad490de8a011714c955dbf8a265e32">这里</a></p>
<p>目前新版的mac下的oc没有汉化补丁，所以看起来会不习惯一些</p>
<p><img src="/2022/12/06/c4d%E5%8F%8A%E5%85%B6oc%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE/image-20221206160326384.png"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[新版oc设置]: 	“<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1944y1Q7zY/?spm_id_from=333.999.0.0&amp;vd_source=e6ad490de8a011714c955dbf8a265e32&quot;">https://www.bilibili.com/video/BV1944y1Q7zY/?spm_id_from=333.999.0.0&amp;vd_source=e6ad490de8a011714c955dbf8a265e32&quot;</a><br>[oc官网]: 	“<a target="_blank" rel="noopener" href="https://home.otoy.com/render/octane-render/&quot;">https://home.otoy.com/render/octane-render/&quot;</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c4d/" rel="tag">c4d</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oc/" rel="tag">oc</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-blender基本操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"
    >blender基本操作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2022-12-05T08:36:06.000Z" itemprop="datePublished">2022-12-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3D/">Web3D</a> / <a class="article-category-link" href="/categories/Web3D/blender/">blender</a> / <a class="article-category-link" href="/categories/Web3D/blender/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">blender基本操作</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Blender基本操作"><a href="#Blender基本操作" class="headerlink" title="Blender基本操作"></a>Blender基本操作</h1><blockquote>
<p>虽然我们是程序员一枚，但是，既然学了3D那么我们就要拓展我们的技能</p>
<p>那么这篇文章就来讲讲这款免费的3维软件<a target="_blank" rel="noopener" href="https://www.blender.org/">Blender</a>（英文版）</p>
<p>你要问我C4d和Blender哪个好（Blender是免费的，不要钱）要是不差钱也可以玩玩oc渲染器（比较香）</p>
<p>具体操作还得看视频，我今天就总结一些快捷键</p>
</blockquote>
<h3 id="一、安装软件"><a href="#一、安装软件" class="headerlink" title="一、安装软件"></a>一、安装软件</h3><p>下载—安装</p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205093244288.png" alt="image-20221205093244288"></p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205094355133.png"></p>
<h3 id="二、更改配置"><a href="#二、更改配置" class="headerlink" title="二、更改配置"></a>二、更改配置</h3><p>更改页面语言，如果需要更改为简体中文的话（如果找不到配置了，改为简体中文后就方便了）</p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205094539463.png"></p>
<h3 id="三、界面快捷键"><a href="#三、界面快捷键" class="headerlink" title="三、界面快捷键"></a>三、界面快捷键</h3><p>这些快捷键有点多，加油（当然，你也可以根据你的习惯去修改你的快捷键）</p>
<p>具体步骤如图所示：</p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205094948395.png"></p>
<blockquote>
<p>我建议，在你选择直接使用快捷键的时候，尽量先去了解界面，快捷键是提高工作效率的首选，但初学者还是要先熟悉软件的界面操作，再逐步的去熟悉我们大量的快捷键来提高我们的工作效率。</p>
<p>在一些情况下，快捷键却会让你行云流水的操作变得生硬</p>
</blockquote>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205094730873.png"></p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205101434727.png"></p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205104621343.png"></p>
<p><img src="/2022/12/05/blender%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20221205142035840.png"></p>
<blockquote>
<p>其他快捷键我们都可以去视频练习哦</p>
<p>最后，一款双语切换插件给你们</p>
</blockquote>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[blender基础操作]: 	“<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=prQj0xVwMeo&amp;list=PL3bztmH9zKvv4sjPb6PJyLgULvQYJ8e0f&amp;index=4&quot;">https://www.youtube.com/watch?v=prQj0xVwMeo&amp;list=PL3bztmH9zKvv4sjPb6PJyLgULvQYJ8e0f&amp;index=4&quot;</a><br>[双语切换]: 	“<a target="_blank" rel="noopener" href="https://github.com/Mister-Kin/ToggleLanguage/releases/tag/v1.1&quot;">https://github.com/Mister-Kin/ToggleLanguage/releases/tag/v1.1&quot;</a><br>[双语切换]: 	“<a target="_blank" rel="noopener" href="https://mister-kin.github.io/manuals/toggle-language/">https://mister-kin.github.io/manuals/toggle-language/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blender/" rel="tag">blender</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-playcanvas初级"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/"
    >playcanvas初级</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/" class="article-date">
  <time datetime="2022-12-04T13:01:02.000Z" itemprop="datePublished">2022-12-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3D/">Web3D</a> / <a class="article-category-link" href="/categories/Web3D/playcanvas/">playcanvas</a> / <a class="article-category-link" href="/categories/Web3D/playcanvas/playcanvas%E5%88%9D%E7%BA%A7/">playcanvas初级</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="playcanvas初级"><a href="#playcanvas初级" class="headerlink" title="playcanvas初级"></a>playcanvas初级</h1><blockquote>
<p>我们在开始本文章之前，推荐大家一个小工具，方便我们在油管上看英文视频</p>
<p>YouTube™ 双字幕</p>
<p>我们通过YouTube上<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=fXc-JjH2nNo&list=PLGmYIROty-5ZX-a88X8ztUeYSPeuBj7rG">Daniel Wood</a>博主的playcanvas视频来浅入一下（看着文章来梳理视频内容食用更佳哦！）</p>
</blockquote>
<h3 id="start：工具下载"><a href="#start：工具下载" class="headerlink" title="start：工具下载"></a>start：工具下载</h3><blockquote>
<p>YouTube™ 双字幕可以帮助我们添加双语字幕</p>
<p>安装步骤：谷歌浏览器-&gt;设置-&gt;扩展程序-&gt;打开应用商店-&gt;查找-&gt;安装</p>
</blockquote>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204161502349.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204161617072.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204161720108.png"></p>
<blockquote>
<p>下载完成之后，我们在扩展程序图标上就可以使用了，如果不起效果，请重新打开浏览器</p>
</blockquote>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204162049453.png"></p>
<h3 id="一、第一课（Getting-started-with-PlayCanvas）"><a href="#一、第一课（Getting-started-with-PlayCanvas）" class="headerlink" title="一、第一课（Getting started with PlayCanvas）"></a>一、第一课（Getting started with PlayCanvas）</h3><blockquote>
<p>我们第一课先来简单使用一下我们的可视化平台</p>
</blockquote>
<p>第一节课主要是熟悉我们的可视化面板，上一篇<a href="https://mengfeng.github.io/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/">playcanvas初识</a>有讲解，如果感兴趣，我们还是可以看看我们的第一课的视频的</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204174020956.png"></p>
<h3 id="二、第二课（Entities-and-materials）"><a href="#二、第二课（Entities-and-materials）" class="headerlink" title="二、第二课（Entities and materials）"></a>二、第二课（Entities and materials）</h3><blockquote>
<p>实体和材质是什么？</p>
<p>实体就是我们编辑器里面的方块、平面等几何体</p>
<p>材质是我们实体需要结合的属性</p>
</blockquote>
<p>1.当我们创建材质资源的时候，我们可以将其分成一个组，方便我们以后去管理我们的材质</p>
<p>2.我们的贴图，那些属性，我建议先去看看Three.js的教程吧，或者有三维软件的使用基础也是容易理解的，如果不具备这些基础概念可以看看我之前的<a href="https://mengfeng.github.io/categories/">threejs</a>的文章</p>
<p>3.简单的赋予实体材质的步骤就是如下图（还是比较容易的）</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204175100109.png"></p>
<p>4.这节课视频主要讲的是贴图和材质和我们材质的一系列属性（不是api）</p>
<p>5.点击我们的Camera（摄像机）调节角度，点击界面右上角的Launch就可以渲染我们的画面了</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204180337214.png"></p>
<h3 id="三、第三课（Lighting）"><a href="#三、第三课（Lighting）" class="headerlink" title="三、第三课（Lighting）"></a>三、第三课（Lighting）</h3><blockquote>
<p>我们的灯光也是有3种，平行光、点光源、聚光灯</p>
<p>这节课除了讲解几种灯光的属性之外，也有灯光与阴影的关系</p>
</blockquote>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204181635026.png"></p>
<p>聚光灯效果，我们在右边的属性栏也可以去修改我们聚光灯的其他属性</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204183234836.png"></p>
<p>点光源效果（可以看成一个灯泡）</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204183435845.png"></p>
<h3 id="四、第四课（Skyboxes-in-PlayCanvas）"><a href="#四、第四课（Skyboxes-in-PlayCanvas）" class="headerlink" title="四、第四课（Skyboxes in PlayCanvas）"></a>四、第四课（Skyboxes in PlayCanvas）</h3><blockquote>
<p>主要展示如何添加天空贴图</p>
<p>我们的贴图就是从这里下载的，可以去试试</p>
<p>[贴图纹理]: 	“<a target="_blank" rel="noopener" href="http://www.humus.name/index.php?page=Textures">http://www.humus.name/index.php?page=Textures</a> “</p>
</blockquote>
<p>具体的步骤总结：</p>
<p>⚠️注意：还是看视频详细，这只是总结一下哈哈哈</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204184930487.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204185140511.png"></p>
<h3 id="五、第五课（Particle-systems-in-PlayCanvas）"><a href="#五、第五课（Particle-systems-in-PlayCanvas）" class="headerlink" title="五、第五课（Particle systems in PlayCanvas）"></a>五、第五课（Particle systems in PlayCanvas）</h3><blockquote>
<p>这节课的东西我比较喜欢，粒子系统（会生成粒子和粒子动画）</p>
</blockquote>
<p>具体的步骤总结：</p>
<p>这个比较简单，到了后面，这个会生成很多惊艳的动画效果</p>
<p>⚠️注意：这个属性比较多，认真看</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204185753349.png"></p>
<h3 id="六、第六课（Overview-of-scripts-in-PlayCanvas）"><a href="#六、第六课（Overview-of-scripts-in-PlayCanvas）" class="headerlink" title="六、第六课（Overview of scripts in PlayCanvas）"></a>六、第六课（Overview of scripts in PlayCanvas）</h3><blockquote>
<p>这节课没什么东西，就是讲解一下我们script资源文件的构造（给没有javaScript基础的同学讲的）</p>
<p>有基础的同学可以快速略过了</p>
</blockquote>
<p>具体的步骤总结：</p>
<p>主要是讲一下script资源的操作</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204190611547.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204190818807.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204191338719.png"></p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204191641346.png"></p>
<h3 id="七、第七课（Make-a-3D-object-move-with-code）"><a href="#七、第七课（Make-a-3D-object-move-with-code）" class="headerlink" title="七、第七课（Make a 3D object move with code）"></a>七、第七课（Make a 3D object move with code）</h3><blockquote>
<p>这节课开始就要编写js脚本文件了</p>
<p>通过我们下面的脚步编译，我们就可以渲染出方块渐行渐远的动画了</p>
<p>具体的API我们可以查询<a target="_blank" rel="noopener" href="https://developer.playcanvas.com/api/pc.Entity.html">文档</a>了</p>
</blockquote>
<pre><code class="javascript">//test.js
var Test = pc.createScript(&#39;test&#39;);
var Move = function(entity)&#123;
  this.entity = entity;
&#125;
// initialize code called once per entity
Test.prototype.initialize = function() &#123;
    
&#125;;

// update code called every frame
Test.prototype.update = function(dt) &#123;
    this.entity.translateLocal(-0.01,0,0);
&#125;;

// swap method called for script hot-reloading
// inherit your script state here
// Test.prototype.swap = function(old) &#123; &#125;;

// to learn more about script anatomy, please read:
// https://developer.playcanvas.com/en/user-manual/scripting/
</code></pre>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204192521888.png"></p>
<h3 id="八、第八课（Moving-objects-with-keyboard-input）"><a href="#八、第八课（Moving-objects-with-keyboard-input）" class="headerlink" title="八、第八课（Moving objects with keyboard input）"></a>八、第八课（Moving objects with keyboard input）</h3><blockquote>
<p>利用键盘的按键来控制我们实体的移动、旋转等</p>
<p>建议不要跟着视频的写法来练习，要自己去查文档，因为视频已经有点陈旧了</p>
<p>api都有所变化</p>
</blockquote>
<p>我们的脚本实现的是利用键盘的上下左右来控制实体的上下左右</p>
<pre><code class="javascript">//test.js
var Test = pc.createScript(&#39;test&#39;);
var keyboard = new pc.Keyboard(window);
var Move = function(entity)&#123;
  this.entity = entity;
&#125;
// initialize code called once per entity
Test.prototype.initialize = function() &#123;
    
&#125;;

// update code called every frame
Test.prototype.update = function(dt) &#123;
   if(keyboard.isPressed(pc.KEY_RIGHT))&#123;
       this.entity.translate(0.01,0,0);
   &#125;
    if(keyboard.isPressed(pc.KEY_LEFT))&#123;
       this.entity.translate(-0.01,0,0);
   &#125;
    if(keyboard.isPressed(pc.KEY_UP))&#123;
       this.entity.translate(0,0,-0.01);
   &#125;
    if(keyboard.isPressed(pc.KEY_DOWN))&#123;
       this.entity.translate(0,0,0.01);
   &#125;
&#125;;

// swap method called for script hot-reloading
// inherit your script state here
// Test.prototype.swap = function(old) &#123; &#125;;

// to learn more about script anatomy, please read:
// https://developer.playcanvas.com/en/user-manual/scripting/
</code></pre>
<h3 id="九、第九课（Rotating-objects-with-keyboard-input）"><a href="#九、第九课（Rotating-objects-with-keyboard-input）" class="headerlink" title="九、第九课（Rotating objects with keyboard input）"></a>九、第九课（Rotating objects with keyboard input）</h3><blockquote>
<p>这节课和上节课的内容差不多，就是利用键盘按键去控制实体的其他属性</p>
<p>教js零基础的同学一下变量的基础写法（可以快速略过了哈哈哈，还得扫一眼哈）</p>
</blockquote>
<h3 id="十、第十课（Rigid-Bodies-and-Collision-in-PlayCanvas）"><a href="#十、第十课（Rigid-Bodies-and-Collision-in-PlayCanvas）" class="headerlink" title="十、第十课（Rigid Bodies and Collision in PlayCanvas）"></a>十、第十课（Rigid Bodies and Collision in PlayCanvas）</h3><blockquote>
<p>PlayCanvas中的刚体和碰撞这节课的知识点还是可以的</p>
<p>大体是讲物体碰撞的属性和运动</p>
</blockquote>
<p>根据步骤可以实现碰撞</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204204506027.png"></p>
<h3 id="十一、第十一课（Adding-sound-to-your-game）"><a href="#十一、第十一课（Adding-sound-to-your-game）" class="headerlink" title="十一、第十一课（Adding sound to your game）"></a>十一、第十一课（Adding sound to your game）</h3><blockquote>
<p>我们的游戏进去是不是有背景音乐呀，这节课就是将背景音乐加载进来</p>
<p>Audio Listener可以简单的说像耳朵一样，可以听见附近的声音</p>
</blockquote>
<p>大体步骤如下，具体可以看视频了（还有许多细节）</p>
<p><img src="/2022/12/04/playcanvas%E5%88%9D%E7%BA%A7/image-20221204205445304.png"></p>
<h3 id="十二、第十二课（Controlling-audio-with-scripts）"><a href="#十二、第十二课（Controlling-audio-with-scripts）" class="headerlink" title="十二、第十二课（Controlling audio with scripts）"></a>十二、第十二课（Controlling audio with scripts）</h3><blockquote>
<p>这节课就是延续上面的，对于audio的属性讲解和脚本编写了，</p>
<p>这个任务交给你们了，写好评论，给你点大赞👍</p>
</blockquote>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[playcanvas初级教程]: 	“<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=fXc-JjH2nNo&amp;list=PLGmYIROty-5ZX-a88X8ztUeYSPeuBj7rG">https://www.youtube.com/watch?v=fXc-JjH2nNo&amp;list=PLGmYIROty-5ZX-a88X8ztUeYSPeuBj7rG</a> “<br>[playcanvas官网API]: 	“<a target="_blank" rel="noopener" href="https://developer.playcanvas.com/en/api/">https://developer.playcanvas.com/en/api/</a> “<br>[playcanvas中文]: 	“<a target="_blank" rel="noopener" href="https://developer.playcanvas.com/zh/">https://developer.playcanvas.com/zh/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/playcanvas/" rel="tag">playcanvas</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-playcanvas初识"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/"
    >playcanvas初识</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/" class="article-date">
  <time datetime="2022-12-03T08:31:14.000Z" itemprop="datePublished">2022-12-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3D/">Web3D</a> / <a class="article-category-link" href="/categories/Web3D/playcanvas/">playcanvas</a> / <a class="article-category-link" href="/categories/Web3D/playcanvas/playcanvas%E5%88%9D%E8%AF%86/">playcanvas初识</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="playcanvas（基于WebGL的游戏引擎）"><a href="#playcanvas（基于WebGL的游戏引擎）" class="headerlink" title="playcanvas（基于WebGL的游戏引擎）"></a>playcanvas（基于WebGL的游戏引擎）</h1><p>PlayCanvas 是一款使用 HTML5 和 WebGL 技术运行游戏以及其他 3D 内容的开源游戏引擎，PlayCanvas 以其独特的性能实现了在任何手机移动端和桌面浏览器端均可以流畅运行。</p>
<p>PlayCanvas 引擎是一款可以基于浏览器的用于制作游戏以及 3D 可视化的开源引擎。除此之外，还开发了<a target="_blank" rel="noopener" href="https://playcanvas.com/">PlayCanvas 开发平台</a>， 为用户提供了可视化编辑器，资源管理，代码编辑，代码托管以及发布等服务。</p>
<blockquote>
<p>目前中文的教程很少，所以英语好的同学可以去看一下国外的那些教程，但是还是有<a target="_blank" rel="noopener" href="https://developer.playcanvas.com/zh/">中文文档</a>的。</p>
</blockquote>
<p>可视化平台操作上倒是没什么难度，就是和正常的建模操作大同小异，一个可视化的一个操作平台，可以进一步的提高我们工作的效率吧。</p>
<h3 id="一、注册账户"><a href="#一、注册账户" class="headerlink" title="一、注册账户"></a>一、注册账户</h3><blockquote>
<p>注册账户的方式很简单，根据提示去注册就可以了</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203152809943.png"></p>
<h3 id="二、新建项目"><a href="#二、新建项目" class="headerlink" title="二、新建项目"></a>二、新建项目</h3><blockquote>
<p>1.我们点击NEW，即可创建新项目</p>
<p>2.点击我们的项目就可以进入项目界面</p>
<p>3.点击EDITOR就可以进入可视化操作平台，去操作我们的项目</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203153658606.png"></p>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203153755107.png"></p>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203152450815.png"></p>
<h3 id="三、导出项目"><a href="#三、导出项目" class="headerlink" title="三、导出项目"></a>三、导出项目</h3><blockquote>
<p>1.导出项目前，我们得先pulish</p>
<p>2.点击下载 .zip 包</p>
<p>3.将包用vsCode打开，运行index.html</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203155914469.png"></p>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203160109159.png"></p>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203160208211.png"></p>
<h3 id="四、其他界面菜单"><a href="#四、其他界面菜单" class="headerlink" title="四、其他界面菜单"></a>四、其他界面菜单</h3><p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203160737778.png"></p>
<h4 id="1-工具栏和菜单栏"><a href="#1-工具栏和菜单栏" class="headerlink" title="1.工具栏和菜单栏"></a>1.工具栏和菜单栏</h4><blockquote>
<p>点击 PLAYCANVAS 图标会显示所有的可用功能，可以使用这些功能编辑场景。如果找不到某个按钮或者快捷键，肯定是能在菜单里找到对应功能的。</p>
<p>工具栏提供快捷访问的常用功能，其中包含最重要的运行按钮。运行按钮会在一个独立的浏览器窗口中启动游戏并且加载当前的场景，可以立即开始游戏测试。可以从属性编辑栏中看到运行中游戏的实时参数变化。</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161229021.png"></p>
<h4 id="2-层级树"><a href="#2-层级树" class="headerlink" title="2.层级树"></a>2.层级树</h4><blockquote>
<p>场景是由层级结构的实体组成，场景层级树显示了当前整个场景的树形结构。一个场景永远包含一个根节点实体，位于层级树的最顶端。所有其他的实体都是由开发者逐步加入的。</p>
<p>层级树面板包含了场景中的全部实体，可以在其中快速定位实体，而不必在场景中搜寻。点击层级树上的实体将会选中它。</p>
<h2 id="创建和删除实体"><a href="#创建和删除实体" class="headerlink" title="创建和删除实体"></a>创建和删除实体</h2><p>当在层级树中选中一个实体时，用户可以创建一个新的实体或者选出这个所选中的选项。或者使用位于层级树面板左上角的各种按钮，又或者通过点击操作打开内容目录来进行操作。</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161304494.png"></p>
<h4 id="3-检测器"><a href="#3-检测器" class="headerlink" title="3.检测器"></a>3.检测器</h4><blockquote>
<p>检查器面板会显示当前选定对象的属性值。</p>
<p>根据选择的不同，会现实不同的检查器面板。目前有</p>
<ul>
<li><strong>实体&#x2F;组件检查器</strong></li>
<li><strong>纹理检查器</strong></li>
<li><strong>材质检查器</strong></li>
<li><strong>Cubemap检查器</strong></li>
</ul>
<p>修改这些数值用以特制化实体的行为。譬如可以设置 Model 组件所渲染的模型，或灯光的颜色等灯。</p>
<p>有些参数是简单的文字或数值，通过标准的文字框和滑动条来进行修改。有些值需要特殊的编辑方式，譬如从资源面板中选取一个高亮的资源之类（选取纹理等）。有些值可以通过视口进行可视化编辑，譬如可以直接在视口中用Gizmo平移旋转缩放一个实体的变换属性.</p>
<p>在应用和编辑器同时运行的情况下，对实体属性的修改将会传递到运行中的应用中。一个绝佳的迭代方式是在应用运行起来之后，并排打开编辑器和应用窗口，实时的对想要的调整的值进行修正。</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161602442.png"></p>
<h4 id="4-视口"><a href="#4-视口" class="headerlink" title="4.视口"></a>4.视口</h4><blockquote>
<p>视口展示了当前场景的可视化状态。你可以通过移动摄影机在场景中自由漫游。</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161643712.png"></p>
<blockquote>
<h2 id="摄影机"><a href="#摄影机" class="headerlink" title="摄影机"></a>摄影机</h2><p>初始情况下，编辑器会采用 <strong>透视</strong> 摄影机。这种摄影机如同电影摄影机一般漂浮在场景之中。可以使用摄影机选择菜单选择场景中的不同摄影机。 <strong>正交</strong> 摄影机包含几个确定的机位：顶视图，底视图，前视图，后视图，左视图，右视图。通过这些机位可以无透视的观察场景，特别方便用来调整场景中的实体位置之类。</p>
<p>在摄影机菜单中选择摄影机的同时，场景中的摄影机实体会被显示为高亮状态。可以利用这个特性精确的设置摄影机位置。</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161804927.png"></p>
<h4 id="5-资源"><a href="#5-资源" class="headerlink" title="5.资源"></a>5.资源</h4><blockquote>
<p>资源面板管理了所有的项目中的可用资源。从这个面板可以创建，上传，删除，查看和编辑任何资源</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203161917993.png"></p>
<h3 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h3><blockquote>
<p>three.js还是比PlayCanvas活跃的，当然，如果感兴趣并且有精力的话，还是建议都了解了解</p>
<p>毕竟知识是无穷无尽的</p>
</blockquote>
<p><img src="/2022/12/03/playcanvas%E5%88%9D%E8%AF%86/image-20221203162850169.png"></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>[playcanvas-github]: 	“<a target="_blank" rel="noopener" href="https://github.com/playcanvas/engine/blob/main/README-zh.md">https://github.com/playcanvas/engine/blob/main/README-zh.md</a> “<br>[playcanvas中文]: 	“<a target="_blank" rel="noopener" href="https://developer.playcanvas.com/zh/">https://developer.playcanvas.com/zh/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/playcanvas/" rel="tag">playcanvas</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-threejs-d-5-0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/02/threejs-d-5-0/"
    >threejs-d-5.0</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/02/threejs-d-5-0/" class="article-date">
  <time datetime="2022-12-02T08:37:44.000Z" itemprop="datePublished">2022-12-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3D/">Web3D</a> / <a class="article-category-link" href="/categories/Web3D/Three-js/">Three.js</a> / <a class="article-category-link" href="/categories/Web3D/Three-js/threejs-d-5-0/">threejs-d-5.0</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="threejs-d-5-0"><a href="#threejs-d-5-0" class="headerlink" title="threejs-d-5.0"></a>threejs-d-5.0</h1><h3 id="一、置换与置换贴图"><a href="#一、置换与置换贴图" class="headerlink" title="一、置换与置换贴图"></a>一、置换与置换贴图</h3><blockquote>
<h3 id="displacementMap-Texture"><a href="#displacementMap-Texture" class="headerlink" title=".displacementMap : Texture"></a>.displacementMap : Texture</h3><p>位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象， 以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。</p>
<h3 id="displacementScale-Float"><a href="#displacementScale-Float" class="headerlink" title=".displacementScale : Float"></a>.displacementScale : Float</h3><p>位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为1。</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_height.jpg&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.BoxGeometry( 1, 1, 1,100,100,100 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p>置换效果图：</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202081128766.png"></p>
<h3 id="二、粗糙度与粗糙度贴图"><a href="#二、粗糙度与粗糙度贴图" class="headerlink" title="二、粗糙度与粗糙度贴图"></a>二、粗糙度与粗糙度贴图</h3><blockquote>
<h3 id="roughness-Float"><a href="#roughness-Float" class="headerlink" title=".roughness : Float"></a>.roughness : Float</h3><p>材质的粗糙程度。0.0表示平滑的镜面反射，1.0表示完全漫反射。默认值为1.0。如果还提供roughnessMap，则两个值相乘。</p>
<h3 id="roughnessMap-Texture"><a href="#roughnessMap-Texture" class="headerlink" title=".roughnessMap : Texture"></a>.roughnessMap : Texture</h3><p>该纹理的绿色通道用于改变材质的粗糙度。</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_height.jpg&#39;) 
const mbRoughnesstexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_roughness.jpg&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.BoxGeometry( 1, 1, 1,50,50,50 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05,
    // roughness:0,
    roughnessMap:mbRoughnesstexture

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p>粗糙度为0效果：</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202082244999.png"></p>
<p>加载粗糙度纹理：</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202082433121.png"></p>
<h3 id="三、金属度与金属贴图"><a href="#三、金属度与金属贴图" class="headerlink" title="三、金属度与金属贴图"></a>三、金属度与金属贴图</h3><blockquote>
<h3 id="metalness-Float"><a href="#metalness-Float" class="headerlink" title=".metalness : Float"></a>.metalness : Float</h3><p>材质与金属的相似度。非金属材质，如木材或石材，使用0.0，金属使用1.0，通常没有中间值。 默认值为0.0。0.0到1.0之间的值可用于生锈金属的外观。如果还提供了metalnessMap，则两个值相乘。</p>
<h3 id="metalnessMap-Texture"><a href="#metalnessMap-Texture" class="headerlink" title=".metalnessMap : Texture"></a>.metalnessMap : Texture</h3><p>该纹理的蓝色通道用于改变材质的金属度。</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_height.jpg&#39;) 
const mbRoughnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_roughness.jpg&#39;) 
const mbMetalnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_metalness.jpg&#39;) 

mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.PlaneGeometry( 1, 1,100,100 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05,
    roughness:0.2,
    roughnessMap:mbRoughnesstexture,
    metalnessMap:mbMetalnesstexture,
    metalness:0.3

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p>添加金属和金属贴图前：</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202091721564.png"></p>
<p>添加金属和金属贴图后： </p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202091744042.png"></p>
<h3 id="四、法线和法线贴图"><a href="#四、法线和法线贴图" class="headerlink" title="四、法线和法线贴图"></a>四、法线和法线贴图</h3><blockquote>
<h3 id="normalMap-Texture"><a href="#normalMap-Texture" class="headerlink" title=".normalMap : Texture"></a>.normalMap : Texture</h3><p>用于创建法线贴图的纹理。RGB值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。 In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness.</p>
<h3 id="normalMapType-Integer"><a href="#normalMapType-Integer" class="headerlink" title=".normalMapType : Integer"></a>.normalMapType : Integer</h3><p>法线贴图的类型。</p>
<p>选项为THREE.TangentSpaceNormalMap（默认）和THREE.ObjectSpaceNormalMap。</p>
<h3 id="normalScale-Vector2"><a href="#normalScale-Vector2" class="headerlink" title=".normalScale : Vector2"></a>.normalScale : Vector2</h3><p>法线贴图对材质的影响程度。典型范围是0-1。默认值是Vector2设置为（1,1）</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_height.jpg&#39;) 
const mbRoughnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_roughness.jpg&#39;) 
const mbMetalnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_metalness.jpg&#39;) 
const mbNormaltexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_normal.jpg&#39;) 

mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.PlaneGeometry( 1, 1,100,100 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05,
    roughness:0.2,
    roughnessMap:mbRoughnesstexture,
    metalnessMap:mbMetalnesstexture,
    metalness:0.3,
    normalMap:mbNormaltexture

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p>添加法线贴图后：</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202092454739.png"></p>
<p>贴图到这里就已经很逼真了，当然，不同的材质所使用的贴图也有一定的区别。</p>
<h3 id="五、纹理加载回调"><a href="#五、纹理加载回调" class="headerlink" title="五、纹理加载回调"></a>五、纹理加载回调</h3><h4 id="1-纹理回调"><a href="#1-纹理回调" class="headerlink" title="1.纹理回调"></a>1.纹理回调</h4><blockquote>
<h3 id="load-url-String-onLoad-Function-onProgress-Function-onError-Function-Texture"><a href="#load-url-String-onLoad-Function-onProgress-Function-onError-Function-Texture" class="headerlink" title=".load ( url : String, onLoad : Function, onProgress : Function, onError : Function ) : Texture"></a>.load ( url : String, onLoad : Function, onProgress : Function, onError : Function ) : Texture</h3><p>url — 文件的URL或者路径，也可以为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">Data URI</a>.<br>onLoad — 加载完成时将调用。回调参数为将要加载的texture.<br>onProgress — 将在加载过程中进行调用。参数为XMLHttpRequest实例，实例包含total和loaded字节。<br>onError — 在加载错误时被调用。</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_height.jpg&#39;) 
const mbRoughnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_roughness.jpg&#39;) 
const mbMetalnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_metalness.jpg&#39;) 
const event = &#123;&#125;;
event.onLoad = function(e)&#123;
    console.log(&#39;加载完成了&#39;)
&#125;
event.onProgress = function(e)&#123;
    console.log(e)
    console.log(&#39;正在加载&#39;)
&#125;
event.onError = function(e)&#123;
    console.log(&#39;加载错误了&#39;)
    console.log(e)
&#125;
const mbNormaltexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_normal.jpg&#39;,
event.onLoad,//加载完成调用
event.onProgress,//加载过程中调用
event.onError//加载错误调用
) 

mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.PlaneGeometry( 1, 1,100,100 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05,
    roughness:0.2,
    roughnessMap:mbRoughnesstexture,
    metalnessMap:mbMetalnesstexture,
    metalness:0.3,
    normalMap:mbNormaltexture

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p>加载中</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202101019627.png" alt="onProgress"></p>
<p>加载完成</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202101056269.png" alt="onLoad"></p>
<p>加载错误</p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202101123771.png" alt="onError"></p>
<h4 id="2-纹理加载器"><a href="#2-纹理加载器" class="headerlink" title="2.纹理加载器"></a>2.纹理加载器</h4><blockquote>
<p>其功能是处理并跟踪已加载和待处理的数据，管理我们加载的纹理</p>
</blockquote>
<pre><code class="javascript">//main.js+
const event = &#123;&#125;;
event.onLoad = function(e)&#123;
    console.log(&#39;加载完成了&#39;)
&#125;
event.onProgress = function( url,itemsLoaded,itemsTotal)&#123;
    console.log(&#39;url:&#39;+ url)//当前加载纹理路径
    console.log(&#39;itemsLoaded:&#39; + itemsLoaded )//加载当前纹理位置
    console.log(&#39;itemsTotal:&#39; + itemsTotal)//纹理总数
    console.log(&#39;加载角度:&#39; + ((itemsLoaded / itemsTotal) * 100).toFixed(2) + &#39;%&#39;)//纹理加载进度
&#125;
event.onError = function(e)&#123;
    console.log(&#39;加载错误了&#39;)
    console.log(e)
&#125;
const manager = new THREE.LoadingManager(
    event.onLoad,
    event.onProgress,
    event.onError
    );

const textureLoader = new THREE.TextureLoader(manager);//装载加载器
const mbColortexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_height.jpg&#39;) 
const mbRoughnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_roughness.jpg&#39;) 
const mbMetalnesstexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_metalness.jpg&#39;) 
const mbNormaltexture = textureLoader.load(&#39;./texture/welded_and_painted_metal_panels_26_64_normal.jpg&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.PlaneGeometry( 1, 1,100,100 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    displacementMap:mbHeighttexture,
    displacementScale:0.05,
    roughness:0.2,
    roughnessMap:mbRoughnesstexture,
    metalnessMap:mbMetalnesstexture,
    metalness:0.3,
    normalMap:mbNormaltexture

 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202102251981.png"></p>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202104213221.png"></p>
<h3 id="六、环境纹理"><a href="#六、环境纹理" class="headerlink" title="六、环境纹理"></a>六、环境纹理</h3><blockquote>
<p>创建一个由6张图片所组成的纹理对象。</p>
<p>（前后，上下，左右）也可以是 <a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%88%90%E5%83%8F">hdr</a>（一张图）</p>
</blockquote>
<pre><code class="javascript">const loader = new THREE.CubeTextureLoader();
loader.setPath( &#39;textures/cube/pisa/&#39; );

const textureCube = loader.load( [
    &#39;px.png&#39;, &#39;nx.png&#39;,
    &#39;py.png&#39;, &#39;ny.png&#39;,
    &#39;pz.png&#39;, &#39;nz.png&#39;
] );
const material = new THREE.MeshBasicMaterial( &#123; color: 0xffffff, envMap: textureCube &#125; );
scene.background = textureCube;
scene.environment = textureCube;//若该值不为null，则该纹理贴图将会被设为场景中所有物理材质的环境贴图。 然而，该属性不能够覆盖已存在的、已分配给 MeshStandardMaterial.envMap 的贴图
</code></pre>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202133340321.png"></p>
<h3 id="七、HDR"><a href="#七、HDR" class="headerlink" title="七、HDR"></a>七、HDR</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%88%90%E5%83%8F">HDR</a></p>
<p>那么我们也是要知道如何加载hdr</p>
</blockquote>
<p><strong>高动态范围成像</strong>（英語：<strong>H</strong>igh <strong>D</strong>ynamic <strong>R</strong>ange Imaging，简称<strong>HDRI</strong>或<strong>HDR</strong>），在计算机图形学与电影摄影术中，是用来实现比普通数位图像技术更大曝光动态范围（即更大的明暗差别）的一组技术。高动态范围成像的目的就是要正确地表示真实世界中从太阳光直射到最暗的阴影这样大的范围亮度。</p>
<blockquote>
<h3 id="mapping-number"><a href="#mapping-number" class="headerlink" title=".mapping : number"></a>.mapping : number</h3><p>图像将如何应用到物体（对象）上。默认值是THREE.UVMapping对象类型， 即UV坐标将被用于纹理映射。</p>
<p>EquirectangularReflectionMapping 和 EquirectangularRefractionMapping 用于等距圆柱投影的环境贴图，也被叫做经纬线映射贴图。等距圆柱投影贴图表示沿着其水平中线360°的视角，以及沿着其垂直轴向180°的视角。贴图顶部和底部的边缘分别对应于它所映射的球体的北极和南极。</p>
</blockquote>
<pre><code class="javascript">//main.js+
import &#123; RGBELoader &#125; from &#39;three/examples/jsm/loaders/RGBELoader&#39;
const rgbeLoader = new RGBELoader();
rgbeLoader.loadAsync(&#39;./texture/ruin1.hdr&#39;).then((texture)=&gt;&#123;
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.background = texture;
    scene.environment = texture;
&#125;)
const geometry = new THREE.SphereGeometry( 15, 100, 50 );
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    metalness:0.5,
    roughness:0.05
 &#125; );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
</code></pre>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202141946012.png"></p>
<h3 id="八、灯光与阴影"><a href="#八、灯光与阴影" class="headerlink" title="八、灯光与阴影"></a>八、灯光与阴影</h3><blockquote>
<p>阴影需要满足的条件</p>
<p>1.材质应满足对灯光有反应（环境光由于是四面八方的光，所以不具备阴影的条件）</p>
<p>2.渲染器开启阴影计算：renderer.shadowMap.enabled &#x3D; true</p>
<p>3.光照投射阴影：light.castShadow &#x3D; true</p>
<p>4.物体投射阴影：cube.castShadow &#x3D; true（投影主体）</p>
<p>5.物体接收投射阴影：plane.receiveShadow &#x3D; true（接收主体）</p>
</blockquote>
<pre><code class="javascript">//main.js
import * as THREE from &#39;three&#39;
import &#123; OrbitControls &#125; from &#39;three/examples/jsm/controls/OrbitControls&#39; 
import dat from &#39;dat.gui&#39;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;//渲染器开启阴影计算
document.body.appendChild( renderer.domElement );

const axesHelper = new THREE.AxesHelper( 30 );//轴的线段长度. 默认为 1.
scene.add( axesHelper );//添加到场景


const geometry = new THREE.SphereGeometry( 15, 100, 50 );
const material = new THREE.MeshStandardMaterial();
const cube = new THREE.Mesh( geometry, material );
cube.castShadow = true;//物体投射阴影
scene.add( cube );

const geometryP = new THREE.PlaneGeometry( 100,100 );
const materialP = new THREE.MeshStandardMaterial();
const plane = new THREE.Mesh( geometryP, materialP );
plane.rotation.x = -Math.PI / 2
plane.position.set(0,-15,0)
plane.receiveShadow = true//物体接收投射阴影
scene.add( plane );

const light = new THREE.PointLight( 0xffffff, 1, 100 );
light.position.set( 10, 50, 10 );
light.castShadow = true;//光照投射阴影
scene.add( light ); 

const gui = new dat.GUI();
gui.add(light.position,&#39;x&#39;)
.min(0)
.max(30)
.name(&#39;移动x坐标&#39;)
.step(0.1)
gui.add(light.position,&#39;y&#39;)
.min(0)
.max(30)
.name(&#39;移动y坐标&#39;)
.step(0.1)
gui.add(light.position,&#39;z&#39;)
.min(0)
.max(30)
.name(&#39;移动z坐标&#39;)
.step(0.1)
const controls = new OrbitControls( camera,renderer.domElement  );
camera.position.set(0,20,100);
controls.update();
function animate() &#123;
    requestAnimationFrame( animate );
    controls.update();
    renderer.render( scene, camera );
&#125;
animate();

window.addEventListener(&#39;resize&#39;,()=&gt;&#123;
    // console.log(&#39;屏幕变化了&#39;)
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
&#125;)
</code></pre>
<p><img src="/2022/12/02/threejs-d-5-0/image-20221202151934429.png"></p>
<p>总结：</p>
<p>我们还有一些灯光，例如点光源和聚光灯，它们的属性我们就不一一来讲了，相信我们到了这，文档已经可以比较熟悉的查阅了。加油！！！</p>
<p>参考文档：</p>
<p>[HDR讲解]: 	“<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%88%90%E5%83%8F&quot;">https://zh.m.wikipedia.org/zh/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%88%90%E5%83%8F&quot;</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threejs/" rel="tag">threejs</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-threejs-d-4-0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/01/threejs-d-4-0/"
    >threejs-d-4.0</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/01/threejs-d-4-0/" class="article-date">
  <time datetime="2022-12-01T09:59:41.000Z" itemprop="datePublished">2022-12-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3D/">Web3D</a> / <a class="article-category-link" href="/categories/Web3D/Three-js/">Three.js</a> / <a class="article-category-link" href="/categories/Web3D/Three-js/threejs-d-4-0/">threejs-d-4.0</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="threejs-d-4-0"><a href="#threejs-d-4-0" class="headerlink" title="threejs-d-4.0"></a>threejs-d-4.0</h1><h3 id="一、基础网格材质"><a href="#一、基础网格材质" class="headerlink" title="一、基础网格材质"></a>一、基础网格材质</h3><blockquote>
<p>一个以简单着色（平面或线框）方式来绘制几何体的材质。</p>
<p>这种材质不受光照的影响。</p>
</blockquote>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();//初始化一个加载器
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) //加载一张纹理贴图

const geometry = new THREE.BoxGeometry( 1, 1, 1 );//创建一个立方体
const material = new THREE.MeshBasicMaterial( &#123; 
    color: &#39;#ffffff&#39;,//给立方体添加颜色
    map:mbColortexture//加载贴图
 &#125; );
const cube = new THREE.Mesh( geometry, material );
console.log(cube)
</code></pre>
<pre><code class="css">.alphaMap : Texture 
#alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。

仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道， 因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 Luminance-only以及luminance/alpha纹理也仍然有效。

.aoMap : Texture
该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。

.aoMapIntensity : Float
环境遮挡效果的强度。默认值为1。零是不遮挡效果。

.color : Color
材质的颜色(Color)，默认值为白色 (0xffffff)。

.combine : Integer
如何将表面颜色的结果与环境贴图（如果有）结合起来。

选项为THREE.MultiplyOperation（默认值），THREE.MixOperation， THREE.AddOperation。如果选择多个，则使用.reflectivity在两种颜色之间进行混合。

.envMap : Texture
环境贴图。默认值为null。

.fog : Boolean
材质是否受雾影响。默认为true。

.lightMap : Texture
光照贴图。默认值为null。lightMap需要第二组UV。

.lightMapIntensity : Float
烘焙光的强度。默认值为1。

.map : Texture
颜色贴图。可以选择包括一个alpha通道，通常与.transparent 或.alphaTest。默认为null。

.reflectivity : Float
环境贴图对表面的影响程度; 见.combine。默认值为1，有效范围介于0（无反射）和1（完全反射）之间。

.refractionRatio : Float
空气的折射率（IOR）（约为1）除以材质的折射率。它与环境映射模式THREE.CubeRefractionMapping 和THREE.EquirectangularRefractionMapping一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过1。默认值为0.98。

.specularMap : Texture
材质使用的高光贴图。默认值为null。

.wireframe : Boolean
将几何体渲染为线框。默认值为false（即渲染为平面多边形）。

.wireframeLinecap : String
定义线两端的外观。可选值为 &#39;butt&#39;，&#39;round&#39; 和 &#39;square&#39;。默认为&#39;round&#39;。

该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。

.wireframeLinejoin : String
定义线连接节点的样式。可选值为 &#39;round&#39;, &#39;bevel&#39; 和 &#39;miter&#39;。默认值为 &#39;round&#39;。

该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。

.wireframeLinewidth : Float
控制线框宽度。默认值为1。
</code></pre>
<p>效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201090956497.png"></p>
<h3 id="二、纹理常用属性"><a href="#二、纹理常用属性" class="headerlink" title="二、纹理常用属性"></a>二、纹理常用属性</h3><pre><code class="javascript">const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) 
console.log(mbColortexture)
</code></pre>
<blockquote>
<p>我们可以看到mbColortexture的属性</p>
</blockquote>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201091841323.png"></p>
<h4 id="1-纹理偏移"><a href="#1-纹理偏移" class="headerlink" title="1.纹理偏移"></a>1.纹理偏移</h4><pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) 
mbColortexture.offset.set(0.2,0.2)//默认是x,y,范围是0.0 to 1.0
</code></pre>
<p>效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201092855963.png"></p>
<h4 id="2-纹理旋转"><a href="#2-纹理旋转" class="headerlink" title="2.纹理旋转"></a>2.纹理旋转</h4><pre><code class="javascript">const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) 
mbColortexture.center.set(0.5,0.5)//设置中心点，(0.5, 0.5)对应纹理的正中心。默认值为(0,0)，即左下角
mbColortexture.rotation = Math.PI / 4 //纹理将围绕中心点旋转多少度，单位为弧度（rad）。正值为逆时针方向旋转，默认值为0。
</code></pre>
<p>效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201093713067.png"></p>
<h4 id="3-纹理重复"><a href="#3-纹理重复" class="headerlink" title="3.纹理重复"></a>3.纹理重复</h4><blockquote>
<p>当我们旋转或者改变了uv属性，那么可能就出现了上面那种情况，是因为</p>
<p>.wrapS : number</p>
<p>这个值定义了纹理贴图在水平方向上将如何包裹，在UV映射中对应于<strong>U</strong>。<br>默认值是THREE.ClampToEdgeWrapping，即纹理边缘将被推到外部边缘的纹素。</p>
</blockquote>
<p>我们需要修改属性，使其达到合适的uv</p>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping//使用RepeatWrapping，纹理将简单地重复到无穷大。
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
mbColortexture.rotation = Math.PI / 4

//使用MirroredRepeatWrapping， 纹理将重复到无穷大，在每次重复时将进行镜像。
</code></pre>
<p>wrapS和wrapT可以设置相同的属性</p>
<p>.wrapS : number</p>
<p>这个值定义了纹理贴图在水平方向上将如何包裹，在UV映射中对应于<strong>U</strong>。<br>默认值是THREE.ClampToEdgeWrapping，即纹理边缘将被推到外部边缘的纹素。 其它的两个选项分别是THREE.RepeatWrapping和THREE.MirroredRepeatWrapping。 请参阅texture constants来了解详细信息。</p>
<p>.wrapT : number</p>
<p>这个值定义了纹理贴图在垂直方向上将如何包裹，在UV映射中对应于<strong>V</strong>。<br>可以使用与 .wrapS : number相同的选项。</p>
<p>请注意：纹理中图像的平铺，仅有当图像大小（以像素为单位）为2的幂（2、4、8、16、32、64、128、256、512、1024、2048、……）时才起作用。 宽度、高度无需相等，但每个维度的长度必须都是2的幂。 这是WebGL中的限制，不是由three.js所限制的。</p>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/mb.png&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.repeat.set(1,1)//设置重复的次数
mbColortexture.center.set(0.5,0.5)
</code></pre>
<h3 id="三、纹理算法显示"><a href="#三、纹理算法显示" class="headerlink" title="三、纹理算法显示"></a>三、纹理算法显示</h3><blockquote>
<p>这里主要是两个属性.magFilter和.minFilter</p>
</blockquote>
<h4 id="magFilter-number"><a href="#magFilter-number" class="headerlink" title=".magFilter : number"></a>.magFilter : number</h4><p>当一个纹素覆盖大于一个像素时，贴图将如何采样。默认值为THREE.LinearFilter， 它将获取四个最接近的纹素，并在他们之间进行双线性插值。 另一个选项是THREE.NearestFilter，它将使用最接近的纹素的值。<br>请参阅texture constants页面来了解详细信息。</p>
<h4 id="minFilter-number"><a href="#minFilter-number" class="headerlink" title=".minFilter : number"></a>.minFilter : number</h4><p>当一个纹素覆盖小于一个像素时，贴图将如何采样。默认值为THREE.LinearMipmapLinearFilter， 它将使用mipmapping以及三次线性滤镜。</p>
<p>magFilter为THREE.NearestFilter效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201100523546.png"></p>
<p>magFilter为THREE.LinearFilter时效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201100924472.png"></p>
<p>.minFilter 的一些属性值</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201102245156.png"></p>
<h3 id="四、透明材质和纹理"><a href="#四、透明材质和纹理" class="headerlink" title="四、透明材质和纹理"></a>四、透明材质和纹理</h3><blockquote>
<p>alphaMap和opacity</p>
</blockquote>
<pre><code class="javascript">//main.js
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/AHS_AlphaPack_V3_ (1).png&#39;) //加载颜色贴图
const mbAlphatexture = textureLoader.load(&#39;./texture/AHS_AlphaPack_V3_ (1).jpg&#39;) //加载Alpha贴图
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    alphaMap:mbAlphatexture,//alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。
    transparent:true //定义此材质是否透明。这对渲染有影响，因为透明对象需要特殊处 理，并在非透明对象之后渲染。设置为true时，通过设置材质的opacity属性来控制材质透明的程度。默认值为false。
    opacity:0.5 //设置材质的opacity属性来控制材质透明的程度
 &#125; );
const cube = new THREE.Mesh( geometry, material ); 
scene.add( cube );
</code></pre>
<p>透明纹理效果展示：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201105806475.png"></p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201110104958.png"></p>
<h3 id="五、环境遮挡贴图与强度"><a href="#五、环境遮挡贴图与强度" class="headerlink" title="五、环境遮挡贴图与强度"></a>五、环境遮挡贴图与强度</h3><blockquote>
<h3 id="aoMap-Texture"><a href="#aoMap-Texture" class="headerlink" title=".aoMap : Texture"></a>.aoMap : Texture</h3><p>该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。</p>
<h3 id="aoMapIntensity-Float"><a href="#aoMapIntensity-Float" class="headerlink" title=".aoMapIntensity : Float"></a>.aoMapIntensity : Float</h3><p> 环境遮挡效果的强度。默认值为1。零是不遮挡效果。</p>
</blockquote>
<pre><code class="javascript">const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_height.jpg&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    aoMap:mbHeighttexture,
    aoMapIntensity:1//范围 0-1
 &#125; );
const cube = new THREE.Mesh( geometry, material );
console.log(cube)
</code></pre>
<p>添加环境遮挡贴图前：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201111821273.png"></p>
<p>添加环境遮挡贴图后：</p>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201111921492.png"></p>
<h3 id="六、PBR"><a href="#六、PBR" class="headerlink" title="六、PBR"></a>六、PBR</h3><p>PBR是Physically-Based Rendering（基于物理的渲染)的简称，这个词的字面意思并不容易弄懂，到底什么是PBR呢？</p>
<p>让PBR材质流区别与其他手法的重要一点是光对表面造成的细腻效果，它有着更为准确的模拟，而且同时不失一定的艺术感。让我们从最基础的概念说起：</p>
<h4 id="1-漫射与反射"><a href="#1-漫射与反射" class="headerlink" title="1.漫射与反射"></a>1.漫射与反射</h4><p>这是两个材质制作里最基本的概念，是光与表面最基础的相互作用，很多人都知道这一点，但不一定知道在物理层面上到底是什么。</p>
<p>当一束光照射到一个表面，有些光会被反射，即从物体表面沿着法线反方向弹射回去。这一过程和一个球打在了墙上或地上反弹回去差不多。在一个光滑的表面上，这会产生一种镜面效果。</p>
<p>也不是所有的光都被物体表面反弹回去，有些会被物体表面吸收，或者散射进了物体内部，有些散射进去的光又会从后面再次穿出去，再次被眼睛或相机捕捉到。</p>
<p><img src="/2022/12/01/threejs-d-4-0/efab4-6369032157239337638822742.png"></p>
<p>- </p>
<p>光的这种被物体表面吸收和散射因光的不同波长而不同，也即颜色的不同而不同。由于这种散射极为不规则，所以看起来给人感觉是来自各个方向。这和镜面效果很不同！要在材质里模拟这种效果，可以通过定义一个漫射颜色来做到。</p>
<h4 id="2-半透与透明"><a href="#2-半透与透明" class="headerlink" title="2.半透与透明"></a>2.半透与透明</h4><p>但有些漫射很复杂，比如皮肤和蜡烛的表面，简单的定义一个漫射颜色是不够的，还需要考虑材质的厚度和形状。如果物体本身很薄，那么就应该能看到透明效果。这时就需要特殊材质才能模拟了。</p>
<p>能量守恒（一）<br>通过以上对反射和漫射的描述，我们不难得出一个结论：漫射和反射是互斥的。为了能看到漫射颜色，光必须先穿过表面，或者说没能被表面反射回去。那么根据能量守恒法则，就出现这样的情况：越是反射强烈的表面，其漫射越是弱（暗），因为没有那么多的光穿过去，大部分都被反射回去了。一个表面很明亮的物体它不可能有很强的反射。</p>
<p><img src="/2022/12/01/threejs-d-4-0/bf8d3-6369032158373459631393348.png"></p>
<p>- </p>
<p>能量守恒是PBR材质流的基础，要做出自然逼真的材质来，不可以无视这个规则。</p>
<h4 id="3-金属"><a href="#3-金属" class="headerlink" title="3.金属"></a>3.金属</h4><p>导电体，比如金属材质要特别单独拿出来讲一下。因为：<br>首先，它们比绝缘体的表面更加具有反射效果，它们的反射率高达60-90%，而绝缘体只有0-20%。高反射率让光无法穿过表面进入物体内部，从而产生了闪光的质感。</p>
<p>其次，金属的反射效果还会随着光谱而不同，这就是说，金属的反射是带有颜色的，而且很不均匀，比如金，铜等。而绝缘体的反射是无色的。</p>
<p>最后，穿过导电体表面的光最后大部分也会被吸收而不是被散射出去，这既是说，理论上导电体是没有漫射颜色的。</p>
<h4 id="4-菲涅尔"><a href="#4-菲涅尔" class="headerlink" title="4.菲涅尔"></a>4.菲涅尔</h4><p>奥古斯汀-让·菲涅尔，这个人的名字是绝对不可能被遗忘的，因为他的名字和反射现象结合到了一起去，不说他的名字谈反射几乎不可能。</p>
<p>在CG里，菲涅尔代表了反射效果因观察角度的不同而不同，也即是物体边缘的反射效果会更加明亮。PBR材质流在这个效果上有几个特色：</p>
<p>首先，对于所有的材质来说，反射效果在接近0度角时最明显，就像镜面反射一样，不管是什么材质都是如此。只要足够光滑能产生反射，那么一定能在某一个角度观察时，看到完美的镜面反射效果！这听起来有点玄乎，但这就是物理。</p>
<p>其次，这种反射效果的变化随着材质的不同而有所不同，如下图：</p>
<p><img src="/2022/12/01/threejs-d-4-0/27de3-6369032159485741581962421.png"></p>
<p>- </p>
<p>- </p>
<p>- </p>
<p>这个图的意思是在说：在模拟真实材质时，反射效果必须要稍微有些收敛，至少要在需要弱的地方弱下来。这并不难做到，而且现在的材质系统都能自带这种菲尼尔效果了。PBR材质流是可以带出些艺术处理的，在做出基础反射效果后，你可以再添加一些完全反射的小局部做点缀。</p>
<h4 id="5-微表面"><a href="#5-微表面" class="headerlink" title="5.微表面"></a>5.微表面</h4><p>上面都是基于物体表面说的东西，或者说是物体能被渲染出来的效果。但物体表面并非完美无瑕，小凹痕，裂纹，凹凸，这些无法被眼睛看到，也无法在法线贴图里被体现出来的微小细节，确实左右漫射和反射效果的真正因素。</p>
<p><img src="/2022/12/01/threejs-d-4-0/923ff-6369032160821103922455437.png"></p>
<p>- </p>
<p>- </p>
<p>- </p>
<p>上图中，平行照射到物体表面的三道光线被反射到不同的方向上去了，因为它们所照到的物体表面具有不同的方向，使得这种反射的角度变得不可预测，这就产生了模糊反射效果。</p>
<p>但要从物理级别上模拟出这种无规则的反射需要大量的内存和计算量，在CG里只能大概模拟一个整体效果，我们一般叫反射光泽度或反射模糊度。</p>
<p>这是材质制作里一个重要的部分，因为真实世界里到处充满了这种模糊反射效果。</p>
<p>能量守恒（二）<br>现在渲染器都有了这种虚拟的模糊反射的模拟，正确的参数能让效果更加逼真，比如粗糙的表面会产生更大更柔和的高光区，请看下图：</p>
<p><img src="/2022/12/01/threejs-d-4-0/70f54-6369032161855385747450216.png" alt="05.png"></p>
<p>- </p>
<p>- </p>
<p>- </p>
<p>图中的小球具有相同的反射强度，但因为不同的反射模糊度而表现出不同的质感，高光随着光滑度越来越清晰明亮。这又是能量守恒的法则体现之一。</p>
<p>微表面反射也同样遵守菲涅尔效果</p>
<p><img src="/2022/12/01/threejs-d-4-0/4232b-6369032162994187744034914.png"></p>
<p>- </p>
<p>- </p>
<p>- </p>
<p>PBR材质似乎在一夜之间改变了人们对于引擎实时渲染画面的理解。在游戏中我们也能够体验到锈蚀的金属，厚重的皮革，精细的纹理，更加真实的世界从此展现在眼前。从此，PBR材质成为了“次时代”游戏必备的标准。</p>
<h3 id="七、标准网格材质"><a href="#七、标准网格材质" class="headerlink" title="七、标准网格材质"></a>七、标准网格材质</h3><blockquote>
<p>一种基于物理的标准材质</p>
<p>基于物理的渲染（PBR）这种方法与旧方法的不同之处在于，不使用近似值来表示光与表面的相互作用，而是使用物理上正确的模型。 我们的想法是，不是在特定照明下调整材质以使其看起来很好，而是可以创建一种材质，能够“正确”地应对所有光照场景。</p>
</blockquote>
<p>我们PBR材质是和光相辅相成的</p>
<h4 id="1-PointLight-color-Integer-intensity-Float-distance-Number-decay-Float"><a href="#1-PointLight-color-Integer-intensity-Float-distance-Number-decay-Float" class="headerlink" title="1.PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )"></a>1.PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )</h4><p>color - (可选参数)) 十六进制光照颜色。 缺省值 0xffffff (白色)。<br>intensity - (可选参数) 光照强度。 缺省值 1。<br>distance - 这个距离表示从光源到光照强度为0的位置。 当设置为0时，光永远不会消失(距离无穷大)。缺省值 0.<br>decay - 沿着光照距离的衰退量。缺省值 2</p>
<h4 id="2-AmbientLight-color-Integer-intensity-Float"><a href="#2-AmbientLight-color-Integer-intensity-Float" class="headerlink" title="2.AmbientLight( color : Integer, intensity : Float )"></a>2.AmbientLight( color : Integer, intensity : Float )</h4><p>color - (参数可选）颜色的rgb数值。缺省值为 0xffffff。<br>intensity - (参数可选)光照的强度。缺省值为 1。</p>
<pre><code class="javascript">//main.js+
const textureLoader = new THREE.TextureLoader();
const mbColortexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_diffuse.jpg&#39;) 
const mbHeighttexture = textureLoader.load(&#39;./texture/road_with_tram_rails_24_71_height.jpg&#39;) 
mbColortexture.wrapS = THREE.RepeatWrapping
mbColortexture.wrapT = THREE.RepeatWrapping
mbColortexture.center.set(0.5,0.5)
// mbColortexture.rotation = Math.PI / 4
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
//和基础网格材质一样具备相同属性
const material = new THREE.MeshStandardMaterial( &#123; 
    color: &#39;#ffffff&#39;,
    map:mbColortexture,
    aoMap:mbHeighttexture,
    aoMapIntensity:1
 &#125; );
const cube = new THREE.Mesh( geometry, material );
console.log(cube)
scene.add( cube );

// const light = new THREE.AmbientLight( 0xffffff); // 环境光，相当于各个方向射过来的光（没有投影）
// scene.add( light );

const light = new THREE.PointLight( 0xffffff, 5, 100 );//点光源，相当于灯泡，相对灯光的物体背面是没光的
light.position.set( 10, 10, 10 );
scene.add( light );
</code></pre>
<p><img src="/2022/12/01/threejs-d-4-0/image-20221201154732277.png"></p>
<p>参考链接：</p>
<p>[什么是PBR]: 	“<a target="_blank" rel="noopener" href="https://tao0.date/2021/06/shenmeshipbrcaizhi/">https://tao0.date/2021/06/shenmeshipbrcaizhi/</a> “</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/threejs/" rel="tag">threejs</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> alan_mf
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="艺术码畜"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.zcool.com.cn/u/21686563">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player">播放器</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/zfb.jpeg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wx.jpeg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>